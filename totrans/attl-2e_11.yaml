- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INTERNATIONALIZATION
  prefs: []
  type: TYPE_NORMAL
- en: '*Like all great travelers I have seen more than I remember, and remember more
    than I have seen.'
  prefs: []
  type: TYPE_NORMAL
- en: —Benjamin Disraeli, Vivian Grey*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to making software available in other languages, native English
    speakers are a little arrogant—but who can blame us? We’ve been taught almost
    from childhood, through every experience we’ve had in this industry, that English
    is the only important language—so much so that we don’t even think about it anymore.
    All computer science–oriented research and academic discussions in communities
    of any consequence are in English. Even our programming languages have English
    keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Some might counter that this is because most programming languages are invented
    by English speakers. Not even close! Take for instance Niklaus Wirth of Switzerland,
    a native German speaker, who invented or had a hand in the invention of several
    important programming languages, including Euler, Pascal, and Modula. Not popular
    enough for you? Bjarne Stroustrup, Danish by birth, invented C++. Guido van Rossum,
    born and raised in the Netherlands, invented Python. Rasmus Lerdorf, who was born
    in Denmark and later moved to Canada, wrote PHP. Ruby was written by Yukihiro
    Matsumoto in Japan.
  prefs: []
  type: TYPE_NORMAL
- en: My point is, it never occurs to developers—even non-native English speakers—to
    invent programming languages that use, for example, German keywords. Why not?
    Probably because no one would use them if they did—not even Germans. New programming
    languages are often conceived in academic or corporate research environments,
    and the industry journals, forums, and standardization organizations that facilitate
    the discussion of the pros and cons of these inventions are written or managed
    almost exclusively in English—for pragmatic reasons, of course. No one is really
    saying that English is the best language. Rather, we need a common medium in which
    to publish, and English, being one of the most widely spoken languages on Earth,
    just sort of fell into that role.
  prefs: []
  type: TYPE_NORMAL
- en: What we miss because of this English-only attitude is that there are entire
    communities of non-English-speaking software users out there who struggle to understand
    applications written entirely in English. It’s as uncomfortable for them to use
    these applications as it is for English-only speakers to look at a web page in
    Chinese or Russian.
  prefs: []
  type: TYPE_NORMAL
- en: Larger companies often provide language packs to allow these communities to
    use software offerings in their native languages. Some of these commercial native-language
    offerings are extensive, providing support even for the more difficult Arabic
    and Asian languages.^([1](footnote.xhtml#ch11fn1)) However, most smaller commercial
    and open source software package authors don’t even try because, they say, it’s
    too expensive, too difficult, or just not important enough to their communities
    or markets. The first of these arguments *may* have some merit in the corporate
    world. Let’s talk about our options for solving these problems and, hence, for
    expanding our communities.
  prefs: []
  type: TYPE_NORMAL
- en: Obligatory Disclaimer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I dive into this topic, I’ll state up front that multivolume works could
    (and should) be written on software internationalization and localization. The
    topic is simply huge. I will not even come close to covering everything in a couple
    of chapters. My goal here is to give an introduction to a topic that may seem
    daunting from the outside. If you’re already familiar with these concepts, you’ll
    probably be disgusted by the amount of material I don’t cover. Please understand
    that these chapters are not for you, although you may find some ideas of value
    in them. Rather, these chapters are for the beginner with little experience in
    this area.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll cover what’s in the C standard and what works with the
    UTF-8 codeset, and I’ll go a bit beyond. I’ll also cover major portions of the
    *GNU gettext* library because integration of *gettext* into Autotools projects
    is, in fact, the point of this chapter, but I won’t cover third-party libraries
    and solutions, though I do mention them where appropriate. Neither will I cover
    wide-character string manipulation and multibyte-to-wide-character (and vice versa)
    transformations; there are plenty of resources out there that cover these topics
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: I just stated that I’ll cover *major portions* of *gettext*, meaning that there
    are parts I’ll leave out because they’re used only under special conditions. Once
    you have the basics down, you can easily pick up the rest, as needed, from the
    manual.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the manual, like many software manuals, the *gettext* manual is
    more a reference than a tutorial for beginners. You may have tried to read the
    *gettext* manual, intending to become familiar with internationalization and localization
    though this channel, and walked away thinking, “Either this is a terrible manual
    or I’m just way out of my depth here.” I know I did at one point. If so, you’d
    be somewhat correct on both counts. First, it’s pretty apparent that the manual
    was written by non-English speakers. Is that such a surprise? We’ve already decided
    that native English speakers don’t really care that much, in general, about this
    topic. Some of the idioms used in the manual are simply not familiar to English
    speakers, and some of the phraseology is clearly foreign. But, provenance aside,
    the manual is also not organized in a manner helpful to someone trying to become
    familiar with the topic. As I was doing research for this chapter, I found several
    online tutorials that would be much more helpful than the manual for programmers
    just trying to figure out where to start.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s begin by first covering some definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization (I18n)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Internationalization*, sometimes referred to as *i18n* in the literature because
    it’s easier to write,^([2](footnote.xhtml#ch11fn2)) is the process of preparing
    a software package to be published in other languages or for other cultures. This
    preparation includes writing (or refactoring) the software in such a way as to
    be easily configured to display human-readable text in other languages, or according
    to other cultural customs and standards. The text I’m referring to here includes
    strings, numbers, dates and times, currency values, postal addresses, salutations
    and greetings, paper sizes, measurements, and any other aspect of human communications
    you can think of that may be done differently in different languages and cultures.'
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization is specifically *not* about converting embedded text from
    one language to another. Rather, it’s about preparing your software so that static
    and generated text can easily be displayed in a target language or in formats
    that conform to target cultural norms. People of British culture, for instance,
    expect to see dates, decimal numbers, and local currency displayed differently
    than do Americans, even though both speak English natively. So internationalization
    encompasses not only language support but also general culture support.
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, this preparation is not about building a version of your software
    specifically for Spanish speakers, for example. That topic is reserved for [Chapter
    12](ch12.xhtml), where I’ll discuss the concept of *localization*. Rather, internationalization
    is about designing or modifying your software such that it *can* be easily used
    by Spanish speakers. This means first locating and tagging the strings in your
    software that should be translated and finding the places in your code where times
    and dates, currency, numbers, and other locale-specific content is formatted for
    display. Then you need to make those bits of static text and text-generation code
    configurable based on a global or specified locale. Of course, it also means configuring
    your software to be aware of the current system locale and switch into it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two areas of software internationalization that are different enough
    that we should discuss them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic, runtime-generated text messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static text messages that are hardcoded into your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s cover generated messages first, since we often get some help in this area
    from programming language standard libraries. Most such libraries provide some
    form of support for locale management, and C is no exception. C++ provides the
    same sort of functionality in an object-oriented manner.^([3](footnote.xhtml#ch11fn3))
    Once you understand what’s available in C, the C++ version is pretty easy to pick
    up on your own, so we’ll cover the functionality provided by the C standard library
    here.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll also introduce you to the extended interfaces provided by the POSIX 2008
    and X/Open standards because, as we’ll see, the functionality provided by the
    standard C library, while usable, is a bit weak, and the POSIX and X/Open standard
    functionality is pretty widely available. Finally, GNU extensions to the C standard
    can make your application shine in other cultures, as long as you’re willing to
    break away from the standards a bit.
  prefs: []
  type: TYPE_NORMAL
- en: '*Instrumenting Source Code for Dynamic Messages*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The standard C library offers the `setlocale` and `localeconv` functions exposed
    by the *locale.h* header file, as shown in the synopsis in [Listing 11-1](ch11.xhtml#ch11ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: A synopsis of the standard C library `setlocale` and `localeconv`
    functions*'
  prefs: []
  type: TYPE_NORMAL
- en: The task of `setlocale` is to tell the standard C library which locale to use
    for a given class of library functionality. This function accepts a *`category`*—an
    enumeration value representing a segment of locale-specific functionality in the
    library that should be changed from the current locale to a new target *`locale`*.
    The available standard category enumeration values are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_ALL`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`LC_ALL` represents all categories. Changing the value of this category sets
    all of the available categories to the specified locale. This is the most common
    and recommended value to use, unless you have a very specific reason for not setting
    all categories to the same locale.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_COLLATE`**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `LC_COLLATE` affects the way collation functions like `strcoll` and
    `strxfrm` work. Different languages and cultures collate and sort based on different
    character- or glyph-ordering rules. Setting the collation locale changes the rules
    used by the library’s text collation functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_CTYPE`**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `LC_CTYPE` affects the way the character attribute functions defined
    in *ctype.h* operate (except for `isdigit` and `isxdigit`). It also affects the
    multibyte and wide-character versions of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_MONETARY`**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `LC_MONETARY` affects the monetary-formatting information returned
    by `localeconv` (which we’ll discuss later in this section), as well as the resulting
    strings returned by the X/Open standard and POSIX extension `strfmon`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_NUMERIC`**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `LC_NUMERIC` affects the decimal point character in formatted input
    and output operations performed by functions like `printf` and `scanf` and the
    values related to decimal formatting returned by `localeconv`, as well as the
    resulting strings returned by the X/Open standard and POSIX extension `strfmon`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_TIME`**'
  prefs: []
  type: TYPE_NORMAL
- en: Changing `LC_TIME` affects the way time and date strings are formatted by `strftime`.
  prefs: []
  type: TYPE_NORMAL
- en: The return value of `setlocale` is a string representing the previous locale,
    or set of locales if all categories are not set the same. If you’re only interested
    in determining the current locale, you can pass `NULL` in the *`locale`* parameter
    and `setlocale` will not change anything. If you have set any of the individual
    categories independently to different locale values, the returned string’s format,
    when passing `LC_ALL`, is implementation defined and therefore not quite as useful
    as it might otherwise be. Nevertheless, most implementations will allow you to
    pass this string back into `setlocale`, using `LC_ALL`, to reset category-specific
    locales to those of a previously retrieved state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the desired locale has been set up, `localeconv` may be called to return
    a pointer to a structure containing *some* of the attributes of the current locale.
    Why not all of them? Because the designers of this API—otherwise intelligent people—were
    on pain medication or something when they created it. Seriously, the *GNU C Library*
    manual has something to say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Together with the `setlocale` function the ISO C people invented the `localeconv`
    function. It is a masterpiece of poor design. It is expensive to use, not extensible,
    and not generally usable as it provides access to only `LC_MONETARY` and `LC_NUMERIC`
    related information. Nevertheless, if it is applicable to a given situation it
    should be used since it is very portable.^([4](footnote.xhtml#ch11fn4))
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these criticisms, I’ll add that it’s not thread safe; the contents
    of the structure are subject to modification (by another thread calling `setlocale`)
    while you’re accessing it. Nevertheless, the rules are clear about how it can
    get modified—only by calls to `setlocale` with a non-`NULL` *`locale`* parameter
    value—so it is usable, but it’s neither elegant nor complete. As the preceding
    excerpt indicates, you should try to use `localeconv` if you don’t need additional
    information for your application, because it’s part of the C standard and is,
    therefore, extremely portable.
  prefs: []
  type: TYPE_NORMAL
- en: To be completely fair, the fields in the structure returned by `localeconv`
    are those that presumably require some direct programmer intervention to use correctly,
    given the functionality provided by the C standard library. For example, the `printf`
    family of functions provides no special format specifiers for locale-specific
    number and currency values, so information related to the `LC_NUMERIC` and `LC_MONETARY`
    categories must be made available to the developer in some fashion in order to
    make proper use of these categories in a program designed to print numbers and
    currency amounts in locale-specific formats. It also means, of course, that without
    third-party libraries or extensions to the C standard, you’ll be writing some
    tedious text-formatting functions that vary their output based on the rules returned
    by `localeconv`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `LC_COLLATE`, `LC_TIME`, and `LC_CTYPE` categories all
    directly affect various existing standard library functionality, making it presumably
    unnecessary for the program author to have direct access to the locale attributes
    used by these library functions.^([5](footnote.xhtml#ch11fn5))
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting and Using Locales**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The C and C++ standards require that all implementations of the standard library
    be initialized in every process with the default “C” locale so that all programs
    not explicitly selecting a locale will act in a predictable and consistent manner.
    Therefore, the first thing you must do to internationalize your software is to
    change the locale. The easiest and most consistent way to change the locale within
    your application is to call `setlocale` with a *`category`* value of `LC_ALL`
    somewhere near the start of the program. But what string should we pass as a *`locale`*
    argument? Well, that’s the beauty of this function—you don’t need to pass any
    specific locale string at all. Passing an empty string disables the *default locale*,
    allowing the library to select the *environment locale* that’s in effect on the
    host. This allows your users to determine how your program will display times
    and dates, decimal numbers, and currency values and how collation and character
    set management will work.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.xhtml#ch11ex2) shows the code for a program that configures
    the standard C library to use the host environment locale and then displays the
    standard locale attributes available from `localeconv` to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The example programs in this chapter can be found in the online GitHub repository
    named* NSP-Autotools/gettext, *found at* [https://github.com/NSP-Autotools/gettext/](https://github.com/NSP-Autotools/gettext/).
    *The small utility programs presented in this chapter are found in the* small-utils
    *directory in that repository, and a makefile is provided that will build them
    all by default. Use a command like *`make lc`*, for instance, to build just the
    *`lc`* program presented in [Listing 11-2](ch11.xhtml#ch11ex2).*'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 11.0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2:* lc.c: *A program to display all locale attributes retrieved
    from `localeconv`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct lconv` structure contains both `char *` and `char` fields. The `char
    *` fields mostly refer to strings whose values are determined according to the
    current locale. Some of the `char` fields are intended to be taken as Boolean
    values, while the rest are designed to be read as small integer values. The code
    shown in [Listing 11-2](ch11.xhtml#ch11ex2) should indicate pretty clearly which
    are Boolean and which are small integers. The documentation for your compiler’s
    standard library should also make it clear.
  prefs: []
  type: TYPE_NORMAL
- en: The only weird ones are the `grouping` and `mon_grouping` fields, which indicate
    how digits in numbers and currency values (respectively) should be grouped, with
    groups separated by the corresponding *thousands separator* string. The `grouping`
    and `mon_grouping` fields are `char *` fields designed to be read not as strings
    but as arrays of small integers. They’re terminated with either a zero or the
    value `CHAR_MAX` (defined in *limits.h*). If they’re terminated with zero, the
    final grouping value is repeated forever; otherwise, the final grouping includes
    the remaining digits in the value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note the call to the internal `print_monetary` routine that’s wrapped
    in a check for `__USE_ISOC99` (near the bottom of the listing). The international
    forms of these currency attributes were added with the C99 standard. Everyone
    should be up to C99 by now, so this is not generally an issue. I added the conditional
    compilation check because, for this utility program, it’s possible and appropriate.
    For an application trying to use these fields, you should probably just insist
    that C99 be required to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building and executing this program from a US English Linux system generates
    the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To change the environment locale, set the `LC_ALL` environment variable to the
    name of the locale you want to use. The values you can use are the locales that
    are generated and installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also set individual locale categories using environment variables
    with the same names as the category names. For example, to change the locale to
    Spanish (in Spain), but only for the *`LC_TIME`* category, you could set the *`LC_TIME`*
    environment variable to *`es_ES.utf8`*. This works for all the standard categories
    defined earlier.^([6](footnote.xhtml#ch11fn6))*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out which locales are available, run the `locale` utility with the
    `-a` option, in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*My example console listings are performed on a Debian-based system. If you’re
    using a Fedora-based distribution, for example, you should expect to see different
    results, as Fedora has significantly different default functionality with respect
    to installed language packs and how the *`locale`* utility works. I’ll discuss
    Red Hat specifics later on in the chapter where it really matters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, a US English installation of Linux will have several locales configured
    that begin with the string `en`. I’ve generated Swedish (`sv_SE.utf8`) and Japanese
    (`ja_JP.utf8`) locales on my Debian-based system, as well, in order to show examples
    of output when the environment is configured for non-English languages and cultures.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I also use the French (*`fr_FR.utf8`*) locale later in the chapter. You may
    wish to pre-build or preinstall all of these locales using whatever mechanism
    is provided by your distribution to make it easier to follow along with my examples
    on your system. Of course, if you are not a native English speaker, you’re probably
    already using a different locale by default. In this case, you might also want
    to build or install the *`en_US.utf8`* locale—though, not surprisingly, this locale
    generally comes preinstalled even on systems not built or sold in the United States.*'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the `C`, `C.UTF-8`, and `POSIX` locales in the preceding
    list. The `C` locale, as already mentioned, is the default locale for programs
    that do not set the locale explicitly. The `POSIX` locale is currently defined
    as an alias for the `C` locale.
  prefs: []
  type: TYPE_NORMAL
- en: Generating and Installing Locales
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The process of generating and installing a locale is pretty specific to a distribution,
    but there are a few common implementations. On a Debian- or Ubuntu-based system,
    for instance, you can look at the */usr/share/i18n/SUPPORTED* file to see which
    locales can be generated and installed from sources on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are 480 locale names in this file on my Linux Mint system. The general
    format of a locale name, as defined by the X/Open standard, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are up to four parts of a locale name. The first part, *`language`*, is
    required. The remaining parts, *`territory`*, *`codeset`*, and *`modifier`*, are
    optional. For example, the locale name for US English using the UTF-8 character
    set is `en_US.utf8`. The *`language`* is represented in the form of a two-letter
    ISO 639 language code.^([7](footnote.xhtml#ch11fn7)) For instance, `en` refers
    to the English language, which could be American, Canadian, British, or some other
    dialect of English.
  prefs: []
  type: TYPE_NORMAL
- en: The *`territory`* portion indicates the location of the language and takes the
    form of a two-letter ISO 3166 country code.^([8](footnote.xhtml#ch11fn8)) For
    example, `US` is for the United States, `CA` is for Canada, and `GB` is for Great
    Britain.
  prefs: []
  type: TYPE_NORMAL
- en: The portion after the dot (`.`) indicates the *`codeset`* or character encoding,
    formatted as a standard ISO character-encoding name like UTF-8 or ISO-8859-1.^([9](footnote.xhtml#ch11fn9))
    The most common character encoding is UTF-8 (represented in the locale name as
    `utf8`) since it can represent all characters in the world. It doesn’t represent
    all of them efficiently, however; some languages don’t use `utf8` because they
    require several bytes per character in this encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The *`modifier`* portion is not often used.^([10](footnote.xhtml#ch11fn10))
    One possible use is to generate a locale that differs only in case sensitivity,
    or in some other attribute that is not a normal locale attribute. For instance,
    when setting `LC_MESSAGES=en@``boldquot`, you get an English message set that
    differs from the normal English message set only in that quoted text is bolded.
    Another historically common case is where the `en_IE@eu``ro` locale is distinguished
    only by a difference in the currency symbol used. Suffice it to say that the differences
    applied by using a locale with a particular modifier are designed for very special
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: To generate and install a particular locale on a Debian- or Ubuntu-based system,
    you can add a file to the */var/lib/locales/supported.d* directory containing
    the line from *SUPPORTED* representing the locale you want to add. The name of
    the file added to the *supported.d* directory is not particularly important, although
    I advise not using filenames that are too far from something reasonably similar
    to what you find already in this directory structure. It’s only important that
    a file exists in that directory and that it contains the exact contents of the
    desired line from *SUPPORTED*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to add `sv_SE.utf8`, I’d find the line in *SUPPORTED* that represents
    this language, add a file to *supported.d* containing this line, and then run
    the `locale-gen` program, in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each line in *SUPPORTED* contains a locale database entry name, followed by
    a codeset name. For Swedish, the entry we’re interested in is `sv_SE.UTF-8`, with
    the `UTF-8` codeset. I chose to add a file called *sv* to */var/lib /locales/supported.d*.
    You may add as many lines as you want to the file; each line will be processed
    as a separate locale. Because the files in */var/lib/locale* are owned by root,
    you’ll need to have root-level permissions to create or write to them. I used
    a common trick involving the `tee` and `echo` commands to add the line I wanted
    to *supported.d/sv* as root.^([11](footnote.xhtml#ch11fn11)) You could also just
    use a text editor started with `sudo`, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a locale on a Red Hat– or CentOS-based system, you can use the
    `localedef` utility in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` option on the `localedef` command line signifies the input file, which
    is taken from the output of the `localedef --list-archive` command. The `-f` option
    indicates the codeset to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve found that recent Red Hat (and therefore CentOS) systems generally come
    preinstalled with many locales. You may find, upon using *`locale -a`*, that you
    do not need to generate any locales. Anything that shows up in *`locale -a`* is
    immediately usable as a locale in the *`LANG`* and *`LC_*`* environment variables.
    Fedora systems, on the other hand, require the installation of language-specific
    langpacks, even if the locale shows up in the list displayed by *`locale -a`*.
    Swedish, for instance, requires the installation of glibc-langpack-sv. Additionally,
    the language sources do not seem to be installed on Fedora. Therefore, the *`localedef`*
    command will not work on that platform, but installation of the langpack will
    provide a precompiled version of the locale.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a Swedish locale available to us, let’s see what’s displayed
    when we execute the `lc` program built from the code in [Listing 11-2](ch11.xhtml#ch11ex2)
    when using that locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as I mentioned earlier, `localeconv` only returns information
    on the numeric (`LC_NUMERIC`) and monetary (`LC_MONETARY`) categories, which isn’t
    quite as bad as it sounds because the remaining ones are handled nearly automatically
    for you by the library. Regardless, there are other options for accessing the
    complete set of locale attributes, which we’ll discuss later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Time and Date for Display
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard C library quietly handles time and date behind the scenes, depending
    on which format specifiers you use in the format string passed to `strftime`.
    Here’s the prototype for `strftime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Briefly, the `strftime` function places up to *`max`* bytes in the buffer pointed
    to by *`s`*. The content is determined by the text and format specifiers in *`format`*.
    Only a single time value format can be specified in *`format`*, and its value
    is obtained from *`tm`*. Since this is a standard library function, you can refer
    to any standard C library manual for details on the way format specifiers work
    in this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-3](ch11.xhtml#ch11ex3) provides the source code for a small program
    that prints the current time and date in a general format supported in some form
    by all languages and territories.^([12](footnote.xhtml#ch11fn12))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3:* td.c: *A small program to print the calendar date and time
    in the environment locale*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building and executing this program displays something like the following output
    on the console; your times and dates will very likely not match mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I set `LC_ALL=C` on the first execution to show how you can execute your localized
    programs using the default C locale. This can be a handy debugging aid for testing
    your internationalized software.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The C locale is not the “American” locale. Rather, it’s referred to as the
    minimal locale. If you execute the *`lc`* program with *`LC_ALL=C`*, you’ll find
    that many of the options are blank. The standard library expects and handles such
    blank options in an appropriate manner.*'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the English and Swedish outputs. The day and month names are in the
    locale language. For July, the month name happens to be the same in English and
    Swedish. However, notice the case difference in both day names and month names.
    In English, the names are capitalized, while in Swedish, they are not. Another
    difference is the 12-hour AM/PM time format in English and the 24-hour time format
    in Swedish. Swedish and C omit the leading zero on the day, whereas the US locale
    does not. Finally, the US time is followed by the Greenwich mean time zone name,
    `GMT`. There is only one time zone in Sweden—Central European Time, `CET`—and
    this fact is reflected in the simplicity of Sweden’s standard general time and
    date format.
  prefs: []
  type: TYPE_NORMAL
- en: All of these differences are defined by the environment locale, but a quick
    glance at the code in [Listing 11-3](ch11.xhtml#ch11ex3) shows that I’m merely
    using the `%c` format specifier in the call to `strftime` in all cases. The effective
    locale is causing this format specifier to output general time and date information
    in a format specific to the locale.
  prefs: []
  type: TYPE_NORMAL
- en: Not all of the format specifiers accepted by `strftime` are as helpful, however.
    For example, while using a format string like `"%X %D"` may seem like a good approach,
    it will not yield correct results in all locales. The `%X` specifier formats the
    time in a locale-specific manner, but `%D` formats the date in a very US-English
    way. Additionally, full time-date strings are formatted in different locales with
    the time and date portions in different orders. Later in the chapter, I’ll show
    you how to work around these issues with `nl_langinfo`.
  prefs: []
  type: TYPE_NORMAL
- en: Collation and Character Classes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s consider the less obvious categories—those whose information is not
    returned in `struct lconv`: `LC_COLLATE` and `LC_CTYPE`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LC_COLLATE` affects the way the functions `strcoll` and `strxfrm` work. It’s
    more difficult for an English speaker to comprehend these functions’ inner workings
    because, in the English language, locale-specific comparisons of characters just
    happen to collate in the same order as their lexicographical orderings in the
    *ASCII* table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The original* American Standard Code for Information Interchange (ASCII) *was
    invented in 1963 by the* American Standards Association (ASA). *At first, it included
    only US English capital letters and numbers. In 1967, it was amended to include
    control characters and lowercase US English letters. Since the standard limited
    code length to 7 bits, it included only 128 characters, using the codes 0 through
    127\. This 7-bit limitation was imposed because the eighth bit in each byte was
    commonly used for error correction during data transmission. In 1981, IBM incorporated
    the ASCII code into the lower half of an 8-bit, 256-character code it named* code
    [page 437](ch16.xhtml#page_437) *and incorporated this code into the firmware
    of its IBM PC line of personal computers. In this chapter, when I mention the*
    ASCII table, *I’m actually referring to* code [page 437](ch16.xhtml#page_437).
    *Technically, ASCII is still limited to 128 characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: This is not the case in many other languages. For instance, in English and Spanish,
    the accented vowels sort properly immediately after their unaccented counterparts,
    while in Japanese, neither vowels nor accented vowels exist in the alphabet, so
    they sort according to their ordinal values in the ASCII table. Since all the
    accented vowels are in the upper half of the ASCII table and all non-accented
    vowels are in the lower half, it should be clear that the sort order of a list
    of Spanish words will be different when using an English or Spanish language locale
    than it will for any locales based on languages that don’t have Latin characters
    in their alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](ch11.xhtml#ch11ex4) contains a short program that uses the C
    `qsort` function to sort a list of Spanish words using different comparison routines.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4:* sc.c: *A short program that illustrates sort order differences
    between locales*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the unsorted `words` list is printed to the console; then, the pointers
    in the `words` list are sorted with `qsort` using the `compare_lex` function,
    which uses `strcmp` to determine the collation order of the letters in each pair
    of words compared. The `strcmp` function doesn’t know anything about locales.
    It simply uses the order of the words’ letters in the ASCII table. Then the sorted
    list is printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `qsort` is called once again on `words`—this time using `compare_loc`,
    which uses `strcoll` to determine the sort order of the word pairs. The `strcoll`
    function uses the current locale to determine the relative order of the letters
    in the words being compared. The re-sorted list is then printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building and executing this program with different locales displays the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: English and Spanish sort accented vowels the same way. The `C` locale, represented
    by the results obtained using `strcmp`, always sorts strictly according to the
    ASCII table. Japanese, however, sorts differently than the Latin languages because
    Japanese makes no assumptions about how characters (accented or otherwise) not
    found in its alphabet should be ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `strcoll` uses an algorithm to transform the characters in the comparison
    strings into numeric values that order naturally in the current locale; then it
    compares these byte arrays using the `strcmp` function. The algorithm used by
    `strcoll` can be pretty heavyweight because, for each set of two strings it compares,
    it transforms the locale-specific multibyte character sequences of these string
    pairs into sequences of bytes that can be compared lexicographically, by codeset
    ordinal values, and then internally compares those byte sequences using `strcmp`.
  prefs: []
  type: TYPE_NORMAL
- en: If you know you’re going to be comparing the same string or set of strings,
    it can be much more efficient to use the `strxfrm` function first, which exposes
    the transformation algorithm that `strcoll` uses internally. You can then simply
    use `strcmp` against these transformed strings to obtain the same collation you’d
    get from `strcoll` against untransformed strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](ch11.xhtml#ch11ex5) illustrates this process by converting the
    contents of [Listing 11-4](ch11.xhtml#ch11ex4) to use `strxfrm` on the words in
    the `words` array, writing the transformed words into a two-dimensional array
    large enough to hold the transformed strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5:* sx.c: *The `sc` program, rewritten to use `strxfrm`*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several items of note here. The `strxfrm` function returns a zero-terminated
    byte buffer that looks and acts like an ordinary C string. There are no internal
    null characters; it can be acted upon by other string functions in the standard
    C library, but it’s not necessarily intelligible from a human-readability standpoint.
    Because of this weird characteristic, the transform buffer contents can only be
    used for comparison purposes during sorting. The original input value must be
    used for display. Therefore, we need to keep track of, and sort as pairs, the
    input buffer and the transform buffer for each word in our list. The `element`
    structure at ➊ manages this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Since we no longer need to use `strcoll`, I’ve removed the `compare_loc` function
    and renamed `compare_lex` to `compare`, and I’ve changed the code to compare the
    `xfrmd` fields of the `element` structures passed in (at ➋). Note, however, that
    the `print_list` function still prints the `input` field of the elements (at ➌).
    This works because the `words` array has been converted to an array of pairs,
    where each element of the array contains both the original and the transformed
    words.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this code work with the original flow of `main` in *sc.c*,
    immediately after setting the locale, *sx.c* iterates over `words` (at ➍), setting
    each element’s `xfrmd` pointer to the same value as its `input` pointer. This
    allows us to see what happens when using `strcmp` on untransformed strings during
    the first call to `qsort`.
  prefs: []
  type: TYPE_NORMAL
- en: At ➎, after printing the results of that first sort operation, the program iterates
    over `words` again, this time calling `strxfrm` on each input string and pointing
    the corresponding `xfrmd` field at a `strdup` copy of the transform buffer, `buf`.^([13](footnote.xhtml#ch11fn13))
  prefs: []
  type: TYPE_NORMAL
- en: 'Building and executing the code in [Listing 11-5](ch11.xhtml#ch11ex5) should
    show us the same output we got when we ran the code from [Listing 11-4](ch11.xhtml#ch11ex4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It’s a bit more complicated—the value of this version is not immediately apparent
    when sorting five words, but the time savings over transforming the strings within
    `strcoll` is significant when sorting hundreds of strings, even with the overhead
    of allocating and freeing the transform buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This sample takes shortcuts in order to highlight the important points of
    *`strxfrm`*. A real program would check the result of *`strxfrm`*, which returns
    the number of bytes required by the transformation (minus the terminating null
    character). If the value is larger than the buffer size specified, the program
    should reallocate and call *`strxfrm`* again. There is no reasonable way to predetermine
    the required buffer size for any given locale and codeset. I made my buffer large
    enough to handle just about any possibility, so I skipped this check for the sake
    of code readability, but this is not a recommended practice.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s turn our attention to the `LC_CTYPE` locale category. Changing this
    locale category affects the way most of the character classification functions
    in *ctype.h* work, including `isalnum`, `isalpha`, `isctrl`, `isgraph`, `islower`,
    `isprint`, `ispunct`, `isspace`, and `isupper` (but specifically not `isdigit`
    or `isxdigit`). It also affects the way `toupper` and `tolower` work—sort of.
    The fact is, the functions in *ctype.h* are broken in many ways with respect to
    internationalization. The problem is they rely on algorithmic mechanisms to convert
    character case, which work fine as long as you stick with the ASCII table. As
    soon as you leave this familiar playing field, however, all bets are off. Sometimes
    they work, and sometimes they don’t. The most consistent way to make them work
    is to use wide characters, because the wide-character versions of these functions
    are newer in the C and C++ standards and the UTF-16 and UTF-32 codesets allow
    for similar algorithmic conversion for an expanded set of characters. However,
    even when wide characters are used, there are still cases where the algorithmic
    approach fails to convert properly, as some languages have digraphs that come
    in three forms: lowercase, uppercase, and title case. There’s just no algorithmic
    way to deal properly with these types of situations.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code in [Listing 11-6](ch11.xhtml#ch11ex6) shows one way to properly
    convert a Spanish word from uppercase to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6:* ct.c: *Converting a Spanish word using wide characters*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This program doesn’t work if you change to `char` buffers and use UTF-8\. It
    barely works using wide characters. If you set `LC_ALL=C`, it prints only `orig:`
    because, had we checked the return value of `printf` in [Listing 11-6](ch11.xhtml#ch11ex6)
    (as we should do—especially when dealing with character set conversions like this),
    we’d have seen it return a `-1`, which is what it returns when it fails to convert
    a wide-character string to a multibyte string using `%ls`.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than cover all the nuances of what does and doesn’t work in the `LC_CTYPE`
    category, I’ll just say that if you have to do a lot of this sort of conversion
    and character classification, I’d highly recommend using a third-party library
    like IBM’s *International Components for Unicode (ICU)*^([14](footnote.xhtml#ch11fn14))
    or GNU libunistring^([15](footnote.xhtml#ch11fn15)) (both of which, to put it
    succinctly, just do the right thing in all cases). ICU is a large library, and
    there’s a bit of a learning curve, but it’s worth the effort if you need it. GNU
    libunistring is a little easier to get your head around, but it still presents
    a lot of new functionality. There are also wrapper libraries like *Boost::locale*,^([16](footnote.xhtml#ch11fn16))
    if you’re using C++, that make accessing ICU a bit simpler, although *Boost::locale*,
    itself, is pretty complex.
  prefs: []
  type: TYPE_NORMAL
- en: X/Open and POSIX Standard Extensions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s a shame there is not a standard C library function to format numeric and
    currency amounts by locale in the same manner that `strftime` formats time and
    date by locale. There is, however, an extension provided by the X/Open and POSIX
    standards and implemented in the GNU C library—the `strfmon` function, whose prototype
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It works very much like `strftime`, placing the formatted value string in the
    *`max`*-sized buffer pointed to by *`s`*. The *`format`* string works like the
    format strings in the `printf` family of functions and like that of `strftime`.
    The format specifiers are specific to this function but, like those of the other
    functions, begin with percent sign (`%`) and end with a format character. Several
    supported modifier characters may be used between the percent and the format character.
    The two valid format characters are `i` for international and `n` for local.
  prefs: []
  type: TYPE_NORMAL
- en: This function is designed to format currency amounts and follows all the `localeconv`-provided
    `LC_CURRENCY` rules, but it can also be used to format decimal numbers according
    to `localeconv`-provided `LC_NUMERIC` rules. [Listing 11-7](ch11.xhtml#ch11ex7)
    provides example code for formatting a currency value in local and international
    formats without any special modifiers and for formatting a decimal number. Unlike
    `strftime`, `strfmon` can format multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7:* amount.c: *An example of calling `strfmon` to format currency
    and decimal values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build and execute this program to see what’s displayed when using different
    locales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All the characteristics displayed by the `lc` program in [Listing 11-2](ch11.xhtml#ch11ex2)
    for monetary and numeric categories are taken into account by `strfmon` in the
    same manner the standard `strftime` function does for time and date characteristics.
    For instance, in both English and Japanese, the currency symbols are displayed
    before the values, while the Swedish currency symbols, `kr` and `SEK`, follow
    the value. The decimal separator is a comma in Sweden (and many other European
    locales), and Japanese yen values do not display a fractional part.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation mark (`!`) modifier in the decimal format specifier is used
    to suppress display of the currency symbol. By explicitly specifying a format
    precision, we can override the default Japanese locale characteristic that indicates
    that monetary values should not have a fractional part. The `strfmon` function
    was obviously designed for formatting currency values but, as we can see here,
    it can just as well be used to format plain old numeric decimal and integer values.
  prefs: []
  type: TYPE_NORMAL
- en: Overcoming localeconv’s Shortcomings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The X/Open and POSIX standards also provide a better and more functional version
    of `localeconv` called `nl_langinfo`. Here is the prototype for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of this interface over the standard library interface are numerous.
    First, it’s more efficient, only acquiring and returning the field you request
    on an as-needed basis, rather than filling and returning the entire locale attribute
    structure for each request. The `nl_langinfo` function is used to acquire a single
    attribute, specified by *`item`*, of the global environment locale.
  prefs: []
  type: TYPE_NORMAL
- en: If your application is required to manage multiple locales simultaneously, check
    out the POSIX interface for managing multiple discrete locales within the same
    application. I won’t cover them in detail here because they manage the same set
    of locale categories as the interfaces I’ve already shown you. Instead, see the
    POSIX 2008 standard for information on the `newlocale`, `duplocale`, `uselocale`,
    and `freelocale` functions, in connection with the `nl_langinfo_l` function, which
    accepts a second argument of type `locale_t` returned by `newlocale`. I will mention
    that the `uselocale` function can be used to set the locale of the current thread.
    All of the functions I’ve mentioned so far are implemented by the GNU C library.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU C library also provides support for additional classes of locale information,
    including `LC_MESSAGES`, `LC_PAPER`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`,
    `LC_MEASUREMENT`, and `LC_IDENTIFICATION`. The `LC_MESSAGES` category has been
    standardized by POSIX and is the basis for *gettext*, which I’ll discuss shortly.
    The others are not standardized in C or POSIX, but they’ve been incorporated for
    many years into so many aspects of Linux, including Linux ports of the X Window
    System, that it’s hard to conceive of them being replaced or removed in the foreseeable
    future. Hence, I recommend their use if you do not intend to port your software
    outside of GNU tools.
  prefs: []
  type: TYPE_NORMAL
- en: These additional categories are not accessible though `localeconv` and the `struct
    lconv` structure. Rather, you’ll need to use `nl_langinfo` to access the values
    in the locale that are associated with these categories.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-8](ch11.xhtml#ch11ex8) is the same program found in [Listing 11-2](ch11.xhtml#ch11ex2),
    except that this version uses `nl_langinfo` to display the locale information
    available through that interface. It’s intentionally organized to display the
    content that’s common to both interfaces in exactly the same format.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8:* nl.c: *Using `nl_langinfo` to display available locale information*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this code, you need to add a couple of definitions to the command
    line: `_GNU_SOURCE` and `OUTER_LIMITS`. The first definition belongs to the GNU
    C library and allows *nl.c* to access the extended international monetary fields
    that were not part of the C standard until C99\. The second is my own invention
    that allows you to build the program without the extended categories provided
    by the GNU C library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted section of the preceding output shows the portion of `nl`’s
    output that goes beyond the `lc` program from [Listing 11-2](ch11.xhtml#ch11ex2).
    The additional locale categories are defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_MESSAGES`**'
  prefs: []
  type: TYPE_NORMAL
- en: This category provides one additional item value, `CODESET`, which defines the
    codeset used by this locale. This item is categorized under “Messages” because
    it’s intended to be helpful when translating static text messages in application
    code. The value can also be used as an environment variable on Linux systems in
    order to help select the static message catalog to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_PAPER`**'
  prefs: []
  type: TYPE_NORMAL
- en: The paper category provides two items, `_NL_PAPER_HEIGHT` and `_NL_PAPER_WIDTH`,
    which return paper dimensional values in millimeters for the most commonly used
    printer paper in the locale. This can be very helpful when formatting print output
    or when auto-selecting paper sizes—*letter* and *A04*, for example. Be aware that
    the pointer values returned from these item enumeration values should be treated
    like native-word-sized integer values, rather than as actual pointers. See the
    *nl.c* code in [Listing 11-8](ch11.xhtml#ch11ex8) for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_NAME`**'
  prefs: []
  type: TYPE_NORMAL
- en: The name category provides information on formatting salutations such as Mr.,
    Mrs., Miss, and Ms. in the locale. The items in this category allow your software
    to automatically select how to state such salutations in the current language
    and territory.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_ADDRESS`**'
  prefs: []
  type: TYPE_NORMAL
- en: The address category provides items that return geographical information for
    the locale, such as country name, postal code, and two- and three-letter country
    name abbreviations. It also returns the language name and library used by the
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_TELEPHONE`**'
  prefs: []
  type: TYPE_NORMAL
- en: The telephone category provides format-specifier strings usable within the *printf*
    family of functions to display telephone numbers in a style that’s common in the
    current locale.
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_MEASUREMENT`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The measurement category provides a single item for returning the system of
    measurement used in the current locale. The `_NL_MEASUREMENT_MEASUREMENT` item
    returns a string whose first character is a short integer value: `0` for Metric
    or `1` for English.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`LC_IDENTIFICATION`**'
  prefs: []
  type: TYPE_NORMAL
- en: The identification category is actually locale metadata. That is, the fields
    of this category return information about the territory, author, and process used
    to create the current locale (for example, the locale author’s name, email address,
    phone number, and so on). It also returns versioning information about the locale.
    Be aware that the pointer value returned from `_NL_ADDRESS_COUNTRY_NUM` should
    be treated like a native-word-sized integer value rather than a pointer. See the
    *nl.c* code in [Listing 11-8](ch11.xhtml#ch11ex8) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the same information using the `-k` option with the `locale`
    command line program that comes preinstalled on your Linux distro, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can query the GNU C library `nl_langinfo` function for individual time-
    and date-formatting attributes such as AM and PM strings, various more granular
    format-specifier strings, and full and abbreviated days of the week and months
    of the year in the current locale.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU C library `nl_langinfo` implementation even returns regular expressions
    intended to be used for matching query responses. The regular expressions returned
    from the `YESEXPR` and `NOEXPR` item enumeration values can be used to match *yes*
    or *no* answers to questions prompted by software.
  prefs: []
  type: TYPE_NORMAL
- en: '*Instrumenting Source Code for Static Messages*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instrumenting access to locale-specific static text messages in your source
    code is also part of the process of internationalizing software, so we’ll cover
    instrumentation of static text display messages here. Then we’ll move on to how
    to generate and consume language packs in [Chapter 12](ch12.xhtml), where I’ll
    discuss localization.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear by now that something needs to be done with the static portion
    of the “*`greeting`*, from *`progname`*!” text we printed from Jupiter (for example).
    I’m not going to take Jupiter any further, but it does provide a concise example
    of something that needs to change in our programs when the locale changes. The
    process of instrumenting source code for translating static display messages involves
    scanning your source code for all string literals that can be displayed to a user
    during the execution of a program and then doing something that makes it possible
    for the program to use a version of that string that specifically targets the
    current locale.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few open source (and several third-party commercial) libraries that
    can be used to accomplish this task, but we’re going to focus on the GNU *gettext*
    library. The *gettext* library is very simple from a software perspective. In
    its simplest form, there’s one function for tagging a message to be translated
    and two functions for selecting the message catalog to be used for display. The
    tagging function is named `gettext`, and its prototype is shown in [Listing 11-9](ch11.xhtml#ch11ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: The prototype for the `gettext` function*'
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts a message identifier in the *`msgid`* parameter and returns
    the display message to the user. The message identifier can be any string but
    is usually the display message itself, in US-ASCII. The reason for this is that
    if the message catalog cannot be found, `gettext` returns the *`msgid`* value
    itself, which will then be used by the program in the same way the translated
    message would have been used, had it been found. Thus, the `gettext` function
    cannot fail in a manner that will cause the program to not work in some reasonable
    fashion under any conceivable set of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: This convention makes it very simple to both instrument existing programs and
    write new programs that use locale-based message catalogs. You simply need to
    find all of the static text messages within the program source files and wrap
    them in calls to `gettext`.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, it’s necessary to provide the translator with more contextual
    information than just the string. For a common example, when providing message
    IDs for menu items such as the `Open` submenu option in the `File` menu, the programmer
    may have communicated to the translator that the programmer has provided the entire
    menu hierarchy in a format such as `|File|Open`. When the translator sees this,
    they know that only the portion following the last vertical bar symbol should
    be translated. But if there is no translation for the current locale, the message
    ID will be the full string. In this case, the programmer must write the code to
    check for a leading vertical bar. If it’s found, only the portion following the
    last vertical bar should actually be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 11-10](ch11.xhtml#ch11ex10) shows a very short (and somehow
    familiar) example program that uses `gettext`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-10:* gt.c: *A short program that illustrates the use of the gettext
    library*'
  prefs: []
  type: TYPE_NORMAL
- en: The `printf` function sends the return value of `gettext` to `stdout`. The `gettext`
    function is exported by the GNU C library, so no additional libraries are required
    to use it. When using `gettext` without GNU C, just link the *intl* library (shared
    object or static archive).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could call `gettext` directly in `printf`, but the underscore (`_`) macro
    is a common idiom used when internationalizing software for two reasons: First,
    it decreases the visual impact of instrumenting an existing code base for *gettext*.
    Second, it allows us a single point of replacement if we choose to wrap `gettext`
    with additional functionality or if we decide to use a more functional variant
    of `gettext` (for example, `dgettext` and `dcgettext`). I haven’t discussed these
    variants here, but you can find out more about them in the *GNU C Library* manual.^([17](footnote.xhtml#ch11fn17))'
  prefs: []
  type: TYPE_NORMAL
- en: Message Catalog Selection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Selection of the message catalog is done in two phases: the programmer phase
    and the user phase. The programmer phase is handled by the functions `textdomain`
    and `bindtextdomain`. The prototypes for these functions (also exported by the
    GNU C library) are shown in [Listing 11-11](ch11.xhtml#ch11ex11).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-11: The prototypes for `textdomain` and `bindtextdomain`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `textdomain` function allows the software author to determine the message
    catalog domain that is in use at any given point within the program. The domain
    represents a given message catalog containing some portion of the messages in
    a program. All strings extracted from the source code belonging to a specific
    domain end up in the message catalog for that domain.
  prefs: []
  type: TYPE_NORMAL
- en: A package may have several domains. The typical boundary between domains, and
    therefore between message catalogs, is an executable module— either a program
    or a library. For example, the *curl* package installs the command line `curl`
    program and the *libcurl.so* shared library. The *curl* library is designed to
    be used by both the `curl` program and by other third-party programs and libraries.
    If the *curl* package were internationalized, the package author might decide
    to use the *curl* domain for the `curl` program and the *libcurl* domain for the
    library so that third-party applications that use *libcurl* aren’t required to
    have the `curl` message catalog installed.
  prefs: []
  type: TYPE_NORMAL
- en: The example used by the *GNU C Library* manual^([18](footnote.xhtml#ch11fn18))
    is one where *libc* itself uses `libc` as the domain name, but programs using
    *libc* would use their own domain. Simply put, the *`domainname`* parameter in
    these functions directly corresponds to a message catalog filename.
  prefs: []
  type: TYPE_NORMAL
- en: The `dirname` parameter in `bindtextdomain` is used to specify a base directory
    in which to search for the well-defined message catalog directory structure, which
    I’ll discuss shortly. Normally, the value passed in this parameter is the absolute
    path in the Automake `datadir` variable, suffixed with */locale*. Recall that
    `datadir` contains, by default, `$(prefix)`*/share* and `prefix` contains */usr/local*,
    so the full path used here would be */usr/local/share/locale*. For distribution-provided
    packages, `prefix` is more often simply */usr*, so the full path would then become
    */usr/share/locale*. It’s therefore up to the maintainer to ensure that `datadir`
    is available within the software (using techniques discussed in [Chapter 3](ch03.xhtml))
    and referenced in the argument passed to this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-12](ch11.xhtml#ch11ex12) shows how to add the code necessary to
    select the proper message catalog based on the current locale. Of course, we must
    first make the program aware of the current locale in the usual manner by calling
    `setlocale`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-12:* gt.c: *Enhancements to enable the current locale and select
    the message catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: I’m using *gt* as the domain name here because that’s the name of the program.
    If this program were part of a package wherein all the components used the same
    domain, then the package name might be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: The directory name passed into `bindtextdomain`’s second parameter is derived
    from a future *config.h* inclusion. We’ll add that later when we incorporate this
    program into an Autotools build system. If we define `TEST_L10N` on the compiler
    command line, the directory name resolves to the value of the `PWD` environment
    variable, allowing us to test our program in any location containing the locale
    directory structure. (We’ll replace this hack later with a more Autotool-ish mechanism
    in [Chapter 12](ch12.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: That’s really all there is to instrumenting your code for message catalog lookup.
    In the next section, I’ll discuss how to generate and build message catalogs,
    which is part of the process of localizing a software package. I’ll also talk
    about the internal workings of the *gettext* library, which allows the user to
    select (during the user phase) the message catalog that should be used by their
    choice of environment variable settings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, my goal was to give you enough background that you could easily
    continue learning about internationalizing your software projects. I’ve covered
    the C standard library functionality that’s designed to help you internationalize
    your software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue our exploration of this topic by diving
    into localization. We’ll also discover how to tie all of this into the Autotools
    so that language packs get built and installed with `make` commands generated
    by Automake.
  prefs: []
  type: TYPE_NORMAL
