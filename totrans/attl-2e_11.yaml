- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: INTERNATIONALIZATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化
- en: '*Like all great travelers I have seen more than I remember, and remember more
    than I have seen.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*像所有伟大的旅行者一样，我看到的比记得的多，记得的比看到的多。'
- en: —Benjamin Disraeli, Vivian Grey*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —本杰明·迪斯雷利，《维维安·格雷》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: When it comes to making software available in other languages, native English
    speakers are a little arrogant—but who can blame us? We’ve been taught almost
    from childhood, through every experience we’ve had in this industry, that English
    is the only important language—so much so that we don’t even think about it anymore.
    All computer science–oriented research and academic discussions in communities
    of any consequence are in English. Even our programming languages have English
    keywords.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到将软件提供到其他语言时，母语为英语的人往往有些傲慢——但谁能怪我们呢？从几乎童年起，我们通过在这个行业中所经历的每一件事，都被教导英语是唯一重要的语言——以至于我们现在甚至不再去思考这个问题。所有计算机科学相关的研究和学术讨论，任何有影响力的社区都是用英语进行的。就连我们的编程语言都有英语关键词。
- en: Some might counter that this is because most programming languages are invented
    by English speakers. Not even close! Take for instance Niklaus Wirth of Switzerland,
    a native German speaker, who invented or had a hand in the invention of several
    important programming languages, including Euler, Pascal, and Modula. Not popular
    enough for you? Bjarne Stroustrup, Danish by birth, invented C++. Guido van Rossum,
    born and raised in the Netherlands, invented Python. Rasmus Lerdorf, who was born
    in Denmark and later moved to Canada, wrote PHP. Ruby was written by Yukihiro
    Matsumoto in Japan.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能反驳说，这是因为大多数编程语言都是由英语使用者发明的。其实并不完全是这样！例如，来自瑞士的尼古拉斯·维尔特（Niklaus Wirth），一位德语为母语的人，他发明或参与了多个重要编程语言的发明，包括欧拉（Euler）、帕斯卡尔（Pascal）和莫杜拉（Modula）。觉得这些不够有名吗？丹麦出生的比雅尼·斯特劳斯特鲁普（Bjarne
    Stroustrup）发明了C++。出生并成长于荷兰的吉多·范罗苏姆（Guido van Rossum）发明了Python。出生在丹麦，后来移居加拿大的拉斯穆斯·勒多夫（Rasmus
    Lerdorf）编写了PHP。Ruby则是由日本的松本行弘（Yukihiro Matsumoto）编写的。
- en: My point is, it never occurs to developers—even non-native English speakers—to
    invent programming languages that use, for example, German keywords. Why not?
    Probably because no one would use them if they did—not even Germans. New programming
    languages are often conceived in academic or corporate research environments,
    and the industry journals, forums, and standardization organizations that facilitate
    the discussion of the pros and cons of these inventions are written or managed
    almost exclusively in English—for pragmatic reasons, of course. No one is really
    saying that English is the best language. Rather, we need a common medium in which
    to publish, and English, being one of the most widely spoken languages on Earth,
    just sort of fell into that role.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点是，开发者——即使是非英语母语的开发者——从未考虑过发明使用德语关键词的编程语言。为什么不呢？可能是因为如果真的有人这么做，几乎没有人会使用它们——甚至连德国人也不会。新的编程语言往往是在学术或企业研究环境中构思出来的，促进这些发明的优缺点讨论的行业期刊、论坛和标准化组织几乎都是用英语书写或管理的——当然，这也是出于实际考虑。没有人在说英语是最好的语言。而是我们需要一个共同的媒介来发布信息，英语作为地球上最广泛使用的语言之一，就自然而然地扮演了这个角色。
- en: What we miss because of this English-only attitude is that there are entire
    communities of non-English-speaking software users out there who struggle to understand
    applications written entirely in English. It’s as uncomfortable for them to use
    these applications as it is for English-only speakers to look at a web page in
    Chinese or Russian.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种只讲英语的态度，我们错过了一个重要的方面，那就是有整个非英语使用者的社区，他们在理解完全用英语编写的应用程序时感到困难。对他们来说，使用这些应用程序就像对只懂英语的人来说，去看一个中文或俄文网页一样不舒服。
- en: Larger companies often provide language packs to allow these communities to
    use software offerings in their native languages. Some of these commercial native-language
    offerings are extensive, providing support even for the more difficult Arabic
    and Asian languages.^([1](footnote.xhtml#ch11fn1)) However, most smaller commercial
    and open source software package authors don’t even try because, they say, it’s
    too expensive, too difficult, or just not important enough to their communities
    or markets. The first of these arguments *may* have some merit in the corporate
    world. Let’s talk about our options for solving these problems and, hence, for
    expanding our communities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大公司通常会提供语言包，以便这些社区能够在其母语中使用软件产品。部分商业本地化产品非常全面，甚至支持更为复杂的阿拉伯语和亚洲语言。^([1](footnote.xhtml#ch11fn1))然而，大多数较小的商业和开源软件包作者甚至都不尝试，因为他们认为成本过高、困难重重，或者这些对于他们的社区或市场来说并不重要。第一个论点*在企业界*可能有一定的道理。让我们讨论一下我们解决这些问题的选项，也就是如何扩大我们的社区。
- en: Obligatory Disclaimer
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制性免责声明
- en: Before I dive into this topic, I’ll state up front that multivolume works could
    (and should) be written on software internationalization and localization. The
    topic is simply huge. I will not even come close to covering everything in a couple
    of chapters. My goal here is to give an introduction to a topic that may seem
    daunting from the outside. If you’re already familiar with these concepts, you’ll
    probably be disgusted by the amount of material I don’t cover. Please understand
    that these chapters are not for you, although you may find some ideas of value
    in them. Rather, these chapters are for the beginner with little experience in
    this area.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论这个话题之前，我先明确声明，关于软件国际化和本地化的多卷作品完全可以（也应该）被写出来。这个话题实在是太庞大了。我不可能在几章内容里涵盖所有内容。我的目标是为一个看起来可能令人生畏的主题提供一个介绍。如果你已经熟悉这些概念，可能会对我没有涉及的材料感到厌烦。请理解，这些章节并不是为你们准备的，虽然你们或许能从中找到一些有价值的想法。实际上，这些章节是为那些在这个领域经验较少的初学者准备的。
- en: In this chapter, I’ll cover what’s in the C standard and what works with the
    UTF-8 codeset, and I’ll go a bit beyond. I’ll also cover major portions of the
    *GNU gettext* library because integration of *gettext* into Autotools projects
    is, in fact, the point of this chapter, but I won’t cover third-party libraries
    and solutions, though I do mention them where appropriate. Neither will I cover
    wide-character string manipulation and multibyte-to-wide-character (and vice versa)
    transformations; there are plenty of resources out there that cover these topics
    in detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将涵盖C标准中的内容以及与UTF-8编码集兼容的部分，还会稍微超出一些。我还将涵盖*GNU gettext*库的主要部分，因为将*gettext*集成到Autotools项目中实际上是本章的重点，但我不会涉及第三方库和解决方案，尽管在适当的地方我会提到它们。我也不会讨论宽字符字符串操作和多字节到宽字符（以及反之）的转换；有很多资源详细讨论了这些话题。
- en: I just stated that I’ll cover *major portions* of *gettext*, meaning that there
    are parts I’ll leave out because they’re used only under special conditions. Once
    you have the basics down, you can easily pick up the rest, as needed, from the
    manual.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才提到，我将涵盖*gettext*的*主要部分*，这意味着有些部分我将跳过，因为它们只在特定条件下使用。一旦你掌握了基础，随时可以从手册中获取其余内容。
- en: Speaking of the manual, like many software manuals, the *gettext* manual is
    more a reference than a tutorial for beginners. You may have tried to read the
    *gettext* manual, intending to become familiar with internationalization and localization
    though this channel, and walked away thinking, “Either this is a terrible manual
    or I’m just way out of my depth here.” I know I did at one point. If so, you’d
    be somewhat correct on both counts. First, it’s pretty apparent that the manual
    was written by non-English speakers. Is that such a surprise? We’ve already decided
    that native English speakers don’t really care that much, in general, about this
    topic. Some of the idioms used in the manual are simply not familiar to English
    speakers, and some of the phraseology is clearly foreign. But, provenance aside,
    the manual is also not organized in a manner helpful to someone trying to become
    familiar with the topic. As I was doing research for this chapter, I found several
    online tutorials that would be much more helpful than the manual for programmers
    just trying to figure out where to start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 说到手册，像许多软件手册一样，*gettext* 手册更多的是作为参考资料，而非为初学者设计的教程。你可能曾经尝试阅读 *gettext* 手册，打算通过这个渠道熟悉国际化和本地化，但读完后你可能会想，“要么这是一本糟糕的手册，要么我根本无法理解。”我曾经也有过这种感觉。如果是这样，你在某种程度上是对的。首先，很明显这本手册是由非英语母语的人编写的。难道这很奇怪吗？我们已经决定，一般来说，英语母语的人并不太关心这个话题。手册中使用的一些习语对英语使用者来说根本不熟悉，而且一些表达方式显然是外来的。不过，不谈出处，这本手册的组织结构也并不有利于那些想要熟悉这个话题的人。当我为这一章做研究时，我发现了几篇在线教程，它们对那些只想弄清楚从哪里入手的程序员来说，要比手册更有帮助。
- en: So, let’s begin by first covering some definitions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们首先从一些定义开始。
- en: Internationalization (I18n)
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国际化 (I18n)
- en: '*Internationalization*, sometimes referred to as *i18n* in the literature because
    it’s easier to write,^([2](footnote.xhtml#ch11fn2)) is the process of preparing
    a software package to be published in other languages or for other cultures. This
    preparation includes writing (or refactoring) the software in such a way as to
    be easily configured to display human-readable text in other languages, or according
    to other cultural customs and standards. The text I’m referring to here includes
    strings, numbers, dates and times, currency values, postal addresses, salutations
    and greetings, paper sizes, measurements, and any other aspect of human communications
    you can think of that may be done differently in different languages and cultures.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*国际化*，在文献中有时被称为 *i18n*，因为这样写更简便，[2](footnote.xhtml#ch11fn2) 是准备将软件包发布到其他语言或文化中的过程。这项准备工作包括以一种方式编写（或重构）软件，使其能够轻松配置以显示其他语言的人类可读文本，或者符合其他文化习俗和标准。我在这里提到的文本包括字符串、数字、日期和时间、货币值、邮政地址、称呼和问候、纸张大小、度量衡以及你能想到的任何其他在人类交流中可能会因语言和文化差异而有所不同的方面。'
- en: Internationalization is specifically *not* about converting embedded text from
    one language to another. Rather, it’s about preparing your software so that static
    and generated text can easily be displayed in a target language or in formats
    that conform to target cultural norms. People of British culture, for instance,
    expect to see dates, decimal numbers, and local currency displayed differently
    than do Americans, even though both speak English natively. So internationalization
    encompasses not only language support but also general culture support.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化特别强调*不是*将嵌入的文本从一种语言转换成另一种语言。而是通过为你的软件做准备，使得静态和生成的文本可以轻松地以目标语言显示，或者以符合目标文化规范的格式显示。例如，英国文化中的人们期望看到日期、小数数字和本地货币的显示方式与美国人不同，尽管两者都讲英语。所以国际化不仅仅包括语言支持，还包括一般的文化支持。
- en: To be clear, this preparation is not about building a version of your software
    specifically for Spanish speakers, for example. That topic is reserved for [Chapter
    12](ch12.xhtml), where I’ll discuss the concept of *localization*. Rather, internationalization
    is about designing or modifying your software such that it *can* be easily used
    by Spanish speakers. This means first locating and tagging the strings in your
    software that should be translated and finding the places in your code where times
    and dates, currency, numbers, and other locale-specific content is formatted for
    display. Then you need to make those bits of static text and text-generation code
    configurable based on a global or specified locale. Of course, it also means configuring
    your software to be aware of the current system locale and switch into it automatically.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，这个准备工作不是为西班牙语使用者专门构建一个版本的应用程序。例如，这个话题留待 [第 12 章](ch12.xhtml)讨论，在那里我将讨论
    *本地化* 的概念。而国际化是指设计或修改你的软件，使其 *能够* 被西班牙语使用者轻松使用。这意味着首先找到并标记出软件中应该翻译的字符串，找出代码中显示格式化时间、日期、货币、数字和其他区域特定内容的地方。然后，你需要使这些静态文本和文本生成代码可以根据全球或指定的区域设置进行配置。当然，这也意味着配置你的软件，使其能够识别当前的系统区域设置，并自动切换到该设置。
- en: 'There are two areas of software internationalization that are different enough
    that we should discuss them separately:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件国际化有两个足够不同的领域，我们应该将它们分开讨论：
- en: Dynamic, runtime-generated text messages
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态、运行时生成的文本消息
- en: Static text messages that are hardcoded into your application
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码到应用中的静态文本消息
- en: Let’s cover generated messages first, since we often get some help in this area
    from programming language standard libraries. Most such libraries provide some
    form of support for locale management, and C is no exception. C++ provides the
    same sort of functionality in an object-oriented manner.^([3](footnote.xhtml#ch11fn3))
    Once you understand what’s available in C, the C++ version is pretty easy to pick
    up on your own, so we’ll cover the functionality provided by the C standard library
    here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论生成的消息，因为在这方面，我们通常会从编程语言标准库中获得一些帮助。大多数此类库都提供某种形式的区域设置管理支持，C 语言也不例外。C++
    提供了同样的功能，只不过是面向对象的方式。^([3](footnote.xhtml#ch11fn3)) 一旦你理解了 C 中可用的内容，C++ 版本就很容易自学，所以我们将在这里介绍
    C 标准库提供的功能。
- en: I’ll also introduce you to the extended interfaces provided by the POSIX 2008
    and X/Open standards because, as we’ll see, the functionality provided by the
    standard C library, while usable, is a bit weak, and the POSIX and X/Open standard
    functionality is pretty widely available. Finally, GNU extensions to the C standard
    can make your application shine in other cultures, as long as you’re willing to
    break away from the standards a bit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将向你介绍 POSIX 2008 和 X/Open 标准提供的扩展接口，因为正如我们将看到的，标准 C 库提供的功能虽然可以使用，但有些薄弱，而 POSIX
    和 X/Open 标准的功能则相当广泛可用。最后，GNU 对 C 标准的扩展可以让你的应用在其他文化中脱颖而出，只要你愿意稍微偏离标准。
- en: '*Instrumenting Source Code for Dynamic Messages*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为动态消息加 Instrumentation 的源代码*'
- en: The standard C library offers the `setlocale` and `localeconv` functions exposed
    by the *locale.h* header file, as shown in the synopsis in [Listing 11-1](ch11.xhtml#ch11ex1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 C 库提供了 `setlocale` 和 `localeconv` 函数，这些函数由 *locale.h* 头文件公开，如 [清单 11-1](ch11.xhtml#ch11ex1)
    中所示。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: A synopsis of the standard C library `setlocale` and `localeconv`
    functions*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：标准 C 库 `setlocale` 和 `localeconv` 函数的概要*'
- en: The task of `setlocale` is to tell the standard C library which locale to use
    for a given class of library functionality. This function accepts a *`category`*—an
    enumeration value representing a segment of locale-specific functionality in the
    library that should be changed from the current locale to a new target *`locale`*.
    The available standard category enumeration values are as follows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`setlocale` 的任务是告诉标准 C 库在给定的库功能类别中使用哪个区域设置。此函数接受一个 *`category`*—一个枚举值，表示库中应从当前区域设置切换到新的目标
    *`locale`* 的区域特定功能段。可用的标准类别枚举值如下。'
- en: '**`LC_ALL`**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_ALL`**'
- en: '`LC_ALL` represents all categories. Changing the value of this category sets
    all of the available categories to the specified locale. This is the most common
    and recommended value to use, unless you have a very specific reason for not setting
    all categories to the same locale.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`LC_ALL` 代表所有类别。更改此类别的值将所有可用类别设置为指定的区域设置。这是最常见且推荐使用的值，除非你有非常具体的理由不将所有类别设置为相同的区域设置。'
- en: '**`LC_COLLATE`**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_COLLATE`**'
- en: Changing `LC_COLLATE` affects the way collation functions like `strcoll` and
    `strxfrm` work. Different languages and cultures collate and sort based on different
    character- or glyph-ordering rules. Setting the collation locale changes the rules
    used by the library’s text collation functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`LC_COLLATE`会影响诸如`strcoll`和`strxfrm`等排序函数的工作方式。不同的语言和文化依据不同的字符或字形顺序规则进行排序。设置排序区域会改变库中排序函数使用的规则。
- en: '**`LC_CTYPE`**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_CTYPE`**'
- en: Changing `LC_CTYPE` affects the way the character attribute functions defined
    in *ctype.h* operate (except for `isdigit` and `isxdigit`). It also affects the
    multibyte and wide-character versions of these functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`LC_CTYPE`会影响在*ctype.h*中定义的字符属性函数的工作方式（`isdigit`和`isxdigit`除外）。它还会影响这些函数的多字节和宽字符版本。
- en: '**`LC_MONETARY`**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_MONETARY`**'
- en: Changing `LC_MONETARY` affects the monetary-formatting information returned
    by `localeconv` (which we’ll discuss later in this section), as well as the resulting
    strings returned by the X/Open standard and POSIX extension `strfmon`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`LC_MONETARY`会影响`localeconv`返回的货币格式信息（稍后在本节中讨论），以及由X/Open标准和POSIX扩展`strfmon`返回的结果字符串。
- en: '**`LC_NUMERIC`**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_NUMERIC`**'
- en: Changing `LC_NUMERIC` affects the decimal point character in formatted input
    and output operations performed by functions like `printf` and `scanf` and the
    values related to decimal formatting returned by `localeconv`, as well as the
    resulting strings returned by the X/Open standard and POSIX extension `strfmon`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`LC_NUMERIC`会影响格式化输入和输出操作中使用的十进制点字符（如`printf`和`scanf`函数）以及由`localeconv`返回的与十进制格式相关的值，以及由X/Open标准和POSIX扩展`strfmon`返回的结果字符串。
- en: '**`LC_TIME`**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_TIME`**'
- en: Changing `LC_TIME` affects the way time and date strings are formatted by `strftime`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`LC_TIME`会影响`strftime`格式化时间和日期字符串的方式。
- en: The return value of `setlocale` is a string representing the previous locale,
    or set of locales if all categories are not set the same. If you’re only interested
    in determining the current locale, you can pass `NULL` in the *`locale`* parameter
    and `setlocale` will not change anything. If you have set any of the individual
    categories independently to different locale values, the returned string’s format,
    when passing `LC_ALL`, is implementation defined and therefore not quite as useful
    as it might otherwise be. Nevertheless, most implementations will allow you to
    pass this string back into `setlocale`, using `LC_ALL`, to reset category-specific
    locales to those of a previously retrieved state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`setlocale`的返回值是一个表示先前区域设置的字符串，或者如果所有类别的区域设置不相同，则是一个区域设置集合。如果你只对确定当前区域设置感兴趣，可以在*`locale`*参数中传递`NULL`，这样`setlocale`就不会更改任何内容。如果你已将某些类别独立设置为不同的区域值，则在传递`LC_ALL`时返回的字符串格式是由实现定义的，因此不像预期的那样有用。尽管如此，大多数实现会允许你将这个字符串传回`setlocale`，并使用`LC_ALL`将类别特定的区域重置为先前获取的状态。'
- en: 'Once the desired locale has been set up, `localeconv` may be called to return
    a pointer to a structure containing *some* of the attributes of the current locale.
    Why not all of them? Because the designers of this API—otherwise intelligent people—were
    on pain medication or something when they created it. Seriously, the *GNU C Library*
    manual has something to say about it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了所需的区域设置，可以调用`localeconv`函数，返回一个指向结构的指针，结构中包含当前区域的一些属性。为什么不是所有的属性？因为这个API的设计者——按理说是聪明的人——在创建它时可能正在服用止痛药。说真的，*GNU
    C库*手册对此有一些解释：
- en: Together with the `setlocale` function the ISO C people invented the `localeconv`
    function. It is a masterpiece of poor design. It is expensive to use, not extensible,
    and not generally usable as it provides access to only `LC_MONETARY` and `LC_NUMERIC`
    related information. Nevertheless, if it is applicable to a given situation it
    should be used since it is very portable.^([4](footnote.xhtml#ch11fn4))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与`setlocale`函数一起，ISO C的人发明了`localeconv`函数。这是一个设计极差的杰作。它使用起来代价高昂，无法扩展，并且由于它只能提供与`LC_MONETARY`和`LC_NUMERIC`相关的信息，因此通常不易使用。然而，如果在特定情况下适用，仍然应该使用它，因为它非常便捷。^([4](footnote.xhtml#ch11fn4))
- en: In addition to these criticisms, I’ll add that it’s not thread safe; the contents
    of the structure are subject to modification (by another thread calling `setlocale`)
    while you’re accessing it. Nevertheless, the rules are clear about how it can
    get modified—only by calls to `setlocale` with a non-`NULL` *`locale`* parameter
    value—so it is usable, but it’s neither elegant nor complete. As the preceding
    excerpt indicates, you should try to use `localeconv` if you don’t need additional
    information for your application, because it’s part of the C standard and is,
    therefore, extremely portable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些批评外，我还要补充一点：它不是线程安全的；在你访问它的同时，结构体的内容可能会被另一个线程（通过调用`setlocale`）修改。不过，规则明确规定了它如何被修改——只有通过传递非`NULL`的*`locale`*参数值的`setlocale`调用，才会修改它——因此它是可以使用的，但既不优雅也不完整。正如前面的摘录所示，如果你的应用程序不需要额外的信息，你应该尽量使用`localeconv`，因为它是
    C 标准的一部分，因此具有极高的可移植性。
- en: To be completely fair, the fields in the structure returned by `localeconv`
    are those that presumably require some direct programmer intervention to use correctly,
    given the functionality provided by the C standard library. For example, the `printf`
    family of functions provides no special format specifiers for locale-specific
    number and currency values, so information related to the `LC_NUMERIC` and `LC_MONETARY`
    categories must be made available to the developer in some fashion in order to
    make proper use of these categories in a program designed to print numbers and
    currency amounts in locale-specific formats. It also means, of course, that without
    third-party libraries or extensions to the C standard, you’ll be writing some
    tedious text-formatting functions that vary their output based on the rules returned
    by `localeconv`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公正地说，`localeconv`返回的结构体中的字段是那些需要程序员直接干预才能正确使用的字段，考虑到 C 标准库提供的功能。例如，`printf`系列函数没有为特定地区的数字和货币值提供特别的格式说明符，因此与`LC_NUMERIC`和`LC_MONETARY`类别相关的信息必须以某种方式提供给开发者，才能在设计用于以特定地区格式打印数字和货币金额的程序中正确使用这些类别。当然，这也意味着，没有第三方库或
    C 标准扩展，你将不得不编写一些繁琐的文本格式化函数，根据`localeconv`返回的规则变化其输出。
- en: On the other hand, the `LC_COLLATE`, `LC_TIME`, and `LC_CTYPE` categories all
    directly affect various existing standard library functionality, making it presumably
    unnecessary for the program author to have direct access to the locale attributes
    used by these library functions.^([5](footnote.xhtml#ch11fn5))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`LC_COLLATE`、`LC_TIME`和`LC_CTYPE`类别直接影响现有的标准库功能，因此程序员可能不需要直接访问这些库函数使用的地区信息属性。^([5](footnote.xhtml#ch11fn5))
- en: '**Setting and Using Locales**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置和使用地区信息**'
- en: The C and C++ standards require that all implementations of the standard library
    be initialized in every process with the default “C” locale so that all programs
    not explicitly selecting a locale will act in a predictable and consistent manner.
    Therefore, the first thing you must do to internationalize your software is to
    change the locale. The easiest and most consistent way to change the locale within
    your application is to call `setlocale` with a *`category`* value of `LC_ALL`
    somewhere near the start of the program. But what string should we pass as a *`locale`*
    argument? Well, that’s the beauty of this function—you don’t need to pass any
    specific locale string at all. Passing an empty string disables the *default locale*,
    allowing the library to select the *environment locale* that’s in effect on the
    host. This allows your users to determine how your program will display times
    and dates, decimal numbers, and currency values and how collation and character
    set management will work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 标准要求所有标准库的实现都必须在每个进程中初始化为默认的“C”地区信息，这样所有没有明确选择地区信息的程序将以可预测和一致的方式运行。因此，国际化软件的第一步就是改变地区信息。最简单且一致的方法是在程序开始时的某个地方调用`setlocale`，并将*`category`*值设置为`LC_ALL`。但是，我们应该传递什么字符串作为*`locale`*参数呢？这就是这个函数的妙处——你根本不需要传递任何特定的地区字符串。传递一个空字符串将禁用*默认地区信息*，允许库选择当前主机上有效的*环境地区信息*。这使得用户可以决定你的程序如何显示时间和日期、十进制数字和货币值，以及如何进行排序和字符集管理。
- en: '[Listing 11-2](ch11.xhtml#ch11ex2) shows the code for a program that configures
    the standard C library to use the host environment locale and then displays the
    standard locale attributes available from `localeconv` to the console.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-2](ch11.xhtml#ch11ex2) 显示了一个程序的代码，该程序配置标准 C 库以使用主机环境的区域设置，并将从 `localeconv`
    获取的标准区域设置属性显示到控制台。'
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The example programs in this chapter can be found in the online GitHub repository
    named* NSP-Autotools/gettext, *found at* [https://github.com/NSP-Autotools/gettext/](https://github.com/NSP-Autotools/gettext/).
    *The small utility programs presented in this chapter are found in the* small-utils
    *directory in that repository, and a makefile is provided that will build them
    all by default. Use a command like *`make lc`*, for instance, to build just the
    *`lc`* program presented in [Listing 11-2](ch11.xhtml#ch11ex2).*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章中的示例程序可以在名为* NSP-Autotools/gettext *的在线 GitHub 仓库中找到，地址为* [https://github.com/NSP-Autotools/gettext/](https://github.com/NSP-Autotools/gettext/)。*
    本章中呈现的小型实用程序位于该仓库中的* small-utils *目录，并且提供了一个 makefile，默认情况下会构建它们。使用类似*`make lc`*的命令，例如，只构建
    [示例 11-2](ch11.xhtml#ch11ex2) 中呈现的 *`lc`* 程序。*'
- en: Git tag 11.0
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 11.0
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2:* lc.c: *A program to display all locale attributes retrieved
    from `localeconv`*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-2:* lc.c: *一个程序，用于显示从 `localeconv` 获取的所有区域设置属性*'
- en: The `struct lconv` structure contains both `char *` and `char` fields. The `char
    *` fields mostly refer to strings whose values are determined according to the
    current locale. Some of the `char` fields are intended to be taken as Boolean
    values, while the rest are designed to be read as small integer values. The code
    shown in [Listing 11-2](ch11.xhtml#ch11ex2) should indicate pretty clearly which
    are Boolean and which are small integers. The documentation for your compiler’s
    standard library should also make it clear.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct lconv` 结构包含 `char *` 和 `char` 字段。`char *` 字段大多是指字符串，其值由当前区域设置决定。一些
    `char` 字段用于表示布尔值，而其他则设计为小整数值。示例代码 [示例 11-2](ch11.xhtml#ch11ex2) 应该清楚地指示哪些是布尔值，哪些是小整数值。您编译器的标准库文档也应该能明确说明这一点。'
- en: The only weird ones are the `grouping` and `mon_grouping` fields, which indicate
    how digits in numbers and currency values (respectively) should be grouped, with
    groups separated by the corresponding *thousands separator* string. The `grouping`
    and `mon_grouping` fields are `char *` fields designed to be read not as strings
    but as arrays of small integers. They’re terminated with either a zero or the
    value `CHAR_MAX` (defined in *limits.h*). If they’re terminated with zero, the
    final grouping value is repeated forever; otherwise, the final grouping includes
    the remaining digits in the value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一奇怪的是 `grouping` 和 `mon_grouping` 字段，它们分别表示数字和货币值的分组方式，分组之间由相应的*千位分隔符*字符串分隔。`grouping`
    和 `mon_grouping` 字段是 `char *` 类型的字段，设计时并非作为字符串读取，而是作为小整数数组读取。它们以零或 `CHAR_MAX`（在
    *limits.h* 中定义）为终止符。如果它们以零终止，最后的分组值将永远重复；否则，最后的分组将包含值中剩余的数字。
- en: Finally, note the call to the internal `print_monetary` routine that’s wrapped
    in a check for `__USE_ISOC99` (near the bottom of the listing). The international
    forms of these currency attributes were added with the C99 standard. Everyone
    should be up to C99 by now, so this is not generally an issue. I added the conditional
    compilation check because, for this utility program, it’s possible and appropriate.
    For an application trying to use these fields, you should probably just insist
    that C99 be required to build the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意对内部 `print_monetary` 例程的调用，该调用被包装在一个 `__USE_ISOC99` 检查中（在示例底部附近）。这些货币属性的国际化形式是通过
    C99 标准加入的。现在每个人都应该使用 C99，因此通常不成问题。我添加了条件编译检查，因为对于这个实用程序来说，这样做是可能且合适的。对于一个试图使用这些字段的应用程序，您应该要求
    C99 标准是构建该应用程序的必要条件。
- en: 'Building and executing this program from a US English Linux system generates
    the following console output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从美国英语的 Linux 系统构建并执行此程序会生成以下控制台输出：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To change the environment locale, set the `LC_ALL` environment variable to the
    name of the locale you want to use. The values you can use are the locales that
    are generated and installed on your system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改环境区域设置，请将 `LC_ALL` 环境变量设置为您想使用的区域设置名称。您可以使用的值是系统中生成并安装的区域设置。
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also set individual locale categories using environment variables
    with the same names as the category names. For example, to change the locale to
    Spanish (in Spain), but only for the *`LC_TIME`* category, you could set the *`LC_TIME`*
    environment variable to *`es_ES.utf8`*. This works for all the standard categories
    defined earlier.^([6](footnote.xhtml#ch11fn6))*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以使用与类别名称相同的环境变量来设置单独的locale类别。例如，要将locale更改为西班牙语（西班牙），但仅针对*`LC_TIME`*类别，你可以将*`LC_TIME`*环境变量设置为*`es_ES.utf8`*。这对所有前面定义的标准类别有效。^([6](footnote.xhtml#ch11fn6))*'
- en: 'To find out which locales are available, run the `locale` utility with the
    `-a` option, in this manner:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的locale，运行`locale`工具并使用`-a`选项，如下所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*My example console listings are performed on a Debian-based system. If you’re
    using a Fedora-based distribution, for example, you should expect to see different
    results, as Fedora has significantly different default functionality with respect
    to installed language packs and how the *`locale`* utility works. I’ll discuss
    Red Hat specifics later on in the chapter where it really matters.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的示例控制台列表是在基于Debian的系统上执行的。如果你使用的是基于Fedora的发行版，例如，你应该预期会看到不同的结果，因为Fedora在安装语言包和*`locale`*工具的工作方式上有显著不同的默认功能。我将在本章稍后讨论与Red
    Hat相关的具体情况，只有在真正需要时才会涉及。*'
- en: Normally, a US English installation of Linux will have several locales configured
    that begin with the string `en`. I’ve generated Swedish (`sv_SE.utf8`) and Japanese
    (`ja_JP.utf8`) locales on my Debian-based system, as well, in order to show examples
    of output when the environment is configured for non-English languages and cultures.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Linux的美国英语安装会配置多个以`en`开头的locale。我在我的基于Debian的系统上还生成了瑞典语（`sv_SE.utf8`）和日语（`ja_JP.utf8`）locale，以展示当环境配置为非英语语言和文化时输出的示例。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I also use the French (*`fr_FR.utf8`*) locale later in the chapter. You may
    wish to pre-build or preinstall all of these locales using whatever mechanism
    is provided by your distribution to make it easier to follow along with my examples
    on your system. Of course, if you are not a native English speaker, you’re probably
    already using a different locale by default. In this case, you might also want
    to build or install the *`en_US.utf8`* locale—though, not surprisingly, this locale
    generally comes preinstalled even on systems not built or sold in the United States.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本章后面也使用了法语（*`fr_FR.utf8`*）locale。你可能希望通过你发行版提供的机制预先构建或预安装所有这些locale，以便在你的系统上更容易跟随我的示例。当然，如果你不是以英语为母语的人，你可能已经默认使用了不同的locale。在这种情况下，你可能还需要构建或安装*`en_US.utf8`*
    locale——尽管不出所料，即使在非美国制造或销售的系统上，这个locale通常也是预安装的。*'
- en: You may have noticed the `C`, `C.UTF-8`, and `POSIX` locales in the preceding
    list. The `C` locale, as already mentioned, is the default locale for programs
    that do not set the locale explicitly. The `POSIX` locale is currently defined
    as an alias for the `C` locale.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到前面列表中的`C`、`C.UTF-8`和`POSIX` locales。正如之前提到的，`C` locale是未显式设置locale的程序的默认locale。`POSIX`
    locale目前被定义为`C` locale的别名。
- en: Generating and Installing Locales
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成和安装Locales
- en: 'The process of generating and installing a locale is pretty specific to a distribution,
    but there are a few common implementations. On a Debian- or Ubuntu-based system,
    for instance, you can look at the */usr/share/i18n/SUPPORTED* file to see which
    locales can be generated and installed from sources on your system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 生成和安装locale的过程通常与发行版密切相关，但也有一些常见的实现方式。例如，在基于Debian或Ubuntu的系统上，你可以查看*/usr/share/i18n/SUPPORTED*文件，查看可以从系统上的源生成并安装的locale：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are 480 locale names in this file on my Linux Mint system. The general
    format of a locale name, as defined by the X/Open standard, is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Linux Mint系统上，这个文件中有480个locale名称。locale名称的一般格式，如X/Open标准所定义，如下所示：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are up to four parts of a locale name. The first part, *`language`*, is
    required. The remaining parts, *`territory`*, *`codeset`*, and *`modifier`*, are
    optional. For example, the locale name for US English using the UTF-8 character
    set is `en_US.utf8`. The *`language`* is represented in the form of a two-letter
    ISO 639 language code.^([7](footnote.xhtml#ch11fn7)) For instance, `en` refers
    to the English language, which could be American, Canadian, British, or some other
    dialect of English.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区域设置名称最多包含四个部分。第一部分，*`language`*，是必需的。其余部分，*`territory`*、*`codeset`* 和 *`modifier`*，是可选的。例如，使用
    UTF-8 字符集的美国英语的区域设置名称是 `en_US.utf8`。*`language`* 以两位字母的 ISO 639 语言代码表示。^([7](footnote.xhtml#ch11fn7))
    例如，`en` 指的是英语，可以是美式英语、加式英语、英式英语或其他英语方言。
- en: The *`territory`* portion indicates the location of the language and takes the
    form of a two-letter ISO 3166 country code.^([8](footnote.xhtml#ch11fn8)) For
    example, `US` is for the United States, `CA` is for Canada, and `GB` is for Great
    Britain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*`territory`* 部分表示语言的地区，采用两位字母的 ISO 3166 国家代码表示。^([8](footnote.xhtml#ch11fn8))
    例如，`US` 代表美国，`CA` 代表加拿大，`GB` 代表英国。'
- en: The portion after the dot (`.`) indicates the *`codeset`* or character encoding,
    formatted as a standard ISO character-encoding name like UTF-8 or ISO-8859-1.^([9](footnote.xhtml#ch11fn9))
    The most common character encoding is UTF-8 (represented in the locale name as
    `utf8`) since it can represent all characters in the world. It doesn’t represent
    all of them efficiently, however; some languages don’t use `utf8` because they
    require several bytes per character in this encoding.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点（`.`）后的部分表示 *`codeset`* 或字符编码，格式为标准 ISO 字符编码名称，如 UTF-8 或 ISO-8859-1。^([9](footnote.xhtml#ch11fn9))
    最常见的字符编码是 UTF-8（在区域设置名称中表示为 `utf8`），因为它可以表示世界上所有字符。然而，它并不是高效地表示所有字符；一些语言不使用 `utf8`，因为在这种编码中它们需要多个字节来表示每个字符。
- en: The *`modifier`* portion is not often used.^([10](footnote.xhtml#ch11fn10))
    One possible use is to generate a locale that differs only in case sensitivity,
    or in some other attribute that is not a normal locale attribute. For instance,
    when setting `LC_MESSAGES=en@``boldquot`, you get an English message set that
    differs from the normal English message set only in that quoted text is bolded.
    Another historically common case is where the `en_IE@eu``ro` locale is distinguished
    only by a difference in the currency symbol used. Suffice it to say that the differences
    applied by using a locale with a particular modifier are designed for very special
    use cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*`modifier`* 部分并不常用。^([10](footnote.xhtml#ch11fn10)) 其中一个可能的用途是生成一个仅在大小写敏感性或其他不是标准区域设置属性的属性上有所不同的区域设置。例如，当设置
    `LC_MESSAGES=en@``boldquot` 时，你会得到一个英语消息集，区别在于引用的文本是加粗的。另一个历史上常见的例子是 `en_IE@eu``ro`
    区域设置，仅通过使用不同的货币符号来区分。可以说，使用特定修改符的区域设置应用的差异是为非常特殊的用例设计的。'
- en: To generate and install a particular locale on a Debian- or Ubuntu-based system,
    you can add a file to the */var/lib/locales/supported.d* directory containing
    the line from *SUPPORTED* representing the locale you want to add. The name of
    the file added to the *supported.d* directory is not particularly important, although
    I advise not using filenames that are too far from something reasonably similar
    to what you find already in this directory structure. It’s only important that
    a file exists in that directory and that it contains the exact contents of the
    desired line from *SUPPORTED*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于 Debian 或 Ubuntu 的系统上生成并安装特定的区域设置，你可以在 */var/lib/locales/supported.d* 目录下添加一个文件，文件中包含来自
    *SUPPORTED* 的表示你要添加的区域设置的行。添加到 *supported.d* 目录中的文件名并不特别重要，尽管我建议不要使用与该目录结构中已有文件名称相差太远的名称。唯一重要的是该目录下存在一个文件，并且文件内容完全与
    *SUPPORTED* 中的相应行一致。
- en: 'For instance, to add `sv_SE.utf8`, I’d find the line in *SUPPORTED* that represents
    this language, add a file to *supported.d* containing this line, and then run
    the `locale-gen` program, in this manner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要添加 `sv_SE.utf8`，我会找到 *SUPPORTED* 中表示此语言的行，将该行添加到 *supported.d* 中的一个文件里，然后运行
    `locale-gen` 程序，步骤如下：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each line in *SUPPORTED* contains a locale database entry name, followed by
    a codeset name. For Swedish, the entry we’re interested in is `sv_SE.UTF-8`, with
    the `UTF-8` codeset. I chose to add a file called *sv* to */var/lib /locales/supported.d*.
    You may add as many lines as you want to the file; each line will be processed
    as a separate locale. Because the files in */var/lib/locale* are owned by root,
    you’ll need to have root-level permissions to create or write to them. I used
    a common trick involving the `tee` and `echo` commands to add the line I wanted
    to *supported.d/sv* as root.^([11](footnote.xhtml#ch11fn11)) You could also just
    use a text editor started with `sudo`, of course.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*SUPPORTED* 中的每一行包含一个语言环境数据库条目名称，后跟字符集名称。对于瑞典语，我们关注的条目是 `sv_SE.UTF-8`，字符集是
    `UTF-8`。我选择添加一个名为 *sv* 的文件到 */var/lib /locales/supported.d* 中。你可以向文件中添加任意多的行；每一行将被作为单独的语言环境处理。由于
    */var/lib/locale* 中的文件属于 root 用户，因此你需要具有 root 权限才能创建或写入它们。我使用了一个常见的小技巧，通过 `tee`
    和 `echo` 命令将我想要的行添加到 *supported.d/sv* 中，作为 root 用户。^([11](footnote.xhtml#ch11fn11))
    当然，你也可以直接使用带 `sudo` 的文本编辑器。'
- en: 'To generate a locale on a Red Hat– or CentOS-based system, you can use the
    `localedef` utility in this manner:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于 Red Hat 或 CentOS 的系统上生成语言环境，你可以以这种方式使用 `localedef` 工具：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-i` option on the `localedef` command line signifies the input file, which
    is taken from the output of the `localedef --list-archive` command. The `-f` option
    indicates the codeset to use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 选项在 `localedef` 命令行中表示输入文件，该文件来自 `localedef --list-archive` 命令的输出。`-f`
    选项表示使用的字符集。'
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’ve found that recent Red Hat (and therefore CentOS) systems generally come
    preinstalled with many locales. You may find, upon using *`locale -a`*, that you
    do not need to generate any locales. Anything that shows up in *`locale -a`* is
    immediately usable as a locale in the *`LANG`* and *`LC_*`* environment variables.
    Fedora systems, on the other hand, require the installation of language-specific
    langpacks, even if the locale shows up in the list displayed by *`locale -a`*.
    Swedish, for instance, requires the installation of glibc-langpack-sv. Additionally,
    the language sources do not seem to be installed on Fedora. Therefore, the *`localedef`*
    command will not work on that platform, but installation of the langpack will
    provide a precompiled version of the locale.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*我发现最近的 Red Hat（因此 CentOS）系统通常预装了许多语言环境。你可能会发现，通过使用 *`locale -a`*，你不需要生成任何语言环境。任何在
    *`locale -a`* 中显示的内容都可以立即作为 *`LANG`* 和 *`LC_*`* 环境变量中的语言环境使用。而 Fedora 系统则需要安装特定语言的语言包，即使该语言环境已显示在
    *`locale -a`* 列表中。例如，瑞典语需要安装 glibc-langpack-sv。此外，Fedora 上似乎没有安装语言源。因此，*`localedef`*
    命令在该平台上无法使用，但安装语言包后会提供语言环境的预编译版本。*'
- en: 'Now that we have a Swedish locale available to us, let’s see what’s displayed
    when we execute the `lc` program built from the code in [Listing 11-2](ch11.xhtml#ch11ex2)
    when using that locale:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以使用瑞典语语言环境了，让我们看看当我们使用该语言环境时执行来自 [Listing 11-2](ch11.xhtml#ch11ex2) 中代码的
    `lc` 程序时会显示什么：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately, as I mentioned earlier, `localeconv` only returns information
    on the numeric (`LC_NUMERIC`) and monetary (`LC_MONETARY`) categories, which isn’t
    quite as bad as it sounds because the remaining ones are handled nearly automatically
    for you by the library. Regardless, there are other options for accessing the
    complete set of locale attributes, which we’ll discuss later in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如我之前提到的，`localeconv` 只返回关于数字（`LC_NUMERIC`）和货币（`LC_MONETARY`）类别的信息，虽然听起来有点糟糕，但实际上其他类别几乎由库自动处理。无论如何，还有其他方式可以访问完整的语言环境属性，我们将在本章后面讨论。
- en: Formatting Time and Date for Display
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 格式化时间和日期以供显示
- en: 'The standard C library quietly handles time and date behind the scenes, depending
    on which format specifiers you use in the format string passed to `strftime`.
    Here’s the prototype for `strftime`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 C 库在后台安静地处理时间和日期，具体取决于你在传递给 `strftime` 的格式字符串中使用的格式说明符。以下是 `strftime` 的原型：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Briefly, the `strftime` function places up to *`max`* bytes in the buffer pointed
    to by *`s`*. The content is determined by the text and format specifiers in *`format`*.
    Only a single time value format can be specified in *`format`*, and its value
    is obtained from *`tm`*. Since this is a standard library function, you can refer
    to any standard C library manual for details on the way format specifiers work
    in this function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`strftime`函数将最多*`max`*字节放入由*`s`*指向的缓冲区。内容由*`format`*中的文本和格式说明符决定。在*`format`*中只能指定一个时间值格式，其值从*`tm`*中获得。由于这是一个标准库函数，你可以参考任何标准C库手册，了解格式说明符在此函数中的使用方式。
- en: '[Listing 11-3](ch11.xhtml#ch11ex3) provides the source code for a small program
    that prints the current time and date in a general format supported in some form
    by all languages and territories.^([12](footnote.xhtml#ch11fn12))'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-3](ch11.xhtml#ch11ex3)提供了一个小程序的源代码，该程序以某种形式输出当前时间和日期，这种格式被所有语言和地区支持。^([12](footnote.xhtml#ch11fn12))'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-3:* td.c: *A small program to print the calendar date and time
    in the environment locale*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3:* td.c: *一个小程序，用于在环境语言环境中打印日历日期和时间*'
- en: 'Building and executing this program displays something like the following output
    on the console; your times and dates will very likely not match mine:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并执行这个程序会在控制台显示类似以下的输出；你的时间和日期可能与我的不同：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I set `LC_ALL=C` on the first execution to show how you can execute your localized
    programs using the default C locale. This can be a handy debugging aid for testing
    your internationalized software.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第一次执行时设置了`LC_ALL=C`，以展示如何使用默认的C语言环境执行本地化程序。这对于测试你的国际化软件来说是一个很有用的调试工具。
- en: '**NOTE**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The C locale is not the “American” locale. Rather, it’s referred to as the
    minimal locale. If you execute the *`lc`* program with *`LC_ALL=C`*, you’ll find
    that many of the options are blank. The standard library expects and handles such
    blank options in an appropriate manner.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*C语言环境并不是“美国”语言环境。它被称为最简语言环境。如果你使用*`LC_ALL=C`*执行*`lc`*程序，你会发现许多选项为空。标准库期望并以适当方式处理这些空选项。*'
- en: Compare the English and Swedish outputs. The day and month names are in the
    locale language. For July, the month name happens to be the same in English and
    Swedish. However, notice the case difference in both day names and month names.
    In English, the names are capitalized, while in Swedish, they are not. Another
    difference is the 12-hour AM/PM time format in English and the 24-hour time format
    in Swedish. Swedish and C omit the leading zero on the day, whereas the US locale
    does not. Finally, the US time is followed by the Greenwich mean time zone name,
    `GMT`. There is only one time zone in Sweden—Central European Time, `CET`—and
    this fact is reflected in the simplicity of Sweden’s standard general time and
    date format.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 比较英文和瑞典文输出。日期和月份名称使用的是当地语言。对于七月，英文和瑞典文的月份名称恰好是一样的。然而，注意到日期和月份名称的大小写差异。在英文中，名称首字母大写，而在瑞典文中则不是。另一个区别是英文使用12小时制的AM/PM时间格式，而瑞典文使用24小时制时间格式。瑞典和C语言省略了日期前的零，而美国语言环境则没有。最后，美国时间后会跟随格林威治标准时间区（`GMT`）的名称，而瑞典只有一个时区——中欧时间（`CET`）——这一点反映在瑞典标准时间和日期格式的简洁性上。
- en: All of these differences are defined by the environment locale, but a quick
    glance at the code in [Listing 11-3](ch11.xhtml#ch11ex3) shows that I’m merely
    using the `%c` format specifier in the call to `strftime` in all cases. The effective
    locale is causing this format specifier to output general time and date information
    in a format specific to the locale.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些差异都由环境语言环境定义，但快速浏览[清单 11-3](ch11.xhtml#ch11ex3)中的代码，可以看到我仅在调用`strftime`时使用了`%c`格式说明符。有效的语言环境使得这个格式说明符根据具体语言环境输出通用的时间和日期信息。
- en: Not all of the format specifiers accepted by `strftime` are as helpful, however.
    For example, while using a format string like `"%X %D"` may seem like a good approach,
    it will not yield correct results in all locales. The `%X` specifier formats the
    time in a locale-specific manner, but `%D` formats the date in a very US-English
    way. Additionally, full time-date strings are formatted in different locales with
    the time and date portions in different orders. Later in the chapter, I’ll show
    you how to work around these issues with `nl_langinfo`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Collation and Character Classes
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s consider the less obvious categories—those whose information is not
    returned in `struct lconv`: `LC_COLLATE` and `LC_CTYPE`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`LC_COLLATE` affects the way the functions `strcoll` and `strxfrm` work. It’s
    more difficult for an English speaker to comprehend these functions’ inner workings
    because, in the English language, locale-specific comparisons of characters just
    happen to collate in the same order as their lexicographical orderings in the
    *ASCII* table.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*The original* American Standard Code for Information Interchange (ASCII) *was
    invented in 1963 by the* American Standards Association (ASA). *At first, it included
    only US English capital letters and numbers. In 1967, it was amended to include
    control characters and lowercase US English letters. Since the standard limited
    code length to 7 bits, it included only 128 characters, using the codes 0 through
    127\. This 7-bit limitation was imposed because the eighth bit in each byte was
    commonly used for error correction during data transmission. In 1981, IBM incorporated
    the ASCII code into the lower half of an 8-bit, 256-character code it named* code
    [page 437](ch16.xhtml#page_437) *and incorporated this code into the firmware
    of its IBM PC line of personal computers. In this chapter, when I mention the*
    ASCII table, *I’m actually referring to* code [page 437](ch16.xhtml#page_437).
    *Technically, ASCII is still limited to 128 characters.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: This is not the case in many other languages. For instance, in English and Spanish,
    the accented vowels sort properly immediately after their unaccented counterparts,
    while in Japanese, neither vowels nor accented vowels exist in the alphabet, so
    they sort according to their ordinal values in the ASCII table. Since all the
    accented vowels are in the upper half of the ASCII table and all non-accented
    vowels are in the lower half, it should be clear that the sort order of a list
    of Spanish words will be different when using an English or Spanish language locale
    than it will for any locales based on languages that don’t have Latin characters
    in their alphabet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](ch11.xhtml#ch11ex4) contains a short program that uses the C
    `qsort` function to sort a list of Spanish words using different comparison routines.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-4:* sc.c: *A short program that illustrates sort order differences
    between locales*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: First, the unsorted `words` list is printed to the console; then, the pointers
    in the `words` list are sorted with `qsort` using the `compare_lex` function,
    which uses `strcmp` to determine the collation order of the letters in each pair
    of words compared. The `strcmp` function doesn’t know anything about locales.
    It simply uses the order of the words’ letters in the ASCII table. Then the sorted
    list is printed to the console.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将未排序的`words`列表打印到控制台；接着，使用`compare_lex`函数通过`qsort`对`words`列表中的指针进行排序，`compare_lex`函数使用`strcmp`来确定每对单词中字母的排序顺序。`strcmp`函数不了解任何区域设置，它只是使用单词中字母在ASCII表中的顺序。然后，将排序后的列表打印到控制台。
- en: Next, `qsort` is called once again on `words`—this time using `compare_loc`,
    which uses `strcoll` to determine the sort order of the word pairs. The `strcoll`
    function uses the current locale to determine the relative order of the letters
    in the words being compared. The re-sorted list is then printed to the console.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次对`words`调用`qsort`——这次使用`compare_loc`，该函数使用`strcoll`来确定单词对的排序顺序。`strcoll`函数使用当前区域设置来确定被比较单词中字母的相对顺序。然后，将重新排序的列表打印到控制台。
- en: 'Building and executing this program with different locales displays the following
    output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的区域设置构建并执行该程序会显示以下输出：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: English and Spanish sort accented vowels the same way. The `C` locale, represented
    by the results obtained using `strcmp`, always sorts strictly according to the
    ASCII table. Japanese, however, sorts differently than the Latin languages because
    Japanese makes no assumptions about how characters (accented or otherwise) not
    found in its alphabet should be ordered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 英语和西班牙语的重音元音排序方式相同。`C`区域设置，由使用`strcmp`获得的结果表示，始终严格按照ASCII表排序。然而，日语的排序方式与拉丁语言不同，因为日语没有假设如何排序其字母表中未包含的字符（无论是否带有重音）。
- en: Internally, `strcoll` uses an algorithm to transform the characters in the comparison
    strings into numeric values that order naturally in the current locale; then it
    compares these byte arrays using the `strcmp` function. The algorithm used by
    `strcoll` can be pretty heavyweight because, for each set of two strings it compares,
    it transforms the locale-specific multibyte character sequences of these string
    pairs into sequences of bytes that can be compared lexicographically, by codeset
    ordinal values, and then internally compares those byte sequences using `strcmp`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`strcoll`使用一种算法将比较字符串中的字符转换为数字值，这些数字值在当前区域设置下自然排序；然后，它使用`strcmp`函数比较这些字节数组。`strcoll`使用的算法可能相当复杂，因为对于每一对它比较的字符串，它会将这些字符串对中的区域特定的多字节字符序列转换为可以按字典顺序比较的字节序列，通过字符集的顺序值，然后使用`strcmp`内部比较这些字节序列。
- en: If you know you’re going to be comparing the same string or set of strings,
    it can be much more efficient to use the `strxfrm` function first, which exposes
    the transformation algorithm that `strcoll` uses internally. You can then simply
    use `strcmp` against these transformed strings to obtain the same collation you’d
    get from `strcoll` against untransformed strings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己将比较相同的字符串或字符串集，那么先使用`strxfrm`函数可能会更高效，它暴露了`strcoll`在内部使用的转换算法。然后，你可以简单地对这些转换后的字符串使用`strcmp`，以获得与对未转换字符串使用`strcoll`时相同的排序结果。
- en: '[Listing 11-5](ch11.xhtml#ch11ex5) illustrates this process by converting the
    contents of [Listing 11-4](ch11.xhtml#ch11ex4) to use `strxfrm` on the words in
    the `words` array, writing the transformed words into a two-dimensional array
    large enough to hold the transformed strings.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-5](ch11.xhtml#ch11ex5)通过将[Listing 11-4](ch11.xhtml#ch11ex4)中的内容转换为使用`strxfrm`处理`words`数组中的单词，演示了这一过程，并将转换后的单词写入一个足够大的二维数组，以容纳转换后的字符串。'
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 11-5:* sx.c: *The `sc` program, rewritten to use `strxfrm`*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-5:* sx.c: *重写后的`sc`程序，使用`strxfrm`*'
- en: There are several items of note here. The `strxfrm` function returns a zero-terminated
    byte buffer that looks and acts like an ordinary C string. There are no internal
    null characters; it can be acted upon by other string functions in the standard
    C library, but it’s not necessarily intelligible from a human-readability standpoint.
    Because of this weird characteristic, the transform buffer contents can only be
    used for comparison purposes during sorting. The original input value must be
    used for display. Therefore, we need to keep track of, and sort as pairs, the
    input buffer and the transform buffer for each word in our list. The `element`
    structure at ➊ manages this for us.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。`strxfrm`函数返回一个以零终止的字节缓冲区，它看起来和行为像一个普通的C字符串。里面没有内置的空字符；它可以被标准C库中的其他字符串函数操作，但从人类可读性的角度来看，它不一定是易于理解的。由于这种奇怪的特性，转换缓冲区的内容只能在排序时用于比较目的。原始输入值必须用于显示。因此，我们需要跟踪并作为对进行排序，输入缓冲区和转换缓冲区的每对单词。`element`结构在
    ➊ 处为我们管理这一点。
- en: Since we no longer need to use `strcoll`, I’ve removed the `compare_loc` function
    and renamed `compare_lex` to `compare`, and I’ve changed the code to compare the
    `xfrmd` fields of the `element` structures passed in (at ➋). Note, however, that
    the `print_list` function still prints the `input` field of the elements (at ➌).
    This works because the `words` array has been converted to an array of pairs,
    where each element of the array contains both the original and the transformed
    words.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再需要使用`strcoll`，我已经移除了`compare_loc`函数，并将`compare_lex`重命名为`compare`，同时修改了代码以比较传入的`element`结构中的`xfrmd`字段（在
    ➋ 处）。但是需要注意的是，`print_list`函数仍然打印元素的`input`字段（在 ➌ 处）。之所以可行，是因为`words`数组已被转换为一个对数组，其中每个元素包含原始和转换后的单词。
- en: In order to make this code work with the original flow of `main` in *sc.c*,
    immediately after setting the locale, *sx.c* iterates over `words` (at ➍), setting
    each element’s `xfrmd` pointer to the same value as its `input` pointer. This
    allows us to see what happens when using `strcmp` on untransformed strings during
    the first call to `qsort`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码与*sc.c*中原始的`main`流程兼容，在设置本地化后，*sx.c*会遍历`words`（在 ➍ 处），将每个元素的`xfrmd`指针设置为与其`input`指针相同的值。这让我们能够看到在第一次调用`qsort`时使用`strcmp`对未转换字符串进行比较时发生了什么。
- en: At ➎, after printing the results of that first sort operation, the program iterates
    over `words` again, this time calling `strxfrm` on each input string and pointing
    the corresponding `xfrmd` field at a `strdup` copy of the transform buffer, `buf`.^([13](footnote.xhtml#ch11fn13))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，在打印完第一次排序操作的结果后，程序再次遍历`words`，这次对每个输入字符串调用`strxfrm`，并将相应的`xfrmd`字段指向转换缓冲区`buf`的`strdup`副本。^([13](footnote.xhtml#ch11fn13))
- en: 'Building and executing the code in [Listing 11-5](ch11.xhtml#ch11ex5) should
    show us the same output we got when we ran the code from [Listing 11-4](ch11.xhtml#ch11ex4):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并执行[示例 11-5](ch11.xhtml#ch11ex5)中的代码应该能显示出与我们运行[示例 11-4](ch11.xhtml#ch11ex4)中的代码时相同的输出：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s a bit more complicated—the value of this version is not immediately apparent
    when sorting five words, but the time savings over transforming the strings within
    `strcoll` is significant when sorting hundreds of strings, even with the overhead
    of allocating and freeing the transform buffers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它稍微复杂一点——这种版本的价值在排序五个单词时不立即显现出来，但在排序数百个字符串时，尽管有分配和释放转换缓冲区的开销，相比在`strcoll`内转换字符串，节省的时间是显著的。
- en: '**NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This sample takes shortcuts in order to highlight the important points of
    *`strxfrm`*. A real program would check the result of *`strxfrm`*, which returns
    the number of bytes required by the transformation (minus the terminating null
    character). If the value is larger than the buffer size specified, the program
    should reallocate and call *`strxfrm`* again. There is no reasonable way to predetermine
    the required buffer size for any given locale and codeset. I made my buffer large
    enough to handle just about any possibility, so I skipped this check for the sake
    of code readability, but this is not a recommended practice.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*此示例通过捷径突出显示*`strxfrm`*的重要点。一个真实的程序会检查*`strxfrm`*的结果，它返回转换所需的字节数（不包括终止的空字符）。如果返回值大于指定的缓冲区大小，程序应该重新分配内存并再次调用*`strxfrm`*。没有合理的方式可以预先确定任何给定区域和字符集所需的缓冲区大小。我将缓冲区设置得足够大，以应对几乎所有的可能性，因此为了代码可读性我跳过了此检查，但这不是推荐的做法。*'
- en: 'Now let’s turn our attention to the `LC_CTYPE` locale category. Changing this
    locale category affects the way most of the character classification functions
    in *ctype.h* work, including `isalnum`, `isalpha`, `isctrl`, `isgraph`, `islower`,
    `isprint`, `ispunct`, `isspace`, and `isupper` (but specifically not `isdigit`
    or `isxdigit`). It also affects the way `toupper` and `tolower` work—sort of.
    The fact is, the functions in *ctype.h* are broken in many ways with respect to
    internationalization. The problem is they rely on algorithmic mechanisms to convert
    character case, which work fine as long as you stick with the ASCII table. As
    soon as you leave this familiar playing field, however, all bets are off. Sometimes
    they work, and sometimes they don’t. The most consistent way to make them work
    is to use wide characters, because the wide-character versions of these functions
    are newer in the C and C++ standards and the UTF-16 and UTF-32 codesets allow
    for similar algorithmic conversion for an expanded set of characters. However,
    even when wide characters are used, there are still cases where the algorithmic
    approach fails to convert properly, as some languages have digraphs that come
    in three forms: lowercase, uppercase, and title case. There’s just no algorithmic
    way to deal properly with these types of situations.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The source code in [Listing 11-6](ch11.xhtml#ch11ex6) shows one way to properly
    convert a Spanish word from uppercase to lowercase.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-6:* ct.c: *Converting a Spanish word using wide characters*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This program doesn’t work if you change to `char` buffers and use UTF-8\. It
    barely works using wide characters. If you set `LC_ALL=C`, it prints only `orig:`
    because, had we checked the return value of `printf` in [Listing 11-6](ch11.xhtml#ch11ex6)
    (as we should do—especially when dealing with character set conversions like this),
    we’d have seen it return a `-1`, which is what it returns when it fails to convert
    a wide-character string to a multibyte string using `%ls`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Rather than cover all the nuances of what does and doesn’t work in the `LC_CTYPE`
    category, I’ll just say that if you have to do a lot of this sort of conversion
    and character classification, I’d highly recommend using a third-party library
    like IBM’s *International Components for Unicode (ICU)*^([14](footnote.xhtml#ch11fn14))
    or GNU libunistring^([15](footnote.xhtml#ch11fn15)) (both of which, to put it
    succinctly, just do the right thing in all cases). ICU is a large library, and
    there’s a bit of a learning curve, but it’s worth the effort if you need it. GNU
    libunistring is a little easier to get your head around, but it still presents
    a lot of new functionality. There are also wrapper libraries like *Boost::locale*,^([16](footnote.xhtml#ch11fn16))
    if you’re using C++, that make accessing ICU a bit simpler, although *Boost::locale*,
    itself, is pretty complex.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: X/Open and POSIX Standard Extensions
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s a shame there is not a standard C library function to format numeric and
    currency amounts by locale in the same manner that `strftime` formats time and
    date by locale. There is, however, an extension provided by the X/Open and POSIX
    standards and implemented in the GNU C library—the `strfmon` function, whose prototype
    is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，目前没有一个标准的C库函数能够像`strftime`根据区域设置格式化时间和日期那样格式化数字和货币金额。然而，X/Open和POSIX标准提供了一个扩展，并在GNU
    C库中实现了——`strfmon`函数，其原型如下：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It works very much like `strftime`, placing the formatted value string in the
    *`max`*-sized buffer pointed to by *`s`*. The *`format`* string works like the
    format strings in the `printf` family of functions and like that of `strftime`.
    The format specifiers are specific to this function but, like those of the other
    functions, begin with percent sign (`%`) and end with a format character. Several
    supported modifier characters may be used between the percent and the format character.
    The two valid format characters are `i` for international and `n` for local.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与`strftime`非常相似，将格式化后的值字符串放入由`s`指向的*`max`*大小的缓冲区中。*`format`*字符串的作用类似于`printf`系列函数中的格式字符串，以及`strftime`中的格式字符串。格式说明符是特定于此函数的，但与其他函数的格式说明符一样，都是以百分号（`%`）开始，并以格式字符结束。可以在百分号和格式字符之间使用几个支持的修饰符字符。两个有效的格式字符是`i`用于国际格式，`n`用于本地格式。
- en: This function is designed to format currency amounts and follows all the `localeconv`-provided
    `LC_CURRENCY` rules, but it can also be used to format decimal numbers according
    to `localeconv`-provided `LC_NUMERIC` rules. [Listing 11-7](ch11.xhtml#ch11ex7)
    provides example code for formatting a currency value in local and international
    formats without any special modifiers and for formatting a decimal number. Unlike
    `strftime`, `strfmon` can format multiple values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数旨在格式化货币金额，并遵循所有由`localeconv`提供的`LC_CURRENCY`规则，但它也可以根据`localeconv`提供的`LC_NUMERIC`规则来格式化十进制数字。[列表
    11-7](ch11.xhtml#ch11ex7)提供了不使用任何特殊修饰符来格式化本地和国际货币格式以及格式化十进制数字的示例代码。与`strftime`不同，`strfmon`可以格式化多个值。
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 11-7:* amount.c: *An example of calling `strfmon` to format currency
    and decimal values*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-7:* amount.c: *调用`strfmon`格式化货币和十进制数值的示例*'
- en: 'Let’s build and execute this program to see what’s displayed when using different
    locales:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并执行这个程序，看看使用不同区域设置时显示的内容：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the characteristics displayed by the `lc` program in [Listing 11-2](ch11.xhtml#ch11ex2)
    for monetary and numeric categories are taken into account by `strfmon` in the
    same manner the standard `strftime` function does for time and date characteristics.
    For instance, in both English and Japanese, the currency symbols are displayed
    before the values, while the Swedish currency symbols, `kr` and `SEK`, follow
    the value. The decimal separator is a comma in Sweden (and many other European
    locales), and Japanese yen values do not display a fractional part.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由`lc`程序在[列表 11-2](ch11.xhtml#ch11ex2)中显示的货币和数字类别的特性，都被`strfmon`以与标准`strftime`函数处理时间和日期特性相同的方式考虑。例如，在英语和日语中，货币符号显示在数值前面，而瑞典的货币符号`kr`和`SEK`则显示在数值后面。在瑞典（以及许多其他欧洲区域设置）中，小数分隔符是逗号，而日元值不显示小数部分。
- en: The exclamation mark (`!`) modifier in the decimal format specifier is used
    to suppress display of the currency symbol. By explicitly specifying a format
    precision, we can override the default Japanese locale characteristic that indicates
    that monetary values should not have a fractional part. The `strfmon` function
    was obviously designed for formatting currency values but, as we can see here,
    it can just as well be used to format plain old numeric decimal and integer values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制格式说明符中的感叹号（`!`）修饰符用于抑制货币符号的显示。通过显式指定格式精度，我们可以覆盖默认的日语区域设置特性，该特性指示货币值不应有小数部分。`strfmon`函数显然是为格式化货币值设计的，但正如我们在这里看到的，它同样可以用来格式化普通的十进制和整数数值。
- en: Overcoming localeconv’s Shortcomings
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 克服localeconv的局限性
- en: 'The X/Open and POSIX standards also provide a better and more functional version
    of `localeconv` called `nl_langinfo`. Here is the prototype for this function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: X/Open和POSIX标准还提供了一个更好、更具功能性的`localeconv`版本，称为`nl_langinfo`。以下是该函数的原型：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The advantages of this interface over the standard library interface are numerous.
    First, it’s more efficient, only acquiring and returning the field you request
    on an as-needed basis, rather than filling and returning the entire locale attribute
    structure for each request. The `nl_langinfo` function is used to acquire a single
    attribute, specified by *`item`*, of the global environment locale.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口相较于标准库接口有许多优势。首先，它更加高效，只在需要时获取和返回你请求的字段，而不是每次请求时都填充并返回整个区域设置属性结构。`nl_langinfo`函数用于获取由*`item`*指定的全局环境区域设置的单一属性。
- en: If your application is required to manage multiple locales simultaneously, check
    out the POSIX interface for managing multiple discrete locales within the same
    application. I won’t cover them in detail here because they manage the same set
    of locale categories as the interfaces I’ve already shown you. Instead, see the
    POSIX 2008 standard for information on the `newlocale`, `duplocale`, `uselocale`,
    and `freelocale` functions, in connection with the `nl_langinfo_l` function, which
    accepts a second argument of type `locale_t` returned by `newlocale`. I will mention
    that the `uselocale` function can be used to set the locale of the current thread.
    All of the functions I’ve mentioned so far are implemented by the GNU C library.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要同时管理多个区域设置，可以查看POSIX接口，用于在同一应用程序中管理多个离散的区域设置。我在这里不会详细讲解，因为它们管理的是与我已经展示给你的接口相同的区域设置类别。相反，请参阅POSIX
    2008标准，了解与`nl_langinfo_l`函数相关的`newlocale`、`duplocale`、`uselocale`和`freelocale`函数的信息，其中`nl_langinfo_l`函数接受一个类型为`locale_t`的第二个参数，这个参数是由`newlocale`返回的。我会提到，`uselocale`函数可用于设置当前线程的区域设置。到目前为止，我提到的所有函数都由GNU
    C库实现。
- en: The GNU C library also provides support for additional classes of locale information,
    including `LC_MESSAGES`, `LC_PAPER`, `LC_NAME`, `LC_ADDRESS`, `LC_TELEPHONE`,
    `LC_MEASUREMENT`, and `LC_IDENTIFICATION`. The `LC_MESSAGES` category has been
    standardized by POSIX and is the basis for *gettext*, which I’ll discuss shortly.
    The others are not standardized in C or POSIX, but they’ve been incorporated for
    many years into so many aspects of Linux, including Linux ports of the X Window
    System, that it’s hard to conceive of them being replaced or removed in the foreseeable
    future. Hence, I recommend their use if you do not intend to port your software
    outside of GNU tools.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C库还提供对额外类别的区域设置信息的支持，包括`LC_MESSAGES`、`LC_PAPER`、`LC_NAME`、`LC_ADDRESS`、`LC_TELEPHONE`、`LC_MEASUREMENT`和`LC_IDENTIFICATION`。`LC_MESSAGES`类别已经通过POSIX标准化，是*gettext*的基础，我稍后会讨论。其他类别在C或POSIX中并未标准化，但它们已经被纳入Linux的许多方面，包括X窗口系统的Linux移植版，已经很难想象它们在可预见的未来会被替换或移除。因此，如果你不打算将软件移植到GNU工具以外的地方，我建议使用它们。
- en: These additional categories are not accessible though `localeconv` and the `struct
    lconv` structure. Rather, you’ll need to use `nl_langinfo` to access the values
    in the locale that are associated with these categories.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的类别无法通过`localeconv`和`struct lconv`结构访问。相反，你需要使用`nl_langinfo`来访问与这些类别相关的区域设置值。
- en: '[Listing 11-8](ch11.xhtml#ch11ex8) is the same program found in [Listing 11-2](ch11.xhtml#ch11ex2),
    except that this version uses `nl_langinfo` to display the locale information
    available through that interface. It’s intentionally organized to display the
    content that’s common to both interfaces in exactly the same format.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-8](ch11.xhtml#ch11ex8)是与[示例 11-2](ch11.xhtml#ch11ex2)相同的程序，不同之处在于这个版本使用`nl_langinfo`来显示通过该接口提供的区域设置信息。它的组织方式刻意与两种接口显示相同内容，并保持完全相同的格式。'
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 11-8:* nl.c: *Using `nl_langinfo` to display available locale information*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-8:* nl.c: *使用 `nl_langinfo` 显示可用的区域设置信息*'
- en: 'To build this code, you need to add a couple of definitions to the command
    line: `_GNU_SOURCE` and `OUTER_LIMITS`. The first definition belongs to the GNU
    C library and allows *nl.c* to access the extended international monetary fields
    that were not part of the C standard until C99\. The second is my own invention
    that allows you to build the program without the extended categories provided
    by the GNU C library:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个代码，你需要在命令行中添加几个定义：`_GNU_SOURCE`和`OUTER_LIMITS`。第一个定义属于GNU C库，允许*nl.c*访问C99之前C标准中没有的扩展国际货币字段。第二个是我自己的发明，允许你在没有GNU
    C库提供的扩展类别的情况下构建程序：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The highlighted section of the preceding output shows the portion of `nl`’s
    output that goes beyond the `lc` program from [Listing 11-2](ch11.xhtml#ch11ex2).
    The additional locale categories are defined as follows.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出中突出显示的部分显示了`nl`输出中的一部分，超出了[Listing 11-2](ch11.xhtml#ch11ex2)中的`lc`程序。额外的区域类别定义如下。
- en: '**`LC_MESSAGES`**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_MESSAGES`**'
- en: This category provides one additional item value, `CODESET`, which defines the
    codeset used by this locale. This item is categorized under “Messages” because
    it’s intended to be helpful when translating static text messages in application
    code. The value can also be used as an environment variable on Linux systems in
    order to help select the static message catalog to be used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别提供一个额外的项目值，`CODESET`，它定义了该区域使用的字符集。该项目被归类为“消息”，因为它旨在帮助翻译应用程序代码中的静态文本消息。该值还可以作为环境变量在Linux系统上使用，以帮助选择要使用的静态消息目录。
- en: '**`LC_PAPER`**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_PAPER`**'
- en: The paper category provides two items, `_NL_PAPER_HEIGHT` and `_NL_PAPER_WIDTH`,
    which return paper dimensional values in millimeters for the most commonly used
    printer paper in the locale. This can be very helpful when formatting print output
    or when auto-selecting paper sizes—*letter* and *A04*, for example. Be aware that
    the pointer values returned from these item enumeration values should be treated
    like native-word-sized integer values, rather than as actual pointers. See the
    *nl.c* code in [Listing 11-8](ch11.xhtml#ch11ex8) for details.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 纸张类别提供两个项目，`_NL_PAPER_HEIGHT`和`_NL_PAPER_WIDTH`，它们返回该区域最常用打印纸张的纸张尺寸值（以毫米为单位）。这在格式化打印输出或自动选择纸张尺寸时非常有用——例如*letter*和*A04*。请注意，从这些项目枚举值返回的指针值应像本地字大小整数值一样对待，而不是实际的指针。有关详细信息，请参阅[Listing
    11-8](ch11.xhtml#ch11ex8)中的*nl.c*代码。
- en: '**`LC_NAME`**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_NAME`**'
- en: The name category provides information on formatting salutations such as Mr.,
    Mrs., Miss, and Ms. in the locale. The items in this category allow your software
    to automatically select how to state such salutations in the current language
    and territory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 名称类别提供关于格式化称呼（如先生、女士、小姐和女士）在该区域的相关信息。此类别中的项目允许你的软件自动选择如何以当前语言和地区陈述这些称呼。
- en: '**`LC_ADDRESS`**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_ADDRESS`**'
- en: The address category provides items that return geographical information for
    the locale, such as country name, postal code, and two- and three-letter country
    name abbreviations. It also returns the language name and library used by the
    locale.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 地址类别提供返回地理信息的项目，例如国家名称、邮政编码以及两字母和三字母的国家名称缩写。它还返回该区域使用的语言名称和库。
- en: '**`LC_TELEPHONE`**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_TELEPHONE`**'
- en: The telephone category provides format-specifier strings usable within the *printf*
    family of functions to display telephone numbers in a style that’s common in the
    current locale.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 电话类别提供格式化说明符字符串，可以在*printf*系列函数中使用，以在当前区域常见的样式中显示电话号码。
- en: '**`LC_MEASUREMENT`**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_MEASUREMENT`**'
- en: 'The measurement category provides a single item for returning the system of
    measurement used in the current locale. The `_NL_MEASUREMENT_MEASUREMENT` item
    returns a string whose first character is a short integer value: `0` for Metric
    or `1` for English.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测量类别提供一个项目，用于返回当前区域使用的度量系统。`_NL_MEASUREMENT_MEASUREMENT`项目返回一个字符串，其第一个字符是一个短整数值：`0`表示公制，`1`表示英制。
- en: '**`LC_IDENTIFICATION`**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**`LC_IDENTIFICATION`**'
- en: The identification category is actually locale metadata. That is, the fields
    of this category return information about the territory, author, and process used
    to create the current locale (for example, the locale author’s name, email address,
    phone number, and so on). It also returns versioning information about the locale.
    Be aware that the pointer value returned from `_NL_ADDRESS_COUNTRY_NUM` should
    be treated like a native-word-sized integer value rather than a pointer. See the
    *nl.c* code in [Listing 11-8](ch11.xhtml#ch11ex8) for details.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 标识类别实际上是区域元数据。也就是说，该类别的字段返回关于领土、作者以及创建当前区域所使用的过程的信息（例如，区域作者的姓名、电子邮件地址、电话号码等）。它还返回有关区域的版本信息。请注意，从`_NL_ADDRESS_COUNTRY_NUM`返回的指针值应被视为本地字大小整数值，而非指针。有关详细信息，请参阅[Listing
    11-8](ch11.xhtml#ch11ex8)中的*nl.c*代码。
- en: 'You can access the same information using the `-k` option with the `locale`
    command line program that comes preinstalled on your Linux distro, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Linux发行版中预装的`locale`命令行程序，使用`-k`选项访问相同的信息，如下所示：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can query the GNU C library `nl_langinfo` function for individual time-
    and date-formatting attributes such as AM and PM strings, various more granular
    format-specifier strings, and full and abbreviated days of the week and months
    of the year in the current locale.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The GNU C library `nl_langinfo` implementation even returns regular expressions
    intended to be used for matching query responses. The regular expressions returned
    from the `YESEXPR` and `NOEXPR` item enumeration values can be used to match *yes*
    or *no* answers to questions prompted by software.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*Instrumenting Source Code for Static Messages*'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instrumenting access to locale-specific static text messages in your source
    code is also part of the process of internationalizing software, so we’ll cover
    instrumentation of static text display messages here. Then we’ll move on to how
    to generate and consume language packs in [Chapter 12](ch12.xhtml), where I’ll
    discuss localization.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear by now that something needs to be done with the static portion
    of the “*`greeting`*, from *`progname`*!” text we printed from Jupiter (for example).
    I’m not going to take Jupiter any further, but it does provide a concise example
    of something that needs to change in our programs when the locale changes. The
    process of instrumenting source code for translating static display messages involves
    scanning your source code for all string literals that can be displayed to a user
    during the execution of a program and then doing something that makes it possible
    for the program to use a version of that string that specifically targets the
    current locale.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There are a few open source (and several third-party commercial) libraries that
    can be used to accomplish this task, but we’re going to focus on the GNU *gettext*
    library. The *gettext* library is very simple from a software perspective. In
    its simplest form, there’s one function for tagging a message to be translated
    and two functions for selecting the message catalog to be used for display. The
    tagging function is named `gettext`, and its prototype is shown in [Listing 11-9](ch11.xhtml#ch11ex9).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 11-9: The prototype for the `gettext` function*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts a message identifier in the *`msgid`* parameter and returns
    the display message to the user. The message identifier can be any string but
    is usually the display message itself, in US-ASCII. The reason for this is that
    if the message catalog cannot be found, `gettext` returns the *`msgid`* value
    itself, which will then be used by the program in the same way the translated
    message would have been used, had it been found. Thus, the `gettext` function
    cannot fail in a manner that will cause the program to not work in some reasonable
    fashion under any conceivable set of conditions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: This convention makes it very simple to both instrument existing programs and
    write new programs that use locale-based message catalogs. You simply need to
    find all of the static text messages within the program source files and wrap
    them in calls to `gettext`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, it’s necessary to provide the translator with more contextual
    information than just the string. For a common example, when providing message
    IDs for menu items such as the `Open` submenu option in the `File` menu, the programmer
    may have communicated to the translator that the programmer has provided the entire
    menu hierarchy in a format such as `|File|Open`. When the translator sees this,
    they know that only the portion following the last vertical bar symbol should
    be translated. But if there is no translation for the current locale, the message
    ID will be the full string. In this case, the programmer must write the code to
    check for a leading vertical bar. If it’s found, only the portion following the
    last vertical bar should actually be displayed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 11-10](ch11.xhtml#ch11ex10) shows a very short (and somehow
    familiar) example program that uses `gettext`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 11-10:* gt.c: *A short program that illustrates the use of the gettext
    library*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `printf` function sends the return value of `gettext` to `stdout`. The `gettext`
    function is exported by the GNU C library, so no additional libraries are required
    to use it. When using `gettext` without GNU C, just link the *intl* library (shared
    object or static archive).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'We could call `gettext` directly in `printf`, but the underscore (`_`) macro
    is a common idiom used when internationalizing software for two reasons: First,
    it decreases the visual impact of instrumenting an existing code base for *gettext*.
    Second, it allows us a single point of replacement if we choose to wrap `gettext`
    with additional functionality or if we decide to use a more functional variant
    of `gettext` (for example, `dgettext` and `dcgettext`). I haven’t discussed these
    variants here, but you can find out more about them in the *GNU C Library* manual.^([17](footnote.xhtml#ch11fn17))'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Message Catalog Selection
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Selection of the message catalog is done in two phases: the programmer phase
    and the user phase. The programmer phase is handled by the functions `textdomain`
    and `bindtextdomain`. The prototypes for these functions (also exported by the
    GNU C library) are shown in [Listing 11-11](ch11.xhtml#ch11ex11).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 11-11: The prototypes for `textdomain` and `bindtextdomain`*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The `textdomain` function allows the software author to determine the message
    catalog domain that is in use at any given point within the program. The domain
    represents a given message catalog containing some portion of the messages in
    a program. All strings extracted from the source code belonging to a specific
    domain end up in the message catalog for that domain.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A package may have several domains. The typical boundary between domains, and
    therefore between message catalogs, is an executable module— either a program
    or a library. For example, the *curl* package installs the command line `curl`
    program and the *libcurl.so* shared library. The *curl* library is designed to
    be used by both the `curl` program and by other third-party programs and libraries.
    If the *curl* package were internationalized, the package author might decide
    to use the *curl* domain for the `curl` program and the *libcurl* domain for the
    library so that third-party applications that use *libcurl* aren’t required to
    have the `curl` message catalog installed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包可能有多个域。域之间的典型边界，因此也就是消息目录之间的边界，是可执行模块——无论是程序还是库。例如，*curl*包安装了命令行`curl`程序和*libcurl.so*共享库。*curl*库设计为供`curl`程序和其他第三方程序及库使用。如果*curl*包进行了国际化，包的作者可能会决定为`curl`程序使用*curl*域，为库使用*libcurl*域，这样使用*libcurl*的第三方应用就不需要安装`curl`消息目录。
- en: The example used by the *GNU C Library* manual^([18](footnote.xhtml#ch11fn18))
    is one where *libc* itself uses `libc` as the domain name, but programs using
    *libc* would use their own domain. Simply put, the *`domainname`* parameter in
    these functions directly corresponds to a message catalog filename.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU C库*手册中使用的示例^([18](footnote.xhtml#ch11fn18))是*libc*本身使用`libc`作为域名，但使用*libc*的程序会使用自己的域名。简单来说，这些函数中的*`domainname`*参数直接对应一个消息目录文件名。'
- en: The `dirname` parameter in `bindtextdomain` is used to specify a base directory
    in which to search for the well-defined message catalog directory structure, which
    I’ll discuss shortly. Normally, the value passed in this parameter is the absolute
    path in the Automake `datadir` variable, suffixed with */locale*. Recall that
    `datadir` contains, by default, `$(prefix)`*/share* and `prefix` contains */usr/local*,
    so the full path used here would be */usr/local/share/locale*. For distribution-provided
    packages, `prefix` is more often simply */usr*, so the full path would then become
    */usr/share/locale*. It’s therefore up to the maintainer to ensure that `datadir`
    is available within the software (using techniques discussed in [Chapter 3](ch03.xhtml))
    and referenced in the argument passed to this parameter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindtextdomain`中的`dirname`参数用于指定一个基础目录，在该目录中搜索已定义的消息目录结构，我稍后会讨论这个结构。通常，传递给此参数的值是Automake
    `datadir`变量中的绝对路径，并以*/locale*结尾。回想一下，`datadir`默认包含`$(prefix)`*/share*，而`prefix`包含*/usr/local*，所以这里使用的完整路径将是*/usr/local/share/locale*。对于由发行版提供的包，`prefix`通常只是*/usr*，因此完整路径将变成*/usr/share/locale*。因此，维护者需要确保在软件中可以使用`datadir`（使用[第3章](ch03.xhtml)中讨论的技术），并在传递给该参数的参数中引用它。'
- en: '[Listing 11-12](ch11.xhtml#ch11ex12) shows how to add the code necessary to
    select the proper message catalog based on the current locale. Of course, we must
    first make the program aware of the current locale in the usual manner by calling
    `setlocale`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-12](ch11.xhtml#ch11ex12)展示了如何添加必要的代码来根据当前地区选择合适的消息目录。当然，我们必须先以通常的方式通过调用`setlocale`让程序了解当前地区。'
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 11-12:* gt.c: *Enhancements to enable the current locale and select
    the message catalog*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-12:* gt.c: *启用当前地区并选择消息目录的增强功能*'
- en: I’m using *gt* as the domain name here because that’s the name of the program.
    If this program were part of a package wherein all the components used the same
    domain, then the package name might be a better choice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用*gt*作为域名，因为这是程序的名称。如果这个程序是某个包的一部分，而包中的所有组件都使用相同的域名，那么包名可能是一个更好的选择。
- en: The directory name passed into `bindtextdomain`’s second parameter is derived
    from a future *config.h* inclusion. We’ll add that later when we incorporate this
    program into an Autotools build system. If we define `TEST_L10N` on the compiler
    command line, the directory name resolves to the value of the `PWD` environment
    variable, allowing us to test our program in any location containing the locale
    directory structure. (We’ll replace this hack later with a more Autotool-ish mechanism
    in [Chapter 12](ch12.xhtml).)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`bindtextdomain`第二个参数的目录名来源于将来*config.h*的包含。我们稍后会在将该程序集成到Autotools构建系统时添加它。如果在编译器命令行中定义了`TEST_L10N`，目录名将解析为`PWD`环境变量的值，从而允许我们在任何包含地区目录结构的位置测试程序。（我们将在[第12章](ch12.xhtml)中用更符合Autotool的机制替换这个临时方案。）
- en: That’s really all there is to instrumenting your code for message catalog lookup.
    In the next section, I’ll discuss how to generate and build message catalogs,
    which is part of the process of localizing a software package. I’ll also talk
    about the internal workings of the *gettext* library, which allows the user to
    select (during the user phase) the message catalog that should be used by their
    choice of environment variable settings.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为你的代码添加消息目录查找功能的全部内容。在下一部分，我将讨论如何生成和构建消息目录，这也是本地化软件包过程的一部分。我还将讲解*gettext*库的内部工作原理，该库允许用户在用户阶段选择应由其环境变量设置选择的消息目录。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, my goal was to give you enough background that you could easily
    continue learning about internationalizing your software projects. I’ve covered
    the C standard library functionality that’s designed to help you internationalize
    your software.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我的目标是为你提供足够的背景知识，让你能够轻松地继续学习如何使你的软件项目国际化。我已经涵盖了C标准库中帮助你进行软件国际化的功能。
- en: In the next chapter, we’ll continue our exploration of this topic by diving
    into localization. We’ll also discover how to tie all of this into the Autotools
    so that language packs get built and installed with `make` commands generated
    by Automake.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索这个话题，深入研究本地化。我们还将发现如何将这一切与Autotools结合，以便通过Automake生成的`make`命令构建和安装语言包。
