- en: '## **11'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **11'
- en: THE INTERNET**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: So far, we’ve focused on computing that occurs on a single device. In this chapter
    and the next, we look at computing that spans multiple devices. We’re going to
    examine two significant innovations in computing, the internet and the world wide
    web, which are not the same thing! This chapter focuses on the internet, and we
    begin by defining key terms. Then we look at a layered model of networks and dig
    into some of the foundational protocols used on the internet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关注的是单一设备上的计算。在本章和下一章中，我们将讨论跨多个设备的计算。我们将研究计算领域中的两项重要创新——互联网和万维网，它们是不同的！本章主要聚焦于互联网，我们首先定义一些关键术语。然后我们将介绍网络的分层模型，并深入探讨互联网使用的一些基础协议。
- en: '**Networking Terms Defined**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络术语定义**'
- en: To discuss the internet and networks in general, you first need to become familiar
    with some concepts and terms, which we cover here. A *computer* *network* is a
    system that allows computing devices to communicate with each other, as illustrated
    in [Figure 11-1](ch11.xhtml#ch11fig1). Networks can be connected wirelessly, using
    technologies like Wi-Fi, which transmits data using radio waves. Networks can
    also be connected with cables, such as copper wiring or fiber optics. Computing
    devices on a network must use a common *communications protocol*, a set of rules
    that describe how information is to be exchanged.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论互联网和网络，首先需要了解一些概念和术语，这里我们将进行介绍。一个*计算机* *网络*是一个允许计算设备相互通信的系统，如[图11-1](ch11.xhtml#ch11fig1)所示。网络可以通过无线方式连接，使用诸如Wi-Fi等技术，它通过无线电波传输数据。网络也可以通过电缆连接，如铜线或光纤。网络上的计算设备必须使用一个共同的*通信协议*，即一套描述信息如何交换的规则。
- en: '![image](../images/fig11-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-1.jpg)'
- en: '*Figure 11-1: A computer network*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：计算机网络*'
- en: The *internet* is a globally connected set of computer networks that all use
    a suite of common protocols. The internet is a *network of networks*, connecting
    networks from various organizations all around the world, as shown in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网*是一个全球互联的计算机网络系统，所有网络都使用一套共同的协议。互联网是一个*网络的网络*，连接了来自世界各地各种组织的网络，如[图11-2](ch11.xhtml#ch11fig2)所示。'
- en: '![image](../images/fig11-2.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-2.jpg)'
- en: '*Figure 11-2: The internet: a network of networks*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：互联网：网络的网络*'
- en: A *host* or *node* is a single computing device attached to a network. A host
    can act as a server or a client on the network, or sometimes both. A network *server*
    is a host that listens for inbound network connections and provides services to
    other hosts. Examples are a web server and an email server. A network *client*
    is a host that makes outbound connections and requests services from network servers.
    Example clients are smartphones or laptops running web browsers or email apps.
    A client makes a *request* to a server, and the server replies with a *response*,
    as illustrated in [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*主机*或*节点*是连接到网络的单个计算设备。主机可以作为网络上的服务器或客户端，或有时两者兼具。网络*服务器*是一个主机，它监听入站的网络连接并为其他主机提供服务。例子包括网页服务器和电子邮件服务器。网络*客户端*是一个主机，它发起出站连接并从网络服务器请求服务。客户端的例子包括运行网页浏览器或电子邮件应用程序的智能手机或笔记本电脑。客户端向服务器发出*请求*，服务器则通过*响应*进行回复，如[图11-3](ch11.xhtml#ch11fig3)所示。
- en: '![image](../images/fig11-3.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-3.jpg)'
- en: '*Figure 11-3: A client makes a request to a server, and the server responds*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：客户端向服务器发出请求，服务器作出响应*'
- en: The term *server*, as just used, refers to any device that accepts inbound requests
    and provides services to clients. However, *server* can also refer to a class
    of computer hardware that’s specifically intended to act as a network server.
    These specialized computers are physically designed to be mounted into racks of
    computers in a datacenter and often include hardware redundancy and management
    capabilities not found in a typical PC. However, any device with the right software
    can act as a server on a network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，*服务器*是指任何接受入站请求并为客户端提供服务的设备。然而，*服务器*也可以指一类专门设计用于作为网络服务器的计算机硬件。这些专用计算机通常被设计成可以安装在数据中心的计算机机架中，并且通常包含典型个人电脑中没有的硬件冗余和管理能力。然而，任何具备正确软件的设备都可以作为网络上的服务器。
- en: '**The Internet Protocol Suite**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**互联网协议套件**'
- en: Physically connecting the networks of the world isn’t enough to allow the devices
    on those networks to communicate with each other. All participating computers
    need to communicate in the same way. The *internet protocol suite* standardizes
    the method of communication on the internet, ensuring that all devices on the
    network speak the same language. The two foundational protocols in the internet
    protocol suite are *Transmission Control Protocol (TCP)* and *Internet Protocol
    (IP)*, collectively known as *TCP/IP*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将世界各地的网络物理连接起来并不足以让这些网络上的设备相互通信。所有参与的计算机需要以相同的方式进行通信。*互联网协议套件*标准化了互联网中的通信方式，确保网络上的所有设备使用相同的语言进行交流。互联网协议套件中的两个基础协议是*传输控制协议（TCP）*和*互联网协议（IP）*，统称为*TCP/IP*。
- en: Network protocols operate in a layered model, and an implementation of such
    a model is referred to as a *network stack* (not to be confused with a stack in
    memory, as covered in [Chapter 9](ch09.xhtml)). The protocols at the lowest layer
    interact with the underlying networking hardware, whereas applications interact
    with protocols in the upper layers. Protocols in the intermediate layers provide
    services such as addressing and reliable delivery of data. A protocol at a certain
    layer doesn’t have to concern itself with the entire networking stack, only the
    layers with which it interfaces, simplifying the overall design. This is another
    example of encapsulation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议在分层模型中运行，而这种模型的实现被称为*网络栈*（与[第9章](ch09.xhtml)中讨论的内存栈不同）。最底层的协议与底层网络硬件进行交互，而应用程序则与上层的协议进行交互。中间层的协议提供诸如寻址和数据可靠传输等服务。某一层的协议不需要关心整个网络栈，只需要关心与其交互的层，从而简化了整体设计。这是封装的另一个例子。
- en: The internet protocol suite is designed around a four-layer model. This is sometimes
    called the *TCP/IP model*. The four layers of the TCP/IP model, starting from
    the bottom up, are the link layer, the internet layer, the transport layer, and
    the application layer, as shown in [Figure 11-4](ch11.xhtml#ch11fig4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议套件是围绕四层模型设计的。这有时被称为*TCP/IP模型*。TCP/IP模型的四层，从下到上依次是链路层、互联网层、传输层和应用层，如[图11-4](ch11.xhtml#ch11fig4)所示。
- en: '![image](../images/fig11-4.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-4.jpg)'
- en: '*Figure 11-4: The internet protocol suite model of networking*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：互联网协议套件的网络模型*'
- en: '**OSI—ANOTHER NETWORK MODEL**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**OSI—另一个网络模型**'
- en: Another commonly used model for network protocols is the *Open Systems Interconnection
    (OSI) model*. The OSI model divides protocols into seven layers rather than four.
    This model is often referenced in technical literature, but the internet is based
    on the internet protocol suite, so this book focuses on the TCP/IP model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的网络协议模型是*开放系统互联（OSI）模型*。OSI模型将协议划分为七层，而不是四层。这个模型在技术文献中经常被提及，但互联网是基于互联网协议套件的，因此本书将重点讨论TCP/IP模型。
- en: These networking layers represent an abstraction, a model for us to use when
    discussing the operation of the internet. In practice, each layer is realized
    with specific networking protocols. Each network layer represents a scope of responsibilities,
    and protocols must fulfill the responsibilities of their assigned layer. [Table
    11-1](ch11.xhtml#ch11tab1) provides a description of each layer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网络层代表了一种抽象，是我们讨论互联网运作时使用的模型。在实际操作中，每一层都是通过特定的网络协议来实现的。每一层网络代表了一定的责任范围，协议必须履行其分配的层级责任。[表11-1](ch11.xhtml#ch11tab1)提供了每一层的描述。
- en: '**Table 11-1:** Description of the Four Layers of the Internet Protocol Suite'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**表11-1：** 互联网协议套件四层的描述'
- en: '| **Layer** | **Description** | **Example protocols** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **层级** | **描述** | **示例协议** |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Application | Protocols that operate at the application layer provide application-specific
    functionality, such as sending an email or retrieving a web page. These protocols
    accomplish tasks that end users (or backend services) wish to complete. Application
    layer protocols structure the data used in process-to-process communication across
    a network. All the lower layer protocols exist as “plumbing” to support the application
    layer. | HTTP, SSH |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 应用层 | 在应用层运行的协议提供特定应用功能，如发送电子邮件或检索网页。这些协议完成终端用户（或后端服务）希望完成的任务。应用层协议构造了用于网络中进程对进程通信的数据。所有较低层的协议作为“管道”来支持应用层。
    | HTTP, SSH |'
- en: '| Transport | Transport layer protocols provide a communications channel for
    applications to send and receive data between hosts. An application structures
    data according to an application layer protocol and then hands off that data to
    a transport layer protocol for delivery to a remote host. | TCP, UDP |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 传输层 | 传输层协议为应用提供了在主机之间发送和接收数据的通信通道。应用根据应用层协议构造数据，然后将这些数据交给传输层协议，送往远程主机。 |
    TCP, UDP |'
- en: '| Internet | Internet layer protocols provide a mechanism for communicating
    across networks. This layer is responsible for identifying hosts with addresses
    and enabling the routing of data from network to network across the internet.
    The transport layer relies on the internet layer for addressing and routing. |
    IP |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 网络层 | 网络层协议提供了一种跨网络通信的机制。该层负责通过地址标识主机，并使数据能够在互联网各网络之间进行路由。传输层依赖于网络层进行地址分配和路由。
    | IP |'
- en: '| Link | Link layer protocols provide a way to communicate on a local network.
    Protocols at this layer are closely associated with the type of networking hardware
    on a local network, such as Wi-Fi. Protocols at the internet layer rely on link
    layer protocols to communicate on a local network. | Wi-Fi, Ethernet |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 链路层 | 链路层协议提供了一种在本地网络上进行通信的方式。该层的协议与本地网络上的网络硬件类型（如 Wi-Fi）紧密相关。网络层协议依赖链路层协议在本地网络上进行通信。
    | Wi-Fi, Ethernet |'
- en: Protocols at each layer communicate with the protocols in adjacent layers. An
    outgoing transmission from a host travels down through the network layers, from
    an application layer protocol, to a transport layer protocol, to an internet layer
    protocol, and finally to a link layer protocol. An incoming transmission to a
    host travels up through the network layers, reversing the order just described.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层的协议与相邻层的协议进行通信。来自主机的外发传输通过网络层逐层传递，从应用层协议，到传输层协议，再到网络层协议，最后到链路层协议。主机接收的传输则从链路层协议开始，逐层向上传递，按照刚才描述的顺序逆向进行。
- en: Although network hosts (such as a client or server) make use of protocols from
    all four layers, other types of networking hardware (such as switches and routers)
    only use protocols associated with lower layers. Such devices can perform their
    jobs without bothering to examine the higher layer protocol data contained in
    a network transmission.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管网络主机（如客户端或服务器）会使用四层协议，但其他类型的网络硬件（如交换机和路由器）只使用与低层协议相关的协议。这些设备可以执行其工作，而无需查看网络传输中包含的高层协议数据。
- en: An outgoing request from a client to a server, and its relationship to the networking
    layers, is illustrated in [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 来自客户端到服务器的请求以及其与网络层的关系，如[图 11-5](ch11.xhtml#ch11fig5)所示。
- en: '![image](../images/fig11-5.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-5.jpg)'
- en: '*Figure 11-5: A network request travels through various network layers*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：网络请求穿越各网络层*'
- en: Let’s walk through the flow of [Figure 11-5](ch11.xhtml#ch11fig5). An application
    on the client device forms a request using an application layer protocol. That
    request is handed off to a transport layer protocol, then to an internet layer
    protocol, and finally to a link layer protocol. All of this happens on the client
    device. At this point the request is transmitted onto the local network, labeled
    Network 1 in the diagram. The request makes its way across the internet, going
    from network to network. In this example, Router A routes the request from Network
    1 to Network 2, and Router B routes the request from Network 2 to Network 3\.
    Once the request reaches the destination server, it works its way up through the
    networking protocols, starting with a link layer protocol, and ending at an application
    layer protocol. A process running on the server receives the request, which is
    formatted according to the application layer protocol originally used by the client.
    The server process interprets the request and responds in an appropriate manner.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步了解[图 11-5](ch11.xhtml#ch11fig5)的流程。客户端设备上的应用通过应用层协议生成一个请求。这个请求被交给传输层协议，再传递到网络层协议，最后到链路层协议。所有这些操作都在客户端设备上完成。此时，请求被传输到本地网络，如图中标示的网络
    1。请求跨越互联网，依次通过各个网络。在此例中，路由器 A 将请求从网络 1 路由到网络 2，路由器 B 将请求从网络 2 路由到网络 3。请求到达目标服务器后，会通过各网络协议向上传递，从链路层协议开始，到达应用层协议。服务器上运行的进程接收该请求，该请求按照客户端原本使用的应用层协议格式化。服务器进程解析请求并做出适当的响应。
- en: Let’s now take a look at each layer, starting from the bottom.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从底层开始，逐层查看。
- en: '***Link Layer***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链路层***'
- en: The lowest level of the internet protocol suite is the *link layer*. The physical
    and logical connections between hosts are known as network *links*. Link layer
    protocols are used by devices on the same network to communicate with each other.
    Each device on a link has a network address that uniquely identifies it. For many
    link layer protocols, this address is known as a *media access control address*
    (or *MAC address*). Link layer data is divided into small units known as *frames*,
    each including a header describing the frame, a payload of data, and finally,
    a frame footer used to detect errors. This is illustrated in [Figure 11-6](ch11.xhtml#ch11fig6).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议栈的最低层是*链路层*。主机之间的物理和逻辑连接被称为网络*链路*。链路层协议被同一网络上的设备用来相互通信。链路上的每个设备都有一个唯一标识其身份的网络地址。对于许多链路层协议，这个地址被称为*媒体访问控制地址*（或*MAC地址*）。链路层数据被分成称为*帧*的小单元，每个帧包括一个描述帧的头部、一个数据负载和最后用于检测错误的帧尾。具体内容如[图11-6](ch11.xhtml#ch11fig6)所示。
- en: '![image](../images/fig11-6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-6.jpg)'
- en: '*Figure 11-6: A link layer frame*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：链路层帧*'
- en: The frame header contains source and destination MAC addresses. The header also
    includes a descriptor of the type of data carried in the frame data section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 帧头包含源和目的MAC地址。头部还包括一个描述帧数据部分所承载数据类型的说明。
- en: If your home has a Wi-Fi network, Wi-Fi is the link between the hosts on your
    network. The Wi-Fi protocol, defined by the IEEE 802.11 specifications, doesn’t
    know or care what type of data is being sent over the wireless network; it simply
    enables communication between devices. Each device connected to the Wi-Fi network
    has a MAC address and receives frames sent to its address. MAC addresses are only
    useable on a local network; a computer on a remote network cannot directly send
    data to a MAC address on your local network.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的家里有Wi-Fi网络，Wi-Fi就是你网络上主机之间的链路。Wi-Fi协议由IEEE 802.11规范定义，它并不关心或知道无线网络上传输的数据类型；它只是使设备之间能够通信。每个连接到Wi-Fi网络的设备都有一个MAC地址，并接收发送到其地址的帧。MAC地址只在本地网络上有效；远程网络上的计算机不能直接向本地网络上的MAC地址发送数据。
- en: Another notable link layer technology is *Ethernet*, used for wired physical
    connections. Ethernet is defined by the IEEE 802.3 standards. Ethernet typically
    uses a cable with pairs of copper wires inside that ends in a connector commonly
    known as *RJ45*, shown in [Figure 11-7](ch11.xhtml#ch11fig7).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的链路层技术是*以太网*，它用于有线物理连接。以太网由IEEE 802.3标准定义。以太网通常使用内含铜线对的电缆，端口使用常见的*RJ45*连接器，如[图11-7](ch11.xhtml#ch11fig7)所示。
- en: '![image](../images/fig11-7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-7.jpg)'
- en: '*Figure 11-7: The cable commonly used for Ethernet*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-7：以太网常用的电缆*'
- en: All devices connected to the internet participate in the link layer. This is
    required, since it’s the link layer that provides connectivity (either wired or
    wireless) to a local network. A host, like a laptop or smartphone, participates
    in all layers, but certain networking devices operate at the link layer only.
    The most basic example of this is a hub. A *network hub* is a networking device
    that connects multiple devices on a local network without any intelligence regarding
    the frames being sent. A simple hub might provide multiple Ethernet ports for
    connecting devices. The hub simply retransmits every frame it receives on one
    physical port to all its other ports. A more intelligent link layer device is
    a *network switch*, which examines the MAC addresses in the frames it receives
    and sends those frames to the physical port where the device with the destination
    MAC address is connected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接到互联网的设备都参与链路层。这是必要的，因为正是链路层提供了本地网络的连接（有线或无线）。像笔记本电脑或智能手机这样的主机参与所有层次，但某些网络设备只在链路层工作。最基本的例子是集线器。*网络集线器*是一种网络设备，用于连接本地网络上的多个设备，但不具备处理发送帧的智能功能。一个简单的集线器可能提供多个以太网端口来连接设备。集线器只是将它接收到的每个帧从一个物理端口转发到所有其他端口。更智能的链路层设备是*网络交换机*，它会检查接收到的帧中的MAC地址，并将这些帧发送到目标MAC地址所在设备的物理端口。
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #29](ch11.xhtml#proj29) on [page 254](ch11.xhtml#page_254),
    where you can look at link layer devices and MAC addresses*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目#29](ch11.xhtml#proj29)在[第254页](ch11.xhtml#page_254)，在那里你可以查看链路层设备和MAC地址*。'
- en: '***Internet Layer***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网层***'
- en: The *internet layer* allows data to travel beyond the local network. The primary
    protocol used in this layer is simply called Internet Protocol (IP). It enables
    *routing*, the process of determining a path for data that’s transmitted between
    networks. Every host on the internet is assigned an *IP address*, a number that
    uniquely identifies the host on the global internet. It’s also possible to have
    private IP addresses that aren’t directly exposed on the internet. IP addresses
    are usually assigned by a server on the local network, and a device’s IP address
    typically changes when it connects to a new network. We’ll cover more on address
    assignment and private IP addresses later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网层*允许数据超越本地网络进行传输。该层使用的主要协议被称为互联网协议（IP）。它支持*路由*，即确定在网络之间传输数据路径的过程。互联网上的每个主机都分配一个*IP地址*，这是一个唯一标识全球互联网中主机的数字。也可以有私有IP地址，它们不会直接暴露在互联网上。IP地址通常由本地网络中的服务器分配，且设备的IP地址在连接到新网络时通常会发生变化。关于地址分配和私有IP地址的内容，我们将在后续部分进行详细介绍。'
- en: Data sent over the internet layer is called a *packet*, which is enclosed in
    a link layer frame. [Figure 11-8](ch11.xhtml#ch11fig8) illustrates the idea that
    a packet fits within a frame’s data section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网层发送的数据称为*数据包*，它被封装在链路层的帧中。[图 11-8](ch11.xhtml#ch11fig8)说明了数据包如何适应帧的数据部分。
- en: The IP packet header contains a source IP address and a destination IP address.
    The header also includes information that describes the packet, such as the IP
    version in use and the header length. The data section of the IP packet contains
    the payload that the IP layer is carrying.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: IP数据包头包含源IP地址和目标IP地址。头部还包括描述数据包的信息，例如正在使用的IP版本和头部长度。IP数据包的数据部分包含IP层携带的有效载荷。
- en: '![image](../images/fig11-8.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-8.jpg)'
- en: '*Figure 11-8: A packet is contained in the data section of a frame*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：数据包包含在帧的数据部分中*'
- en: Two versions of Internet Protocol are in use on the internet today. *Internet
    Protocol Version 4 (IPv4)* is the dominant version in use, and the other active
    version is *Internet Protocol Version 6 (IPv6)*. You may wonder what happened
    to IPv5\. No such protocol ever existed, but an experimental protocol called Internet
    Stream Protocol identified its IP version as 5, and so IPv5 was skipped when the
    successor to IPv4 was developed. A significant difference between IPv4 and IPv6
    is the size of an IP address. An IPv4 address is 32 bits in length, whereas an
    IPv6 address is 128 bits. This difference allows for a vastly larger number of
    addresses with IPv6\. This change in address size is meant to help deal with the
    relatively short supply of IPv4 addresses. In this book, we focus on IPv4 addresses
    (and just refer to them as *IP addresses*), as they are still the primary means
    of addressing on the internet today.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前互联网上使用两种版本的互联网协议。*互联网协议版本4（IPv4）*是当前使用的主要版本，另一个活跃的版本是*互联网协议版本6（IPv6）*。你可能会想，IPv5发生了什么？其实并没有这样的协议，但一个叫做互联网流协议的实验性协议将其IP版本标识为5，因此在IPv4的继任者开发时跳过了IPv5。IPv4和IPv6之间的一个重要区别是IP地址的大小。IPv4地址的长度为32位，而IPv6地址的长度为128位。这一差异使得IPv6可以提供更多的地址。这种地址大小的变化旨在帮助解决IPv4地址短缺的问题。在本书中，我们将重点介绍IPv4地址（并称之为*IP地址*），因为它们仍然是目前互联网上最主要的寻址方式。
- en: A 32-bit IP address is typically displayed in dotted decimal notation, meaning
    the 32 bits are separated into four groups of 8 bits each, the 8-bit numbers are
    displayed in decimal (rather than hexadecimal or binary), and the four decimal
    numbers are separated by periods (dots). An example IP address, displayed in dotted
    decimal notation, is 192.168.1.23\. Each 8-bit decimal number can be referred
    to as an *octet*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个32位的IP地址通常以点分十进制表示法显示，意味着32位被分成四组，每组8位，8位数字以十进制显示（而不是十六进制或二进制），四个十进制数字之间用句点（点）分隔。一个示例IP地址，以点分十进制表示法显示为192.168.1.23。每个8位的十进制数字可以称为*字节*。
- en: Computers connected to the same local network have IP addresses that begin with
    the same leading bits and are said to be on the same *subnet*. Computers that
    are on the same subnet are able to communicate directly with each other at the
    link layer because they are operating on the same physical network. Computers
    that are on different subnets must send their traffic through a *router*, a device
    that connects subnets and operates at the internet layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到同一本地网络的计算机具有以相同前导位开头的 IP 地址，且被认为处于同一个*子网*中。处于同一子网的计算机能够直接在链路层进行通信，因为它们在同一物理网络上运行。处于不同子网的计算机必须通过*路由器*发送其流量，路由器是一个连接子网并在互联网层上工作的设备。
- en: 'Subnetting divides the IP address into two parts: the *network prefix*, which
    all devices on the same subnet share, and the *host identifier*, which is unique
    to a host on that subnet. The number of bits included in the network prefix varies
    based on the network configuration.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 子网划分将 IP 地址分为两部分：*网络前缀*，同一子网中的所有设备共享此前缀；以及*主机标识符*，它是该子网上每台主机的唯一标识。网络前缀中包含的位数根据网络配置的不同而有所不同。
- en: Let’s look at an example. Assume a subnet uses a 24-bit network prefix, leaving
    us with 8 bits to represent the host. Also assume that a host on this subnet uses
    the example IP address from earlier—192.168.1.23\. Given this IP address and network
    prefix, the IP address is divided as shown in [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设一个子网使用 24 位网络前缀，剩余 8 位用于表示主机。还假设此子网中的一台主机使用之前的示例 IP 地址——192.168.1.23。根据这个
    IP 地址和网络前缀，IP 地址的划分如 [图 11-9](ch11.xhtml#ch11fig9) 所示。
- en: In this example, all hosts on the local subnet have an IP address that begins
    with 192.168.1\. Each host has a different value for the last octet, with `23`
    being assigned to this specific host. This example uses a 24-bit prefix length,
    meaning the prefix neatly aligns with the first three octets of the IP address.
    This makes for a nice example, but the prefix length doesn’t always align with
    an octet boundary. A 25-bit prefix, for example, would also include the first
    bit of the last octet, leaving only 7 bits for identifying the host.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，所有本地子网中的主机都有一个以 192.168.1\ 开头的 IP 地址。每台主机的最后一个八位字节的值不同，`23` 被分配给这台特定的主机。此示例使用了一个
    24 位前缀长度，意味着前缀与 IP 地址的前三个八位字节对齐。这是一个很好的示例，但前缀长度并不总是与八位字节边界对齐。例如，一个 25 位前缀也会包括最后一个八位字节的第一个位，留给主机的则只有
    7 位。
- en: '![image](../images/fig11-9.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-9.jpg)'
- en: '*Figure 11-9: An example IP address using a 24-bit network prefix*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：使用 24 位网络前缀的示例 IP 地址*'
- en: The number of bits reserved for the network prefix is commonly expressed in
    one of two ways. *Classless Inter-Domain Routing (CIDR) notation* lists an IP
    address followed by a slash (/), and then the number of bits used for the network
    prefix. In our example this would be 192.168.1.23/24\. Another common way to represent
    the number of prefix bits is with a *subnet mask*, a 32-bit number where a binary
    1 is used for each bit that’s part of the network prefix and a 0 is used for each
    bit that’s part of the host number. Subnet masks are also written in dotted decimal
    notation, so our example of a 24-bit network prefix would result in a subnet mask
    of 255.255.255.0, as shown in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示网络前缀的位数通常有两种方式。*无类域间路由（CIDR）符号*列出了一个 IP 地址，后跟一个斜杠（/），然后是用于网络前缀的位数。在我们的示例中，这将是
    192.168.1.23/24。表示前缀位数的另一种常见方法是使用*子网掩码*，它是一个 32 位的数字，其中每个属于网络前缀的位都用二进制 1 表示，而属于主机号的位用二进制
    0 表示。子网掩码也以点分十进制表示，因此我们这个 24 位网络前缀的示例会导致一个子网掩码为 255.255.255.0，如 [图 11-10](ch11.xhtml#ch11fig10)
    所示。
- en: '![image](../images/fig11-10.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-10.jpg)'
- en: '*Figure 11-10: A 24-bit network prefix expressed as a subnet mask*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：表示为子网掩码的 24 位网络前缀*'
- en: Let’s look at how this is useful in practice. Say your computer has an IP address
    of 192.168.0.133 and a subnet mask of 255.255.255.224, or, expressed in CIDR notation,
    192.168.0.133/27\. Your computer wishes to connect to another computer with an
    IP address of 192.168.0.84\. As mentioned earlier, two computers can communicate
    directly if they are on the same subnet, and if not, they must go through a router.
    So your computer must determine if the other computer is on the same subnet. How
    can it do this?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中如何发挥作用。假设你的计算机 IP 地址是 192.168.0.133，子网掩码是 255.255.255.224，或者以 CIDR
    表示法表示为 192.168.0.133/27\。你的计算机希望连接到另一台 IP 地址为 192.168.0.84\ 的计算机。如前所述，如果两台计算机在同一子网中，它们可以直接通信；如果不在同一子网中，它们必须通过路由器通信。那么，如何判断另一台计算机是否在同一子网呢？
- en: 'Performing a bitwise logical AND of an IP address and its subnet mask produces
    the first address in a subnet. This first address, where the host bits are all
    0, serves as an identifier for the subnet itself. This is commonly referred to
    as the *network ID*. Two computers that share a network ID are on the same subnet.
    A host can perform this AND operation against both its own IP address and the
    IP address it wishes to connect to, to see if they share a network ID and thus
    are on the same subnet. Let’s try this with our example computer’s IP address,
    as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对 IP 地址和其子网掩码执行按位逻辑与操作，得到子网中的第一个地址。这个第一个地址，其中主机位全为 0，作为子网本身的标识符。通常称之为*网络 ID*。共享网络
    ID 的两台计算机在同一子网中。主机可以对其自身的 IP 地址和希望连接的 IP 地址执行此与操作，以查看它们是否共享网络 ID，从而是否在同一子网中。我们可以用示例计算机的
    IP 地址来试一下，如下所示：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now perform the same operation for the second computer in our example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对我们示例中的第二台计算机执行相同的操作：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from this example, this operation produced two different network
    IDs (`192.168.0.128` and `192.168.0.64`). This means that the second computer
    is not on the same subnet as your computer. To communicate, these computers need
    to send their messages through a router connecting the two subnets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过这个操作，得出了两个不同的网络 ID（`192.168.0.128` 和 `192.168.0.64`）。这意味着第二台计算机不在与你的计算机同一子网中。为了进行通信，这两台计算机需要通过连接两个子网的路由器来发送消息。
- en: '**EXERCISE 11-1: WHICH IPS ARE ON THE SAME SUBNET?**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 11-1：哪些 IP 在同一子网？**'
- en: Is IP address 192.168.0.200 on the same subnet as your computer? Assume your
    computer has an IP address of 192.168.0.133 and a subnet mask of 255.255.255.224.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址 192.168.0.200 是否与你的计算机在同一子网中？假设你的计算机 IP 地址为 192.168.0.133，子网掩码为 255.255.255.224。
- en: 'Here’s another way to look at this: the network prefix describes the range
    of addresses that can be used on a subnet. The first address in that range is
    defined as the network prefix bits followed by all binary 0s for the host identifier.
    Continuing with our example computer at 192.168.0.133, the first address on its
    subnet is 192.168.0.128\. The last address in the range is the network prefix
    bits followed by all binary 1s for the host identifier. In our example that’s
    192.168.0.159\. The first and last addresses have special meanings—the first identifies
    the network, the last is the *broadcast address* (used for sending a message to
    all hosts on the subnet). All the addresses in between can be used for hosts on
    the subnet. Our example IP address of 192.168.0.133 is clearly in this range (from
    192.168.0.128 to 192.168.0.159), while the other computer with an IP address of
    192.168.0.84 is outside this range.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方法是：网络前缀描述了子网中可以使用的地址范围。该范围中的第一个地址被定义为网络前缀位，后跟所有主机标识符的二进制 0。继续以我们示例中的计算机
    192.168.0.133 为例，它所在子网的第一个地址是 192.168.0.128\。该范围中的最后一个地址是网络前缀位，后跟所有主机标识符的二进制 1。在我们的示例中，这个地址是
    192.168.0.159\。第一个和最后一个地址有特殊含义——第一个标识网络，最后一个是*广播地址*（用于向子网上所有主机发送消息）。其间的所有地址可以用于子网中的主机。我们示例中的
    IP 地址 192.168.0.133 显然在此范围内（从 192.168.0.128 到 192.168.0.159），而另一台 IP 地址为 192.168.0.84
    的计算机则不在该范围内。
- en: 'You can also use the number of bits reserved for the host identifier to determine
    how many IP addresses are available for hosts on a subnet. In our example, 27
    bits are reserved for the network prefix, leaving 5 bits for host identifiers.
    These 5 bits give us 32 possible host addresses, since 2⁵ is 32\. However, as
    mentioned earlier, the first and last addresses have special purposes, so really
    only 30 hosts can be identified using this network prefix. This aligns with our
    earlier findings: the first host identifier is 128, and 128 + 32 gives us 160,
    the first address in the next subnet, so 159 would be the last host in our range.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过查看为主机标识符保留的位数来确定子网中可用于主机的 IP 地址数量。在我们的示例中，27 位保留用于网络前缀，剩余 5 位用于主机标识符。这
    5 位提供了 32 个可能的主机地址，因为 2⁵ 等于 32。然而，正如前面所提到的，第一个和最后一个地址有特殊用途，因此实际上只能使用这个网络前缀识别 30
    个主机。这与我们之前的结论一致：第一个主机标识符是 128，128 + 32 给出的是 160，这是下一个子网中的第一个地址，因此 159 将是我们的地址范围中的最后一个主机。
- en: '**NOTE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #30](ch11.xhtml#proj30) on [page 255](ch11.xhtml#page_255),
    where you can look at the internet layer using your Raspberry Pi*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #30](ch11.xhtml#proj30) 在 [第 255 页](ch11.xhtml#page_255)，你可以通过你的 Raspberry
    Pi 查看互联网层*'
- en: '***Transport Layer***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传输层***'
- en: 'The *transport layer* provides a communications channel that applications may
    use to send and receive data. There are two commonly used transport layer protocols:
    Transmission Control Protocol (TCP) and *User Datagram Protocol (UDP)*. TCP provides
    a reliable connection between two hosts. It ensures that errors are minimized,
    data arrives in order, lost data is resent, and so forth. Data sent with TCP is
    known as a *segment*. On the other hand, UDP is a “best effort” protocol, meaning
    its delivery is unreliable. UDP is preferred when speed is valued over reliability.
    Data sent with UDP is known as a *datagram*. Both protocols have their place,
    but to keep things simple, I cover only TCP for the remainder of the chapter.
    [Figure 11-11](ch11.xhtml#ch11fig11) illustrates the idea that a TCP segment fits
    within a packet’s data section, which in turn fits within a frame’s data section.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层* 提供了一个通信通道，应用程序可以使用它来发送和接收数据。传输层有两个常用的协议：传输控制协议（TCP）和 *用户数据报协议（UDP）*。TCP
    提供两个主机之间的可靠连接。它确保最小化错误，数据按顺序到达，丢失的数据会被重发，等等。使用 TCP 发送的数据被称为 *段*。另一方面，UDP 是一种“尽力而为”的协议，这意味着它的传输是不可靠的。UDP
    在速度比可靠性更重要的情况下更受青睐。使用 UDP 发送的数据被称为 *数据报*。这两种协议各有其用，但为了简单起见，接下来的章节中我只讲解 TCP。 [图
    11-11](ch11.xhtml#ch11fig11) 展示了一个 TCP 段如何嵌入到数据包的数据部分中，而数据包又嵌入到帧的数据部分中。'
- en: As we saw earlier, the link layer includes a destination MAC address in the
    frame header to identify a local network interface, and the internet layer includes
    a destination IP address in the packet header to identify the host on the internet.
    That’s enough information to get a packet to a specific device on the internet.
    Once a packet has reached its destination host, the transport layer header includes
    a destination network *port number* that identifies the specific service or process
    that will receive the data. A host with a single IP address can have multiple
    active ports, each used for performing a different type of activity on the network.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，链路层在帧头中包括目标 MAC 地址来识别本地网络接口，互联网层在数据包头中包括目标 IP 地址来识别互联网中的主机。这些信息足以将数据包传送到互联网中的特定设备。一旦数据包到达目标主机，传输层头部会包括目标网络
    *端口号*，用于标识将接收数据的特定服务或进程。一个拥有单一 IP 地址的主机可以有多个活跃端口，每个端口用于执行不同类型的网络活动。
- en: '![image](../images/fig11-11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-11.jpg)'
- en: '*Figure 11-11: A TCP segment is contained in the data section of an IP packet*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：TCP 段包含在 IP 数据包的数据部分中*'
- en: To use an analogy, an IP address is like the street address of an office building,
    and a network port number is like the office number of a worker in that office
    building. The IP address uniquely identifies a host computer, just as a street
    address uniquely identifies an office building. Using internet protocol, a packet
    can be delivered to a host in the same way that a package can be delivered to
    an office building. However, once a packet arrives at the computer, the operating
    system must decide what to do with it. The packet isn’t intended for the OS itself,
    but for some process running on the computer. In the same way, a package arriving
    at an office building likely isn’t intended for the mailroom worker but for someone
    else in the building. An operating system examines the port number and delivers
    the inbound data to the process listening on the specified port, just as a mailroom
    worker examines the name or office number on the package to deliver the package
    to the right person.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个类比来说明，IP 地址就像办公大楼的街道地址，而网络端口号就像该办公大楼中某个员工的办公室号码。IP 地址唯一标识一台主机计算机，就像街道地址唯一标识一座办公大楼一样。通过互联网协议，数据包可以像包裹送到办公大楼一样送到主机。然而，一旦数据包到达计算机，操作系统必须决定如何处理它。数据包并不是送给操作系统本身的，而是送给计算机上某个正在运行的进程。同样，包裹到达办公大楼后，可能并不是送给邮局工作人员的，而是送给大楼里其他某个人的。操作系统检查端口号，将传入的数据送到在指定端口上监听的进程，就像邮局工作人员检查包裹上的姓名或办公室号码，将包裹送到正确的人手中。
- en: Network ports in the range of 0 to 1,023 are called *well-known ports*, whereas
    ports in the range of 1,024 to 49,151 can be registered with the Internet Assigned
    Numbers Authority (IANA) and are known as *registered ports*. Ports with a value
    greater than 49,151 are *dynamic ports*. Technically, any process with sufficient
    privileges can listen on any port that isn’t already in use on a system, potentially
    ignoring the typical use case for that port number. However, when a client application
    wishes to connect to a remote service on another computer, it needs to know what
    port to use, so it makes sense to standardize port numbers. For example, web servers
    typically listen on port 80 and port 443 (for encrypted connections). A web browser
    assumes that it should use port 80 or 443 unless directed otherwise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号范围从 0 到 1,023 的网络端口称为*知名端口*，而端口号范围从 1,024 到 49,151 的端口可以在互联网分配号码局（IANA）注册，称为*注册端口*。大于
    49,151 的端口是*动态端口*。从技术上讲，任何具有足够权限的进程都可以在任何未被系统占用的端口上监听，可能会忽略该端口号的典型使用案例。然而，当客户端应用程序希望连接到另一台计算机上的远程服务时，它需要知道使用哪个端口，因此标准化端口号是有意义的。例如，Web
    服务器通常监听端口 80 和端口 443（用于加密连接）。除非另行指示，Web 浏览器会假定应使用端口 80 或 443。
- en: '**EXERCISE 11-2: RESEARCH COMMON PORTS**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 11-2：研究常见端口**'
- en: 'Find the port numbers for common application layer protocols. What are the
    port numbers for Domain Name System (DNS), Secure Shell (SSH), and Simple Mail
    Transfer Protocol (SMTP)? You can find this information online with a search,
    or by looking at the IANA registry, here: *[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)*.
    The IANA listings sometimes use an unexpected term for the service name. For example,
    DNS is simply listed as “domain.”'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 查找常见应用层协议的端口号。域名系统（DNS）、安全外壳协议（SSH）和简单邮件传输协议（SMTP）的端口号是多少？你可以通过在线搜索或查看 IANA
    注册表找到这些信息，网址是：*[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)*。IANA
    列表有时会使用意想不到的术语来表示服务名称。例如，DNS 仅被列为“domain”。
- en: Servers use well-known ports to make it easy for clients to connect. However,
    most network communication is a two-way street (a client sends a request and a
    server responds), so the client needs to have an open port as well so that it
    can receive data from the server. A client only needs to temporarily open such
    a port, just long enough for it to complete its communication with a server. Such
    ports are called *ephemeral ports* and are assigned by the networking components
    in the operating system. For example, a client web browser connects to a web server
    on port 80, and an ephemeral port on the client is also opened, let’s say port
    number 61,348\. The client sends its web request to port 80 on the server, and
    the server sends its response to port 61,348 on the client.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用知名端口以方便客户端连接。然而，大多数网络通信是双向的（客户端发送请求，服务器响应），因此客户端也需要有一个开放的端口，以便接收来自服务器的数据。客户端只需暂时打开这样的端口，足够完成与服务器的通信即可。这样的端口称为*临时端口*，由操作系统中的网络组件分配。例如，客户端网页浏览器连接到服务器的
    80 端口，客户端上也会打开一个临时端口，假设是端口号 61,348。客户端将其网页请求发送到服务器的 80 端口，服务器则将响应发送到客户端的 61,348
    端口。
- en: An IP address plus a port number form an *endpoint*, and an instance of an endpoint
    is known as a *socket*. A socket can listen for new connections, or it can represent
    an established connection. If multiple clients connect to the same endpoint, each
    has its own socket.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IP 地址加上一个端口号构成一个*端点*，而一个端点的实例称为*套接字*。一个套接字可以监听新的连接，或者它可以代表一个已建立的连接。如果多个客户端连接到同一个端点，每个客户端都有自己独立的套接字。
- en: '**NOTE**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #31](ch11.xhtml#proj31) on [page 256](ch11.xhtml#page_256),
    where you can look at the port usage of your Raspberry Pi*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目 #31](ch11.xhtml#proj31)在[第256页](ch11.xhtml#page_256)，在这里您可以查看 Raspberry
    Pi 的端口使用情况*。'
- en: '***Application Layer***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用层***'
- en: The *application layer* is the final, topmost layer of the internet protocol
    suite. While the lower three layers provide a generalized foundation for communication
    over the internet, the protocols at the application layer focus on accomplishing
    a specific task. For example, web servers use *HyperText Transfer Protocol (HTTP)*
    for retrieving and updating web content. Email servers use *Simple Mail Transfer
    Protocol (SMTP)* for sending and receiving email messages. File transfer servers
    use *File Transfer Protocol (FTP)* to, you guessed it, transfer files! In other
    words, the application layer is where we get to the protocols that describe the
    behavior of applications, whereas the lower layers of the stack are the “plumbing”
    that enables applications to do the things they want to do over the internet.
    [Figure 11-12](ch11.xhtml#ch11fig12) provides a completed view of the four layers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用层*是互联网协议栈的最终、最上层。虽然下三层为互联网通信提供了通用的基础，但应用层的协议专注于完成特定的任务。例如，Web 服务器使用*超文本传输协议（HTTP）*来检索和更新网页内容；邮件服务器使用*简单邮件传输协议（SMTP）*来发送和接收电子邮件；文件传输服务器使用*文件传输协议（FTP）*来，没错，就是传输文件！换句话说，应用层是我们接触到描述应用程序行为的协议的地方，而栈的较低层则是使应用程序能够在互联网上完成其任务的“管道”。[图11-12](ch11.xhtml#ch11fig12)提供了四个层次的完整视图。'
- en: '![image](../images/fig11-12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-12.jpg)'
- en: '*Figure 11-12: The application layer’s data is contained in the segment’s data
    section.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-12：应用层的数据包含在段的数据部分中。*'
- en: '[Figure 11-12](ch11.xhtml#ch11fig12) is a breakout view of how each layer fits
    in the lower layer’s data payload. Assembling all the layers together in [Figure
    11-13](ch11.xhtml#ch11fig13), we can see a representation of what is contained
    in a frame sent to a device on the internet.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-12](ch11.xhtml#ch11fig12)展示了每个层次如何适配低层数据负载的视图。将所有层次组合在一起，参见[图11-13](ch11.xhtml#ch11fig13)，我们可以看到发送到互联网设备的帧所包含的内容。'
- en: '![image](../images/fig11-13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-13.jpg)'
- en: '*Figure 11-13: A frame containing an IP packet, a TCP segment, and application
    data*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-13：包含IP数据包、TCP段和应用数据的帧*'
- en: We’ve walked through the contents of a network frame from the bottom up, starting
    with the layer closest to hardware. When a frame is received by a host, it is
    processed by the host in that same order, from the link layer up to the application
    layer. In contrast, when a frame is sent from a host, the frame is assembled in
    the reverse order. A process prepares application data that is enclosed in a segment,
    a packet, and finally, a frame.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从下到上地走了一遍网络帧的内容，从最接近硬件的层开始。当一个帧被主机接收时，它会按照相同的顺序处理，从链路层到应用层。相反，当一个帧从主机发送时，帧会以相反的顺序组装。一个过程准备好应用数据，数据最终被封装在一个段、一个包，最后是一个帧中。
- en: '**A Trip Through the Internet**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**互联网之旅**'
- en: Now that you’re familiar with each of the four layers in the TCP/IP networking
    model, let’s look at an example of how data travels across the internet. We’ll
    see how various devices along the way interact with each of the networking layers.
    [Figure 11-14](ch11.xhtml#ch11fig14) illustrates this, showing a client in the
    upper left communicating with a server in the lower left.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 TCP/IP 网络模型中的四个层次，让我们通过一个例子来看数据是如何在互联网中传输的。我们将看到沿途的各种设备如何与每个网络层进行交互。[图
    11-14](ch11.xhtml#ch11fig14) 说明了这一点，展示了左上方的客户端如何与左下方的服务器进行通信。
- en: '![image](../images/fig11-14.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-14.jpg)'
- en: '*Figure 11-14: Different devices interact at different layers of the networking
    stack*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-14：不同设备在网络栈的不同层次进行交互*'
- en: I’ll set up the scenario in [Figure 11-14](ch11.xhtml#ch11fig14). A client device
    (upper left of diagram) is connected to a wireless Wi-Fi network. That network
    is connected to the internet via a router. Somewhere else we have a server (lower
    left of diagram), which has a wired connection to the internet through a switch
    and router. A user of the client device opens a web browser and requests a web
    page hosted on the server. For simplicity, let’s assume that the client already
    knows the IP address of the server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 [图 11-14](ch11.xhtml#ch11fig14) 中设置场景。一个客户端设备（图示左上角）连接到一个无线 Wi-Fi 网络。该网络通过路由器连接到互联网。在图示的另一个位置，我们有一台服务器（图示左下角），它通过交换机和路由器与互联网建立有线连接。客户端设备的用户打开网页浏览器，向服务器请求一个网页。为了简便起见，我们假设客户端已经知道服务器的
    IP 地址。
- en: The web browser on the client “speaks” HTTP, the application layer protocol
    of the web, so it forms an HTTP request intended for the destination server. The
    browser then hands off the HTTP request to the operating system’s TCP/IP software
    stack, asking that the data be delivered to the server—specifically the server’s
    IP address and port 80, the standard port for HTTP. The TCP/IP software stack
    on the client operating system then encapsulates the HTTP payload in a TCP segment
    (transport layer), setting the destination port to 80 in the segment header. If
    necessary, TCP divides the application layer data into multiple segments, each
    with its own header. The internet layer software on the client then wraps the
    TCP segment in an IP packet, which includes the destination IP address of the
    server in the packet header. If necessary, IP divides the packet into multiple
    smaller fragments in preparation for transmission over the network link. At the
    link layer on the client, the IP packet is encapsulated in a frame with the MAC
    address of the local router in its header. This frame is wirelessly transmitted
    by the client device’s Wi-Fi hardware.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端上的网页浏览器使用 HTTP 语言，这是 web 的应用层协议，因此它会形成一个面向目标服务器的 HTTP 请求。浏览器随后将 HTTP 请求交给操作系统的
    TCP/IP 软件栈，请求将数据传送到服务器——特别是服务器的 IP 地址和端口 80，HTTP 的标准端口。客户端操作系统上的 TCP/IP 软件栈随后将
    HTTP 负载封装在一个 TCP 段中（传输层），并在段头中设置目标端口为 80。如果需要，TCP 会将应用层数据分割成多个段，每个段都带有自己的头部。客户端的互联网层软件随后将
    TCP 段封装在一个 IP 包中，该包在头部包含服务器的目标 IP 地址。如果需要，IP 会将数据包分割成多个更小的片段，为通过网络链路的传输做好准备。在客户端的链路层，IP
    包被封装在一个帧中，帧头部包含本地路由器的 MAC 地址。该帧通过客户端设备的 Wi-Fi 硬件无线传输。
- en: The wireless access point receives the frame. The access point, operating at
    the link layer, sends the frame along to the router. The router examines the internet
    layer packet to determine the destination IP address. To reach the server, the
    request needs to travel through multiple routers on the internet. The local router
    encapsulates the packet in a new frame, with a new destination MAC address (the
    address of the next router), and sends the new frame on its way. This routing
    process continues through multiple routers on the internet until the request reaches
    the router on the subnet where the server is connected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无线接入点接收该帧。接入点在链路层操作，将帧发送给路由器。路由器检查互联网层的数据包以确定目标IP地址。为了到达服务器，请求需要通过互联网上的多个路由器。当地路由器将数据包封装成一个新的帧，带有新的目标MAC地址（下一个路由器的地址），并将新帧发送出去。这个路由过程会在互联网上经过多个路由器，直到请求到达与服务器连接的子网上的路由器。
- en: The last router encapsulates the packet in a frame suitable for the server’s
    local network. This frame’s header includes the MAC address of the server. The
    switch on the server’s subnet looks at the MAC address in the frame and forwards
    the frame out the appropriate physical port. There’s no need for the switch to
    look at any higher layers. The server receives the frame, and the driver for the
    network interface passes the TCP/IP packet up to the TCP/IP software stack, which
    in turn, hands off the HTTP data to the process listening on TCP port 80\. Web
    server software, listening on port 80, handles the request. This includes replying
    to the client, and to do that, this entire process happens again, except in reverse
    order.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的路由器将数据包封装成适合服务器本地网络的帧。这个帧的头部包含服务器的MAC地址。服务器子网上的交换机查看帧中的MAC地址，并将帧转发到合适的物理端口。交换机无需查看更高层的信息。服务器接收到帧后，网络接口的驱动程序将TCP/IP数据包传递给TCP/IP软件栈，接着将HTTP数据交给监听TCP端口80的进程。监听80端口的Web服务器软件处理请求。这包括回复客户端，为此，整个过程会再次发生，只不过顺序是反向的。
- en: '**NOTE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #32](ch11.xhtml#proj32) on [page 258](ch11.xhtml#page_258),
    where you can see the route from your Raspberry Pi to a host on the internet*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #32](ch11.xhtml#proj32)，该项目位于[第258页](ch11.xhtml#page_258)，在其中你可以看到从你的Raspberry
    Pi到互联网上主机的路由*'
- en: '**Foundational Internet Capabilities**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基础互联网功能**'
- en: Whereas TCP/IP provides the necessary plumbing for reliable transfer of data
    across the internet, other protocols provide additional foundational internet
    capabilities. These features are implemented as application layer protocols. Let’s
    now look at two such protocols (DHCP and DNS) and a system for translating IP
    addresses (NAT).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TCP/IP为可靠的数据传输提供了必要的基础设施，但其他协议则提供了额外的基础互联网功能。这些功能作为应用层协议来实现。现在让我们看看两个这样的协议（DHCP和DNS）以及一种用于转换IP地址的系统（NAT）。
- en: '***Dynamic Host Configuration Protocol***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态主机配置协议***'
- en: Every host on the internet needs an IP address, a subnet mask, and the IP address
    of its router (also called its *default gateway*) in order to communicate with
    other hosts. How are IP addresses assigned? A device can be given a *static IP
    address*, which requires someone to edit the configuration on the device and set
    its IP information manually. This is sometimes useful, but it requires the user
    to ensure that the IP address in question isn’t already taken and is valid for
    the subnet. Most end users don’t have the expertise to manually configure the
    IP settings for their devices, nor do they want to deal with the hassle of manual
    configuration. Fortunately, most IP addresses are assigned dynamically using *Dynamic
    Host Configuration Protocol (DHCP)*. With DHCP, when a device connects to a network,
    it receives an IP address and related information without user intervention.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的每个主机都需要一个IP地址、一个子网掩码以及它的路由器IP地址（也叫*默认网关*），才能与其他主机进行通信。IP地址是如何分配的呢？设备可以被赋予一个*静态IP地址*，这需要有人编辑设备的配置并手动设置IP信息。这有时是有用的，但它要求用户确保该IP地址没有被占用，并且对该子网是有效的。大多数终端用户没有手动配置设备IP设置的专业知识，也不想处理手动配置的麻烦。幸运的是，大多数IP地址是通过*动态主机配置协议（DHCP）*动态分配的。通过DHCP，当设备连接到网络时，它会在没有用户干预的情况下接收IP地址和相关信息。
- en: For DHCP to be available on a network, a device on the network must be configured
    as a *DHCP server*. This server has a pool of IP addresses that it’s allowed to
    assign to devices on the network. The flow of DHCP is illustrated in [Figure 11-15](ch11.xhtml#ch11fig15).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 DHCP 在网络上可用，网络上的设备必须被配置为*DHCP 服务器*。该服务器有一个可分配给网络上设备的 IP 地址池。DHCP 的流程在[图
    11-15](ch11.xhtml#ch11fig15)中进行了说明。
- en: '![image](../images/fig11-15.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-15.jpg)'
- en: '*Figure 11-15: A DHCP conversation*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-15：一个 DHCP 对话*'
- en: Let’s walk through [Figure 11-15](ch11.xhtml#ch11fig15). When a device connects
    to a network, it broadcasts a message to discover any DHCP servers. A *broadcast*
    is a special kind of packet that’s addressed to all hosts on the local network.
    When the DHCP server receives this broadcast, it offers an IP address to the client
    device. If the client wishes to accept the offered IP address, it replies to the
    server with a request for the offered address. The DHCP server then acknowledges
    the request, and the IP address is assigned to the client. The IP address is *leased*
    to the client, and it eventually expires if the client does not renew its lease.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步了解[图 11-15](ch11.xhtml#ch11fig15)。当一个设备连接到网络时，它会广播一条消息以发现任何 DHCP 服务器。*广播*是一种特别的包，它的目标是本地网络上的所有主机。当
    DHCP 服务器收到这个广播时，它会向客户端设备提供一个 IP 地址。如果客户端希望接受这个提供的 IP 地址，它会向服务器回复一个请求，要求分配该地址。然后，DHCP
    服务器会确认请求，并将该 IP 地址分配给客户端。该 IP 地址会被*租赁*给客户端，如果客户端没有续租，地址最终会过期。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #33](ch11.xhtml#proj33) on [page 258](ch11.xhtml#page_258),
    where you can see the IP address your Raspberry Pi has leased using DHCP*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目 #33](ch11.xhtml#proj33)和[第 258 页](ch11.xhtml#page_258)，在那里你可以看到你的 Raspberry
    Pi 使用 DHCP 租赁的 IP 地址*。'
- en: '***Private IP Addresses and Network Address Translation***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***私有 IP 地址和网络地址转换***'
- en: The number of available IP addresses is limited, so most home internet service
    providers (ISPs) only assign a single IP address to a customer. This IP address
    is assigned to the device that’s directly attached to the ISP’s network, usually
    a router. However, many customers have multiple devices on their home network.
    Let’s look at how multiple devices can share a single public IP address by leveraging
    private IP addresses and Network Address Translation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 IP 地址数量是有限的，因此大多数家庭互联网服务提供商（ISP）只会分配一个 IP 地址给客户。这个 IP 地址被分配给直接连接到 ISP 网络的设备，通常是一个路由器。然而，许多客户家中有多个设备。让我们看看如何通过利用私有
    IP 地址和网络地址转换，使多个设备共享一个公共 IP 地址。
- en: Certain ranges of IP addresses are considered *private IP addresses*, addresses
    intended to be used on *private networks*, such as those in homes or offices,
    where the devices aren’t directly connected to the internet. Any address that
    matches the pattern of 10.*x.x.x*, 172.16.*x.x*, or 192.168.*x.x* is a private
    IP address. Anyone can use these ranges of IP addresses without asking permission.
    The catch is that private IP addresses are nonroutable—they can’t be used on the
    public internet. A DHCP server on a home network can assign these addresses without
    worrying about whether any other network is using the same addresses. Unlike public
    IP addresses that must be unique, private IP addresses are intended to be used
    simultaneously on multiple private networks. It doesn’t matter if multiple networks
    use the same addresses, since the addresses won’t ever be seen outside of the
    private network anyway. Private IP addresses solve the problem of an ISP only
    providing a single public IP address to a home or business, but how are private
    IP addresses useful if they aren’t routable on the internet?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 某些范围的 IP 地址被认为是*私有 IP 地址*，这些地址是为*私有网络*设计的，例如家庭或办公室中的网络，在这些网络中，设备并没有直接连接到互联网。任何符合
    10.*x.x.x*、172.16.*x.x* 或 192.168.*x.x* 格式的地址都是私有 IP 地址。任何人都可以在不需要许可的情况下使用这些地址范围。问题是私有
    IP 地址是不可路由的——它们不能在公共互联网中使用。家庭网络中的 DHCP 服务器可以分配这些地址，而不必担心其他网络是否也在使用相同的地址。与必须唯一的公共
    IP 地址不同，私有 IP 地址设计上可以在多个私有网络中同时使用。即使多个网络使用相同的地址，也没有关系，因为这些地址永远不会出现在私有网络之外。私有 IP
    地址解决了 ISP 仅为家庭或企业提供一个公共 IP 地址的问题，但如果私有 IP 地址无法在互联网上路由，它们又如何有用呢？
- en: '*Network Address Translation (NAT)* allows devices on a private network, often
    a home network, to all use the same public IP address on the internet. As packets
    flow through a NAT router, the router modifies the IP address information in those
    packets. When a packet originating from the private home network arrives at the
    NAT router, it modifies the source IP address field to match the public IP address,
    as shown in [Figure 11-16](ch11.xhtml#ch11fig16).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络地址转换 (NAT)* 允许在私有网络（通常是家庭网络）上的设备使用相同的公共IP地址访问互联网。当数据包通过NAT路由器时，路由器会修改数据包中的IP地址信息。当来自私有家庭网络的数据包到达NAT路由器时，路由器会修改源IP地址字段，以匹配公共IP地址，如[图11-16](ch11.xhtml#ch11fig16)所示。'
- en: '![image](../images/fig11-16.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-16.jpg)'
- en: '*Figure 11-16: A NAT router replaces private IP addresses with its own public
    IP address*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-16：NAT路由器将私有IP地址替换为其自己的公共IP地址*'
- en: 'When a response comes back to the router, it sets the destination IP address
    to the private address of the host that originated the request. In this way, all
    traffic from the home appears to originate from the same public IP address, even
    if there are actually multiple devices on the private network. NAT also has the
    side benefit of security: the devices on the private network aren’t directly exposed
    to the public internet, so a malicious user on the internet can’t initiate a connection
    directly to a private device. Most routers sold to consumers for home use are
    NAT routers, often with built-in wireless access point capabilities as well.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应返回到路由器时，路由器将目标IP地址设置为发起请求的主机的私有地址。通过这种方式，家庭网络中的所有流量看起来都来自同一个公共IP地址，即使实际在私有网络上有多个设备。NAT还具有额外的安全性好处：私有网络上的设备不会直接暴露在公共互联网中，因此互联网中的恶意用户无法直接发起连接到私有设备。大多数面向消费者销售的家用路由器都是NAT路由器，通常还具备内置无线接入点功能。
- en: Private IP addresses are valuable not only for home networks, but also for businesses
    that don’t want their computers exposed to the public internet. Many corporate
    networks use a *proxy server* rather than a NAT router. A proxy server is similar
    to a NAT router in that it allows devices on a private network to access the internet,
    but a proxy server differs in that it typically operates at the application layer
    rather than the internet layer. Proxies also usually provide additional features
    such as user authentication, traffic logging, and content filtering.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 私有IP地址不仅对家庭网络有价值，对于不希望将计算机暴露于公共互联网的企业来说也同样重要。许多企业网络使用*代理服务器*而不是NAT路由器。代理服务器类似于NAT路由器，它允许私有网络上的设备访问互联网，但代理服务器通常在应用层而非互联网层运行。代理服务器通常还提供额外的功能，如用户认证、流量日志记录和内容过滤。
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #34](ch11.xhtml#proj34) on [page 259](ch11.xhtml#page_259),
    where you can see if the IP address your device is assigned is a public IP address
    or a private IP address*.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #34](ch11.xhtml#proj34)以及[第259页](ch11.xhtml#page_259)，在其中你可以看到分配给你设备的IP地址是公共IP地址还是私有IP地址*。'
- en: '***The Domain Name System***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***域名系统***'
- en: We’ve seen that hosts on the internet are identified by IP addresses. However,
    most users of the internet rarely, if ever, directly deal with IP addresses. Although
    IP addresses work well for computers, they aren’t very user friendly. No one wants
    to remember sets of four numbers separated by periods. Fortunately, we have the
    *Domain Name System (DNS)* to make things easier for us. DNS is an internet service
    that maps names to IP addresses. This allows us to refer to a host by a name like
    *www.example.com* rather than by its IP address.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，互联网上的主机通过IP地址进行标识。然而，互联网的多数用户很少，甚至从不直接处理IP地址。虽然IP地址对于计算机来说是有效的，但它们对用户来说并不友好。没有人愿意记住由点分隔的四组数字。幸运的是，我们有*域名系统
    (DNS)* 来简化这一切。DNS是一个将名称映射到IP地址的互联网服务。这使得我们可以通过像 *www.example.com* 这样的名称来引用主机，而不是通过其IP地址。
- en: A computer’s full DNS name is known as a *fully qualified domain name*, or *FQDN*.
    A name like *travel.example.com* is an FQDN. This name is composed of a short,
    local *hostname (travel)* and a domain suffix *(example.com*). The term *hostname*
    is often used interchangeably to mean either the computer’s short name or the
    FQDN. Later in this section, we use *hostname* to mean a computer’s FQDN. A *domain*,
    like *example.com*, represents a grouping of network resources managed by an organization.
    Both *example.com* and *travel.example.com* are domain names. The former represents
    a network domain; the latter represents a specific host on that domain.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的完整 DNS 名称被称为 *完全限定域名*，或 *FQDN*。像 *travel.example.com* 这样的名称就是一个 FQDN。这个名称由一个简短的本地
    *主机名（travel）* 和一个域后缀 *（example.com）* 组成。术语 *主机名* 常常交替使用，指的是计算机的短名称或 FQDN。本文接下来会使用
    *主机名* 来指代计算机的 FQDN。*域名*，如 *example.com*，代表一个由组织管理的网络资源组。*example.com* 和 *travel.example.com*
    都是域名。前者代表一个网络域；后者代表该域中的特定主机。
- en: Software needs to be able to query DNS to convert hostnames to IP addresses—this
    is known as *resolving* a hostname. To enable this functionality, hosts are configured
    with a list of the IP addresses of DNS servers. This list is usually provided
    by DHCP, and it typically is composed of DNS servers maintained by the internet
    service provider or running on the local network. When a client wants to connect
    to a server by name, it asks a DNS server for the IP address corresponding to
    that name. The server replies with the requested IP address, if it can. This is
    illustrated in [Figure 11-17](ch11.xhtml#ch11fig17).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 软件需要能够查询 DNS 将主机名转换为 IP 地址——这被称为 *解析* 主机名。为了实现这一功能，主机会配置一个 DNS 服务器 IP 地址的列表。这个列表通常由
    DHCP 提供，通常包含由互联网服务提供商维护或在本地网络上运行的 DNS 服务器。当客户端想通过名称连接到服务器时，它会向 DNS 服务器请求与该名称对应的
    IP 地址。如果服务器能提供，它会返回请求的 IP 地址。这个过程如 [图 11-17](ch11.xhtml#ch11fig17) 所示。
- en: '![image](../images/fig11-17.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-17.jpg)'
- en: '*Figure 11-17: A simplified DNS query. The IP address of* example.com *is not
    intended to be accurate*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-17：简化的 DNS 查询。* example.com *的 IP 地址并不准确。*'
- en: Once the client has the server’s IP, it proceeds to communicate with the server
    using the IP address, as described earlier. I’ve heard DNS described as the phone
    book of the internet, although that analogy may fall short for some readers since
    phone books aren’t as common as they once were!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端获取到服务器的 IP 地址，它就会使用该地址与服务器进行通信，如前所述。我曾听说 DNS 被比作互联网的电话簿，尽管这种类比对一些读者来说可能不太恰当，因为电话簿不再像以前那样普及！
- en: You might assume that there’s a one-to-one mapping between IP addresses and
    names. That actually isn’t the case. A name can map to multiple IP addresses.
    In that scenario, different clients query DNS for a certain name, and they may
    all receive a different IP address as a response. This is useful for situations
    in which the load for a given service needs to be distributed across multiple
    servers. This can be done geographically, so that clients in Europe, for example,
    get a different IP address than clients in Asia, allowing clients in each region
    to connect to the IP address of a server that’s physically close to them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为 IP 地址和名称之间存在一对一的映射关系。实际上并非如此。一个名称可以映射到多个 IP 地址。在这种情况下，多个客户端查询 DNS 获取某个名称时，它们可能会收到不同的
    IP 地址作为响应。这对于需要将某个服务的负载分配到多个服务器的情况非常有用。负载分配可以基于地理位置进行，比如欧洲的客户端可能会得到一个不同于亚洲客户端的
    IP 地址，这样可以让各地区的客户端连接到离它们物理上更近的服务器 IP 地址。
- en: 'The reverse is possible too: multiple names can map to the same IP address.
    In this scenario, a query for different names may return a single IP address.
    This is useful when a server hosts multiple instances of the same type of service,
    each identified by name. This is common in web hosting, where a single server
    hosts multiple websites, each identified by its DNS name.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 反向查询也是可能的：多个名称可以映射到相同的 IP 地址。在这种情况下，查询不同名称时，可能会返回同一个 IP 地址。这对于服务器托管多个相同类型的服务实例（每个实例通过名称标识）非常有用。此情况在网站托管中很常见，一台服务器可能托管多个网站，每个网站通过其
    DNS 名称进行标识。
- en: Each entry in DNS is known as a *record*. There are various kinds of records;
    the most basic is an *A record*, which simply maps a hostname to an IP address.
    Other examples are *CNAME (canonical name)* records that map one hostname to another
    hostname, and *MX (mail exchanger)* records used for email services.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: DNS中的每个条目被称为*记录*。记录有多种类型；最基本的是*A记录*，它只是将主机名映射到IP地址。其他例子包括将一个主机名映射到另一个主机名的*CNAME（规范名称）*记录，以及用于电子邮件服务的*MX（邮件交换器）*记录。
- en: No single organization would want to undertake the task of managing the many,
    many DNS records that exist today. Fortunately, this isn’t needed; DNS is implemented
    in a way that allows for shared responsibility. A DNS name like *www.example.com*
    actually represents a hierarchy of records, and different DNS servers are responsible
    for maintaining the records at different levels of the hierarchy. The DNS hierarchy,
    as applied to *www.example.com*, is illustrated in [Figure 11-18](ch11.xhtml#ch11fig18).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何一个组织愿意承担管理当今存在的众多DNS记录的任务。幸运的是，这并不需要；DNS的实现方式允许共享责任。像*www.example.com*这样的DNS名称实际上代表了一个记录层次结构，不同的DNS服务器负责维护该层次结构中不同级别的记录。应用于*www.example.com*的DNS层次结构，如[图11-18](ch11.xhtml#ch11fig18)所示。
- en: '![image](../images/fig11-18.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig11-18.jpg)'
- en: '*Figure 11-18: Example DNS hierarchy, highlighting* www.example.com'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-18：示例DNS层次结构，突出显示* www.example.com'
- en: At the top of this hierarchical tree is the *root domain*. The root domain doesn’t
    get a textual representation in a DNS name like *www.example.com*, but it’s an
    essential part of the DNS hierarchy. The root domain contains records for all
    the *top-level domains (TLDs)* like *.com*, *.org*, *.edu*, *.net*, and so forth.
    As of 2020, there are 13 root name servers worldwide, each responsible for knowing
    the details of all the top-level domain servers. Let’s say you want to look up
    a record in a domain that ends with *.com*. A root server can point you to a TLD
    server that knows about domains under *.com*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构的顶部是*根域名*。根域名在DNS名称中不会像*www.example.com*那样有文本表示，但它是DNS层次结构中不可或缺的一部分。根域名包含所有*顶级域名（TLD）*的记录，例如*.com*、*.org*、*.edu*、*.net*等。截至2020年，全球有13个根名称服务器，每个根名称服务器负责了解所有顶级域名服务器的详细信息。假设你想查找一个以*.com*结尾的域名的记录，根服务器可以将你引导到一个知道*.com*下域名信息的TLD服务器。
- en: A top-level DNS server is responsible for knowing about all the second-level
    domains under its hierarchy. A top-level DNS server for *.com* could point you
    to the second-level DNS server for *example.com*. The DNS servers for second-level
    domains maintain records for hosts and third-level domains that fall under second-level
    domains. This means that the DNS server(s) for *example.com* are responsible for
    maintaining the records for hosts like *www.example.com* and *mail.example.com*.
    This pattern continues, allowing for nested domains. Once a domain is registered
    under a top-level domain, the owner of that domain can create as many records
    as needed under their domain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级DNS服务器负责了解其层次结构下所有二级域名的信息。一个*.com*的顶级DNS服务器可以将你引导到*example.com*的二级DNS服务器。二级域名的DNS服务器维护着主机和三级域名的记录，这些主机和三级域名位于二级域名下。这意味着*example.com*的DNS服务器负责维护诸如*www.example.com*和*mail.example.com*等主机的记录。这个模式继续下去，允许域名嵌套。一旦一个域名在顶级域名下注册，域名的拥有者可以在其域名下创建任意多的记录。
- en: As mentioned earlier, when a computer needs to find the IP address for an FQDN,
    it sends a request to its configured DNS server. What does the DNS server do with
    this request? If the server has recently looked up the requested record, it may
    have a copy of that record stored in its cache, and it can immediately return
    the IP address to the client. If the DNS server doesn’t have the response in cache,
    it may query other DNS servers as needed to get the answer. This involves starting
    at the root and working down the hierarchy of servers to find the record in question.
    Once the server has the record, it can cache it so that it can immediately respond
    to future queries for that record. Eventually the cached record is removed to
    ensure that the server always provides reasonably recent data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当计算机需要为FQDN查找IP地址时，它会向配置的DNS服务器发送请求。那么DNS服务器如何处理这个请求呢？如果服务器最近已经查找过该记录，它可能会将该记录存储在缓存中，并立即返回IP地址给客户端。如果DNS服务器没有缓存响应，它可能会根据需要查询其他DNS服务器来获取答案。这涉及从根服务器开始，逐步向下查询服务器层次，直到找到该记录。一旦服务器找到记录，它可以将其缓存起来，以便未来查询该记录时能够立即回应。最终，缓存的记录会被删除，以确保服务器提供的是较为最新的数据。
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #35](ch11.xhtml#proj35) on [page 260](ch11.xhtml#page_260),
    where you can look up information in DNS*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #35](ch11.xhtml#proj35)，在[第260页](ch11.xhtml#page_260)上查看有关DNS的信息*。'
- en: '**Networking Is Computing**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络即计算**'
- en: Let’s take a moment to consider how the internet fits in with the broader picture
    of computing that we’ve already covered in this book. Networking may seem like
    a tangential topic, but really it isn’t so far removed from computing in general.
    The internet is composed of hardware and software working together to allow communication
    between devices. Data sent over the internet boils down to 0s and 1s, represented
    in various forms such as voltages on a wire. From the perspective of a computer,
    a networking interface like a Wi-Fi or Ethernet adapter is just another I/O device.
    An operating system interacts with such adapters via device drivers, and the OS
    includes software libraries that allow applications to easily communicate over
    the internet. Networking devices like routers and switches are computers too,
    although highly specialized ones. The internet, and networking in general, is
    an extension of local computing, allowing for data transfer and processing beyond
    the boundaries of a single device.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来思考互联网如何融入我们在本书中已经讨论的更广泛的计算概念。网络看起来可能是一个边缘话题，但实际上它与计算并没有多远的关系。互联网由硬件和软件共同工作，允许设备之间的通信。通过互联网发送的数据最终归结为0和1，以各种形式表示，例如电线上的电压。从计算机的角度来看，像Wi-Fi或以太网适配器这样的网络接口只是另一个I/O设备。操作系统通过设备驱动与这些适配器进行交互，操作系统还包含了软件库，允许应用程序轻松地通过互联网进行通信。像路由器和交换机这样的网络设备也是计算机，尽管它们是高度专业化的。互联网以及网络本身，实际上是本地计算的延伸，它允许数据在超出单一设备范围的情况下进行传输和处理。
- en: '### **Summary**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: In this chapter we covered the internet, a globally connected set of computer
    networks that all use a suite of common protocols. You learned about the four
    layers of the internet protocol suite—the link layer, the internet layer, the
    transport layer, and the application layer. You saw how data travels through the
    internet and how devices interact at various layers. You learned how DHCP provides
    networking configuration data, how NAT allows devices on private networks to connect
    to the internet, and how DNS provides friendly names that can be used in place
    of IP addresses. In the next chapter you’ll learn about the World Wide Web, a
    set of resources delivered by HTTP over the internet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了互联网，一个全球互联的计算机网络集合，所有这些网络都使用一套通用的协议。你学习了互联网协议套件的四个层次——链路层、互联网层、传输层和应用层。你了解了数据如何在互联网中传输，以及设备如何在各个层次上进行交互。你学习了DHCP如何提供网络配置信息，NAT如何让私有网络上的设备连接到互联网，以及DNS如何提供友好的名称，可以代替IP地址使用。在下一章中，你将学习万维网，这是一组通过HTTP在互联网中传输的资源。
- en: '**PROJECT #29: EXAMINE THE LINK LAYER**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #29：检查链路层**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you
    flip to [Appendix B](appb.xhtml) and read the entire “Raspberry Pi” section if
    you haven’t already.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件：一台运行Raspberry Pi OS的Raspberry Pi。如果你还没有，建议你翻到[附录B](appb.xhtml)，阅读完整的“Raspberry
    Pi”部分。
- en: 'In this project, you’ll use your Raspberry Pi to check out the link layer of
    your local network. Let’s start with the following command, which lists the MAC
    address of your Ethernet adapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用你的树莓派检查本地网络的链路层。我们先从以下命令开始，它可以列出你以太网适配器的MAC地址：
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output should look something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应该类似于以下内容：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the MAC address is `b8:27:eb:12:34:56`. That’s a hexadecimal
    representation of a 48-bit number. Remember, each hex character represents 4 bits,
    so that’s 12 characters × 4 bits = 48 bits.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，MAC地址是`b8:27:eb:12:34:56`。这是一个48位数字的十六进制表示。记住，每个十六进制字符表示4位，因此12个字符 ×
    4位 = 48位。
- en: 'The first 24 bits of a MAC address represent the vendor/manufacturer of the
    hardware. This number is known as an *organizationally unique identifier (OUI)*
    and is managed by the *Institute of Electrical and Electronics Engineers (IEEE)*.
    In this case the OUI is B827EB, which is assigned to the Raspberry Pi Foundation.
    You can see the current OUI listings here: *[http://standards-oui.ieee.org/oui.txt](http://standards-oui.ieee.org/oui.txt)*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MAC地址的前24位表示硬件的供应商/制造商。这个数字被称为*组织唯一标识符（OUI）*，由*电气和电子工程师协会（IEEE）*管理。在这个例子中，OUI是B827EB，它分配给了树莓派基金会。你可以在这里查看当前的OUI列表：*[http://standards-oui.ieee.org/oui.txt](http://standards-oui.ieee.org/oui.txt)*。
- en: 'Your Raspberry Pi’s Wi-Fi adapter has its own MAC address. View it like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你的树莓派Wi-Fi适配器有它自己的MAC地址。你可以像这样查看它：
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On my system, the OUI (the first 24 bits of the MAC address) of the Wi-Fi adapter
    is the same as the OUI of the Ethernet adapter. This is because both adapters
    are internal Raspberry Pi hardware and use the OUI for the Raspberry Pi Foundation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，Wi-Fi适配器的OUI（MAC地址的前24位）与以太网适配器的OUI相同。这是因为这两个适配器都是树莓派的内部硬件，使用树莓派基金会的OUI。
- en: From your Raspberry Pi, you can also see the MAC address of other devices on
    your local network. To do this you can use a tool called `arp-scan` that attempts
    to connect to every computer on your local network and retrieve its MAC address.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的树莓派上，你还可以查看本地网络上其他设备的MAC地址。你可以使用一个名为`arp-scan`的工具，它尝试连接本地网络上的每台计算机并检索其MAC地址。
- en: 'First, install the tool:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装该工具：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then run this command (that’s a lowercase L at the end of the command, not
    the number 1):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行这个命令（命令末尾是小写字母L，而不是数字1）：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should get a list of IP addresses (which we cover elsewhere in this chapter)
    and MAC addresses, plus a column that attempts to match the MAC prefix to the
    manufacturer. I got 10 results on my local network, some of which I didn’t immediately
    recognize. You may see some duplicate results returned, indicated with `DUP` in
    the third column. The returned list typically does not include the address of
    the computer from which you ran the scan.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个IP地址列表（我们将在本章的其他部分进行讲解）和MAC地址，还有一列尝试将MAC前缀与制造商匹配。我在我的本地网络上得到了10个结果，其中一些我没有立即认出来。你可能会看到一些重复的结果，它们会在第三列中标记为`DUP`。返回的列表通常不包括你运行扫描的计算机的地址。
- en: 'You may have some results in the third column that show as `(Unknown)`. This
    means that the `arp-scan` tool wasn’t able to match the OUI number to a known
    manufacturer, probably because the tool is using an outdated version of the OUI
    list. You can try to fix this by downloading the current list of OUI numbers from
    IEEE and then running the scan again, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在第三列中看到一些显示为`(Unknown)`的结果。这意味着`arp-scan`工具无法将OUI号码与已知制造商匹配，可能是因为该工具使用的是过时的OUI列表版本。你可以尝试通过下载IEEE当前的OUI号码列表并重新运行扫描来修复此问题，命令如下：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When I see multiple devices on my home network that I can’t identify right
    away, I have an immediate urge to figure out what they are! As a bonus challenge
    for you, identify every device returned from `arp-scan`. Now, this may be impractical
    if you’re running this tool on a network you don’t control (say, at a coffee shop
    or library), but if you’re at home, this is something you can do. You’ll probably
    need to log on to each device on your network and dig through its settings to
    find its IP address or MAC address and see if it matches one of the entries returned
    from `arp-scan`. Hint: use the `ifconfig` utility on Linux or Mac, or the `ipconfig`
    tool on Windows. On mobile devices, look at the user interface for network settings.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在家里的网络上看到多个设备，我无法立即识别时，我会立刻产生想要弄清楚它们是什么的冲动！作为额外的挑战，找出所有从`arp-scan`返回的设备。现在，如果你在一个你无法控制的网络上运行这个工具（比如咖啡店或图书馆），这可能不太实际，但如果你在家里，这是你可以做的事。你可能需要登录到网络中的每个设备，翻查其设置，找到它的IP地址或MAC地址，并查看它是否与`arp-scan`返回的某个条目匹配。提示：在Linux或Mac上使用`ifconfig`工具，或在Windows上使用`ipconfig`工具。在移动设备上，可以查看网络设置的用户界面。
- en: '**PROJECT #30: EXAMINE THE INTERNET LAYER**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #30：检查互联网层**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件：一台运行Raspberry Pi OS的树莓派。
- en: In this project, you’ll look at the internet layer using your Raspberry Pi.
    Let’s begin with the following command, which lists all the network interfaces
    on your device and their associated IP addresses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用树莓派查看互联网层。让我们从以下命令开始，它列出了设备上所有的网络接口及其关联的IP地址。
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll typically see three interfaces: `eth0`, `lo`, and `wlan0`. The `lo`
    interface is a special case; it’s the *loopback* interface. It’s used for processes
    running on the Pi that wish to communicate with each other using TCP/IP, but without
    actually sending any traffic over the network. That is, the traffic stays on the
    device. The loopback interface has an IP address of 127.0.0.1\. This is a special
    address that is not routable and can’t be used as an address on the local subnet,
    because any attempt to deliver messages to that address results in the messages
    coming right back to the sending computer. In other words, every computer considers
    127.0.0.1 to be its own IP address.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会看到三个接口：`eth0`、`lo`和`wlan0`。`lo`接口是一个特殊的接口，它是*环回*接口。它用于树莓派上运行的进程，这些进程希望使用TCP/IP相互通信，但不需要通过网络实际发送任何流量。也就是说，流量会留在设备上。环回接口的IP地址是127.0.0.1。这个地址是一个特殊地址，无法路由，也不能作为本地子网中的地址使用，因为任何尝试将消息发送到该地址的行为都会导致消息立即返回给发送计算机。换句话说，每台计算机都认为127.0.0.1是自己的IP地址。
- en: 'As we covered in the previous project, `eth0` is the wired Ethernet interface
    and `wlan0` is the wireless Wi-Fi interface. If you’re connected to a network
    on either or both of these interfaces, you should see an IP address beside the
    text `inet` in the `ifconfig` output. You may also see an IPv6 address listed
    beside `inet6`. Here’s example `wlan0` output from `ifconfig`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个项目中提到的，`eth0`是有线以太网接口，`wlan0`是无线Wi-Fi接口。如果你通过这些接口之一或两个连接到网络，你应该能在`ifconfig`的输出中看到`inet`旁边的IP地址。你可能还会看到列在`inet6`旁边的IPv6地址。以下是`ifconfig`输出中的示例`wlan0`信息：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this output you can see that the assigned IP address is `192.168.1.138`.
    The `netmask` value (subnet mask) is `255.255.255.0`, and the `broadcast` address
    is `192.168.1.255`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，你可以看到分配的IP地址是`192.168.1.138`。`netmask`值（子网掩码）是`255.255.255.0`，而`broadcast`地址是`192.168.1.255`。
- en: The `ifconfig` command gives us information about the various network interfaces
    on the Raspberry Pi, but it doesn’t tell us about how routing is configured. Let’s
    take a look at that using the `ip route` command. I’ve included sample output
    here; your results may vary.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifconfig`命令为我们提供了有关树莓派各种网络接口的信息，但它并没有告诉我们路由是如何配置的。让我们使用`ip route`命令来看一下。这里包含了一个示例输出；你的结果可能有所不同。'
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command’s output can be a little difficult to interpret. In short, the
    first line gives the default route. This is where packets should be sent when
    there isn’t a specific route that applies. In this particular example, every packet
    that doesn’t match a specific routing rule should be sent to `192.168.1.1`. That
    means that `192.168.1.1` is the IP address of the local router, also known as
    the *default gateway*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可能有些难以理解。简而言之，第一行给出了默认路由。当没有特定的路由适用时，数据包应该发送到这里。在这个特定的例子中，所有不匹配特定路由规则的数据包应发送到`192.168.1.1`。这意味着`192.168.1.1`是本地路由器的IP地址，也被称为*默认网关*。
- en: The next line is a routing entry that tells you that any packet sent to an IP
    address in the range of `192.168.1.0/24` should be sent through device `wlan0`.
    That’s the Wi-Fi adapter on the local subnet. In other words, this routing rule
    ensures that communication with IP addresses on the local subnet happens directly,
    without going through a router.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是一个路由条目，告诉你，任何发送到`192.168.1.0/24`范围内的IP地址的数据包，应该通过设备`wlan0`发送。这是本地子网的Wi-Fi适配器。换句话说，这条路由规则确保与本地子网IP地址的通信直接发生，而无需经过路由器。
- en: To summarize, this output tells you that any packet sent to an IP address that
    matches `192.168.1.0/24` should be sent directly to the destination address via
    the `wlan0` interface. Any other traffic uses the default route, which sends traffic
    to the router at `192.168.1.1`. The end result is that local subnet traffic is
    sent directly to the target device, while traffic to devices on other subnets,
    likely on the internet, is sent to the default gateway.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个输出告诉你，任何发送到与`192.168.1.0/24`匹配的IP地址的数据包，都应该通过`wlan0`接口直接发送到目标地址。其他的流量则使用默认路由，将流量发送到`192.168.1.1`的路由器。最终结果是，本地子网的流量直接发送到目标设备，而发送到其他子网上的设备的流量，通常是互联网设备，将通过默认网关发送。
- en: '**PROJECT #31: EXAMINE PORT USAGE**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #31：检查端口使用情况**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的树莓派。
- en: In this project, you’ll see which network ports are in use on a Raspberry Pi.
    You’ll then examine ports on other computers. Let’s begin with the following command
    that shows you the listening and established TCP sockets on your Raspberry Pi.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将查看树莓派上哪些网络端口在使用。然后你将检查其他计算机上的端口。让我们从以下命令开始，它将展示树莓派上监听和已建立的TCP套接字。
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s break down the `-nat` options used in the command. The `n` option indicates
    that numeric output should be used to show the port numbers. The `a` option means
    show all connections (both listening and established), and `t` means limit the
    output to TCP. On my device, I see a list like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下命令中使用的`-nat`选项。`n`选项表示使用数字输出以显示端口号。`a`选项表示显示所有连接（包括监听和已建立的连接），`t`表示将输出限制为TCP。在我的设备上，我看到如下的列表：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here you see four sockets, all related to SSH. I can tell they are related to
    SSH because all the sockets are using port `22`. I have SSH enabled on my Raspberry
    Pi to allow remote terminal connections. The first and last lines show that the
    Pi is listening on port `22` for new incoming SSH connections using both TCP and
    TCP over IPv6\. The middle two lines show that I have two established SSH connections
    to this device, both of them from my laptop (with an IP of `192.168.1.125`) to
    the Pi (with an IP of `192.168.1.138`). Note how both the established connections
    go to the same server port on the Pi (`22`), whereas the client port on my laptop
    varies (`52654` and `51778`), as they are ephemeral ports.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你看到四个与SSH相关的套接字。我知道它们与SSH相关，因为所有套接字都使用端口`22`。我在树莓派上启用了SSH，以允许远程终端连接。第一行和最后一行显示树莓派在端口`22`上监听新的传入SSH连接，使用TCP和IPv6上的TCP协议。中间的两行显示我有两个已经建立的SSH连接到这个设备，它们都来自我的笔记本（IP为`192.168.1.125`）到树莓派（IP为`192.168.1.138`）。注意到，两个已建立的连接都指向树莓派的相同服务器端口（`22`），而我笔记本上的客户端端口则不同（`52654`和`51778`），因为它们是临时端口。
- en: 'Run the command again, this time adding the p option and prefixing the command
    with sudo:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行命令，这次添加`-p`选项并在命令前加上`sudo`：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This gives you the same list, but with the process ID (PID) and program name
    to which the socket belongs. Any traffic sent to the socket is directed to the
    PID, which handles the traffic and responds as needed. On my computer I see that
    the program using this port is `sshd`—the daemon for SSH.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你相同的列表，但还会显示与该套接字相关的进程ID（PID）和程序名称。任何发送到该套接字的流量都会被定向到PID，后者处理流量并根据需要响应。在我的计算机上，我看到使用此端口的程序是`sshd`—SSH的守护进程。
- en: 'Now that you’ve examined which ports are in use on your Raspberry Pi, let’s
    examine the ports on a remote computer. For this, you’ll use a tool called `nmap`,
    which must first be installed on your Raspberry Pi:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经检查了树莓派上哪些端口在使用，接下来让我们检查远程计算机上的端口。为此，你将使用一个名为`nmap`的工具，首先需要在树莓派上安装它：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the tool is installed, select a target host that you wish to scan. This
    can be either a device on your network (say your router or a laptop) or a host
    on the internet. Note that repeatedly scanning a host that you don’t control may
    look suspicious to the administrators of that server, so I strongly recommend
    that you only scan devices that you own.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工具安装完成，选择一个你希望扫描的目标主机。这个主机可以是你网络上的设备（比如你的路由器或笔记本电脑），也可以是互联网上的主机。注意，反复扫描一个你无法控制的主机可能会引起该服务器管理员的怀疑，所以我强烈建议你只扫描你拥有的设备。
- en: 'In my case, I decided to scan my default gateway, which happens to be at 192.168.1.1\.
    The following `nmap` command scans for open TCP ports on the specified IP address.
    Try this on your Raspberry Pi, replacing the IP address with the address of the
    device you wish to scan. If you want to scan your own router, see [Project #30](ch11.xhtml#proj30)
    for a reminder of how to get the IP address of your default gateway.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '在我的案例中，我决定扫描我的默认网关，恰好它位于192.168.1.1。以下`nmap`命令扫描指定IP地址上开放的TCP端口。尝试在你的树莓派上运行此命令，将IP地址替换为你希望扫描的设备的地址。如果你想扫描你自己的路由器，请参阅[项目
    #30](ch11.xhtml#proj30)，了解如何获取默认网关的IP地址。'
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A partial listing of the results from my scan showed these ports:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我扫描的结果的部分列表显示了以下端口：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This tells me that the device acts not only as a router, but as a DNS server
    (port `53`) and web server (port `80`). It’s normal for a home router to provide
    these services.  **PROJECT #32: TRACE THE ROUTE TO A HOST ON THE INTERNET**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '这告诉我，这个设备不仅充当路由器，还充当DNS服务器（端口`53`）和Web服务器（端口`80`）。对于家庭路由器来说，提供这些服务是正常的。 **项目
    #32：追踪互联网主机的路由**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的树莓派。
- en: In this project, you’ll examine the route a packet travels from your Raspberry
    Pi to a host on the internet. First, you need to choose a host on the internet.
    This can be a website like *www.example.com*, or the IP address or FQDN of any
    internet host you happen to know. Once you’ve decided on a host, enter the following
    command, replacing *`www.example.com`* with the name or IP address of the host
    you wish to see.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将检查数据包从树莓派到互联网上某个主机的路由。首先，你需要选择一个互联网上的主机。这个主机可以是像*www.example.com*这样的网站，也可以是你知道的任何互联网主机的IP地址或完全限定域名（FQDN）。一旦你决定了主机，输入以下命令，将*`www.example.com`*替换为你希望查看的主机的名称或IP地址。
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `traceroute` tool attempts to show the routers that are encountered on a
    packet’s journey across the internet. The output should be read line by line.
    Each line is sequentially numbered and shows the name (if available) and IP address
    of the router encountered at that step of the packet’s trip. If there is no response
    after a short time, the output displays an asterisk (`*`) and moves on to the
    next router. You may also see more than one IP address per line, indicating multiple
    possible routes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceroute`工具尝试显示在数据包跨越互联网时遇到的路由器。输出应该逐行阅读。每一行都有序号，并显示该数据包在旅行过程中遇到的路由器的名称（如果有的话）和IP地址。如果短时间内没有响应，输出将显示一个星号（`*`），并跳到下一个路由器。你也可能看到每一行显示多个IP地址，表示可能有多个路由。'
- en: '**PROJECT #33: SEE YOUR LEASED IP ADDRESS**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #33：查看你的租用IP地址**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的树莓派。
- en: 'In this project, you’ll look at the lease information associated with your
    Raspberry Pi’s IP address obtained from a DHCP server. Of course, this assumes
    that your Raspberry Pi is configured to use DHCP (which is the default) rather
    than a static IP address. To do this, look at the system log:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将查看与树莓派的IP地址相关的租用信息，该IP地址是从DHCP服务器获取的。当然，这假设你的树莓派配置为使用DHCP（这是默认设置），而不是静态IP地址。要做到这一点，请查看系统日志：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Expect to see output similar to the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 预计会看到类似以下的输出：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here you can see that IP address `192.168.1.104` was leased from a DHCP server
    for use on network interface `eth0`, the Ethernet interface on the Raspberry Pi.
    Your output likely shows a different IP address and perhaps a different interface,
    maybe `wlan0`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到IP地址`192.168.1.104`是从DHCP服务器租用的，供网络接口`eth0`使用，这是树莓派上的以太网接口。你的输出可能显示不同的IP地址，也许是不同的接口，可能是`wlan0`。
- en: 'By default, the *syslog* file is periodically cleared, and its contents are
    moved to a backup file. Because of this, you may not see a DHCP entry in your
    *syslog* file. You can release your current IP address, request a new one, and
    look again for the lease entry like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*syslog* 文件会定期清除，其内容会被移动到备份文件中。因此，您可能无法在 *syslog* 文件中看到 DHCP 条目。您可以释放当前的
    IP 地址，申请一个新的，并再次查看租赁条目，方法如下：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Replace `wlan0` with `eth0` if you want to do this for Ethernet rather than
    Wi-Fi.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看以太网而不是 Wi-Fi 的地址，请将 `wlan0` 替换为 `eth0`。
- en: '**PROJECT #34: IS YOUR DEVICE’S IP PUBLIC OR PRIVATE?**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #34：您的设备的 IP 地址是公有的还是私有的？**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行 Raspberry Pi OS 的 Raspberry Pi。
- en: In this project, you’ll see if the IP address of your Raspberry Pi is public
    or private. If your device has a private IP address, you’ll also find the public
    IP address that is used for your communication over the internet. As before, you
    can use the following utility to see your device’s assigned IP address(es).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将检查 Raspberry Pi 的 IP 地址是公有的还是私有的。如果您的设备有一个私有 IP 地址，您还可以找到用于互联网通信的公有
    IP 地址。如同之前，您可以使用以下工具查看设备的分配 IP 地址。
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When looking for your device’s assigned IP address, you’ll likely see an entry
    for 127.0.0.1; you can ignore this one since it’s used for loopback (see [Project
    #30](ch11.xhtml#proj30)). As mentioned earlier, any address that matches the pattern
    of 10.*x.x.x*, 172.16.*x.x*, or 192.168.*x.x* is a private IP address. Now, even
    if you have a private IP address like one of these, when you access resources
    on the internet, you’re also indirectly making use of a public IP address. This
    is the address that websites or other internet services see when you connect to
    them. If you’re on a home network, that public IP address is likely assigned to
    your router. If you’re on a business network, that public IP address may be assigned
    to a proxy device on the edge of your corporate network. In either case, all the
    network traffic from inside your local network to the internet originates from
    that public address.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '在查找设备的分配 IP 地址时，您可能会看到一个 127.0.0.1 的条目；可以忽略它，因为它用于环回（见 [项目 #30](ch11.xhtml#proj30)）。如前所述，任何符合
    10.*x.x.x*、172.16.*x.x* 或 192.168.*x.x* 格式的地址都是私有 IP 地址。现在，即使您拥有像这些这样的私有 IP 地址，当您访问互联网资源时，您也间接地使用了一个公有
    IP 地址。这是网站或其他互联网服务在您连接时看到的地址。如果您在家庭网络中，这个公有 IP 地址很可能是分配给您的路由器的。如果您在企业网络中，这个公有
    IP 地址可能是分配给您公司网络边缘的代理设备的。在这两种情况下，从您本地网络到互联网的所有网络流量都起源于这个公有地址。'
- en: To find the public IP address that your device uses when connecting to a device
    on the internet, one option is to log on to your router or proxy server and check
    its network configuration. If you know how to query your router or proxy server
    for this information, feel free to do so. However, since every model of network
    device is somewhat different, I won’t walk you through the steps here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找设备在连接互联网设备时使用的公有 IP 地址，一种选择是登录到您的路由器或代理服务器并检查其网络配置。如果您知道如何查询路由器或代理服务器以获取这些信息，随时可以进行操作。不过，由于每种网络设备的型号略有不同，我在这里不会一一讲解步骤。
- en: A more universal option is to query an online service that can return your current
    public IP address. This is possible because every internet server that your device
    connects to knows your IP address; it’s simply a matter of finding a service that’s
    willing to tell you what IP address it sees. If you’re running a web browser on
    your device, perhaps the simplest thing to do is query Google for something like
    “my IP address.” This usually returns the information you want.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更通用的选择是查询一个可以返回您当前公有 IP 地址的在线服务。之所以可以实现，是因为每个您的设备连接的互联网服务器都知道您的 IP 地址；关键是找到一个愿意告诉您它看到的
    IP 地址的服务。如果您在设备上使用的是网页浏览器，或许最简单的做法是查询 Google，搜索类似“我的 IP 地址”这样的内容。通常这会返回您想要的信息。
- en: 'If you’re working from a terminal, like on the Raspberry Pi, you can use the
    `curl` utility to make an HTTP request to a website that returns your current
    IP address. The following are a few examples of services that are available for
    this at the time of this writing:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用终端工作，比如在 Raspberry Pi 上，您可以使用 `curl` 工具向一个返回当前 IP 地址的网页发出 HTTP 请求。以下是一些当前可以使用的服务示例：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Any of these should return your public IP address to the terminal window. Compare
    this address with the address you got earlier from `ifconfig`. If they are the
    same, then your device is directly assigned a public IP address. If they differ,
    then your device likely has a private IP assigned to it, and you’re connecting
    to the internet through a NAT router or proxy server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个命令都应该返回你的公共IP地址到终端窗口。将此地址与之前通过`ifconfig`获得的地址进行比较。如果它们相同，则说明你的设备直接分配了公共IP地址。如果不同，则说明你的设备可能被分配了私有IP地址，你正在通过NAT路由器或代理服务器连接到互联网。
- en: '**PROJECT #35: FIND INFORMATION IN DNS**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #35：在DNS中查找信息**'
- en: 'Prerequisite: A Raspberry Pi, running Raspberry Pi OS.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：一台运行Raspberry Pi OS的树莓派。
- en: In this project, you’ll use your Raspberry Pi to query DNS records. Let’s begin
    by looking up the IP address of a website. You’ll use the `host` utility to do
    this. The following command returns the IP address of *`www.example.com`*, the
    hostname of the site I’m interested in. Feel free to substitute the name of another
    host you wish to look up.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用树莓派查询DNS记录。让我们从查找一个网站的IP地址开始。你将使用`host`工具来完成此操作。以下命令返回我感兴趣的网站*`www.example.com`*的IP地址。你可以自由替换为你希望查找的其他主机名。
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should see output that gives the IP address of the host. You may also see
    an IPv6 address. Depending on the hostname you queried, you may get back multiple
    records, since a DNS name can map to multiple IP addresses. You may also learn
    that the name you typed is actually an alias for a different name, which in turn
    maps to an IP address.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到输出，显示该主机的IP地址。你可能还会看到一个IPv6地址。根据你查询的主机名，可能会返回多个记录，因为一个DNS名称可以映射到多个IP地址。你还可能会发现你输入的名称实际上是另一个名称的别名，而该名称又映射到一个IP地址。
- en: 'DNS also allows for reverse lookups, where you specify an IP address and a
    hostname is returned. This doesn’t always work, since DNS records need to be in
    place to support it. To give this a try, just use `host` with an IP address. In
    the following command, replace *`a.b.c.d`* with your public IP address that you
    found in [Project #34](ch11.xhtml#proj34), or any other public IP address you
    wish to query. Again, this works only for IP addresses that have DNS records in
    place to support reverse lookups.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'DNS还支持反向查找，你可以指定一个IP地址，返回与之对应的主机名。这并不总是有效，因为需要DNS记录来支持此功能。想尝试的话，只需使用`host`命令并提供一个IP地址。在以下命令中，将*`a.b.c.d`*替换为你在[项目
    #34](ch11.xhtml#proj34)中找到的公共IP地址，或者任何其他你想查询的公共IP地址。同样，这仅对那些已有DNS记录支持反向查找的IP地址有效。'
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, the `host` utility uses the DNS server your device is configured
    to use. You may also query a specific DNS server using `host` by specifying the
    IP address of that server. Internet service providers include DNS services for
    their customers, but many free alternate DNS services are available as well. For
    example, at the time of this writing, Google provides a DNS server at 8.8.8.8
    and Cloudflare provides a DNS server at 1.1.1.1\. If you want to use the DNS server
    at 1.1.1.1 to look up *www.example.com*, you could enter this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`host`工具使用你的设备配置的DNS服务器。你也可以通过指定该服务器的IP地址，使用`host`查询特定的DNS服务器。互联网服务提供商为其客户提供DNS服务，但也有许多免费的替代DNS服务可用。例如，在本文撰写时，Google提供了一个DNS服务器，地址为8.8.8.8，Cloudflare提供了一个DNS服务器，地址为1.1.1.1。如果你想使用1.1.1.1的DNS服务器查找*www.example.com*，你可以输入如下命令：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This should output IP address information as before, along with some text indicating
    which DNS server was used for the lookup.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出与之前相同的IP地址信息，并附带一些文本，指示用于查找的DNS服务器。
- en: If you’re curious about the details of the DNS query, you can use the `-v` option
    with the host command, which provides verbose output.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对DNS查询的详细信息感兴趣，可以在使用`host`命令时加上`-v`选项，这样会提供详细输出。
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
