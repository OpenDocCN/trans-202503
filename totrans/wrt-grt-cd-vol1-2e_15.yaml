- en: 'AFTERWORD: THINKING LOW-LEVEL, WRITING HIGH-LEVEL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal of this book was to get you thinking at the machine level. One way
    to force yourself to write code at this level is to write your applications in
    assembly language. When you write code statement by statement in assembly language,
    you get a pretty good idea of the cost associated with each one.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, using assembly language isn’t a realistic solution for most applications.
    The disadvantages of assembly language have been well publicized (and exaggerated)
    over the past several decades, and as a result many people have decided assembly
    isn’t an option for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike writing code in assembly language, writing code in a high-level language
    doesn’t force you to think at a high level of abstraction. There’s nothing preventing
    you from thinking in low-level terms while writing high-level code. This book
    has equipped you with the background knowledge you need to do just that. By learning
    how the computer represents data, you’ve learned how HLL data types translate
    to the machine level. By learning how the CPU executes machine instructions, you’ve
    learned the costs of various operations in your HLL applications. And by learning
    about memory performance, you’ve learned how to organize your HLL variables and
    other data to maximize cache and memory access. There’s only one piece missing
    from this puzzle: “Exactly *how* does a particular compiler map HLL statements
    to the machine level?” That topic is sufficiently large that it deserves an entire
    book on its own. And that’s the purpose of the second volume in the *Write Great
    Code* series: *Thinking Low-Level, Writing High-Level*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*WGC2* will pick up right where this book leaves off. It will teach you how
    each statement in a typical HLL maps to machine code, how you can choose between
    two or more high-level sequences to produce the best possible machine code, and
    how to analyze that machine code to determine its quality and that of the high-level
    code that produced it. And while doing all of this, it will give you a greater
    appreciation for how compilers work and encourage you to help them do their job
    better.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on your progress thus far toward writing great code. See you
    in Volume 2.
  prefs: []
  type: TYPE_NORMAL
