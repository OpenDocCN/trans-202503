- en: 'AFTERWORD: THINKING LOW-LEVEL, WRITING HIGH-LEVEL'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后记：低级思维，高级编程
- en: '![Image](../images/comm1.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: The goal of this book was to get you thinking at the machine level. One way
    to force yourself to write code at this level is to write your applications in
    assembly language. When you write code statement by statement in assembly language,
    you get a pretty good idea of the cost associated with each one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是让你开始从机器级的角度思考。迫使自己在这个层次上编写代码的一种方法是用汇编语言编写应用程序。当你一条一条地用汇编语言编写代码时，你会对每一条语句的成本有一个相当清晰的了解。
- en: Unfortunately, using assembly language isn’t a realistic solution for most applications.
    The disadvantages of assembly language have been well publicized (and exaggerated)
    over the past several decades, and as a result many people have decided assembly
    isn’t an option for them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用汇编语言并不是大多数应用程序的现实解决方案。汇编语言的缺点在过去几十年间已被广泛宣传（甚至夸大），因此许多人决定不再选择汇编语言。
- en: 'Unlike writing code in assembly language, writing code in a high-level language
    doesn’t force you to think at a high level of abstraction. There’s nothing preventing
    you from thinking in low-level terms while writing high-level code. This book
    has equipped you with the background knowledge you need to do just that. By learning
    how the computer represents data, you’ve learned how HLL data types translate
    to the machine level. By learning how the CPU executes machine instructions, you’ve
    learned the costs of various operations in your HLL applications. And by learning
    about memory performance, you’ve learned how to organize your HLL variables and
    other data to maximize cache and memory access. There’s only one piece missing
    from this puzzle: “Exactly *how* does a particular compiler map HLL statements
    to the machine level?” That topic is sufficiently large that it deserves an entire
    book on its own. And that’s the purpose of the second volume in the *Write Great
    Code* series: *Thinking Low-Level, Writing High-Level*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与汇编语言编写代码不同，使用高级语言编写代码并不会强制你在抽象的高层次上思考。在编写高级代码时，完全没有什么能阻止你用低级术语来思考。本书已经为你提供了做这件事所需的背景知识。通过学习计算机如何表示数据，你了解了高级语言数据类型如何映射到机器级别。通过学习CPU如何执行机器指令，你了解了各种操作在高级语言应用中的成本。通过学习内存性能，你了解了如何组织你的高级语言变量和其他数据，以最大化缓存和内存访问。现在，这个谜题只剩下最后一块：
    “究竟*如何*将某个特定编译器的高级语言语句映射到机器级别？” 这个话题足够庞大，值得另起一本书来讲解。这也是《写出伟大代码》系列第二卷的目的：*低级思维，高级编程*。
- en: '*WGC2* will pick up right where this book leaves off. It will teach you how
    each statement in a typical HLL maps to machine code, how you can choose between
    two or more high-level sequences to produce the best possible machine code, and
    how to analyze that machine code to determine its quality and that of the high-level
    code that produced it. And while doing all of this, it will give you a greater
    appreciation for how compilers work and encourage you to help them do their job
    better.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*WGC2* 将从本书的结尾接着讲解。它将教你如何将典型高级语言中的每条语句映射到机器代码，如何在两个或多个高级语言序列之间做出选择，以生成最优的机器代码，并如何分析这些机器代码以评估它的质量以及产生它的高级语言代码的质量。同时，它将帮助你更好地理解编译器的工作原理，并鼓励你协助编译器更好地完成它的工作。'
- en: Congratulations on your progress thus far toward writing great code. See you
    in Volume 2.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你在编写伟大代码的进程中取得了如此大的进展。第二卷见。
