["```\n#include <deque>\n#include <iterator>\n\nTEST_CASE(\"Insert iterators convert writes into container insertions.\") {\n  std::deque<int> dq;\n  auto back_instr = std::back_inserter(dq); ➊\n  *back_instr = 2; ➋ // 2\n  ++back_instr; ➌\n  *back_instr = 4; ➍ // 2 4\n  ++back_instr;\n\n  auto front_instr = std::front_inserter(dq); ➎\n  *front_instr = 1; ➏ // 1 2 4\n  ++front_instr;\n\n  auto instr = std::inserter(dq, dq.begin()+2); ➐\n  *instr = 3; ➑ // 1 2 3 4\n  instr++;\n\n  REQUIRE(dq[0] == 1);\n  REQUIRE(dq[1] == 2);\n  REQUIRE(dq[2] == 3);\n  REQUIRE(dq[3] == 4); ➒\n}\n```", "```\n#include <forward_list>\n\nTEST_CASE(\"std::forward_list begin and end provide input iterators\") {\n  const std::forward_list<int> easy_as{ 1, 2, 3 }; ➊\n  auto itr = easy_as.begin(); ➋\n  REQUIRE(*itr == 1); ➌\n  itr++; ➍\n  REQUIRE(*itr == 2);\n  itr++;\n  REQUIRE(*itr == 3);\n  itr++;\n  REQUIRE(itr == easy_as.end()); ➎\n}\n```", "```\nTEST_CASE(\"std::forward_list’s begin and end provide forward iterators\") {\n  const std::forward_list<int> easy_as{ 1, 2, 3 }; ➊\n  auto itr1 = easy_as.begin(); ➋\n  auto itr2{ itr1 }; ➌\n  int double_sum{};\n  while (itr1 != easy_as.end()) ➍\n    double_sum += *(itr1++);\n  while (itr2 != easy_as.end()) ➎\n    double_sum += *(itr2++);\n  REQUIRE(double_sum == 12); ➏\n}\n```", "```\n#include <list>\n\nTEST_CASE(\"std::list begin and end provide bidirectional iterators\") {\n  const std::list<int> easy_as{ 1, 2, 3 }; ➊\n  auto itr = easy_as.begin(); ➋\n  REQUIRE(*itr == 1); ➌\n  itr++; ➍\n  REQUIRE(*itr == 2);\n  itr--; ➎\n  REQUIRE(*itr == 1); ➏\n  REQUIRE(itr == easy_as.cbegin());\n}\n```", "```\n#include <vector>\n\nTEST_CASE(\"std::vector begin and end provide random-access iterators\") {\n  const std::vector<int> easy_as{ 1, 2, 3 }; ➊\n  auto itr = easy_as.begin(); ➋\n  REQUIRE(itr[0] == 1); ➌\n  itr++; ➍\n  REQUIRE(*(easy_as.cbegin() + 2) == 3); ➎\n  REQUIRE(easy_as.cend() - itr == 2); ➏\n}\n```", "```\n&itr[n] + i == &itr[n+i]\n```", "```\n#include <deque>\n\nTEST_CASE(\"Mutable random-access iterators support writing.\") {\n  std::deque<int> easy_as{ 1, 0, 3 }; ➊\n  auto itr = easy_as.begin(); ➋\n  itr[1] = 2; ➌\n  itr++; ➍\n  REQUIRE(*itr == 2); ➎\n}\n```", "```\nvoid std::advance(InputIterator&➊ itr, Distance➋ d);\n```", "```\n#include <iterator>\n\nTEST_CASE(\"advance modifies input iterators\") {\n  std::vector<unsigned char> mission{ ➊\n    0x9e, 0xc4, 0xc1, 0x29,\n    0x49, 0xa4, 0xf3, 0x14,\n    0x74, 0xf2, 0x99, 0x05,\n    0x8c, 0xe2, 0xb2, 0x2a\n  };\n  auto itr = mission.begin(); ➋\n  std::advance(itr, 4); ➌\n  REQUIRE(*itr == 0x49);\n  std::advance(itr, 4); ➍\n  REQUIRE(*itr == 0x74);\n  std::advance(itr, -8); ➎\n  REQUIRE(*itr == 0x9e);\n}\n```", "```\nForwardIterator std::next(ForwardIterator& itr➊, Distance d=1➋);\nBidirectionalIterator std::prev(BidirectionalIterator& itr➌, Distance d=1➍);\n```", "```\n#include <iterator>\n\nTEST_CASE(\"next returns iterators at given offsets\") {\n  std::vector<unsigned char> mission{\n    0x9e, 0xc4, 0xc1, 0x29,\n    0x49, 0xa4, 0xf3, 0x14,\n    0x74, 0xf2, 0x99, 0x05,\n    0x8c, 0xe2, 0xb2, 0x2a\n  };\n  auto itr1 = mission.begin(); ➊\n  std::advance(itr1, 4); ➋\n  REQUIRE(*itr1 == 0x49); ➌\n\n  auto itr2 = std::next(itr1); ➍\n  REQUIRE(*itr2 == 0xa4); ➎\n\n  auto itr3 = std::next(itr1, 4); ➏\n  REQUIRE(*itr3 == 0x74); ➐\n\n  REQUIRE(*itr1 == 0x49); ➑\n}\n```", "```\nDistance std::distance(InputIterator itr1, InputIterator itr2);\n```", "```\n#include <iterator>\n\nTEST_CASE(\"distance returns the number of elements between iterators\") {\n  std::vector<unsigned char> mission{ ➊\n    0x9e, 0xc4, 0xc1, 0x29,\n    0x49, 0xa4, 0xf3, 0x14,\n    0x74, 0xf2, 0x99, 0x05,\n    0x8c, 0xe2, 0xb2, 0x2a\n  };\n  auto eighth = std::next(mission.begin(), 8); ➋\n  auto fifth = std::prev(eighth, 3); ➌\n  REQUIRE(std::distance(fifth, eighth) == 3); ➍\n}\n```", "```\nDistance std::iter_swap(ForwardIterator itr1, ForwardIterator itr2);\n```", "```\n#include <iterator>\n\nTEST_CASE(\"iter_swap swaps pointed-to elements\") {\n  std::vector<long> easy_as{ 3, 2, 1 }; ➊\n  std::iter_swap(easy_as.begin()➋, std::next(easy_as.begin(), 2)➌);\n  REQUIRE(easy_as[0] == 1); ➍\n  REQUIRE(easy_as[1] == 2);\n  REQUIRE(easy_as[2] == 3);\n}\n```", "```\nstruct Movable{\n  Movable(int id) : id{ id } { } ➊\n  Movable(Movable&& m) {\n    id = m.id; ➋\n    m.id = -1; ➌\n  }\n  int id;\n};\n```", "```\n#include <iterator>\n\nTEST_CASE(\"move iterators convert accesses into move operations\") {\n  std::vector<Movable> donor; ➊\n  donor.emplace_back(1); ➋\n  donor.emplace_back(2);\n  donor.emplace_back(3);\n  std::vector<Movable> recipient{\n    std::make_move_iterator(donor.begin()), ➌\n    std::make_move_iterator(donor.end()),\n  };\n  REQUIRE(donor[0].id == -1); ➍\n  REQUIRE(donor[1].id == -1);\n  REQUIRE(donor[2].id == -1);\n  REQUIRE(recipient[0].id == 1); ➎\n  REQUIRE(recipient[1].id == 2);\n  REQUIRE(recipient[2].id == 3);\n}\n```", "```\nTEST_CASE(\"reverse iterators can initialize containers\") {\n  std::list<int> original{ 3, 2, 1 }; ➊\n  std::vector<int> easy_as{ original.crbegin(), original.crend() }; ➋\n  REQUIRE(easy_as[0] == 1); ➌\n  REQUIRE(easy_as[1] == 2);\n  REQUIRE(easy_as[2] == 3);\n}\n```", "```\nTEST_CASE(\"make_reverse_iterator converts a normal iterator\") {\n  std::list<int> original{ 3, 2, 1 };\n  auto begin = std::make_reverse_iterator(original.cend()); ➊\n  auto end = std::make_reverse_iterator(original.cbegin()); ➋\n  std::vector<int> easy_as{ begin, end }; ➌\n  REQUIRE(easy_as[0] == 1);\n  REQUIRE(easy_as[1] == 2);\n  REQUIRE(easy_as[2] == 3);\n}\n```"]