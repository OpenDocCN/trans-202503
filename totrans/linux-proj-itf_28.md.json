["```\n#define _BSD_SOURCE\n#include <unistd.h>\n\nint `acct`(const char **acctfile*);\n```", "```\n`procexec/acct_on.c`\n#define _BSD_SOURCE\n#include <unistd.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    if (argc > 2 || (argc > 1 && strcmp(argv[1], \"--help\") == 0))\n        usageErr(\"%s [file]\\n\");\n\n    if (acct(argv[1]) == -1)\n        errExit(\"acct\");\n\n    printf(\"Process accounting %s\\n\",\n            (argv[1] == NULL) ? \"disabled\" : \"enabled\");\n    exit(EXIT_SUCCESS);\n}\n     `procexec/acct_on.c`\n```", "```\ntypedef u_int16_t comp_t;  /* See text */\n\nstruct acct {\n    char      ac_flag;     /* Accounting flags (see text) */\n    u_int16_t ac_uid;      /* User ID of process */\n    u_int16_t ac_gid;      /* Group ID of process */\n    u_int16_t ac_tty;      /* Controlling terminal for process (may be\n                              0 if none, e.g., for a daemon) */\n    u_int32_t ac_btime;    /* Start time (time_t; seconds since the Epoch) */\n    comp_t    ac_utime;    /* User CPU time (clock ticks) */\n    comp_t    ac_stime;    /* System CPU time (clock ticks) */\n    comp_t    ac_etime;    /* Elapsed (real) time (clock ticks) */\n    comp_t    ac_mem;      /* Average memory usage (kilobytes) */\n    comp_t    ac_io;       /* Bytes transferred by read(2) and write(2)\n                              (unused) */\n    comp_t    ac_rw;       /* Blocks read/written (unused) */\n    comp_t    ac_minflt;   /* Minor page faults (Linux-specific) */\n    comp_t    ac_majflt;   /* Major page faults (Linux-specific) */\n    comp_t    ac_swaps;    /* Number of swaps (unused; Linux-specific) */\n    u_int32_t ac_exitcode; /* Process termination status */\n#define ACCT_COMM 16\n    char      ac_comm[ACCT_COMM+1];\n                           /* (Null-terminated) command name\n                              (basename of last execed file) */\n    char      ac_pad[10];  /* Padding (reserved for future use) */\n};\n```", "```\n$ `su`                            *Need privilege to enable process accounting*\nPassword:\n# `touch pacct`\n# `./acct_on pacct`\n               *This process will be first entry in accounting file*\nProcess accounting enabled\n# `exit`                          *Cease being superuser*\n```", "```\n$ `sleep 15 &`\n[1] 18063\n$ `ulimit -c unlimited`           *Allow core dumps (shell built-in)*\n$ `cat`                           *Create a process*\n*Type Control-\\ (generates* SIGQUIT *, signal 3) to kill cat process*\nQuit (core dumped)\n$\n*Press Enter to see shell notification*\n *of completion of sleep before next shell prompt*\n[1]+  Done          sleep 15\n$ `grep xxx badfile`              *grep fails with status of 2*\ngrep: badfile: No such file or directory\n$ `echo $?`                       *The shell obtained status of grep (shell built-in)*\n2\n```", "```\n$ `./t_execve /bin/echo`\nhello world goodbye\n$ `./t_fork`\nPID=18350 (child) idata=333 istack=666\nPID=18349 (parent) idata=111 istack=222\n```", "```\n$ `./acct_view pacct`\ncommand  flags   term.  user     start time            CPU   elapsed\n                status                                 time    time\nacct_on   -S--      0   root     2010-07-23 17:19:05   0.00    0.00\nbash      ----      0   root     2010-07-23 17:18:55   0.02   21.10\nsu        -S--      0   root     2010-07-23 17:18:51   0.01   24.94\ncat       --XC   0x83   mtk      2010-07-23 17:19:55   0.00    1.72\nsleep     ----      0   mtk      2010-07-23 17:19:42   0.00   15.01\ngrep      ----  0x200   mtk      2010-07-23 17:20:12   0.00    0.00\necho      ----      0   mtk      2010-07-23 17:21:15   0.01    0.01\nt_fork    F---      0   mtk      2010-07-23 17:21:36   0.00    0.00\nt_fork    ----      0   mtk      2010-07-23 17:21:36   0.00    3.01\n```", "```\n`procexec/acct_view.c`\n#include <fcntl.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/acct.h>\n#include <limits.h>\n#include \"ugid_functions.h\"             /* Declaration of userNameFromId() */\n#include \"tlpi_hdr.h\"\n\n#define TIME_BUF_SIZE 100\n\nstatic long long                /* Convert comp_t value into long long */\ncomptToLL(comp_t ct)\n{\n    const int EXP_SIZE = 3;             /* 3-bit, base-8 exponent */\n    const int MANTISSA_SIZE = 13;       /* Followed by 13-bit mantissa */\n    const int MANTISSA_MASK = (1 << MANTISSA_SIZE) - 1;\n    long long mantissa, exp;\n\n    mantissa = ct & MANTISSA_MASK;\n    exp = (ct >> MANTISSA_SIZE) & ((1 << EXP_SIZE) - 1);\n    return mantissa << (exp * 3);       /* Power of 8 = left shift 3 bits */\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int acctFile;\n    struct acct ac;\n    ssize_t numRead;\n    char *s;\n    char timeBuf[TIME_BUF_SIZE];\n    struct tm *loc;\n    time_t t;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file\\n\", argv[0]);\n\n    acctFile = open(argv[1], O_RDONLY);\n    if (acctFile == -1)\n        errExit(\"open\");\n\n    printf(\"command  flags   term.  user     \"\n            \"start time            CPU   elapsed\\n\");\n    printf(\"                status           \"\n            \"                      time    time\\n\");\n\n    while ((numRead = read(acctFile, &ac, sizeof(struct acct))) > 0) {\n        if (numRead != sizeof(struct acct))\n            fatal(\"partial read\");\n\n        printf(\"%-8.8s  \", ac.ac_comm);\n\n        printf(\"%c\", (ac.ac_flag & AFORK) ? 'F' : '-') ;\n        printf(\"%c\", (ac.ac_flag & ASU)   ? 'S' : '-') ;\n        printf(\"%c\", (ac.ac_flag & AXSIG) ? 'X' : '-') ;\n        printf(\"%c\", (ac.ac_flag & ACORE) ? 'C' : '-') ;\n\n#ifdef __linux__\n        printf(\" %#6lx   \", (unsigned long) ac.ac_exitcode);\n#else   /* Many other implementations provide ac_stat instead */\n        printf(\" %#6lx   \", (unsigned long) ac.ac_stat);\n#endif\n\n        s = userNameFromId(ac.ac_uid);\n        printf(\"%-8.8s \", (s == NULL) ? \"???\" : s);\n\n        t = ac.ac_btime;\n        loc = localtime(&t);\n        if (loc == NULL) {\n            printf(\"???Unknown time???  \");\n        } else {\n            strftime(timeBuf, TIME_BUF_SIZE, \"%Y-%m-%d %T \", loc);\n            printf(\"%s \", timeBuf);\n        }\n\n        printf(\"%5.2f %7.2f \", (double) (comptToLL(ac.ac_utime) +\n                    comptToLL(ac.ac_stime)) / sysconf(_SC_CLK_TCK),\n                (double) comptToLL(ac.ac_etime) / sysconf(_SC_CLK_TCK));\n        printf(\"\\n\");\n    }\n\n    if (numRead == -1)\n        errExit(\"read\");\n\n    exit(EXIT_SUCCESS);\n}\n     `procexec/acct_view.c`\n```", "```\nstruct acct_v3 {\n    char      ac_flag;        /* Accounting flags */\n    char      ac_version;     /* Accounting version (3) */\n    u_int16_t ac_tty;         /* Controlling terminal for process */\n    u_int32_t ac_exitcode;    /* Process termination status */\n    u_int32_t ac_uid;         /* 32-bit user ID of process */\n    u_int32_t ac_gid;         /* 32-bit group ID of process */\n    u_int32_t ac_pid;         /* Process ID */\n    u_int32_t ac_ppid;        /* Parent process ID */\n    u_int32_t ac_btime;       /* Start time (time_t) */\n    float     ac_etime;       /* Elapsed (real) time (clock ticks) */\n    comp_t    ac_utime;       /* User CPU time (clock ticks) */\n    comp_t    ac_stime;       /* System CPU time (clock ticks) */\n    comp_t    ac_mem;         /* Average memory usage (kilobytes) */\n    comp_t    ac_io;          /* Bytes read/written (unused) */\n    comp_t    ac_rw;          /* Blocks read/written (unused) */\n    comp_t    ac_minflt;      /* Minor page faults */\n    comp_t    ac_majflt;      /* Major page faults */\n    comp_t    ac_swaps;       /* Number of swaps (unused; Linux-specific) */\n#define ACCT_COMM 16\n    char      ac_comm[ACCT_COMM];   /* Command name */\n};\n```", "```\n#define _GNU_SOURCE\n#include <sched.h>\n\nint `clone`(int (**func*) (void *), void **child_stack*, int\n *flags*, void **func_arg*, ...\n          /* pid_t **ptid*, struct user_desc **tls*, pid_t **ctid* */ );\n```", "```\n`procexec/t_clone.c`\n    #define _GNU_SOURCE\n    #include <signal.h>\n    #include <sys/wait.h>\n    #include <fcntl.h>\n    #include <sched.h>\n    #include \"tlpi_hdr.h\"\n\n    #ifndef CHILD_SIG\n    #define CHILD_SIG SIGUSR1       /* Signal to be generated on termination\n                                       of cloned child */\n    #endif\n\n    static int                      /* Startup function for cloned child */\n    childFunc(void *arg)\n    {\n   if (close(*((int *) arg)) == -1)\n            errExit(\"close\");\n\n        return 0;                           /* Child terminates now */\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        const int STACK_SIZE = 65536;       /* Stack size for cloned child */\n        char *stack;                        /* Start of stack buffer */\n        char *stackTop;                     /* End of stack buffer */\n        int s, fd, flags;\n\n   fd = open(\"/dev/null\", O_RDWR);     /* Child will close this fd */\n        if (fd == -1)\n            errExit(\"open\");\n\n          /* If argc > 1, child shares file descriptor table with parent */\n\n    flags = (argc > 1) ? CLONE_FILES : 0;\n\n        /* Allocate stack for child */\n\n    stack = malloc(STACK_SIZE);\n        if (stack == NULL)\n            errExit(\"malloc\");\n        stackTop = stack + STACK_SIZE;      /* Assume stack grows downward */\n\n        /* Ignore CHILD_SIG, in case it is a signal whose default is to\n           terminate the process; but don't ignore SIGCHLD (which is ignored\n           by default), since that would prevent the creation of a zombie. */\n\n    if (CHILD_SIG != 0 && CHILD_SIG != SIGCHLD)\n            if (signal(CHILD_SIG, SIG_IGN) == SIG_ERR)\n                errExit(\"signal\");\n\n        /* Create child; child commences execution in childFunc() */\n\n    if (clone(childFunc, stackTop, flags | CHILD_SIG, (void *) &fd) == -1)\n            errExit(\"clone\");\n\n        /* Parent falls through to here. Wait for child; __WCLONE is\n           needed for child notifying with signal other than SIGCHLD. */\n\n    if (waitpid(-1, NULL, (CHILD_SIG != SIGCHLD) ? __WCLONE : 0) == -1)\n            errExit(\"waitpid\");\n        printf(\"child has terminated\\n\");\n\n        /* Did close() of file descriptor in child affect parent? */\n\n    s = write(fd, \"x\", 1);\n        if (s == -1 && errno == EBADF)\n            printf(\"file descriptor %d has been closed\\n\", fd);\n        else if (s == -1)\n            printf(\"write() on file descriptor %d failed \"\n                    \"unexpectedly (%s)\\n\", fd, strerror(errno));\n        else\n            printf(\"write() on file descriptor %d succeeded\\n\", fd);\n\n        exit(EXIT_SUCCESS);\n    }\n         `procexec/t_clone.c`\n```", "```\n$ `./t_clone`                               *Doesn’t use* CLONE_FILES\nchild has terminated\nwrite() on file descriptor 3 succeeded    *Child’s close() did not affect parent*\n```", "```\n$ `./t_clone x`                             *Uses* CLONE_FILES\nchild has terminated\nfile descriptor 3 has been closed         *Child’s close() affected parent*\n```", "```\ntid = clone(...);\n```", "```\nCLONE_VM | CLONE_VFORK | SIGCHLD\n```", "```\nCLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND\n```", "```\nCLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |\nCLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM\n```", "```\nCLONE_VM | CLONE_VFORK | CLONE_FS | CLONE_SIGHAND | CLONE_FILES\n```"]