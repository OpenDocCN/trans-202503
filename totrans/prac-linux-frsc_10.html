<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_273"/><strong><span class="big">10</span><br/>RECONSTRUCTING USER DESKTOPS AND LOGIN ACTIVITY</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">It is often necessary to reconstruct user login activity to know when a person has logged in to a system, how they logged in, what they were doing, and when they finally logged out. This chapter explains various aspects of shell and desktop user logins, and describes various artifacts that are interesting from a digital forensics perspective.</p>&#13;
<p class="indent">We are primarily focused on <em>human</em> interaction with the computer. Other system “users” are running daemons or starting programs, but they are part of normal system operation and are covered in other sections of the book. The human use of peripheral devices, such as printers, external drives, and so on, is also covered separately in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<h3 class="h3" id="ch00lev1_47"><strong>Linux Login and Session Analysis</strong></h3>&#13;
<p class="noindent">On early Unix systems, users logged in via a physical terminal or a terminal emulated by a PC, both of which connected over an RS232 serial line. Remote connections were possible using analog modems over dial-up or leased <span epub:type="pagebreak" id="page_274"/>lines from the local phone company. As TCP/IP became popular, users logged in over the network using telnet or rlogin. Users entered their login name and password, and if correct, the system ran scripts to set up their environments and provide a command line prompt. When the user finished, they logged out, and the terminal was reset to prepare for the next login.</p>&#13;
<p class="indent">Today, people log in using the local console or securely over a network. The most common ways to log in to Linux systems are:</p>&#13;
<ul>&#13;
<li class="noindent">Graphical logins through a local <em>display manager</em> (usually workstations and laptops)</li>&#13;
<li class="noindent">Shell logins on a local virtual console (usually physical server access)</li>&#13;
<li class="noindent">Shell logins remotely over a network using secure shell (SSH) (usually remote server access)</li>&#13;
<li class="noindent">Shell logins over local serial lines (often used by embedded systems or Linux-based IoT devices)</li>&#13;
</ul>&#13;
<p class="noindent"><a href="ch10.xhtml#ch010fig01">Figure 10-1</a> shows a simplified overview of these user login methods.</p>&#13;
<div class="image"><img id="ch010fig01" src="Images/ch10fig01.jpg" alt="Image" width="688" height="715"/></div>&#13;
<p class="figcap"><em>Figure 10-1: System initialization and user login process</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_275"/>The first three of the above listed login methods are primarily intended for human interaction. The last login method is mostly used as an interface for configuration, firmware updates, or diagnostic programs, and it may use internal pins directly on the circuit board. Serial line logins can be useful in the forensic analysis of embedded and IoT devices where storage cannot be removed and imaged like a regular computer.</p>&#13;
<p class="indent">Remote desktop connections like VNC are not listed here because they are usually connecting to an already logged-in desktop or remotely accessing the display manager. In such cases, the remote desktop can be analyzed like a local graphical login. Remote desktop access is explained at the end of this chapter.</p>&#13;
<p class="indent">The following sections describe how login sessions work and identify interesting digital forensic artifacts that may be available.</p>&#13;
<h4 class="h4" id="ch00lev2_130"><strong><em>Seats and Sessions</em></strong></h4>&#13;
<p class="noindent">To analyze human user activity on a Linux system, we must understand the concepts of seats, users, and sessions.</p>&#13;
<p class="indent">A <em>seat</em> is typically composed of one or more screens, a keyboard and mouse (unless the screen is a touchscreen), audio devices, video cameras, and other human interactive peripherals attached to a local workplace. The default seat name is <span class="literal">seat0</span>, and it’s recognized on system boot. We can view it in the systemd journal:</p>&#13;
<pre>Jul 23 13:06:11 pc1 systemd-logind[316]: New seat seat0.</pre>&#13;
<p class="noindent">A Linux system can be configured to have additional seats when a PC has multiple keyboards and screens for more than one person (though this is somewhat rare).</p>&#13;
<p class="indent">We can view a seat’s device components on a live system with <span class="codestrong">loginctl seat-status seat0</span>; however, this information is not available in a postmortem forensic investigation and must be inferred or reconstructed from the logs. See the sd-login(3) man page for more information on seats.</p>&#13;
<p class="indent">The term <em>user</em> can refer to either a person or a process. A human user is a person with a user account on the computer, which corresponds to a traditional Unix username and numeric user ID (UID). System processes (which are not people) also run under specified usernames and UIDs. When performing a forensic analysis of a system, it is important to differentiate between human and system user activity. A human user will log in from a seat or remotely with SSH or some other remote access method. Non-human (system process) users are typically daemons started from systemd or by some other system user.</p>&#13;
<p class="indent">A <em>session</em> is the duration of a user login and can take place on a physical seat or over a network connection such as SSH. After a successful login, a user is given a session ID, and the session is cleanly terminated at logout. Sessions are logged and managed by systemd-logind. Systemd, together with the display manager, can also facilitate <em>fast user switching</em>. This means that <span epub:type="pagebreak" id="page_276"/>multiple users can be logged in to the same seat at the same time and can securely switch control between them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The word “session" has many meanings in computing. There are system login sessions, desktop sessions, application login sessions, browser sessions, TCP sessions, SSL/TLS sessions, and others. When performing forensic analysis work and writing forensic reports, make sure the use of the word session is clearly understood.</em></p>&#13;
</div>&#13;
<p class="indent">Early Unix systems were expensive, and accounting logs were developed to facilitate billing of users or departments. Administrators needed to know when a user logged in, when they logged off, and possibly other usage information. On modern Linux systems, this is largely managed by systemd, but some traditional files still record the state and history of user login sessions:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<tbody>&#13;
<tr>&#13;
<td><strong><em>/var/log/wtmp</em></strong></td>&#13;
<td>History of successful logins and logouts</td>&#13;
</tr>&#13;
<tr>&#13;
<td><strong><em>/var/log/btmp</em></strong></td>&#13;
<td>History of failed login attempts</td>&#13;
</tr>&#13;
<tr>&#13;
<td><strong><em>/var/log/lastlog</em></strong></td>&#13;
<td>Most recent user logins</td>&#13;
</tr>&#13;
<tr>&#13;
<td><strong><em>/var/run/utmp</em></strong></td>&#13;
<td>Current users logged in (only on running systems)</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="indent">When performing a postmortem forensic analysis of a modern Linux system, anything stored temporarily on pseudo-filesystems will not be available (pseudo-filesystems are stored in memory). The <em>/var/run/utmp</em> will not be available for analysis unless it is recovered from a memory image.</p>&#13;
<p class="indent">The <span class="literal">utmpdump</span><sup><a id="ch10foot01" href="footnotes.xhtml#ch10foot_01">1</a></sup> tool can be used to view the raw contents of <em>wtmp</em> and <em>btmp</em> (and <em>utmp</em> on a live system). Here are some example entries:</p>&#13;
<pre>[1] [00000] [~~  ] [shutdown] [~          ] [5.7.9-arch1-1   ]&#13;
 [0.0.0.0        ] [2020-07-23T07:54:31,091222+00:00]&#13;
[2] [00000] [~~  ] [reboot  ] [~          ] [5.7.9-arch1-1   ]&#13;
 [0.0.0.0        ] [2020-07-23T07:59:19,330505+00:00]&#13;
[5] [00392] [tty1] [        ] [/dev/tty1  ] [                ]&#13;
 [0.0.0.0        ] [2020-07-23T07:59:21,363253+00:00]&#13;
[6] [00392] [tty1] [LOGIN   ] [tty1       ] [                ]&#13;
 [0.0.0.0        ] [2020-07-23T07:59:21,363253+00:00]&#13;
[7] [00392] [tty1] [sam     ] [tty1       ] [                ]&#13;
 [0.0.0.0        ] [2020-07-23T07:59:31,017548+00:00]&#13;
[7] [14071] [s/11] [sam     ] [pts/11     ] [10.0.1.30       ]&#13;
 [10.0.1.30      ] [2020-07-24T01:44:54,513510+00:00]&#13;
[6] [32537] [    ] [ftpuser ] [ssh:notty  ] [122.224.217.42  ]&#13;
 [122.224.217.42 ] [2020-07-25T05:46:17,000000+00:00]</pre>&#13;
<p class="noindent">The output fields (from left to right and following wrapped lines) are listed here with a description:<sup><a id="ch10foot02" href="footnotes.xhtml#ch10foot_02">2</a></sup></p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>type</em></strong> Type of record (see list of types below)</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_277"/><strong><em>pid</em></strong> PID of login process (agetty, sshd, or 0 for reboots and shutdowns)</p>&#13;
<p class="noindentin"><strong><em>id</em></strong> Terminal name suffix (last four characters of the tty; blank or tildes if none)</p>&#13;
<p class="noindentin"><strong><em>user</em></strong> Username (failed or successful) or action (shutdown, reboot, and so on)</p>&#13;
<p class="noindentin"><strong><em>line</em></strong> Device name of the tty (tilde if none)</p>&#13;
<p class="noindentin"><strong><em>host</em></strong> A hostname or IP address string (or kernel info for some types)</p>&#13;
<p class="noindentin"><strong><em>addr</em></strong> An IP address (IPv4 or IPv6, if available)</p>&#13;
<p class="noindentin"><strong><em>time</em></strong> Timestamp of record</p>&#13;
</div>&#13;
<p class="indent">Depending on the record type and the program writing to <em>wtmp</em> or <em>btmp</em>, the contents of the fields may be used for different information. For example, with types 1 or 2, the <em>user</em> field is used to log a shutdown or reboot, and the <em>host</em> field logs the kernel version. Also notice how <em>id</em> and <em>line</em> are similar, as are <em>host</em> and <em>address</em>. Any program can write to <em>wtmp</em> or <em>btmp</em> and can choose the fields it wants to use. Although this seems redundant, it increases the amount of log information saved from a variety of different programs.</p>&#13;
<p class="indent">The following record type numbers are stored in <em>wtmp</em> and <em>btmp</em> (and <em>/var/run/utmp</em>):</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>0</strong>   Invalid data</p>&#13;
<p class="noindentin"><strong>1</strong>   Change in run level or equivalent systemd target</p>&#13;
<p class="noindentin"><strong>2</strong>   Time of boot</p>&#13;
<p class="noindentin"><strong>3</strong>   Timestamp before a clock change</p>&#13;
<p class="noindentin"><strong>4</strong>   Timestamp after a clock change</p>&#13;
<p class="noindentin"><strong>5</strong>   Process spawned by init</p>&#13;
<p class="noindentin"><strong>6</strong>   Login prompt provided</p>&#13;
<p class="noindentin"><strong>7</strong>   Successful user login</p>&#13;
<p class="noindentin"><strong>8</strong>   Process terminated (logout)</p>&#13;
</div>&#13;
<p class="noindent">For more information, see the utmp(5) man page.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>During a forensic examination, look for possible passwords in the</em> btmp <em>file. If a user accidentally typed their password at the user login prompt, it will be logged here.</em></p>&#13;
</div>&#13;
<p class="indent">Alternatives to <span class="literal">utmpdump</span> are <span class="literal">utmpr</span><sup><a id="ch10foot03" href="footnotes.xhtml#ch10foot_03">3</a></sup> (on GitHub at <em><a href="https://github.com/m9/lastlog/">https://github.com/m9/lastlog/</a></em>) and a one-line Perl script to dump <em>wtmp</em> files (<em><a href="https://www.hcidata.info/wtmp.htm">https://www.hcidata.info/wtmp.htm</a></em>.</p>&#13;
<p class="indent">In addition, the <em>/var/log/lastlog</em> file contains the most recent login information for each user on a system. This is a sparse binary file that can be <span epub:type="pagebreak" id="page_278"/>read on a running system with the <span class="literal">lastlog</span> command. Running <span class="literal">lastlog</span> on a separate Linux examination host will produce incorrect results because it reads the local password file, so an offline forensic tool must be used instead.</p>&#13;
<p class="indent">The following three-line Perl script (<em>lastlog.pl</em>) parses offline <em>lastlog</em> files from suspect Linux systems:</p>&#13;
<pre>#!/bin/perl -w&#13;
$U=0;$/=\292;while(&lt;&gt;){($T,$L,$H)=unpack(IZ32Z256,$_);if($T!=0)&#13;
{printf("%5d %s %s %s\n",$U,scalar(gmtime($T)),$L,$H);}$U++;};</pre>&#13;
<p class="noindent">Running it on an offline examination machine produces output similar to this:</p>&#13;
<pre>$ <span class="codestrong1">./lastlog.pl lastlog</span>&#13;
    0 Sun Jul 26 09:35:06 2020 tty3&#13;
 1000 Sun Jul 26 08:48:19 2020 pts/2 10.0.0.35&#13;
 1001 Mon Mar 30 05:41:18 2020 pts/0 10.0.0.35</pre>&#13;
<p class="noindent">The output starts with the numeric UID followed by a timestamp. The last two columns are the line (or terminal) used and the hostname or IP address (if it exists). This same information is in the <em>wtmp</em> log and should match.</p>&#13;
<p class="indent">The <span class="literal">lslogins</span> tool dumps information about <em>wtmp</em>, <em>btmp</em>, and <em>lastlog</em> in a single table (with the <span class="literal">--output-all</span> flag). It’s also possible to specify which offline copies of the files to use on an analysis machine. However, running this command will still read the <em>/etc/passwd</em> and <em>/etc/shadow</em> on your local analysis machine, creating incorrect output.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be careful when running tools on your analysis machine that are intended for live systems. In many cases, the resulting data will not be about the suspect drive, but from your own analysis machine.</em></p>&#13;
</div>&#13;
<p class="indent">Some machines will have a <em>/var/log/tallylog</em> file. This file maintains the state for <span class="literal">pam_tally</span>, a PAM module that counts attempted logins on a live system, possibly blocking on too many failed attempts. See the pam_tally2(8) man page for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_131"><strong><em>Shell Login</em></strong></h4>&#13;
<p class="noindent">Users can log in to a Linux system with a shell on a local console<sup><a id="ch10foot04" href="footnotes.xhtml#ch10foot_04">4</a></sup> or remotely with SSH. After successful authentication and authorization, a program called a shell is started and the user can interact with the system. This shell program interprets and executes commands typed by the user, or read from a text file run as a shell script.</p>&#13;
<p class="indent">The most common shell program on Linux systems is Bash; however, zsh and fish also have active user communities. The default shell is defined in the last field of the user’s <em>/etc/passwd</em> entry. This section focuses on Bash, <span epub:type="pagebreak" id="page_279"/>but the forensic examination principles should apply to any shell (refer to the specific shell’s man pages for help).</p>&#13;
<p class="indent">A shell can be <em>interactive</em> (for users) or <em>non-interactive</em> (for scripts). When invoked as a <em>login</em> shell (usually the first shell upon login), several additional startup scripts are run. <a href="ch10.xhtml#ch010fig01">Figure 10-1</a> earlier in the chapter shows the typical process for getting a login shell.</p>&#13;
<p class="indent">The local Linux console is a text mode interface via the PC monitor and keyboard. Over this physical interface, multiple “virtual consoles” are available, which can be switched using a hotkey (ALT-FN or CTRL-ALT-FN) or the <span class="literal">chvt</span> program.</p>&#13;
<p class="indent">Systemd-logind starts the agetty<sup><a id="ch10foot05" href="footnotes.xhtml#ch10foot_05">5</a></sup> program when a virtual console becomes active. The agetty daemon sets up the terminal and displays a login prompt. After a username is entered, it’s passed to the login program that asks for a password. If the username and password are correct and the user is authorized, a shell is started under the user’s UID and group ID (GID).</p>&#13;
<p class="indent">Logging in to a shell over a network has been possible with telnet and rlogin since network protocols were introduced. Today, remote logins are typically done with more secure alternatives like SSH.</p>&#13;
<p class="indent">By default, the SSH daemon (sshd) listens on TCP port 22. When incoming network connections are received, a cryptographic channel is established, the user is authenticated, and a shell is started. More details about analyzing SSH are provided later in the chapter, but <a href="ch10.xhtml#ch010fig01">Figure 10-1</a> given earlier provides an overview of a network login.</p>&#13;
<p class="indent">Linux systems use PAM libraries for multiple login activities. PAM modules check passwords, authenticate users, determine authorization, and perform other pre-login checks. One important function on modern Linux systems is the starting of a systemd user instance (if it hasn’t started already). On successful login, PAM registers the session with systemd-logind, which starts the systemd user instance. The systemd user instance has a <span class="literal">default</span> <span class="literal">.target</span> that starts various unit files (user daemons, such as D-Bus) for the user before they are finally given a shell command prompt.</p>&#13;
<p class="indent">Shell login activity can be observed in the journal. This example shows an SSH login, followed by a logout:</p>&#13;
<pre>Aug 16 20:38:45 pc1 sshd[75355]: Accepted password for sam from 10.0.11.1 port 53254 ssh2&#13;
Aug 16 20:38:45 pc1 sshd[75355]: pam_unix(sshd:session): session opened for user sam by (uid=0)&#13;
Aug 16 20:38:45 pc1 systemd-logind[374]: New session 56 of user sam.&#13;
Aug 16 20:38:45 pc1 systemd[1]: Started Session 56 of user sam.&#13;
...&#13;
Aug 16 20:39:02 pc1 sshd[75357]: Received disconnect from 10.0.11.1 port 53254:11: disconnected&#13;
 by user&#13;
Aug 16 20:39:02 pc1 sshd[75357]: Disconnected from user sam 10.0.11.1 port 53254&#13;
Aug 16 20:39:02 pc1 sshd[75355]: pam_unix(sshd:session): session closed for user sam&#13;
Aug 16 20:39:02 pc1 systemd[1]: session-56.scope: Succeeded.&#13;
Aug 16 20:39:02 pc1 systemd-logind[374]: Session 56 logged out. Waiting for processes to exit.</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_280"/>Notice how in the first three lines the SSH daemon takes the connection and engages <span class="literal">pam</span>, which then involves systemd. SSH logins may also be found in syslog files like <em>/var/log/auth.log</em>, or in other traditional Unix locations.</p>&#13;
<h5 class="h5"><strong>Shell Startup Files</strong></h5>&#13;
<p class="noindent">After a successful login, the shell starts and several scripts are run to set up the environment. Some system scripts are configured by the system administrator and run by every user, but users can also create and modify additional scripts in their home directories. Shell startup scripts (using Bash as an example) typically include the following:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/etc/profile</em></li>&#13;
<li class="noindent"><em>/etc/profile.d/*</em></li>&#13;
<li class="noindent"><em>~/.bash_profile</em></li>&#13;
<li class="noindent"><em>/etc/bash.bashrc</em></li>&#13;
<li class="noindent"><em>~/.bashrc</em></li>&#13;
</ul>&#13;
<p class="noindent">The profile scripts are run only in a login shell (normally the first shell when the user logs in). The other scripts (<em>*rc</em>) are run on every invocation of the shell.</p>&#13;
<p class="indent">On exit or logout, additional scripts are run, which typically include:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/etc/bash.bash_logout</em></li>&#13;
<li class="noindent"><em>~/.bash_logout</em></li>&#13;
</ul>&#13;
<p class="noindent">These files should be examined for changes deviating from the defaults. In particular, user customization in the home directory may be interesting. In the case of a system-wide compromise, malicious modifications also may be made to the <em>/etc/</em> files.</p>&#13;
<p class="indent">The environment variables, especially those that were explicitly set, can be interesting, and may reveal programs used or custom configuration. The <span class="literal">PATH</span> variable may point to an additional directory where the user’s own scripts and binaries are located. The <span class="literal">VISUAL</span> and <span class="literal">EDITOR</span> variables indicate the default editor used and, depending on the editor, may point to additional cache and history information about the files edited.</p>&#13;
<p class="indent">Systemd and PAM provide additional locations to set environment variables at login:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/etc/security/pam_env.conf</em></li>&#13;
<li class="noindent"><em>/etc/environment</em></li>&#13;
<li class="noindent"><em>/etc/environment.d/*.conf</em></li>&#13;
<li class="noindent"><em>/usr/lib/environment.d/*.conf</em></li>&#13;
<li class="noindent"><em>~/.config/environment.d/*.conf</em></li>&#13;
</ul>&#13;
<p class="noindent">You can find more information in the environment.d(5) and pam_env.conf(5) man pages. Variables stored in <em>/run/</em> or modified in the memory of a running system will not be available in a postmortem forensic analysis.</p>&#13;
<h5 class="h5"><strong>Shell History</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_281"/>Most shells can save a history of commands typed so the user can search and recall commands, instead of retyping them. This command history is especially interesting from an investigative point of view because they were explicitly typed by a human user. In the case of a compromised login, however, the command history could also be from a malicious script.</p>&#13;
<p class="indent">Shell history is configured using environment variables (starting with <span class="literal">HIST*</span>) that specify the file used, the number of commands to save, timestamp format, and other history features offered by the particular shell. The default Bash history file is <em>~/.bash_history</em>. This file contains a simple list of commands typed. Organizations wanting more forensic readiness may set the <span class="literal">HISTTIMEFORMAT</span> variable in Bash to include timestamps in the history. A shell history file may exist for every user, including root.</p>&#13;
<p class="indent">An examination of the shell history gives insight into the activity and character of the human user. Items, activity, and behavior you can observe or look for in the shell history include:</p>&#13;
<ul>&#13;
<li class="noindent">Skill level (simple commands or mistakes indicating a beginner)</li>&#13;
<li class="noindent">Revealed filenames from files created, edited, or deleted</li>&#13;
<li class="noindent">Commands modifying system configuration</li>&#13;
<li class="noindent">Manually setting up tunnels, relays, or VPNs</li>&#13;
<li class="noindent">Mounting local or remote filesystems or encrypted containers</li>&#13;
<li class="noindent">Testing local daemons or functionality on remote hosts</li>&#13;
<li class="noindent">Passwords typed (accidentally or as parameters on a command line)</li>&#13;
<li class="noindent">Revealing other IP addresses or hostnames from running <span class="literal">ping</span>, <span class="literal">nslookup</span>, <span class="literal">ssh</span>, or other network tools</li>&#13;
<li class="noindent">Information from text accidentally copy/pasted into a terminal window</li>&#13;
<li class="noindent">Any sequence of commands revealing intent or train of thought</li>&#13;
</ul>&#13;
<p class="noindent">Typed commands are stored in memory and written to the history file when the shell exits. A history file may contain lines from multiple shell instances that exited at different times, so the commands saved may not be in chronological order.</p>&#13;
<p class="indent">If the history file has been explicitly disabled, deleted, zeroed, or symlinked to <em>/dev/null</em>, it indicates an awareness of security or higher skill level of a suspected user or an attacker. For an excellent SANS talk on Bash history forensics, see <em><a href="https://youtu.be/wv1xqOV2RyE/">https://youtu.be/wv1xqOV2RyE/</a></em>.</p>&#13;
<h4 class="h4" id="ch00lev2_132"><strong><em>X11 and Wayland</em></strong></h4>&#13;
<p class="noindent">The X11 window system was the de facto standard graphical interface for Unix and the natural choice for the Linux community. The most popular implementation of X11 on Linux today is <a href="http://X.Org">X.Org</a>, and many new extensions and enhancements have been added since forking from the XFree86 project.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/><a href="http://X.Org">X.Org</a> connects applications to input devices (keyboard, mouse, touchscreen, and so on) and to output devices like graphics cards and monitors. In addition to <a href="http://X.Org">X.Org</a>, a separate window manager is needed to manage the windows (placement, decorations, resizing, movement, and so on). On top of the window manager, a desktop environment typically provides an additional “look and feel” or even a completely separate graphical shell. Each of these components and subcomponents may store information useful in a digital forensic context.</p>&#13;
<p class="indent">Most of the <a href="http://X.Org">X.Org</a> configuration is done automatically; however, manual tweaks and customization are typically found in <em>/etc/X11/xorg.conf</em> or files in the <em>/etc/X11/xorg.conf.d/</em> directory. A log of <a href="http://X.Org">X.Org</a> activity is created by default and written to <em>/var/log/Xorg.0.log</em> (in some cases, it may be located in the user’s <em>.local/share/xorg/Xorg.0.log</em>). The contents of the file describe the graphics hardware, monitors, input devices, default screen resolution, and more. Some examples are shown here, taken from such a log:</p>&#13;
<pre>...&#13;
[  31.701] (II) NVIDIA(0): NVIDIA GPU GeForce GTX 1050 Ti (GP107-A) at PCI:1:0:0 (GPU-0)&#13;
[  31.701] (--) NVIDIA(0): Memory: 4194304 kBytes&#13;
[  31.701] (--) NVIDIA(0): VideoBIOS: 86.07.59.00.24&#13;
...&#13;
[  31.702] (--) NVIDIA(GPU-0): LG Electronics LG ULTRAWIDE (DFP-2): connected&#13;
...&#13;
[  31.707] (II) NVIDIA(0): Virtual screen size determined to be 3840 x 1600&#13;
...&#13;
[  31.968] (II) config/udev: Adding input device Logitech M280/320/275 (/dev/input/event5)&#13;
...&#13;
[  31.978] (II) XINPUT: Adding extended input device "LEOPOLD Mini Keyboard" (type: KEYBOARD,&#13;
 id 12)&#13;
...</pre>&#13;
<p class="noindent">Other instances of the log may exist, such as a <em>/var/log/Xorg.1.log</em> file. Unlike rotated logfiles, this is not an older version, but represents the display that was logged (0, 1, and so on). Older versions of the log may also exist and have an <em>.old</em> filename extension.</p>&#13;
<p class="indent">The <em>Xorg</em> logfiles contain “markers” used to describe the log entries:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">(–)</span>     Probed</p>&#13;
<p class="noindentin"><span class="codestrong">(**)</span>     From config file</p>&#13;
<p class="noindentin"><span class="codestrong">(==)</span>     Default setting</p>&#13;
<p class="noindentin"><span class="codestrong">(++)</span>     From command line</p>&#13;
<p class="noindentin"><span class="codestrong">(!!)</span>     Notice</p>&#13;
<p class="noindentin"><span class="codestrong">(II)</span>     Informational</p>&#13;
<p class="noindentin"><span class="codestrong">(WW)</span>     Warning</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_283"/><span class="codestrong">(EE)</span>     Error</p>&#13;
<p class="noindentin"><span class="codestrong">(NI)</span>     Not implemented</p>&#13;
<p class="noindentin"><span class="codestrong">(??)</span>     Unknown</p>&#13;
</div>&#13;
<p class="noindent">If a user was working with X11 and later switched to Wayland, this log may still exist and would provide information from an earlier point in time. You can find more information about <a href="http://X.Org">X.Org</a> in the Xorg(1) man page.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010fig02">Figure 10-2</a> shows X11’s basic architecture. The evolution of desktop computing obsoleted many of X11’s original design decisions, and a more modern windowing system was needed. Wayland was designed to be the replacement, and most Linux distributions are moving toward Wayland-based desktops.</p>&#13;
<div class="image"><img id="ch010fig02" src="Images/ch10fig02.jpg" alt="Image" width="694" height="296"/></div>&#13;
<p class="figcap"><em>Figure 10-2: X11 Architecture</em></p>&#13;
<p class="indent">Window managers are used in X11 environments to manage windows. Functionally, the window manager is just another X11 client. Most distros and graphical environments have a default window manager. Some popular X11 window mangers include:</p>&#13;
<ul>&#13;
<li class="noindent">Mutter (GNOME default)</li>&#13;
<li class="noindent">KWin (KDE default)</li>&#13;
<li class="noindent">Xfwm4 (Xfce default)</li>&#13;
<li class="noindent">Openbox (LXDE default)</li>&#13;
<li class="noindent">Fluxbox, FVWM, and tiling window managers like i3</li>&#13;
</ul>&#13;
<p class="noindent">Each window manager will have its own configuration and logging artifacts. See the associated documentation for more information.</p>&#13;
<p class="indent">Wayland uses a different model than X11 and combines window management together with compositing and other functionality. <a href="ch10.xhtml#ch010fig03">Figure 10-3</a> shows Wayland’s architecture. The differences between X11 and Wayland can be seen by comparing the two architectures. As a side note, Wayland is not exclusive to Linux and is used in other operating systems like BSD.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_284"/><img id="ch010fig03" src="Images/ch10fig03.jpg" alt="Image" width="278" height="342"/></div>&#13;
<p class="figcap"><em>Figure 10-3: Wayland Architecture</em></p>&#13;
<p class="indent">More information about the architectural differences between X11 and Wayland is available at <em><a href="https://wayland.freedesktop.org/architecture.html">https://wayland.freedesktop.org/architecture.html</a></em>.</p>&#13;
<p class="indent">Wayland compositors are becoming more popular. Mutter and KWin both support Wayland (in addition to X11), and power users are using specialty compositors like Sway (an i3 clone for Wayland) or Hikari (originally developed for FreeBSD). Each compositor has configuration and logging capability that can be examined, but the forensic analysis of individual compositors is outside the scope of this book.</p>&#13;
<h4 class="h4" id="ch00lev2_133"><strong><em>Desktop Login</em></strong></h4>&#13;
<p class="noindent">Typical Linux desktop and laptop systems have a graphical login screen. This screen is sometimes called the <em>greeter</em> and is provided by a daemon called the <em>display manager</em>. The display manager sets up the graphics on the local machine and provides pre-login options (for example, language, screen brightness, accessibility, and so on).</p>&#13;
<p class="indent">The display manager is independent of the graphical environment used, and it may allow users to choose which graphical environment they want to use after login. The most popular display managers today are GDM (the GNOME default) and SDDM (the KDE Plasma default).</p>&#13;
<p class="indent">You can determine which desktop manager is used by examining the systemd <em>display-manager.service</em> unit file, which is a symbolic link to the actual display manager. In the following example, the default target is symlinked to the graphical target and specifies (<span class="literal">Wants=</span>) the display manager service:</p>&#13;
<pre>default.target -&gt; /lib/systemd/system/graphical.target&#13;
Wants=display-manager.service</pre>&#13;
<p class="noindent">The display manager service is symlinked to the GDM service, which starts (<span class="literal">ExecStart=</span>) the GDM daemon:</p>&#13;
<pre><span epub:type="pagebreak" id="page_285"/>display-manager.service -&gt; /usr/lib/systemd/system/gdm.service&#13;
ExecStart=/usr/bin/gdm</pre>&#13;
<p class="indent">Depending on the configuration, the GDM display manager may save logs in <em>/var/log/gdm/</em> or leave traces in the systemd journal.</p>&#13;
<p class="indent">The SDDM display manager may save logs in <em>/var/log/sddm.log</em> and also log activity in the systemd journal (search for <span class="literal">sddm</span>). After a successful login, the SDDM display manager stores session logs in the user’s home directory that can be examined:</p>&#13;
<pre>$ <span class="codestrong1">ls -l /home/sam/.local/share/sddm</span>&#13;
total 24&#13;
-rw------- 1 sam sam 20026 Jun 14 12:35 wayland-session.log&#13;
-rw------- 1 sam sam 2514 Jun 14 15:38 xorg-session.log</pre>&#13;
<p class="noindent">Other logs for either Wayland or X11 sessions may be present that are related to the desktop environment.</p>&#13;
<p class="indent">Upon successful login via the display manager, multiple processes are started. For example:</p>&#13;
<ul>&#13;
<li class="noindent">User instance of systemd (<span class="literal">systemd --user</span>)</li>&#13;
<li class="noindent">Desktop session manager (<span class="literal">gnome-session</span>, <span class="literal">plasma_session</span>, <span class="literal">xfce4-session</span>, and so on)</li>&#13;
<li class="noindent">Window manager (if running X11)</li>&#13;
<li class="noindent">Systemd user units</li>&#13;
<li class="noindent">XDG session autostart items (<em>*.desktop</em> files)</li>&#13;
<li class="noindent">D-Bus session instance</li>&#13;
<li class="noindent">Agents (polkit, gpg, ssh, and so on)</li>&#13;
<li class="noindent">The desktop or graphical shell</li>&#13;
<li class="noindent">Supporting daemons for the desktop environment (settings, Pulseaudio or PipeWire, Bluetooth, and so on)</li>&#13;
</ul>&#13;
<p class="noindent">Each component will be running under the user’s UID. Configuration, logs, cache, and other related data is typically found in the user’s XDG directories. (Refer back to <a href="ch10.xhtml#ch010fig01">Figure 10-1</a> for an overview of the graphical login process.)</p>&#13;
<p class="indent">The systemd <em>user</em> instance (not to be confused with the systemd <em>system</em> instance) is responsible for activating the units needed to bring up and supervise the login session. The systemd user instance is started when PAM registers the session with systemd-logind. The user unit files are found here:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/usr/lib/systemd/user/*</em></li>&#13;
<li class="noindent"><em>/etc/systemd/user/*</em></li>&#13;
<li class="noindent"><em>~/.config/systemd/user/*</em></li>&#13;
</ul>&#13;
<p class="noindent">Each directory overrides the previous. The first two directories are the vendor and system administrator defaults. The last directory contains the <span epub:type="pagebreak" id="page_286"/>custom configuration in the user’s home directory. In a forensic examination, these directories can be checked for deviations from the expected defaults, or any custom additions added by the system administrator, user, or malicious actor. The system-wide configuration of the systemd user instance is found in the <em>/etc/systemd/user.conf</em> and <em>/etc/systemd/logind.conf</em> files.</p>&#13;
<p class="indent">In addition to the systemd user instance, the desktop session manager will bring up the user’s login environment with its own startup files. The XDG desktop definition files (<em>*.desktop</em>) provide the information needed to bring up a user’s desktop environment. The XDG standards also define common locations for storing desktop configuration files. These files are found in the autostart directories, and files specific to the desktop environment are read and applications are launched accordingly. The system default and user-defined directory locations (user-created files have priority) are located here:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/etc/xdg/autostart/*</em></li>&#13;
<li class="noindent"><em>~/.config/autostart/*</em></li>&#13;
</ul>&#13;
<p class="noindent">Window managers and desktop shells may also have their own <em>autostart</em> directories containing desktop files that start relevant components. The XDG Desktop Entry Specification can be found at <em><a href="https://specifications.freedesktop.org/desktop-entry-spec/">https://specifications.freedesktop.org/desktop-entry-spec/</a></em>.</p>&#13;
<p class="indent">Definition files have a <em>*.desktop</em> extension and describe how the desktop component should be brought up. The following example shows several entries illustrating the contents of a definition file:</p>&#13;
<pre>$ <span class="codestrong1">cat gnome-keyring-secrets.desktop</span>&#13;
[Desktop Entry]&#13;
Type=Application&#13;
...&#13;
Name[en_GB]=Secret Storage Service&#13;
...&#13;
Comment[de]=GNOME-SchlÃsselbunddienst: Sicherheitsdienst&#13;
...&#13;
Exec=/usr/bin/gnome-keyring-daemon --start --components=secrets&#13;
OnlyShowIn=GNOME;Unity;MATE;Cinnamon;&#13;
...</pre>&#13;
<p class="noindent">Here, an application (GNOME Keyring, discussed later in this chapter) is described. Files have multilingual content for names and comments, and the context in which the definition file is valid is specified. The program and flags to execute are also defined.</p>&#13;
<p class="indent">Systemd and XDG both provide similar functionality in setting up desktop environments. Because of the widespread use of XDG and a commitment to compatibility by the major distros, both of them can be examined. Many desktop environments are transitioning XDG desktop startup activity to systemd, which is a complex process requiring backward compatibility with the XDG <em>*.desktop</em> files. If a <em>*.desktop</em> file contains the line <span class="literal">X-GNOME-Hidden <span epub:type="pagebreak" id="page_287"/>UnderSystemd=true</span>, it means that the GNOME session manager should ignore the file, as it is being started by systemd.<sup><a id="ch10foot06" href="footnotes.xhtml#ch10foot_06">6</a></sup></p>&#13;
<p class="indent">Some session managers can save and restore session state about the desktop. These files can be examined to determine which windows may have been open in a previously saved state. The location of the saved session information is different for each desktop environment, and common locations include:</p>&#13;
<ul>&#13;
<li class="noindent"><em>~/.cache/sessions/</em></li>&#13;
<li class="noindent"><em>~/.config/session/</em></li>&#13;
<li class="noindent"><em>~/.config/gnome-session/saved-session/</em></li>&#13;
<li class="noindent"><em>~/.config/ksmserverrc</em></li>&#13;
</ul>&#13;
<p class="noindent">Sessions may be saved automatically on exit or explicitly requested by the user. Depending on the desktop environment and its configuration, the session manager may save a simple list of open programs and also include the window sizes and locations on-screen.</p>&#13;
<h5 class="h5"><strong>Fast User Switching</strong></h5>&#13;
<p class="noindent">Multiple users can be logged in to separate graphical environments at the same time by starting their sessions in different virtual consoles. Switching between users can be done with a hotkey (CTRL-ALT-FN), the <span class="literal">chvt</span> command, or a <em>switch user</em> option in the current graphical environment. User switching may indicate multiple people using the same machine or one person using multiple identities on the same machine.</p>&#13;
<p class="indent">Also known as <em>fast user switching</em>, a menu option is typically provided in the graphical environment (if there are multiple users) that locks the screen and jumps to the display manager where another user can be authenticated. Depending on the display manager, this transition might be found in the journal. The following example log shows a new GDM session (a login screen) started due to a user switch, and terminated less than a minute later after the second user successfully authenticated:</p>&#13;
<pre>Jul 03 15:05:42 pc1 systemd-logind[401]: New session 26 of user gdm.&#13;
Jul 03 15:05:42 pc1 systemd[1]: Started Session 26 of user gdm.&#13;
...&#13;
Jul 03 15:06:20 pc1 systemd-logind[401]: Session 26 logged out. Waiting for&#13;
 processes to exit.&#13;
Jul 03 15:06:20 pc1 systemd-logind[401]: Removed session 26.</pre>&#13;
<p class="noindent">Observing when a display manager is started without a user logging out indicates a possible user switch. This information provides a starting point to examine surrounding logs and filesystem timestamps that identify which users were active before and after the switch. A user switch can also be initiated from a locked screen by another person.</p>&#13;
<h3 class="h3" id="ch00lev1_48"><span epub:type="pagebreak" id="page_288"/><strong>Authentication and Authorization</strong></h3>&#13;
<p class="noindent">When a user wants to access a Linux system, a number of checks are made before granting that access. The system looks for an indicator that the person really is who they claim to be and that they are indeed authorized to access the resources they want. Today, this is typically done with PAM. PAM can provide authentication and authorization controls between the user and the system, both at login and throughout the user login session.</p>&#13;
<p class="indent">PAM configuration is in the <em>pam.conf</em> file and the <em>/etc/pam.d/</em> directory. PAM also logs the successes and failures of attempted authentication and authorization. Here are several examples:</p>&#13;
<pre><span class="ent">➊</span> Dec 26 19:31:00 pc1 sshd[76857]: pam_unix(sshd:session): session opened for&#13;
    user sam(uid=1000) by (uid=0)&#13;
   Dec 26 19:31:20 pc1 sshd[76857]: pam_unix(sshd:session): session closed for&#13;
    user sam&#13;
   ...&#13;
<span class="ent">➋</span> Dec 26 19:26:50 pc1 login[76823]: pam_unix(login:session): session opened for&#13;
    user sam(uid=1000) by LOGIN(uid=0)&#13;
   Dec 26 19:28:04 pc1 login[76823]: pam_unix(login:session): session closed for&#13;
    user sam&#13;
   ...&#13;
<span class="ent">➌</span> Dec 26 19:45:40 pc1 gdm-password][6257]: pam_unix(gdm-password:session):&#13;
    session opened for user sam(uid=1000) by (uid=0)&#13;
   Dec 26 19:46:46 pc1 gdm-password][6257]: pam_unix(gdm-password:session):&#13;
    session closed for user sam</pre>&#13;
<p class="noindent">The first two lines <span class="ent">➊</span> show logs from an SSH login and logout over a network. The next two lines <span class="ent">➋</span> show logs from a login and logout on a local virtual console (text login prompt). The last two lines <span class="ent">➌</span> show a login and logout using GDM (a typical graphical login screen).</p>&#13;
<h4 class="h4" id="ch00lev2_134"><strong><em>User, Group, and Password Files</em></strong></h4>&#13;
<p class="noindent">Linux adopted the concepts and implementation of usernames and groups from Unix. Traditionally, these usernames and groups were listed in several files in the <em>/etc/</em> directory.<sup><a id="ch10foot07" href="footnotes.xhtml#ch10foot_07">7</a></sup> The password file <em>/etc/passwd</em> (which doesn’t contain passwords anymore) lists the defined users on the system with some additional information. The shadow file <em>/etc/shadow</em> contains hashed passwords for each (enabled) user. The group file <em>/etc/group</em> lists the groups and their members. Each user has a default group assigned (typically named after themselves) and can be added to other groups for access to files and resources.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_289"/>The format of the <em>passwd</em>, <em>shadow,</em> and <em>group</em> files are described in the passwd(5),<sup><a id="ch10foot08" href="footnotes.xhtml#ch10foot_08">8</a></sup> shadow(5), and group(5) man pages. These files are plaintext, have one line per user/group, and have multiple fields per line. The following shows some excerpts from a <em>passwd</em> file:</p>&#13;
<pre>root:x:0:0:root:/root:/bin/bash&#13;
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin&#13;
...&#13;
sam:x:1000:1000:Samantha Samuel:/home/sam:/bin/bash</pre>&#13;
<p class="noindent">The fields (separated by colons) of the <em>passwd</em> file are as follows:</p>&#13;
<ul>&#13;
<li class="noindent">Login name</li>&#13;
<li class="noindent">Password field (<span class="literal">x</span> indicates a password is stored in <em>/etc/shadow</em>; <span class="literal">!</span> indicates password access is locked; a blank field means no password is required and applications may choose to allow access)</li>&#13;
<li class="noindent">Numerical user ID</li>&#13;
<li class="noindent">Numerical group ID</li>&#13;
<li class="noindent">Comment field (often the user’s full name)</li>&#13;
<li class="noindent">User’s home directory</li>&#13;
<li class="noindent">User’s shell program (the <span class="literal">nologin</span> program simply rejects login attempts)</li>&#13;
</ul>&#13;
<p class="noindent">The <em>/etc/passwd</em> file has historically been a prime target of theft on early Unix systems. Anyone stealing this file had a list of users and encrypted/ hashed passwords that could be potentially cracked. This weakness led to the development of the shadow password file.</p>&#13;
<p class="indent">The <em>/etc/shadow</em> file is not readable by regular users because it contains the (encrypted) password and other potentially sensitive information. Some examples from a shadow file are as follows:</p>&#13;
<pre>daemon:*:17212:0:99999:7:::&#13;
...&#13;
sam:$6$6QKDnXEBlVofOhFC$iGGPk2h1160ERjIkI7GrHKPpcLFn1mL2hPDrhX4cXyYa8SbdrbxVt.h&#13;
nwZ4MK1fp2yGPIdvD8M8CxUdnItDSk1:18491:0:99999:7:::</pre>&#13;
<p class="noindent">The fields (separated by colons) of the <em>shadow</em> file are as follows:</p>&#13;
<ul>&#13;
<li class="noindent">Login name</li>&#13;
<li class="noindent">Encrypted password (if not a valid password string, password access is blocked)</li>&#13;
<li class="noindent">Date of last password change (days since January 1, 1970)</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_290"/>Days until a user is allowed to change their password (if empty, the user can change password any time)</li>&#13;
<li class="noindent">Days until a user is required to change their password (if empty, the user never has to change password)</li>&#13;
<li class="noindent">Password warning period (number of days before password expires)</li>&#13;
<li class="noindent">Password grace period (number of days user can change password after expiration)</li>&#13;
<li class="noindent">Account expiration date (days since January 1, 1970)</li>&#13;
<li class="noindent">Unused field reserved for future use</li>&#13;
</ul>&#13;
<p class="noindent">The date of last password change may be interesting when constructing a forensic timeline of user activity.</p>&#13;
<p class="indent">The encrypted password field has three dollar sign ($)–separated fields. These fields are the encryption algorithm used, the encryption salt (to make cracking more difficult), and the encrypted password string. The encryption algorithms are:</p>&#13;
<div class="bqparan">&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:75%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>1</strong></td>&#13;
<td style="vertical-align: top">MD5</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>2a</strong></td>&#13;
<td style="vertical-align: top">Blowfish</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>5</strong></td>&#13;
<td style="vertical-align: top">SHA-256</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><strong>6</strong></td>&#13;
<td style="vertical-align: top">SHA-512</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p class="noindent">See the crypt(3) man page for more information.</p>&#13;
<p class="indent">The <em>/etc/group</em> file stores information about Unix groups, including a list of group members. Some excerpts from a typical <em>group</em> file are as follows:</p>&#13;
<pre>root:x:0:&#13;
daemon:x:1:&#13;
...&#13;
sudo:x:27:sam,fred,anne</pre>&#13;
<p class="noindent">The fields (separated by colons) of the group file are as follows:</p>&#13;
<ul>&#13;
<li class="noindent">Group name</li>&#13;
<li class="noindent">Password (if used, the password information is stored in a gshadow file)</li>&#13;
<li class="noindent">Numerical group ID</li>&#13;
<li class="noindent">Comma-separated list of members</li>&#13;
</ul>&#13;
<p class="noindent">A default group for each user is defined in the <em>/etc/passwd</em> file. The <em>/etc/ group</em> file can provide additional group configuration. For example, notice how the <em>sudo</em> group lists users allowed to use the <span class="literal">sudo</span> program.</p>&#13;
<p class="indent">Users and groups are simply human-readable names mapped to numbers: the user ID (UID) and group ID (GID). The <em>passwd</em> and <em>group</em> files define the name-to-number assignment.<sup><a id="ch10foot09" href="footnotes.xhtml#ch10foot_09">9</a></sup> There is no requirement to have an <span epub:type="pagebreak" id="page_291"/>assigned user or group name for a particular UID or GID number. To illustrate, observe the following sequence of commands:</p>&#13;
<pre># <span class="codestrong1">touch example.txt</span>&#13;
# <span class="codestrong1">chown 5555:6666 example.txt</span>&#13;
# <span class="codestrong1">ls -l example.txt</span>&#13;
-rw-r----- 1 5555 6666 0 5. Mar 19:33 example.txt&#13;
#</pre>&#13;
<p class="noindent">In this example, a file is created using the <span class="literal">touch</span> command. The user and group is then changed using <span class="literal">chown</span> to numeric values that are not defined in the password or group files. You can see in the directory listing that the unknown user is <span class="literal">5555</span> and the unknown group is <span class="literal">6666</span>. From a forensics perspective, files with unassigned users and groups are interesting because they may indicate a previously deleted user/group or an attempt to hide malicious activity.</p>&#13;
<p class="indent">How can we find files without assigned UIDs or GIDs? On a live system, the <span class="literal">find</span> command has the options <span class="literal">-nouser</span> and <span class="literal">-nogroup</span>, which can be used to scan a system for files that don’t have an existing user or group assigned. On a postmortem drive image, forensic software may have the ability to identify such files (using EnCase EnScript, for example). Identified files and directories can be analyzed in more detail to answer certain questions:</p>&#13;
<ul>&#13;
<li class="noindent">How and why were the files created?</li>&#13;
<li class="noindent">What happened to the original user and group?</li>&#13;
<li class="noindent">Are the file timestamps interesting or relevant?</li>&#13;
<li class="noindent">Does this UID or GID appear in any logs?</li>&#13;
<li class="noindent">On a live system, are there any running processes with the same UID and GID?</li>&#13;
</ul>&#13;
<p class="noindent">There are several ways users and groups can be created and deleted. A system administrator can manually edit the <em>passwd</em>, <em>shadow</em>, and <em>group</em> files to add or remove assigned UIDs or GIDs. Command line tools like <span class="literal">useradd</span> or <span class="literal">groupadd</span> can be used. Distros may also provide graphical configuration tools that can add users and groups.</p>&#13;
<p class="indent">When a user or group is created or modified, some tools make backup copies of the password, group, shadow files, and others. The backup copies have the same name with a hyphen (-) appended, as follows:</p>&#13;
<ul>&#13;
<li class="noindent"><em>/etc/passwd-</em></li>&#13;
<li class="noindent"><em>/etc/shadow-</em></li>&#13;
<li class="noindent"><em>/etc/gshadow-</em></li>&#13;
<li class="noindent"><em>/etc/group-</em></li>&#13;
<li class="noindent"><em>/etc/subuid-</em></li>&#13;
</ul>&#13;
<p class="noindent">These backup copies are normally identical to the original files. If a file is different, it was possibly modified manually or using alternative tools not <span epub:type="pagebreak" id="page_292"/>supporting this backup convention. Examining the differences may reveal users that have been deleted, added, or modified previously.</p>&#13;
<p class="indent">The <em>passwd</em> file contains both human users and system users. When analyzing human user activity, it is important to know the difference. The numeric ID fields in the <em>passwd</em> and <em>group</em> can help make this distinction in a forensic investigation. The following list describes a few standard users, groups, and allocated numeric ranges:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>0</strong> root (LSB required)</p>&#13;
<p class="noindentin"><strong>1</strong> daemon (LSB required)</p>&#13;
<p class="noindentin"><strong>2</strong> bin (LSB required)</p>&#13;
<p class="noindentin"><strong>0–100</strong> Allocated by the system</p>&#13;
<p class="noindentin"><strong>101–999</strong> Allocated by applications</p>&#13;
<p class="noindentin"><strong>1000–6000</strong> Regular (human) user accounts</p>&#13;
<p class="noindentin"><strong>65534</strong> nobody</p>&#13;
</div>&#13;
<p class="noindent">Deviations from these standard UID and GID ranges are interesting from the perspective of a forensic investigator because they indicate possible manual modification or non-standard creation of users and groups.</p>&#13;
<p class="indent">Most Linux distros create new users starting with UID 1000 and also create default groups with the same GID number. However, the UID and GID of a user doesn’t have to be the same number. If a user’s UID is different from the GID, it suggests that an additional group was manually created.</p>&#13;
<p class="indent">The creation of a new user or group might be found in the shell history of the root user (<span class="literal">useradd fred</span>, for example) or in the shell history of a regular user (<span class="literal">sudo useradd fred</span>). If the user was created in a GUI tool, it may appear in the journal as follows:</p>&#13;
<pre>Aug 17 20:21:57 pc1 accounts-daemon[966]: request by system-bus-name::1.294&#13;
 [gnome-control-center pid:7908 uid:1000]: create user 'fred'&#13;
Aug 17 20:21:57 pc1 groupadd[10437]: group added to /etc/group: name=fred,&#13;
 GID=1002&#13;
Aug 17 20:21:57 pc1 groupadd[10437]: group added to /etc/gshadow: name=fred&#13;
Aug 17 20:21:57 pc1 groupadd[10437]: new group: name=fred, GID=1002&#13;
Aug 17 20:21:57 pc1 useradd[10441]: new user: name=fred, UID=1002, GID=1002,&#13;
 home=/home/fred, shell=/bin/bash</pre>&#13;
<p class="noindent">In this example, GNOME’s <span class="literal">gnome-control-center</span> (the Settings program) asked the <span class="literal">accounts-daemon</span> (part of AccountsService; <em><a href="https://www.freedesktop.org/wiki/Software/AccountsService/">https://www.freedesktop.org/wiki/Software/AccountsService/</a></em>) to create a user (<span class="literal">fred</span>). This D-Bus service accesses and configures local user accounts using system tools like <span class="literal">useradd</span> or <span class="literal">groupadd</span>. AccountService was originally developed for GNOME but can be used by any distro.</p>&#13;
<p class="indent">The deletion of a user simply means that the defined user and ID record in the shadow, password, and group files has been deleted. The following is an example found in the journal (deleting <span class="literal">fred</span> from the previous example):</p>&#13;
<pre><span epub:type="pagebreak" id="page_293"/>Aug 17 20:27:22 pc1 accounts-daemon[966]: request by system-bus-name::1.294&#13;
 [gnome-control-center pid:7908 uid:1000]: delete user 'fred' (1002)&#13;
Aug 17 20:27:22 pc1 userdel[10752]: delete user 'fred'</pre>&#13;
<p class="noindent">Deleting a user or group does not automatically delete the files owned by those users. Unless explicitly deleted, the files will still exist and appear with the former numeric IDs of the deleted users.</p>&#13;
<p class="indent">Some forensic programs or password recovery tools are able to attempt recovery of encrypted passwords stored in shadow files. Here is an example of John the Ripper recovering a password from the <em>/etc/shadow</em> entry extracted for the user <em>sam</em>:</p>&#13;
<pre># <span class="codestrong1">cat sam.txt</span>&#13;
sam:$6$CxWwj5nHL9G9tsJZ$KCIUnMpd6v8W1fEu5sfXMo9/K5ZgjbX3ZSPFhthkf5DfWbyzGL3DxH&#13;
NkYBGs4eFJPvqw1NAEQcveD5rCZ18j7/:18746:0:99999:7:::&#13;
# <span class="codestrong1">john sam.txt</span>&#13;
Created directory: /root/.john&#13;
Warning: detected hash type "sha512crypt", but the string is also recognized&#13;
as "sha512crypt-opencl"&#13;
...&#13;
Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 128/128 AVX 2x])&#13;
Cost 1 (iteration count) is 5000 for all loaded hashes&#13;
Will run 8 OpenMP threads&#13;
...&#13;
Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist&#13;
canada           (sam)&#13;
...</pre>&#13;
<p class="noindent">Here, the <span class="literal">john</span> cracking tool discovers the password is <em>canada</em> from a wordlist or dictionary-based attack. John the Ripper leaves traces of password cracking activity, including previously recovered passwords, in the <em>~/.john/</em> directory of the user who ran it.</p>&#13;
<h4 class="h4" id="ch00lev2_135"><strong><em>Elevated Privileges</em></strong></h4>&#13;
<p class="noindent">A typical user account on a Linux system is expected to have enough privileges to do “normal work,” but not enough to cause damage to the system, disrupt other users, or access files that are meant to be private. Only one user, root (UID 0), has privileges to do everything. Several mechanisms allow regular users to elevate privileges to perform certain authorized tasks.</p>&#13;
<p class="indent">The traditional Unix <span class="literal">su</span> (substitute user) command allows a command to be executed with the privileges of another user or group (root is the default if nothing is specified). Failed and successful use of the <span class="literal">su</span> command appears in the system log as shown here:</p>&#13;
<pre>Aug 20 09:00:13 pc1 su[29188]: pam_unix(su:auth): authentication failure;&#13;
 logname= uid=1000 euid=0 tty=pts/4 ruser=sam rhost= user=root&#13;
<span epub:type="pagebreak" id="page_294"/>Aug 20 09:00:15 pc1 su[29188]: FAILED SU (to root) sam on pts/4&#13;
...&#13;
Aug 20 09:01:20 pc1 su[29214]: (to root) sam on pts/4&#13;
Aug 20 09:01:20 pc1 su[29214]: pam_unix(su:session): session opened for user&#13;
 root by (uid=1000)</pre>&#13;
<p class="noindent">By default, all users are permitted to use the <span class="literal">su</span> command. See the su(1) man page for more information.</p>&#13;
<p class="indent">The <span class="literal">sudo</span> command provides more granularity than <span class="literal">su</span> and can be configured to allow some users to execute specific commands only. The <span class="literal">sudo</span> configuration is found in the <em>/etc/sudoers</em> file or in files in the <em>/etc/sudoers.d/</em> directory. A <em>sudo</em> group may also contain a list of authorized users.</p>&#13;
<p class="indent">Failed and successful uses of the <span class="literal">sudo</span> command by authorized users is logged as shown here:</p>&#13;
<pre>Aug 20 09:21:22 pc1 sudo[18120]: pam_unix(sudo:auth): authentication failure;&#13;
logname=sam uid=1000 euid=0 tty=/dev/pts/0 ruser=sam rhost= user=sam&#13;
...&#13;
Aug 20 09:21:29 pc1 sudo[18120]:   sam : TTY=pts/0 ; PWD=/home/sam ; USER=&#13;
root ; COMMAND=/bin/mount /dev/sdb1 /mnt&#13;
Aug 20 09:21:29 pc1 sudo[18120]: pam_unix(sudo:session): session opened for&#13;
user root by sam(uid=0)</pre>&#13;
<p class="noindent">Attempts to use <span class="literal">sudo</span> by unauthorized users (those users who are not considered “administrators”) will also appear in the system log:</p>&#13;
<pre>Aug 20 09:24:19 pc1 sudo[18380]:   sam : user NOT in sudoers ; TTY=pts/0 ;&#13;
PWD=/home/sam ; USER=root ; COMMAND=/bin/ls</pre>&#13;
<p class="noindent">A search for <span class="literal">sudo</span> activity can reveal information about compromised systems or abuse by regular users, including the privileged commands attempted.</p>&#13;
<p class="indent">When a user runs <span class="literal">sudo</span> for the first time, they may be presented with a warning message or “lecture” about the risks and responsibilities:</p>&#13;
<pre>$ <span class="codestrong1">sudo ls</span>&#13;
&#13;
We trust you have received the usual lecture from the local System&#13;
Administrator. It usually boils down to these three things:&#13;
&#13;
    #1) Respect the privacy of others.&#13;
    #2) Think before you type.&#13;
    #3) With great power comes great responsibility.&#13;
&#13;
[sudo] password for sam:</pre>&#13;
<p class="noindent">If sudo is configured to display the message once only (the default), a zero-length file named after the user is created in the <em>/var/db/sudo/lectured/</em> directory. The creation timestamp on this file indicates the first time a user ran the <span class="literal">sudo</span> command. See the sudo(8) and sudoers(5) man pages for more information.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>Another method of privilege escalation uses a <span class="literal">setuid</span> flag on an executable file indicating the program should execute with the UID of the file’s owner. Use of this flag is not logged (although the <span class="literal">setuid</span> program itself may generate logs). The <span class="literal">ls -l</span> of a <span class="literal">setuid</span> program has an “s” in the permission information:</p>&#13;
<pre>$ <span class="codestrong1">ls -l /usr/bin/su</span>&#13;
-rwsr-xr-x 1 root root 67552 23. Jul 20:39 /usr/bin/su</pre>&#13;
<p class="indent">In a forensic investigation, a search can be made to find all <em>setuid</em> files. In particular, <em>setuid</em> files that are not part of any official distro software package can be interesting; for example:</p>&#13;
<pre>$ <span class="codestrong1">find /usr -perm -4000</span>&#13;
/usr/bin/sudo&#13;
...&#13;
/usr/bin/passwd&#13;
...&#13;
/tmp/Uyo6Keid&#13;
...</pre>&#13;
<p class="noindent">In this example, a suspicious <em>setuid</em> file was found in <em>/tmp/</em> and should be examined further.</p>&#13;
<p class="indent">All <em>setuid</em> files pose a risk to the system, and can be exploited if they contain vulnerabilities. If non-privileged users can exploit a <span class="literal">setuid</span> program, they may gain unauthorized access or execute arbitrary code as another user (like root for example). Files can also have the <span class="literal">setgid</span> flag set, causing programs to run as the file’s group.</p>&#13;
<p class="indent">An API provided by the polkit (also called PolicyKit) framework can also escalate privileges over D-Bus. The polkit daemon (<span class="literal">polkitd</span>) listens for requests and takes appropriate action. The authorization actions are configured using <em>.rules</em> and <em>.policy</em> files located in the <em>/etc/polkit-1/</em> or <em>/usr/share/ polkit-1/</em> directories. When making authorization decisions, <span class="literal">polkitd</span> checks these rules and policies and logs activity to the journal, as shown here:</p>&#13;
<pre>Aug 20 10:41:21 pc1 polkitd[373]: Operator of unix-process:102176:33910959 FAILED&#13;
to authenticate to gain authorization for action org.freedesktop.login1.reboot-&#13;
multiple-sessions for system-bus-name::1.2975 [&lt;unknown&gt;] (owned by unix-user:sam)</pre>&#13;
<p class="noindent">In this example, a user tries to reboot a system, polkit asks for authentication, and the user fails to provide it.</p>&#13;
<p class="indent">The <span class="literal">pkexec</span> command line tool is part of the polkit software package and functions similarly to <span class="literal">sudo</span>. For more information about polkit use over D-Bus, see the polkit(8) and polkitd(8) man pages.</p>&#13;
<p class="indent">The Linux kernel also provides <em>capabilities</em> that can extend and reduce privileges of a user at a more granular level. Systemd has options to define capabilities in unit files. See the capabilities(7) and systemd.unit(5) man pages for more information.</p>&#13;
<h4 class="h4" id="ch00lev2_136"><span epub:type="pagebreak" id="page_296"/><strong><em>GNOME Keyring</em></strong></h4>&#13;
<p class="noindent">The GNOME desktop environment has a credential storage mechanism called the GNOME Keyring. Users can create multiple keyrings, and each keyring can store multiple passwords. Frontend tools interact with a backend daemon that creates and manages the files containing the passwords.</p>&#13;
<p class="indent">The default location of the keyring files is <em>~/.local/share/keyrings/</em> (previously <em>~/.gnome2/keyrings/</em>). Filenames are the same as the keyring names, with spaces replaced with underscores. If multiple keyrings exist and a default is specified, a file called <em>default</em> will contain the name of the default keyring. <a href="ch10.xhtml#ch010fig04">Figure 10-4</a> shows an overview of GNOME Keyring.</p>&#13;
<div class="image"><img id="ch010fig04" src="Images/ch10fig04.jpg" alt="Image" width="693" height="528"/></div>&#13;
<p class="figcap"><em>Figure 10-4: GNOME Keyring data flow</em></p>&#13;
<p class="indent">In some installations, the <span class="literal">pam_gnome_keyring</span> PAM module may use a keyring for logins. In that case, the login password is the same as the password of the default <span class="literal">gnome-keyring</span>. If a keyring is not given a password on creation, the keyring file will be stored in unencrypted form, with passwords and other information visible in a readable plaintext file format.</p>&#13;
<p class="indent">The <em>*.keyring</em> files can be copied to another system for analysis. The decrypted keyring files contain interesting data from a forensics perspective, including the creation timestamp of the keyring, the creation and modification timestamps for each password entry, and the description and password for each password entry.</p>&#13;
<p class="indent">If you don’t have the password, brute-force attempts can be made to crack it using a recovery tool that supports the GNOME Keyring format. <span epub:type="pagebreak" id="page_297"/>If you do have the password to unlock a keyring, there are several ways to extract information.</p>&#13;
<p class="indent">The easiest way to view all the information is simply to set a blank password for the keyring, meaning that the resulting keyring file contents will be saved unencrypted. Another way to extract information is using <span class="literal">dump-keyring0</span> <span class="literal">-format</span>, which is included in the GNOME Keyring source code,<sup><a id="ch10foot010" href="footnotes.xhtml#ch10foot_010">10</a></sup> as shown here:</p>&#13;
<pre>$ <span class="codestrong1">dump-keyring0-format ~/.local/share/keyrings/Launch_Codes.keyring</span>&#13;
Password:&#13;
#version: 0.0 / crypto: 0 / hash: 0&#13;
&#13;
[keyring]&#13;
display-name=Launch Codes&#13;
ctime=0&#13;
mtime=1583299936&#13;
lock-on-idle=false&#13;
lock-after=false&#13;
lock-timeout=0&#13;
x-hash-iterations=1953&#13;
x-salt=8/Ylw/XF+98=&#13;
x-num-items=1&#13;
x-crypto-size=128&#13;
&#13;
[1]&#13;
item-type=2&#13;
display-name=WOPR&#13;
secret=topsecretpassword&#13;
ctime=1583300127&#13;
mtime=1583419166&#13;
&#13;
[1:attribute0]&#13;
name=xdg:schema&#13;
type=0&#13;
value=org.gnome.keyring.Note</pre>&#13;
<p class="noindent">Using this method, you can see information about the keyring and the individual entries. The password entries contain the password, creation time, and last modified time.</p>&#13;
<p class="indent"><em>Seahorse</em> is the primary graphical tool in the GNOME desktop environment for managing passwords and keys. Seahorse can create and manage password keyrings (via the gnome-keyring-daemon) and can also create and manage other keys such as SSH and GNU Privacy Guard (GPG). Support for PKCS11 certificates is under development and uses the file <em>user.keystore</em>. <a href="ch10.xhtml#ch010fig05">Figure 10-5</a> shows a screenshot of Seahorse.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_298"/><img id="ch010fig05" src="Images/ch10fig05.jpg" alt="Image" width="695" height="370"/></div>&#13;
<p class="figcap"><em>Figure 10-5: Seahorse Passwords and Keys manager tool</em></p>&#13;
<h4 class="h4" id="ch00lev2_137"><strong><em>KDE Wallet Manager</em></strong></h4>&#13;
<p class="noindent">The KDE desktop environment has a credential storage mechanism called KWallet, in which users can store multiple passwords and web form data. The wallet is protected with a separate password. KDE-integrated apps are able to use KWallet to store passwords and other sensitive information.</p>&#13;
<p class="indent">Wallets managed using the KWallet Manager operate through the <span class="literal">kwalletd</span> daemon, which is started on demand by the wallet manager. Wallets can be encrypted using the Blowfish algorithm or with the user’s GPG keys. <a href="ch10.xhtml#ch010fig06">Figure 10-6</a> on the following page shows an overview of the KDE Wallet system.</p>&#13;
<p class="indent">The default location for wallet files is <em>~/.local/share/kwalletd/</em>, and files have the same name as the wallet. There are two files per wallet: one with a <em>*.kwl</em> extension containing the encrypted data and one with a <em>*.salt</em> extension containing salt data to strengthen against password-cracking attempts. The <em>*.kwl</em> files have a header that determines the version and type of wallet file.</p>&#13;
<p class="indent">The first 12 bytes of the wallet file are always the same and signify that it is a KDE wallet:</p>&#13;
<pre>4B 57 41 4C 4C 45 54 0A 0D 00 0D 0A 00 01 02 00 KWALLET.........</pre>&#13;
<p class="noindent">The 13th and 14th bytes are the major and minor version numbers and the 15th and 16th bytes specify the encryption and hash algorithms, respectively (see <em><a href="https://github.com/KDE/kwallet/blob/master/src/runtime/kwalletd/backend/backendpersisthandler.cpp">https://github.com/KDE/kwallet/blob/master/src/runtime/kwalletd/backend/backendpersisthandler.cpp</a></em> for more information). If the 15th byte of a <em>*.kwl</em> file is 0x02, it’s GPG; if the 15th byte is 0x00 or 0x03, it’s a version of Blowfish.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_299"/><img id="ch010fig06" src="Images/ch10fig06.jpg" alt="Image" width="553" height="572"/></div>&#13;
<p class="figcap"><em>Figure 10-6: KWallet data flow</em></p>&#13;
<p class="indent">Some Linux distributions create a default wallet called <em>kdewallet</em>, and users can create and manage additional wallets using frontend tools like <span class="literal">kwallet-query</span> or <span class="literal">kwalletmanager5</span>, shown in <a href="ch10.xhtml#ch010fig07">Figure 10-7</a>.</p>&#13;
<div class="image"><img id="ch010fig07" src="Images/ch10fig07.jpg" alt="Image" width="694" height="359"/></div>&#13;
<p class="figcap"><em>Figure 10-7: KWallet Manager Tool</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_300"/>You can copy these files to another Linux machine to analyze them using the same wallet manager utilities.</p>&#13;
<p class="indent">If a password-recovery tool supports the Blowfish format of KWallet files, attempts to brute-force the password can be made.</p>&#13;
<p class="indent">In some cases, the login password and KWallet password might be the same—for example, when <span class="literal">pam_kwallet</span> is used. If GPG is used, the KWallet password is the same as the user’s GPG key password. Also check the logs for <span class="literal">kwalletd5</span> or <span class="literal">kwalletmanager5</span>, as sometimes error messages may appear during the use of the wallet manager, providing a timestamp linked to evidence of use.</p>&#13;
<h4 class="h4" id="ch00lev2_138"><strong><em>Biometric Fingerprint Authentication</em></strong></h4>&#13;
<p class="noindent">Recent versions of Linux desktops offer biometric fingerprint authentication if the machine has compatible hardware. The fprint project (<em><a href="https://fprint.freedesktop.org/">https://fprint.freedesktop.org/</a></em>) provides Linux support for various fingerprint-reading devices, which can be used for authentication.</p>&#13;
<p class="indent">The user must enroll fingerprints before they can be used. The enrollment process saves fingerprint information to files (a single file for each finger). The files are located in the <em>/var/lib/fprint/</em> directory, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">sudo ls /var/lib/fprint/sam/synaptics/45823e114e26</span>&#13;
1 2 7 8</pre>&#13;
<p class="noindent">This directory path is constructed from the username (<span class="literal">sam</span>), and the manufacturer (<span class="literal">synaptics</span>) and USB device number or serial number (<span class="literal">45823e114e26</span>) of the fingerprint-reading device. The filenames of enrolled fingers are saved as numbers. The associated numbers for each finger are as follows:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">1</span>    Left thumb</p>&#13;
<p class="noindentin"><span class="codestrong">2</span>    Left index finger</p>&#13;
<p class="noindentin"><span class="codestrong">3</span>    Left middle finger</p>&#13;
<p class="noindentin"><span class="codestrong">4</span>    Left ring finger</p>&#13;
<p class="noindentin"><span class="codestrong">5</span>    Left little finger</p>&#13;
<p class="noindentin"><span class="codestrong">6</span>    Right thumb</p>&#13;
<p class="noindentin"><span class="codestrong">7</span>    Right index finger</p>&#13;
<p class="noindentin"><span class="codestrong">8</span>    Right middle finger</p>&#13;
<p class="noindentin"><span class="codestrong">9</span>    Right ring finger</p>&#13;
<p class="noindentin"><span class="codestrong">10</span>    Right little finger</p>&#13;
</div>&#13;
<p class="noindent">The structure of the fingerprint objects is documented at the project team’s website, including useful information for a forensic examination.</p>&#13;
<p class="indent">The fingerprint files contain information about the fingerprint reader, the username, the date of enrollment, and possibly the data from the scanned finger. Depending on the fingerprint reader hardware, these files may <span epub:type="pagebreak" id="page_301"/>differ. Some readers will store the fingerprint data in the device itself and only save metadata in the files.</p>&#13;
<p class="indent">A PAM module (<em>pam_fprintd</em>) and PAM configuration file (<em>gdm-fingerprint</em> for example) facilitates fingerprint scanning for authentication. This PAM module also logs successful fingerprint authentication, as shown:</p>&#13;
<pre>Dec 26 20:59:33 pc1 gdm-fingerprint][6241]: pam_unix(gdm-fingerprint:session):&#13;
session opened for user sam(uid=1000) by (uid=0)</pre>&#13;
<p class="noindent">Here, biometric authentication was used to log in to a machine from GDM.</p>&#13;
<p class="indent">Biometric authentication is especially interesting from a forensics perspective. It identifies physical attributes of a person rather than knowledge of a password that can be stolen or shared. However, biometric authentication can also be forced (coercion, blackmail, physical force, or other threats) or “stolen” while someone is sleeping or unconscious. Other methods of using copies of fingerprints on certain materials have been shown to work with some fingerprint readers.<sup><a id="ch10foot011" href="footnotes.xhtml#ch10foot_011">11</a></sup></p>&#13;
<h4 class="h4" id="ch00lev2_139"><strong><em>GnuPG</em></strong></h4>&#13;
<p class="noindent">In 1991, Philip Zimmermann created Pretty Good Privacy (PGP) to provide the public with a simple tool for strong encryption to protect files and messages. It was initially free and open source but later became a commercial product. Concerns over patents and commercialization led to the creation of the OpenPGP standard, originally described in RFC 2440 (currently RFC 4880 and RFC 5581). In 1999, an independent implementation of Open- PGP was developed under the name GNU Privacy Guard (GnuPG or GPG), a software project that is actively developed to this day.</p>&#13;
<p class="indent">GPG is a popular form of encryption and used by email programs, office programs, software package integrity verification tools, password managers,<sup><a id="ch10foot012" href="footnotes.xhtml#ch10foot_012">12</a></sup> and other programs in need of interoperable cryptography.</p>&#13;
<p class="indent">Most Linux distributions include GPG software by default for the purpose of verifying the signatures of software packages. Frontend tools like Seahorse and KGpg make GPG key generation and management easy for Linux users. Decrypting GPG-encrypted files is a challenge that forensic investigators regularly face, together with other encryption challenges.</p>&#13;
<p class="indent">The <span class="literal">gpg</span> program is compiled with default options, but will look for a system-wide configuration file (<em>/etc/gnupg/gpgconf.conf</em> ) and the default location of the user configuration file (<em>~/.gnupg/gpg.conf</em> ). <a href="ch10.xhtml#ch010fig08">Figure 10-8</a> provides an overview of GPG.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_302"/><img id="ch010fig08" src="Images/ch10fig08.jpg" alt="Image" width="556" height="434"/></div>&#13;
<p class="figcap"><em>Figure 10-8: GnuPG data flow</em></p>&#13;
<p class="indent">The key files consist of public and private key pairs belonging to the user and any other keys that have been added to the public keyring. On newer systems, the user’s public keys are located in <em>~/.gnupg/pubring.kbx</em> (previous versions stored them in <em>~/.gnupg/pubring.gpg</em>).</p>&#13;
<p class="indent">In addition to the private keys, it can be interesting to examine which public keys have been added to a keyring. This file can be read without the secret key and may contain information of forensic interest. For example, any public keys added by the user will be visible together with the date created, name, email address, and other information.</p>&#13;
<p class="indent">The <span class="literal">gpg</span> binary does not have an option to specify which file to use, but the <span class="literal">GNUPGHOME</span> environment variable can be set to point to a copy of the <em>.gnupg</em> directory if you have moved the files to a separate analysis machine, as demonstrated in the following example:</p>&#13;
<pre>$ <span class="codestrong1">GNUPGHOME=/evidence-extracted/home/sam/.gnupg gpg --list-public-keys</span>&#13;
/home/sam/extract/.gnupg/pubring.kbx&#13;
------------------------------------&#13;
...&#13;
pub  rsa2048 2011-04-26 [SC]&#13;
   FCF986EA15E6E293A5644F10B4322F04D67658D8&#13;
   uid           [ unknown] FFmpeg release signing key &lt;ffmpeg-devel@ffmpeg.org&gt;&#13;
   sub   rsa2048 2011-04-26 [E]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_303"/>Other GPG commands for listing or extracting keys and information can also be used in this way. See the gpg(1) man page for more details.</p>&#13;
<p class="indent">Some forensic programs or password-recovery tools are able to attempt recovery of GPG private keys. John the Ripper also supports brute-forcing GPG encrypted files.</p>&#13;
<h3 class="h3" id="ch00lev1_49"><strong>Linux Desktop Artifacts</strong></h3>&#13;
<p class="noindent">As with the forensic examination of Windows or Macintosh computers, the Linux desktop can be of significant interest to forensic investigators. Analyzing digital traces from various graphical components allows you to reconstruct past activity and user behavior. This section focuses on finding useful forensic artifacts on a graphical Linux system.</p>&#13;
<h4 class="h4" id="ch00lev2_140"><strong><em>Desktop Settings and Configuration</em></strong></h4>&#13;
<p class="noindent">Most desktops today use a database for storing configuration data. This database can be used by any application, and configuration settings can be shared between different programs.</p>&#13;
<h5 class="h5"><strong>GNOME configuration</strong></h5>&#13;
<p class="noindent">Desktop environments based on GNOME 3 and GNOME 40<sup><a id="ch10foot013" href="footnotes.xhtml#ch10foot_013">13</a></sup> store settings and configuration data using the GSettings API, which in turn uses the dconf configuration system. The <span class="literal">dconf-service</span> program is activated over D-Bus whenever an application or desktop component wants to modify configuration settings (for performance, reading settings is done directly from the files, without D-Bus). Dconf is conceptually similar to the Windows Registry, where data is stored in a hierarchical tree with keys and values.</p>&#13;
<p class="indent">The desktop configuration utilities like GNOME Control Center (see <a href="ch10.xhtml#ch010fig09">Figure 10-9</a> on the following page) or GNOME Tweaks read and write settings to the dconf system (the <span class="literal">dconf-editor</span> tool can be used to see all settings). Any applications built with the glib library are also able to use the dconf system to store configuration information.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_304"/><img id="ch010fig09" src="Images/ch10fig09.jpg" alt="Image" width="694" height="565"/></div>&#13;
<p class="figcap"><em>Figure 10-9: GNOME Control Center</em></p>&#13;
<p class="indent">Because the typical tools (GNOME Control Center, Gnome Tweaks, <span class="literal">gsettings</span>, <span class="literal">dconf-editor</span>) for viewing dconf configuration also operate using D-Bus on a live system, they are not suitable for use in a postmortem examination. Therefore, we must examine the files where configuration data is stored on the filesystem. All the dconf settings that deviate from the defaults (that is, the user or application made changes) are stored in a single file: <em>~/.config/dconf/user</em>.</p>&#13;
<p class="indent">This file uses a binary database format known as GNOME Variant (gvdb). The database can be extracted using an offline reader found here: <em><a href="https://github.com/chbarts/gvdb/">https://github.com/chbarts/gvdb/</a></em>. The <span class="literal">reader</span> tool dumps the contents of any gvdb file, including GNOME configuration databases; for example:</p>&#13;
<pre>$ <span class="codestrong1">reader /home/sam/.config/dconf/user</span>&#13;
/home/sam/.config/dconf/user&#13;
...&#13;
   /org/gnome/shell/favorite-apps&#13;
       ['org.gnome.Calendar.desktop', 'org.gnome.Music.desktop',&#13;
       'org.gnome.Photos.desktop', 'org.gnome.Nautilus.desktop',&#13;
       'org.gnome.Software.desktop', 'termite.desktop',&#13;
       'firefox.desktop'] <span class="ent">➊</span> &#13;
...&#13;
   /org/gnome/cheese/camera&#13;
       'HD Webcam C525' <span class="ent">➋</span> &#13;
...&#13;
   /org/gnome/desktop/background/picture-uri&#13;
       'file:///home/sam/Pictures/Webcam/2020-10-11-085405.jpg' <span class="ent">➌</span> &#13;
...&#13;
   /org/blueman/plugins/recentconns/recent-connections&#13;
       [{'adapter': 'B4:6B:FC:56:BA:70',&#13;
       <span epub:type="pagebreak" id="page_305"/>'address': '38:01:95:99:4E:31',&#13;
       'alias': '[Samsung] R3', 'icon': 'audio-card', 'name': 'Auto connect profiles',&#13;
       'uuid': '00000000-0000-0000-0000-000000000000', 'time': '1597938017.9869914',&#13;
       'device': '', 'mitem': ''}] <span class="ent">➍</span> &#13;
...&#13;
   /org/gnome/epiphany/search-engines&#13;
       [('DuckDuckGo', 'https://duckduckgo.com/?q=%s&amp;t=epiphany', '!ddg')] <span class="ent">➎</span> &#13;
...&#13;
   /system/proxy/socks/port&#13;
       8008 <span class="ent">➏</span> &#13;
...&#13;
   /system/proxy/socks/host&#13;
       'proxy.example.com' <span class="ent">➏</span> &#13;
...</pre>&#13;
<p class="noindent">In this example, we see a variety of desktop configuration information that might be found in the dconf database file. The hierarchical tree structure of the configuration can be seen in paths (<em>/org/gnome/. . .</em>) and the contents on the line below. From this example, the configuration that is interesting from a forensics perspective includes:</p>&#13;
<ul>&#13;
<li class="noindent">Favorite apps listed on the GNOME dash (the dock revealed by clicking Activities) <span class="ent">➊</span></li>&#13;
<li class="noindent">A webcam used by the cheese program (cheese is a webcam photo app: <em><a href="https://wiki.gnome.org/Apps/Cheese">https://wiki.gnome.org/Apps/Cheese</a></em>) <span class="ent">➋</span></li>&#13;
<li class="noindent">The file location of the desktop background picture (likely taken with the webcam) <span class="ent">➌</span></li>&#13;
<li class="noindent">The most recent Bluetooth devices, including MAC address, device description, and timestamp <span class="ent">➍</span></li>&#13;
<li class="noindent">The user-configured default search engine (DuckDuckGo) in the Epiphany web browser <span class="ent">➎</span></li>&#13;
<li class="noindent">User-defined proxy settings, including the protocol (SOCKS), TCP port number, and proxy host <span class="ent">➏</span></li>&#13;
</ul>&#13;
<p class="noindent">Any application can save settings via the GSettings API, and they will be stored in the dconf database files. In addition to the gvdb <em>user</em> file, system-wide equivalent dconf databases may be found in <em>/etc/dconf/db/*</em>. User-defined configuration data has priority over system configuration or other configuration databases (profiles).</p>&#13;
<p class="indent">The configuration information saved depends on an application’s developer. As shown in the previous example, configuration information can include any persistent information desired, including history of files opened, bookmarks, timestamps of various events, remote servers and account names, previously attached devices, previous calendar notifications, and much more information that could be useful in a forensic investigation. See the dconf(7) man page for more information.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_306"/><strong>KDE Configuration</strong></h5>&#13;
<p class="noindent">The KDE desktop manages user configuration changes with KConfig Modules (KCMs).<sup><a id="ch10foot014" href="footnotes.xhtml#ch10foot_014">14</a></sup> These configuration changes are stored as plaintext files in the user’s <em>.config/</em> directory, with the filename usually ending in <em>rc</em>. Here are some examples:</p>&#13;
<pre>$ <span class="codestrong1">ls .config/*rc</span>&#13;
 .config/akregatorrc                .config/kmixrc&#13;
 .config/baloofilerc                .config/konsolerc&#13;
 .config/gtkrc                      .config/kscreenlockerrc&#13;
 .config/gwenviewrc                 .config/ksmserverrc&#13;
 .config/kactivitymanagerdrc        .config/ktimezonedrc&#13;
 .config/kactivitymanagerd-statsrc  .config/kwinrc&#13;
 .config/kateschemarc               .config/kwinrulesrc&#13;
 .config/kcminputrc                 .config/kxkbrc&#13;
...</pre>&#13;
<p class="noindent">In this example, the user’s KDE/Plasma configuration changes that deviate from the system defaults are written into files. These files can be from any applications that integrate with KDE/Plasma.</p>&#13;
<p class="indent">The files have a basic <em>ini</em>-style format that is easy to understand, as illustrated here:</p>&#13;
<pre>$ <span class="codestrong1">cat ~/.config/kcookiejarrc</span>&#13;
[Cookie Policy]&#13;
AcceptSessionCookies=true&#13;
CookieDomainAdvice=evil.com:Reject,evil.org:Reject&#13;
CookieGlobalAdvice=Accept&#13;
Cookies=true&#13;
RejectCrossDomainCookies=true</pre>&#13;
<p class="noindent">Here the user has configured a personal cookie policy that includes explicitly rejecting cookies from certain sites.</p>&#13;
<h5 class="h5"><strong>Other Desktop Configurations</strong></h5>&#13;
<p class="noindent">Desktop environments and applications based on GNOME 2 store settings and configuration data using the GConf system. GConf is now deprecated, but some applications may still use it. The configuration data is stored using readable text files in XML format. The user-defined gconf files are located in <em>~/.config/gconf/*</em> and system-wide files are in <em>/etc/gconf/*</em>.</p>&#13;
<p class="indent">Other desktop environments, window managers, and graphical components may save configuration data in files or databases in the user XDG standard directories (<em>~/.config/</em>, <em>~/.local/share/</em>) or as hidden files in the home directory (<em>~/.*</em>). Close examination of the user home directories may reveal additional configuration specific to a desktop environment or component not respecting the XDG base directory standard.</p>&#13;
<h4 class="h4" id="ch00lev2_141"><span epub:type="pagebreak" id="page_307"/><strong><em>Desktop Clipboard Data</em></strong></h4>&#13;
<p class="noindent">Early X11 systems had very simple copy/paste mechanisms where selected text could be pasted using the middle mouse button into whatever window had focus (the selected text was not saved). The Inter-Client Communication Conventions Manual (ICCCM) standards called this the “PRIMARY” selection and added an additional “CLIPBOARD” for text that was saved in memory and could be pasted at any time.</p>&#13;
<p class="indent">Modern desktop environments introduced clipboard management systems for multiple items that were stored persistently across logins. These clipboard managers are implemented as user daemons, plug-ins, or tray applets that coordinate the copying of text and choosing what to paste.</p>&#13;
<p class="indent">Most desktop environments have a default clipboard manager, but users may choose to install other stand-alone clipboard manager programs. This section describes the analysis and extraction of clipboard data from the most common clipboard managers.</p>&#13;
<p class="indent">The KDE desktop provides the Klipper clipboard manager. By default, the last seven copied items are remembered and saved to the file <em>~/.local/ share/klipper/history2.lst</em>. The file has a short header, and clipboard entries are separated by the word <span class="literal">string</span>.</p>&#13;
<p class="indent">The file can be viewed with a hex editor or text editor capable of 16-bit character widths. The following <span class="literal">sed</span> command can provide a quick-and-dirty list of saved clipboard entries:</p>&#13;
<pre>$ <span class="codestrong1">sed</span> '<span class="codestrong1">s/s.t.r.i.n.g...../\n/g</span>' <span class="codestrong1">.local/share/klipper/history2.lst</span>&#13;
.P^ÃĞ5.18.2&#13;
&#13;
apropos clipboard&#13;
&#13;
xclip - command line interface to X selections&#13;
&#13;
UUID=514d2d84-e25d-41dd-b013-36d3a4575c0a&#13;
&#13;
MyUncrackableSuperPassword!1234&#13;
&#13;
https://www.opensuse.org/searchPage</pre>&#13;
<p class="noindent">The header ends with a version number, and the lines following are the history of items copied into the clipboard. You can also use the <span class="literal">strings</span> command (maybe with <span class="literal">-el</span>), but the list will appear unformatted.</p>&#13;
<p class="indent">Distributions with the GNOME desktop environment may have different clipboard managers. These are available as plug-ins or separate programs, and some distros don’t install a clipboard manager by default. The following example shows the Clipboard Indicator extension for GNOME. The default history size is 15 items, which are stored in the <em>~/.cache/clipboard -indicator@tudmotu.com/registry.txt</em> file, as shown in this example:</p>&#13;
<pre>$ <span class="codestrong1">cat .cache/clipboard-indicator@tudmotu.com/registry.txt</span>&#13;
[{"contents":"GNOME Shell Extension","favorite":false},{&#13;
<span epub:type="pagebreak" id="page_308"/>"contents":"https://www.debian.org/","favorite":false},{&#13;
"contents":"https://www.gnome.org/gnome-3/","favorite":false}]</pre>&#13;
<p class="noindent">This is a simple JSON file and can be read with any text editor.</p>&#13;
<p class="indent">Clipman is a plug-in for the Xfce panel and is embedded in the panel bar across the top or bottom of the desktop. By default, 10 items are stored in the <em>~/.cache/xfce4/clipman/textsrc</em> file. The items are stored in a readable format, and each item is separated by a semicolon:</p>&#13;
<pre>$ <span class="codestrong1">cat .cache/xfce4/clipman/textsrc</span>&#13;
[texts]&#13;
texts=1584351829;MyAWeSoMeUnCrackablePassword!1234;This paragraph has\nmultiple&#13;
lines\nof text to demonstrate\nhow it looks in the\nclipboard history;</pre>&#13;
<p class="noindent">Everything in <span class="literal">texts=</span> is on a single line. Copied text with multiple lines is separated with a newline character <span class="literal">\n</span>.</p>&#13;
<p class="indent">Another example is Lubuntu, which uses Qlipper by default and stores clipboard data in <em>~/.config/Qlipper/qlipper.ini</em>.</p>&#13;
<p class="indent">Many clipboard managers are available for Linux. Each distro makes its own decision on what to use, and you need to determine which clipboard system is in use and where the data might be stored.</p>&#13;
<h4 class="h4" id="ch00lev2_142"><strong><em>Desktop Trash Cans</em></strong></h4>&#13;
<p class="noindent">The computer desktop metaphor also introduced the concept of trash cans that allow a user to easily recover files that were discarded. <a href="http://freedesktop.org">freedesktop.org</a> defines a standard for implementing trash cans on Linux desktop systems.<sup><a id="ch10foot015" href="footnotes.xhtml#ch10foot_015">15</a></sup> The standard refers to moving files to the trash as <em>trashing</em> and unlinking from the filesystem as <em>erasing</em>. Adherence to this standard lies not so much with the distros or even the desktops, but primarily with the file managers.</p>&#13;
<p class="indent">The desktop or file manager can display a trash icon where people can see trashed files, recover them, or delete them from the filesystem (that is, empty the trash). Depending on the type of storage media and filesystem, files deleted from the trash might still be recoverable using forensic tools.</p>&#13;
<p class="indent">The default file managers for GNOME, KDE, Xfce, and LXDE are Nautilus, Dolphin, Thunar, and PCManFM, respectively. These file managers (and others) follow the trash specification. When files and directories are moved to the trash, they are moved to another location on the filesystem, and the information needed to recover them is saved. The typical location of the trash is <em>~/.local/share/Trash/</em> in the user’s home directory, which contains the following:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>files/</em></strong> The directory where trashed files and directories are moved. Unless entire directories are trashed, the <em>files/</em> directory is flat with no additional structure.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_309"/><strong><em>info/</em></strong> A directory containing <em>*.trashinfo</em> files for every deleted file or directory. These files contain the original location of the trashed item and a timestamp of when it was moved to the trash.</p>&#13;
<p class="noindentin"><strong><em>directorysizes</em></strong> When a directory is trashed, some file managers update the <em>directorysizes</em> file with the name and size of the directory trashed together with a timestamp (Unix epoch) of when it was moved.</p>&#13;
<p class="noindentin"><strong><em>expunged/</em></strong> GNOME gvfs may create an expunged directory for deleting files from the trash. This is not part of the standard and doesn’t always appear.</p>&#13;
</div>&#13;
<p class="indent">The following example shows a typical trash folder structure containing a trashed file (<em>helloworld.c</em>) and trashed directory (<em>Secret_Docs/</em>):</p>&#13;
<pre>$ <span class="codestrong1">find .local/share/Trash/</span>&#13;
.local/share/Trash/&#13;
.local/share/Trash/files&#13;
.local/share/Trash/files/Secret_Docs&#13;
.local/share/Trash/files/Secret_Docs/mypasswords.odt&#13;
.local/share/Trash/files/helloworld.c&#13;
.local/share/Trash/info&#13;
.local/share/Trash/info/Secret_Docs.trashinfo&#13;
.local/share/Trash/info/helloworld.c.trashinfo&#13;
.local/share/Trash/directorysizes</pre>&#13;
<p class="noindent">The <em>*.trashinfo</em> and <em>directorysizes</em> file contents are readable plaintext. The <em>directorysizes</em> file contains one line for every deleted directory (in addition to the <em>*.trashinfo</em> file).</p>&#13;
<p class="indent">No additional meta information is kept about the contents of trashed directories—only the size. The <em>.trashinfo</em> and <em>directorysizes</em> are shown here:</p>&#13;
<pre>$ <span class="codestrong1">cat .local/share/Trash/info/helloworld.c.trashinfo</span>&#13;
[Trash Info]&#13;
Path=/home/sam/helloworld.c&#13;
DeletionDate=2020-03-16T15:55:04&#13;
$ <span class="codestrong1">cat .local/share/Trash/info/Secret_Docs.trashinfo</span>&#13;
[Trash Info]&#13;
Path=/home/sam/Secret_Docs&#13;
DeletionDate=2020-03-16T21:14:14&#13;
$ <span class="codestrong1">cat .local/share/Trash/directorysizes</span>&#13;
8293 1584389654463 Secret_Docs</pre>&#13;
<p class="noindent">Trash folders (other than a user’s home Trash) can exist on removable storage (like USB sticks), mounted network shares, and other locations using a <em>.Trash/</em> or <em>.Trash-UID/</em> directory (where UID is the numeric ID of the user) at the top of the mounted directory. The Trash specification does not require systems to support this, but many file managers do.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_310"/>Analyzing trash folders on any operating system is standard in forensic investigations. When a deletion attempt is made, deletion timestamps exist, and an original location is revealed where more relevant files might be found.</p>&#13;
<h4 class="h4" id="ch00lev2_143"><strong><em>Desktop Bookmarks and Recent Files</em></strong></h4>&#13;
<p class="noindent">Identifying bookmarks (sometimes called “favorites") and recently used items on the desktop is a typical part of a forensic examination. On Linux desktops, bookmarks and recently used files, or “recents,” are managed with the same mechanism. Recent documents can also be thought of as dynamically created bookmarks.</p>&#13;
<p class="indent">The <em>xbel</em> file format refers to the XML Bookmark Exchange Language (see <em><a href="http://pyxml.sourceforge.net/topics/xbel/">http://pyxml.sourceforge.net/topics/xbel/</a></em> and <em><a href="https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/">https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/</a></em>). These are not limited to office documents and pictures; they may also contain other files that were opened by applications or file managers (zip files, for example).</p>&#13;
<p class="indent">Bookmarks and information about recent files can be found in several standard locations on a Linux system with an <em>.xbel</em> extention. Examples include <em>.local/share/recently-used.xbel</em> and <em>.local/user-places.xbel</em> found in the user’s home directory. These files may also have backup copies (<em>*.bak</em>) containing previously bookmarked items.</p>&#13;
<p class="indent">The following shows a single entry (there can be multiple entries) in a recently used file:</p>&#13;
<pre>$ <span class="codestrong1">cat ~/.local/share/recently-used.xbel</span>&#13;
  &lt;bookmark href="file:///tmp/mozilla_sam0/Conference.pdf" added="2020-11-03T06&#13;
  :47:20.501705Z" modified="2020-11-03T06:47:20.501738Z" visited="2020-11-03T06&#13;
  :47:20.501708Z"&gt;&#13;
    &lt;info&gt;&#13;
      &lt;metadata owner="http://freedesktop.org"&gt;&#13;
        &lt;mime:mime-type type="application/pdf"/&gt;&#13;
        &lt;bookmark:applications&gt;&#13;
          &lt;bookmark:application name="Thunderbird" exec="&amp;apos;thunderbird&#13;
          %u&amp;apos;" modified="2020-11-03T06:47:20.501717Z" count="1"/&gt;&#13;
        &lt;/bookmark:applications&gt;&#13;
      &lt;/metadata&gt;&#13;
    &lt;/info&gt;&#13;
  &lt;/bookmark&gt;&#13;
...</pre>&#13;
<p class="noindent">Here, the file <em>Conference.pdf</em> was saved to a temporary location by the Thunderbird mail client. Information about the file type and timestamps are also saved.</p>&#13;
<p class="indent">This example shows an entry in the <em>user-places.xbel</em> file:</p>&#13;
<pre>$ <span class="codestrong1">cat ~/.local/user-places.xbel</span>&#13;
 <span epub:type="pagebreak" id="page_311"/>&lt;bookmark href="file:///home/sam/KEEPOUT"&gt;&#13;
 &lt;title&gt;KEEPOUT&lt;/title&gt;&#13;
 &lt;info&gt;&#13;
  &lt;metadata owner="http://freedesktop.org"&gt;&#13;
   &lt;bookmark:icon name="/usr/share/pixmaps/electron.png"/&gt;&#13;
  &lt;/metadata&gt;&#13;
  &lt;metadata owner="http://www.kde.org"&gt;&#13;
   &lt;ID&gt;1609154297/4&lt;/ID&gt;&#13;
  &lt;/metadata&gt;&#13;
 &lt;/info&gt;&#13;
&lt;/bookmark&gt;</pre>&#13;
<p class="noindent">Here, the folder <em>/home/sam/KEEPOUT</em> is bookmarked (“add to places”) in KDE’s Dolphin file manager. The timestamp refers to the date added or when the properties of the bookmark were changed (name, icon, and so on).</p>&#13;
<p class="indent">Some recent file data is stored in <em>*.desktop</em> files in the <em>.local/share/Recent Documents/</em> directory; for example:</p>&#13;
<pre>$ <span class="codestrong1">cat</span> <span class="codestrong1">PFI_cover-front-FINAL.png.desktop</span>&#13;
[Desktop Entry]&#13;
Icon=image-png&#13;
Name=PFI_cover-front-FINAL.png&#13;
Type=Link&#13;
URL[$e]=file:$HOME/publish/pfi-book/nostarch/COVER/PFI_cover-front-FINAL.png&#13;
X-KDE-LastOpenedWith=ristretto</pre>&#13;
<p class="noindent">Here, the <em>PFI_cover-front-FINAL.png</em> image file (the cover art from my last book) was recently opened by the Ristretto application. These desktop files contain no timestamps and the filesystem timestamp may indicate the creation date.</p>&#13;
<p class="indent">The aforementioned bookmarking methods were designed to be shared across applications, but individual applications may have their own implementation of storing bookmarks and recent documents. In a forensic examination, the list of installed programs may be analyzed for application-specific artifacts. Often these are stored in the user’s <em>.cache/</em> directory.</p>&#13;
<h4 class="h4" id="ch00lev2_144"><strong><em>Desktop Thumbnail Images</em></strong></h4>&#13;
<p class="noindent">When Linux desktops started to grow in popularity, graphical applications were developing their own way of managing thumbnail images (smaller versions of the original) for quick previews. Today this is standardized by <a href="http://freedesktop.org">freedesktop.org</a> and used by most modern applications that need thumbnail functionality. This means that thumbnails created by one application can be reused by another application because they are all stored in the same place and in the same format. The specification for Linux desktop thumbnails can be found at <em><a href="https://www.freedesktop.org/wiki/Specifications/thumbnails/">https://www.freedesktop.org/wiki/Specifications/thumbnails/</a></em>.</p>&#13;
<p class="indent">Thumbnails are typically stored in <em>~/.cache/thumbnails/</em> in several directories. Three possible subdirectories store thumbnail images: <em>large/</em>, <em>normal/</em>, and <em>fail/</em>. These contain different sizes (usually 256×256 or 128×128) of thumbnail images and also failed attempts to create a thumbnail.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>The standard dictates that all thumbnail files must be saved in PNG format and contain metadata about the original file. The possible metadata stored in the thumbnail images includes:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">Thumb::URI</span>    URI of the original file (required)</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::MTime</span>    Modification time of the original file (required)</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Size</span>    Size of the original file</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Mimetype</span>    The file MIME type</p>&#13;
<p class="noindentin"><span class="codestrong">Description</span>    Descriptive text about thumbnail contents</p>&#13;
<p class="noindentin"><span class="codestrong">Software</span>    Information about software that created the thumbnail</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Image::Width</span>    Width (pixels) of the original image</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Image::Height</span>    Height (pixels) of the original image</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Document::Pages</span>    Number of pages in the original document</p>&#13;
<p class="noindentin"><span class="codestrong">Thumb::Movie::Length</span>    Length (seconds) of the original video</p>&#13;
<p class="noindentin"><span class="codestrong">date:create</span>    The creation timestamp of the thumbnail file</p>&#13;
<p class="noindentin"><span class="codestrong">date:modify</span>    The modification date of the thumbnail file (updated if the original changes)</p>&#13;
</div>&#13;
<p class="noindent">The thumbnail filename is created using the MD5 hash of the URI of the original file location (without a trailing newline). For example, if the original file URI is <em>file:///home/username/cats.jpg</em>, the thumbnail filename will be <em>14993c875146cb2df70672a60447ea31.png</em>.</p>&#13;
<p class="indent">Failed thumbnails are sorted by the program that failed and contain a blank PNG file with as much metadata about the original file as possible. The timestamp of the PNG saved in the fail directory is the time it failed.</p>&#13;
<p class="indent">The following example shows thumbnails found in a user’s <em>~/.cache/</em> directory:</p>&#13;
<pre>$ <span class="codestrong1">ls .cache/thumbnails/normal/</span>&#13;
a13c5980c0774f2a19bc68716c63c3d0.png d02efb099973698e2bc7364cb37bd5f4.png&#13;
a26075bbbc1eec31ae2e152eb9864976.png d677a23a98437d33c7a7fb5cddf0a5b0.png&#13;
a3afe6c3e7e614d06093ce4c71cf5a43.png dc1455eab0c0e77bf2b2041fe99b960e.png&#13;
a4a457a6738615c9bfe80dafc8abb17d.png e06e9ae1a831b3903d9a368ddd653778.png&#13;
...</pre>&#13;
<p class="noindent">Using any PNG analysis tool reveals more information inside these files.</p>&#13;
<p class="indent">In this example, the ImageMagick <span class="literal">identify</span> tool is used to extract metadata from one of the files:</p>&#13;
<pre>$ <span class="codestrong1">identify -verbose a13c5980c0774f2a19bc68716c63c3d0.png</span>&#13;
Image: a13c5980c0774f2a19bc68716c63c3d0.png&#13;
  Format: PNG (Portable Network Graphics)&#13;
...&#13;
 Properties:&#13;
    date:create: 2020-03-15T08:27:17+00:00&#13;
    date:modify: 2020-03-15T08:27:17+00:00&#13;
<span epub:type="pagebreak" id="page_313"/>...&#13;
    Software: KDE Thumbnail Generator Images (GIF, PNG, BMP, ...)&#13;
    Thumb::Mimetype: image/png&#13;
    Thumb::MTime: 1465579499&#13;
    Thumb::Size: 750162&#13;
    Thumb::URI: file:///tmp/Practical_Forensic_Imaging.png&#13;
...</pre>&#13;
<p class="noindent">The first two timestamps refer to the creation and last modification times of the thumbnail PNG (it will be updated if the original image changes). The <span class="literal">Thumb::MTime:</span> property is the last modified timestamp (in Unix epoch format) of the original file.<sup><a id="ch10foot016" href="footnotes.xhtml#ch10foot_016">16</a></sup> The <span class="literal">Software:</span> property is the program that created the thumbnail. In this case, it was from KDE while using the Dolphin file manager. The <span class="literal">Thumb::Mimetype:</span>, <span class="literal">Thumb::Size:</span>, and <span class="literal">Thumb::URI:</span> properties reveal the image type, size, and location of the original file. The thumbnail is a smaller version of the original, as shown in <a href="ch10.xhtml#ch010fig010">Figure 10-10</a>.</p>&#13;
<div class="image"><img id="ch010fig010" src="Images/ch10fig10.jpg" alt="Image" width="209" height="279"/></div>&#13;
<p class="figcap"><em>Figure 10-10: Recovered thumbnail example</em></p>&#13;
<p class="indent">The removal of thumbnail files is best effort. Some file managers may delete the thumbnail when the original file is deleted. Some “cleaner” tools exist that purge cached files. Users could also manually delete the cache.</p>&#13;
<p class="indent">Some older applications might use the <em>~/.thumbnails</em> directory to store thumbnail image files.</p>&#13;
<h4 class="h4" id="ch00lev2_145"><strong><em>Well-Integrated Desktop Applications</em></strong></h4>&#13;
<p class="noindent">In the early days of X11 window managers, standard widget libraries were used to create a unified appearance across windows (same button styles, scrollbar styles, and so on). Desktop environments have taken this unified “look and feel” further to include tightly integrated applications. These apps don’t just look similar, they also behave in a similar manner, are able to communicate with one another (usually via D-Bus), and can share configuration. <span epub:type="pagebreak" id="page_314"/>These apps are sometimes called <em>well-integrated</em> applications and are developed as part of a desktop environment project. Here are several examples of project teams along with links to lists of their apps:</p>&#13;
<ul>&#13;
<li class="noindent">GNOME: <em><a href="https://wiki.gnome.org/Apps/">https://wiki.gnome.org/Apps/</a></em></li>&#13;
<li class="noindent">KDE: <em><a href="https://apps.kde.org/">https://apps.kde.org/</a></em></li>&#13;
<li class="noindent">Xfce: <em><a href="https://gitlab.xfce.org/apps/">https://gitlab.xfce.org/apps/</a></em></li>&#13;
<li class="noindent">LXDE: <em><a href="https://wiki.lxde.org/">https://wiki.lxde.org/</a></em></li>&#13;
</ul>&#13;
<p class="noindent">Typical integrated apps tend to be text editors, image and document viewers, file managers, music and video players, and so on.</p>&#13;
<p class="indent">Other integrated “accessory” applications may include applications for screenshot, configuration tools, hotkey managers, themes, and so on. The larger desktop environments may even include their own email client (GNOME’s Evolution or KDE’s Kmail, for example) or web browser. Large cross-platform applications like Firefox, Thunderbird, LibreOffice, and so on may be integrated in a more generic way (using D-Bus to communicate).</p>&#13;
<p class="indent">Well-integrated apps are interesting from a forensics perspective because they tend to log, share, configure, and store data in the same place and in the same way, making forensic analysis easier.</p>&#13;
<p class="indent">The use of widget libraries and well-integrated apps is not mandatory. It is possible to install GNOME, KDE, Xfce, and LXDE apps together on a single system, and even use older non-integrated X11 applications with various widget libraries (like Athena or Motif, for example).</p>&#13;
<h5 class="h5"><strong>File Managers</strong></h5>&#13;
<p class="noindent">File manager applications are of special interest to forensic examiners. File managers are to the local system what web browsers are to the internet. Analysis of file managers provides insight into how files on the local machine were managed.</p>&#13;
<p class="indent">Dozens of file managers are available for Linux, both graphical and text console based. Each desktop environment favors a particular file manager, and distributions may choose one file manager as their default.</p>&#13;
<p class="indent">File managers are often a strong personal preference among Linux enthusiasts, and a user’s favorite may be installed, overriding the distro default.</p>&#13;
<p class="indent">Overall, these file managers are not bound to a particular desktop, and they can be used in any environment (if the required libraries are installed).</p>&#13;
<p class="indent">The default file managers for the different desktop environments (KDE Dolphin, GNOME Nautilus, XFCE Thunar, and LXDE PCManFM) may be called by other well-integrated apps and leave artifacts of past activity, which can be useful in an investigation.</p>&#13;
<p class="indent">From a forensics perspective, the analysis of file managers and other integrated applications may include the following:</p>&#13;
<ul>&#13;
<li class="noindent">Recently opened documents</li>&#13;
<li class="noindent">Trash cans/recycle bins</li>&#13;
<li class="noindent">Image thumbnails</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_315"/>Search indexes and queries</li>&#13;
<li class="noindent">Bookmarked files and directories</li>&#13;
<li class="noindent">Tags and file manager metadata</li>&#13;
<li class="noindent">History of mounted devices and network shares</li>&#13;
<li class="noindent">Configuration and plug-ins</li>&#13;
</ul>&#13;
<p class="noindent">These artifacts may be created and shared across well-integrated applications, and they can help reconstruct past activity. Every application may store different information and in different locations. During a forensic analysis, look for cache and data files for each application used.</p>&#13;
<h4 class="h4" id="ch00lev2_146"><strong><em>Other Desktop Forensic Artifacts</em></strong></h4>&#13;
<p class="noindent">A variety of other desktop artifacts can be found on most Linux systems. These are described here.</p>&#13;
<h5 class="h5"><strong>Screenshots</strong></h5>&#13;
<p class="noindent">Screenshot functionality on Linux desktops can be implemented as extensions, as tools bundled with a particular environment, or as stand-alone applications. Screenshot tools typically save screenshots to the clipboard or to the filesystem.</p>&#13;
<p class="indent">When saved to the filesystem, screenshots are often saved to the user’s <em>~/Pictures/</em> directory with a default naming convention that includes a timestamp of when the screenshot was made, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">ls -l /home/sam/Pictures/</span>&#13;
total 3040&#13;
-rw-r----- 1 sam sam 1679862 Oct 11 09:18 'Screenshot from 2020-10-11 09-18-47.png'&#13;
-rw-r----- 1 sam sam 1426161 Oct 11 09:20 'Screenshot from 2020-10-11 09-20-52.png'</pre>&#13;
<p class="noindent">Wayland’s security architecture prevents X11-based screenshot programs from working as expected, but alternative tools work with various Wayland compositors.</p>&#13;
<h5 class="h5"><strong>Desktop Search</strong></h5>&#13;
<p class="noindent">Desktop search engines are an interesting place to look for forensic artifacts. Here, we are not looking for the keywords searched (they are not typically saved), but rather the search indexes containing filenames and other data. Local search engines are included with most distros and can index filenames or file content.</p>&#13;
<h5 class="h5"><strong>GNOME Desktop Search</strong></h5>&#13;
<p class="noindent">GNOME’s local search engine is called Tracker, and it uses daemons called Miners that index the filesystem and extract metadata for the Tracker database. Tracker uses the SPARQL database, which is based on SQLite. The database files can be found in either the <em>.cache/tracker/</em> or <em>.cache/tracker3/</em> directories.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>Newer versions of Tracker separate the database into files for each search miner (Pictures, Documents, Filesystem, and so on). The database files (<em>*.db</em>) can be dumped with the <span class="literal">sqlite</span> command and viewed as text or imported into SQLite forensic tools for analysis. For example, here the <span class="literal">sqlite</span> command is used to dump a tracker database:</p>&#13;
<pre>$ <span class="codestrong1">sqlite3 ~/.cache/tracker3/files/http%3A%2F%2Ftracker.api.gnome.org%2Fontology</span>&#13;
<span class="codestrong1">%2Fv3%2Ftracker%23FileSystem.db .dump</span>&#13;
...&#13;
INSERT INTO "nfo:FileDataObject" VALUES(100086,1602069522,NULL,275303,NULL,&#13;
'Fintech_Forensics_Nikkel.pdf',NULL,NULL,1593928895,'9f3e4118b613f560ccdebc&#13;
ee36846f09695c584997fa626eb72d556f8470697f');&#13;
...&#13;
INSERT INTO "nie:DataObject" VALUES(100086,'file:///home/sam/Downloads/&#13;
Fintech_Forensics_Nikkel.pdf', 275303,NULL,NULL,100081);&#13;
...</pre>&#13;
<p class="noindent">In this example, a file on the filesystem is represented by two lines (linked by the record number <span class="literal">100086</span>). There is a path and filename (<span class="literal">file:///home/sam/</span> <span class="literal">Downloads/Fintech_Forensics_Nikkel.pdf</span>), file size (<span class="literal">275303</span>), a file creation timestamp (<span class="literal">1593928895</span>), and a file added to database timestamp (<span class="literal">1602069522)</span>.</p>&#13;
<p class="indent">These databases may contain additional information not otherwise found on a forensic image, possibly information about files that had already been deleted.</p>&#13;
<h5 class="h5"><strong>KDE Desktop Search</strong></h5>&#13;
<p class="noindent">KDE has two local search engines: one for the local filesystem called Baloo and another for contacts, calendar, and email built into Akonadi, KDE’s personal information management (PIM) framework.</p>&#13;
<p class="indent">The Baloo database is a single file located in the user’s home directory (<em>~/.local/share/baloo/index</em>), as shown here:</p>&#13;
<pre>$ <span class="codestrong1">ls -lh ~/.local/share/baloo/</span>&#13;
total 13G&#13;
-rw-r----- 1 sam sam 13G 4. Okt 19:07 index&#13;
-rw-r----- 1 sam sam 8.0K 11. Dez 10:48 index-lock</pre>&#13;
<p class="noindent">The size of the index can grow large over time as Baloo appears to ingest significant amounts of content data. As of this writing, no tools are available for offline forensic analysis of Baloo index files on a separate analysis machine. Analysis can be done with <span class="literal">strings</span>, hex editors, and forensic carving tools. There are several Baloo tools for searching and extracting data from a running system.</p>&#13;
<p class="indent">KDE’s other indexing activity is done with Akonadi. This framework stores and indexes email, contacts, calendar entries, notes, and other information in the KDE Kontact PIM suite. The data itself is stored in MySQL databases, and the search index uses Xapian database files (<em>*.glass</em>). Everything is located in the user’s home directory (<em>~/.local/share/akonadi/</em>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_317"/>$ <span class="codestrong1">ls ~/.local/share/akonadi/</span>&#13;
Akonadi.error db_data db_misc file_db_data mysql.conf search_db&#13;
socket-localhost.localdomain-default&#13;
$ <span class="codestrong1">ls ~/.local/share/akonadi/search_db/</span>&#13;
calendars collections contacts email emailContacts notes&#13;
$ <span class="codestrong1">ls ~/.local/share/akonadi/search_db/email</span>&#13;
docdata.glass flintlock iamglass postlist.glass termlist.glass</pre>&#13;
<p class="noindent">This example shows the parts of the Akonadi directory structure. The <em>/search _db/</em> directory contains Xapian databases for each data category. The other directories have MySQL databases for the data itself. The contents of the databases can be extracted using standard MySQL and Xapian tools.</p>&#13;
<h5 class="h5"><strong>Other Search Indexes</strong></h5>&#13;
<p class="noindent">The Xfce desktop environment uses the Catfish search tool. Catfish does not index files and searches files on demand.</p>&#13;
<p class="indent">A system-wide search package called <em>mlocate</em> indexes filenames. Some distros may have it installed by default (Ubuntu, for example). A tool to update the database is run periodically from cron or with systemd timers. Only file and directory names are indexed, not content. The configuration file is <em>/etc/updatedb.conf</em>, and the database is <em>/var/lib/mlocate/mlocate.db</em>. The mlocate.db(5) man page describes the database format. This database contains last modified/changed timestamps for each directory, and it also lists which files belong to that directory (but the individual files have no timestamps). A tool for dumping this database can be found here: <em><a href="https://github.com/halpomeranz/dfis/blob/master/mlocate-time/">https://github.com/halpomeranz/dfis/blob/master/mlocate-time/</a></em>.</p>&#13;
<p class="indent">The search databases described in this section may contain evidence of files that have been deleted, previous timestamps of files, or even document and file content that may be useful in a forensic investigation.</p>&#13;
<h3 class="h3" id="ch00lev1_50"><strong>User Network Access</strong></h3>&#13;
<p class="noindent">This section describes access to/from Linux systems over a network. Remote access can be viewed from two perspectives: users initiating connections from a Linux system to a remote system, and Linux systems accepting connections from users on remote systems. Remote access is typically in the form of a remote shell or remote desktop.</p>&#13;
<p class="indent">Network shares and cloud access are considered from the end user or client perspective. Local forensic analysis of client-side activity is covered, although analysis of network server applications is beyond the scope of this book.</p>&#13;
<h4 class="h4" id="ch00lev2_147"><strong><em>Secure Shell Access</em></strong></h4>&#13;
<p class="noindent">Remote access to Unix machines began with analog telephone modems used to connect a physical terminal to a serial port (tty) on a remote system. Once machines became connected to the internet, protocols like telnet and rlogin <span epub:type="pagebreak" id="page_318"/>were created, and they used TCP/IP to access pseudo-terminals (pty or pts) on remote systems. These early protocols had poor security, and SSH was developed as a secure replacement that used cryptographic authentication and protection. Today, OpenSSH (<em><a href="https://www.openssh.com/">https://www.openssh.com/</a></em>) is the de facto standard for secure remote access.</p>&#13;
<p class="indent">Machines with an SSH server (default TCP port 22) directly exposed to the internet will experience constant scanning, probing, and brute-force attempts to gain access, which will be visible in the logs. In a forensic examination, random opportunistic “noise” from the internet must be distinguished from a targeted attack under investigation.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch010fig011">Figure 10-11</a> provides a basic overview diagram of OpenSSH clients.</p>&#13;
<div class="image"><img id="ch010fig011" src="Images/ch10fig11.jpg" alt="Image" width="693" height="521"/></div>&#13;
<p class="figcap"><em>Figure 10-11: SSH client overview</em></p>&#13;
<p class="indent">The <span class="literal">ssh</span> client accesses a shell or sends commands to a remote machine, the <span class="literal">scp</span> client is used to copy files (based on BSD’s <span class="literal">rcp</span>), and the <span class="literal">sftp</span> client also copies files interactively, similar to <span class="literal">ftp</span>. These three client programs use the same configuration files and keys, which are stored in the user’s <em>~/.ssh/</em> directory.</p>&#13;
<p class="indent">An SSH client can authenticate to a remote machine using passwords, key files, or other security key providers (smartcards, for example). By default, key files (if used) are manually created using the <span class="literal">ssh-keygen</span> tool and stored in files beginning with <em>id_*</em>. The files are named after the algorithm used, and the public key file ends with the extension <em>*.pub</em>.</p>&#13;
<p class="indent">The private key file can be encrypted with a passphrase or stored in the clear (often used for automated remote system administration tasks). The <span epub:type="pagebreak" id="page_319"/>easiest way to check whether a key file is encrypted is to attempt to change the password (using <span class="literal">ssh-keygen -p</span>). If you are prompted with <span class="literal">Enter old</span> <span class="literal">passphrase:</span>, it’s encrypted. If you are prompted with <span class="literal">Enter new passphrase</span> <span class="literal">(empty for no passphrase):</span>, then it is stored in the clear. Brute-forcing an encrypted SSH key file can also be attempted.</p>&#13;
<p class="indent">In an investigation, it is useful to search the entire system for SSH key files that might not be encrypted. Sometimes system users are created to make backups or run automated system management tools (Ansible or Nagios, for example). The header and footer of an SSH private key is the same whether encrypted or not, and the following examples can be used to create search strings in a forensic tool:<sup><a id="ch10foot017" href="footnotes.xhtml#ch10foot_017">17</a></sup></p>&#13;
<pre>-----BEGIN OPENSSH PRIVATE KEY-----&#13;
...&#13;
-----END OPENSSH PRIVATE KEY-----</pre>&#13;
<p class="noindent">The public key file ends with a comment field that can be interesting. It may contain a username, email address, hostname, or other descriptive information associated with the key. This public key can be made available for authentication using an <em>authorized_keys</em> keys file. Here’s an example public key:</p>&#13;
<pre>ssh-rsa AAAAB3NzaC1yc2EAAA ... /uzXGy1Wf172aUzlpvV3mHws= sam@example.com</pre>&#13;
<p class="noindent">Notice how the public key string contains the user’s email address in the comment area. SSH clients don’t log anything locally by default, so it can be difficult to reconstruct past SSH activity. The <em>.ssh/known_hosts</em> file is interesting from a forensics perspective, as it contains a list of hosts that were accessed in the past. New hosts are automatically added to this list when an SSH connection is made. The <em>.ssh/known_hosts</em> file contains a hostname and/or IP address, the cryptographic algorithm used, and the public key of the remote machine. This list can be used to identify other machines, hostnames, domain names, and IP addresses possibly linked to an investigation.</p>&#13;
<p class="indent">The public key information is also interesting as it can be correlated with externally gathered intelligence data like SSH public key scans (Shodan, for example), and could potentially identify other hosts using the same key (reused or replicated virtual machines). The following is an example line from a <em>.ssh/known_hosts</em> file:</p>&#13;
<pre>sdf.lonestar.org,205.166.94.16 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJJk3a190w/1&#13;
TZkzVKORvz/kwyKmFY144lVeDFm80p17</pre>&#13;
<p class="noindent">Another place to look for traces of past secure shell client activity is in the user’s shell history. These history files can be searched for <span class="literal">ssh</span>, <span class="literal">scp</span>, or <span class="literal">sftp</span> commands.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_320"/>Even though SSH clients don’t log activity by default, there may still be log entries indicating previous use. For example, when a client script or program has failed (or succeeded), evidence of SSH connection attempts might be found.</p>&#13;
<p class="indent">The SSH client configuration can be found several places: <em>/etc/ssh/ssh _config</em>, <em>/etc/ssh/ssh_config.d/*</em>, and <em>~/.ssh/config</em>, although some of these are optional. Here, added custom configuration might point to other infrastructure (Host, Match, and ProxyJump commands, for example). Also, the use of relaying and forwarding of ports might be revealed (RemoteForward, ProxyCommand, and Tunnel, for example). SSH provides highly flexible port forwarding and proxying functionality, which can be used to bypass firewall rules and existing perimeter security systems. Evidence of remote hosts, remote usernames, port forwarding, and proxying may be found in the configuration files or from commands in the shell history.</p>&#13;
<p class="indent">In a forensic examination, check other (non-OpenSSH) programs interacting with SSH (password managers or agents, for example) or alternative implementations of SSH (PuTTY, for example). An SSH agent will provide key authentication, and that is included by default in OpenSSH, but alternate agents can be used. Some examples of alternate agents or password managers were described previously (GNOME Keyring, GPG, or KDEWallet). Search for the existence of the <span class="literal">SSH_AUTH_SOCK</span> variable setting that indicates the use of an alternate agent for SSH.</p>&#13;
<p class="indent">The file copying programs <span class="literal">scp</span> and <span class="literal">sftp</span> are often used as backends for larger applications (office suites, file managers, and so on) that need to exchange files with remote servers. An additional software package called sshfs exists to create a FUSE-mounted filesystem of a remote sftp login.</p>&#13;
<p class="indent">See the ssh(1), scp(1), sftp(1), ssh-keygen(1), and ssh_config(5) man pages for more detailed information about secure shell clients.</p>&#13;
<h4 class="h4" id="ch00lev2_148"><strong><em>Remote Desktop Access</em></strong></h4>&#13;
<p class="noindent">For server environments, the ability to copy files and get a remote shell is often enough for users (especially administrators), and SSH adequately fills this need. But for desktop environments, a remote graphical desktop is possible and usually desired.</p>&#13;
<p class="indent">Traditional Unix and Linux machines didn’t need remote desktop software, because remotely accessing desktops was built into the X11 protocol. This capability requires both the local and remote machines to run X11, which is not always the case (Windows or Mac clients accessing remote Linux desktops, for example). This led to the use of remote desktops.</p>&#13;
<p class="indent">Virtual network computing (VNC) is the most popular remote desktop client for Linux. VNC servers typically listen on TCP port 5900 when a Linux desktop has a VNC server installed and running.</p>&#13;
<p class="indent">Wayland was developed with more security in mind and prevents client windows from accessing each other. Because of this, most X11-based remote access software doesn’t work on Wayland desktops (nor do X11 screenshot <span epub:type="pagebreak" id="page_321"/>or hotkey managers). As a result, Wayland desktops must build remote desktop functionality into the compositor or use other methods to gain access to the desktop.</p>&#13;
<p class="indent">One issue with VNC servers is the poor logging. In some cases, there may be no logs indicating a remote desktop connection. In other cases, the connection may be logged, but without an IP address. The following is an example from an Ubuntu machine:</p>&#13;
<pre>Dec 29 10:52:43 pc1 vino-server[371755]: 29/12/2020 10:52:43 [IPv4] Got connection from&#13;
 pc2.example.com&#13;
...&#13;
Dec 29 10:53:12 pc1 vino-server[371755]: 29/12/2020 10:53:12 Client pc2.example.com gone</pre>&#13;
<p class="noindent">Here a VNC connection was made to the <span class="literal">vino-server</span> daemon and then terminated. A hostname from a reverse DNS lookup is logged, but not an IP address.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If a person or organization runs their own DNS for the source IP range (</em>*.in-addr .arpa <em>zone), they can fake or spoof any DNS reverse lookup they want, causing logs to be false. Never fully trust hostnames from reverse DNS lookups.</em></p>&#13;
</div>&#13;
<p class="indent">There are other client protocols for remote desktop access. Remote desktop protocol (RDP) is popular in Windows environments and has some Linux support. The Spice protocol was developed primarily for Linux desktops and includes features such as TLS encryption, USB port redirection, audio, and smartcard support. Many video-conferencing applications (Jitsi, Zoom, Microsoft Teams, and Skype, for example) offer screen sharing for support and presentation purposes.</p>&#13;
<p class="indent">Many enterprise environments are implementing virtual desktop environments (VDEs) as an alternative to hardware desktop or laptop systems. A VDE is a full desktop environment running in a cloud. Similar to a virtual server, it’s a virtual desktop PC accessible with a remote desktop access method.</p>&#13;
<h4 class="h4" id="ch00lev2_149"><strong><em>Network Shares and Cloud Services</em></strong></h4>&#13;
<p class="noindent">Network-mounted filesystems (also called network shares) can be managed in the kernel, or in userspace with FUSE. If mounted for system-wide use, these network filesystems may be configured in the <em>/etc/fstab</em> file together with local hard drives. Network filesystems can also be mounted manually from the command line, and evidence might be found in the shell history. Evidence of mounting may also be found in the logs.</p>&#13;
<p class="indent">Network file system (NFS) is the traditional Unix protocol, developed by Sun Microsystems, for mounting remote filesystems on local machines. NFS shares are mounted like normal drives, but with a hostname prepended to the first field of the fstab entry (<span class="literal">hostname.example.com:/home</span>, for example).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_322"/>Compared to other network filesystems, NFS is more complex, requiring multiple protocols and RPC services (mountd), processes to manage locking, authentication, exports, and more. NFS is typically used in enterprise environments, and rarely found in consumer home environments. See the nfs(5) man page for more information. The supporting protocols are defined in nearly a dozen different RFCs.</p>&#13;
<p class="indent">Common internet file system (CIFS) and/or sever message block (SMB) were originally developed by IBM and then later by Microsoft to mount remote network filesystems on local machines. Linux implements the client in the kernel, and mounting can be an entry in <em>/etc/fstab</em> (similar to NFS). The most common server-side implementation is Samba, which serves network shares to other SMB clients. See the mount.smb(3) man page for details.</p>&#13;
<p class="indent">Webdav is a web-based specification for mounting shares over the HTTP protocol. The filesystem implementation under Linux is called davfs. Webdav is popular for mounting cloud services like NextCloud. Variations of the Webdav protocol include caldav and carddav for accessing remote calendars and contact databases. See the mount.davfs(8) man page for more information about mounting webdav shares.</p>&#13;
<p class="indent">FUSE allows mounting filesystems without requiring a kernel implementation. FUSE filesystems also allow non-privileged users to mount filesystems (USB sticks, for example). FUSE can create filesystem abstractions for accessing arbitrary datasets in a filesystem-based manner (like remote FTP servers, local archive files, or unusual hardware devices containing data).</p>&#13;
<p class="indent">Various cloud accounts on desktop machines can be configured with GUI tools provided by the desktop environment. GNOME provides GOA, or GNOME Online Accounts, for configuring cloud accounts. <a href="ch10.xhtml#ch010fig012">Figure 10-12</a> shows the GOA configuration panel.</p>&#13;
<div class="image"><img id="ch010fig012" src="Images/ch10fig12.jpg" alt="Image" width="660" height="453"/></div>&#13;
<p class="figcap"><em>Figure 10-12: GNOME Online Accounts panel</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_323"/>The user has the ability to add and configure a variety of commercial and open cloud services.</p>&#13;
<p class="indent">The configured accounts can be found in the user’s home directory in the <em>~/.config/goa-1.0/accounts.conf</em> file. The following shows two examples of configured cloud accounts:</p>&#13;
<pre>   $ <span class="codestrong1">cat ~/.config/goa-1.0/accounts.conf</span>&#13;
<span class="ent">➊</span> [Account account_1581875544_0]&#13;
<span class="ent">➋</span> Provider=exchange&#13;
   Identity=sam&#13;
   PresentationIdentity=sam@example.com&#13;
   MailEnabled=true&#13;
   CalendarEnabled=true&#13;
   ContactsEnabled=true&#13;
   Host=example.com&#13;
   AcceptSslErrors=false&#13;
&#13;
<span class="ent">➌</span> [Account account_1581875887_1]&#13;
<span class="ent">➍</span> Provider=imap_smtp&#13;
   Identity=sam@example.com&#13;
   PresentationIdentity=sam@example.com&#13;
   Enabled=true&#13;
   EmailAddress=sam@example.com&#13;
   Name=Samantha Samuel&#13;
   ImapHost=example.com&#13;
   ImapUserName=sam&#13;
   ImapUseSsl=false&#13;
   ImapUseTls=true&#13;
   ImapAcceptSslErrors=false&#13;
   SmtpHost=example.com&#13;
   SmtpUseAuth=true&#13;
   SmtpUserName=sam&#13;
   SmtpAuthLogin=false&#13;
   SmtpAuthPlain=true&#13;
   SmtpUseSsl=false&#13;
   SmtpUseTls=true&#13;
   SmtpAcceptSslErrors=false</pre>&#13;
<p class="noindent">Here, Microsoft Exchange <span class="ent">➋</span> and Imap <span class="ent">➍</span> accounts are configured. Account identifiers at <span class="ent">➊</span> and <span class="ent">➌</span> in the file each contain a numeric timestamp indicating when the account entry was created. The passwords are stored in the GNOME Keyring.</p>&#13;
<p class="indent">A list of possible GOA account sections can be found here: <em><a href="https://gitlab.gnome.org/GNOME/gnome-online-accounts/raw/master/doc/goa-sections.txt">https://gitlab.gnome.org/GNOME/gnome-online-accounts/raw/master/doc/goa-sections.txt</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_324"/>KDE stores cloud account information in the user’s <em>~/.config/libaccounts -glib/</em> directory. This is in an SQLite 3 database and can be accessed (dumped) as follows:</p>&#13;
<pre>$ sqlite3 ~/.config/libaccounts-glib/accounts.db .dump&#13;
...&#13;
INSERT INTO Accounts VALUES(1,'sam','nextcloud',1);&#13;
...&#13;
INSERT INTO Settings VALUES(1,0,'dav/storagePath','s','''/remote.php/dav/files/sam''');&#13;
INSERT INTO Settings VALUES(1,0,'dav/contactsPath','s','''/remote.php/dav/addressbooks/users/sam&#13;
''');&#13;
INSERT INTO Settings VALUES(1,0,'dav/host','s','''example.com''');&#13;
INSERT INTO Settings VALUES(1,0,'auth/mechanism','s','''password''');&#13;
INSERT INTO Settings VALUES(1,0,'username','s','''sam''');&#13;
INSERT INTO Settings VALUES(1,0,'name','s','''sam''');&#13;
INSERT INTO Settings VALUES(1,0,'CredentialsId','u','1');&#13;
INSERT INTO Settings VALUES(1,0,'server','s','''https://example.com/cloud/''');&#13;
...</pre>&#13;
<p class="noindent">This reveals that a NextCloud account is configured for user <span class="literal">sam</span>. The password is stored in the KDE Wallet and requested by the libaccounts client.</p>&#13;
<p class="indent">In some cases, a Linux system may have “fat client” software installed for accessing cloud resources. This can be free and open source software like the NextCloud client, or proprietary client software like Microsoft Teams.</p>&#13;
<p class="indent">Being able to reconstruct access to cloud services can support investigations and lead to the possible recovery of additional evidence stored on remote servers.</p>&#13;
<h3 class="h3" id="ch00lev2_150"><strong><em>Summary</em></strong></h3>&#13;
<p class="noindent">This chapter will likely feel the most familiar for readers coming from a Windows or Mac forensics background. Nearly all of the user and desktop artifacts covered here are similar in concept. You now should know how to find and analyze the locations of user credentials and passwords and how fingerprint scans are stored. You also have explored windowing and desktop systems and the artifacts they provide. You should have a solid foundation for reconstructing user activity on the desktop, as well as remote access and cloud connectivity.</p>&#13;
</div></body></html>