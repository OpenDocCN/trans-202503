## 第五十六章. 套接字：简介

套接字是 IPC（进程间通信）的一种方法，允许在同一主机（计算机）或通过网络连接的不同主机之间交换数据。套接字 API 的首次广泛实现出现在 1983 年的 4.2BSD 中，该 API 已被移植到几乎所有 UNIX 实现中，以及大多数其他操作系统。

### 注意

套接字 API 在 POSIX.1g 中进行了正式规定，POSIX.1g 于 2000 年批准，此前作为草案标准存在了约十年。该标准已被 SUSv3 所取代。

本章及随后的章节描述了套接字的使用，具体如下：

+   本章提供了套接字 API 的一般介绍。以下章节假定读者已理解本章介绍的基本概念。本章不提供示例代码。UNIX 和互联网领域的代码示例将在后续章节中提供。

+   第五十七章描述了 UNIX 域套接字，它允许在同一主机系统上的应用程序之间进行通信。

+   第五十八章介绍了各种计算机网络概念，并描述了 TCP/IP 网络协议的关键特性。它为接下来的章节提供了所需的背景知识。

+   第五十九章描述了互联网域套接字，它允许不同主机上的应用程序通过 TCP/IP 网络进行通信。

+   第六十章讨论了使用套接字的服务器设计。

+   第六十一章涵盖了一系列高级主题，包括套接字 I/O 的附加特性、更详细的 TCP 协议分析，以及使用套接字选项来检索和修改套接字的各种属性。

这些章节仅旨在为读者提供使用套接字的基础知识。套接字编程，特别是用于网络通信，是一个庞大的主题，足以写成整本书。更多信息来源请参见进一步信息。

## 概述

在典型的客户端-服务器场景中，应用程序通过以下方式使用套接字进行通信：

+   每个应用程序都会创建一个套接字。套接字是允许通信的“装置”，并且两个应用程序都需要一个。

+   服务器将其套接字绑定到一个众所周知的地址（名称），以便客户端能够找到它。

使用*socket()*系统调用创建套接字，该调用返回一个文件描述符，用于在后续的系统调用中引用该套接字：

```
fd = socket(domain, type, protocol);
```

我们将在接下来的段落中描述套接字域和类型。对于本书中描述的所有应用程序，*协议*始终指定为 0。

#### 通信域

套接字存在于*通信域*中，通信域决定了：

+   套接字的标识方法（即，套接字“地址”的格式）；和

+   通信范围（即，应用程序之间的通信可能发生在同一主机上，也可能发生在通过网络连接的不同主机之间）。

现代操作系统至少支持以下几种域：

+   *UNIX* (`AF_UNIX`) 域允许在同一主机上的应用程序之间进行通信。（POSIX.1g 使用 `AF_LOCAL` 作为 `AF_UNIX` 的同义词，但该名称在 SUSv3 中未使用。）

+   *IPv4* (`AF_INET`) 域允许在通过 Internet 协议第四版（IPv4）网络连接的主机上运行的应用程序之间进行通信。

+   *IPv6* (`AF_INET6`) 域允许在通过 Internet 协议第六版（IPv6）网络连接的主机上运行的应用程序之间进行通信。虽然 IPv6 被设计为 IPv4 的继任者，但后者协议目前仍是使用最广泛的协议。

表 56-1 总结了这些套接字域的特点。

### 注意

在一些代码中，我们可能会看到类似 `PF_UNIX` 而不是 `AF_UNIX` 的常量。在这种情况下，`AF` 代表“地址族”，而 `PF` 代表“协议族”。最初，设想一个协议族可能支持多个地址族。但实际上，从未定义过支持多个地址族的协议族，所有现有的实现都将 `PF_` 常量视为与相应的 `AF_` 常量同义。（SUSv3 指定了 `AF_` 常量，但未指定 `PF_` 常量。）在本书中，我们始终使用 `AF_` 常量。关于这些常量历史的更多信息，可以参考 I/O 的通用性，出自 [Stevens 等人，2004 年]。

表 56-1. 套接字域

| 域 | 执行的通信 | 应用程序间通信 | 地址格式 | 地址结构 |
| --- | --- | --- | --- | --- |
| `AF_UNIX` | 内核内 | 在同一主机上 | 文件路径名 | *sockaddr_un* |
| `AF_INET` | 通过 IPv4 | 在通过 IPv4 网络连接的主机上 | 32 位 IPv4 地址 + 16 位端口号 | *sockaddr_in* |
| `AF_INET6` | 通过 IPv6 | 在通过 IPv6 网络连接的主机上 | 128 位 IPv6 地址 + 16 位端口号 | *sockaddr_in6* |

#### 套接字类型

每种套接字实现至少提供两种类型的套接字：流式套接字和数据报套接字。这些套接字类型在 UNIX 域和 Internet 域中都得到支持。表 56-2 总结了这些套接字类型的属性。

表 56-2. 套接字类型及其属性

| 属性 | 套接字类型 |
| --- | --- |
| 流式 | 数据报 |
| --- | --- |
| 可靠交付？ | Y | N |
| 消息边界是否保留？ | N | Y |
| 面向连接？ | Y | N |

*流套接字*（`SOCK_STREAM`）提供可靠的、双向的字节流通信通道。根据这个描述中的术语，我们指的是以下内容：

+   *可靠*意味着我们可以保证，传输的数据要么会完整地到达接收应用程序，完全按照发送方的原样（假设网络连接和接收方没有崩溃），要么我们会收到关于传输失败的通知。

+   *双向*意味着数据可以在两个套接字之间双向传输。

+   *字节流*意味着，就像管道一样，数据传输没有消息边界的概念（参见概述）。

流套接字类似于使用一对管道允许两个应用程序之间的双向通信，区别在于（互联网域）套接字允许通过网络进行通信。

流套接字以连接对的形式工作。因此，流套接字被描述为*面向连接*的。术语*对等套接字*指的是连接另一端的套接字；*对等地址*表示该套接字的地址；*对等应用程序*表示使用该对等套接字的应用程序。有时，*远程*（或*外部*）一词与*对等*互换使用。类比地，有时*本地*一词用来指代连接这一端的应用程序、套接字或地址。一个流套接字只能连接一个对等。

*数据报套接字*（`SOCK_DGRAM`）允许以名为*数据报*的消息形式交换数据。使用数据报套接字时，消息边界被保留，但数据传输不可靠。消息可能会乱序、重复，或者根本没有到达。

数据报套接字是*无连接*套接字这一更通用概念的一个例子。与流套接字不同，数据报套接字不需要连接到另一个套接字就能使用。（在使用*connect()*与数据报套接字 with Datagram Sockets")中，我们将看到数据报套接字可以互相连接，但这与连接的流套接字语义上有所不同。）

在互联网域中，数据报套接字使用用户数据报协议（UDP），而流套接字（通常）使用传输控制协议（TCP）。我们通常使用*UDP 套接字*和*TCP 套接字*这两个术语，而不是使用*互联网域数据报套接字*和*互联网域流套接字*。

#### 套接字系统调用

关键的套接字系统调用如下：

+   *socket()*系统调用创建一个新的套接字。

+   *bind()*系统调用将套接字绑定到一个地址。通常，服务器使用此调用将其套接字绑定到一个知名地址，以便客户端可以定位该套接字。

+   *listen()*系统调用允许流套接字接受来自其他套接字的传入连接。

+   *accept()*系统调用接受监听流套接字上来自对等应用程序的连接，并可选择返回对等套接字的地址。

+   *connect()*系统调用与另一个套接字建立连接。

### 注意

在大多数 Linux 架构上（例外包括 Alpha 和 IA-64），所有套接字系统调用实际上都是通过单个系统调用*socketcall()*复用的库函数实现的（这是 Linux 套接字实现作为单独项目的原始开发遗留的结果）。尽管如此，在本书中我们将所有这些函数称为系统调用，因为这是它们在原始 BSD 实现中以及许多其他当代 UNIX 实现中的称呼。

可以使用传统的*read()*和*write()*系统调用执行套接字 I/O，也可以使用一系列特定于套接字的系统调用（例如*send()*、*recv()*、*sendto()*和*recvfrom()*）。默认情况下，如果 I/O 操作无法立即完成，这些系统调用将阻塞。也可以通过使用*fcntl()*的`F_SETFL`操作（打开文件状态标志）来启用`O_NONBLOCK`打开文件状态标志来进行非阻塞 I/O。

### 注意

在 Linux 上，我们可以调用*ioctl(fd, FIONREAD, &cnt)*来获取由文件描述符*fd*引用的流套接字上的未读字节数。对于数据报套接字，此操作返回下一个未读数据报中的字节数（如果下一个数据报长度为零，则可能为零），如果没有待处理的数据报则返回零。此功能未在 SUSv3 中指定。

## 创建套接字：*socket()*

*socket()*系统调用创建一个新的套接字。

```
#include <sys/socket.h>

int `socket`(int *domain*, int *type*, int *protocol*);
```

### 注意

成功时返回文件描述符，出错时返回-1。

*domain*参数指定套接字的通信域。*type*参数指定套接字类型。此参数通常指定为`SOCK_STREAM`，以创建流套接字，或指定为`SOCK_DGRAM`，以创建数据报套接字。

*protocol*参数对于本书中描述的套接字类型总是指定为 0。非零的*protocol*值用于我们不描述的某些套接字类型。例如，对于原始套接字（`SOCK_RAW`），*protocol*指定为`IPPROTO_RAW`。

成功时，*socket()*返回用于在后续系统调用中引用新创建套接字的文件描述符。

### 注意

从内核 2.6.27 开始，Linux 为 *type* 参数提供了第二种用途，允许两个非标准标志与套接字类型进行按位或操作。`SOCK_CLOEXEC` 标志使内核为新的文件描述符启用关闭时执行标志（`FD_CLOEXEC`）。这个标志的作用与 *open()* 中的 `O_CLOEXEC` 标志相同，详见文件描述符号返回值 *open()*")。SOCK_NONBLOCK 标志使内核为底层的打开文件描述符设置 `O_NONBLOCK` 标志，这样对套接字的未来 I/O 操作将变为非阻塞。这样就避免了额外调用 *fcntl()* 来实现相同的效果。

## 将套接字绑定到地址：*bind()*

*bind()* 系统调用将一个套接字绑定到一个地址。

```
#include <sys/socket.h>

int `bind`(int *sockfd*, const struct sockaddr **addr*, socklen_t *addrlen*);
```

### 注意

成功时返回 0，出错时返回 -1

*sockfd* 参数是通过之前调用 *socket()* 获取的文件描述符。*addr* 参数是指向结构体的指针，该结构体指定了此套接字要绑定的地址。传入该参数的结构体类型取决于套接字的域。*addrlen* 参数指定地址结构的大小。*socklen_t* 数据类型用于 *addrlen* 参数，是由 SUSv3 指定的整数类型。

通常，我们将服务器的套接字绑定到一个著名地址——也就是说，绑定到一个客户端应用程序提前知道的固定地址，这样客户端才能与服务器进行通信。

### 注意

除了将服务器的套接字绑定到一个著名地址外，还有其他选择。例如，对于一个互联网域套接字，服务器可以省略对 *bind()* 的调用，直接调用 *listen()*，这会使内核为该套接字选择一个临时端口。（我们在端口号中描述了临时端口。）然后，服务器可以使用 *getsockname()*（获取套接字地址）来检索其套接字的地址。在这种情况下，服务器必须发布该地址，以便客户端能够找到服务器的套接字。此类发布可以通过将服务器地址注册到一个集中的目录服务应用程序来实现，客户端可以联系该服务来获取地址。（例如，Sun RPC 使用其 *portmapper* 服务器来解决这个问题。）当然，目录服务应用程序的套接字必须位于一个著名地址。

## 通用套接字地址结构：*struct sockaddr*

*bind()*的*addr*和*addrlen*参数需要进一步解释。查看表 56-1，我们可以看到每个套接字域使用不同的地址格式。例如，UNIX 域套接字使用路径名，而互联网域套接字使用 IP 地址加端口号的组合。对于每个套接字域，定义了不同的结构类型来存储套接字地址。然而，由于像*bind()*这样的系统调用是通用的，适用于所有套接字域，因此它们必须能够接受任何类型的地址结构。为了实现这一点，套接字 API 定义了一个通用的地址结构*struct sockaddr*。该类型的唯一目的是将各种特定领域的地址结构转换为单一类型，以便在套接字系统调用中作为参数使用。*sockaddr*结构通常定义如下：

```
struct sockaddr {
    sa_family_t sa_family;          /* Address family (AF_* constant) */
    char        sa_data[14];        /* Socket address (size varies
                                       according to socket domain) */
};
```

这个结构作为所有特定领域地址结构的模板。每个地址结构都以*family*字段开始，该字段对应于*sockaddr*结构中的*sa_family*字段。（*sa_family_t*数据类型是 SUSv3 中指定的整数类型。）*family*字段中的值足以确定结构中其余部分存储的地址的大小和格式。

### 注意

一些 UNIX 实现还在*sockaddr*结构中定义了一个附加字段*sa_len*，该字段指定了结构的总大小。SUSv3 并不要求此字段，而且在 Linux 实现的套接字 API 中并不存在该字段。

如果我们定义了`_GNU_SOURCE`特性测试宏，那么*glibc*会使用*gcc*扩展原型化各种套接字系统调用，在`<sys/socket.h>`中消除了*(struct sockaddr *)*类型转换的需要。然而，依赖于此特性是不可移植的（它会在其他系统上产生编译警告）。

## 流式套接字

流式套接字的操作可以通过与电话系统类比来解释：

1.  *socket()*系统调用用于创建一个套接字，相当于安装一部电话。为了让两个应用程序能够通信，每个应用程序都必须创建一个套接字。

1.  通过流式套接字的通信类似于电话通话。一个应用程序必须将它的套接字连接到另一个应用程序的套接字，才能进行通信。两个套接字的连接方式如下：

    1.  一个应用程序调用*bind()*来将套接字绑定到一个已知地址，然后调用*listen()*通知内核它愿意接受传入的连接。这个步骤类似于拥有一个已知的电话号码，并确保我们的电话处于开启状态，以便别人可以给我们打电话。

    1.  另一个应用程序通过调用*connect()*建立连接，指定要连接的套接字地址。这相当于拨打某人的电话号码。

    1.  调用*listen()*的应用程序随后使用*accept()*接受连接。这类似于接起电话当它响起。如果*accept()*在对端应用程序调用*connect()*之前执行，那么*accept()*会阻塞（“在电话旁等”）。

1.  一旦建立了连接，数据可以在两个应用程序之间双向传输（类似于双向电话交谈），直到其中一个通过*close()*关闭连接。通信可以通过传统的*read()*和*write()*系统调用进行，或者通过一些特定于套接字的系统调用（如*send()*和*recv()*）来提供额外的功能。

图 56-1 展示了流套接字使用的系统调用。

#### 主动套接字和被动套接字

流套接字通常被区分为主动套接字和被动套接字：

+   默认情况下，通过*socket()*创建的套接字是*主动*的。主动套接字可以在*connect()*调用中用于与被动套接字建立连接。这称为执行*主动打开*。

+   一个*被动*套接字（也叫*监听*套接字）是通过调用*listen()*标记为允许传入连接的套接字。接受传入连接的过程称为执行*被动打开*。

在大多数使用流套接字的应用程序中，服务器执行被动打开，客户端执行主动打开。我们在后续章节中假定这种场景，因此我们会经常说“客户端”而不是“执行主动套接字打开的应用程序”。同样，我们将“服务器”与“执行被动套接字打开的应用程序”视为等同。

![流套接字使用的系统调用概览](img/56-1_SOCKINTRO-stream-overview-scale90.png.jpg)图 56-1. 流套接字使用的系统调用概览

### 监听传入连接：*listen()*

*listen()*系统调用将由文件描述符*sockfd*引用的流套接字标记为*被动*。该套接字随后将用于接受来自其他（主动）套接字的连接。

```
#include <sys/socket.h>

int `listen`(int *sockfd*, int *backlog*);
```

### 注意

成功时返回 0，错误时返回 -1

我们不能将*listen()*应用于一个已连接的套接字——即，已经成功执行过*connect()*的套接字，或者是通过*accept()*调用返回的套接字。

为了理解*backlog*参数的目的，我们首先观察到客户端可能会在服务器调用*accept()*之前调用*connect()*。例如，这种情况可能发生在服务器忙于处理其他客户端时。这就导致了一个*待处理连接*，如图 56-2 所示。

![待处理的套接字连接](img/56-2_SOCKINTRO-unaccepted-connect-scale90.png.jpg)图 56-2. 待处理的套接字连接

内核必须记录每个待处理连接请求的一些信息，以便后续的 *accept()* 调用能够处理该请求。*backlog* 参数允许我们限制待处理连接的数量。直到此限制的连接请求会立即成功。（对于 TCP 套接字，情况稍微复杂一些，正如我们在 TCP 连接建立 中将看到的。）更多的连接请求会被阻塞，直到一个待处理连接被接受（通过 *accept()*），从而将其从待处理连接队列中移除。

SUSv3 允许实现对 *backlog* 参数指定的值施加上限，并允许实现将 *backlog* 值默默地向下舍入到这个上限。SUSv3 规定实现应通过在 `<sys/socket.h>` 中定义常量 `SOMAXCONN` 来声明这一限制。在 Linux 上，这个常量的值为 128。然而，自内核版本 2.4.25 起，Linux 允许通过 Linux 特定的 `/proc/sys/net/core/somaxconn` 文件在运行时调整这个上限。（在早期内核版本中，`SOMAXCONN` 限制是不可变的。）

### 注意

在原始的 BSD 套接字实现中，*backlog* 的上限为 5，且我们可能会在旧代码中看到这个值。所有现代实现都允许更高的 *backlog* 值，这对于使用 TCP 套接字的网络服务器来说是必要的，以便服务大量客户端。

### 接受连接：*accept()*

*accept()* 系统调用接受通过文件描述符 *sockfd* 引用的监听流套接字上的传入连接。如果在调用 *accept()* 时没有待处理的连接，请求会被阻塞，直到有连接请求到达。

```
#include <sys/socket.h>

int `accept`(int *sockfd*, struct sockaddr **addr*, socklen_t **addrlen*);
```

### 注意

成功时返回文件描述符，出错时返回 -1

理解 *accept()* 的关键点是，它创建了一个*新的*套接字，并且正是这个新套接字与执行了 *connect()* 的对等方套接字建立了连接。连接的套接字的文件描述符作为 *accept()* 调用的返回结果返回。监听套接字 (*sockfd*) 保持打开状态，可以用来接受进一步的连接。一个典型的服务器应用会创建一个监听套接字，将其绑定到一个已知的地址，然后通过该套接字处理所有客户端请求。

*accept()* 的其余参数返回对等方套接字的地址。*addr* 参数指向一个结构，用于返回套接字地址。该参数的类型取决于套接字域（如同 *bind()*）。

*addrlen* 参数是一个值-结果参数。它指向一个整数，在调用之前，必须初始化为 *addr* 所指向的缓冲区的大小，以便内核知道可用空间的大小以返回套接字地址。在从 *accept()* 返回时，这个整数会被设置为实际复制到缓冲区的数据字节数。

如果我们不关心对等套接字的地址，则应将*addr*和*addrlen*分别指定为`NULL`和 0。（如果需要，我们可以稍后使用*getpeername()*系统调用获取对等地址，如第 61.5 节所述。）

### 注意

从内核版本 2.6.28 开始，Linux 支持一种新的非标准系统调用，*accept4()*。该系统调用执行与*accept()*相同的任务，但支持一个额外的参数*flags*，可以用来修改系统调用的行为。支持两个标志：`SOCK_CLOEXEC`和`SOCK_NONBLOCK`。`SOCK_CLOEXEC`标志使内核为由该调用返回的新文件描述符启用 close-on-exec 标志（`FD_CLOEXEC`）。该标志与在*open()*返回的文件描述符编号返回的文件描述符编号")中描述的*open()* `O_CLOEXEC`标志有相同的作用。`SOCK_NONBLOCK`标志使内核在底层打开的文件描述上启用`O_NONBLOCK`标志，从而使套接字的未来 I/O 操作为非阻塞。这避免了多次调用*fcntl()*来实现相同的效果。

### 连接到对等套接字：*connect()*

*connect()*系统调用将由文件描述符*sockfd*引用的活动套接字连接到由*addr*和*addrlen*指定的监听套接字。

```
#include <sys/socket.h>

int `connect`(int *sockfd*, const struct sockaddr **addr*, socklen_t *addrlen*);
```

### 注意

成功时返回 0，错误时返回-1

*addr*和*addrlen*参数的指定方式与*bind()*的相应参数相同。

如果*connect()*失败，并且我们希望重新尝试连接，那么 SUSv3 指定的便捷方法是关闭套接字，创建一个新套接字，并使用新套接字重新尝试连接。

### 流套接字的 I/O

一对连接的流套接字提供了一个在两个端点之间的双向通信通道。图 56-3 展示了在 UNIX 域中这种结构的样子。

![UNIX 域流套接字提供双向通信通道](img/56-3_SOCKINTRO-unix-connected-scale90.png.jpg)图 56-3. UNIX 域流套接字提供双向通信通道

连接流套接字的 I/O 语义类似于管道的 I/O：

+   要执行 I/O 操作，我们使用*read()*和*write()*系统调用（或特定于套接字的*send()*和*recv()*，这些我们在套接字特定的 I/O 系统调用：*recv()*和*send()*和 send()")中描述）。由于套接字是双向的，因此可以在连接的两端使用这两种调用。

+   可以使用*close()*系统调用关闭套接字，或者由于应用程序终止而关闭套接字。之后，当对端应用程序尝试从连接的另一端读取数据时，它会收到文件结束标志（当所有缓冲数据已被读取时）。如果对端应用程序尝试向其套接字写入数据，则会收到`SIGPIPE`信号，系统调用将以`EPIPE`错误失败。如我们在创建和使用管道中所述，通常处理这种情况的方法是忽略`SIGPIPE`信号，并通过`EPIPE`错误获知连接已关闭。

### 连接终止：*close()*

终止流套接字连接的通常方法是调用*close()*。如果多个文件描述符引用同一个套接字，则当所有描述符关闭时，连接将被终止。

假设在我们关闭连接后，对端应用程序崩溃或未能正确读取或处理我们之前发送的数据。在这种情况下，我们无法知道发生了错误。如果我们需要确保数据已成功读取和处理，那么我们必须在应用程序中构建某种类型的确认协议。通常，这包括从对端返回的显式确认消息。

在*shutdown()*系统调用 系统调用")中，我们描述了*shutdown()*系统调用，它提供了更精细的控制方式，来关闭流套接字连接。

## 数据报套接字

数据报套接字的操作可以通过与邮政系统的类比来解释：

1.  *socket()*系统调用相当于设置一个邮箱。（这里，我们假设一个类似某些国家农村邮政服务的系统，它既能从邮箱中取信，也能将信投递到邮箱。）每个想要发送或接收数据报的应用程序都使用*socket()*创建一个数据报套接字。

1.  为了让另一个应用程序发送数据报（信件）到该应用程序，应用程序使用*bind()*将其套接字绑定到一个知名地址。通常，服务器将其套接字绑定到一个知名地址，而客户端则通过向该地址发送数据报来启动通信。（在某些领域——特别是 UNIX 领域——如果客户端希望接收服务器发送的数据报，它可能也需要使用*bind()*为其套接字分配一个地址。）

1.  要发送数据报，应用程序调用*sendto()*，它的一个参数是数据报将被发送到的套接字地址。这类似于在信件上写上收件人的地址并邮寄出去。

1.  为了接收数据报，应用程序调用*recvfrom()*，如果没有数据报到达，它可能会阻塞。因为*recvfrom()*允许我们获取发送方的地址，我们可以根据需要发送回复。（如果发送方的套接字绑定到一个不常见的地址，这通常发生在客户端中，便非常有用。）这里我们稍微扩展了一下类比，因为没有要求投递的信件上必须标明发送方的地址。

1.  当不再需要套接字时，应用程序使用*close()*关闭它。

就像邮政系统一样，当从一个地址发送多个数据报（信件）到另一个地址时，并不能保证它们按发送顺序到达，甚至可能完全无法到达。数据报还增加了邮政系统中不存在的一种可能性：由于底层的网络协议有时会重新传输数据包，同一个数据报可能会到达多次。

图 56-4 展示了与数据报套接字一起使用的系统调用。

![使用数据报套接字的系统调用概览](img/56-4_SOCKINTRO-datagram-overview-scale90.png.jpg)图 56-4. 使用数据报套接字的系统调用概览

### 交换数据报：*recvfrom()*和*sendto()*

*recvfrom()*和*sendto()*系统调用用于在数据报套接字上接收和发送数据报。

```
#include <sys/socket.h>

ssize_t `recvfrom`(int *sockfd*, void **buffer*, size_t *length*, int *flags*,
                 struct sockaddr **src_addr*, socklen_t **addrlen*);
```

### 注意

返回接收到的字节数，EOF 时返回 0，错误时返回-1。

```
ssize_t `sendto`(int *sockfd*, const void **buffer*, size_t *length*, int *flags*,
               const struct sockaddr **dest_addr*, socklen_t *addrlen*);
```

### 注意

返回发送的字节数，错误时返回-1。

这些系统调用的返回值和前三个参数与*read()*和*write()*相同。

第四个参数*flags*是一个位掩码，用于控制特定于套接字的 I/O 特性。我们将在第 61.3 节描述*recv()*和*send()*系统调用时详细介绍这些特性。如果不需要这些特性，可以将*flags*指定为 0。

*src_addr*和*addrlen*参数用于获取或指定与我们通信的对等方套接字的地址。

对于*recvfrom()*，*src_addr*和*addrlen*参数返回用于发送数据报的远程套接字地址。（这些参数类似于*accept()*的*addr*和*addrlen*参数，后者返回连接的对等方套接字的地址。）*src_addr*参数是指向适用于通信域的地址结构的指针。与*accept()*一样，*addrlen*是一个值结果参数。在调用之前，*addrlen*应初始化为*src_addr*所指向结构的大小；返回时，它包含实际写入该结构的字节数。

如果我们不关心发送方的地址，那么我们可以将*src_addr*和*addrlen*都指定为`NULL`。在这种情况下，*recvfrom()*等同于使用*recv()*接收数据报。我们也可以使用*read()*来读取数据报，这等同于使用*recv()*并将*flags*参数设置为 0。

无论 *length* 的值指定为何，*recvfrom()* 都会从数据报套接字中检索到一个消息。如果该消息的大小超过 *length* 字节，消息会被默默地截断为 *length* 字节。

### 注意

如果我们使用 *recvmsg()* 系统调用（*sendmsg()* 和 *recvmsg()* 系统调用 and recvmsg() System Calls")），则可以通过返回的 *msghdr* 结构中的 *msg_flags* 字段中的 `MSG_TRUNC` 标志来得知一个被截断的数据报。详细信息请参见 *recvmsg(2)* 手册页。

对于 *sendto()*，*dest_addr* 和 *addrlen* 参数指定要发送数据报的套接字。这些参数的使用方式与 *connect()* 的对应参数相同。*dest_addr* 参数是一个适用于此通信域的地址结构。它初始化为目标套接字的地址。*addrlen* 参数指定 *addr* 的大小。

### 注意

在 Linux 上，使用 *sendto()* 可以发送长度为 0 的数据报。然而，并不是所有 UNIX 实现都允许这样做。

### 使用 *connect()* 与数据报套接字

即使数据报套接字是无连接的，*connect()* 系统调用在应用于数据报套接字时仍然有其作用。在数据报套接字上调用 *connect()* 会导致内核记录一个特定的地址作为该套接字的对等方。此时，称该套接字为 *连接数据报套接字*。对于未调用 *connect()* 的数据报套接字（即新建数据报套接字的默认状态），则称其为 *未连接数据报套接字*。

在数据报套接字连接后：

+   可以通过套接字使用 *write()*（或 *send()*）发送数据报，并且数据会自动发送到同一对等方套接字。与 *sendto()* 一样，每次调用 *write()* 都会生成一个独立的数据报。

+   只有通过对等方套接字发送的数据报可以在该套接字上读取。

请注意，*connect()* 对数据报套接字的作用是非对称的。上述语句仅适用于调用了 *connect()* 的套接字，而不适用于其连接的远程套接字（除非对等方应用程序也在其套接字上调用了 *connect()*）。

我们可以通过发出进一步的 *connect()* 调用来更改已连接数据报套接字的对等方。还可以通过指定一个地址结构，在该结构中地址族（例如 UNIX 域中的 *sun_family* 字段）指定为 `AF_UNSPEC`，完全解除对等方关联。然而，请注意，许多其他 UNIX 实现不支持将 `AF_UNSPEC` 用于此目的。

### 注意

SUSv3 对解除对等方关联的描述较为模糊，指出可以通过调用指定“空地址”的 *connect()* 来重置连接，但没有定义该术语。SUSv4 明确指定了使用 `AF_UNSPEC`。

设置 datagram 套接字的对等地址的明显优势是，在通过套接字传输数据时，我们可以使用更简单的 I/O 系统调用。我们不再需要使用带有 *dest_addr* 和 *addrlen* 参数的 *sendto()*，而可以使用 *write()*。设置对等地址主要用于需要向单个对等体发送多个 datagram 的应用程序（这在某些 datagram 客户端中很常见）。

### 注意

在某些 TCP/IP 实现中，将 datagram 套接字连接到对等体可以提高性能（[Stevens et al., 2004]）。在 Linux 上，连接 datagram 套接字对性能几乎没有影响。

## 总结

套接字允许同一主机或通过网络连接的不同主机之间进行通信。

套接字存在于一个通信域内，该域决定了通信的范围和用于标识套接字的地址格式。SUSv3 定义了 UNIX（`AF_UNIX`）、IPv4（`AF_INET`）和 IPv6（`AF_INET6`）通信域。

大多数应用程序使用两种套接字类型之一：流套接字或 datagram 套接字。流套接字（`SOCK_STREAM`）提供一个可靠的、双向的字节流通信通道，连接两个端点。Datagram 套接字（`SOCK_DGRAM`）提供不可靠的、无连接的、面向消息的通信。

一个典型的流套接字服务器使用 *socket()* 创建套接字，然后使用 *bind()* 将套接字绑定到一个知名地址。服务器接着调用 *listen()* 来允许接收连接。每个客户端连接随后通过 *accept()* 在监听套接字上被接受，该调用返回一个文件描述符，该描述符对应一个与客户端套接字连接的新套接字。一个典型的流套接字客户端使用 *socket()* 创建一个套接字，然后通过调用 *connect()* 建立连接，指定服务器的知名地址。两者的流套接字连接后，可以使用 *read()* 和 *write()* 双向传输数据。一旦所有引用流套接字端点的文件描述符的进程都执行了隐式或显式的 *close()*，连接就会终止。

一个典型的 datagram 套接字服务器使用 *socket()* 创建一个套接字，然后使用 *bind()* 将其绑定到一个知名地址。由于 datagram 套接字是无连接的，服务器的套接字可以用来接收来自任何客户端的 datagram。可以通过 *read()* 或使用特定于套接字的 *recvfrom()* 系统调用来接收 datagram，后者返回发送套接字的地址。一个 datagram 套接字客户端使用 *socket()* 创建一个套接字，然后使用 *sendto()* 向指定的（即服务器的）地址发送 datagram。*connect()* 系统调用可以与 datagram 套接字一起使用，为套接字设置对等地址。完成此操作后，不再需要为传出的 datagram 指定目标地址；可以使用 *write()* 调用发送 datagram。

#### 进一步的信息

请参考进一步信息中列出的相关资料来源。
