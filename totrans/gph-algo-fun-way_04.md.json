["```\ndef check_node_path_valid(g: Graph, path: list) -> bool: \n    num_nodes_on_path: int = len(path)\n  ❶ if num_nodes_on_path == 0:\n        return True\n  ❷ prev_node: int = path[0]\n    if prev_node < 0 or prev_node >= g.num_nodes:\n        return False for step in range(1, num_nodes_on_path):\n        next_node: int = path[step]\n      ❸ if not g.is_edge(prev_node, next_node):\n            return False\n      ❹ prev_node = next_node\n    return True \n```", "```\ndef check_edge_path_valid(g: Graph, path: list) -> bool: \n  ❶ if len(path) == 0:\n        return True\n\n  ❷ prev_node: int = path[0].from_node\n    if prev_node < 0 or prev_node >= g.num_nodes:\n        return False\n\n    for edge in path:\n      ❸ if edge.from_node != prev_node:\n            return False\n\n        next_node: int = edge.to_node\n        if not g.is_edge(prev_node, next_node):\n            return False\n\n        prev_node = next_node\n    return True \n```", "```\ndef make_node_path_from_last(last: list, dest: int) -> list: \n  ❶ reverse_path: list = []\n    current: int = dest\n\n  ❷ while current != -1:\n        reverse_path.append(current)\n      ❸ current = last[current] ❹ path: list = list(reversed(reverse_path))\n    return path \n```", "```\ndef check_last_path_valid(g: Graph, last: list) -> bool: \n  ❶ if len(last) != g.num_nodes:\n        return False\n\n    for to_node, from_node in enumerate(last):\n      ❷ if from_node != -1 and not g.is_edge(from_node, to_node):\n            return False\n    return True \n```", "```\ndef compute_path_cost_from_edges(path: list) -> float: \n  ❶ if len(path) == 0:\n        return 0.0\n\n    cost: float = 0.0\n    prev_node: int = path[0].from_node\n    for edge in path:\n      ❷ if edge.from_node != prev_node:\n            cost = math.inf\n        else:\n            cost = cost + edge.weight\n        prev_node = edge.to_node\n\n    return cost \n```"]