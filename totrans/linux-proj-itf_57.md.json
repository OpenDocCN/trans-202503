["```\nstruct sockaddr_un {\n    sa_family_t sun_family;         /* Always AF_UNIX */\n    char sun_path[108];             /* Null-terminated socket pathname */\n};\n```", "```\nconst char *SOCKNAME = \"/tmp/mysock\";\n    int sfd;\n    struct sockaddr_un addr;\n\n    sfd = socket(AF_UNIX, SOCK_STREAM, 0);            /* Create socket */\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    memset(&addr, 0, sizeof(struct sockaddr_un));     /* Clear structure */\n    addr.sun_family = AF_UNIX;                            /* UNIX domain address */\n    strncpy(addr.sun_path, SOCKNAME, sizeof(addr.sun_path) - 1);\n\n    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1)\n        errExit(\"bind\");\n```", "```\n`sockets/us_xfr.h`\n#include <sys/un.h>\n#include <sys/socket.h>\n#include \"tlpi_hdr.h\"\n\n#define SV_SOCK_PATH \"/tmp/us_xfr\"\n\n#define BUF_SIZE 100\n      `sockets/us_xfr.h`\n```", "```\n`sockets/us_xfr_sv.c`\n#include \"us_xfr.h\"\n\n#define BACKLOG 5\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_un addr;\n    int sfd, cfd;\n    ssize_t numRead;\n    char buf[BUF_SIZE];\n\n    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    /* Construct server socket address, bind socket to it,\n       and make this a listening socket */\n\n    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT)\n        errExit(\"remove-%s\", SV_SOCK_PATH);\n\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);\n\n    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1)\n        errExit(\"bind\");\n\n    if (listen(sfd, BACKLOG) == -1)\n        errExit(\"listen\");\n\n    for (;;) {          /* Handle client connections iteratively */\n\n        /* Accept a connection. The connection is returned on a new\n           socket, 'cfd'; the listening socket ('sfd') remains open\n           and can be used to accept further connections. */\n\n        cfd = accept(sfd, NULL, NULL);\n        if (cfd == -1)\n            errExit(\"accept\");\n\n        /* Transfer data from connected socket to stdout until EOF */\n\n        while ((numRead = read(cfd, buf, BUF_SIZE)) > 0)\n            if (write(STDOUT_FILENO, buf, numRead) != numRead)\n                fatal(\"partial/failed write\");\n\n        if (numRead == -1)\n            errExit(\"read\");\n        if (close(cfd) == -1)\n            errMsg(\"close\");\n    }\n}\n     `sockets/us_xfr_sv.c`\n```", "```\n`sockets/us_xfr_cl.c`\n#include \"us_xfr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_un addr;\n    int sfd;\n    ssize_t numRead;\n    char buf[BUF_SIZE];\n\n    sfd = socket(AF_UNIX, SOCK_STREAM, 0);       /* Create client socket */\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    /* Construct server address, and make the connection */\n\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);\n\n    if (connect(sfd, (struct sockaddr *) &addr,\n                sizeof(struct sockaddr_un)) == -1)\n        errExit(\"connect\");\n\n    /* Copy stdin to socket */\n\n    while ((numRead = read(STDIN_FILENO, buf, BUF_SIZE)) > 0)\n        if (write(sfd, buf, numRead) != numRead)\n            fatal(\"partial/failed write\");\n\n    if (numRead == -1)\n        errExit(\"read\");\n\n    exit(EXIT_SUCCESS);         /* Closes our socket; server sees EOF */\n}\n     `sockets/us_xfr_cl.c`\n```", "```\n$ `./us_xfr_sv > b &`\n[1] 9866\n$ `ls -lF /tmp/us_xfr`                        *Examine socket file with ls*\nsrwxr-xr-x    1 mtk      users         0 Jul 18 10:48 /tmp/us_xfr=\n```", "```\n$ `cat *.c > a`\n$ `./us_xfr_cl < a`                           *Client takes input from test file*\n```", "```\n$ `kill %1`                                   *Terminate server*\n [1]+  Terminated   ./us_xfr_sv >b          *Shell sees serverâ€™s termination*\n$ `diff a b`\n$\n```", "```\n`sockets/ud_ucase.h`\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <ctype.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 10             /* Maximum size of messages exchanged\n                                   between client to server */\n\n#define SV_SOCK_PATH \"/tmp/ud_ucase\"\n     `sockets/ud_ucase.h`\n```", "```\n`sockets/ud_ucase_sv.c`\n#include \"ud_ucase.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_un svaddr, claddr;\n    int sfd, j;\n    ssize_t numBytes;\n    socklen_t len;\n    char buf[BUF_SIZE];\n\n    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /* Create server socket */\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    /* Construct well-known address and bind server socket to it */\n\n    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT)\n        errExit(\"remove-%s\", SV_SOCK_PATH);\n\n    memset(&svaddr, 0, sizeof(struct sockaddr_un));\n    svaddr.sun_family = AF_UNIX;\n    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);\n\n    if (bind(sfd, (struct sockaddr *) &svaddr, sizeof(struct sockaddr_un)) == -1)\n        errExit(\"bind\");\n\n    /* Receive messages, convert to uppercase, and return to client */\n\n    for (;;) {\n        len = sizeof(struct sockaddr_un);\n        numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,\n                            (struct sockaddr *) &claddr, &len);\n        if (numBytes == -1)\n            errExit(\"recvfrom\");\n\n        printf(\"Server received %ld bytes from %s\\n\", (long) numBytes,\n                claddr.sun_path);\n\n        for (j = 0; j < numBytes; j++)\n            buf[j] = toupper((unsigned char) buf[j]);\n\n        if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &claddr, len) !=\n                numBytes)\n            fatal(\"sendto\");\n    }\n}\n      `sockets/ud_ucase_sv.c`\n```", "```\n`sockets/ud_ucase_cl.c`\n#include \"ud_ucase.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_un svaddr, claddr;\n    int sfd, j;\n    size_t msgLen;\n    ssize_t numBytes;\n    char resp[BUF_SIZE];\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s msg...\\n\", argv[0]);\n\n    /* Create client socket; bind to unique pathname (based on PID) */\n\n    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    memset(&claddr, 0, sizeof(struct sockaddr_un));\n    claddr.sun_family = AF_UNIX;\n    snprintf(claddr.sun_path, sizeof(claddr.sun_path),\n            \"/tmp/ud_ucase_cl.%ld\", (long) getpid());\n\n    if (bind(sfd, (struct sockaddr *) &claddr, sizeof(struct sockaddr_un)) == -1)\n        errExit(\"bind\");\n\n    /* Construct address of server */\n\n    memset(&svaddr, 0, sizeof(struct sockaddr_un));\n    svaddr.sun_family = AF_UNIX;\n    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);\n\n    /* Send messages to server; echo responses on stdout */\n\n    for (j = 1; j < argc; j++) {\n        msgLen = strlen(argv[j]);       /* May be longer than BUF_SIZE */\n        if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &svaddr,\n                sizeof(struct sockaddr_un)) != msgLen)\n            fatal(\"sendto\");\n\n        numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);\n        if (numBytes == -1)\n            errExit(\"recvfrom\");\n        printf(\"Response %d: %.*s\\n\", j, (int) numBytes, resp);\n    }\n\n    remove(claddr.sun_path);            /* Remove client socket pathname */\n    exit(EXIT_SUCCESS);\n}\n      `sockets/ud_ucase_cl.c`\n```", "```\n$ `./ud_ucase_sv &`\n[1] 20113\n$ `./ud_ucase_cl hello world`                 *Send 2 messages to server*\nServer received 5 bytes from /tmp/ud_ucase_cl.20150\nResponse 1: HELLO\nServer received 5 bytes from /tmp/ud_ucase_cl.20150\nResponse 2: WORLD\n$ `./ud_ucase_cl 'long message'`              *Send 1 longer message to server*\nServer received 10 bytes from /tmp/ud_ucase_cl.20151\nResponse 1: LONG MESSA\n$ `kill %1`                                   *Terminate server*\n```", "```\n#include <sys/socket.h>\n\nint `socketpair`(int *domain*, int *type*, int *protocol*, int *sockfd*[2]);\n```", "```\n*from* `sockets/us_abstract_bind.c`\n    struct sockaddr_un addr;\n\n    memset(&addr, 0, sizeof(struct sockaddr_un));  /* Clear address structure */\n    addr.sun_family = AF_UNIX;                     /* UNIX domain address */\n\n    /* addr.sun_path[0] has already been set to 0 by memset() */\n\n    str = \"xyz\";         /* Abstract name is \"\\0xyz\" */\n    strncpy(&addr.sun_path[1], str, strlen (str));\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (sockfd == -1)\n        errExit(\"socket\");\n\n    if (bind(sockfd, (struct sockaddr *) &addr,\n            sizeof(sa_family_t) + strlen(str) + 1) == -1)\n        errExit(\"bind\");\n                                                  *from* `sockets/us_abstract_bind.c`\n```", "```\nstrncpy(addr.sun_path, name, sizeof(addr.sun_path) - 1);\n```"]