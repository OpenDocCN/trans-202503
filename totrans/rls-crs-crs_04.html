<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Models"><div class="titlepage"><div><div><h1 class="title"><a id="models"/>Chapter 3. Models</h1></div></div></div><p><a class="indexterm" id="iddle1117"/><a class="indexterm" id="iddle1847"/><a class="indexterm" id="iddle1971"/>In Rails, models represent the data in your application and the rules to
        manipulate that data. Models manage interactions between your application and a
        corresponding database table. The bulk of your application’s business logic should
        also be in the models.</p><p>This chapter covers Active Record, the Rails component that provides model persistence
        (that is, storing data in the database), as well as data validations, database migrations,
        and model associations. <span class="emphasis"><em>Validations</em></span> are rules to ensure that only valid
        data is stored in the database. You create database <span class="emphasis"><em>migrations</em></span> to
        change the schema of the database, and <span class="emphasis"><em>associations</em></span> are relationships
        between multiple models in your application.</p><div class="sect1" title="The Post Model"><div class="titlepage"><div><div><h1 class="title"><a id="post_model"/>The Post Model</h1></div></div></div><p>In the previous chapter, we used the Rails scaffold generator to build a simple blog
          with models, views, and controllers for blog posts. Look at the post model created by the
          scaffold generator by opening the file <span class="emphasis"><em>app/models/post.rb</em></span> in your
          favorite text editor.</p><a id="pro_id00069"/><pre class="programlisting">class Post &lt; ActiveRecord::Base
end</pre><p><a class="indexterm" id="iddle1033"/><a class="indexterm" id="iddle1499"/><a class="indexterm" id="iddle1557"/><a class="indexterm" id="iddle1594"/><a class="indexterm" id="iddle1944"/><a class="indexterm" id="iddle1986"/><a class="indexterm" id="iddle2046"/>There’s not much to see here. Right now, the file just tells us that the
          class <code class="literal">Post</code> inherits from <code class="literal">ActiveRecord::Base</code>. Before
          I talk about what you can actually do with <code class="literal">Post</code>, let’s begin our
          discussion with Active Record.</p></div><div class="sect1" title="Active Record"><div class="titlepage"><div><div><h1 class="title"><a id="active_record"/>Active Record</h1></div></div></div><p><span class="emphasis"><em>Active Record</em></span> is an implementation of the object-relational
          mapping (ORM) pattern described, using the same name, by Martin Fowler in
            <span class="emphasis"><em>Patterns of Enterprise Application Architecture</em></span> (Addison-Wesley
          Professional, 2002). It’s an automated mapping between classes and tables as well as
          attributes and columns.</p><p>Each table in your database is represented by a class in your application. Each row of
          that table is represented by an instance (or object) of the associated class, and each
          column of that row is represented by an attribute of that object. The example in <a class="xref" href="ch03.html#posts_table" title="Table 3-1. The Posts Table">Table 3-1</a> demonstrates this structure. If you could look inside your
          database, this is what you would see.</p><div class="table"><a id="posts_table"/><p class="title">Table 3-1. The Posts Table</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="The Posts Table"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>id</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>title</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>body</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>created_at</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>updated_at</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Hello, World</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Welcome to my blog...</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>...</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>...</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>My Cat</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>The cutest kitty in the...</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>...</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>...</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>3</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>Too Busy</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>Sorry I haven’t posted...</p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>...</p></td><td style="" valign="top"><p>...</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch03.html#posts_table" title="Table 3-1. The Posts Table">Table 3-1</a> holds three example blog posts. This table is
          represented by the <code class="literal">Post</code> class. The post with an <code class="literal">id</code>
          of 1 can be represented by a <code class="literal">Post</code> object. Let’s call our object
            <code class="literal">post</code>.</p><p>You can access the data associated with a single column by calling an attribute method
          on the object. For example, to see the post’s title, call
            <code class="literal">post.title</code>. The ability to access and change database values by
          calling attribute methods on an object is known as <span class="emphasis"><em>direct
            manipulation</em></span>.</p></div><div class="sect1" title="Create, Read, Update, and Delete"><div class="titlepage"><div><div><h1 class="title"><a id="createcomma_readcomma_updatecomma_and_de"/>Create, Read, Update, and Delete</h1></div></div></div><p>Let’s explore Active Record further by entering a few commands in the Rails
          console. The Rails console is the IRB that you used in <a class="xref" href="ch01.html" title="Chapter 1. Ruby Fundamentals">Chapter 1</a>
          with your Rails application’s environment preloaded.</p><p>To start the Rails console, go to your <span class="emphasis"><em>blog</em></span> directory and enter
            <span class="strong"><strong><code class="literal">bin/rails console</code></strong></span>. You might
          notice that the console takes a little longer to start than the IRB. During that slight
          pause, your application’s environment is being loaded.</p><p>As with the IRB, you can enter <code class="literal">exit</code> to quit the console when
          you’re done.</p><p><a class="indexterm" id="iddle1397"/><a class="indexterm" id="iddle1406"/><a class="indexterm" id="iddle1432"/><a class="indexterm" id="iddle1433"/><a class="indexterm" id="iddle1752"/><a class="indexterm" id="iddle1903"/><a class="indexterm" id="iddle2070"/><a class="indexterm" id="iddle2183"/>The four major functions of database applications are
            <span class="emphasis"><em>create</em></span>, <span class="emphasis"><em>read</em></span>, <span class="emphasis"><em>update</em></span>, and
            <span class="emphasis"><em>delete</em></span>, usually abbreviated as <span class="emphasis"><em>CRUD</em></span>. Once you
          know how to perform these four actions, you can build any type of application you
          need.</p><p>Rails makes these actions easy for you. In most cases, you can accomplish each with a
          single line of code. Let’s use them now to work with posts on our blog.</p><div class="sect2" title="Create"><div class="titlepage"><div><div><h2 class="title"><a id="create"/>Create</h2></div></div></div><p>We’ll start by adding a few records to the database. Enter these commands in
            the Rails console as you work through this section. The remaining examples in this
            chapter use these records.</p><p>The easiest way to create a record in Rails is with the appropriately named
              <code class="literal">create</code> method, as shown here:</p><a id="pro_id00070"/><pre class="programlisting">  2.1.0 :001 &gt; <span class="strong"><strong>Post.create title: "First Post"</strong></span>
➊    (0.1ms) begin transaction
    SQL (0.4ms) INSERT INTO "posts" ("created_at"...
     (1.9ms) commit transaction
   =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;</pre><p>The Rails console displays the SQL being sent to the database as commands are run
            ➊. In the interest of brevity, I’m going to omit these SQL statements in
            the rest of the samples.</p><p>The <code class="literal">create</code> method accepts a hash of attribute-value pairs and
            inserts a record into the database with the appropriate values. In this case, it’s
            setting the <code class="literal">title</code> attribute to the value <code class="literal">"First
              Post"</code>. When you run this example, the values for <code class="literal">id</code>,
              <code class="literal">created_at</code>, and <code class="literal">updated_at</code> are set for you
            automatically. The <code class="literal">id</code> column is an auto-incrementing value in the
            database, whereas <code class="literal">created_at</code> and <code class="literal">updated_at</code> are
            timestamps set for you by Rails. The <code class="literal">body</code> column is set to NULL since
            no value was passed for it.</p><p>The <code class="literal">create</code> method is a shortcut for instantiating a new
              <code class="literal">Post</code> object, assigning values, and saving it to the database. If
            you don’t want to take the shortcut, you could also write a separate line of code
            for each action:</p><a id="pro_id00071"/><pre class="programlisting">2.1.0 :002 &gt; <span class="strong"><strong>post = Post.new</strong></span>
 =&gt; #&lt;Post id: nil, title: nil, ...&gt;
2.1.0 :003 &gt; <span class="strong"><strong>post.title = "Second Post"</strong></span>
 =&gt; "Second Post"
2.1.0 :004 &gt; <span class="strong"><strong>post.save</strong></span>
 =&gt; true</pre><p>We had to use multiple commands this time, but just like before, we’ve created
            a brand new <code class="literal">Post</code> object. Two posts are now stored in the database. In
            both examples, we only assigned values to the post’s <code class="literal">title</code>
            attribute, but you would assign values to the post <code class="literal">body</code> in exactly
            the same way. Rails assigns values to <code class="literal">id</code>,
              <code class="literal">created_at</code>, and <code class="literal">updated_at</code> automatically. You
            shouldn’t change these.</p></div><div class="sect2" title="Read"><div class="titlepage"><div><div><h2 class="title"><a id="read"/>Read</h2></div></div></div><p><a class="indexterm" id="iddle1038"/><a class="indexterm" id="iddle1040"/><a class="indexterm" id="iddle1051"/><a class="indexterm" id="iddle1166"/><a class="indexterm" id="iddle1569"/><a class="indexterm" id="iddle1571"/><a class="indexterm" id="iddle1709"/><a class="indexterm" id="iddle1790"/><a class="indexterm" id="iddle2068"/><a class="indexterm" id="iddle2335"/>Once you have a few posts in your database, you’ll probably want to
            read them back out for display. First, let’s look at all of the posts in the
            database with the <code class="literal">all</code> method:</p><a id="pro_id00072"/><pre class="programlisting">2.1.0 :005 &gt; <span class="strong"><strong>posts = Post.all</strong></span>
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Post id: 1, ...&gt;, #&lt;Post id: 2, ...&gt;]&gt;</pre><p>This returns an Active Record <span class="emphasis"><em>relation</em></span>, which contains an array
            of all posts in your database, and stores it in <code class="literal">posts</code>. You can chain
            additional methods onto this relation, and Active Record combines them into a single
            query.</p><p>Active Record also implements the <code class="literal">first</code> and
              <code class="literal">last</code> methods, which return the first and last entries in an array.
            The Active Record version of these methods returns only the first or last record in the
            database table. This is much more efficient than fetching all of the records in the
            table and then calling <code class="literal">first</code> or <code class="literal">last</code> on the array.
            Let’s try fetching a couple of posts from our database:</p><a id="pro_id00073"/><pre class="programlisting">2.1.0 :006 &gt; <span class="strong"><strong>Post.first</strong></span>
 =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;
2.1.0 :007 &gt; <span class="strong"><strong>Post.last</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;</pre><p>This example returns the first and last posts, as ordered by <code class="literal">id</code>.
            You’ll learn how to order records by a different field in the next section.
            Sometimes, however, you’ll know exactly which record you want, and it might not be
            the first or last one. In that case, you can use the <code class="literal">find</code> method to
            retrieve a record by <code class="literal">id</code>.</p><a id="pro_id00074"/><pre class="programlisting">2.1.0 :008 &gt; <span class="strong"><strong>post = Post.find 2</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;</pre><p>Just don’t ask <code class="literal">find</code> to fetch a record that doesn’t
            exist. If a record with the specified <code class="literal">id</code> isn’t in your
            database, Active Record will raise an <code class="literal">ActiveRecord::RecordNotFound</code>
            exception. When you know a specific record exists but you don’t know its
              <code class="literal">id</code>, you can use the <code class="literal">where</code> method to specify an
            attribute that you do know:</p><a id="pro_id00075"/><pre class="programlisting">2.1.0 :009 &gt; <span class="strong"><strong>post = Post.where(title: "First Post").first</strong></span>
 =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;</pre><p>The <code class="literal">where</code> method also returns a relation. If more than one record
            matches, you can chain the <code class="literal">all</code> method after <code class="literal">where</code>
            and tell Rails to retrieve all matching records on demand when they are needed.</p><p><a class="indexterm" id="iddle1479"/><a class="indexterm" id="iddle1489"/><a class="indexterm" id="iddle2072"/><a class="indexterm" id="iddle2073"/><a class="indexterm" id="iddle2279"/><a class="indexterm" id="iddle2284"/>If you know the database has only one matching record, you can chain the
              <code class="literal">first</code> method after <code class="literal">where</code> to retrieve that
            specific record as in the previous example. This pattern is so common that Active Record
            also provides the <code class="literal">find_by</code> method as a shortcut:</p><a id="pro_id00076"/><pre class="programlisting">2.1.0 :010 &gt; <span class="strong"><strong>post = Post.find_by title: "First Post"</strong></span>
 =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;</pre><p>This method takes a hash of attribute-value pairs and returns the first matching
            record.</p></div><div class="sect2" title="Update"><div class="titlepage"><div><div><h2 class="title"><a id="update"/>Update</h2></div></div></div><p>Updating a record is as easy as reading it into a variable, changing values via
            direct manipulation, and then saving it back to the database:</p><a id="pro_id00077"/><pre class="programlisting">2.1.0 :011 &gt; <span class="strong"><strong>post = Post.find 2</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;
2.1.0 :012 &gt; <span class="strong"><strong>post.title = "2nd Post"</strong></span>
 =&gt; "2nd Post"
2.1.0 :013 &gt; <span class="strong"><strong>post.save</strong></span>
 =&gt; true</pre><p>Rails also provides the <code class="literal">update</code> method, which takes a hash of
            attribute-value pairs, updates the record, and saves to the database all on one
            line:</p><a id="pro_id00078"/><pre class="programlisting">2.1.0 :014 &gt; <span class="strong"><strong>post = Post.find 2</strong></span>
 =&gt; #&lt;Post id: 2, title: "2nd Post", ...&gt;
2.1.0 :015 &gt; <span class="strong"><strong>post.update title: "Second Post"</strong></span>
 =&gt; true</pre><p>The <code class="literal">update</code> method, like the <code class="literal">save</code> method,
            returns <code class="literal">true</code> when successful or <code class="literal">false</code> if it has a
            problem saving the record.</p></div><div class="sect2" title="Delete"><div class="titlepage"><div><div><h2 class="title"><a id="delete"/>Delete</h2></div></div></div><p>Once you have read a record from the database, you can delete it with the
              <code class="literal">destroy</code> method. But this time don’t type in these commands.
            You don’t want to delete the posts you created earlier!</p><a id="pro_id00079"/><pre class="programlisting">2.1.0 :016 &gt; <span class="strong"><strong>post = Post.find 2</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;
2.1.0 :017 &gt; <span class="strong"><strong>post.destroy</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;</pre><p>The <code class="literal">destroy</code> method can also be called on the class to delete a
            record by <code class="literal">id</code>, which has the same effect as reading the record into a
            variable first:</p><a id="pro_id00080"/><pre class="programlisting">2.1.0 :018 &gt; <span class="strong"><strong>Post.destroy 2</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;</pre><p><a class="indexterm" id="iddle1037"/><a class="indexterm" id="iddle1167"/><a class="indexterm" id="iddle1486"/><a class="indexterm" id="iddle1800"/><a class="indexterm" id="iddle1906"/><a class="indexterm" id="iddle1918"/>You can also delete records based on a relation:</p><a id="pro_id00081"/><pre class="programlisting">2.1.0 :019 &gt; <span class="strong"><strong>Post.where(title: "First Post").destroy_all</strong></span>
 =&gt; [#&lt;Post id: 1, title: "First Post", ...&gt;]</pre><p>This example deletes all records with a title of <code class="literal">"First Post"</code>. Be
            careful with the <code class="literal">destroy_all</code> method, however. If you call it without
            a <code class="literal">where</code> clause, you’ll delete all records of the specified
            class!</p></div></div><div class="sect1" title="More Active Record Methods"><div class="titlepage"><div><div><h1 class="title"><a id="more_active_record_methods"/>More Active Record Methods</h1></div></div></div><p>If you’re familiar with SQL or other methods of accessing records in a database,
          you know there’s much more to working with a database than simple CRUD. Active
          Record provides methods for more database operations, such as ordering, limiting,
          counting, and other calculations.</p><div class="sect2" title="Query Conditions"><div class="titlepage"><div><div><h2 class="title"><a id="query_conditions"/>Query Conditions</h2></div></div></div><p>In addition to the simple <code class="literal">where</code> conditions you’ve seen so
            far, Active Record also has several methods to help refine your queries. The
              <code class="literal">order</code> method specifies the order of returned records;
              <code class="literal">limit</code> specifies how many records to return; and
              <code class="literal">offset</code> specifies the first record to return from a list.</p><p>The <code class="literal">limit</code> and <code class="literal">offset</code> methods are often used
            together for pagination. For example, if you want to show 10 blog posts per page, you
            can read the posts for the first page like this:</p><a id="pro_id00082"/><pre class="programlisting">2.1.0 :020 &gt; <span class="strong"><strong>posts = Post.limit(10)</strong></span>
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Post id: 1, ...&gt;, #&lt;Post id: 2, ...&gt;]&gt;</pre><p>To read the posts for the second page of your site, you’ll need to skip the
            first 10 posts:</p><a id="pro_id00083"/><pre class="programlisting">2.1.0 :021 &gt; <span class="strong"><strong>posts = Post.limit(10).offset(10)</strong></span>
 =&gt; #&lt;ActiveRecord::Relation []&gt;</pre><p>Entering this returns an empty set since we only have two posts in our database.
            When you combine <code class="literal">offset</code> with <code class="literal">limit</code> in this way,
            you can pass <code class="literal">offset</code> multiples of what you passed
              <code class="literal">limit</code> to view different pages of your blog.</p><p>You can also change how the entries in a relation are ordered. When using
              <code class="literal">limit</code>, the order of records returned is undefined, so you need to
            specify an order. With the <code class="literal">order</code> method, you can specify a different
            order for the set of records returned:</p><a id="pro_id00084"/><pre class="programlisting">2.1.0 :022 &gt; <span class="strong"><strong>posts = Post.limit(10).order "created_at DESC"</strong></span>
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Post id: 2, ...&gt;, #&lt;Post id: 1, ...&gt;]&gt;</pre><p>Using <code class="literal">DESC</code> tells <code class="literal">order</code> to return the posts
            from newest to oldest. You could also use <code class="literal">ASC</code> to order them the
            opposite way. If you would rather see <a class="indexterm" id="iddle1036"/><a class="indexterm" id="iddle1216"/><a class="indexterm" id="iddle1389"/><a class="indexterm" id="iddle1440"/><a class="indexterm" id="iddle1459"/><a class="indexterm" id="iddle1824"/><a class="indexterm" id="iddle1839"/><a class="indexterm" id="iddle1840"/><a class="indexterm" id="iddle2071"/><a class="indexterm" id="iddle2207"/>posts alphabetized by title, try replacing <code class="literal">"created_at
              DESC"</code> with <code class="literal">"title ASC"</code>. The <code class="literal">order</code>
            method defaults to ascending order if you don’t specify <code class="literal">ASC</code> or
              <code class="literal">DESC</code>, but I always give an order so my intention is clear.</p></div><div class="sect2" title="Calculations"><div class="titlepage"><div><div><h2 class="title"><a id="calculations"/>Calculations</h2></div></div></div><p>Databases also provide methods for performing calculations on records. We could read
            the records and perform these operations in Ruby, but the methods built in to the
            database are usually optimized to be faster and use less memory.</p><p>The <code class="literal">count</code> method returns the number of records matching a given
            condition:</p><a id="pro_id00085"/><pre class="programlisting">2.1.0 :023 &gt; <span class="strong"><strong>count = Post.count</strong></span>
 =&gt; 2</pre><p>If you don’t specify a condition, <code class="literal">count</code> counts all records
            by default, as in this example.</p><p>The <code class="literal">sum</code>, <code class="literal">average</code>, <code class="literal">minimum</code>,
            and <code class="literal">maximum</code> methods perform the requested function on a field. For
            example, this line of code finds and returns the date on the newest blog post:</p><a id="pro_id00086"/><pre class="programlisting">2.1.0 :024 &gt; <span class="strong"><strong>date = Post.maximum :created_at</strong></span>
 =&gt; 2014-03-12 04:10:08 UTC</pre><p>The maximum <code class="literal">created_at</code> date you see should match the date for
            your newest blog post, not necessarily the date you see in the example.</p></div></div><div class="sect1" title="Migrations"><div class="titlepage"><div><div><h1 class="title"><a id="migrations"/>Migrations</h1></div></div></div><p><span class="emphasis"><em>Database migrations</em></span> are used any time you need to change your
          database’s structure. When we used the scaffold generator to create blog posts, it
          generated a migration for us, but you can also create migrations yourself. As you build
          your application, your database migrations contain a complete record of the changes made
          to your database.</p><p>Migration files are stored in the <span class="emphasis"><em>db/migrate</em></span> directory and start
          with a timestamp that indicates when they were created. For example, you can see the
          migration created by the scaffold generator by editing the file
            <span class="emphasis"><em>db/migrate/*_create_posts.rb</em></span>. (Because the timestamps on your files
          will surely be different from mine, I’ll use an asterisk from now on to refer to the
          date part of the filename.) Let’s look at that file now:</p><a id="pro_id00087"/><pre class="programlisting">  class CreatePosts &lt; ActiveRecord::Migration
➊   def change
      create_table :posts do |t|
        t.string :title
        t.text :body

        t.timestamps
      end
    end
  end</pre><p><a class="indexterm" id="iddle1310"/><a class="indexterm" id="iddle1435"/><a class="indexterm" id="iddle1460"/><a class="indexterm" id="iddle1461"/><a class="indexterm" id="iddle2063"/><a class="indexterm" id="iddle2132"/><a class="indexterm" id="iddle2133"/>Database migrations are actually Ruby classes. The <code class="literal">change</code>
          method is called ➊ when the migration is run. In this case, the method creates a
          table named <code class="literal">posts</code> with fields for <code class="literal">title</code>,
            <code class="literal">body</code>, and <code class="literal">timestamps</code>. The
            <code class="literal">timestamps</code> field refers to both the <code class="literal">created_at</code> and
            <code class="literal">updated_at</code> fields. Rails also automatically adds the
            <code class="literal">id</code> column.</p><p>You can run migrations as tasks with the <code class="literal">rake</code> command. For example,
          you enter <code class="literal">bin/rake db:migrate</code> to run all pending migrations and bring
          your database up-to-date.</p><p>Rails keeps track of which migrations have been run by storing the timestamps in a
          database table called <code class="literal">schema_migrations</code>.</p><p>If you make a mistake in a database migration, use the <code class="literal">db:rollback</code>
          task to undo it. After you correct the migration, use <code class="literal">db:migrate</code> to run
          it again.</p><div class="sect2" title="The Schema"><div class="titlepage"><div><div><h2 class="title"><a id="schema"/>The Schema</h2></div></div></div><p>In addition to the individual migration files, Rails also stores your
            database’s current state. You can see this by opening the file
              <span class="emphasis"><em>db/schema.rb</em></span>. Ignoring the comment block at the top of the file,
            it should look like this:</p><a id="pro_id00088"/><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>--
ActiveRecord::Schema.define(version: 20130523013959) do

  create_table "posts", force: true do |t|
    t.string   "title"
    t.text     "body"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

end</pre><p>This file is updated whenever you run a database migration. You should not edit it
            manually. If you are moving your application to a new computer and would like to create
            a new, empty database all at once instead of by running the individual migrations, you
            can do that with the <code class="literal">db:schema:load rake</code> task:</p><a id="pro_id00089"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake db:schema:load</strong></span></pre><p>Running this command resets the database structure and removes all of your data in
            the process.</p></div><div class="sect2" title="Adding a Column"><div class="titlepage"><div><div><h2 class="title"><a id="adding_a_column"/>Adding a Column</h2></div></div></div><p><a class="indexterm" id="iddle1215"/><a class="indexterm" id="iddle1309"/><a class="indexterm" id="iddle1336"/><a class="indexterm" id="iddle1431"/><a class="indexterm" id="iddle1987"/><a class="indexterm" id="iddle2050"/><a class="indexterm" id="iddle2084"/><a class="indexterm" id="iddle2085"/>Now that you know more about migrations, let’s create one and run it.
            When we created our blog post model, we forgot that posts need authors. Add a string
            column to the posts table by generating a new migration:</p><a id="pro_id00090"/><pre class="programlisting">$ <span class="strong"><strong>bin/rails g migration add_author_to_posts author:string</strong></span></pre><p>The Rails generator (<code class="literal">g</code> is short for <code class="literal">generate</code>)
            looks at the name of your migration, in this case,
              <code class="literal">add_author_to_posts</code>, and tries to figure out what you want to do.
            This is another example of convention over configuration: name your migration in the
            format
              <code class="literal">add_</code><span class="emphasis"><em><code class="literal">ColumnName</code></em></span><code class="literal">_to_</code><span class="emphasis"><em><code class="literal">TableName</code></em></span>,
            and Rails will parse that to add what you need. Based on the name, we clearly want to
            add a column named <code class="literal">author</code> to the posts table. We also specified that
              <code class="literal">author</code> is a string, so Rails has all the information it needs to
            create the migration.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note01"/>Note</h3><p><span class="emphasis"><em>You can name a migration anything you want, but you should follow the
                convention so you don’t have to edit the migration manually.</em></span></p></div><p>Enter <span class="strong"><strong><code class="literal">bin/rake db:migrate</code></strong></span> to
            run the migration and add the <code class="literal">author</code> column to your database. If you
            still have a Rails console open, you’ll need to <span class="strong"><strong><code class="literal">exit</code></strong></span> and restart with <span class="strong"><strong><code class="literal">bin/rails console</code></strong></span> for your changes to take effect.
            You can also look at the <span class="emphasis"><em>db/schema.rb</em></span> file to see the new column in
            the posts table.</p></div><div class="sect2" title="Inside the Author Migration"><div class="titlepage"><div><div><h2 class="title"><a id="inside_the_author_migration"/>Inside the Author Migration</h2></div></div></div><p>The code you just generated for adding a column is simple. Edit the file
              <span class="emphasis"><em>db/migrate/*_add_author_to_posts.rb</em></span> to see how it works.</p><a id="pro_id00091"/><pre class="programlisting">class AddAuthorToPosts &lt; ActiveRecord::Migration
  def change
    add_column :posts, :author, :string
  end
end</pre><p>Like <span class="emphasis"><em>*_create_posts.rb</em></span>, this migration is a class containing a
              <code class="literal">change</code> method. The <code class="literal">add_column</code> method is called
            with the table name, column name, and column type. If you want to add multiple columns,
            you could create separate migrations for each, or you could call this method multiple
            times.</p><p>Active Record migrations also provide the <code class="literal">rename_column</code> method
            for changing a column’s name, the <code class="literal">remove_column</code> method for
            removing a column from a table, and the <code class="literal">change_column</code> method for
            changing a column’s type or other options, such as default value.</p></div></div><div class="sect1" title="Validations"><div class="titlepage"><div><div><h1 class="title"><a id="validations"/>Validations</h1></div></div></div><p><a class="indexterm" id="iddle1555"/><a class="indexterm" id="iddle1719"/><a class="indexterm" id="iddle1762"/><a class="indexterm" id="iddle1795"/><a class="indexterm" id="iddle1825"/><a class="indexterm" id="iddle1841"/><a class="indexterm" id="iddle1994"/><a class="indexterm" id="iddle2273"/><a class="indexterm" id="iddle2302"/>Remember that models have rules for manipulating application data. Active
          Record <span class="emphasis"><em>validations</em></span> are sets of rules created to protect your data.
          Add validation rules to ensure that only good data makes it into your database.</p><div class="sect2" title="Adding a Validation"><div class="titlepage"><div><div><h2 class="title"><a id="adding_a_validation"/>Adding a Validation</h2></div></div></div><p>Let’s look at an example. Because we’re making a blog, we should ensure
            that all posts have a title so readers don’t get confused, and we can do that with
            a validation rule.</p><p>Validations are implemented as class methods in Rails. Open the post model
              (<span class="emphasis"><em>app/models/post.rb</em></span>) in your editor and add this line:</p><a id="pro_id00092"/><pre class="programlisting">class Post &lt; ActiveRecord::Base
  <span class="strong"><strong>validates :title, :presence =&gt; true</strong></span>
end</pre><p>This validates the presence of text in the <code class="literal">title</code> field.
            Attempting to create a blog post with a blank title should now result in an
            error.</p><div class="sidebar"><a id="other_common_validations"/><p class="title">Other Common Validations</p><p>Rails provides a variety of other validations in addition to the
                <code class="literal">:presence</code> validation. For example, you can use the
                <code class="literal">:uniqueness</code> validation to ensure that no two posts have the same
              title.</p><p>The <code class="literal">:length</code> validation accepts a hash of options to confirm
              that the value is the correct length. Adding this line to your post model confirms
              that all titles are at least five characters:</p><a id="pro_id00093"/><pre class="programlisting"><span class="strong"><strong>validates :title, :length =&gt; { :minimum =&gt; 5 }</strong></span></pre><p>You can also specify a <code class="literal">:maximum</code> value instead of a
                <code class="literal">:minimum</code>, or you can use <code class="literal">:is</code> to set an exact
              value.</p><p>The <code class="literal">:exclusion</code> validation ensures the value does not belong to
              a given set of values. For example, adding this validation prohibits blog posts with
              the title <span class="emphasis"><em>Title</em></span>:</p><a id="pro_id00094"/><pre class="programlisting"><span class="strong"><strong>validates :title, :exclusion =&gt; { :in =&gt; [ "Title" ] }</strong></span></pre><p>You can think of <code class="literal">:exclusion</code> as a blacklist for values you
              don’t want to allow. Rails also provides an <code class="literal">:inclusion</code>
              validation for specifying a whitelist of accepted values.</p></div></div><div class="sect2" title="Testing Data"><div class="titlepage"><div><div><h2 class="title"><a id="testing_data"/>Testing Data</h2></div></div></div><p><a class="indexterm" id="iddle1183"/><a class="indexterm" id="iddle1187"/><a class="indexterm" id="iddle1253"/><a class="indexterm" id="iddle1343"/><a class="indexterm" id="iddle1430"/><a class="indexterm" id="iddle1550"/><a class="indexterm" id="iddle1907"/><a class="indexterm" id="iddle1968"/><a class="indexterm" id="iddle1975"/><a class="indexterm" id="iddle2234"/><a class="indexterm" id="iddle2305"/>Validations are automatically run before data is saved to the database.
            Attempt to store invalid data, and <code class="literal">save</code> returns
              <code class="literal">false</code>. You can also test a model manually with the
              <code class="literal">valid?</code> method:</p><a id="pro_id00095"/><pre class="programlisting">2.1.0 :025 &gt; <span class="strong"><strong>post = Post.new</strong></span>
 =&gt; #&lt;Post id: nil, title: nil, ...&gt;
2.1.0 :026 &gt; <span class="strong"><strong>post.valid?</strong></span>
 =&gt; false
2.1.0 :027 &gt; <span class="strong"><strong>post.errors.full_messages</strong></span>
 =&gt; ["Title can't be blank"]</pre><p>In this example, the <code class="literal">valid?</code> method should return
              <code class="literal">false</code> because you didn’t set a value for the title. Failing
            validations add messages to an array called <code class="literal">errors</code>, and calling
              <code class="literal">full_messages</code> on the <code class="literal">errors</code> array should return
            a list of error messages generated by Active Record based on your validations.</p><p>Use validations freely to keep bad data out of your database, but also consider your
            users when you create those validations. Make it clear which values are valid, and
            display error messages if invalid data is given so the user can correct the
            mistake.</p></div></div><div class="sect1" title="Associations"><div class="titlepage"><div><div><h1 class="title"><a id="associations"/>Associations</h1></div></div></div><p>Only the simplest of applications contain a single model. As your application grows,
          you’ll need additional models, and as you add more, you’ll need to describe
          the relationships between them. Active Record <span class="emphasis"><em>associations</em></span> describe
          the relationships between models. For example, let’s add comments to our blog
          posts.</p><p>Posts and comments are associated. Each post <span class="emphasis"><em>has many</em></span> comments,
          and each comment <span class="emphasis"><em>belongs to</em></span> a post. This
            <span class="emphasis"><em>one-to-many</em></span> relationship is one of the most commonly used
          associations, and we’ll explore it here.</p><div class="sect2" title="Generating the Model"><div class="titlepage"><div><div><h2 class="title"><a id="generating_the_model"/>Generating the Model</h2></div></div></div><p>A blog comment should have an author, a body, and a reference to a post. You can
            easily generate a model using that information:</p><a id="pro_id00096"/><pre class="programlisting">$ <span class="strong"><strong>bin/rails g model Comment author:string body:text post:references</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch03note02"/>Note</h3><p><span class="emphasis"><em>Remember to run database migrations after generating this new
                model!</em></span></p></div><p>The <code class="literal">post:references</code> option tells the Rails generator to add a
            foreign key to the comments database table. In this case, the foreign key is named
              <code class="literal">post_id</code> because it refers to a post. The <code class="literal">post_id</code>
            field contains the <code class="literal">id</code> of this comment’s post. The migration
            created the column we need in the database, so now we need to edit our models to finish
            setting up the association.</p></div><div class="sect2" title="Adding Associations"><div class="titlepage"><div><div><h2 class="title"><a id="adding_associations"/>Adding Associations</h2></div></div></div><p><a class="indexterm" id="iddle1184"/><a class="indexterm" id="iddle1188"/><a class="indexterm" id="iddle1233"/><a class="indexterm" id="iddle1346"/><a class="indexterm" id="iddle1672"/>First, open <span class="emphasis"><em>app/model/post.rb</em></span> again to add the comments
            association. Earlier I said that each post has many comments, and that’s the
            association we need here:</p><a id="pro_id00097"/><pre class="programlisting">class Post &lt; ActiveRecord::Base
  validates :title, :presence =&gt; true
  <span class="strong"><strong>has_many :comments</strong></span>
end</pre><p>Rails uses a class method called <code class="literal">has_many</code> to create this
            association in a readable way. Now, edit <span class="emphasis"><em>app/model/comment.rb</em></span>, and
            you’ll see that the Rails generator already added the matching
              <code class="literal">belongs_to</code> statement for you automatically:</p><a id="pro_id00098"/><pre class="programlisting">class Comment &lt; ActiveRecord::Base
  belongs_to :post
end</pre><p>The post to comments association should now work as intended. If your Rails console
            was still running while you made these changes, you’ll need to restart it to see
            the effects.</p></div><div class="sect2" title="Using Associations"><div class="titlepage"><div><div><h2 class="title"><a id="using_associations"/>Using Associations</h2></div></div></div><p>When you create an association in a model, Rails automatically defines several
            methods for that model. Use these methods, and you won’t have to worry about
            keeping the <code class="literal">post_id</code> updated. They maintain this relationship for you
            automatically.</p><div class="sect3" title="The has_many Methods"><div class="titlepage"><div><div><h3 class="title"><a id="hasunderscoremany_methods"/>The has_many Methods</h3></div></div></div><p>The <code class="literal">has_many :comments</code> statement you saw inside
                <code class="literal">Post</code> defines several methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="comments"><span class="title"><strong><span class="strong"><strong><code class="literal">comments</code></strong></span></strong></span>. Returns an Active Record relation representing the array of comments for
                    this post</p></li><li class="listitem"><p title="comments&lt;"><span class="title"><strong><span class="strong"><strong><code class="literal">comments&lt;</code></strong></span></strong></span>. Adds an existing comment to this post</p></li><li class="listitem"><p title="comments="><span class="title"><strong><span class="strong"><strong><code class="literal">comments=</code></strong></span></strong></span>. Replaces the existing array of comments for this post with a given
                    array</p></li><li class="listitem"><p title="comment_ids"><span class="title"><strong><span class="strong"><strong><code class="literal">comment_ids</code></strong></span></strong></span>. Returns an array of the comment ids associated with this post</p></li><li class="listitem"><p title="comment_ids="><span class="title"><strong><span class="strong"><strong><code class="literal">comment_ids=</code></strong></span></strong></span>. Replaces the existing array of comments for this post with the comments
                    corresponding to the given array of ids</p></li></ul></div><p>Because the <code class="literal">comments</code> method returns a relation, it is commonly
              used with other methods. For example, you can create new comments associated with a
              post with <code class="literal">post.comments.build</code>, which builds a new comment belonging
              to this post, or <code class="literal">post.comments.create</code>, which creates a new comment
              belonging to this post and saves it to the database. Each of these <a class="indexterm" id="iddle1041"/><a class="indexterm" id="iddle1185"/><a class="indexterm" id="iddle1232"/><a class="indexterm" id="iddle1344"/><a class="indexterm" id="iddle1962"/>methods automatically assigns the <code class="literal">post_id</code> of the newly
              created comment. This example creates a new comment associated with your first post.
              You should see the new comment in the output from
              <code class="literal">post.comments</code>:</p><a id="pro_id00099"/><pre class="programlisting">2.1.0 :028 &gt; <span class="strong"><strong>post = Post.first</strong></span>
 =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;
2.1.0 :029 &gt; <span class="strong"><strong>post.comments.create :author =&gt; "Tony", :body =&gt; "Test comment"</strong></span>
 =&gt; #&lt;Comment id: 1, author: "Tony", ...&gt;
2.1.0 :030 &gt; <span class="strong"><strong>post.comments</strong></span>
 =&gt; #&lt;ActiveRecord::Relation [#&lt;Comment id: 1, author: "Tony", ...&gt;]&gt;</pre><p>If you want to check if any comments are associated with a post, use
                <code class="literal">comments.empty?</code>, which returns <code class="literal">true</code> if there
              are none. You might also find it helpful to know how many comments are associated with
              a particular post; in that case, you use <code class="literal">comments.size</code>:</p><a id="pro_id00100"/><pre class="programlisting">2.1.0 :031 &gt; <span class="strong"><strong>post.comments.empty?</strong></span>
 =&gt; false
2.1.0 :032 &gt; <span class="strong"><strong>post.comments.size</strong></span>
 =&gt; 1</pre><p>When you know a post has comments associated with it, you can look for a
              particular comment by passing <code class="literal">post.comments.find</code> a comment id. This
              method raises an <code class="literal">ActiveRecord::RecordNotFound</code> exception if a
              matching comment cannot be found belonging to this post. Use
                <code class="literal">post.comments.where</code> instead if you would rather not raise an
              exception. This method just returns an empty relation if a matching comment is not
              found.</p></div><div class="sect3" title="The belongs_to Methods"><div class="titlepage"><div><div><h3 class="title"><a id="belongsunderscoreto_methods"/>The belongs_to Methods</h3></div></div></div><p>The <code class="literal">belongs_to :post</code> statement inside the
                <code class="literal">Comment</code> model defines five methods. Because
                <code class="literal">belongs_to</code> is a singular association (a comment can only belong
              to one post), all of these methods have singular names:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="post"><span class="title"><strong><span class="strong"><strong><code class="literal">post</code></strong></span></strong></span>. Returns an instance of the post that this comment belongs to</p></li><li class="listitem"><p title="post="><span class="title"><strong><span class="strong"><strong><code class="literal">post=</code></strong></span></strong></span>. Assigns this comment to a different post</p></li><li class="listitem"><p title="build_post"><span class="title"><strong><span class="strong"><strong><code class="literal">build_post</code></strong></span></strong></span>. Builds a new post for this comment</p></li><li class="listitem"><p title="create_post"><span class="title"><strong><span class="strong"><strong><code class="literal">create_post</code></strong></span></strong></span>. Creates a new post for this comment and saves it to the database</p></li><li class="listitem"><p title="create_post!"><span class="title"><strong><span class="strong"><strong><code class="literal">create_post!</code></strong></span></strong></span> Creates a new post for this comment but raises
                      <code class="literal">ActiveRecord::RecordInvalid</code> if the post is not valid</p></li></ul></div><p>These methods are the inverse of the methods defined in the
                <code class="literal">Post</code> model. Use them when you have a comment and you would like
              to manipulate its post. For example, let’s fetch the post associated with our
              first comment:</p><a id="pro_id00101"/><pre class="programlisting">2.1.0 :033 &gt; <span class="strong"><strong>comment = Comment.first</strong></span>
 =&gt; #&lt;Comment id: 1, author: "Tony", ...&gt;
2.1.0 :034 &gt; <span class="strong"><strong>comment.post</strong></span>
 =&gt; #&lt;Post id: 1, title: "First Post", ...&gt;</pre><p>Calling <code class="literal">post</code> on the first comment, which is also our only
              comment so far, should return our first post. This confirms the association works both
              ways. Assuming you still have more than one post in your database, you can also assign
              this comment to a different post:</p><a id="pro_id00102"/><pre class="programlisting">2.1.0 :035 &gt; <span class="strong"><strong>comment.post = Post.last</strong></span>
 =&gt; #&lt;Post id: 2, title: "Second Post", ...&gt;
2.1.0 :036 &gt; <span class="strong"><strong>comment.save</strong></span>
 =&gt; true</pre><p>Assigning a comment to another post updates the comment’s
                <code class="literal">post_id</code>, but does not write that to the database. Don’t
              forget to call <code class="literal">save</code> after updating the <code class="literal">post_id</code>!
              If you make this common mistake, the comment’s <code class="literal">post_id</code>
              won’t actually change.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00004"/>Summary</h1></div></div></div><p>This chapter has been a whirlwind tour of Active Record, so play around in the console
          until you’re comfortable with these ideas. Add more posts, update the existing posts
          with body text, and create comments associated with these posts. Focus on the CRUD
          operations and association methods in particular. These methods are commonly used in all
          Rails applications.</p><p>The next chapter covers Rails controllers. There, you’ll see all of these
          methods in use as you work your way through the various controller actions.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00005"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch03qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe1"/><a id="ch03qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. It might be nice to contact the people leaving comments on our blog. Generate
                a new migration to add a string column to the comments table to store an email
                address. Run this migration, and use the Rails console to verify that you can add an
                email address to comments now.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe2"/><a id="ch03qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. We need to ensure that users actually enter some text when they create a
                comment. Add validations to the comments model for the <code class="literal">author</code> and
                  <code class="literal">body</code> fields.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch03qa1qe3"/><a id="ch03qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. Write a query to determine the number of comments belonging to each post. You
                can’t do this with a single query, but you should be able to find the answer
                by iterating over a collection of posts as if it were an array.</p></td></tr></tbody></table></div></div></div></body></html>