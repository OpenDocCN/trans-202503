- en: '29'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE MAXWELL EQUATIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the past several chapters, we’ve introduced electric and magnetic fields
    and suggested that these fields are properly part of the description of the state
    of a physical system, at least one in which electric charge plays a role. What
    we have not yet done is shown how the electric and magnetic fields evolve in time.
    This chapter addresses that issue by introducing the Maxwell equations.
  prefs: []
  type: TYPE_NORMAL
- en: The Maxwell equations describe how electric and magnetic fields are created
    by charge and current, how the fields are related to each other, and how the fields
    evolve in time. Together with the Lorentz force law, the Maxwell equations express
    modern electromagnetic theory.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin the chapter with some introductory code, after which we’ll present
    the Maxwell equations. We’ll then discuss four relationships between electricity
    and magnetism implied by these equations and how the equations relate to our treatment
    of electric and magnetic fields in previous chapters. We’ll also show how the
    state-update technique can be applied to the Maxwell equations. Finally, we’ll
    present the finite difference time domain (FDTD) method for solving the Maxwell
    equations and use it to animate the electric field produced by oscillating charge.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 29-1](ch29.xhtml#ch29list1) shows the first lines of the code in the
    `Maxwell` module we’ll write in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 29-1: Opening lines of code for the `Maxwell` module*'
  prefs: []
  type: TYPE_NORMAL
- en: We use types and functions from the `SimpleVec` module of [Chapter 10](ch10.xhtml),
    the `CoordinateSystems` module of [Chapter 22](ch22.xhtml), and the `ElectricField`
    module of [Chapter 25](ch25.xhtml). We also do a qualified import of `Data.Map.Strict`,
    giving it the short name `M`, for use in the section on the FDTD method. We import
    several types and functions from the `Diagrams` package to do asynchronous animation
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Maxwell Equations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In SI units, the Maxwell equations consist of the following four equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/552equ01.jpg)![Image](Images/552equ02.jpg)![Image](Images/552equ03.jpg)![Image](Images/552equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The electric field is denoted **E**, the magnetic field **B**, the current
    density **J**, and the charge density *ρ*. Remember that *ϵ*[0] is the permittivity
    of free space, first introduced in [Chapter 21](ch21.xhtml). The symbol *∇* is
    called the *del operator*, and in Cartesian coordinates it is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/553equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The word *operator* here is used as physicists use it, meaning something that
    takes a function as input and produces a function as output. Functional programmers
    call such a thing a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The combination of the del operator followed by a dot product symbol, as in
    Equations 29.1 and 29.2, is called the *divergence*, a higher-order function that
    takes a vector field as input and produces a scalar field as output. The definition
    of divergence is flux per unit volume, so a place where a vector field has positive
    divergence is a place that the vectors point away from. Similarly, a place where
    a vector field has negative divergence is a place that the vectors point toward.
    In Cartesian coordinates, the divergence of a vector field looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/553equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The combination of the del operator followed by a cross product symbol, as
    in Equations 29.3 and 29.4, is called the *curl*, a higher-order function that
    takes a vector field as input and produces a vector field as output. The definition
    of curl is circulation per unit area, so it describes how the vectors form a pattern
    of circulation. A place where a vector field has curl in the z-direction is a
    place where the vectors point in a counterclockwise sense parallel to the xy-plane.
    In Cartesian coordinates, the curl of a vector field looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/553equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Equation 29.1 is called Gauss’s law (you may have encountered Gauss’s law in
    the exercises in [Chapter 25](ch25.xhtml)). Gauss’s law says that charge dictates
    the divergence of the electric field. Since vectors point away from a place of
    positive divergence and toward a place of negative divergence, Gauss’s law says
    that the electric field points away from positive charge and toward negative charge.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 29.2 is called Gauss’s law for magnetism, or “no magnetic monopoles.”
    Since the divergence of the magnetic field must be 0 at all points in space and
    time, there is no magnetic charge for the magnetic field to point toward or away
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 29.3 is called Faraday’s law (you may have encountered Faraday’s law
    in the exercises in [Chapter 27](ch27.xhtml)). It asserts a link between the curl
    of the electric field and the time rate of change of the magnetic field. Faraday’s
    law explains electric generators and transformers.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 29.4 is the *Ampere-Maxwell law*. It asserts a relationship among the
    curl of the magnetic field, the time rate of change of the electric field, and
    the current density.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four independent variables in the Maxwell equations: three space
    coordinates and one time coordinate. There are six dependent variables: three
    electric field components and three magnetic field components. We can think of
    the charge and current densities as source terms. They are inputs to the Maxwell
    equations that determine the fields and how they change.'
  prefs: []
  type: TYPE_NORMAL
- en: With the Maxwell equations, we have electric field and magnetic field appearing
    in the same equations for the first time. The Maxwell equations describe four
    relationships between electricity and magnetism, which we describe next.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships Between Electricity and Magnetism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Equation 29.1 is purely electric, and Equation 29.2 is purely magnetic. The
    remaining two Maxwell equations express four relationships between electricity
    and magnetism.
  prefs: []
  type: TYPE_NORMAL
- en: First, electric charge produces a magnetic field when it moves. This was Hans
    Christian Oersted’s 1820 discovery. He saw that electric current could deflect
    a compass needle. This relationship is described by the Ampere-Maxwell law, Equation
    29.4, in that the current density **J** is related to the curl of the magnetic
    field, ∇ × **B**. An earlier version of this law, called Ampere’s law, omitted
    the time derivative of the electric field and thus expressed in a simpler, if
    less comprehensive, way the dependence of magnetic field on current.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, a changing magnetic field produces an electric field. This was Faraday’s
    discovery and goes by the name of Faraday’s law, Equation 29.3\. So, there are,
    in a sense, two sources of electric fields: one is charge and the other is a changing
    magnetic field. Coulomb’s law is missing this changing magnetic field contribution
    to the electric field and is incompatible with relativity. Most electric generation
    plants today use Faraday’s law to produce alternating electric current. The rotation
    of a turbine produces a changing magnetic field, which produces an electric field
    that drives the current.'
  prefs: []
  type: TYPE_NORMAL
- en: Third, a changing electric field produces a magnetic field. In 1865, Maxwell
    added the term with the time derivative of the electric field to Ampere’s law,
    creating the Ampere-Maxwell law, Equation 29.4\. The added term is known as *displacement
    current* because, although it is not an electrical current, it serves a similar
    role in the creation of a magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, electric and magnetic fields constitute light. The modern theory of
    optics asserts that light is an electromagnetic wave. There is no such thing as
    an electric wave or a magnetic wave by itself. Wavelike electric fields are always
    accompanied by wavelike magnetic fields.
  prefs: []
  type: TYPE_NORMAL
- en: Connection to Coulomb’s Law and Biot-Savart Law
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the Maxwell equations describe how electric and magnetic fields are created
    and how they evolve, why did we not use them in [Chapters 25](ch25.xhtml) and
    [27](ch27.xhtml)? Those chapters gave methods for how an electric field is created
    by charge and how a magnetic field is created by current, respectively. How do
    the methods given in those chapters relate to the Maxwell equations?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that [Chapter 25](ch25.xhtml) gave methods for calculating the electric
    field in static situations (that is, in situations where charge is not moving
    or accelerating). In practice, the methods of that chapter, which are equivalent
    to Coulomb’s law, work reasonably well for charges moving slowly compared with
    the speed of light. In static situations, we can remove the two time derivative
    terms from the Maxwell equations, causing the equations for electricity to decouple
    from those for magnetism. Thus, in static situations, Equations 29.1 and 29.3
    become
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/555equ01.jpg)![Image](Images/555equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and describe static electricity. Coulomb’s law is the solution to Equations
    29.8 and 29.9.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in static situations, Equations 29.2 and 29.4 become
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/555equ03.jpg)![Image](Images/555equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and describe the magnetic field created by steady currents. The Biot-Savart
    law of [Chapter 27](ch27.xhtml) is the solution to Equations 29.10 and 29.11.
  prefs: []
  type: TYPE_NORMAL
- en: The static methods we introduced in [Chapters 25](ch25.xhtml) and [27](ch27.xhtml)
    are useful and substantially simpler than the Maxwell equations, but they do not
    account for dynamic situations where charge is moving quickly or accelerating.
    We turn now to the task of solving the Maxwell equations, employing a state-update
    similar to what we used to solve Newton’s second law in [Part II](part02.xhtml)
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: State Update
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand how electric and magnetic fields change in time, it is helpful
    to rearrange Maxwell Equations 29.3 and 29.4 so that they give the rates of change
    of the fields in terms of the fields and the current density.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/555equ05.jpg)![Image](Images/555equ06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Equations 29.1 and 29.2 serve as constraints; as long as the electric and magnetic
    fields satisfy them at one point in time, they will continue to satisfy them as
    they change according to Equations 29.12 and 29.13.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 29-1](ch29.xhtml#ch29fig1) shows a schematic diagram for the Maxwell
    equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/556fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 29-1: A schematic diagram representing the Maxwell equations*'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram is similar to the diagrams we made in [Part II](part02.xhtml) of
    the book for Newton’s second law. The most striking difference is that the values
    carried by the wires here are vector fields, whereas in mechanics they were numbers
    or vectors. As we integrated acceleration to obtain velocity in mechanics, here
    we integrate the curl of the electric field to obtain the magnetic field. As a
    loop in this kind of schematic diagram signaled a differential equation in mechanics,
    the loop here also signals that the Maxwell equations are differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 29-1](ch29.xhtml#ch29fig1), magnetic field change
    is controlled by the negative curl of the electric field. Electric field change
    is controlled by both current density and the curl of the magnetic field. This
    schematic diagram represents Equations 29.3 and 29.4\. The integrators are with
    respect to time, as they have been in all of the schematic diagrams like this.
    The type `VectorField` below each integrator indicates the nature of the state
    contained in the integrator. Each integrator here contains a full vector field
    as state that gets updated by the vector field acting as input to the integrator.
    Equations 29.1 and 29.2 place constraints on the vector fields that can be held
    as state by the integrators. The multiplications by *c*² and –*μ* [0]*c*² are
    appropriate for SI units.
  prefs: []
  type: TYPE_NORMAL
- en: As in [Part II](part02.xhtml) of the book, our methods for solving the Maxwell
    equations involve treating time discretely, updating the quantities we care about
    over a time step that is small compared with time scales on which significant
    change occurs, and then iterating this update procedure over many small time steps.
    For the Maxwell equations, the quantities we care about are the electric and magnetic
    fields. We update the electric and magnetic fields using Equations 29.12 and 29.13
    to provide the rate at which electric and magnetic fields change. The updated
    fields change by the product of the rate with the time step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/557equ01.jpg)![Image](Images/557equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To encode Equations 29.14 and 29.15 in Haskell, we need to take the curl of
    a vector field. We’ll turn next to the question of how to write the curl in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial Derivatives and the Curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The divergence and curl that appear in the Maxwell equations are types of spatial
    derivatives. Conceptually, the simplest spatial derivative is the *directional
    derivative*, defined to be the rate at which a field changes as we move in a specified
    direction. If *f* is a scalar field and ![Image](Images/ncap.jpg) is a unit vector,
    the directional derivative of *f* in the direction ![Image](Images/ncap.jpg) is
    defined to be the limit of the ratio of the difference of the values of the scalar
    field at two points separated by distance *ϵ* in the direction ![Image](Images/ncap.jpg),
    divided by *ϵ*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/557equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our computational directional derivative will not take a limit but instead
    will simply calculate the ratio using a small displacement ![Image](Images/557equ04.jpg),
    which we call `d` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The displacement vector `d` that serves as the first input to `directional`
    `Derivative` has two roles. Its direction specifies the direction in which we
    want the derivative. In calculus, where we take limits, this is its only role.
    But in computation, where our derivatives involve small but finite steps, the
    second role of this input is for its magnitude to specify the step size for the
    derivative. We evaluate the field at two points: one shifted half the displacement
    vector from `r` and the other shifted minus half the displacement vector from
    `r`. We find the difference of these two field values and divide it by the magnitude
    of the displacement vector.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Equation 29.7 that we can find the curl from partial derivatives
    along the three coordinate directions. The partial derivative with respect to
    *x* is the directional derivative in the ![Image](Images/icap.jpg) direction.
    The local functions `derivX`, `derivY`, and `derivZ` in the code for `curl` are
    partial derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: We write the curl of a vector field in terms of Cartesian coordinates and partial
    derivatives, as in Equation 29.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The input `a` is a real number specifying the spatial step size to use for the
    curl. The input `vf` is the vector field for which we want the curl. The local
    variables `vx`, `vy`, and `vz` have type `ScalarField` and are the components
    of the vector field `vf`. The partial derivatives `derivX`, `derivY`, and `derivZ`
    have type `ScalarField -> ScalarField`. Finally, we use Equation 29.7 to find
    the curl.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can take the curl of a vector field, we are ready to try encoding
    the Maxwell equations in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: A Naive Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest encoding of the Maxwell equations uses a state space consisting
    of the current time, the electric field, and the magnetic field. We use the type
    synonym `FieldState` to describe a triple consisting of a real number for time,
    a vector field for electric field, and a vector field for magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function `maxwellUpdate` encodes Equations 29.14 and 29.15, which describe
    how the electric field and the magnetic field can be updated in time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The input `dx` to `maxwellUpdate` is a real number describing the spatial step
    size to use for the curl present in Equations 29.14 and 29.15\. The input `dt`
    is a real number describing the time step. The input `j` is a time-dependent vector
    field describing the current density **J**. [Table 29-1](ch29.xhtml#ch29tab1)
    gives a correspondence between the mathematical notation of Equations 29.14 and
    29.15 with the Haskell notation in `maxwellUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 29-1:** Correspondence Between Mathematical Notation and Haskell Notation
    for the Maxwell Equations'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Mathematics** | **Haskell** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Time | *t* | `t` |'
  prefs: []
  type: TYPE_TB
- en: '| Position | **r** | `r` |'
  prefs: []
  type: TYPE_TB
- en: '| Time step | Δ*t* | `dt` |'
  prefs: []
  type: TYPE_TB
- en: '| Speed of light | *c* | `cSI` |'
  prefs: []
  type: TYPE_TB
- en: '| Permeability of free space | *μ*[0] | `mu0` |'
  prefs: []
  type: TYPE_TB
- en: '| Current density | **J** | `j` |'
  prefs: []
  type: TYPE_TB
- en: '| Current density | **J**(*t*,**r**) | `j t r` |'
  prefs: []
  type: TYPE_TB
- en: '| Electric field | **E**(*t*,**r**) | `eF r` |'
  prefs: []
  type: TYPE_TB
- en: '| Magnetic field | **B**(*t*,**r**) | `bF r` |'
  prefs: []
  type: TYPE_TB
- en: '| Updated electric field | **E**(*t* + Δ*t*,**r**) | `eF'' r` |'
  prefs: []
  type: TYPE_TB
- en: '| Updated magnetic field | **B**(*t* + Δ*t*,**r**) | `bF'' r` |'
  prefs: []
  type: TYPE_TB
- en: '| Curl | ∇× | `curl dx` |'
  prefs: []
  type: TYPE_TB
- en: '| Curl of electric field | ∇×**E**(*t*,**r**) | `curl dx eF r` |'
  prefs: []
  type: TYPE_TB
- en: '| Curl of magnetic field | ∇×**B**(*t*,**r**) | `curl dx bF r` |'
  prefs: []
  type: TYPE_TB
- en: '| Vector addition | + | `^+^` |'
  prefs: []
  type: TYPE_TB
- en: '| Vector subtraction | – | `^-^` |'
  prefs: []
  type: TYPE_TB
- en: '| Scalar multiplication | Juxtaposition | `*^` |'
  prefs: []
  type: TYPE_TB
- en: We update the time by adding the time step `dt` to the current time `t` to form
    the updated time `t'`. We update the electric field by adding *c*²[∇×**B**(*t*,**r**)
    – *μ*[0]**J**(*t*,**r**)]Δ*t* to the current electric field to form the updated
    electric field. We update the magnetic field by subtracting [∇×**E**(*t*,**r**)]Δ*t*
    from the current magnetic field to form the updated magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: To find the electric and magnetic fields as functions of time, we could iterate
    the `maxwellUpdate` function to produce a long list of states. The `maxwell` `Evolve`
    function does this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, there is problem. While the code we have written compiles and in principle
    can be run, it is hopelessly inefficient. The trouble is that the computer does
    not automatically remember the function values it has already calculated, and
    it recalculates the same things over and over again. A function, to the Haskell
    compiler, is a rule for calculating outputs from inputs. If we know that we will
    need the output of a function in the future, it is up to us as Haskell programmers
    to see that it is available, usually by giving it a name. The values of the electric
    field at various places are just such function outputs in this naive method. They
    are not stored anywhere and must be recalculated each time they are needed. By
    the time we get to the eighth time step, for example, the computer needs to know
    the values of the electric and magnetic fields at the seventh time step, but these
    were not stored, so they must be recalculated. But the values for the seventh
    time step depend on those for the sixth, which were not stored and therefore must
    be recalculated.
  prefs: []
  type: TYPE_NORMAL
- en: The state `FieldState` and update method `maxwellUpdate` we have written in
    this section, while elegant and illustrative of what we want the computer to do,
    are not usable in practice, which is why we call them “naive” methods. Nevertheless,
    I would argue that there is value in this code. It type checks, indicating that
    the compiler agrees we are asking for something that makes sense. It is written
    in a style that is readable and can help us to understand what the Maxwell equations
    are about. Perhaps some day compilers will be smart enough to be able to plan
    what values should be remembered because they will be used again.
  prefs: []
  type: TYPE_NORMAL
- en: However, for today, we want to write code that runs and produces results. To
    do that, we’ll turn to a new method.
  prefs: []
  type: TYPE_NORMAL
- en: The FDTD Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw in the naive method that using functions to describe the state of a system,
    while clear in meaning and elegant in exposition, is not an efficient way to solve
    the Maxwell equations. To get decent executable code, we want numbers describing
    the state of our system rather than functions. To achieve this, we will select
    a large but finite number of positions in space at which to keep track of the
    electric and magnetic field components. The method we describe in detail is called
    the *finite difference time domain* (*FDTD*) method for solving the Maxwell equations.
    It is the simplest method used by people who need to numerically solve the Maxwell
    equations. The FDTD method is described more fully in [**[18](bib.xhtml#bib18)**].
  prefs: []
  type: TYPE_NORMAL
- en: The FDTD method is still based on Equations 29.12 and 29.13\. Each of these
    two equations is a vector equation. It is helpful to write out the Cartesian components
    of these equations. Using Equation 29.7 to express the curl, Equations 29.17,
    29.18, and 29.19 list the x-, y-, and z-components of Equation 29.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/560equ01.jpg)![Image](Images/560equ02.jpg)![Image](Images/560equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the x-, y-, and z-components of Equation 29.13 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/561equ01.jpg)![Image](Images/561equ02.jpg)![Image](Images/561equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The FDTD method consists of approximating each partial derivative with a symmetric
    finite difference. By symmetric, we mean that we can approximate the partial derivative
    of a field component (*E[x]*, *E[y]*, *E[z]*, *B[x]*, *B[y]*, or *B[z]*) at a
    particular point (*t*,*x*,*y*,*z*) in time and space by sampling the field component
    at two points equidistant from (*t*,*x*,*y*,*z*). In the case of a partial derivative
    with respect to time, the sample points are (*t* + Δ*t*/2,*x*,*y*,*z*) and (*t*
    – Δ*t*/2,*x*,*y*,*z*). In the case of a partial derivative with respect to space,
    say in the y-direction, the sample points are (*t*,*x*,*y* + Δ*y*/2,*z*) and (*t*,*x*,*y*
    – Δ*y*/2,*z*). For example, the partial derivative of *E[x]* with respect to time
    is approximated as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/561equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the partial derivative of *E[z]* with respect to *y* is approximated as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/561equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applying this finite difference approximation to Equation 29.17 and performing
    a bit of algebra results in an equation that tells us how to update the value
    of the x-component of electric field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/561equ06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are five analogous equations for *E[y]*, *E[z]*, *B[x]*, *B[y]*, and *B[z]*.
    Equation 29.25 and the other five are concisely expressed in vector form as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/562equ01.jpg)![Image](Images/562equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where components of the curl are approximated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/562equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the similarity between Equations 29.26 and 29.27 on one hand and Equations
    29.14 and 29.15 on the other. The only difference is that the curls of the fields
    and the current density are evaluated at a time midway between the original and
    updated values of the fields in the FDTD Equations 29.26 and 29.27, while the
    curls and current density are evaluated at the time of the original values of
    the fields in Equations 29.14 and 29.15, which is closer to the Euler method.
  prefs: []
  type: TYPE_NORMAL
- en: The curl of Equation 29.28 requires values of *B[y]* and *B[z]* that are half
    a spatial step away. Updating *E[x]* at a point in time and space depends on *E[x]*
    at the same place one time step *Δt* earlier. It also depends on *B[y]* half a
    spatial step to either side in the z-direction half a time step earlier, and it
    depends on *B[z]* half a spatial step to either side in the y-direction half a
    time step earlier.
  prefs: []
  type: TYPE_NORMAL
- en: These half-spatial-step dependencies imply that the locations at which we keep
    track of the six components should be staggered. The places at which we keep track
    of *E[x]* will be shifted slightly from the places where we keep track of *E[y]*
    or *B[y]*. Equation 29.25 and the five analogous equations for *E[y]*, *E[z]*,
    *B[x]*, *B[y]*, and *B[z]* determine where we should track each component. We
    turn next to describing the locations at which we will keep track of the electric
    and magnetic field components.
  prefs: []
  type: TYPE_NORMAL
- en: The Yee Cell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will use a triple `(nx,ny,nz)` of `Int`s to specify a location where we keep
    track of the field components. The integer `nx` measures the number of half spatial
    steps in the x-direction from the origin of our coordinate system. In other words,
    if `dx` is the spatial step size in the x-direction, equivalent to Δ*x* in mathematical
    notation, then the x-coordinate of the position associated with `(nx,ny,nz)` is
    `fromIntegral nx * dx / 2`. Even integers denote whole steps from the origin,
    while odd integers denote an odd number of half steps. [Table 29-2](ch29.xhtml#ch29tab2)
    shows the locations at which each of the six field components is tracked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 29-2:** Locations at Which We Calculate Components of the Electric
    and Magnetic Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | `nx` | `ny` | `nz` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *E[x]* | odd | even | even |'
  prefs: []
  type: TYPE_TB
- en: '| *E[y]* | even | odd | even |'
  prefs: []
  type: TYPE_TB
- en: '| *E[z]* | even | even | odd |'
  prefs: []
  type: TYPE_TB
- en: '| *B[x]* | even | odd | odd |'
  prefs: []
  type: TYPE_TB
- en: '| *B[y]* | odd | even | odd |'
  prefs: []
  type: TYPE_TB
- en: '| *B[z]* | odd | odd | even |'
  prefs: []
  type: TYPE_TB
- en: The locations at which values of *E[x]* are kept are held in a list called `exLocs`,
    which is formed using a list comprehension to allow the integer `nx` to range
    over a sequence of consecutive odd integers, `ny` to range over a sequence of
    consecutive even integers, and `nz` to range over a sequence of consecutive even
    integers, as specified in [Table 29-2](ch29.xhtml#ch29tab2). Other lists with
    similar names hold the locations of other field components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The constant `spaceStepsCE` (CE for center to edge) gives the number of full
    spatial steps from the center to the edge of our grid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use integers to specify locations in the grid. The largest even integer,
    called `hiEven`, is twice the number of full steps from center to edge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The even numbers used to specify locations range from `-hiEven` to `hiEven`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The odd numbers used to specify locations begin one above the lowest even number
    and end one below the highest even number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The pattern of locations for storing the field components is called a *Yee cell*
    and is shown in [Figure 29-2](ch29.xhtml#ch29fig2). The Yee cell is named after
    Kane S. Yee, who pioneered the FDTD method in the 1960s.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/564fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 29-2: Yee cell showing where electric and magnetic field components
    are calculated*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 29-2](ch29.xhtml#ch29fig2) shows a patch of three-dimensional space,
    with a coordinate system in which *x* increases to the right, *y* increases up
    the page, and *z* increases out of the page. Double-headed arrows are placed at
    the locations in space where field components are tracked. Black arrows are electric
    field components, and gray arrows are magnetic field components. The direction
    in which the arrow points indicates which of the three components is being shown.
    A left-right arrow, for example, is an x-component. [Figure 29-2](ch29.xhtml#ch29fig2)
    is a visual way of expressing the information in [Table 29-2](ch29.xhtml#ch29tab2).
    For example, an *E[x]*-component is stored at `(nx,ny,nz) = (1,2,0)` since `nx`
    is odd, `ny` is even, and `nz` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of the Yee cell is that each component’s nearest neighbors
    contain the information needed to update that component in time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk next about how we represent the state of the electric and magnetic
    fields in the FDTD method and how we update that state.
  prefs: []
  type: TYPE_NORMAL
- en: A Type for State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of the `FieldState` data type we used in the naive method, which contains
    functions for the electric and magnetic fields, we wish to have a state that holds
    numbers for the components of the electric and magnetic fields at the positions
    identified in the Yee cell of [Figure 29-2](ch29.xhtml#ch29fig2).
  prefs: []
  type: TYPE_NORMAL
- en: One of the standard Haskell library modules, `Data.Map.Strict`, includes a data
    structure called a `Map` that is good for this purpose. The type `Map k v` is
    the type of a lookup table of key-value pairs, with `k` being the type of the
    key and `v` being the type of the value. In [Chapter 9](ch09.xhtml) we showed
    how a list of pairs with type `[(k,v)]` can be used as a lookup table, but the
    type `Map k v` is better because it will store the keys in such a way that they
    can be looked up quickly.
  prefs: []
  type: TYPE_NORMAL
- en: For the key, we will use a triple `(nx,ny,nz)` of `Int`s to describe the location
    of a field component, and for the value we will use a real number `R`. So, the
    type we want to hold our field data is `Map (Int,Int,Int) R`.
  prefs: []
  type: TYPE_NORMAL
- en: Since electric field components are stored at different locations from magnetic
    field components, we could get away with a single lookup table, but we choose
    to use two tables, one for electric field and one for magnetic field, to make
    the code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Our state space, called `StateFDTD`, consists of the time, three real numbers
    for the spatial step size in each direction, a `Map (Int,Int,Int) R` for the electric
    field, and a `Map (Int,Int,Int) R` for the magnetic field. It is not strictly
    necessary to include the spatial step sizes in the state, but it is convenient
    because functions that have a state as input often need to know the spatial step
    sizes to do their jobs. A function that computes the curl of a field, for example,
    needs the spatial step size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the introductory code, the line `import qualified Data.Map.Strict as M` allows
    us to access all of the functions and types defined in `Data.Map.Strict` if we
    prefix them with a capital `M`. Because of the way we imported the module, we
    need to refer to the type `Map (Int,Int,Int) R` as `M.Map (Int,Int,Int) R`, which
    we see above is the type we use to hold the electric field and the magnetic field.
  prefs: []
  type: TYPE_NORMAL
- en: The function `initialStateFDTD` takes a real number that it uses for the spatial
    step size in all three directions as input, and it returns a state in which the
    electric field and the magnetic field are 0 at all positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function `M.fromList` from the `Data.Map.Strict` module turns a list-of-pairs
    lookup table into a `Map` lookup table. We use a list comprehension to form a
    list of pairs in which the key is one of the locations for a field component and
    the value is 0.
  prefs: []
  type: TYPE_NORMAL
- en: The `Data.Map.Strict` module uses strict evaluation instead of Haskell’s default
    lazy evaluation. When doing numerical calculations, we almost never want to use
    lazy evaluation. Lazy evaluation is good when we might, depending on input data,
    compute only a subset of the possible outputs of our program. But when we are
    numerically evaluating a model, we just want to compute the quantities of interest
    at all specified points. In this case, we don’t need to pay the price in memory
    space (a memory pointer to either the code to evaluate a function or the result
    of a previous evaluation) of lazy evaluation. A general rule of thumb is that
    the strict version of a function is usually what you want, unless you really know
    what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look now at how we will compute curls in the FDTD method.
  prefs: []
  type: TYPE_NORMAL
- en: FDTD and the Curl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Equation 29.28 showed how to compute the x-component of the curl of the magnetic
    field in the FDTD method. There are five other analogous equations: two for the
    y- and z-components of the curl of the magnetic field and three for the components
    of the curl of the electric field. The approximation of the curl in Equation 29.28
    is based on the approximation of the partial derivative in Equation 29.24, so
    we’ll want to encode the partial derivative first. However, even more basic than
    computing the partial derivative is simply looking up values from the key-value
    lookup table, so let’s address that now.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking Up Values in the Lookup Table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `Data.Map.Strict` module provides the function `lookup`, which we write
    as `M.lookup`, to retrieve values from a lookup table. Let’s look at the type
    of this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to see the type of `lookup` from `Data.Map.Strict` without loading
    the code in this chapter, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we ask for the type of `lookup` using the fully qualified name of the function,
    prefixing the module name before the function name to distinguish the `lookup`
    of `Data.Map.Strict` from the `lookup` of `Prelude`.
  prefs: []
  type: TYPE_NORMAL
- en: From the type, we see that `M.lookup` wants a key and a lookup table and will
    return something of type `Maybe a`. If it finds the key in the table, it will
    return the value associated with it, wrapped in the `Just` constructor of the
    `Maybe a` type. If it doesn’t find the key, it will return `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: Our helping function `lookupAZ` uses `M.lookup` to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The function `lookupAZ` (AZ for assume zero) has a slightly simpler type than
    `M.lookup`. The function serves two purposes. First, it relieves us of the need
    to case analyze the results each time we do a lookup. Second, when we compute
    a curl for a location at the edge of our grid, we will be trying to look up values
    that don’t exist because they are just off the grid. For these two reasons, we
    write a function that treats nonexistent keys as if they had values of 0\. This
    is not the safest procedure, because it will not help us find errors in our code
    if we are asking for nonexistent keys because of a mistake we made in programming.
    I’m generally a pretty careful and conservative person, but in this one case,
    I chose to live on the wild side.
  prefs: []
  type: TYPE_NORMAL
- en: The partial derivative requires that we look up values of the relevant component
    half a spatial step to either side of where we want to compute the derivative.
    Half a spatial step means one integer higher and one integer lower in the relevant
    direction. The functions `partialX`, `partialY`, and `partialZ` all have the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each function takes a spatial step size, a lookup table (called `m` for map),
    and a location as input. Each works by using the `lookupAZ` function to retrieve
    values on either side of the given location. The difference between these values
    is divided by the step size to obtain the approximation to the partial derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Curl
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With partial derivative in hand, we now turn to the curl. Here are six functions
    that compute components of the curl of the electric field and the magnetic field.
    Equation 29.7 gives the components of the curl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each curl function takes a `StateFDTD` and a location as input. The function
    `curlBx` computes the x-component of the curl of the magnetic field. According
    to Equation 29.7, this is the difference between the partial derivative with respect
    to *y* of *B[z]*, denoted `partialY dy b loc` in the code above, and the partial
    derivative with respect to *z* of *B[y]*, denoted `partialZ dz b loc`, each evaluated
    at the given location. Why do we not specify in the expression `partialY dy b
    loc` that it is the z-component we want the derivative of? The answer is that,
    because of the way the Yee cell is constructed, every location at which we need
    to compute `curlBx` has *B[z]* living one integer away in the y-direction. The
    x-component of the curl of the magnetic field is needed only to update the x-component
    of the electric field. We use `curlBx` only when we update *E[x]*, and *B[z]*
    is its neighbor in the y-direction, so taking `partialY` at that location automatically
    takes the partial of *B[z]*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look now at how we will update the state.
  prefs: []
  type: TYPE_NORMAL
- en: State Update
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function `stateUpdate` takes a time step, a time-dependent current density,
    and a state as input, and it uses that information to produce an updated state
    as output. It passes the real work off to the functions `updateE` and `updateB`,
    which update the electric and magnetic fields, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Updating the electric field, as Equation 29.25 shows, requires knowledge of
    the current density, so we include the current density at the present time, `j
    t`, as an input to `updateE`.
  prefs: []
  type: TYPE_NORMAL
- en: The role of `updateE` is to carry out Equation 29.25 and the analogous equations
    for *E[y]* and *E[z]* that come from Equations 29.18 and 29.19.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `updateE` uses record syntax to update two of the items in the
    state: the time and the electric field. The function updates the current time,
    `timeFDTD st`, by adding half a time step to it. The function `updateB` adds the
    other half time step.'
  prefs: []
  type: TYPE_NORMAL
- en: We update the electric field components at every place they are stored using
    the `mapWithKey` function from `Data.Map.Strict`. Let’s look at the type of `mapWithKey`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `mapWithKey` function takes a higher-order function `k -> a -> b` as input.
    For us, this will be a function `(Int,Int,Int) -> R -> R`. It describes how to
    use the key and value of a key-value pair to produce a new value. The function
    `updateEOneLoc dt jVF st`, defined later, serves this role for us, describing
    how to update an electric field component at a particular position in space.
  prefs: []
  type: TYPE_NORMAL
- en: The function `updateB` updates the magnetic field. It does for the magnetic
    field what `updateE` does for the electric field. The only difference is that
    the current density is not required to update the magnetic field, so it is not
    an input to `updateB`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As promised, `updateB` increases the time by half a time step, so after we have
    used both `updateE` and `updateB`, the time has increased by one whole time step.
    As with `updateE`, `updateB` uses `mapWithKey` to carry out the update over all
    locations we are tracking in the state. For the magnetic field, the function we
    map across the lookup table is called `updateBOneLoc dt st`. We define it later,
    and it describes how to update the magnetic field at one particular location in
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Now we look at the functions that update the electric and magnetic fields at
    one point in space. Here we finally see the Maxwell equations. The function `updateEOneLoc`
    is responsible for updating electric field components at one location in space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It requires a time step, a current density, the state, a location, and a present
    electric field component value as inputs. It uses a `let` construction to define
    a few local variables. The local variable `r` holds the position described by
    the integer triple `(nx,ny,nz)`. The current density needs this position, and
    we compute it by multiplying each integer by half a spatial step in the appropriate
    direction. The local variables `jx`, `jy`, and `jz` are the components of the
    current density at the relevant location. Finally, we decide which component is
    being updated by examining the oddness or evenness of the three integers. As [Table
    29-2](ch29.xhtml#ch29tab2) indicates, an odd-even-even triple of integers means
    we are updating *E[x]*, an even-odd-even triple of integers means we are updating
    *E[y]*, and an even-even-odd triple of integers means we are updating *E[z]*.
    We include a final line to catch a triple that does not fall into one of these
    three cases, which would indicate an error in our code since `updateEOneLoc` should
    only ever be used at locations that hold electric field components.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the case analysis, we update the electric field component, called
    `ec`, using one of the three Cartesian components of Equation 29.26\. The local
    variable `ec` contains the present value of the electric field component to be
    updated (that is, one of *E[x]*, *E[y]*, or *E[z]*).
  prefs: []
  type: TYPE_NORMAL
- en: The function `updateBOneLoc` does for the magnetic field what `updateEOneLoc`
    does for the electric field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function is simpler because it does not involve the current density. Again,
    there is a case analysis on the oddness or evenness of the three integers describing
    the location to determine which magnetic field component we are asking the function
    to update. As [Table 29-2](ch29.xhtml#ch29tab2) indicates, an even-odd-odd triple
    of integers means we are updating *B[x]*, an odd-even-odd triple of integers means
    we are updating *B[y]*, and an odd-odd-even triple of integers means we are updating
    *B[z]*.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the case analysis, we update the magnetic field component, called
    `bc`, using one of the three Cartesian components of Equation 29.27\. The local
    variable `bc` contains the magnetic field component to be updated, which could
    be *B[x]*, *B[y]*, or *B[z]*, depending on the oddness or evenness of the integers
    in the triple.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the description of the FDTD method. The function `stateUpdate`
    is the entry point for those wishing to use the method. It requires a time step,
    a time-dependent current density, and an initial state, and it gives back an updated
    state one time step later. We will likely want to iterate this `stateUpdate` function
    to see the fields evolve over time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn now to a use of the FDTD method by producing an animation of the
    fields for the radiation produced by an oscillating current density.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An accelerating charge radiates. In other words, an accelerating charge creates
    wavelike electric and magnetic fields that emanate away from the source charge.
    We can track how the electric and magnetic fields evolve in time by solving the
    Maxwell equations using the FDTD method we developed.
  prefs: []
  type: TYPE_NORMAL
- en: Current Density
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll produce an animation of the electric field produced by
    an oscillating current density. Our current density will be localized in space,
    and we’ll center our coordinate system on the current density. There are several
    ways we could produce a localized current density. Since we have discretized space
    in the FDTD method, one way to specify a localized current density is to allow
    the current density to be nonzero at a single location in the FDTD grid. Slightly
    more convenient for us is to specify a current density that extends over several
    grid points but quickly drops off with distance from its center.
  prefs: []
  type: TYPE_NORMAL
- en: One function that drops off in this way depends on the distance *r* from the
    origin as *e*^(–*r*²/*l*²). Such a function is called a *Gaussian*. Its largest
    value is at the origin, and its value decreases with distance from the origin.
    The parameter *l* has dimensions of length and gives a sense of the region over
    which the value is significant. At *r* = *l*, the Gaussian value is 36.8 percent
    of its value at the origin. At *r* = 2*l*, its value is only 1.8 percent of its
    value at the origin. And by *r* = 3*l*, its value is only about a hundredth of
    a percent. Equation 29.29 gives the current density we use for our radiation animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/571equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need three parameters to fully specify this current density: an amplitude
    *J*[0], a localization length *l*, and a frequency *f* . We can think of this
    current density as representing a charge at the origin that is oscillating in
    the z-direction.'
  prefs: []
  type: TYPE_NORMAL
- en: The function `jGaussian` describes the current density in Equation 29.29.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function `jGaussian` uses some local variables to specify its behavior.
    We wish for the oscillation to occur with a frequency that will produce radiation
    with a wavelength of 1.08 m. The frequency (in Hz) is the speed of light divided
    by the wavelength. We chose an amplitude of 77.5 A/m² because this radiates about
    100 W of power. We chose the parameter *l* to be 0.108 m, which is the same value
    we will choose later for the spatial step size of the grid. This means that only
    grid points near the origin will contain any significant current density.
  prefs: []
  type: TYPE_NORMAL
- en: Having decided on a current density to serve as the source of our electric and
    magnetic fields, we turn to a few comments about the boundary of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Grid Boundary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The FDTD method uses a finite grid that keeps track of the electric and magnetic
    fields at a finite number of places. We use neighboring grid points to calculate
    the curl needed by the Maxwell equations, as explained earlier. What happens at
    the edges of the grid? The simple choice we made is to assume that electric and
    magnetic fields beyond the grid are 0\. This choice is enforced by the lookupAZ
    function, which returns 0 for any point off the grid. While this choice is simple
    and seems reasonable, it has some undesirable properties. An outgoing wave will
    reflect at the edge of the grid, bounce back, and interfere. However, if the grid
    is very large, the amplitude of the reflected wave may be very small and its presence
    may be tolerable. In our case, we display only a portion of the grid on which
    calculations occur. Our animation terminates before the wave hits the boundary,
    so we do not see any reflected wave. In general, the results obtained using our
    simple boundary conditions are only valid until the wave propagates to the edge
    of the grid. There are more sophisticated methods available for dealing with the
    boundary conditions at the edge of the grid. One way is to model a material that
    absorbs all of the radiation incident; this more or less acts like an infinite
    box, without requiring computing an infinite number of points. The book by Inan
    and Marshall [**[18](bib.xhtml#bib18)**] has a nice discussion of boundary conditions
    for the FDTD method.
  prefs: []
  type: TYPE_NORMAL
- en: Even without sophisticated boundary conditions, the calculations we are doing
    are computationally intensive. It could take 20 minutes or more to generate all
    of the PNG files that will be sewn together to produce the final animation. The
    files are produced as the information becomes available, so you can see on your
    own machine how many files are produced in a minute and estimate how long the
    entire batch will take.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to turn to the question of producing frames for the asynchronous
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: Display Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want a function that will produce a picture given a `StateFDTD`. The function
    `makeEpng` serves this role. It produces a PNG graphics file from a state of the
    electromagnetic field. We intend to produce one such graphics file at each time
    step and then sew them together into an animation. The picture we produce in `makeEpng`
    is that of the electric field in the xz-plane. We use shading to indicate the
    strength of the field, transitioning from one color (usually black or white) indicating
    a zero field to another color indicating some maximum strength.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The function `makeEpng` takes a pair of colors as input, as well as a pair containing
    an integer `n` and the state of the electromagnetic field. The color pair consists
    of a strong color `scol` for the color of the strongest fields and a zero color
    `zcol` for the color of a zero field. The integer `n` that is paired with the
    state serves as part of the name of the PNG file.
  prefs: []
  type: TYPE_NORMAL
- en: The function `makeEpng` uses local variables to name the PNG file, the threshold
    for a strong electric field, and a list of electric field values to be displayed.
    The local name `pngFilePath` is a `String` whose value is the name of the PNG
    file to be produced. This name is *MaxVF* followed by three digits from the integer
    `n`, followed by *.png*. We use the threshold `strongE` for a strong electric
    field to choose the display color for each electric field arrow. We color electric
    field values of 176 V/m or higher with the strong color `scol`, values of 0 with
    the zero color `zcol`, and values in between with a blend of the two colors.
  prefs: []
  type: TYPE_NORMAL
- en: The list `vs` has type `[((R,R),(R,R))]` and contains the two-dimensional locations
    and components of the electric field to be displayed. The function `getAverage`,
    defined next, takes a triple of even integers as input and averages the values
    on either side of the Yee cell to produce a vector at a single point in space.
    Finally, we use the function `gradientVectorPNG`, defined below, to make the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Two Helping Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function `getAverage`, used in `makeEpng` earlier, produces field vectors
    at particular locations by averaging the values around the location. Since the
    Yee cell stores different field components at different locations, we might ask
    whether there is any natural way to recombine the components into a single vector.
    The answer is yes, as long as we are willing to use the average of the values
    at two locations. At any point in the Yee cell labeled by an even-even-even triple,
    electric field components are stored at each adjacent location. By averaging these,
    we can produce an electric field vector at any even-even-even location. Similarly,
    we can produce a magnetic field vector at any odd-odd-odd location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function `getAverage` takes an integer triple as input, which should be
    either even-even-even for an electric field or odd-odd-odd for a magnetic field,
    along with a lookup table, and produces a vector. It does this by sampling the
    six locations adjacent to the input location, averaging the values in each direction,
    and putting the averaged components into a vector.
  prefs: []
  type: TYPE_NORMAL
- en: The function `gradientVectorPNG`, used by `makeEpng` earlier, is similar to
    `vfGrad` from [Chapter 22](ch22.xhtml). It produces a gradient vector field picture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `gradientVectorPNG` takes three inputs: a name for the PNG file,
    a pair of colors to use, and a list of two-dimensional vector locations and components.
    It gives the local name `fileName` to the string given as a name for the PNG file.
    It gives the local names `scol` and `zcol` to the strong color and zero color
    to be used in the picture. The list `vs :: [((R,R),(R,R))]` gives the locations
    (first pair of real numbers) and components (second pair of real numbers) of the
    vectors to be displayed. The magnitudes of these two-dimensional vectors are expected
    to be in the range 0 (which will get the zero color) to 1 (which will get the
    strong color).'
  prefs: []
  type: TYPE_NORMAL
- en: The function `gradientVectorPNG` assigns the local name `maxX` to the largest
    value of *x* describing the locations of the arrows. The local function `normalize`
    takes an (*x*,*y*) pair as input and returns a pair in the square from (–1, –1)
    to (1, 1). The function `normalize` assumes that the region to be displayed is
    a square patch in the xy-plane centered at the origin. The local list `array`
    contains the normalized locations at which arrows are to be placed, along with
    the magnitude and orientation of each arrow.
  prefs: []
  type: TYPE_NORMAL
- en: The function `arrowMagRadColors` is a helping function that produces a diagram
    of a single arrow. We define it as a local function because `gradient` `VectorPNG`
    is the only function that uses it. Since it is a local function, it can use the
    local colors `scol` and `zcol` without these colors being inputs to `arrow` `MagRadColors`.
    The function `arrowMagRadColors` expects the magnitude of arrows to be in the
    range from 0 to 1, assigning the zero color to 0 and the strong color to 1.
  prefs: []
  type: TYPE_NORMAL
- en: We use the local variable `step` to scale the size of the arrows. It is based
    on the number of arrows to be displayed on each horizontal row, that number being
    equal to the square root of the total number of arrows to be displayed over the
    entire square. The local variable `pic` holds the entire picture that the final
    line of the function renders.
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 29-2](ch29.xhtml#ch29list2) sets the time step size, the number of
    time steps to be taken, and the spatial step size through its specification of
    the initial state.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 29-2: Stand-alone program to produce PNG files for an electric field
    animation*'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the `sequence_` function, described in [Chapter 20](ch20.xhtml), to
    turn a list of actions into a single action. Since the function application operator
    `$` is right associative (recall [Table 1-2](ch01.xhtml#ch1tab2)), it’s easiest
    to read the definition of `mainPNGs` from right to left. The rightmost phrase,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: is an infinite list of states, starting with an initial state in which the electric
    and magnetic fields are 0 everywhere and the spatial step size in each direction
    is 0.108 m. Applying `zip [0..numTimeSteps]` to this infinite list produces a
    finite list, each element being a pair of an integer with a state. Applying `map
    (makeEpng (yellow,black))` to this list of pairs produces a finite list with type
    `[IO ()]`. Finally, applying `sequence_` converts the list of actions into a single
    action. This program will produce 720 files, named *MaxVF000.png* through *MaxVF719.png*,
    that we can combine into an MP4 movie with an external program such as ffmpeg.
  prefs: []
  type: TYPE_NORMAL
- en: The following command asks the external program ffmpeg to combine all PNG files
    named *MaxVFDDD.png*, where the capital Ds are digits. We ask for a frame rate
    of 25 frames/second. The final movie is called *MaxVF.mp4*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use a spatial step size of 0.108 m because it is one tenth of the wavelength
    we expect from our current density. 10 spatial steps per wavelength is about the
    smallest I’d like to go. More spatial steps per wavelength would produce more
    accurate results but would take longer to run, assuming we increase the number
    of grid points to allow the same number of wavelengths to fit across the grid.
  prefs: []
  type: TYPE_NORMAL
- en: The time step needs to be a bit smaller than the time it takes light to travel
    one spatial step; otherwise, the method becomes unstable. (See [**[18](bib.xhtml#bib18)**]
    for details on the stability criterion.) It takes light about 0.36 ns to travel
    one spatial step. Our time step of 0.02 ns is plenty small to avoid instability.
    Of course, a smaller time step produces more accurate results at the cost of longer
    computation time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 29-3](ch29.xhtml#ch29fig3) shows one of the frames of the animation,
    except that we used black as the strong color and white as the zero color.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/577fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 29-3: Electric field obtained by solving the Maxwell equations using
    the current density `jGaussian`. The image is one of the frames produced by the
    main program and shows the xz-plane.*'
  prefs: []
  type: TYPE_NORMAL
- en: The wavelike nature of the electric field is apparent. The magnetic field, not
    shown in [Figure 29-3](ch29.xhtml#ch29fig3), points into or out of the page. The
    magnitude of the electric field decreases with distance from the source at the
    center. The radiating electric field is stronger in the *z* = 0 plane and weaker
    above and below the source in the z-direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we saw how the Maxwell equations describe the evolution of
    electric and magnetic fields. We identified four relationships between electricity
    and magnetism, and we explained how the Maxwell equations relate to our description
    of electric and magnetic fields in previous chapters. We saw how the Maxwell equations,
    like Newton’s second law, can be viewed as rules for a state-update technique.
    We described the FDTD method for solving the Maxwell equations, and we applied
    it to the radiation produced by an oscillating charge and current density. We
    produced an animation of the wavelike electric field generated by an oscillating
    current density.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered a lot of ground in this book. Many of the ideas are really cool
    but not so easy to grasp right away. If you’re like most people, you’ve understood
    some things and gotten stuck on others. Patience and perseverance are my advice
    when you’re stuck. Patience is especially important, and it sometimes means skipping
    ahead to the beginning of the next section or chapter. I’ve had books on my shelves
    that were unreadable for years, but somehow I got the background I needed and
    then one day I could read them.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you’ve enjoyed the introduction to computational physics in Haskell that
    this book provides. You can, of course, do computational physics in any programming
    language you like. You would learn a lot by translating the work we’ve done here
    into another language. Let’s take a brief look back at what we’ve done to recall
    the benefits of a functional language for physics. A pure functional language
    allows and encourages us to express what is central and important in a single
    function. The function `newtonSecondPS` from [Chapter 16](ch16.xhtml) expresses
    Newton’s second law. The function `maxwellUpdate` in this chapter expresses the
    Maxwell equations.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functional programming provides a simpler model of computation than imperative
    languages like Python since names (variables) refer to quantities that never change.
    This encourages the naming of verbs (functions) that change nouns, rather than
    giving names to nouns that change. Physics is a natural candidate to take advantage
    of pure functional writing because the central ideas of physics, like Newton’s
    second law and the Maxwell equations, are expressible as verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, a typed functional language allows us to express with precision the
    nature of the verb a function describes. The type of `newtonSecondPS` expresses
    that we can produce a differential equation from a list of one-body forces. The
    type of `bFieldFromLineCurrent` from [Chapter 27](ch27.xhtml) expresses that we
    can calculate a magnetic field from a curve and a current.
  prefs: []
  type: TYPE_NORMAL
- en: The effectful functions we’ve written, those like `gradientVectorPNG` with `IO
    ()` in their type that *do* something, are certainly useful for producing graphs
    and animations, but they are not really part of the “elegant code” promised in
    this book’s subtitle. Haskell is as powerful as any other language for doing these
    things, but the real strength of a functional language for physics lies in the
    elegant expression of its central ideas, which are purely functional. Programming
    in a functional language has allowed me to write code that parallels the organization
    of the subject in my mind. I find that it helps me to think about the subject.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of writing physics in a functional language is in its infancy.
    Two advanced books on the subject are [**[20](bib.xhtml#bib20)**] and [**[11](bib.xhtml#bib11)**].
    There is a lot more to discover about what physics and functional programming
    can offer each other. I hope you continue to explore these areas if they interest
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 29.1.** Use `gnuplot` to graph the Gaussian function'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/579equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for several values of *l*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 29.2.** Modify the main program and the function `makeEpng` to produce
    an animation of the magnetic field in the xy-plane produced by the current density
    `jGaussian`. Try using 10^(–6) T as the threshold for a strong magnetic field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 29.3.** The current density'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/579equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: has an oscillating magnetic dipole moment, while that of Equation 29.29 has
    an oscillating electric dipole moment. The radiation produced by the current density
    of Equation 29.30 is called magnetic dipole radiation. Produce an animation of
    the magnetic field in the xz-plane. It should look similar to the electric field
    animation we made for the electric dipole radiation from the current density of
    Equation 29.29\. Try using 2 × 10^(–7) T as the threshold for a strong magnetic
    field.
  prefs: []
  type: TYPE_NORMAL
