- en: '![Image](Images/f001-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: '1'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Leaf Me Alone!: Scratch Basics'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Scratch is neat tool for making animations, games, and movies. In this book,
    we’ll focus on making games, so our projects will be playful and interactive.
    Scratch is mostly self-contained: for example, if you need a character for your
    game, you can draw it directly in Scratch or upload an image you already have.
    You can also choose one of the built-in Scratch characters.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Scratch’s simple, block-based programming language to code the interactive
    parts of our game. Scratch uses a system of blocks that represent different functions.
    They snap together like puzzle pieces into complete lines of code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f002-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: '*How Scratch code blocks fit together*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: These stacks of code blocks tell the objects in your games what to do. As you’ll
    see shortly, using code blocks in Scratch is very easy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Scratch
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin, you need to sign up for your own Scratch account. It’s free, and after
    you’ve registered, you can start saving and sharing your games. In your web browser,
    open the official Scratch website at *[https://scratch.mit.edu/](https://scratch.mit.edu/)*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: On the Scratch website, click **Join Scratch** in the upper right. When asked,
    add your email address and some information about yourself. Then you’ll get an
    email asking you to confirm your email address. Check your inbox and click the
    link in the email. Bam! You should now have your own Scratch account.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f003-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: '*The Scratch home page*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create** button at the top of the Scratch home page if you’re not
    already in Scratch’s editor. You’ll see a blank white box with a smiling orange
    cat, as shown in the following figure. This box is the game window, which is the
    only part of the editor your players will see. The cat is your first sprite. Let’s
    talk about what a sprite is and what you can do with it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f003-02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: '*Opening the Scratch editor*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: That orange cat is `Scratchy`, Scratch’s mascot. With every new Scratch project,
    `Scratchy` is automatically included in a noble effort to encourage more people
    to make games about cats.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Does `Scratchy` love lasagna? Does `Scratchy` hate Mondays? No one knows. But
    we *do* know that `Scratchy` is a *sprite*, which is any object in a Scratch game
    that can do something, like change its appearance or play music. Each sprite can
    have scripts, costumes, and sounds attached to it. A *script* is a group of coding
    blocks that fit together, telling the sprite what to do. A *costume* is a snapshot
    or a frame of a sprite that you can use to create animation. For example, the
    pose `Scratchy` is in right now is one of two default costumes that come with
    `Scratchy`. Click the **Costumes** tab on the top left (between Code and Sounds)
    to see the `Scratchy` sprite’s costumes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f004-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Scratchy *comes with two costumes*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: When you flip between the two costumes by clicking one and then the other like
    a flip book, `Scratchy` should look they’re walking. We’ll use costumes to animate
    our sprites or change their appearance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Sprites can also have sound effects that they can play. For example, `Scratchy`
    comes with a meow sound. Click the **Play** button in the Sounds tab to hear it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f005-01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Leaf Me Alone (While I Eat This Leaf)
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll create a simple game in Scratch called *Leaf Me Alone (While I Eat This
    Leaf)*. It’s about a hungry little bug who wants to eat a leaf and wants to do
    so in solitude. You can first play it at *[https://scratch.mit.edu/projects/117199134/](https://scratch.mit.edu/projects/117199134/)*,
    and then we’ll create it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f005-02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '*Exploring the* Leaf Me Alone *game*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Click the green flag to start the game. The little bug starts moving forward
    automatically! Press the left or right arrows to make the bug change direction.
    As the bug eats the leaf, it leaves a trail of munches behind. This hungry little
    bug never stops munching. When you want to stop the game, click the red stop sign
    in the upper-right corner. If you click the green flag again, the game will start
    over.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: It seems pretty simple, right? Now, let’s make this game from *scratch*!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Sprites
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need to draw your *own* sprites for the *Leaf Me Alone* game. One of
    Scratch’s cool features is that you can use the mouse to draw characters for your
    game. Then you can give them instructions to make them do different things. It’s
    okay if they turn out messy or imperfect. Don’t worry!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `Scratchy` and click **Delete**. *Zoink!* `Scratchy` disappears.
    (You won’t really hear a *zoink* sound. I made that part up.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Next, look at the Sprites list below the game window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f006-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: '*Opening the Sprites list*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The *Stage*, which is currently a plain white rectangle, is the background for
    the game. When you click it, it should be surrounded by a blue highlight. Because
    we deleted `Scratchy`, no sprites are in our Stage right now. Let’s fix that by
    adding a new sprite!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Hover over the cat icon below the Stage to display four more buttons. Click
    **Choose a Sprite** to select a sprite from the Sprites Library. The Paint button
    lets you create your own sprite. The Surprise button selects a random sprite,
    and the Upload button lets you use an image from your computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Weird Bugs
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s click the **Paintbrush** to draw a sprite for our game. Then click the
    **Costumes** tab. Now you’re in the costume window where you can draw a costume
    for your new sprite.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f007-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: '*Drawing a new costume for your bug*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of the drawing area is a menu of drawing tools. Make sure the
    paintbrush is selected. On the top of the drawing area is a color selector. To
    the right of the paintbrush icon is a number you can change to control the size
    of the paintbrush.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'I drew a caterpillar, but you can draw any kind of bug you’d like. You should
    see a tiny plus sign (+) in the middle of the drawing area. That is the center
    point of the sprite: draw the bug’s head there so its head is about the size of
    the plus sign (+).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我画了一个毛毛虫，但你可以画任何你喜欢的虫子。你应该在绘图区域中看到一个小的加号（+）。那是角色的中心点：把虫子的头画在那里，让它的头部大约和加号（+）一样大。
- en: '![Image](Images/f008-01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f008-01.jpg)'
- en: That’s a pretty small bug! To make drawing easier, use the magnifying glass
    buttons in the lower right to zoom in so you can see the bug better. The magnifying
    glass with the plus sign (+) zooms in, and the minus sign (–) zooms out. You can
    see what your sprite looks like at its normal size by looking over at the game
    window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那只虫子真小！为了让绘图更容易，可以使用右下角的放大镜按钮进行缩放，这样你就能更清楚地看到虫子了。带加号（+）的放大镜可以放大，带减号（–）的放大镜可以缩小。你可以通过查看游戏窗口来看到角色在正常大小下的样子。
- en: You can make your bug look however you want, but make sure it’s facing toward
    the right. Scratch will automatically rotate your bug as it walks around the leaf,
    but sprites should always start by facing toward the right. So, if you want to
    give your bug a big weird butt, make sure its butt is pointing to the left side
    in the opposite direction of the head.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意设计你的虫子外观，但一定要确保它朝向右边。Scratch 会在虫子绕叶子走动时自动旋转它，但角色应该总是从朝向右边开始。所以，如果你想给虫子设计一个奇特的大屁股，确保它的屁股朝向左边，和头部的方向相反。
- en: If you make a mistake while drawing your sprite, click the Undo button, which
    is the left arrow above your drawing. This button will undo the last change you
    made. If you decide you didn’t want to undo the change, you can click the Redo
    button, which is the right arrow at the top of your drawing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在绘制角色时犯了错误，点击撤销按钮，它是你绘图区上方的左箭头。这个按钮会撤销你刚才的操作。如果你决定不想撤销那个操作，可以点击重做按钮，它是绘图区上方的右箭头。
- en: When you’re happy with your bug, look at the Sprites list below the Stage again.
    Your bug should be there now, but it will be called `empty`. That’s not the best
    name for a bug, but you can change it. Enter your new name into the Sprite field
    just below the stage. Change its name to something like `weird bug` or `my perfect
    creation`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对虫子的外观满意时，再次查看舞台下方的角色列表。你的虫子应该出现在那里，但它会被命名为`empty`。这个名字对虫子来说并不合适，但你可以更改它。在舞台下方的角色字段中输入你新的名字。可以把它改成像`奇怪的虫子`或`我的完美创作`之类的名字。
- en: Drawing a Backdrop
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制背景
- en: The Stage is a lot like a sprite in that it also has its own scripts, costumes,
    and sounds. Costumes for the Stage are called *backdrops*. Any image you create
    for the Stage becomes the backdrop for the entire game window. You can make multiple
    backdrops and switch between them at different moments in your game. For example,
    the first level of your game could take place in a forest, and the second level
    could take place underwater. For *Leaf Me Alone*, we need only one backdrop because
    there is only one level. Let’s draw it now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 舞台和角色很像，它也有自己的脚本、服装和声音。舞台的服装叫做*背景*。你为舞台创建的任何图像都会成为整个游戏窗口的背景。你可以制作多个背景，并在游戏的不同时刻之间切换它们。例如，游戏的第一关可能发生在森林中，第二关可能发生在水下。对于*Leaf
    Me Alone*，我们只需要一个背景，因为只有一关。让我们现在就绘制它。
- en: Click the **Stage** (the blank white rectangle) to the right of the Sprites
    list. The Stage should show the text `1 backdrop` below it. Below that is a blue
    button with a stage icon that works just like the Choose a Sprite button. Hover
    over it to show four buttons that do the same things as the Sprite buttons but
    for backdrops.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**舞台**（角色列表右侧的空白白色矩形）。舞台下方应该显示`1个背景`字样。其下是一个蓝色按钮，带有舞台图标，它的功能和选择角色按钮一样。将鼠标悬停在上面会显示四个按钮，功能与角色按钮相同，但适用于背景。
- en: 'Instead of making a new backdrop, we’ll just paint over the empty white one
    we started with. If you’re not in the drawing window, click the **Backdrops**
    tab. Let’s draw the background for the game: a big juicy leaf for the bug to eat.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算制作一个新的背景，而是直接在我们开始时使用的空白白色背景上绘制。如果你不在绘图窗口中，点击**背景**选项卡。现在让我们绘制游戏的背景：一片大大的多汁的叶子，供虫子食用。
- en: If you zoomed in to draw the bug, you might still be zoomed in. Click the button
    in between the two magnifying glasses (**=**) to go back to normal view. You should
    see the entire backdrop. If you can see sliders around the edges to scroll the
    view, it means you’re still zoomed in.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大画面以绘制小虫，你可能仍然处于放大视图。点击两个放大镜中间的按钮 (**=**) 以恢复到正常视图。你应该能够看到整个背景。如果你能看到边缘的滑动条来滚动视图，这意味着你仍然处于放大状态。
- en: '![Image](Images/f009-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f009-01.jpg)'
- en: '*Drawing the leaf backdrop*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*绘制叶子背景*'
- en: 'We’ll use two colors for this backdrop: one for the background and one for
    the leaf. (I used sky blue for the background and leaf green for the leaf.) Using
    just two colors here will be important when you write your program later, so make
    sure not to add more colors right now. You can also rename the background by clicking
    the text `backdrop1` in the text field and entering a new name.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种颜色来绘制这个背景：一种用于背景，另一种用于叶子。（我使用了天蓝色作为背景色，叶绿色作为叶子色。）现在使用两种颜色在这里非常重要，等你以后编写程序时，这一点会特别有用，所以现在不要添加更多颜色。你还可以通过点击文本框中的
    `backdrop1` 来重新命名背景，并输入一个新的名称。
- en: Now that we have our bug and our leaf, it’s time to get our bug moving.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了小虫和叶子，是时候让小虫动起来了。
- en: Using Event Blocks
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用事件积木
- en: Click your bug in the Sprites list, and then make sure you’re in the Code tab.
    The empty area on the right is where we’ll snap our code blocks together to write
    directions for our sprites. On the left are several categories that hold the different
    blocks that we can choose. Click a few of the categories to see which code blocks
    they contain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Sprite列表中的小虫，然后确保你处于代码标签下。右侧的空白区域是我们将积木拼接在一起，编写角色指令的地方。左侧有几个类别，里面包含了我们可以选择的不同积木。点击几个类别，看看它们包含哪些代码积木。
- en: 'For example, click **Events** to view the **Events** blocks, which let you
    sense events and trigger other code blocks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，点击**事件**查看**事件**积木，它们可以让你感知事件并触发其他代码积木：
- en: '![Image](Images/f010-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f010-01.jpg)'
- en: '*Exploring the **Events** blocks*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*探索**事件**积木*'
- en: Most categories are pretty self-explanatory. **Motion** blocks control movement.
    **Looks** blocks change the sprite’s appearance. **Sound** blocks play sounds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类别都很容易理解。**运动**积木控制运动。**外观**积木改变角色的外观。**声音**积木播放声音。
- en: Every stack of programming blocks you’ll write begins with an **Events** block.
    Click **Events** and you’ll see that all the **Events** blocks have big round
    tops. Like a chef following directions to bake a cake, Scratch always reads directions
    from top to bottom. Keep in mind that an **Events** block *always* goes first;
    all other blocks can only attach underneath it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的每一组编程积木都以一个**事件**积木开始。点击**事件**，你会看到所有的**事件**积木都有大圆顶。就像厨师按照指示做蛋糕一样，Scratch总是从上到下读取指令。请记住，**事件**积木*总是*排在第一位；所有其他积木只能附加在它下面。
- en: '![Image](Images/f011-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f011-01.jpg)'
- en: '***Events** blocks always go first (at the top).*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***事件**积木总是排在第一位（最上面）。*'
- en: Events answer the important question *When do I do this?* The **Events** block
    we want to use right now is `when green flag clicked`. Click and drag it into
    the area on the right.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事件回答了一个重要问题 *我什么时候做这个？* 我们现在要使用的**事件**积木是 `when green flag clicked`。点击并拖动它到右侧区域。
- en: Recall that you started the example game by clicking the green flag. The game
    had the `when green flag clicked` event, which tells the program to run the code
    blocks when the player clicks the green flag. Our game will start with this **Events**
    block too. Next, we’ll write code that tells our bug to move.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你是通过点击绿色旗帜开始了示例游戏。游戏有一个 `when green flag clicked` 事件，它告诉程序当玩家点击绿色旗帜时执行代码积木。我们的游戏也将以这个**事件**积木开始。接下来，我们将编写代码，告诉小虫如何移动。
- en: Moving the Bug
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移动小虫
- en: Think of a bug crawling along a wall and the weird, winding path it takes. That
    kind of movement is very easy to replicate. The bug can keep moving forward until
    the player makes it turn to the left or right. To make our bug move, we’ll use
    the blocks Scratch has for moving forward and turning. The player will have to
    do their best to guide the bug as it moves nonstop, making the game fun to play.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一只虫子在墙上爬行，并且它沿着奇怪、弯曲的路径前进。这种运动非常容易模仿。虫子可以继续向前移动，直到玩家让它向左或向右转。为了让小虫移动，我们将使用Scratch提供的前进和转弯积木。玩家必须尽力引导小虫不停地移动，让游戏更有趣。
- en: Let’s start by making our bug move forward. The block that moves a sprite forward
    moves the sprite only one step forward. Because we don’t want the bug to stop
    after just one step, we need to add a loop. A *loop* is a block that makes something
    happen more than once. To make our bug keep moving, we’ll use a loop block to
    repeat a *move* instruction over and over for as long as the green flag is on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Control** category to find all the blocks that handle *branching*,
    which is when you write different scripts that will run in certain situations.
    Think of branching code as branches growing off the main part of your code (the
    trunk). When different actions happen in your game, Scratch will make specific
    parts of the branch run. On their sides, branching blocks have empty slots in
    which to fit other blocks. For example, *looping* is a form of branching that
    can have different outcomes depending on the situation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We want to use the simplest loop, which is a `forever` loop. Once a `forever`
    loop starts, it just keeps running over and over until the game is over. We use
    a `forever` loop because we want our bug to keep moving as long as the game is
    running. Click and drag a `forever` loop to attach it to the bottom of the `when
    green flag clicked` block. A shadow of the block should appear to show you can
    connect it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f012-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: '*Attaching a forever block*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You can put as many other code blocks inside a `forever` loop as you want. The
    loop runs the blocks inside it in order from top to bottom and then jumps back
    to the start of the loop to repeat them. The `forever` loop continues repeating
    the loop until you click the stop sign to end the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add a `move () steps` block into the `forever` loop to move our bug forever.
    You can find this block in the **Motion** category. We’ll also add a block that
    prevents the bug from moving off the Stage, because the player won’t be able to
    see the bug and it might get lost. So, we’ll add an `if on edge, bounce` block
    to the loop that makes the bug change directions when it hits the edge of the
    Stage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Click **Motion**. Click and drag the `move 10 steps` and `if on edge, bounce`
    blocks into the `forever` loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f013-01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: '*Creating a motion loop*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `move 10 steps` block makes a sprite take 10 steps in the direction it’s
    currently facing. Double-click the number 10 to change the number of steps the
    bug will move. A lower number makes the bug move slower. I changed the number
    of steps to 5.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Click the green flag to test your code. The bug should start moving to the right
    until it hits the edge of the Stage; then it will reverse direction and walk back
    to the left, then reverse toward the right again. And on and on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f013-02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: '*Testing your bug’s movement*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: While your game is running, a glow should appear around the stack of code blocks
    you just made. The glow indicates that the bug is currently following the directions
    in that stack. For example, if you didn’t have a `forever` loop, the glow would
    disappear after that stack of code was finished running. You can use this glow
    to keep track of which parts of your code Scratch is running at any given time
    and to help make sure all parts of your program work properly. The glow comes
    in handy when you try to debug your code later on!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Steering the Bug
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our bug can move only in a straight line, but we want the player to use the
    arrow keys to turn the bug left and right. First, we need to check whether the
    player is pressing a key that makes the bug turn. Second, when we know which key
    the player is pressing (left or right arrow), we need to make the bug turn in
    the correct direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use branching again as well as an `if () then` block to check first whether
    the player is pressing a key; then (and only then) will we make our bug turn.
    Again, all the blocks related to branching are in the **Control** category.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Click and drag an if () then block and place it under the `if on edge, bounce`
    block inside the `forever` loop. We put the `if () then` block in our `forever`
    loop so the player can turn the bug as long as the game is still running.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f014-01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: '*Using an if () then block*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal hole in the middle of the `if () then` block holds **Sensing**
    blocks. **Sensing** blocks check whether a specific action has happened, such
    as whether two sprites are touching or whether a player is pressing a key. The
    **Sensing** blocks are pointy and hexagonal, just like the hole they fit into.
    Click and drag the **Sensing** block `if key space pressed?` and place it into
    the hole in the `if () then` block.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Because the space key isn’t the key we want to check for, click the small black
    triangle next to it and choose left arrow from the drop-down menu. The block should
    now show `if key left arrow pressed? then`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses the left arrow key, we want the bug to turn left! In
    the **Motion** category, find the `turn left 15 degrees` block. It should have
    a counterclockwise arrow on it. Drag that block over and snap it onto the bottom
    of the `if key left arrow pressed? then` block. The space between the two blocks
    should light up to show you where the connection will be. Finally, change 15 to
    10 in the `turn left 15 degrees` block to make the left turns a little less sharp.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f015-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: '*Checking whether the player is pressing the left arrow key*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and see if you can make your bug turn in circles by holding down
    the left arrow key! Now let’s make the bug turn right as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `if key left arrow pressed? then` block and select **duplicate**.
    A copy of that block including the `turn left 10 degrees` block inside it should
    appear under your cursor. Place that copied `if () then` block below the preceding
    `if () then` block.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`if key left arrow pressed? then`块并选择**复制**。包含`turn left 10 degrees`块的该块副本应该出现在你的光标下。将这个复制的`if
    () then`块放置在前一个`if () then`块下方。
- en: '![Image](Images/f016-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f016-01.jpg)'
- en: '*Checking whether the player is pressing the right arrow key*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查玩家是否按下右箭头键*'
- en: Be sure to click the black arrow next to `left arrow` and change it to right
    arrow. Then remove the `turn left 10 degrees` block by clicking and dragging it
    back into the block list on the left side. Next, find the **Motion** block `turn
    right 15 degrees` (it has a clockwise arrow). Place this block inside the `if
    key right arrow pressed? then` block and change the number to 10 (otherwise, the
    bug will turn right at a different angle than it does when turning left).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保点击`left arrow`旁边的黑色箭头并将其更改为右箭头。然后通过点击并拖动将`turn left 10 degrees`块移回左侧的块列表。接下来，找到**运动**块`turn
    right 15 degrees`（它有一个顺时针箭头）。将该块放入`if key right arrow pressed? then`块中，并将数字改为10（否则，虫子向右转时的角度会与向左转时不同）。
- en: Test your code again, and make sure pressing the left arrow key turns the bug
    left, pressing the right arrow key turns the bug right, and pressing neither makes
    the bug move straight.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次测试你的代码，确保按下左箭头键时，虫子向左转，按下右箭头键时，虫子向右转，且不按任何键时，虫子直行。
- en: If you hold down the right arrow key and the bug turns left, you forgot to replace
    the block inside the `if key right arrow pressed? then` branch! If the bug keeps
    turning, even when you’re not holding down an arrow key, you put the turning block
    in the main `forever` loop instead of inside the `if () then` branch! Check your
    code blocks against the ones shown in the book to make sure all your blocks are
    in the correct places.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按住右箭头键，虫子却向左转，说明你忘记替换`if key right arrow pressed? then`分支中的块！如果虫子在没有按下箭头键时仍不断转动，说明你把转向块放进了主`forever`循环中，而不是放在`if
    () then`分支里！检查你的代码块与书中显示的代码，确保所有块都在正确的位置。
- en: Chewing Holes in the Leaf Using Pen Blocks
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用笔块在叶子上咀嚼洞口
- en: Now our bug is moving all over the leaf, but it’s not really wreaking a path
    of destruction yet. Let’s make it chew its way through the leaf, leaving a trail
    of bite holes behind it!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的虫子在叶子上四处移动，但它还没有真正地造成破坏。让我们让它咀嚼叶子，留下咬洞的痕迹！
- en: 'To do this, we’ll use the **Pen** blocks. Imagine a mass-produced room-cleaning
    robot with a marker taped to it that moves in a straight line across your kitchen
    floor, scaring your cat: the device would leave a line on the floor behind it,
    showing where it moved. (Don’t try this at home!) Just like this cleaning robot,
    a sprite can use a pen to draw on the backdrop.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用**笔**块。想象一下一个大规模生产的房间清洁机器人，上面贴着一个记号笔，它在厨房地板上直线移动，吓到你的猫：设备会在地板上留下轨迹，显示它移动过的地方。（不要在家里尝试这个！）就像这个清洁机器人一样，一个精灵可以用笔在背景上画线。
- en: We’ll draw the color of the sky onto the leaf, making it look like the bug has
    chewed holes through it. That’s why it was important to make the background behind
    the leaf just one color!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在叶子上画出天空的颜色，使它看起来像是虫子咬破了叶子。这就是为什么要将叶子背景设为单一颜色的重要原因！
- en: To add the **Pen** blocks, click the blue button at the bottom-left corner of
    the screen. This should pull up a library of Extensions. Click the **Pen** extension
    to add it. We need to place all the **Pen** blocks *before* the `forever` loop,
    not inside it, because we want them to happen only once at the start of the game.
    Think of this part of the code as the setup area.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加**笔**块，点击屏幕左下角的蓝色按钮。这将弹出一个扩展库。点击**笔**扩展以将其添加。我们需要将所有的**笔**块放置在`forever`循环之前，而不是里面，因为我们希望它们仅在游戏开始时执行一次。可以将这一部分代码看作是设置区域。
- en: '![Image](Images/f017-01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f017-01.jpg)'
- en: Add the `set pen color to` block. We’ll set the pen color to the color of the
    sky by clicking the colored box in the `set pen color to` block, clicking the
    dropper at the bottom of the menu that pops up, and then clicking the backdrop
    of the Stage. Add the `set pen size to` block and change the size to 5 because
    that seems like a reasonable size for the bug’s mouth. Then add the `pen down`
    block to start drawing, similar to lowering a pen to paper. (The `pen up` block
    stops drawing.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there is a `set pen size to` as well as a `change pen size by` block.
    *Setting* makes the pen size a specific value, such as 1, 10, or 187\. *Changing*
    adds a number to that pen size. If the pen size is 1 and you use a `set pen size
    to 1` block, the pen size is still 1\. If the pen size is 1 and you use a `change
    pen size by 1` block, the pen size is 2 because you’ve added 1 to 1\. Don’t get
    them mixed up!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f018-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '*Adding the **Pen** stack before the loop*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: After you have all your **Pen** blocks in place, click the green flag. The bug
    should now leave a trail through the leaf as it chews. Using the arrow keys, try
    making the bug chew big, curving lines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f019-01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '*The bug leaves a trail of blue that makes it look like the bug is chewing
    through the leaf!*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Our bug is making lines through the leaf now, but the lines look a bit too neat
    and smooth to be holes left behind by a hungry bug. Let’s make the line a little
    *chompier* by changing the line as it’s drawn.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f019-02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Click another `set pen size to` block (*set* not *change*) and drag it into
    the `forever` loop, as shown here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f020-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Varying pen size to make bug bites look more realistic*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We want the `set pen size to` block inside the `forever` loop so we can change
    the size again and again, every time the bug moves. We’ll change it at random.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: You already know that you can change a number that is in a hole in a block by
    entering another number. Well, some Scratch blocks can also calculate numbers
    using the numbers you fill in. Those blocks are in the **Operators** category,
    as shown here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f020-02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: '***Operators** blocks*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Operators** blocks perform mathematical operations. Any rounded block can
    fit into a round hole in any other block (including other rounded blocks!). The
    first four blocks perform simple mathematical functions: addition, subtraction,
    multiplication, and division. We’ll use the fifth block: click `pick random 1
    to 10`, and drop it directly over the number 1 on the `set pen size to 1` block,
    as shown here. Any rounded block can fit into a round hole in any other block
    (including other rounded blocks!).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f021-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '*Randomizing pen size*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `pick random` operator picks a random number between the two numbers you
    specify. In our code, the number could be between 1 and 10 but could also include
    the numbers 1 and 10\. With this block as part of our `forever` loop, every time
    the bug moves the pen size will change.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Now the trail that the bug leaves should look like it’s made up of individual
    bite marks because each chomp will be a slightly different size. Click the flag
    and see what happens!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f022-01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: '*Using randomized pen lines to make bug bites look more realistic*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The new lines look chompier—*nice*!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: But notice that all the old chomp lines from the bug’s previous meals still
    appear. They never go away! Let’s add some instructions to make sure the game
    starts with a clean leaf every time we run it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Starting Fresh Each Game
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To refresh the game each time it starts, we’ll add three blocks to the setup
    part of our code: the part before the `forever` loop starts. The setup code runs
    once when the game starts and never again until the game starts over.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two blocks we need to refresh our game are the **Motion** blocks
    `go to x: y:` and `point in direction`. The two blocks make sure the bug always
    starts in the same position. The third block we need is a **Pen** block called
    `erase all`, which we’ll use to clear the trail the bug drew in the previous game.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f023-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: '*Code blocks to refresh the game*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Using the Grid
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `go to x: y:` block moves a sprite to any position on the screen, which
    you define using two numbers *x* and *y*. In Scratch, we use numbers on a grid
    to locate the position of different objects. Imagine an invisible grid over the
    Stage. This grid is made up of two number lines that intersect at the center of
    the screen. The numbers on the horizontal line (*x*) increase to the right and
    decrease to the left. The numbers on the vertical line (*y*) increase up the line
    and decrease down the line. Any numbers to the left of the center point on the
    horizontal number line or below the center point on the vertical line are negative.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The value *x* is the sprite’s place along the horizontal line, and *y* is its
    place on the vertical line. Every possible position on the screen has an *x*-coordinate
    and *y*-coordinate that indicates how far it is from the center of the screen.
    For example, in the bottom-right corner of the game screen, you’ll see the *x*-
    and *y*-coordinates showing the current position of your mouse. Watch how these
    numbers change as you move your mouse around the screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f024-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '*Tracking the location of your mouse with x- and y-coordinates*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Setting Your Bug’s Starting Position
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `go to x: y:` block always starts with the current position of the sprite.
    (Try dragging and dropping the bug in different places on the screen; the numbers
    in the `go to x: y:` block will change.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to set the bug’s starting position is to first drag the bug to
    wherever you want it to start at the beginning of the game. Then drag the `go
    to x: y:` block into your stack in the setup area. The coordinates of the bug’s
    current position will be filled.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Setting Your Bug’s Starting Direction
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `go to x: y:` block sets the bug’s starting position but doesn’t affect
    the bug’s starting direction. To set the bug’s starting direction, you need to
    use the `point in direction` block. Click the triangle on the `point in direction`
    block and, from the drop-down menu, choose 90, the direction we want the bug to
    start in.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Every direction has a number associated with it. In Scratch, when the bug turns,
    its direction number changes. The direction number is the angle the sprite is
    facing. Imagine a circle that has a number line wrapped around its circumference
    with the sprite positioned in the middle of the circle. The sprite’s direction
    at 0 means it’s facing straight up (the very top of the circle). Each number is
    called a *degree*, and the angle of the circle can range from 0 to 360 degrees.
    As the degree number changes, the sprite changes the direction it’s facing. For
    example, 90 degrees changes the sprite’s starting direction to the right, which
    is the direction we want the sprite to face when the game starts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f025-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '*The sprite’s direction in degrees*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the Background
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `erase all` block clears all the pen marks that have been drawn so far,
    making our leaf pristine and new again. Place the `erase all` block directly below
    the `go to x: y:` block and `point in direction` block at the beginning of your
    stack so they run first when a player clicks the green flag.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Click the green flag to run the game and make sure all the blocks work. Click
    the flag a few more times to reset the game each time. Your game should start
    in the same condition every time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Contact Between the Bug and the Leaf
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To really sell the idea that the bug is tearing right through this leaf, let’s
    play a munching sound effect whenever the bug is chewing on it. To do that, we
    first need to check whether the bug is touching the leaf. If we played the sound
    *all the time*, whether or not the bug was on the leaf, it wouldn’t match what
    was happening onscreen. So we want to be sure to check for contact between the
    bug and the leaf.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: To check for contact, we’ll use one **Control** block and one **Sensing** block
    to branch our code when the bug is on the leaf, just like we checked for a left
    or right arrow keypress earlier. To keep our stack neat, we’ll add a second `when
    green flag clicked` block instead of adding to the existing one. As a result,
    we’ll have two identical stacks that begin with the `when green flag clicked`
    block.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating two stacks like this works well. In fact, you can have as many identical
    events as you want. When you click the green flag to start the game, *all* the
    `when green flag clicked` events will run at the same time. You’ll find this technique
    useful when you want to run multiple loops with different timings or when you
    just want to organize the code, like we’re doing now.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Start the new code stack by clicking and dragging a new `when green flag clicked`
    block from **Events.** Put it next to the other one, creating a new stack. Then
    give it its own `forever` block. We use the `forever` block because we want the
    bug to keep checking whether it’s touching the leaf during the entire game. Inside
    the `forever` block, place an `if () then` block.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the bug is touching the leaf, add the `if touching color ?
    then` block inside the `if () then` block. When you click the colored box in the
    block, a menu pops down; click the dropper and then the leaf, and the color in
    the box should change to the color in the leaf.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f026-01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: '*Checking whether the bug is touching a color*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Because we drew the leaf using just one color, we only have to check that the
    bug is touching that color. Next, we’ll add the sound we want to play inside the
    branch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Playing Sounds
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Click the **Sound** blocks category and drag the `play sound pop until done`
    block into the `if touching color ? then` branch. In Scratch, sprites come with
    the `pop` sound by default. You can click the Sounds tab to play the sound.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f027-01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '*Playing the pop sound effect*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: A sprite can have multiple scripts and costumes attached to it, and it can have
    multiple sounds as well. Right now the only sound our bug has is `pop`, but that’s
    not a sound a bug might make while eating a leaf. Let’s find a better sound.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Scratch comes with a huge library of sound effects, such as beatboxing, animal
    sounds, and music. Click the **Choose a Sound** button to add a sound. Hover over
    it to display the other options. The Record button lets you record a sound, the
    Surprise button selects a random sound for you, and the Upload button lets you
    upload a sound from your computer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f028-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '*Exploring the Sound Library*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a ton of sounds in the Sound Library! Click the **Animals** category
    to narrow the list down. Listen to sounds by hovering over them. Try to find a
    bug munching sound. When you find a sound you like, double-click it to add it
    to your sprite’s sounds. Try the `chomp` sound for this example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f028-02.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Now that your bug has its new sound effect, return to the Code tab. Click the
    triangle on the `play sound until done` block to change the sound from `pop` to
    `chomp`. Your bug should now play the chomping sound effect while eating the leaf.
    Run the game to hear what it sounds like!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: It sounds a little weird—definitely not the same as the preview! The game plays
    the entire sound effect only *after* the bug moves off the leaf. The reason is
    that the bug tries to play its sound whenever it’s in contact with the leaf; however,
    the sound restarts *every moment* the bug is in contact with the leaf, down to
    a fraction of a second. So it sounds like a continuous drone instead of a series
    of distinct sounds. We need to use the **Control** category’s `wait` block to
    make the bug wait just long enough for the entire sound effect to play before
    replaying the sound.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `wait 1 seconds` block into your stack, just above the `if () then`
    block. Place it *before* the branch, not inside it. Otherwise, it will check whether
    the bug is touching the leaf *and then* wait one second before playing the sound.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: One second is a bit too long between chomps. Instead, let’s try using 0.2 seconds,
    which is two-tenths of a second. One complete second is a surprisingly long amount
    of time in a game!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f029-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Waiting before replaying the sound effect*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now. With a 0.2 second delay between chomps, the chomps should
    sound a whole lot better. *Chomp chomp chomp chomp chomp chomp chomp*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Your Code
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our game is basically complete, but let’s take a moment to think about how best
    to lay out the Code area visually. Where should you put the instructions for your
    sprite in the Code area? Blocks need to be connected in the right places or they
    won’t work correctly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Right now, I’m not talking about situations where there’s an obvious right answer.
    I’m talking about the decisions that don’t affect how your code runs, but *do*
    affect how it looks when someone is reading it. For example, when you use two
    different `when green flag clicked` stacks, where should you place them? Do you
    put one below the other? Or perhaps side by side?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f030-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: This question is about form, not function. It’s entirely a matter of personal
    preference. It doesn’t matter to Scratch whether two stacks of code are above
    and below each other or side by side. They could be on top of each other in a
    messy heap, and as long as the code blocks are connected in the right ways, Scratch
    will still run them. So, does it matter where you place your stacks of code?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Well, yes, it does! Your Code area is like the inside of your head. The way
    you organize the Code area reflects your thought processes and how you think about
    your game. When the Code area is disorganized, your thoughts are jumbled and hard
    to follow. If one of your players clicks the **See inside** button to look at
    how you did something in your game, how you arranged your scripts will make a
    big difference in whether or not it makes sense to them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f031-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: '*Organizing the* Leaf Me Alone *code stacks*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: A thoughtful layout can help you keep your thoughts in order, help you remember
    what all your script parts do, and help make your script clearer to others who
    look at your work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Placing related stacks next to each makes the most sense to me. For example,
    putting the `when green flag clicked` events next to each other is logical because
    they start at the same time and run simultaneously.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Scratch offers a couple of helpful functions for organizing your code. When
    you right-click the coding area, you can click **Clean up Blocks** to arrange
    all your stacks neatly, or you can click **Add Comment** to attach a note to your
    code. You can even attach a note to a specific block by right-clicking on the
    block and choosing **Add Comment**. Comments help explain the block’s purpose
    in the game to others (and help you remember what the block does). Comments don’t
    change how the code runs—they just make it a lot easier for humans to understand!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The layout of your game doesn’t have to match my layout exactly. But the layouts
    you use should make sense to you. Think of rearranging the stacks in your Code
    tab as a way of organizing your thoughts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Challenge Level
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the Scratch knowledge you have now, try this optional task: make your
    bug burp after it has eaten some leaf. To make this work, you’ll probably want
    to use the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: A `forever` loop to make sure the burp is not a one time effect
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Sensing** block to check whether the bug is on the leaf
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `wait` block to make sure the burp doesn’t happen too often
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little randomness to keep the game interesting
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A burping sound (Try recording your own burp sound using the microphone on your
    computer. Do your best pretend burp!)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](Images/f033-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: '*Recording your own burping sound*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If you need help completing this task, click the **See inside** button on *Leaf
    Me Alone* to see how I did it! (Not the burping sound, just the code.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Your Game
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All you need to do now is share your game with the world! Right now, no one
    can see your game except you. You can tinker with it as much as you want—no one’s
    looking! After you’ve shared your game, other people can find it and play it,
    so make sure you’ve made all the changes and final touches you want before sharing
    it. But don’t worry; you can keep changing it after you share it or just temporarily
    unshare it again to make changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two buttons at the top of the Scratch editor: Share and See Project
    Page. Don’t click Share just yet. You still need to do a few more tweaks before
    you make your game public.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Click **See Project Page** to go to the page your players will see when they
    look at your game.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f034-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '*The See Project Page*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: At the top of this page is a handy reminder that you’ve not yet shared the game.
    You should fill out the Instructions to tell players how to play the game (for
    example, “Use the left and right arrow keys to help the caterpillar eat that leaf!”),
    and add the Notes and Credits (for example, your name or “my finest creation!”).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Use a hashtag (#) to create a link to the search results for that word. For
    example, try adding your username, the title of your game, or words like *games*
    and *animations* as keywords to help others find your game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: When the game is complete, click **Share**. Now people on the Scratch site can
    find your game, or you can share it with a friend by giving them the link. You’ve
    finished your first game!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'One last detail: click your username in the top right, and then click **My
    Stuff** in the drop-down menu to go to your personal My Stuff page. The My Stuff
    page keeps track of all your projects, finished and unfinished, shared and unshared.
    You can also see how many people have looked at your game, sort through all your
    projects, and even unshare a game you’ve shared by clicking the Unshare link.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f035-01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: '*Viewing all your projects on the My Stuff page*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Think of the My Stuff page as your personal, secret headquarters. From here,
    you can unleash all your diabolical Scratch plans on the unsuspecting masses!
    Or, you can just keep track of every project you’re working on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f035-02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: What You Learned
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You learned a bunch of good stuff in this chapter! You used Scratch’s block-based
    programming to create backdrops and sprites for a game. You also learned how to
    use loops, how to take input from a player, and how to use conditionals and branching.
    In Scratch, you can use *x*-coordinates and y-coordinates to keep track of where
    your sprites are onscreen. You know how to share your game when you finish it
    and how to use the My Stuff page to keep track of all your cool projects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#ch02), we’ll make a game that becomes more challenging
    as the player improves. We’ll also talk about more advanced programming ideas,
    like coding sprites to clone themselves. See you there!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
