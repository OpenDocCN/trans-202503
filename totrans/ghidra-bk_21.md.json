["```\n00000000 4d       ??         4Dh    M\n\n00000001 5a       ??         5Ah    Z\n\n00000002 90       ??         90h\n\n00000003 00       ??         00h\n\n00000004 03       ??         03h\n\n00000005 00       ??         00h\n\n00000006 00       ??         00h\n\n00000007 00       ??         00h\n```", "```\n00000000 4d 5a      WORD      5A4Dh    e_magic\n\n00000002 90 00      WORD      90h      e_cblp\n\n00000004 03 00      WORD      3h       e_cp\n\n00000006 00 00      WORD      0h       e_crlc\n\n00000008 04 00      WORD      4h       e_cparhdr\n\n0000000a 00 00      WORD      0h       e_minalloc\n\n0000000c ff ff      WORD      FFFFh    e_maxalloc\n\n0000000e 00 00      WORD      0h       e_ss\n\n00000010 b8 00      WORD      B8h      e_sp\n\n00000012 00 00      WORD      0h       e_csum\n\n00000014 00 00      WORD      0h       e_ip\n\n00000016 00 00      WORD      0h       e_cs\n\n00000018 40 00      WORD      40h      e_lfarlc\n\n0000001a 00 00      WORD      0h       e_ovno\n\n0000001c 00 00 00   WORD[4]            e_res\n\n         00 00 00\n\n         00 00\n\n 00000024 00 00      WORD      0h       e_oemid\n\n00000026 00 00      WORD      0h       e_oeminfo\n\n00000028 00 00 00   WORD[10]           e_res2\n\n         00 00 00\n\n         00 00 00\n\n0000003c d8 00 00   LONG      D8h      e_lfanew\n```", "```\n000000d8    IMAGE_NT_HEADERS\n\n   000000d8       DWORD           4550h     Signature\n\n   000000dc    IMAGE_FILE_HEADER            FileHeader\n\n      000000dc    WORD            14Ch      Machine➊\n\n      000000de    WORD            5h        NumberOfSections➋\n\n      000000e0    DWORD           40FDFD    TimeDateStamp\n\n      000000e4    DWORD           0h        PointerToSymbolTable\n\n      000000e8    DWORD           0h        NumberOfSymbols\n\n      000000ec    WORD            E0h       SizeOfOptionalHeader\n\n      000000ee    WORD            10Fh      Characteristics\n\n   000000f0    IMAGE_OPTIONAL_HEADER32      OptionalHeader\n\n      000000f0    WORD            10Bh      Magic\n\n      000000f2    BYTE            '\\u0006'  MajorLinkerVersion\n\n      000000f3    BYTE            '\\0'      MinorLinkerVersion\n\n      000000f4    DWORD           21000h    SizeOfCode\n\n      000000f8    DWORD           A000h     SizeOfInitializedData\n\n      000000fc    DWORD           0h        SizeOfUninitializedData\n\n      00000100    DWORD           14E0h     AddressOfEntryPoint➌\n\n      00000104    DWORD           1000h     BaseOfCode\n\n      00000108    DWORD           1000h     BaseOfData\n\n      0000010c    DWORD           400000h   ImageBase➍\n\n      00000110    DWORD           1000h     SectionAlignment➎\n\n      00000114    DWORD           1000h     FileAlignment➏\n```", "```\n004001d0    IMAGE_SECTION_HEADER\n\n   004001d0       BYTE[8]         \".text\"   Name➊\n\n   004001d8    _union_226                   Misc\n\n      004001d8    DWORD           20A80h    PhysicalAddress\n\n      004001d8    DWORD           20A80h    VirtualSize\n\n   004001dc       DWORD           1000h     VirtualAddress➋\n\n   004001e0       DWORD           21000h    SizeOfRawData➌\n\n   004001e4       DWORD           1000h     PointerToRawData➍\n\n   004001e8       DWORD           0h        PointerToRelocations\n\n   004001ec       DWORD           0h        PointerToLinenumbers\n\n   004001f0       WORD            0h        NumberOfRelocations\n\n   004001f2       WORD            0h        NumberOfLinenumbers\n```", "```\n00400220    IMAGE_SECTION_HEADER\n\n   00400220       BYTE[8]         \".data\"   Name\n\n   00400228    _union_226                   Misc\n\n      00400228    DWORD           5624h     PhysicalAddress\n\n      00400228    DWORD           5624h     VirtualSize➊\n\n   0040022c       DWORD           24000h    VirtualAddress➋\n\n   00400230       DWORD           4000h     SizeOfRawData➌\n\n   00400234       DWORD           24000h    PointerToRawData\n\n   00400238       DWORD           0h        PointerToRelocations\n\n   0040023c       DWORD           0h        PointerToLinenumbers\n\n   00400240       WORD            0h        NumberOfRelocations\n\n   00400242       WORD            0h        NumberOfLinenumbers\n\n   00400244       DWORD           C0000040h Characteristics\n\n00400248    IMAGE_SECTION_HEADER\n\n   00400248       BYTE[8] \".idata\" Name\n\n   00400250    _union_226 Misc\n\n      00400250    DWORD           75Ch      PhysicalAddress\n\n      00400250    DWORD           75Ch      VirtualSize\n\n 00400254       DWORD           2A000h    VirtualAddress➍\n\n   00400258       DWORD           1000h     SizeOfRawData\n\n   0040025c       DWORD           28000h    PointerToRawData➎\n\n   00400260       DWORD           0h        PointerToRelocations\n\n   00400264       DWORD           0h        PointerToLinenumbers\n\n   00400268       WORD            0h        NumberOfRelocations\n\n   0040026a       WORD            0h        NumberOfLinenumbers\n\n   0040026c       DWORD           C0000040h Characteristics\n```", "```\n004014e0  ??     55h    U\n\n004014e1  ??     8Bh\n\n004014e2  ??     ECh\n\n...\n```", "```\n     FUN_004014e0\n\n004014e0  PUSH   EBP\n\n 004014e1  MOV    EBP,ESP\n\n004014e3  PUSH   -0x1\n\n004014e5  PUSH   DAT_004221b8\n\n004014ea  PUSH   LAB_004065f0\n\n004014ef  MOV    EAX,FS:[0x0]\n\n004014f5  PUSH   EAX\n```", "```\n#include <stdlib.h>\n\nint main(int argc, char **argv, char **envp) {\n\n   execve(\"/bin/sh\", NULL, NULL);\n\n}\n```", "```\n0000002b  INC    EBX\n\n0000002c  MOV    AL,0x66       ; 0x66 is Linux sys_socketcall\n\n0000002e  INT    0x80          ; transfers flow to kernel to\n\n                               ; execute system call\n\n 00000030  XCHG   EAX,EBX\n\n00000031  POP    ECX\n\n        LAB_00000032             XREF[1]:  00000038(j)\n\n00000032  PUSH   0x3f          ; 0x3f is Linux sys_dup2\n\n00000034  POP    EAX\n\n00000035  INT    0x80          ; transfers flow to kernel to\n\n                               ; execute system call\n\n00000037  DEC    ECX\n\n00000038  JNS   LAB_00000\n\n0000003a  PUSH   0x68732f2f    ; 0x68732f2f converts to \"//sh\"\n\n0000003f  PUSH   0x6e69622f    ; 0x6e69622f converts to \"/bin\"\n\n00000044  MOV    EBX,ESP\n\n00000046  PUSH   EAX\n\n00000047  PUSH   EBX\n\n00000048  MOV    ECX,ESP\n\n0000004a  MOV    AL,0xb        ; 0xb is Linux sys_execve which\n\n                               ; executes a specified program\n\n0000004c  INT    0x80          ; transfers flow to kernel to\n\n                                      ; execute system call\n```", "```\n/**\n\n * TODO: Provide class-level documentation that describes what this\n\n * loader does.\n\n */\n```", "```\n/*\n\n * This loader loads shellcode binaries into Ghidra,\n\n * including setting an entry point.\n\n */\n```", "```\npublic String getName() {\n\n       // TODO: Name the loader.  This name must match the name\n\n       // of the loader in the .opinion files\n\n     return \"My loader\"➊;\n\n}\n```", "```\npublic String getName() {\n\n   return \"Simple Shellcode Loader\";\n\n}\n```", "```\npublic Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider)\n\n                            throws IOException {\n\n   List<LoadSpec> loadSpecs = new ArrayList<>();\n\n   // TODO: Examine the bytes in 'provider' to determine if this loader\n\n   // can load it.  If it can load it, return the appropriate load\n\n   // specifications.\n\n   return loadSpecs;\n\n}\n```", "```\npublic Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider)\n\n                                                   throws IOException {\n\n   // The List of load specs supported by this loader\n\n   List<LoadSpec> loadSpecs = new ArrayList<>();\n\n   List<LanguageDescription> languageDescriptions =\n\n        getLanguageService().getLanguageDescriptions(false);\n\n   for (LanguageDescription languageDescription : languageDescriptions) {\n\n      Collection<CompilerSpecDescription> compilerSpecDescriptions =\n\n         languageDescription.getCompatibleCompilerSpecDescriptions();\n\n      for (CompilerSpecDescription compilerSpecDescription :\n\n           compilerSpecDescriptions) {\n\n         LanguageCompilerSpecPair lcs =\n\n            new LanguageCompilerSpecPair(languageDescription.getLanguageID(),\n\n            compilerSpecDescription.getCompilerSpecID());\n\n         loadSpecs.add(new LoadSpec(this, 0, lcs, false));\n\n      }\n\n   }\n\n   return loadSpecs;\n\n}\n```", "```\n@Override\n\npublic LoaderTier getTier() {\n\n   return LoaderTier.UNTARGETED_LOADER;\n\n}\n\n@Override\n\npublic int getTierPriority() {\n\n   return 101;\n\n}\n```", "```\nprotected void load(ByteProvider provider, LoadSpec loadSpec,\n\n               List<Option> options, Program program, TaskMonitor monitor,\n\n               MessageLog log) throws CancelledException, IOException {\n\n   // TODO: Load the bytes from 'provider' into the 'program'.\n\n}\n```", "```\nprotected void load(ByteProvider provider, LoadSpec loadSpec,\n\n               List<Option> options, Program program, TaskMonitor monitor,\n\n               MessageLog log) throws CancelledException, IOException {\n\n➊ FlatProgramAPI flatAPI = new FlatProgramAPI(program);\n\n   try {\n\n      monitor.setMessage(\"Simple Shellcode: Starting loading\");\n\n      // create the memory block we're going to load the shellcode into\n\n      Address start_addr = flatAPI.toAddr(0x0);\n\n   ➋ MemoryBlock block = flatAPI.createMemoryBlock(\"SHELLCODE\",\n\n      start_addr, provider.readBytes(0, provider.length()), false);\n\n      // make this memory block read/execute but not writeable\n\n   ➌ block.setRead(true);\n\n      block.setWrite(false);\n\n      block.setExecute(true);\n\n      // set the entry point for the shellcode to the start address\n\n   ➍ flatAPI.addEntryPoint(start_addr);\n\n      monitor.setMessage( \"Simple Shellcode: Completed loading\" );\n\n   } catch (Exception e) {\n\n      e.printStackTrace();\n\n      throw new IOException(\"Failed to load shellcode\");\n\n   }\n\n}\n```", "```\npublic List<Option> getDefaultOptions(ByteProvider provider, LoadSpec\n\n       loadSpec,DomainObject domainObject, boolean isLoadIntoProgram) {\n\n   List<Option> list = super.getDefaultOptions(provider, loadSpec,\n\n                       domainObject, isLoadIntoProgram);\n\n   // TODO: If this loader has custom options, add them to 'list'\n\n   list.add(new Option(\"Option name goes here\",\n\n                        Default option value goes here));\n\n   return list;\n\n}\n```", "```\npublic List<Option> getDefaultOptions(ByteProvider provider, LoadSpec\n\n       loadSpec,DomainObject domainObject, boolean isLoadIntoProgram) {\n\n   // no options\n\n   List<Option> list = new ArrayList<Option>();\n\n   return list;\n\n}\n```", "```\npublic String validateOptions(ByteProvider provider, LoadSpec loadSpec,\n\n                              List<Option> options, Program program) {\n\n   // TODO: If this loader has custom options, validate them here.\n\n   // Not all options require validation.\n\n   return super.validateOptions(provider, loadSpec, options, program);\n\n}\n```", "```\npublic String validateOptions(ByteProvider provider, LoadSpec loadSpec,\n\n                              List<Option> options, Program program) {\n\n   // No options, so no need to validate\n\n   return null;\n\n}\n```", "```\n     undefined FUN_00000000()\n\n        undefined  AL:1 <RETURN>\n\n        undefined4 Stack[-0x10]:4 local_10  XREF[1]: 00000022(W)\n\n     FUN_00000000                           XREF[1]: Entry Point(*)➊\n\n00000000 31 db          XOR    EBX,EBX\n\n00000002 f7 e3          MUL    EBX\n\n00000004 53             PUSH   EBX\n\n00000005 43             INC    EBX\n\n00000006 53             PUSH   EBX\n\n00000007 6a 02          PUSH   0x2\n\n00000009 89 e1          MOV    ECX,ESP\n\n0000000b b0 66          MOV    AL,0x66\n\n0000000d cd 80          INT    0x80\n\n0000000f 5b             POP    EBX\n\n00000010 5e             POP    ESI\n\n00000011 52             PUSH   EDX\n\n00000012 68 02 00 11 5c PUSH   0x5c110002\n```", "```\n// The List of load specs supported by this loader\n\nList<LoadSpec> loadSpecs = new ArrayList<>();\n\n// Activate loader if the filename ends in a .c extension\n\nif (!provider.getName().endsWith(\".c\")) {\n\n   return loadSpecs;\n\n}\n```", "```\npublic int getTierPriority() {\n\n   // priority of this loader\n\n   return 99;\n\n}\n```", "```\nprivate String pattern = \"\\\\\\\\x[0-9a-fA-F]{1,2}\";\n```", "```\n// set up the regex matcher\n\nCharSequence provider_char_seq =\n\n      new String(provider.readBytes(0, provider.length())➊, \"UTF-8\");\n\nPattern p = Pattern.compile(pattern);\n\nMatcher m = p.matcher(provider_char_seq)➋;\n\n // Determine how many matches (shellcode bytes) were found so that we can\n\n// correctly size the memory region, then reset the matcher\n\nint match_count = 0;\n\nwhile (m.find()) {\n\n ➌ match_count++;\n\n}\n\nm.reset();\n```", "```\nbyte[] shellcode = new byte[match_count];\n\n// convert the hex representation of bytes in the source code to actual\n\n// byte values in the binary we're creating in Ghidra\n\nint ii = 0;\n\nwhile (m.find()) {\n\n   // strip out the \\x\n\n   String hex_digits = m.group().replaceAll(\"[^0-9a-fA-F]+\", \"\")➊;\n\n   // parse what's left into an integer and cast it to a byte, then\n\n   // set current byte in byte array to that value\n\n   shellcode[ii++]➋ = (byte)Integer.parseInt(hex_digits, 16)➌;\n\n}\n```", "```\n// create the memory block and populate it with the shellcode\n\nAddress start_addr = flatAPI.toAddr(0x0);\n\nMemoryBlock block =\n\n      flatAPI.createMemoryBlock(\"SHELLCODE\", start_addr, shellcode, false);\n```", "```\nunsigned char buf[] =\n\n   \"\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\"\n\n   \"\\x5b\\x5e\\x52\\x68\\x02\\x00\\x11\\x5c\\x6a\\x10\\x51\\x50\\x89\\xe1\\x6a\"\n\n   \"\\x66\\x58\\xcd\\x80\\x89\\x41\\x04\\xb3\\x04\\xb0\\x66\\xcd\\x80\\x43\\xb0\"\n\n \"\\x66\\xcd\\x80\\x93\\x59\\x6a\\x3f\\x58\\xcd\\x80\\x49\\x79\\xf8\\x68\\x2f\"\n\n   \"\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\"\n\n   \"\\x0b\\xcd\\x80\";\n```", "```\n     **************************************************************\n\n     *                         FUNCTION                           *\n\n     **************************************************************\n\n     undefined FUN_00000000()\n\n        undefined AL:1 <RETURN>\n\n        undefined4 Stack[-0x10]:4 local_10\n\n     FUN_00000000                      XREF[1]: Entry Point(*)\n\n00000000  XOR    EBX,EBX\n\n00000002  MUL    EBX\n\n00000004  PUSH   EBX\n\n00000005  INC    EBX\n\n00000006  PUSH   EBX\n```", "```\n        LAB_00000032\n\n00000032  PUSH   0x3f\n\n00000034  POP    EAX\n\n 00000035  INT    0x80\n\n00000037  DEC    ECX\n\n00000038  JNS    LAB_00000\n\n0000003a  PUSH   0x68732f2f          ; 0x68732f2f converts to \"//sh\"\n\n0000003f  PUSH   0x6e69622f          ; 0x6e69622f converts to \"/bin\"\n```", "```\n$ file elf_shellcode_min\n\n  elf_shellcode_min: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV),\n\n  statically linked, corrupted section header size\n\n$\n```", "```\nprivate final byte[] ELF_MAGIC            = {0x7f, 0x45, 0x4c, 0x46};\n\nprivate final long EH_MAGIC_OFFSET        = 0x00;\n\nprivate final long EH_MAGIC_LEN           = 4;\n\nprivate final long EH_CLASS_OFFSET        = 0x04;\n\nprivate final byte EH_CLASS_32BIT         = 0x01;\n\nprivate final long EH_DATA_OFFSET         = 0x05;\n\nprivate final byte EH_DATA_LITTLE_ENDIAN  = 0x01;\n\nprivate final long EH_ETYPE_OFFSET        = 0x10;\n\nprivate final long EH_ETYPE_LEN           = 0x02;\n\nprivate final short EH_ETYPE_EXEC         = 0x02;\n\nprivate final long EH_EMACHINE_OFFSET     = 0x12;\n\nprivate final long EH_EMACHINE_LEN        = 0x02;\n\nprivate final short EH_EMACHINE_X86       = 0x03;\n\nprivate final long EH_EFLAGS_OFFSET       = 0x24;\n\nprivate final long EN_EFLAGS_LEN          = 4;\n\nprivate final long EH_EEHSIZE_OFFSET      = 0x28;\n\nprivate final long EH_PHENTSIZE_OFFSET    = 0x2A;\n\nprivate final long EH_PHNUM_OFFSET        = 0x2C;\n```", "```\nbyte[] magic = provider.readBytes(EH_MAGIC_OFFSET, EH_MAGIC_LEN);\n\nif (!Arrays.equals(magic, ELF_MAGIC)) {\n\n   // the binary is not an ELF\n\n   return loadSpecs;\n\n}\n```", "```\nbyte ei_class = provider.readByte(EH_CLASS_OFFSET);\n\nbyte ei_data = provider.readByte(EH_DATA_OFFSET);\n\nif ((ei_class != EH_CLASS_32BIT) || (ei_data != EH_DATA_LITTLE_ENDIAN)) {\n\n   // not an ELF we want to accept\n\n   return loadSpecs;\n\n}\n```", "```\nbyte[] etyp = provider.readBytes(EH_ETYPE_OFFSET, EH_ETYPE_LEN);\n\nshort e_type =\n\n      ByteBuffer.wrap(etyp).order(ByteOrder.LITTLE_ENDIAN).getShort();\n\nbyte[] emach = provider.readBytes(EH_EMACHINE_OFFSET, EH_EMACHINE_LEN);\n\nshort e_machine =\n\n      ByteBuffer.wrap(emach).order(ByteOrder.LITTLE_ENDIAN).getShort();\n\nif ((e_type != EH_ETYPE_EXEC) || (e_machine != EH_EMACHINE_X86)) {\n\n   // not an ELF we want to accept\n\n   return loadSpecs;\n\n}\n```", "```\nbyte[] eflag = provider.readBytes(EH_EFLAGS_OFFSET, EN_EFLAGS_LEN);\n\nint e_flags = ByteBuffer.wrap(eflag).order(ByteOrder.LITTLE_ENDIAN).getInt();\n\nList<QueryResult> results =\n\n     QueryOpinionService.query(getName(), Short.toString(e_machine),\n\n                               Integer.toString(e_flags));\n```", "```\nfor (QueryResult result : results) {\n\n   CompilerSpecID cspec = result.pair.getCompilerSpec().getCompilerSpecID();\n\n   if (cspec.toString().equals(\"borlanddelphi\"➊)) {\n\n      // ignore anything created by Delphi\n\n      continue;\n\n   }\n\n   String variant = result.pair.getLanguageDescription().getVariant();\n\n   if (variant.equals(\"System Management Mode\"➋)) {\n\n       // ignore anything where the variant is \"System Management Mode\"\n\n       continue;\n\n   }\n\n   // valid load spec, so add it to the list\n\n ➌ loadSpecs.add(new LoadSpec(this, 0, result));\n\n}\n\nreturn loadSpecs;\n```", "```\n// Get some values from the header needed for the load process\n\n//\n\n// How big is the ELF header?\n\n byte[] ehsz = provider.readBytes(EH_EEHSIZE_OFFSET, 2);\n\ne_ehsize = ByteBuffer.wrap(ehsz).order(ByteOrder.LITTLE_ENDIAN).getShort();\n\n// How big is a single program header?\n\nbyte[] phsz = provider.readBytes(EH_PHENTSIZE_OFFSET, 2);\n\ne_phentsize =\n\n      ByteBuffer.wrap(phsz).order(ByteOrder.LITTLE_ENDIAN).getShort();\n\n// How many program headers are there?\n\nbyte[] phnum = provider.readBytes(EH_PHNUM_OFFSET, 2);\n\ne_phnum = ByteBuffer.wrap(phunm).order(ByteOrder.LITTLE_ENDIAN).getShort();\n\n// What is the total header size for our simplified ELF format\n\n// (This includes the ELF Header plus program headers.)\n\nlong hdr_size = e_ehsize + e_phentsize * e_phnum;\n```", "```\n// Create the memory block for the ELF header\n\nlong LOAD_BASE = 0x10000000;  \n\nAddress hdr_start_adr = flatAPI.toAddr(LOAD_BASE);\n\nMemoryBlock hdr_block =\n\n      flatAPI.createMemoryBlock(\".elf_header\", hdr_start_adr,\n\n                                 provider.readBytes(0, hdr_size), false);\n\n// Make this memory block read-only\n\nhdr_block.setRead(true);\n\nhdr_block.setWrite(false);\n\nhdr_block.setExecute(false);\n\n// Create the memory block for the text from the simplified ELF binary\n\nAddress txt_start_adr = flatAPI.toAddr(LOAD_BASE + hdr_size);\n\nMemoryBlock txt_block =\n\n      flatAPI.createMemoryBlock(\".text\", txt_start_adr,\n\n             provider.readBytes(hdr_size, provider.length() – hdr_size),\n\n             false);\n\n// Make this memory block read & execute\n\ntxt_block.setRead(true);\n\ntxt_block.setWrite(false);\n\ntxt_block.setExecute(true);\n```", "```\n  // Add structure to the ELF HEADER\n\n➊ flatAPI.createData(hdr_start_adr, new ElfDataType());\n\n // Add label and entry point at start of shellcode\n\n➋ flatAPI.createLabel(txt_start_adr, \"shellcode\", true);\n\n➌ flatAPI.addEntryPoint(txt_start_adr);\n\n  // Add a cross reference from the ELF header to the entrypoint\n\n  Data d = flatAPI.getDataAt(hdr_start_adr).getComponent(0).getComponent(9);\n\n➍ flatAPI.createMemoryReference(d, txt_start_adr, RefType.DATA);\n```", "```\n<language processor=\"x86\"\n\n          endian=\"little\"\n\n          size=\"32\"\n\n          variant=\"default\"\n\n          version=\"2.8\"\n\n          slafile=\"x86.sla\"\n\n          processorspec=\"x86.pspec\"\n\n          manualindexfile=\"../manuals/x86.idx\"\n\n          id=\"x86:LE:32:default\">\n\n   <description>Intel/AMD 32-bit x86</description>\n\n   <compiler name=\"Visual Studio\" spec=\"x86win.cspec\" id=\"windows\"/>\n\n   <compiler name=\"gcc\" spec=\"x86gcc.cspec\" id=\"gcc\"/>\n\n   <compiler name=\"Borland C++\" spec=\"x86borland.cspec\" id=\"borlandcpp\"/>\n\n ➊ <compiler name=\"Delphi\" spec=\"x86delphi.cspec\" id=\"borlanddelphi\"/>\n\n</language>\n\n<language processor=\"x86\"\n\n          endian=\"little\"\n\n          size=\"32\"\n\n        ➋ variant=\"System Management Mode\"\n\n          version=\"2.8\"\n\n          slafile=\"x86.sla\"\n\n          processorspec=\"x86-16.pspec\"\n\n          manualindexfile=\"../manuals/x86.idx\"\n\n          id=\"x86:LE:32:System Management Mode\">\n\n   <description>Intel/AMD 32-bit x86 System Management Mode</description>\n\n   <compiler name=\"default\" spec=\"x86-16.cspec\" id=\"default\"/>\n\n</language>\n```", "```\n<opinions>\n\n   <constraint loader=\"Simple ELF Shellcode Loader\" compilerSpecID=\"gcc\">\n\n      <constraint➊ primary➋=\"3\" processor=\"x86\"  endian=\"little\" size=\"32\" />\n\n      <constraint primary=\"62\" processor=\"x86\"  endian=\"little\" size=\"64\" />\n\n   </constraint>\n\n</opinions>\n```", "```\n10000000 7f             db      7Fh          e_ident_magic_num\n\n10000001 45 4c 46       ds      \"ELF\"        e_ident_magic_str\n\n10000004 01             db      1h           e_ident_class\n\n10000005 01             db      1h           e_ident_data\n\n10000006 01             db      1h           e_ident_version\n\n10000007 00 00 00 00 00 db[9]                e_ident_pad\n\n         00 00 00 00\n\n10000010 02 00          dw      2h           e_type\n\n10000012 03 00          dw      3h           e_machine\n\n10000014 01 00 00 00    ddw     1h           e_version\n\n10000018 54 00 00 10    ddw     shellcode➊  e_entry\n\n1000001c 34 00 00 00    ddw     34h          e_phoff\n\n10000020 00 00 00 00    ddw     0h           e_shoff\n\n10000024 00 00 00 00    ddw     0h           e_flags\n\n10000028 34 00          dw      34h          e_ehsize\n```", "```\n1000008c  JNS    LAB_10000086\n\n1000008e  PUSH   \"//sh\"\n\n10000093  PUSH   \"/bin\"\n\n10000098  MOV    EBX,ESP\n\n1000009a  PUSH   EAX\n```"]