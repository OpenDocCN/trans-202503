- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: 'I’ve Got the Power: Introduction to Power Analysis'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我掌控了力量：功率分析简介
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: You’ll often hear that cryptographic algorithms are unbreakable, regardless
    of the huge advances in computing power. That is true. However, as you’ll learn
    in this chapter, the key to finding vulnerabilities in cryptographic algorithms
    lies in their implementation, no matter how “military grade” they are.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你常常会听到关于加密算法是不可破解的论调，不管计算能力如何巨大进步。这是真的。然而，正如你将在本章中学到的，发现加密算法漏洞的关键在于其实现方式，无论它们有多么“军用级”。
- en: That said, we won’t be discussing crypto implementation errors, such as failed
    bounds checks, in this chapter. Instead, we’ll exploit the very nature of digital
    electronics using side channels to break algorithms that, on paper, appear to
    be secure. A *side channel* is some observable aspect of a system that reveals
    secrets held within that system. The techniques we describe leverage vulnerabilities
    that arise from the physical implementation of these algorithms in hardware, primarily
    in the way that digital devices use power. We’ll start with data-dependent execution
    time, which we can determine by monitoring power consumption, and then we’ll move
    on to monitoring power consumption as a means to identify key bits in cryptographic
    processing functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们本章不会讨论加密实现中的错误，比如失败的边界检查。相反，我们将利用数字电子的本质，通过侧信道攻击打破那些表面上看似安全的算法。*侧信道*是系统中某个可观察到的方面，它能揭示系统内部所藏的秘密。我们将描述的技术利用了这些算法在硬件中的物理实现中产生的漏洞，主要是在数字设备如何使用电力方面。我们将从数据依赖的执行时间开始，我们可以通过监控功耗来确定它，然后再通过监控功耗作为一种手段，识别加密处理函数中的密钥位。
- en: 'Considerable historical precedence exists for side-channel analysis. For example,
    during the Second World War, the British were interested in estimating the number
    of tanks being produced by the Germans. The most reliable way to do so turned
    out to be a statistical analysis of the sequence of serial numbers from captured
    or disabled tanks, assuming that serial numbers typically increment in a straightforward
    manner. The attacks we’ll present in this chapter mirror this so-called *German
    Tank Problem*: they combine statistics with assumptions and ultimately use a small
    amount of data that our adversary unknowingly leaked to us.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧信道分析方面有着相当丰富的历史先例。例如，在第二次世界大战期间，英国人曾试图估算德国生产的坦克数量。最可靠的方法竟然是通过对被俘或损坏坦克的序列号进行统计分析，假设序列号通常以直观的方式递增。本章将介绍的攻击正是这种所谓的*德国坦克问题*：它们结合了统计学与假设，并最终利用了对方无意中泄露给我们的少量数据。
- en: 'Other historical side-channel attacks monitor unintended electronic signals
    emanating from the hardware. In fact, almost as soon as electronic systems were
    used to pass secure messages, they were subject to attack. One such famous early
    attack was the TEMPEST attack, launched by Bell Labs scientists in WWII to decode
    electronic typewriter key presses from 80 feet away with a 75 percent accuracy
    (see “TEMPEST: A Signal Problem” by the USA’s National Security Agency). TEMPEST
    has since been used to reproduce what is being displayed on a computer monitor
    by picking up the monitor’s radio signal emissions from outside the building (see,
    for instance, Wim van Eck’s “Electromagnetic Radiation from Video Display Units:
    An Eavesdropping Risk?”). And while the original TEMPEST attack used CRT-type
    monitors, this same vulnerability has been demonstrated on more recent LCD displays
    by Markus G. Kuhn in “Electromagnetic Eavesdropping Risks of Flat-Panel Displays,”
    so it’s far from outdated.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '其他历史上的侧信道攻击监测的是来自硬件的意外电子信号。事实上，几乎一开始电子系统被用来传递安全信息时，它们就已经遭遇了攻击。其中一个著名的早期攻击是“TEMPEST”攻击，由贝尔实验室的科学家们在二战期间发起，通过80英尺外的电波信号解码电子打字机按键，准确率达到75%（参见美国国家安全局的《TEMPEST:
    A Signal Problem》）。此后，TEMPEST被用来通过拾取计算机显示器的无线电信号，从建筑物外部重现显示在屏幕上的内容（例如，参见Wim van
    Eck的《Electromagnetic Radiation from Video Display Units: An Eavesdropping Risk?》）。而最初的TEMPEST攻击是使用CRT显示器进行的，这一漏洞在Markus
    G. Kuhn的《Electromagnetic Eavesdropping Risks of Flat-Panel Displays》中已经被证明同样适用于更新型的LCD显示器，所以这项技术远远没有过时。'
- en: 'We’ll show you something even more surreptitious than TEMPEST, though: a way
    to use unintended emissions from hardware to break otherwise secure cryptographic
    algorithms. This strategy covers both software running on hardware (such as firmware
    on a microcontroller) and pure hardware implementations of the algorithms (such
    as cryptographic accelerators). We’ll describe how to measure, how to process
    your measurement to improve leakage, and how to extract secrets. We’ll cover topics
    that have their roots in areas ranging all the way from chip and printed circuit
    board (PCB) design, through electronics, electromagnetism, and (digital) signal
    processing, to statistics, cryptography, and even to common sense.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将向你展示比TEMPEST更隐秘的东西：一种利用硬件意外发射来破解原本安全的加密算法的方法。这个策略包括运行在硬件上的软件（如微控制器上的固件）和加密算法的纯硬件实现（如加密加速器）。我们将描述如何测量，如何处理你的测量以改善泄露，并且如何提取秘密。我们将涉及的主题从芯片和印刷电路板（PCB）设计开始，跨越电子学、电磁学、（数字）信号处理、统计学、密码学，甚至到常识。
- en: Timing Attacks
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时序攻击
- en: Timing is everything. Consider what happens when implementing a personal identification
    number (PIN) code check, like one you’d find on a wall safe or door alarm. The
    designer allows you to enter the complete PIN (say, four digits) before comparing
    the entered PIN with the stored secret code. In C code, it could look something
    like [Listing 8-1](#listing8-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 时机决定一切。考虑一下当实施个人身份号码（PIN）码检查时会发生什么，就像你在墙上的保险箱或门警报上看到的那样。设计师允许你输入完整的PIN码（比如四位数），然后将输入的PIN码与存储的密钥代码进行比较。在C代码中，它可能类似于[Listing
    8-1](#listing8-1)。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Sample PIN code check written in C'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-1：用C语言编写的PIN码检查示例
- en: It looks like a pretty reasonable piece of code, right? We read in four digits.
    If they match the secret code, the function returns a `1`; otherwise, it returns
    a `0`. Ultimately, we can use this return value to open a safe or disarm the security
    system by pressing the valid button after the four digits have been entered. A
    red error LED illuminates to show that the PIN is incorrect.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这是一段相当合理的代码，对吧？我们读取四位数字。如果它们与密钥代码匹配，函数返回`1`；否则，返回`0`。最终，我们可以使用这个返回值通过按下有效按钮，在输入四个数字后打开保险箱或解除安全系统。红色错误LED亮起，表示PIN码不正确。
- en: How might this safe be attacked? Assuming that the PIN accepts the numbers 0
    through 9, testing all possible combinations would require a total of 10 × 10
    × 10 × 10 = 10,000 guesses. On average, we would have to perform 5,000 guesses
    to find the PIN, but that would take a long time, and the system might limit the
    speed at which we can repeatedly enter guesses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个保险箱可能会如何被攻击？假设PIN码接受数字0到9，测试所有可能的组合将需要总共10 × 10 × 10 × 10 = 10,000次猜测。平均来说，我们需要进行5,000次猜测才能找到PIN码，但这将需要很长时间，而且系统可能会限制我们反复输入猜测的速度。
- en: Fortunately, we can reduce the number of guesses to 40 using a technique called
    a *timing attack*. Assume we have the keypad shown in [Figure 8-1](#figure8-1).
    The C key (for clear) clears the entry, and the V key (for valid) validates it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用一种叫做*时序攻击*的技术将猜测次数减少到40次。假设我们有如[图8-1](#figure8-1)所示的键盘。C键（清除）用于清除输入，V键（有效）用于验证。
- en: '![f08001](image_fi/278748c08/f08001.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](image_fi/278748c08/f08001.png)'
- en: 'Figure 8-1: A simple keypad'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：一个简单的键盘
- en: 'To perform the attack, we connect two oscilloscope probes to the keypad: one
    to the connecting wire on the V button and the other to the connecting wire on
    the error LED. We then enter PIN 0000\. (Of course, we are assuming we have access
    to a copy of this PIN pad that we’ve now dissected.) We press the V button, watch
    our oscilloscope trace, and measure the time difference between the V button being
    pressed and the error LED illuminating. The execution of the loop in [Listing
    8-1](#listing8-1) tells us that the function will take longer to return a failed
    result if the first three numbers in the PIN are correct and only the final check
    fails than it would take if the first number had been incorrect from the start.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行攻击，我们将两个示波器探头连接到键盘：一个连接到V按钮的连接线，另一个连接到错误LED的连接线。然后，我们输入PIN 0000。 （当然，我们假设我们已经获得了这个PIN垫的副本，并且已经对其进行了拆解。）我们按下V按钮，观察示波器的波形，并测量按下V按钮与错误LED亮起之间的时间差。通过[Listing
    8-1](#listing8-1)中的循环执行，我们可以得出结论：如果PIN的前三个数字是正确的，而只有最后一次检查失败，那么函数返回失败结果所需的时间将比从一开始第一个数字就是错误时所需的时间更长。
- en: The attack cycles through all possibilities for the first digit of the PIN (0000,
    1000, 2000, through 9000) while recording the time delay between pressing the
    V button and the error LED illuminating. [Figure 8-2](#figure8-2) shows the timing
    sequence.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击会遍历所有可能的PIN码第一个数字（0000、1000、2000，直到9000），同时记录按下V按钮与错误LED亮起之间的时间延迟。[图8-2](#figure8-2)展示了定时序列。
- en: '![f08002](image_fi/278748c08/f08002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](image_fi/278748c08/f08002.png)'
- en: 'Figure 8-2: Determination of loop delay time'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：确定循环延迟时间
- en: We expect that when the first PIN digit is correct (let’s say it’s a 1), the
    delay will increase before the error LED goes high, which happens only after the
    second digit has been compared to `correct_pin[]`. We now know the correct first
    digit. The top part of [Figure 8-2](#figure8-2) shows that when the valid button
    is pressed after a completely incorrect sequence, the error LED turns on within
    a short amount of time (t[bad]). Compare this to the valid button being pressed
    after a partially correct sequence (the first button was correct in this partial
    sequence). Now the error LED takes a longer amount of time (t[correct]) since
    the first number was correct, but upon comparing the second number, it turns on
    the error LED.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计，当第一个PIN码数字正确时（假设是1），延迟会增加，然后错误LED才会亮起，而这只有在第二个数字与`correct_pin[]`进行比较之后才会发生。我们现在知道第一个数字是正确的。[图8-2](#figure8-2)的上半部分显示，当完全错误的序列之后按下有效按钮时，错误LED会在短时间内亮起（t[bad]）。将其与部分正确序列之后按下有效按钮进行比较（该部分序列的第一个按钮是正确的）。现在，由于第一个数字是正确的，错误LED的亮起时间更长（t[correct]），但在比较第二个数字时，它会亮起错误LED。
- en: 'We continue the attack by trying every possibility for the second digit: entering
    1000, 1100, 1200 through 1900\. Once again, we expect that for the correct digit
    (let’s say it’s 3), the delay will increase before the error LED goes high.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过尝试第二个数字的每种可能性来继续攻击：输入1000、1100、1200直到1900\. 一如既往，我们预计当第二个数字正确时（假设是3），延迟会增加，然后错误LED才会亮起。
- en: Repeating this attack for the third digit, we determine that the first three
    digits are 133\. Now it’s a simple matter of guessing the final digit and seeing
    which one unlocks the system (let’s say it’s 7). The PIN combination is, thus,
    1337\. (Considering the audience of this book, we realize we may have just published
    your PIN. Change it now.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对第三个数字进行相同的攻击，我们确定前面三个数字是133\. 现在，只需要猜测最后一个数字，看看哪个数字能解锁系统（假设是7）。因此，PIN码组合就是1337\.
    （考虑到本书的读者，我们意识到我们可能刚刚公布了你的PIN码。现在就更改它吧。）
- en: The advantage to this method is that we discover the digits incrementally by
    knowing the position in the PIN sequence of the incorrect digit. This little bit
    of information has a big impact. Instead of a maximum of 10 × 10 × 10 × 10 guesses,
    we now need to make no more than 10 + 10 + 10 + 10 = 40 guesses. If we are locked
    out after three unsuccessful attempts, the probability of guessing the PIN has
    been improved from 3/1000 (0.3 percent) to 3/40 (7.5 percent). Further, assuming
    the PIN is selected randomly (which in reality is a poor assumption), we would
    on average *find* the guess halfway through our guessing sequence. This means,
    on average, we need to guess only five numbers for each digit, so we have an average
    total of 20 guesses with our assisted attack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，通过知道错误数字在PIN码序列中的位置，我们逐步发现了数字。这个小小的信息有着巨大的影响。我们不再需要进行最多10 × 10 × 10
    × 10次猜测，而只需要进行最多10 + 10 + 10 + 10 = 40次猜测。如果我们在三次失败尝试后被锁定，猜测PIN码的概率已经从3/1000（0.3%）提高到了3/40（7.5%）。进一步假设PIN码是随机选择的（尽管在现实中这是一个不太好的假设），我们平均*能找到*猜测的数字在猜测序列中的中间位置。这意味着，平均而言，我们每个数字只需要猜测五个数字，因此我们通过辅助攻击，平均总共只需进行20次猜测。
- en: We call this a *timing attack*. We measured only the time between two events
    and used that information to recover part of the secret. Can it really be as easy
    in practice? Here’s a real-life example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为*定时攻击*。我们只测量了两事件之间的时间，并利用这个信息恢复了部分秘密。实践中真的是这么简单吗？下面是一个真实的例子。
- en: Hard Drive Timing Attack
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬盘定时攻击
- en: Consider a hard drive enclosure with a PIN-protected partition—in particular,
    the Vantec Vault, model number NSTV290S2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个带有PIN保护分区的硬盘外壳——特别是Vantec Vault，型号NSTV290S2。
- en: The Vault hard drive enclosure works by messing with the drive’s partition table
    so that it doesn’t appear in the host operating system; the enclosure doesn’t
    actually encrypt anything. When the correct PIN is entered into the Vault, valid
    partition information is made accessible to the operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Vault硬盘外壳通过篡改硬盘的分区表，使其在主机操作系统中无法显示；该外壳实际上并不加密任何内容。当正确的PIN码输入Vault时，有效的分区信息将被操作系统访问。
- en: The most obvious way to attack the Vault might be to repair the partition table
    manually on the drive, but we can also use a timing attack against its PIN-entry
    logic—one that’s more in line with our side-channel power analysis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击Vault最明显的方式可能是手动修复硬盘的分区表，但我们也可以针对其PIN码输入逻辑使用定时攻击—这种方式更符合我们的侧信道功率分析。
- en: Unlike the PIN pad example discussed earlier, we first need to determine when
    a button is *read*, because in this device, the microcontroller only occasionally
    *scans* the buttons. Each scan requires checking the status of each button to
    determine whether it has been pressed. This scanning technique is standard in
    hardware that must receive input from buttons. It frees the microcontroller in
    the hardware to do work in the 100ms or so between checking for button presses,
    which maintains the illusion of instantaneous response to us comparatively slow
    and clumsy humans.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面讨论的PIN码键盘例子不同，我们首先需要确定何时按钮被*读取*，因为在这个设备中，微控制器仅偶尔*扫描*按钮。每次扫描都需要检查每个按钮的状态，以确定它是否被按下。这种扫描技术是硬件中必须接收按钮输入的标准方法。它使硬件中的微控制器能够在每次检查按钮按下与否的100毫秒左右时间内执行其他工作，从而维持了我们这些相对缓慢而笨拙的人类的即时反应假象。
- en: When performing a scan, the microcontroller sets some line to a positive voltage
    (high). We can use this transition as a trigger to indicate when a button is being
    read. While a button is pressed, the time delay from this line going high to the
    *error* event gives us the timing information we need for our attack. [Figure
    8-3](#figure8-3) shows that line B goes high only when the microcontroller is
    reading the button status *and* the button is being pressed at the same time.
    Our primary challenge is to trigger the capture when that high value propagates
    through the button, not just when the button is pushed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行扫描时，微控制器将某些线路设置为正电压（高电平）。我们可以利用这一转换作为触发信号，指示何时正在读取按钮。按钮按下时，从此线路变为高电平到*错误*事件的时间延迟为我们提供了执行攻击所需的时间信息。[图8-3](#figure8-3)显示了只有在微控制器正在读取按钮状态*并且*按钮同时被按下时，B线才会变高。我们的主要挑战是触发捕获，当这个高电平值通过按钮传播时，而不仅仅是当按钮被按下时。
- en: '![f08003](image_fi/278748c08/f08003.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![f08003](image_fi/278748c08/f08003.png)'
- en: 'Figure 8-3: Hard drive attack timing diagram'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3：硬盘攻击时序图
- en: This simple example shows how the microcontroller checks the state of the button
    only every 50ms, as shown by the upper timing line A. It can detect the button
    press only during brief high pulses at those 50ms intervals. The presence of a
    button press is indicated by the correspondingly brief high pulse that the A line
    pulse allows through onto the B line.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了微控制器仅每50毫秒检查一次按钮的状态，如上面的定时线A所示。它只能在这些50毫秒间隔内的短暂高脉冲期间检测到按钮按下。按钮按下的存在通过A线脉冲允许的短暂高脉冲传递到B线。
- en: '[Figure 8-4](#figure8-4) shows the buttons along the right-hand side of the
    hard drive enclosure by which a six-digit PIN code is entered. Only once the entire
    correct PIN is entered does the hard drive reveal its contents to the operating
    system.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-4](#figure8-4)显示了硬盘外壳右侧的按钮，通过这些按钮可以输入六位数的PIN码。只有当整个正确的PIN码输入后，硬盘才会将其内容暴露给操作系统。'
- en: It so happens that the correct PIN code in our hard drive is 123456 (the same
    combination as on our luggage), and [Figure 8-5](#figure8-5) demonstrates how
    we can read this out.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 恰巧我们的硬盘的正确PIN码是123456（和我们行李的密码相同），[图8-5](#figure8-5)展示了我们如何读取这个密码。
- en: The top line is the error signal, and the bottom line is the button scan signal.
    The vertical cursors are aligned to the rising edge of the button scan signal
    and to the falling edge of the errorsignal. We’re interested in the time difference
    between those cursors, which corresponds to the time the microcontroller needs
    to process the PIN entry before it responds with an error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上面一条是错误信号，下面一条是按钮扫描信号。垂直光标与按钮扫描信号的上升沿和错误信号的下降沿对齐。我们关心的是这两个光标之间的时间差，这对应于微控制器处理PIN码输入所需的时间，之后它会响应错误信号。
- en: Looking at the top part of the figure, we see the timing information where the
    first digit is incorrect. The time delay between the first rising edge of the
    button scan and the falling edge of the errorsignal gives us the processing time.
    By comparison, the bottom part of the figure shows the same waveforms when the
    first digit is correct. Notice that the time delay isslightly longer. This longer
    delay is due to the password-checking loop accepting the first digit and then
    going to check the next digit. In this way, we can identify the first digit of
    the password.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看图的上半部分，我们看到定时信息，其中第一位数字是错误的。按钮扫描的第一个上升沿与错误信号的下降沿之间的时间延迟给出了处理时间。相比之下，图的下半部分显示了第一位数字正确时的相同波形。注意，时间延迟稍长一些。这一延迟更长是因为密码检查循环接受了第一位数字后，继续检查下一个数字。通过这种方式，我们可以识别密码的第一位数字。
- en: '![f08004](image_fi/278748c08/f08004.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![f08004](image_fi/278748c08/f08004.png)'
- en: 'Figure 8-4: Vantec Vault NSTV290S2 hard drive enclosure'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：Vantec Vault NSTV290S2硬盘外壳
- en: '![f08005](image_fi/278748c08/f08005.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f08005](image_fi/278748c08/f08005.png)'
- en: 'Figure 8-5: Hard drive timing measurement'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：硬盘定时测量
- en: The next stage of the attack is to iterate through all options for the second
    digit (that is, testing 106666, 116666 . . . 156666, 166666) and looking for a
    similar jump in processing delay. This jump in delay again indicates that we have
    found the correct value of a digit and can then attack the next digit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的下一阶段是迭代所有第二位数字的选项（即测试106666、116666……156666、166666），并寻找类似的处理延迟跳跃。这种延迟跳跃再次表明我们找到了正确的数字，然后可以继续攻击下一个数字。
- en: We can use a timing attack to guess the password for the Vault in (at most)
    60 guesses (10 + 10 + 10 + 10 + 10 + 10), which should take no longer than 10
    minutes doing it manually. Yet, the manufacturer claims that the Vault has one
    million combinations (10 × 10 × 10 × 10 × 10 × 10), which is true when entering
    guesses of the PIN. However, our timing attack reduces the number of combinations
    we actually need to try to 0.006 percent of the total number of combinations.
    No countermeasures such as random delays complicate our attack, and the drive
    doesn’t provide a lock-out mechanism that prevents the user from entering an unlimited
    number of guesses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用定时攻击在（最多）60次猜测内猜出Vault的密码（10 + 10 + 10 + 10 + 10 + 10），手动操作时不应超过10分钟。然而，制造商声称Vault有一百万个组合（10
    × 10 × 10 × 10 × 10 × 10），这一点在输入PIN码时是正确的。然而，我们的定时攻击将实际需要尝试的组合数减少到了总组合数的0.006%。没有任何反制措施（如随机延迟）使得我们的攻击变得复杂，硬盘也没有提供锁定机制来防止用户输入无限次的猜测。
- en: Power Measurements for Timing Attacks
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时攻击的功耗测量
- en: Let’s say that in an attempt to thwart a timing attack, someone has inserted
    a small random delay before illuminating the error LED. The underlying password
    check is the same as that in [Listing 8-1](#listing8-1), but now the time delay
    between pressing the V button and the error LED illuminating no longer clearly
    indicates the position of an incorrect digit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了阻止定时攻击，有人插入了一个小的随机延迟，然后才点亮错误LED。底层的密码检查与[清单8-1](#listing8-1)中的相同，但现在从按下V按钮到错误LED亮起之间的时间延迟不再清晰地指示错误数字的位置。
- en: Now assume we’re able to measure the power consumption of the microcontroller
    that’s executing the code. (We’ll explain how to do this in the section “Preparing
    the Oscilloscope” in Chapter 9.) The power consumption might look something like
    [Figure 8-6](#figure8-6), which shows the power trace of a device while it’s performing
    an operation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们能够测量执行代码的微控制器的功耗。（我们将在第9章“准备示波器”一节中解释如何做到这一点。）功耗可能类似于[图8-6](#figure8-6)，该图展示了设备执行操作时的功耗轨迹。
- en: '![f08006](image_fi/278748c08/f08006.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![f08006](image_fi/278748c08/f08006.png)'
- en: 'Figure 8-6: A sample power consumption trace of a device performing an operation'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：设备执行操作时的功耗示例轨迹
- en: Notice the repetitive nature of the power consumption trace. Oscillations will
    occur at a rate similar to the microcontroller’s operating frequency. Most transistor-switching
    activity on the chip happens at the edges of the clock, and thus the power consumption
    also spikes close to those moments. The same principle applies even to high-speed
    devices, such as Arm microcontrollers or custom hardware.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意功耗轨迹的重复性。振荡将以类似微控制器工作频率的速率发生。芯片上的大部分晶体管开关活动发生在时钟的边缘，因此功耗也在这些时刻附近出现峰值。同样的原理也适用于高速设备，如Arm微控制器或定制硬件。
- en: We can glean some information about what a device is doing based on this power
    signature. For example, if the random delay discussed earlier is implemented as
    a simple `for` loop that counts from 0 to a random number *n*, it will appear
    as a pattern that is repeated *n* times. In window B of [Figure 8-6](#figure8-6),
    a pattern (in this case, the simple pulse) is repeated four times, so if we expect
    a random delay, that sequence of four pulses may be the delay. If we record a
    few of these power traces using the same PIN, and all patterns are the same except
    for different numbers of pulses similar to window B, that would indicate a random
    process around window B. This randomness could be either a truly random process
    or some pseudorandom process (pseudorandom normally being a purely deterministic
    process generating the “randomness”). For example, if you reset the device, you
    might see the same consecutive repetitions in window B, which indicates it’s not
    truly random. But of more interest, if we vary the PIN and see the number of patterns
    that look like those in window A change, we have a good idea that the power sequence
    around window A represents the comparison function. Thus, we can focus our timing
    attack on that section of the power trace.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过功率特征推测设备正在做什么。例如，如果之前讨论的随机延迟是通过一个简单的`for`循环来实现的，该循环从0计数到一个随机数*n*，那么它将呈现为一个重复*n*次的模式。在[图8-6](#figure8-6)的窗口B中，一个模式（在此情况下为简单脉冲）重复了四次，因此，如果我们预期有一个随机延迟，那么这一连续四个脉冲的序列可能就是延迟。如果我们使用相同的PIN记录几个这样的功率轨迹，且所有模式除了脉冲数量不同，类似于窗口B的脉冲模式相同，那么这表明在窗口B周围存在一个随机过程。这个随机性可能是真正的随机过程，也可能是某种伪随机过程（伪随机通常是一个纯粹确定性的过程，用来生成“随机性”）。例如，如果你重置设备，你可能会在窗口B中看到相同的连续重复，这表明它并不是真正的随机。然而，更有意思的是，如果我们改变PIN并看到类似窗口A的模式数量发生变化，那么我们可以很好地推测窗口A周围的功率序列代表了比较函数。因此，我们可以将定时攻击集中在功率轨迹的这一部分。
- en: The difference between this approach and previous timing attacks is that we
    don’t have to measure timing over an entire algorithm but instead can choose specific
    parts of an algorithm that happen to have a characteristic signal. We can use
    similar techniques to break cryptographic implementations, as we’ll describe next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与以前的定时攻击的不同之处在于，我们不需要对整个算法进行定时测量，而是可以选择算法中恰好具有特征信号的特定部分。我们可以使用类似的技术来破解加密实现，接下来我们将介绍。
- en: Simple Power Analysis
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单功率分析
- en: Everything is relative, and so is the simplicity of *simple power analysis (SPA)*
    with respect to *differential power analysis (DPA)*. The term *simple power analysis*
    has its origins in the 1998 paper “Differential Power Analysis” by Paul Kocher,
    Joshua Jaffe, and Benjamin Jun, where SPA was coined along with the more complex
    DPA. Bear in mind, however, that performing SPA can sometimes be more complex
    than performing DPA in some leakage scenarios. You can perform an SPA attack by
    observing a single execution of the algorithm, whereas a DPA attack involves multiple
    executions of an algorithm with varying data. DPA generally analyzes statistical
    differences between hundreds to billions of traces. While you can perform SPA
    in a single trace, it may involve a few to thousands of traces—the additional
    traces are included to reduce noise. The most basic example of an SPA attack is
    to inspect power traces visually, which can break weak cryptographic implementations
    or PIN verifications, as shown earlier in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都是相对的，*简单功率分析（SPA）*与*差分功率分析（DPA）*也是如此。术语*简单功率分析*起源于1998年保罗·科赫尔（Paul Kocher）、约书亚·贾菲（Joshua
    Jaffe）和本杰明·俊（Benjamin Jun）的论文《差分功率分析》（“Differential Power Analysis”），其中SPA与更复杂的DPA一同被提出。然而，请记住，在某些泄漏场景下，进行SPA有时可能比进行DPA更为复杂。你可以通过观察算法的单次执行来执行SPA攻击，而DPA攻击则涉及多次执行算法并使用不同的数据。DPA通常分析数百到数十亿个轨迹之间的统计差异。虽然你可以在单个轨迹中执行SPA，但它可能涉及几条到成千上万条轨迹——额外的轨迹是为了减少噪声。SPA攻击的最基本示例是通过目视检查功率轨迹，这可以破解弱的加密实现或PIN验证，如本章前面所示。
- en: 'SPA relies on the observation that each microcontroller instruction has its
    own characteristic appearance in power consumption traces. For example, a multiplication
    operation can be distinguished from a load instruction: microcontrollers use different
    circuitry to handle multiplication instructions from the circuitry they use when
    performing load instructions. The result is a unique power consumption signature
    for each process.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 依赖于观察每条微控制器指令在功耗轨迹中的独特表现。例如，乘法操作可以与加载指令区分开：微控制器使用不同的电路来处理乘法指令和加载指令的电路。因此，每个过程都会有一个独特的功耗特征。
- en: SPA differs from the timing attack discussed in the previous section, in that
    SPA allows you to examine the execution of an algorithm. You can analyze the timing
    of both individual operations and identifiable power profiles of operations. If
    any operation depends on a secret key, you may be able to determine that key.
    You can even use SPA attacks to recover secrets when you can’t interact with a
    device and can observe it only while it’s performing the cryptographic operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 与前一节讨论的定时攻击不同，SPA 让你可以检查算法的执行过程。你可以分析每个操作的时序以及操作的可识别功率特征。如果某个操作依赖于秘密密钥，你可能能够确定该密钥。即使你无法与设备交互，且只能在设备执行加密操作时观察它，你也可以使用
    SPA 攻击来恢复密钥。
- en: Applying SPA to RSA
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 SPA 应用到 RSA
- en: Let’s apply the SPA technique to a cryptographic algorithm. We’ll concentrate
    on asymmetric encryption, where we’ll look at operations using the private key.
    The first algorithm to consider will be the RSA cryptosystem, where we’ll investigate
    a decryption operation. At the core of the RSA cryptosystem is the modular exponentiation
    algorithm, which calculates *m*[*e*] = *c* mod *n*, where *m* is the message,
    *c* is the ciphertext, and mod *n* is the modulus operation. If you aren’t familiar
    with RSA, we recommend picking up *Serious Cryptography* by Jean-Philippe Aumasson
    (also published by No Starch Press), which covers the theory in an approachable
    manner. We also provided a quick overview of RSA in Chapter 6, but for the following
    side-channel work, you don’t need to understand anything about RSA besides the
    fact that it processes data and a secret key.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 SPA 技术应用于一个加密算法。我们将专注于非对称加密，尤其是使用私钥的操作。第一个考虑的算法是 RSA 加密系统，我们将研究一个解密操作。RSA
    加密系统的核心是模幂运算算法，该算法计算 *m*[*e*] = *c* mod *n*，其中 *m* 是消息，*c* 是密文，mod *n* 是取模运算。如果你不熟悉
    RSA，我们建议阅读 Jean-Philippe Aumasson 的《Serious Cryptography》（也由 No Starch Press 出版），这本书以通俗易懂的方式介绍了理论。我们在第
    6 章也提供了对 RSA 的快速概述，但对于接下来的侧信道分析，你只需了解它处理数据和一个密钥的事实，不需要理解 RSA 的任何其他内容。
- en: This secret key is part of the processing done in the modular exponentiation
    algorithm, and [Listing 8-2](#listing8-2) shows one possible implementation of
    a modular exponentiation algorithm.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个秘密密钥是模幂运算算法中处理的一部分，[列表 8-2](#listing8-2) 展示了一个可能的模幂运算算法实现。
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: An implementation of the square-and-multiply algorithm'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-2：平方-乘法算法的实现
- en: This algorithm happens to be at the heart of an RSA implementation you might
    find as taught from a classic textbook. This particular algorithm is called a
    *square-and-multiply exponentiation*, hard-coded for a 10-bit secret key, represented
    by the `secret_data` variable. (Usually the `secret_data` would be a much longer
    key in the range of thousands of bits, but for this example, we’ll keep it short.)
    Variable `m` is the message we are trying to decrypt. The system defenses will
    have been penetrated at the point when an attacker determines the value of `secret_data`.
    Side-channel analysis on this algorithm is a tactic that can break the system.
    Note that we skip the square on the first iteration. The first `if (i > 0)` is
    not part of the leakage we are attacking; it’s just part of the algorithm construction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法恰好位于你可能会在经典教科书中学到的 RSA 实现的核心。这个特定的算法叫做 *平方-乘法指数*，是针对一个 10 位密钥硬编码的，密钥由 `secret_data`
    变量表示。（通常，`secret_data` 会是一个更长的密钥，位数在几千位范围内，但为了这个例子，我们保持它较短。）变量 `m` 是我们尝试解密的消息。当攻击者确定
    `secret_data` 的值时，系统防御已经被突破。对这个算法进行侧信道分析是一种可以攻破系统的策略。注意，我们在第一次迭代时跳过了平方操作。第一个 `if
    (i > 0)` 不是我们攻击的泄漏部分，它只是算法构造的一部分。
- en: SPA can be used to look at the execution of this algorithm and determine its
    code path. If we can recognize whether `P * s` has been executed, we can find
    the value of one bit of `secret_data`. If we can recognize this for every iteration
    of the loop, we may be able to literally read the secret from a power consumption
    oscilloscope trace during code execution (see [Figure 8-7](#figure8-7)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SPA可以用来查看这个算法的执行并确定其代码路径。如果我们能够识别是否执行了`P * s`，就能找到`secret_data`的一个位的值。如果我们能为每次循环迭代识别这一点，那么我们可能能够直接从功耗示波器的跟踪中读取这个秘密（见[图8-7](#figure8-7)）。
- en: Before we explain how to read this trace, take a good look at the trace and
    try to map the execution of the algorithm onto it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释如何读取这个跟踪之前，仔细观察一下跟踪，并尝试将算法的执行与其对应起来。
- en: '![f08007](image_fi/278748c08/f08007.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![f08007](image_fi/278748c08/f08007.png)'
- en: 'Figure 8-7: Power consumption trace of a square-and-multiply execution'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7：平方与乘法执行的功耗跟踪
- en: 'Notice some interesting patterns between roughly 5ms and 12ms (between 50 and
    120 on the 100µs unit x-axis): blocks of approximately 0.9ms and 1.1ms interspersed
    among each other. We can refer to the shorter blocks as Q (quick) and to the longer
    blocks as L (long). Q occurs 10 times, and L occurs four times; in sequence, they
    are QLQQQQLQLQQQQL. This is the visualization part of SPA signal analysis.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在大约5毫秒到12毫秒之间（100µs单位x轴上的50到120之间）的一些有趣的模式：大约0.9毫秒和1.1毫秒的块交替出现。我们可以将较短的块称为Q（快速），将较长的块称为L（长）。Q出现了10次，L出现了四次；它们的顺序是QLQQQQLQLQQQQL。这是SPA信号分析的可视化部分。
- en: 'Now we need to interpret this information by relating it to something secret.
    If we assume that `s * s` and `P * s` are the computationally expensive operations,
    we should see two variations of the outer loop: some with only a square (S, `(s
    * s)`) and others that are both a square and a multiply (SM, `(s * s)` followed
    by `(P * s)`). We’ve carefully ignored the `i = 0` case, which doesn’t have `(s
    * s)`, but we’ll get to that.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过将这些信息与某些秘密相关联来进行解释。如果我们假设`s * s`和`P * s`是计算上昂贵的操作，我们应该能看到外循环的两种变体：一种仅包含平方（S，`(s
    * s)`），另一种既包含平方也包含乘法（SM，`(s * s)`接着是`(P * s)`）。我们小心地忽略了`i = 0`的情况，因为它没有`(s * s)`，但我们会讨论这个问题。
- en: 'We know that S is executed when a bit is 0, and SM is executed when a bit equals
    1\. There is just one missing piece: does each block in the trace equate to a
    single S or single M operation, or does each block in the trace equate to a single
    loop iteration, and thus either a single S or combined SM operation? In other
    words, is our mapping {Q → S, L → M} or {Q → S, L → SM}?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当位为0时执行S操作，而当位为1时执行SM操作。现在缺少的一个部分是：跟踪中的每个块是否对应单一的S操作或单一的M操作，还是每个块对应一个循环迭代，因此可能是单一的S操作或结合的SM操作？换句话说，我们的映射是{Q
    → S, L → M}，还是{Q → S, L → SM}？
- en: A hint to the answer lies in the sequence QLQQQQLQLQQQQL. Note that every L
    is preceded by a Q, and there are no LL sequences. Per the algorithm, every M
    has to be preceded by an S (except in the first iteration), and there are no MM
    sequences. This indicates {Q → S, L → M} is the right mapping as the {Q → S, L
    → SM} mapping would likely have also given rise to an LL sequence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 答案的线索就在序列QLQQQQLQLQQQQL中。注意，每个L前面都有一个Q，并且没有LL序列。根据算法，每个M必须在S之前（第一次迭代除外），并且没有MM序列。这表明{Q
    → S, L → M}是正确的映射，因为{Q → S, L → SM}映射可能也会产生LL序列。
- en: 'This allows us to map the patterns to operations and operations to secret bits,
    which means QLQQQQLQLQQQQL becomes the operations SM,S,S,S,SM,SM,S,S,S,SM. The
    first bit processed by the algorithm is the least significant bit of the key,
    and the first sequence we observe is SM. Since the algorithm skips the S for the
    least significant bit, we know the initial SM must come from the next loop iteration
    and thus the next bit. With that knowledge, we can reconstruct the key: 10001100010.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将模式映射到操作，并将操作映射到秘密位，这意味着QLQQQQLQLQQQQL将变为操作SM,S,S,S,SM,SM,S,S,S,SM。算法处理的第一个位是密钥的最低有效位，我们观察到的第一个序列是SM。由于算法跳过了最低有效位的S操作，我们知道初始的SM必须来自下一个循环迭代，因此是下一个位。有了这个信息，我们就能重建密钥：10001100010。
- en: Applying SPA to RSA, Redux
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将SPA应用于RSA，Redux
- en: 'The implementation of modular exponentiation in RSA implementations will vary,
    and some variants may require more effort to break. But fundamentally, finding
    differences in processing a 0 or 1 bit is the starting point for an SPA attack.
    As an example, the RSA implementation of ARM’s open source MBED-TLS library uses
    something called *windowing*. It processes multiple bits of the secret at a time
    (a *window*), which theoretically means the attack is more complicated because
    the algorithm does not process individual bits. Praveen Kumare Vadnala and Lukasz
    Chmielewski’s “Attacking OpenSSL Using Side-Channel Attacks: The RSA Case Study”
    describes a complete attack on the windowing implementation used by MBED-TLS.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: RSA实现中的模幂运算实现会有所不同，一些变体可能需要更多的努力才能破解。但从根本上讲，找到处理0位或1位的差异是SPA攻击的起点。例如，ARM开源的MBED-TLS库的RSA实现使用了一种叫做*窗口化*的方法。它一次处理多个秘密密钥位（一个*窗口*），这在理论上意味着攻击更复杂，因为该算法不会逐个位地处理。Praveen
    Kumare Vadnala和Lukasz Chmielewski的《利用侧信道攻击攻击OpenSSL：RSA案例研究》描述了对MBED-TLS使用的窗口化实现的完整攻击。
- en: We specifically call out that having a simple model is a good starting point,
    even when the implementation isn’t exactly the same as the model, because even
    the best implementations may have flaws that can be explained/exploited by the
    simple model. The implementation of the windowing modular exponentiation function
    used by MBED-TLS version 2.26.0 in the RSA decryption is such an example. In the
    following discussion, we’ve taken the *bignum.c* file from MBED-TLS and simplified
    part of the `mbedtls_mpi_exp_mod` function to produce the code in [Listing 8-3](#listing8-3),
    which assumes we have a `secret_key` variable holding the secret key, and a `secret_key_size`
    variable holding the number of bits to process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别指出，拥有一个简单的模型是一个很好的起点，即使实现与模型不完全相同，因为即使是最好的实现也可能存在可以通过简单模型解释/利用的缺陷。MBED-TLS版本2.26.0中用于RSA解密的窗口化模幂运算函数的实现就是一个例子。在接下来的讨论中，我们已经从MBED-TLS中提取了*bignum.c*文件，并简化了`mbedtls_mpi_exp_mod`函数的部分代码，生成了[清单8-3](#listing8-3)中的代码，这假设我们有一个存储秘密密钥的`secret_key`变量，以及一个存储要处理的位数的`secret_key_size`变量。
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Pseudocode of *bignum.c* showing part of the `mbedtls_mpi_exp_mod`
    implementation flow'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8-3：*bignum.c*的伪代码，展示了`mbedtls_mpi_exp_mod`实现流程的一部分
- en: We’ll refer you to original line numbers of the *bignum.c* file in MBED-TLS
    version 2.26.0 in case you want to find the specific implementation. To start,
    the outer `for()` loop 1 from [Listing 8-3](#listing8-3) is implemented as a `while(1)`
    loop in MBED-TLS and can be found at line 2227.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将参考MBED-TLS版本2.26.0中*bignum.c*文件的原始行号，以便您可以找到具体的实现。如果您想查找，外部的`for()`循环1在[清单8-3](#listing8-3)中实现为`while(1)`循环，并可以在第2227行找到。
- en: One bit of the secret key is loaded into the `ei` variable 2 (line 2241 in original
    file). As part of the modular exponentiation implementation, the function will
    process the secret key bits until the first bit with a value of 1 is reached.
    To perform this processing, the `state` variable is a flag indicating whether
    we are done processing all the leading zeros. We can see the comparison at 3,
    which skips to the next iteration of the loop if `state == 0` (meaning we haven’t
    seen a 1 bit yet) and the current secret key bit (`ei`) is 0.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个秘密密钥位被加载到`ei`变量中2（在原文件的第2241行）。作为模幂运算实现的一部分，该函数将处理秘密密钥的位，直到遇到第一个值为1的位为止。为了执行此处理，`state`变量是一个标志，指示我们是否已经完成了所有前导零的处理。我们可以看到在3处的比较，如果`state
    == 0`（意味着我们还没有看到1位）并且当前的秘密密钥位（`ei`）是0时，跳过循环的下一次迭代。
- en: Interestingly, the order of operations in the comparison 3 turns out to be a
    completely fatal flaw for this function. The trusty C compiler will *often* first
    perform the `ei == 0` comparison before the `state == 0` comparison. The `ei comparison
    *always* leaks the value of the secret key bit 4, for all of the key bits. It
    turns out you can pick this up with SPA.`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，比较3中的操作顺序对于此函数来说是一个完全致命的缺陷。值得信赖的C编译器*通常*会首先执行`ei == 0`的比较，而不是`state ==
    0`的比较。`ei`比较*总是*泄露秘密密钥位4的值，对于所有密钥位而言。事实证明，您可以通过SPA（侧信道攻击）捕捉到这一点。
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
