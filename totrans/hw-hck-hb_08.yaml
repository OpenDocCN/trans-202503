- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve Got the Power: Introduction to Power Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll often hear that cryptographic algorithms are unbreakable, regardless
    of the huge advances in computing power. That is true. However, as you’ll learn
    in this chapter, the key to finding vulnerabilities in cryptographic algorithms
    lies in their implementation, no matter how “military grade” they are.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we won’t be discussing crypto implementation errors, such as failed
    bounds checks, in this chapter. Instead, we’ll exploit the very nature of digital
    electronics using side channels to break algorithms that, on paper, appear to
    be secure. A *side channel* is some observable aspect of a system that reveals
    secrets held within that system. The techniques we describe leverage vulnerabilities
    that arise from the physical implementation of these algorithms in hardware, primarily
    in the way that digital devices use power. We’ll start with data-dependent execution
    time, which we can determine by monitoring power consumption, and then we’ll move
    on to monitoring power consumption as a means to identify key bits in cryptographic
    processing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considerable historical precedence exists for side-channel analysis. For example,
    during the Second World War, the British were interested in estimating the number
    of tanks being produced by the Germans. The most reliable way to do so turned
    out to be a statistical analysis of the sequence of serial numbers from captured
    or disabled tanks, assuming that serial numbers typically increment in a straightforward
    manner. The attacks we’ll present in this chapter mirror this so-called *German
    Tank Problem*: they combine statistics with assumptions and ultimately use a small
    amount of data that our adversary unknowingly leaked to us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other historical side-channel attacks monitor unintended electronic signals
    emanating from the hardware. In fact, almost as soon as electronic systems were
    used to pass secure messages, they were subject to attack. One such famous early
    attack was the TEMPEST attack, launched by Bell Labs scientists in WWII to decode
    electronic typewriter key presses from 80 feet away with a 75 percent accuracy
    (see “TEMPEST: A Signal Problem” by the USA’s National Security Agency). TEMPEST
    has since been used to reproduce what is being displayed on a computer monitor
    by picking up the monitor’s radio signal emissions from outside the building (see,
    for instance, Wim van Eck’s “Electromagnetic Radiation from Video Display Units:
    An Eavesdropping Risk?”). And while the original TEMPEST attack used CRT-type
    monitors, this same vulnerability has been demonstrated on more recent LCD displays
    by Markus G. Kuhn in “Electromagnetic Eavesdropping Risks of Flat-Panel Displays,”
    so it’s far from outdated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll show you something even more surreptitious than TEMPEST, though: a way
    to use unintended emissions from hardware to break otherwise secure cryptographic
    algorithms. This strategy covers both software running on hardware (such as firmware
    on a microcontroller) and pure hardware implementations of the algorithms (such
    as cryptographic accelerators). We’ll describe how to measure, how to process
    your measurement to improve leakage, and how to extract secrets. We’ll cover topics
    that have their roots in areas ranging all the way from chip and printed circuit
    board (PCB) design, through electronics, electromagnetism, and (digital) signal
    processing, to statistics, cryptography, and even to common sense.'
  prefs: []
  type: TYPE_NORMAL
- en: Timing Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Timing is everything. Consider what happens when implementing a personal identification
    number (PIN) code check, like one you’d find on a wall safe or door alarm. The
    designer allows you to enter the complete PIN (say, four digits) before comparing
    the entered PIN with the stored secret code. In C code, it could look something
    like [Listing 8-1](#listing8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Sample PIN code check written in C'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like a pretty reasonable piece of code, right? We read in four digits.
    If they match the secret code, the function returns a `1`; otherwise, it returns
    a `0`. Ultimately, we can use this return value to open a safe or disarm the security
    system by pressing the valid button after the four digits have been entered. A
    red error LED illuminates to show that the PIN is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: How might this safe be attacked? Assuming that the PIN accepts the numbers 0
    through 9, testing all possible combinations would require a total of 10 × 10
    × 10 × 10 = 10,000 guesses. On average, we would have to perform 5,000 guesses
    to find the PIN, but that would take a long time, and the system might limit the
    speed at which we can repeatedly enter guesses.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can reduce the number of guesses to 40 using a technique called
    a *timing attack*. Assume we have the keypad shown in [Figure 8-1](#figure8-1).
    The C key (for clear) clears the entry, and the V key (for valid) validates it.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](image_fi/278748c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: A simple keypad'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the attack, we connect two oscilloscope probes to the keypad: one
    to the connecting wire on the V button and the other to the connecting wire on
    the error LED. We then enter PIN 0000\. (Of course, we are assuming we have access
    to a copy of this PIN pad that we’ve now dissected.) We press the V button, watch
    our oscilloscope trace, and measure the time difference between the V button being
    pressed and the error LED illuminating. The execution of the loop in [Listing
    8-1](#listing8-1) tells us that the function will take longer to return a failed
    result if the first three numbers in the PIN are correct and only the final check
    fails than it would take if the first number had been incorrect from the start.'
  prefs: []
  type: TYPE_NORMAL
- en: The attack cycles through all possibilities for the first digit of the PIN (0000,
    1000, 2000, through 9000) while recording the time delay between pressing the
    V button and the error LED illuminating. [Figure 8-2](#figure8-2) shows the timing
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](image_fi/278748c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Determination of loop delay time'
  prefs: []
  type: TYPE_NORMAL
- en: We expect that when the first PIN digit is correct (let’s say it’s a 1), the
    delay will increase before the error LED goes high, which happens only after the
    second digit has been compared to `correct_pin[]`. We now know the correct first
    digit. The top part of [Figure 8-2](#figure8-2) shows that when the valid button
    is pressed after a completely incorrect sequence, the error LED turns on within
    a short amount of time (t[bad]). Compare this to the valid button being pressed
    after a partially correct sequence (the first button was correct in this partial
    sequence). Now the error LED takes a longer amount of time (t[correct]) since
    the first number was correct, but upon comparing the second number, it turns on
    the error LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the attack by trying every possibility for the second digit: entering
    1000, 1100, 1200 through 1900\. Once again, we expect that for the correct digit
    (let’s say it’s 3), the delay will increase before the error LED goes high.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeating this attack for the third digit, we determine that the first three
    digits are 133\. Now it’s a simple matter of guessing the final digit and seeing
    which one unlocks the system (let’s say it’s 7). The PIN combination is, thus,
    1337\. (Considering the audience of this book, we realize we may have just published
    your PIN. Change it now.)
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to this method is that we discover the digits incrementally by
    knowing the position in the PIN sequence of the incorrect digit. This little bit
    of information has a big impact. Instead of a maximum of 10 × 10 × 10 × 10 guesses,
    we now need to make no more than 10 + 10 + 10 + 10 = 40 guesses. If we are locked
    out after three unsuccessful attempts, the probability of guessing the PIN has
    been improved from 3/1000 (0.3 percent) to 3/40 (7.5 percent). Further, assuming
    the PIN is selected randomly (which in reality is a poor assumption), we would
    on average *find* the guess halfway through our guessing sequence. This means,
    on average, we need to guess only five numbers for each digit, so we have an average
    total of 20 guesses with our assisted attack.
  prefs: []
  type: TYPE_NORMAL
- en: We call this a *timing attack*. We measured only the time between two events
    and used that information to recover part of the secret. Can it really be as easy
    in practice? Here’s a real-life example.
  prefs: []
  type: TYPE_NORMAL
- en: Hard Drive Timing Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a hard drive enclosure with a PIN-protected partition—in particular,
    the Vantec Vault, model number NSTV290S2.
  prefs: []
  type: TYPE_NORMAL
- en: The Vault hard drive enclosure works by messing with the drive’s partition table
    so that it doesn’t appear in the host operating system; the enclosure doesn’t
    actually encrypt anything. When the correct PIN is entered into the Vault, valid
    partition information is made accessible to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious way to attack the Vault might be to repair the partition table
    manually on the drive, but we can also use a timing attack against its PIN-entry
    logic—one that’s more in line with our side-channel power analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the PIN pad example discussed earlier, we first need to determine when
    a button is *read*, because in this device, the microcontroller only occasionally
    *scans* the buttons. Each scan requires checking the status of each button to
    determine whether it has been pressed. This scanning technique is standard in
    hardware that must receive input from buttons. It frees the microcontroller in
    the hardware to do work in the 100ms or so between checking for button presses,
    which maintains the illusion of instantaneous response to us comparatively slow
    and clumsy humans.
  prefs: []
  type: TYPE_NORMAL
- en: When performing a scan, the microcontroller sets some line to a positive voltage
    (high). We can use this transition as a trigger to indicate when a button is being
    read. While a button is pressed, the time delay from this line going high to the
    *error* event gives us the timing information we need for our attack. [Figure
    8-3](#figure8-3) shows that line B goes high only when the microcontroller is
    reading the button status *and* the button is being pressed at the same time.
    Our primary challenge is to trigger the capture when that high value propagates
    through the button, not just when the button is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](image_fi/278748c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Hard drive attack timing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: This simple example shows how the microcontroller checks the state of the button
    only every 50ms, as shown by the upper timing line A. It can detect the button
    press only during brief high pulses at those 50ms intervals. The presence of a
    button press is indicated by the correspondingly brief high pulse that the A line
    pulse allows through onto the B line.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-4](#figure8-4) shows the buttons along the right-hand side of the
    hard drive enclosure by which a six-digit PIN code is entered. Only once the entire
    correct PIN is entered does the hard drive reveal its contents to the operating
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: It so happens that the correct PIN code in our hard drive is 123456 (the same
    combination as on our luggage), and [Figure 8-5](#figure8-5) demonstrates how
    we can read this out.
  prefs: []
  type: TYPE_NORMAL
- en: The top line is the error signal, and the bottom line is the button scan signal.
    The vertical cursors are aligned to the rising edge of the button scan signal
    and to the falling edge of the errorsignal. We’re interested in the time difference
    between those cursors, which corresponds to the time the microcontroller needs
    to process the PIN entry before it responds with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the top part of the figure, we see the timing information where the
    first digit is incorrect. The time delay between the first rising edge of the
    button scan and the falling edge of the errorsignal gives us the processing time.
    By comparison, the bottom part of the figure shows the same waveforms when the
    first digit is correct. Notice that the time delay isslightly longer. This longer
    delay is due to the password-checking loop accepting the first digit and then
    going to check the next digit. In this way, we can identify the first digit of
    the password.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08004](image_fi/278748c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Vantec Vault NSTV290S2 hard drive enclosure'
  prefs: []
  type: TYPE_NORMAL
- en: '![f08005](image_fi/278748c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Hard drive timing measurement'
  prefs: []
  type: TYPE_NORMAL
- en: The next stage of the attack is to iterate through all options for the second
    digit (that is, testing 106666, 116666 . . . 156666, 166666) and looking for a
    similar jump in processing delay. This jump in delay again indicates that we have
    found the correct value of a digit and can then attack the next digit.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a timing attack to guess the password for the Vault in (at most)
    60 guesses (10 + 10 + 10 + 10 + 10 + 10), which should take no longer than 10
    minutes doing it manually. Yet, the manufacturer claims that the Vault has one
    million combinations (10 × 10 × 10 × 10 × 10 × 10), which is true when entering
    guesses of the PIN. However, our timing attack reduces the number of combinations
    we actually need to try to 0.006 percent of the total number of combinations.
    No countermeasures such as random delays complicate our attack, and the drive
    doesn’t provide a lock-out mechanism that prevents the user from entering an unlimited
    number of guesses.
  prefs: []
  type: TYPE_NORMAL
- en: Power Measurements for Timing Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say that in an attempt to thwart a timing attack, someone has inserted
    a small random delay before illuminating the error LED. The underlying password
    check is the same as that in [Listing 8-1](#listing8-1), but now the time delay
    between pressing the V button and the error LED illuminating no longer clearly
    indicates the position of an incorrect digit.
  prefs: []
  type: TYPE_NORMAL
- en: Now assume we’re able to measure the power consumption of the microcontroller
    that’s executing the code. (We’ll explain how to do this in the section “Preparing
    the Oscilloscope” in Chapter 9.) The power consumption might look something like
    [Figure 8-6](#figure8-6), which shows the power trace of a device while it’s performing
    an operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08006](image_fi/278748c08/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: A sample power consumption trace of a device performing an operation'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the repetitive nature of the power consumption trace. Oscillations will
    occur at a rate similar to the microcontroller’s operating frequency. Most transistor-switching
    activity on the chip happens at the edges of the clock, and thus the power consumption
    also spikes close to those moments. The same principle applies even to high-speed
    devices, such as Arm microcontrollers or custom hardware.
  prefs: []
  type: TYPE_NORMAL
- en: We can glean some information about what a device is doing based on this power
    signature. For example, if the random delay discussed earlier is implemented as
    a simple `for` loop that counts from 0 to a random number *n*, it will appear
    as a pattern that is repeated *n* times. In window B of [Figure 8-6](#figure8-6),
    a pattern (in this case, the simple pulse) is repeated four times, so if we expect
    a random delay, that sequence of four pulses may be the delay. If we record a
    few of these power traces using the same PIN, and all patterns are the same except
    for different numbers of pulses similar to window B, that would indicate a random
    process around window B. This randomness could be either a truly random process
    or some pseudorandom process (pseudorandom normally being a purely deterministic
    process generating the “randomness”). For example, if you reset the device, you
    might see the same consecutive repetitions in window B, which indicates it’s not
    truly random. But of more interest, if we vary the PIN and see the number of patterns
    that look like those in window A change, we have a good idea that the power sequence
    around window A represents the comparison function. Thus, we can focus our timing
    attack on that section of the power trace.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between this approach and previous timing attacks is that we
    don’t have to measure timing over an entire algorithm but instead can choose specific
    parts of an algorithm that happen to have a characteristic signal. We can use
    similar techniques to break cryptographic implementations, as we’ll describe next.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Power Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything is relative, and so is the simplicity of *simple power analysis (SPA)*
    with respect to *differential power analysis (DPA)*. The term *simple power analysis*
    has its origins in the 1998 paper “Differential Power Analysis” by Paul Kocher,
    Joshua Jaffe, and Benjamin Jun, where SPA was coined along with the more complex
    DPA. Bear in mind, however, that performing SPA can sometimes be more complex
    than performing DPA in some leakage scenarios. You can perform an SPA attack by
    observing a single execution of the algorithm, whereas a DPA attack involves multiple
    executions of an algorithm with varying data. DPA generally analyzes statistical
    differences between hundreds to billions of traces. While you can perform SPA
    in a single trace, it may involve a few to thousands of traces—the additional
    traces are included to reduce noise. The most basic example of an SPA attack is
    to inspect power traces visually, which can break weak cryptographic implementations
    or PIN verifications, as shown earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'SPA relies on the observation that each microcontroller instruction has its
    own characteristic appearance in power consumption traces. For example, a multiplication
    operation can be distinguished from a load instruction: microcontrollers use different
    circuitry to handle multiplication instructions from the circuitry they use when
    performing load instructions. The result is a unique power consumption signature
    for each process.'
  prefs: []
  type: TYPE_NORMAL
- en: SPA differs from the timing attack discussed in the previous section, in that
    SPA allows you to examine the execution of an algorithm. You can analyze the timing
    of both individual operations and identifiable power profiles of operations. If
    any operation depends on a secret key, you may be able to determine that key.
    You can even use SPA attacks to recover secrets when you can’t interact with a
    device and can observe it only while it’s performing the cryptographic operation.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SPA to RSA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s apply the SPA technique to a cryptographic algorithm. We’ll concentrate
    on asymmetric encryption, where we’ll look at operations using the private key.
    The first algorithm to consider will be the RSA cryptosystem, where we’ll investigate
    a decryption operation. At the core of the RSA cryptosystem is the modular exponentiation
    algorithm, which calculates *m*[*e*] = *c* mod *n*, where *m* is the message,
    *c* is the ciphertext, and mod *n* is the modulus operation. If you aren’t familiar
    with RSA, we recommend picking up *Serious Cryptography* by Jean-Philippe Aumasson
    (also published by No Starch Press), which covers the theory in an approachable
    manner. We also provided a quick overview of RSA in Chapter 6, but for the following
    side-channel work, you don’t need to understand anything about RSA besides the
    fact that it processes data and a secret key.
  prefs: []
  type: TYPE_NORMAL
- en: This secret key is part of the processing done in the modular exponentiation
    algorithm, and [Listing 8-2](#listing8-2) shows one possible implementation of
    a modular exponentiation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: An implementation of the square-and-multiply algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm happens to be at the heart of an RSA implementation you might
    find as taught from a classic textbook. This particular algorithm is called a
    *square-and-multiply exponentiation*, hard-coded for a 10-bit secret key, represented
    by the `secret_data` variable. (Usually the `secret_data` would be a much longer
    key in the range of thousands of bits, but for this example, we’ll keep it short.)
    Variable `m` is the message we are trying to decrypt. The system defenses will
    have been penetrated at the point when an attacker determines the value of `secret_data`.
    Side-channel analysis on this algorithm is a tactic that can break the system.
    Note that we skip the square on the first iteration. The first `if (i > 0)` is
    not part of the leakage we are attacking; it’s just part of the algorithm construction.
  prefs: []
  type: TYPE_NORMAL
- en: SPA can be used to look at the execution of this algorithm and determine its
    code path. If we can recognize whether `P * s` has been executed, we can find
    the value of one bit of `secret_data`. If we can recognize this for every iteration
    of the loop, we may be able to literally read the secret from a power consumption
    oscilloscope trace during code execution (see [Figure 8-7](#figure8-7)).
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain how to read this trace, take a good look at the trace and
    try to map the execution of the algorithm onto it.
  prefs: []
  type: TYPE_NORMAL
- en: '![f08007](image_fi/278748c08/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: Power consumption trace of a square-and-multiply execution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice some interesting patterns between roughly 5ms and 12ms (between 50 and
    120 on the 100µs unit x-axis): blocks of approximately 0.9ms and 1.1ms interspersed
    among each other. We can refer to the shorter blocks as Q (quick) and to the longer
    blocks as L (long). Q occurs 10 times, and L occurs four times; in sequence, they
    are QLQQQQLQLQQQQL. This is the visualization part of SPA signal analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to interpret this information by relating it to something secret.
    If we assume that `s * s` and `P * s` are the computationally expensive operations,
    we should see two variations of the outer loop: some with only a square (S, `(s
    * s)`) and others that are both a square and a multiply (SM, `(s * s)` followed
    by `(P * s)`). We’ve carefully ignored the `i = 0` case, which doesn’t have `(s
    * s)`, but we’ll get to that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that S is executed when a bit is 0, and SM is executed when a bit equals
    1\. There is just one missing piece: does each block in the trace equate to a
    single S or single M operation, or does each block in the trace equate to a single
    loop iteration, and thus either a single S or combined SM operation? In other
    words, is our mapping {Q → S, L → M} or {Q → S, L → SM}?'
  prefs: []
  type: TYPE_NORMAL
- en: A hint to the answer lies in the sequence QLQQQQLQLQQQQL. Note that every L
    is preceded by a Q, and there are no LL sequences. Per the algorithm, every M
    has to be preceded by an S (except in the first iteration), and there are no MM
    sequences. This indicates {Q → S, L → M} is the right mapping as the {Q → S, L
    → SM} mapping would likely have also given rise to an LL sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to map the patterns to operations and operations to secret bits,
    which means QLQQQQLQLQQQQL becomes the operations SM,S,S,S,SM,SM,S,S,S,SM. The
    first bit processed by the algorithm is the least significant bit of the key,
    and the first sequence we observe is SM. Since the algorithm skips the S for the
    least significant bit, we know the initial SM must come from the next loop iteration
    and thus the next bit. With that knowledge, we can reconstruct the key: 10001100010.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying SPA to RSA, Redux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation of modular exponentiation in RSA implementations will vary,
    and some variants may require more effort to break. But fundamentally, finding
    differences in processing a 0 or 1 bit is the starting point for an SPA attack.
    As an example, the RSA implementation of ARM’s open source MBED-TLS library uses
    something called *windowing*. It processes multiple bits of the secret at a time
    (a *window*), which theoretically means the attack is more complicated because
    the algorithm does not process individual bits. Praveen Kumare Vadnala and Lukasz
    Chmielewski’s “Attacking OpenSSL Using Side-Channel Attacks: The RSA Case Study”
    describes a complete attack on the windowing implementation used by MBED-TLS.'
  prefs: []
  type: TYPE_NORMAL
- en: We specifically call out that having a simple model is a good starting point,
    even when the implementation isn’t exactly the same as the model, because even
    the best implementations may have flaws that can be explained/exploited by the
    simple model. The implementation of the windowing modular exponentiation function
    used by MBED-TLS version 2.26.0 in the RSA decryption is such an example. In the
    following discussion, we’ve taken the *bignum.c* file from MBED-TLS and simplified
    part of the `mbedtls_mpi_exp_mod` function to produce the code in [Listing 8-3](#listing8-3),
    which assumes we have a `secret_key` variable holding the secret key, and a `secret_key_size`
    variable holding the number of bits to process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Pseudocode of *bignum.c* showing part of the `mbedtls_mpi_exp_mod`
    implementation flow'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll refer you to original line numbers of the *bignum.c* file in MBED-TLS
    version 2.26.0 in case you want to find the specific implementation. To start,
    the outer `for()` loop 1 from [Listing 8-3](#listing8-3) is implemented as a `while(1)`
    loop in MBED-TLS and can be found at line 2227.
  prefs: []
  type: TYPE_NORMAL
- en: One bit of the secret key is loaded into the `ei` variable 2 (line 2241 in original
    file). As part of the modular exponentiation implementation, the function will
    process the secret key bits until the first bit with a value of 1 is reached.
    To perform this processing, the `state` variable is a flag indicating whether
    we are done processing all the leading zeros. We can see the comparison at 3,
    which skips to the next iteration of the loop if `state == 0` (meaning we haven’t
    seen a 1 bit yet) and the current secret key bit (`ei`) is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the order of operations in the comparison 3 turns out to be a
    completely fatal flaw for this function. The trusty C compiler will *often* first
    perform the `ei == 0` comparison before the `state == 0` comparison. The `ei comparison
    *always* leaks the value of the secret key bit 4, for all of the key bits. It
    turns out you can pick this up with SPA.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
