<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch12" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch12">
<span class="CN"><span aria-label=" Page 179. " epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TRANSFERRING DATA TO AND FROM USB FLASH DRIVES</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">USB flash drives are a convenient tool to move data to and from your Arduino projects. This chapter shows you how to transfer data to and from these forms of portable storage, using your Arduino and an inexpensive interface module.</p>
<p class="TX">You can use these methods of recording and retrieving data to create more user-friendly ways of interfacing information with your projects. For example, you could change the movements of an Arduino-controlled robot by having it read control values from the USB flash drive, or you could change the times for an automated sprinkler controller without needing to have a physical user interface.</p>
<p class="TX">In this chapter, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Install and test USB flash drive modules</li>
<li class="BL">Write and append data from your Arduino to a USB flash drive</li>
<li class="BL"><span aria-label=" Page 180. " epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>Log sensor data to a USB flash drive</li>
<li class="BL">Read numbers and text from a USB flash drive into your Arduino</li>
<li class="BL">Build a project USB security key</li>
<li class="BL">Configure Arduino projects with external data from a USB flash drive</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-82"/><samp class="SANS_Futura_Std_Bold_B_11">Selecting and Preparing a USB Flash Drive</samp></h2>
<p class="TNI">There are many brands and types of USB flash drives on the market. Because of the idiosyncrasies of the interface module, some units may or may not work at all. After some testing, I’ve found that Lexar- and Toshiba-branded flash drives have been successful. Ensure that they are advertised as USB 2.0, not USB 3.0.</p>
<p class="TX">USB flash drives should ship preformatted. However, if you find that they don’t work reliably, you may need to reformat them yourself. In this case, use the FAT32 filesystem with a 16KB allocation unit size.</p>
<p class="TX">Whenever it’s time to remove the USB flash drive from your PC, always use the safe removal option provided by your computer’s operating system. Don’t just pull the flash drive out when you think the PC is finished with the drive, as this will often make the drive unreadable to the USB interface module.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-83"/><samp class="SANS_Futura_Std_Bold_B_11">The USB Interface Module</samp></h2>
<p class="TNI">To work with USB flash drives, you’ll need an interface module based around the CH376S USB file manager and control IC—for example, PMD Way part 566592, shown in <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE CH376 USB FLASH DRIVE MODULE" class="img5" id="fig12-1" src="../images/fig12-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: A USB flash drive interface module</samp></p></figcaption>
</figure>
<p class="TX">You can use many possible interfaces to make connections between the module and a microcontroller. For the purposes of this chapter, we’ll use <span aria-label=" Page 181. " epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/>a 9,600 bps serial UART connection between the module and a software serial port on the Arduino.</p>
<p class="TX">Since the module setup for all the projects in this chapter is the same, let’s begin by testing your module with the required configuration. Locate the header pin jumper in the 2 <span class="symbol">×</span> 3 group of header pins below the USB socket and then place the jumper across the second and third pins on the top row, as shown in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>. This sets the unit into serial interface mode. If your module has a 1 <span class="symbol">×</span> 3 set of jumper pins, you may need to try both options (jumpering 1 and 2 or 2 and 3, if the pins aren’t labeled).</p>
<figure class="IMG"><img alt="A PHOTO OF THE CH376 USB FLASH DRIVE MODULE’S CONFIGURATION JUMPERS" class="img3" id="fig12-2" src="../images/fig12-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Setting the jumper on the USB flash drive interface module</samp></p></figcaption>
</figure>
<p class="TX">Next, make the connections shown in <a href="chapter12.xhtml#fig12-3">Figure 12-3</a> using some male-to-female jumper wires between the module and your Arduino Uno or compatible board. The bottom row of three pins below the jumper you just placed are referred to as S1, S2, and S3.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR CONNECTION OF THE CH376 USB FLASH DRIVE MODULE TO THE ARDUINO" class="img3" id="fig12-3" src="../images/fig12-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The schematic for the connections between USB module and Arduino</samp></p></figcaption>
</figure>
<p class="TX">The module requires you to install an Arduino library. Search for <b>CH376</b> in the Library Manager and then click <b>Install</b> at the bottom of the library description.</p>
<p class="TX">Once you’ve installed the library, connect the Arduino with the interface module to your PC and upload the sketch <i>basicUsageSoftSerial</i>, which is included with the CH376 library examples, as shown in <a href="chapter12.xhtml#fig12-4">Figure 12-4</a>.</p>
<figure class="IMG"><img alt="LOCATING THE EXAMPLE SKETCH FOR THE CH376 USB FLASH DRIVE MODULE IN ARDUINO IDE" class="img7" id="fig12-4" src="../images/fig12-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: Locating the CH376 example sketch in the Arduino IDE</samp></p></figcaption>
</figure>
<p class="TX">The purpose of running this sketch is to test the USB usage before building it into your own projects. Now open the Serial Monitor, change the speed to 115,200 bps, and reset your Arduino. The sketch should display a series of options and show the presence of a flash drive, as shown in <a href="chapter12.xhtml#fig12-5">Figure 12-5</a>.<span aria-label=" Page 182. " epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE OUTPUT FROM THE CH376 USB FLASH DRIVE MODULE DEMONSTRATION SKETCH" class="img7" id="fig12-5" src="../images/fig12-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The output from the CH376 demonstration sketch</samp></p></figcaption>
</figure>
<p class="TX">If you don’t see the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Flash drive attached!</samp> in the monitor, gently remove and reinsert the USB flash drive into the module. A single LED on the module should also light up when a USB flash drive is inserted. If this is still not successful, try reformatting the flash drive as described in the previous section. Failing that, try a different flash drive.</p>
<p class="TX">If the Arduino reports the flash drive is attached, run the various operations described in the menu displayed on the Serial Monitor. First, send a 1 in the Serial Monitor to create a text file in the flash drive, then a 2 to append data to that file (which opens the original file and adds more text to it), and then a 7 to show the contents of the flash drive, as shown in <a href="chapter12.xhtml#fig12-6">Figure 12-6</a>, for example.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF LISTING THE FILES STORED ON THE USB FLASH DRIVE GENERATED BY DEMONSTRATION SKETCH" class="img7" id="fig12-6" src="../images/fig12-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The results of flash drive operations</samp></p></figcaption>
</figure>
<p class="TX">The sketch creates the file and calls it <i>TEST1.TXT</i>. If you have files with filenames that are longer than the classic 8 + 3 file format, they will be truncated and have a tilde inserted into the filename, as has been done with the first two files shown in <a href="chapter12.xhtml#fig12-6">Figure 12-6</a>.</p>
<p class="TX">Once you’ve created and appended the file <i>TEST1.TXT</i>, you can be satisfied that your hardware and USB flash drive combination are operating correctly. It’s time to move on to writing data to text files on the flash drive.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-84"/><span aria-label=" Page 183. " epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Writing Data</samp></h2>
<p class="TNI">In this section, I’ll show you how to initialize and write various kinds of numerical and text data to a text file on the flash drive and then demonstrate the process with an example sketch. This technique is perfect for data capture and logging applications. First, I’ll show you the required functions and how they work, which are then demonstrated in the following projects.</p>
<p class="TX">No matter what type of text data you want to write, you’ll first need the following four lines at the start of the sketch to initialize the interface module and the required software serial port:</p>

<pre><code>#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial USBserial (7, 6);
Ch376msc USBdrive(Serial1);
</code></pre>

<p class="TX">This includes the libraries for the USB module (CH376) and the software serial port, then initializes the software serial port, and finally creates an instance of the USB module over software serial.</p>
<p class="TX">Next, you’ll add some lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>:</p>

<pre><code>Serial.begin(115200); // For Serial Monitor
USBserial.begin(9600); // For USB module
USBdrive.init();
</code></pre>

<p class="TX">This starts serial communications between the Serial Monitor and the USB module and starts the USB module communication. You must place the three functions in the order shown.</p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> section of the sketch, use the following code to check the status of the USB module. In addition to checking for the presence of the USB flash drive, it’s also handy for troubleshooting; if the flash drive isn’t connected or working, this code will stop the sketch and notify you via the Serial Monitor:</p>

<pre><code>if (USBdrive.checkIntMessage())
{
    if (USBdrive.getDeviceStatus())
    {
        Serial.println(F("Flash drive attached!"));
    } else {
        Serial.println(F("Flash drive detached!"));
    }
}
</code></pre>

<p class="TX">The text in <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp> is enclosed with <samp class="SANS_TheSansMonoCd_W5Regular_11">F()</samp> to save the Arduino’s SRAM (think of this as the memory used for operations, like RAM in your computer) and instead use the flash memory (where sketches are stored in the microcontroller).</p>
<p class="TX"><span aria-label=" Page 184. " epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/>Next, set the filename and open the file:</p>

<pre><code>USBdrive.setFileName("TEST1.TXT");
USBdrive.openFile();
</code></pre>

<p class="TX">Filenames must be in the classic 8 + 3 format. Use the <i>.txt</i> file extension if you intend to write plaintext, or use <i>.csv</i> if you intend to open the file in a spreadsheet. If you use the same filename and write a second or multiple times to that file, the data in the file will be overwritten from the start.</p>
<p class="TX">Next, write some data. To write a byte, integer, or double or long variable, use</p>

<pre><code>USBdrive.writeNum(<var>x</var>)
USBdrive.writeNumln(<var>x</var>)
</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is the name of the variable you want to write. The second function writes a new line after the number.</p>
<p class="TX">To write a character of text or send a command in the form of a character (such as a new line <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), use this:</p>

<pre><code>USBdrive.writeChar('<var>x</var>');
</code></pre>

<p class="TX">This will write the character <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> to the file.</p>
<p class="TX">To write a line of text, you must first store it in a character array no longer than 254 characters:</p>

<pre><code>char text1[] = "This is a line of text. \n";
USBdrive.writeFile(text1, strlen(text1));
</code></pre>

<p class="TX">This writes the text in the array <samp class="SANS_TheSansMonoCd_W5Regular_11">text1</samp> to the opened file, and a newline character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">writeFile()</samp> function accepts the character array and then the length of the character array as parameters.</p>
<p class="TX">To write floating-point variables, you must convert the number to a character array and then write the array. First create an array of characters in which to place the number:</p>

<pre><code>char floatChar[8] = " ";
</code></pre>

<p class="TX">Ensure the array is long enough to contain all digits, the decimal point, and the negative sign, if necessary. Then assign the floating-point variable some value:</p>

<pre><code>float f = 123.456;
</code></pre>

<p class="TX">Now use the following to convert the float to the character array:</p>

<pre><code>dtostrf(<var>a</var>,<var>b</var>,<var>c</var>,<var>d</var>);
</code></pre>

<p class="BodyContinued"><span aria-label=" Page 185. " epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/>Here, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">a</samp> is the float to convert, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp> is the number of digits in the whole number, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">c</samp> is the number of digits in the fraction, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">d</samp> is the array to place the resulting number. For example, to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">floatChar</samp>, use this:</p>

<pre><code>dtostrf(f,3,3,floatChar);
</code></pre>

<p class="TX">You can now write the character array with the following (as you did with the line of text):</p>

<pre><code>USBdrive.writeFile(floatChar, strlen(floatChar));
</code></pre>

<p class="TX">Finally, when you’ve finished writing the data to the text file, close the file:</p>

<pre><code>USBdrive.closeFile();
</code></pre>

<p class="TX">At this point, you can remove the flash drive from the module and insert it into a PC to retrieve the text file.</p>
<p class="TX">You can test these functions with the following sketch. After you’ve connected the interface module to your Arduino and inserted the USB flash drive, enter and upload <a href="#LiT-12-1">Listing 12-1</a>.</p>
<span id="LiT-12-1"/>

<pre><code>char text1[] = "This is a line of text in the form of a character
array, followed by a new line function. \n"; <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>

char text2[] = "This is another line of text. I hope you're enjoying the book. John. \n";

char floatChar[8] = " ";
float f = 12.34567;

#include &lt;Ch376msc.h&gt; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial USBserial(7, 6);
Ch376msc USBdrive(USBserial);

void fileWrite()
{
    Serial.println("fileWrite()");
    USBdrive.setFileName("TEST1.TXT"); // Set the filename <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
    USBdrive.openFile();               // Open the file

    // Write some integers:
    for (int a = 0; a &lt; 20; a++)
    {
        USBdrive.writeNum(a); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
        USBdrive.writeChar(',');
    }

    // Write new line:
    USBdrive.writeChar('\n'); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
<span aria-label=" Page 186. " epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>    // Write lines of text:
    USBdrive.writeFile(text1, strlen(text1)); <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
    USBdrive.writeFile(text2, strlen(text2));
    USBdrive.writeChar('\n');

    // Write floating-point number - first convert to char:
    dtostrf(f,2,5,floatChar); // 2 whole digits, 5 decimals <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
    USBdrive.writeFile(floatChar, strlen(floatChar));
    USBdrive.closeFile(); // Close the file <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
    Serial.println("Finished.");
}

void setup()
{
    Serial.begin(115200); // For Serial Monitor <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>
    USBserial .begin(9600); // For USB module
    USBdrive.init();
    delay(5000);
}

void loop()
{
    if (USBdrive.checkIntMessage()) <span aria-label="annotation10" class="CodeAnnotationCode">❿</span>
    {
        if (USBdrive.getDeviceStatus())
        {
            Serial.println("Flash drive attached!");
        } else {
            Serial.println("Flash drive detached!");
        }
    }
    fileWrite();
    delay(5000);
}</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Test writing to the USB flash drive</samp></p>
<p class="TX">The sketch declares the required variables for text use and the float for demonstration <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It initializes the required libraries <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then names and opens the file <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. It then writes integers to the file <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, along with characters (commas to separate the numbers being written). The program writes a newline command to the file <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, followed by writing text <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, converting a float to a character array, and writing it to the file <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>.</p>
<p class="TX">Once the file is closed <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>, the flash drive can be removed. The serial communication and USB drive start at <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>. The sketch then inserts the code for USB flash drive detection <span aria-label="annotation10" class="CodeAnnotationCode">❿</span> and finally calls the function to write the data by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fileWrite()</samp>.</p>
<p class="TX">You can monitor the progress of the writing and remove the flash drive once <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp> is displayed in the Serial Monitor. Check the results by viewing the text file on a PC, as shown in <a href="chapter12.xhtml#fig12-7">Figure 12-7</a>.<span aria-label=" Page 187. " epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE TEXT FILE CREATED BY LISTING 12-1" class="img8" id="fig12-7" src="../images/fig12-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The results of <a href="#LiT-12-1">Listing 12-1</a></samp></p></figcaption>
</figure>
<p class="TX">All this allows you to write data in a once-off burst. However, if you want to add data to a file over time, you need to append the data instead.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">Appending Data to a File</samp></h2>
<p class="TNI">Writing numerical and text data to a text file stored on the flash drive is perfect for once-only types of situations. If you need to add data to a file, however, you can’t just write to it as described in the previous section. Instead, after writing to a file the first time, you must append data to that file to keep all the data stored safely. In this section, I’ll explain the required functions and then demonstrate them in the following projects.</p>
<p class="TX">The code for appending data to a file is like the code for writing, with some minor differences after opening the file. I’ll explain what needs to be done and then demonstrate operation with a project. First, you check that the file exists, and if it does, you move the cursor (the position where the USB interface will start writing) to the end of the file with the following commands:</p>

<pre><code>if (USBdrive.openFile() == ANSW_USB_INT_SUCCESS)
{
    USBdrive.moveCursor(CURSOREND);
}
</code></pre>

<p class="TX">You can then append data to the file with the previously described writing functions, if there’s free space on the flash drive:</p>

<pre><code>if (USBdrive.getFreeSectors())
{
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> // Write data to flash drive here
} else
{
    Serial.println("Disk full");
}
</code></pre>

<p class="TX">Insert the required code to write your data to the file <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>; then close the file with <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.closeFile()</samp> as normal.</p>
<p class="TX"><span aria-label=" Page 188. " epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>Let’s test appending data now with <a href="#LiT-12-2">Listing 12-2</a>, which will append a random number to the <i>TEST1.TXT</i> file generated by <a href="#LiT-12-1">Listing 12-1</a>.</p>
<span id="LiT-12-2"/>

<pre><code>#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;

SoftwareSerial USBserial (7, 6);
Ch376msc USBdrive(USBserial);

void fileAppend()
{
    Serial.println("fileAppend()");
    USBdrive.setFileName("TEST1.TXT"); // Set the filename
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> if (USBdrive.openFile() == ANSW_USB_INT_SUCCESS)
    {
        USBdrive.moveCursor(CURSOREND);
    }
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (USBdrive.getFreeSectors())
    {
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> USBdrive.writeNumln(random(1000));
    } else
    {
        Serial.println("Disk full");
    }
    USBdrive.closeFile();
    Serial.println("Finished");
    delay(1000);
}

void setup()
{
    Serial.begin(115200); // For Serial Monitor
    USBserial .begin(9600); // For USB module
    USBdrive.init();
    delay(5000);
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> randomSeed(analogRead(0));
}

void loop()
{
    if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus())
        {
            Serial.println(F("Flash drive attached!"));
        } else {
            Serial.println(F("Flash drive detached!"));
        }
    }
    fileAppend();
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> do {} while (1);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Appending a random number to the</samp> <samp class="SANS_Futura_Std_Book_11">.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp></p>
<p class="TX"><span aria-label=" Page 189. " epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/>After initializing the required libraries and proceeding through <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch calls the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">fileAppend()</samp>, at which point the sketch continues only if the file to append exists <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If it does, the cursor (or point where new text is appended to the file) is moved to the end of the file.</p>
<p class="TX">A check for free space occurs <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If there’s free space, the sketch writes a random number to a new line in the text file <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. It then closes the file as usual. As the project uses random numbers, the sketch seeds the random number generator <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. A “do nothing forever” line <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> prevents data from being endlessly appended.</p>
<p class="TX">As with <a href="#LiT-12-1">Listing 12-1</a>, you can monitor the progress of the writing and remove the flash drive once the Serial Monitor displays <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp>. Check the results by viewing the text file on a PC. For example, <a href="chapter12.xhtml#fig12-8">Figure 12-8</a> shows the results after the sketch has run six times.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE OUTPUT FROM LISTING 12-2 AFTER OPERATING SIX TIMES" class="img7" id="fig12-8" src="../images/fig12-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The results of <a href="#LiT-12-2">Listing 12-2</a></samp></p></figcaption>
</figure>
<p class="TX">In the next project, you’ll use the framework you’ve just learned to append data from a temperature sensor to a text file.</p>
<p class="HeadProject"><span id="h1-86"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #36: Logging Sensor Data</samp></p>
<p class="TNI">This simple data-logging demonstration records temperature, air pressure, and altitude as detected by the BMP180 sensor demonstrated in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. The Project #36 sketch captures the data from the sensor and writes it to the USB flash drive over fixed intervals, which you can alter for your own purposes.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A USB flash drive interface module</li>
<li class="BL">A BMP180 sensor module with inline pins fitted</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">For this project, you’ll use the breadboard as a bridge to help create more 5V and GND connections for the two modules to the Arduino. If you haven’t previously used the BMP180 sensor, please refer to the section <span aria-label=" Page 190. " epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>“<span class="Xref">BMP180 Sensors</span>” in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. Assemble the circuit as shown in <a href="chapter12.xhtml#fig12-9">Figure 12-9</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #36" class="img7" id="fig12-9" src="../images/fig12-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: The schematic for Project #36</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the Project #36 sketch. Once the sketch has run for a few minutes, remove the USB flash drive and review the file using the PC, as shown in <a href="chapter12.xhtml#fig12-10">Figure 12-10</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36" class="img7" id="fig12-10" src="../images/fig12-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: Example data captured by Project #36</samp></p></figcaption>
</figure>
<p class="TX">Thanks to using the comma separator as a delimiter between data and descriptions, you can import the file into a spreadsheet such as Microsoft Excel, which allows for easy analysis or distribution of the captured data in a popular format, as shown in <a href="chapter12.xhtml#fig12-11">Figure 12-11</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36 IN MICROSOFT EXCEL" class="img7" id="fig12-11" src="../images/fig12-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: Example data captured by Project #36 in Excel</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 191. " epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>Let’s see how this works:</p>
<span id="pro-36"/>

<pre><code>// Project #36 - Log sensor data to USB flash drive

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Wire.h&gt;
#include &lt;Adafruit_BMP085.h&gt;
#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;

Adafruit_BMP085 bmp;
SoftwareSerial USBserial (7, 6);
Ch376msc USBdrive(USBserial);

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> char floatChar[8] = " ";

void fileAppend()
{
    Serial.println("fileAppend()");
    USBdrive.setFileName("TEMPDATA.TXT"); // Set the filename
    if (USBdrive.openFile() == ANSW_USB_INT_SUCCESS)
    {
        USBdrive.moveCursor(CURSOREND);
    }
    if (USBdrive.getFreeSectors())
    {
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> dtostrf(bmp.readTemperature(),2,2,floatChar);
        USBdrive.writeFile(floatChar, strlen(floatChar));
        USBdrive.writeChar(',');
        USBdrive.writeChar('C');
        USBdrive.writeChar(',');

      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> USBdrive.writeNum(bmp.readPressure());
        USBdrive.writeChar(',');
        USBdrive.writeChar('P');
        USBdrive.writeChar('a');
        USBdrive.writeChar(',');

      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> dtostrf(bmp.readAltitude(),5,1,floatChar);
        USBdrive.writeFile(floatChar, strlen(floatChar));
        USBdrive.writeChar(',');
        USBdrive.writeChar('m');
        USBdrive.writeChar('\n');
    } else
    {
        Serial.println("Disk full");
    }
    USBdrive.closeFile();
    Serial.println("Finished");
}

void setup()
{
    bmp.begin();
    Serial.begin(115200);  // For Serial Monitor
    USBserial.begin(9600); // For USB module
<span aria-label=" Page 192. " epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>    USBdrive.init();
    delay(5000);
}

void loop()
{
    if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus()) {
        Serial.println(F("Flash drive attached!"));
    }
    else
    {
        Serial.println(F("Flash drive detached!"));
        return;
    }
}

fileAppend();
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span> delay(5000); // Arbitrary delay
    9
</code></pre>

<p class="TX">This practical extension of the <a href="#LiT-12-2">Listing 12-2</a> sketch first includes and sets up the required libraries for the BMP180, USB module, and software serial, starting at <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The sketch then declares a character array <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> used to convert floating-point numbers to characters for writing to the flash drive. The temperature in degrees Celsius, air pressure in pascals, and altitude in meters are taken from the BMP180 and written to the flash drive with some simple separators at <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, respectively. You can alter the arbitrary delay <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> as needed.</p>
<p class="TX">You can use this project to log any data that can be captured or generated by your Arduino to a USB flash drive. For a challenge, you could add a real-time clock to log the time and date along with the weather data.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">Reading Numerical Data</samp></h2>
<p class="TNI">Reading data from a USB flash drive is a useful way to import settings, parameters, and other information into your Arduino project. In this section, I’ll show you how to read numerical data from your USB; you’ll learn how to read text data a little later.</p>
<p class="TX">Your Arduino can interrogate a file stored on the flash drive that contains purely integers and read them one at a time from start to finish. Each integer must be stored on its own line in the file and be followed by a new line character. You can create the text file in a Notepad-style text editor, being sure to use an 8 + 3 filename like <i>FILENAME.TXT</i>.</p>
<p class="TX">The sketch initialization is the same as when you are writing to or appending data to the USB flash drive. You’ll first need the following four lines at the start of the sketch to initialize the interface module and the required software serial port:</p>

<pre><code><span aria-label=" Page 193. " epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial Serial1(7, 6);
Ch376msc USBdrive(Serial1);
</code></pre>

<p class="TX">Next, set the name of the file you want to open and open the file, using the following two functions:</p>

<pre><code>USBdrive.setFileName("<var>FILENAME.TXT</var>");
USBdrive.openFile();
</code></pre>

<p class="TX">You can then read each number in turn, from the start to the end of the file, using the following code:</p>

<pre><code>while(!USBdrive.getEOF())
{
    number = USBdrive.readLong();
}
</code></pre>

<p class="TX">The integer in this example will be stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>.</p>
<p class="TX">Finally, close the file:</p>

<pre><code>USBdrive.closeFile();
</code></pre>

<p class="TX">Let’s demonstrate this with a sketch that writes 10 integers to a file on the flash drive and then retrieves and displays those numbers. You’ll need the USB flash drive module connected to the Arduino, along with the flash drive, as usual.</p>
<p class="TX">Upload the <a href="#LiT-12-3">Listing 12-3</a> sketch.</p>
<span id="LiT-12-3"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial Serial1(7, 6);
Ch376msc USBdrive(Serial1);

void writeIntegers()
{
    int number;
    if (USBdrive.driveReady())
    {
        USBdrive.setFileName("NUMBERS.TXT");
        USBdrive.openFile();
        Serial.println(F("Writing integers:"));
        for (int a = 0; a &lt; 10; a++)
        {
            number = random(−1000, 1000);
            Serial.print(number); Serial.print(" ");
            USBdrive.writeNumln(number);
        }
        USBdrive.closeFile();
        Serial.println(F("Finished writing integers."));
<span aria-label=" Page 194. " epub:type="pagebreak" id="pg_194" role="doc-pagebreak"/>        Serial.println();
    }
}

void readIntegers()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> USBdrive.setFileName("NUMBERS.TXT");
    USBdrive.openFile();
    Serial.println(F("Reading integer numbers…"));

  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> while(!USBdrive.getEOF())
    {
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Serial.print(USBdrive.readLong());
        Serial.print(" ");
    }
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> USBdrive.closeFile();
    Serial.println(F("Finished reading integers."));
    Serial.println();
}

void setup()
{
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> randomSeed(analogRead(0));
    Serial.begin(115200);
    Serial1.begin(9600);
    USBdrive.init();
    delay(5000);
}

void loop()
{
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus()) {
            Serial.println(F("Flash drive attached!"));
    } else {
            Serial.println(F("Flash drive detached!"));
            return;
        }
    }
  <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> writeIntegers();
    delay(2000);
  <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> readIntegers();
    delay(30000);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Writing and displaying integers on the USB flash drive</samp></p>
<p class="TX">After a short delay, the sketch should display in the Serial Monitor the numbers written to the flash drive, then read them back from the flash drive and display the same numbers in the Serial Monitor once again, as shown in <a href="chapter12.xhtml#fig12-12">Figure 12-12</a>.<span aria-label=" Page 195. " epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE OUTPUT FROM LISTING 12-3" class="img7" id="fig12-12" src="../images/fig12-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Example output from <a href="#LiT-12-3">Listing 12-3</a></samp></p></figcaption>
</figure>
<p class="TX">The sketch first includes and sets up the required libraries for the USB module and software serial <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">writeIntegers()</samp> function writes some integers to the USB flash drive for your demonstration, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.setFileName()</samp> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> sets the name of the file to be stored. After setting the name of the file to open and opening the file, the sketch loops from the start of the file <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> until the end of the file, reads each integer <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and displays them on the Serial Monitor.</p>
<p class="TX">The sketch then closes the file <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, seeds the random number generator <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, and starts the serial ports and USB module. It checks for the presence of a USB flash drive in the module <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> and then runs the writing and reading demonstration functions at <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> and <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>, respectively.</p>
<p class="TX">You’re ready to put your knowledge of writing and reading integers to work in the following two projects by creating a USB security key and then loading parameters into your Arduino projects.</p>
<p class="HeadProject"><span id="h1-88"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #37: Using a USB Security Key</samp></p>
<p class="TNI">This project shows you how to lock or unlock the ability for your Arduino to operate by forcing it to read a secret number text file stored on the USB flash drive before operating the main code. If the number in the text file matches what’s loaded in the sketch, the code can operate; if not, the Arduino comes to a halt and will not operate. Nor will it operate without a USB flash drive.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A USB flash drive interface module</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Connect the USB flash drive module to the Arduino as described in Project #36 and then create a text file using your PC called <i>SECURITY.TXT</i> whose contents contain just the number 12345 on one line. Copy this file to your USB flash drive.</p>
<p class="TX">Next, insert the flash drive into the USB module, then enter and upload the following sketch.</p>

<pre><code><span aria-label=" Page 196. " epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/>// Project #37 - USB security key

#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial Serial1(7, 6);
Ch376msc USBdrive(Serial1);

boolean readKey()
{
    boolean keyStatus=false;
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> int securityKey=12345;
    int testKey=0;
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> USBdrive.setFileName("SECURITY.TXT");
    USBdrive.openFile();
    while(!USBdrive.getEOF())
    {
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> testKey=USBdrive.readLong();
    }
    USBdrive.closeFile();
    if (securityKey==testKey)
    {
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> keyStatus=true;
    }
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> return keyStatus;
}

void setup()
{
    pinMode(13, OUTPUT);
    Serial.begin(115200);
    Serial1.begin(9600);
    USBdrive.init();
    delay(5000);

  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus())
        {
            Serial.println(F("Flash drive attached!"));
        } else {
            Serial.println(F("Flash drive detached!"));
            return;
        }
    }
  <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> if (readKey()==false)
    {
        Serial.println("Incorrect key!");
      <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> do {} while (1); // Halt
  }
}

<span aria-label=" Page 197. " epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/>void loop()
{
  <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> digitalWrite(13, HIGH);
    delay(500);
    digitalWrite(13, LOW);
    delay(500);
}
</code></pre>

<p class="TX">In essence, this sketch opens a text file, reads the five-digit number, and compares it with a number stored in the sketch. If they match, it executes the code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, but if not, the sketch stops dead in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>.</p>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">boolean readKey()</samp> function checks the security file, which has the security key number stored <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The sketch opens the file on the USB flash drive <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then reads the key number from the file <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If the Arduino key number and the file key number match when the sketch compares the two, the function’s value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Otherwise, the function will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> by default. Either result is returned at <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">Checking the key begins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. The sketch first checks the existence of the USB flash drive <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> and then the file key number <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. If there isn’t a match or a USB flash drive hasn’t been inserted, the sketch stops <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> and the Arduino must be reset to try again. These results will be displayed in the Serial Monitor. In <a href="chapter12.xhtml#fig12-13">Figure 12-13</a>, for example, the monitor tells me the flash drive is attached, but I have the incorrect key.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #37" class="img7" id="fig12-13" src="../images/fig12-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: Example output from Project #37 when security keys don’t match</samp></p></figcaption>
</figure>
<p class="TX">If the key does match, however, the sketch can continue to <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> and operate any code as usual <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>. In this case, it simply blinks the Arduino’s onboard LED.</p>
<p class="TX">You can use this sketch to add a security key to your own Arduino-based projects. In the following project, you’ll use similar hardware to import larger amounts of data into an Arduino, from which decisions can be made.</p>
<p class="HeadProject"><span id="h1-89"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #38: Configuring a Project via USB Flash Drive</samp></p>
<p class="TNI">You can also use USB flash drive functionality to import data or parameters from the USB flash drive into the Arduino. For example, you might import preset instructions for a robot, set start and finish times for a <span aria-label=" Page 198. " epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>timer-controlled project, or add on/off patterns for lights controlled by your project. You can do so by reading files on your USB, saving those values to your Arduino’s internal EEPROM, and retrieving and acting on those values. This is useful for configuration purposes for more permanent projects.</p>
<p class="TX">To demonstrate this process, this project shows you how to read integers between the value of 0 and 255 from a file on the USB flash drive, store the values to the EEPROM, and then retrieve the values and display them in binary on eight LEDs. Once you’ve finished, you can use the functions as a framework for your own projects.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A USB flash drive interface module</li>
<li class="BL">Various jumper wires</li>
<li class="BL">Eight 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Eight LEDs</li>
<li class="BL">A solderless breadboard</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter12.xhtml#fig12-14">Figure 12-14</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #38" class="img8" id="fig12-14" src="../images/fig12-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: The schematic for Project #38</samp></p></figcaption>
</figure>
<p class="TX">Next, create a text file on your USB flash drive called <i>SETTINGS.TXT</i> and place a number between 0 and 255 inclusive on each of the 100 lines. These are the values you’ll copy from the flash drive to the EEPROM. (You can review writing and installing your own Arduino library in Chapter 18 of <i>Arduino Workshop</i>, 2nd edition.)</p>
<p class="TX">Next, insert the flash drive into the USB module, enter and upload the Project #38 sketch, and open the Serial Monitor. The LEDs should display the binary equivalent of each number stored in the EEPROM. (Values 0 through 3 may not display properly, as the LEDs are sharing the digital pins used for the USB serial connection to the PC.)</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-38"/>

<pre><code>// Project #38 - Project configuration via USB flash drive

#include &lt;EEPROM.h&gt;
#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
<span aria-label=" Page 199. " epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/>SoftwareSerial Serial1(9, 8);
Ch376msc USBdrive(Serial1);

void loadData()
{
    int _data;
    int pointer = 0;

  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> USBdrive.setFileName("SETTINGS.TXT");
    USBdrive.openFile();
    Serial.println(F("Reading data from USB:"));

    while(!USBdrive.getEOF())
    {
      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> data = USBdrive.readLong();
        EEPROM.write(_data,pointer);
        Serial.print(pointer); Serial.print(" "); Serial.println(_data);
        pointer++;
    }
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> USBdrive.closeFile();
    Serial.println(F("Finished."));
    Serial.println();
}

void useData()
{
    int a;
    int _data;
    Serial.println("Reading from EEPROM…");
    for (a = 0; a &lt; 100; a++)
    {
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> _data = EEPROM.read(a);
        PORTD = _data;
        Serial.print(a); Serial.print(" "); Serial.println(_data);
        delay(100);
    }
}

void setup()
{
    DDRD = B11111111;
    Serial.begin(115200);
    Serial1.begin(9600);
    USBdrive.init();
    delay(5000);
}

void loop()
{
    if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus()) {
            Serial.println(F("Flash drive attached!"));
        } else
<span aria-label=" Page 200. " epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/>        {
            Serial.println(F("Flash drive detached!"));
            return;
        }
    }
    loadData();
    delay(1000);

    useData();
    delay(1000);

    do {} while (1); // Halt

}
</code></pre>

<p class="TX">The sketch first includes and sets up the required libraries for the USB module, EEPROM, and software serial lines. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp> retrieves data from the <i>SETTINGS.TXT</i> file in the USB flash drive and stores it in the EEPROM. The sketch opens the file on the flash drive <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then reads each integer from the file <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and stores it in the EEPROM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp> variable tracks the EEPROM position, which is increased by 1 after every read. After the sketch has read the file, it closes it <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> function reads each value in turn from the EEPROM and stores it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> register to control the LEDs. (For a review of port manipulation, please revisit <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop cycles, reading the value from each EEPROM position in turn <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and then sending that value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> register.</p>
<p class="TX">The sketch sets the usual configurations in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> and checks for a flash drive in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>. It then calls the custom functions <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp>. The sketch runs only once, thanks to the “do nothing” line.</p>
<p class="TX">When this project is operating, you’ll see the data copied from the flash drive to the EEPROM, and then you’ll see the same data displayed from the EEPROM. I’ve inserted a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp> lines into the <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> functions to enable monitoring of the process; <a href="chapter12.xhtml#fig12-15">Figure 12-15</a> shows an example of this.</p>
<figure class="IMG"><img alt="THE EXAMPLE OUTPUT FROM PROJECT #38" class="img3" id="fig12-15" src="../images/fig12-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: Example output for Project #38</samp></p></figcaption>
</figure>
<p class="TX">However, you can remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp> lines if you don’t need them.</p>
<p class="TX">This simple example demonstrates how to read numerical data from the USB flash drive and store it away in the Arduino. It’s up to you to get your own projects the data they need from the EEPROM.</p>
<p class="TX">Now that you’ve learned to read numerical data, I’ll show you how to read text.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h1-90"/><span aria-label=" Page 201. " epub:type="pagebreak" id="pg_201" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Reading Text</samp></h2>
<p class="TNI">Your Arduino can also read text from simple files (the same type of text files as used for the integers) that contain only text and newline characters. The library will detect the newline character, but any other formatting codes created by word processor software will simply be displayed as characters from the ASCII table.</p>
<p class="TX">Again, it’s best to create such files using a Notepad-style text editor, using an 8 + 3 filename. Reading text is quite similar to reading integers; first set the file you want to open, then open it:</p>

<pre><code>USBdrive.setFileName("TESTTEXT.TXT");
USBdrive.openFile();
</code></pre>

<p class="TX">Next, read each character of text in turn, from the start to the end of the file, using</p>

<pre><code>moreText = USBdrive.readFile(_buffer, sizeof(_buffer));
</code></pre>

<p class="BodyContinued">where <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is a Boolean variable (true or false) and <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer</samp> is a character array between 2 and 255 characters in length where the text will be placed. You need to repeat the previous statement until the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is returned as false (which signifies the end of the file being read).</p>
<p class="TX">Finally, close the file:</p>

<pre><code>USBdrive.closeFile();
</code></pre>

<p class="TX">Let’s demonstrate this with a sketch that displays the contents of a text file called <i>TESTTEXT.TXT</i> stored on the USB flash drive. Connect the USB module as shown in <a href="chapter12.xhtml#fig12-3">Figure 12-3</a>, insert your USB flash drive into the module, and enter and upload the <a href="#LiT-12-4">Listing 12-4</a> sketch:</p>
<span id="LiT-12-4"/>

<pre><code>#include &lt;Ch376msc.h&gt;
#include &lt;SoftwareSerial.h&gt;
SoftwareSerial Serial1(7, 6);
Ch376msc USBdrive(Serial1);

void readText()
{
    char _buffer[254];
    boolean moreText;

  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> USBdrive.setFileName("TESTTEXT.TXT");
    USBdrive.openFile();
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> moreText = true;
    while(moreText)
    {
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> moreText = USBdrive.readFile(_buffer, sizeof(_buffer));
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Serial.print(_buffer);
    }
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> USBdrive.closeFile();
<span aria-label=" Page 202. " epub:type="pagebreak" id="pg_202" role="doc-pagebreak"/>}

void setup()
{
    Serial.begin(115200);
    Serial1.begin(9600);
    USBdrive.init();
    delay(5000);
}

void loop()
{
    if (USBdrive.checkIntMessage())
    {
        if (USBdrive.getDeviceStatus())
        {
            Serial.println(F("Flash drive attached!"));
        } else
        {
            Serial.println(F("Flash drive detached!"));
        }
    }
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> readText();
    delay(5000);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Reading text from the flash drive</samp></p>
<p class="TX">Open the Serial Monitor, which should display the contents of the text file, as shown in <a href="chapter12.xhtml#fig12-16">Figure 12-16</a>.</p>
<figure class="IMG"><img alt="THE EXAMPLE TEXT OUTPUT READ FROM THE USB DRIVE, DISPLAYED IN THE SERIAL MONITOR" class="img1" id="fig12-16" src="../images/fig12-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: Example output from <a href="#LiT-12-4">Listing 12-4</a></samp></p></figcaption>
</figure>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp> function takes care of opening the text file, reading the contents, and using the text. The required variables are the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp>, which stores the data from the USB flash drive 254 characters at a time, and the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>, which monitors the reading status. After the function sets and opens the file to use <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, it sets the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> to enable the following <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to start. It reads 254 characters from the file and places them into the array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If there’s more text to read, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>, enabling the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to repeat again. The function then sends the text to the Serial Monitor <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. When the read reaches the end of the file, <span aria-label=" Page 203. " epub:type="pagebreak" id="pg_203" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> and the file is closed <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Finally, the sketch calls this entire <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp> function <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">You now have the basic framework to read text from a USB flash drive and work with it in your own projects. As demonstrated with reading integers in the previous section, you could use load parameters as characters or words to configure your projects or use the array of characters collected to be displayed using other methods. If you use a smaller buffer array, perhaps 10 characters long, this will enable you to read command words for the Arduino to recognize and act upon.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h2 class="H1" id="sec7"><span id="h1-91"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned how to write data to a USB flash drive and retrieve and use data from a USB flash drive with your Arduino. This is an easy-to-use method of transferring data to and from your Arduino.</p>
<p class="TX">In the next chapter, you’ll expand your knowledge of input methods by learning how to interface a PS/2 PC keyboard with your Arduino.</p>
</section>
</section>
</body>
</html>