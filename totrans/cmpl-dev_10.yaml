- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">AUTHORIZATION
    WITH OAUTH</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Certain apps store data about users as part of a login workflow. There are many
    ways to implement this authentication and authorization, but one of the easiest
    is to use OAuth2 to piggyback on the existing accounts of well-known companies.
    *OAuth2*, or simply *OAuth*, is an open standard for access delegation, and you’ve
    probably encountered it if you’ve ever used an app’s “log in with Facebook, GitHub,
    or Google Account” feature.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth protocol essentially allows our web application to access another
    application’s login data without requiring the third party to share a user’s credentials
    with us. To do so, the user grants our application access rights to their third-party
    account through the creation of an access token. OAuth is the accepted standard
    for authorization-based access delegation, and Amazon, Google, Facebook, Microsoft,
    and GitHub all support OAuth workflows.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the OAuth workflow and then explore the structure
    of the bearer tokens used for its access delegation, laying the foundation for
    implementing OAuth2 into your Food Finder application in [Part II](part2.xhtml).
    In [Exercise 9](#Exe9) on page 168, we won’t update our sample Next.js application
    with an OAuth flow but instead manually walk through the OAuth authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How OAuth Works</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we explore OAuth, you need to understand the differences between authentication
    and authorization. In short, we use authentication to verify the identity of a
    user, whereas authorization specifies the permissions that the authenticated user
    possesses and enforces those permissions. OAuth allows for that process to be
    delegated to a third party with which the user already has an account, which simplifies
    the login process for the user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication vs.
    Authorization</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time an app receives a login request, it checks the user’s credentials
    before allowing access, a process called *authentication*. Usually, those credentials
    consist of a username and a password, but they could also be hardware tokens or
    involve biometric factors such as fingerprints or facial recognition. The application
    then verifies that the credentials match the ones stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of authentication is *single-factor authentication*, which
    requires only one factor, usually a password. Unfortunately, it is also the least
    secure method of implementing authentication. A more robust and recommended form
    is *multifactor authentication*, in which a user must supply at least two factors.
    These might be something the user *knows*, such as a password, as well as something
    the user *has*, such as a physical token, or something the user *is*, such as
    the owner of a fingerprint. You probably use multifactor authentication when you
    log in to PayPal or Google, both of which require you to supply your password
    and an additional one-time password (OTP).
  prefs: []
  type: TYPE_NORMAL
- en: The OTP is a code that is created based on a secret shared between you and the
    application when you register your account. Both actors regenerate the pair in
    short intervals. Yours may be generated by an authenticator app, like Google Authenticator,
    or received in a text message. The application at which you have the account (for
    example, PayPal or Google) generates its own OTP code and keeps it on the server.
    As soon as you send yours, the server verifies that the codes cryptographically
    match.
  prefs: []
  type: TYPE_NORMAL
- en: We perform authorization after we’ve authenticated a user. Broadly speaking,
    this involves looking at the user’s data and deciding whether they have the access
    rights needed to access a resource. A typical full-stack application can either
    handle this user data or enable users to log in without providing user data. There
    are benefits to the latter approach, as handling and storing user data can be
    inconvenient. It also comes with additional responsibilities, such as the need
    to adhere to stricter privacy and data retention laws, and requires your users
    to create another account.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you provide users with the option to log in with an existing account
    through an authorization provider. In that case, you’ve removed an entry barrier.
    Also, you don’t need to worry about handling their data. If you need user data—for
    example, to bill your customers—you can use an OAuth workflow and save the data
    you receive from the provider, such as the user’s payment details, in your own
    database if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Role of OAuth</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time a web application enables you to log in through a third-party provider
    such as Facebook, GitHub, or Google, it uses the OAuth authorization code flow
    behind the scenes. OAuth isn’t authentication; rather, it’s a way of authorizing
    the web application you use to perform actions or to access resources on your
    behalf. Common actions include posting to your Facebook feed and accessing data
    such as your name, profile picture, or email address. Consequently, each time
    you use an OAuth-based login function, the application asks for particular permissions
    and can use only those you grant to it.
  prefs: []
  type: TYPE_NORMAL
- en: To understand OAuth, you must understand its terminology. Each OAuth flow uses
    a set of RESTful APIs to authorize the *client* (an application) to get resources
    (such as the user’s profile information) from a *resource provider* (such as Facebook,
    GitHub, or Google) that has the protected resources the client wants to access.
    In addition, we call the server that provides the OAuth API endpoints the *authorization
    server*, and the party that owns the access rights (and, hence, has the ability
    to grant an application access to a resource) the *resource owner*. In most scenarios,
    the resource owner is the application’s end user.
  prefs: []
  type: TYPE_NORMAL
- en: To get the resource owner’s authorization, the client application sends its
    client credentials, the ID, the secret, and the user credentials to the authorization
    server, which usually is part of the same system as the resource provider. The
    authorization server authenticates the resource owner and handles the OAuth flow
    that results in granting them an *access token*, which allows the user to access
    the protected resources on the resource provider. Both the authorization server
    and the resource provider are two sets of APIs on the same system.
  prefs: []
  type: TYPE_NORMAL
- en: The *client ID* is a public identifier for the client app; you can make it public
    and store it in the code. Unlike the client ID, the *client secret* should be
    kept private; it is the app-specific password, and you should never store it in
    your code. Instead, handle it using Next.js’s environment files or your server’s
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grant Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several variants of the OAuth flow. Each of these *grant types* covers
    a specific use case, but all result in the generation of an access token. OAuth
    specifies four grant types: the client credentials flow, the implicit flow, the
    authorization code flow, and the resource owner password credentials flow.'
  prefs: []
  type: TYPE_NORMAL
- en: The *client credentials flow* covers machine-to-machine communication; we use
    it when no actual end user authorization is necessary, as in the case of automated
    tasks that connect to an API. Here, the task itself is both the client and the
    resource owner. It knows the resource owner’s credentials, the client ID, and
    the client secret and passes these to the authorization server to receive an access
    token.
  prefs: []
  type: TYPE_NORMAL
- en: The most common grant type for full-stack web development is the *authorization
    code flow*. In this scenario, our web application is a client, and it makes two
    calls to two separate API endpoints. The first is to receive an authorization
    grant code, and the second is to exchange this authorization grant for an access
    token. “The Authorization Code Flow” on page 161 provides a deep dive into this
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The last two grant types shouldn’t be used. The *implicit flow* is similar to
    the authorization code flow, but instead of making separate requests to receive
    the authorization grant and access token, the client receives the access token
    directly. This flow skips the authorization step, doesn’t include client authentication,
    and is deprecated. The *resource owner password credentials flow* should be avoided
    because it involves the end user passing their user credentials to the client
    and then the client sending these credentials to the OAuth server to exchange
    them for the access token. While this sounds straightforward, sending actual user
    credentials to the remote authorization server is an immense security risk.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bearer Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the client application initiates an OAuth flow, it receives a shared access
    token, most commonly a *bearer token* that is easy to implement. This access token
    replaces the user’s credentials; hence, anyone who has the token can access the
    data. To prevent security gaps caused by stolen tokens, a bearer token usually
    has a defined shelf life. Upon expiration, the token can be refreshed only with
    a valid *refresh token*. These are long-lived tokens that we use to generate new
    bearer tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing the token can be done implicitly or explicitly, and there are multiple
    strategies for preventing stolen refresh tokens from compromising the OAuth access.
    For example, the OAuth provider can require a unique ID or the client secret to
    issue a new token. The provider usually rotates the refresh token each time a
    new bearer token is issued and accepts each refresh token only once. From our
    perspective as OAuth clients, the details of the refresh token are unimportant,
    as the OAuth provider handles this token.
  prefs: []
  type: TYPE_NORMAL
- en: The bearer token that contains the user session and authentication data is a
    *JSON Web Token (JWT)*. JWT is an open standard for securely transmitting data
    in a JSON object. Because JSON is fairly compact, JWTs can be sent as URL parameters,
    as part of the POST data, or even inside an HTTP header, all without impacting
    the application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: JWT tokens can be signed as well as encrypted, saving the application from needing
    to make an additional request to verify it or retrieve extra data. *Encrypted
    tokens* hide the contained data from other parties. These aren’t very common in
    OAuth due to their additional overhead, so we can ignore them for now. *Signed
    tokens* guarantee the integrity of the contained data, because any modification
    to the token would change its signature. Thus, the application can trust the information
    stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common cryptographic algorithm for signing JWTs is *hash-based message
    authentication code (HMAC)* with the SHA-256 hash algorithm. An HMAC is a type
    of message authentication code (MAC). A MAC’s main feature is that it enables
    you to verify the authenticity of a message by calculating a checksum from the
    message. The checksum uses a mathematical function to produce a unique, reproducible
    value or data string based on the initial message. If the message changes, the
    checksum changes as well. This way, we can quickly verify the integrity of the
    data. For the JWT token, we use two checks: the authenticity check confirms that
    the actual sender sent the message, whereas the data integrity checks verify that
    the message’s content did not change.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other types of MACs, HMAC uses a cryptographic hash function and a secret
    key. You can freely choose the cryptographic hash function, but the strength of
    your HMAC implementation depends on the cryptographic strength of the selected
    function. JWTs commonly use the SHA-256 hash function, a fast and collision-resistant
    cryptographic function from the SHA-2 collection also used for authenticating
    Debian software packages and Bitcoin transactions. In cryptography, *collisions*
    occur when two different inputs result in the same output. The higher the possibility
    of a collision, the less we can trust the checksum of the hash function. If a
    collision is likely, our message could be replaced with a different one, but the
    hash function could indicate that it hasn’t changed. Therefore, we want collision-resistant
    cryptographic functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Authorization Code Flow</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how an OAuth interaction takes place using the authorization code
    flow mentioned earlier, let’s return to our fictional weather service. Imagine
    that you want to grant weather stations the ability to write data to the application
    by using the API, but a station should be able to modify only its own ZIP code.
    You also want the application to display the weather stations’ locations and additional
    details about them. Additionally, you prefer not to deal with the maintenance
    of user accounts or to manually set up permissions for each station, so using
    OAuth is your best bet.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that each weather station already has a social media account for
    publishing weather updates. These accounts include typical user information and
    the stations’ ZIP codes. We could easily use the social media provider as an OAuth
    authorization provider to access this data. The stations would log in to the weather
    app using the social media provider, and the app would request access to the weather
    station’s user profile. We could then check the ZIP code stored in the OAuth session
    against the one in our dataset, provide the appropriate write access, and retrieve
    any other data we need.
  prefs: []
  type: TYPE_NORMAL
- en: Only a few steps are necessary for implementing this authorization code flow.
    [Figure 9-1](chapter9.xhtml#fig9-1) is a simplified description of these steps.
    Usually, developers use an SDK or a Node.js module to implement the steps and
    need to provide only a few properties, such as the client ID, client secret, and
    callback URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-1: A simplified OAuth
    authorization grant flow</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To register our app as an OAuth client, we need to provide GitHub with a *callback
    URL* to our application, to which GitHub will redirect the user after the authorization
    request. This endpoint on our application receives the authorization grant. Recent
    OAuth implementations require the callback URL to use HTTPS as a way to protect
    the token from being intercepted.
  prefs: []
  type: TYPE_NORMAL
- en: Our app must use the resource owner’s credentials and the client credentials,
    an ID, and a secret to communicate with GitHub’s authorization server. The ID
    identifies the client, and the secret authenticates it. The app can then request
    the authorization to access specific resources, such as a weather station’s profile
    data. To do so, the weather station user needs to log in to GitHub’s authorization
    server. They’ll see a prompt that summarizes the requested access resources, such
    as read and write access to the profile or stream. If the user authorizes the
    requests with their user credentials, the OAuth client receives the authorization
    grant as a GET parameter in the callback URL, and the OAuth SDK we use in our
    application exchanges the authorization grant for an access token at the authorization
    server in the next step of the flow.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the OAuth client uses the client credentials, which are the client ID
    and client secret, in combination with the previously received authorization grant
    to request an access token from the OAuth provider’s authorization server. It
    is part of the GitHub infrastructure, and to complete the authorization flow,
    the authorization server authenticates the identity and verifies that the grant
    is valid for this identity. Finally, the app receives the bearer token from here
    and stores it in the user session.
  prefs: []
  type: TYPE_NORMAL
- en: With the token and the user session received from the OAuth provider, our app
    can now act on the user’s behalf and access their protected resources, such as
    the profile data from the resource server. To act on their behalf, we add the
    bearer token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header in the HTTP requests; the OAuth provider checks our granted permission
    and verifies our identity with this token. To access the user’s data, we simply
    extract it from the session data and use it in our application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: For the weather application, we could use the second option to query location-specific
    weather data from our database. We’d need to read the location property from the
    user’s session data and use that value as the ZIP code supplied to our API endpoint.
    In addition, we can access other properties, such as the description and the name
    or profile picture, to display them on the weather application’s status page for
    each station.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a JWT Token</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most bearer tokens are JWTs, and while the authorization server automatically
    issues them, it’s good to know what kind of information you can find in them.
    This section will walk you through the process of creating an example OAuth JWT
    for the weather service app. The JWT is a string made up of three sections divided
    by periods (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>): the header,
    the payload, and the signature. The first two sections are Base64-encoded JSON
    objects, whereas the signature is a checksum of the previous two.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Header</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first string we create is the *header*, which defines basic metadata such
    as the token’s type and the signatures used for the signing algorithm. [Listing
    9-1](chapter9.xhtml#Lis9-1) shows the creation of a simple header in JavaScript
    with the most essential metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: The JWT header for the OAuth2 weather service'
  prefs: []
  type: TYPE_NORMAL
- en: We set the type of the weather service’s token to <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp>
    and specify that we use the HMAC-SHA-256 algorithm to calculate the signature
    later. Finally, we store the JSON object in a constant to use later.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Payload</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we create the second string, the *payload*, which stores the token’s
    data. Each property of the payload is called a *claim*. In OAuth, the claims describe
    the user object and, usually, the session data. The JWT specification contains
    three types of claims: registered, public, and private.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registered Claims</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are seven registered claims, each three letters long. While not necessary
    in general JWTs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> registered claims
    are required for OAuth JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: The *issuer claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>,
    contains a unique identifier for the entity that issued the JWT. A good value
    might be the application’s URL, as shown in [Listing 9-2](chapter9.xhtml#Lis9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: A registered issuer claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *subject claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>,
    identifies the principal to which the JWT belongs. For an OAuth client authentication
    flow, the subject claim must be the client ID of the OAuth client, whereas for
    an OAuth authorization grant, the subject should identify the resource owner or
    should pseudonymously identify an anonymous user. We create a sample subject claim
    in [Listing 9-3](chapter9.xhtml#Lis9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: A registered subject claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *audience claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">aud</samp>,
    identifies the token’s recipient. Its value could be the token endpoint URL on
    the authorization server or anything else that identifies the recipient, such
    as an application ID. See [Listing 9-4](chapter9.xhtml#Lis9-4) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: A registered audience claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *expiration claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    identifies the time window during which the token is valid. After that period,
    the authorization server will reject the token and you’ll need to request a new
    one. An expiration claim’s value is a number whose date is defined in “seconds
    since the Unix Epoch,” a common format for timestamps. It is calculated by counting
    the number of seconds that have elapsed since January 1, 1970\. [Listing 9-5](chapter9.xhtml#Lis9-5)
    shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: A registered expiration claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *issued at claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">iat</samp>,
    is optional and identifies the time at which the authorization server issued the
    token. You can determine a token’s age from this claim, which is also defined
    in seconds since the Unix Epoch, as shown in [Listing 9-6](chapter9.xhtml#Lis9-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: A registered issued at claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *not before claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp>,
    is optional and identifies the time at which the authorization server should start
    accepting the token. The authorization server will reject every token with an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp> claim in the future.
    We define it as a number in seconds since the Unix Epoch, as you can see in [Listing
    9-7](chapter9.xhtml#Lis9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: A registered not before claim'
  prefs: []
  type: TYPE_NORMAL
- en: The *JWT claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">jti</samp>, is
    optional and sets a unique ID for the token (see [Listing 9-8](chapter9.xhtml#Lis9-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: A registered JWT claim'
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server might keep a list of recent tokens and their expiration
    dates to check whether the token is being reused in a *replay attack*, which occurs
    when an attacker tries to access data by reusing a previously issued token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Public Claims</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A token’s issuer can define public claims for the purpose of adding an application-specific
    public API. Unlike private claims, these are custom properties defined for public
    access. The issuer should register these claims in the JWT Claims registry or
    use collision-resistant names with custom namespaces—for example, a UUID or the
    application’s name. Also, as public claims are meant for public consumption, they
    should never include private or sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: A public claim for the OAuth JWT of our fictional weather service might include
    the ZIP code to directly provide each station’s location data. By making the ZIP
    code a public claim, we won’t need to parse the user object and extract the ZIP
    code manually. Also, as the location is publicly available information on social
    media profiles, it’s not sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Private Claims</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Private claims are custom claims that are neither registered claims nor public
    claims. We can define them to our liking, and they can be specific to our application
    or use case. Even though they don’t need to be collision resistant, using a private
    namespace is recommended. Unlike public claims, private claims contain information
    specific to the application and are intended to be used only internally. Whereas
    the public claims store generic information such as the name, the private claims
    contain the application’s user ID and role. For example, we could define a private
    claim for the OAuth JWT of our fictional weather service to specify the type of
    service we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the payload object’s possible properties, you can create
    a complete payload like the one in [Listing 9-9](chapter9.xhtml#Lis9-9), which
    specifies GitHub as the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: The JWT payload for the OAuth weather service'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we create a constant and store the object there. Our payload has three
    claims, each of a different type. It’s up to the publisher of the JWT token to
    decide which claims to include; for this example, we limit the size of the token
    to one of each type. The registered claim <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    sets the expiration date and time, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    is a public claim, and <samp class="SANS_TheSansMonoCd_W5Regular_11">role</samp>
    is a private claim. Both use the custom namespace <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    to minimize the risk of a collision.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Signature</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the header and payload in place, we create a JWT signature by using the
    algorithm specified in the header to calculate the checksum. We pass the header
    and payload as Base64-encoded strings and a custom secret to the checksum function.
    As an exercise, we’ll create the signature in TypeScript with the code from [Listing
    9-10](chapter9.xhtml#Lis9-10). You’ll see that the secret is hardcoded for simplicity
    here. In production code, this secret should be stored in an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Save the code as *index.ts* in a TypeScript project, or use <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-node index.ts</samp> to run it locally. If you prefer, you can also use a TypeScript
    sandbox at [*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io) or [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com)
    to run it. Generate a fresh secret (*[https://www.usemodernfullstack.dev/generate-secret](https://www.usemodernfullstack.dev/generate-secret)*)
    and use it instead of the one in the listing to see how the token changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: An index.ts file to calculate the JWT signature for the OAuth2
    weather service'
  prefs: []
  type: TYPE_NORMAL
- en: We use Node.js’s standard crypto module and then create a library for transforming
    the JSON objects into Base64-encoded strings via buffers. We pass the strings
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">secret</samp> to the crypto
    module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHmac</samp> function
    to initialize the HMAC object with <samp class="SANS_TheSansMonoCd_W5Regular_11">sha256</samp>
    as the hashing algorithm, Then we feed the Base64-encoded header and payload string,
    separated by a period, to the HMAC object. Finally, we convert the result to a
    hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the JWT string, we create an array containing the Base64-encoded strings
    from the header and payload objects, as well as the Base64-encoded signature.
    To convert the array into a string that uses a period to separate every part,
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Array.join</samp> with a
    period as a separator and return the resulting JWT.
  prefs: []
  type: TYPE_NORMAL
- en: To generate the JWT, we run the script. The final JWT token logged to the console
    should look similar to the one in [Listing 9-11](chapter9.xhtml#Lis9-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: The final JWT token for the OAuth2 weather service'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll use our new knowledge to walk through an actual OAuth
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9: Access a Protected Resource</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand OAuth’s components and the theory behind the authorization
    code flow, let’s work with a practical example. We’ll try to access the protected
    resource hosted by an OAuth server at *[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*.
    Run the exercise’s cURL commands from your terminal to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, attempt to access the protected resource without an access token by
    sending a GET request for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag to output
    the headers, and when we search the response for the HTTP code, we see a *401*
    status code, which tells us that we’re not authorized to access the resource and
    must obtain an access token.
  prefs: []
  type: TYPE_NORMAL
- en: To get an access token, we’ll set up an OAuth client by creating a user account
    and registering it with the provider to receive a client ID and client secret.
    Then we’ll make a request to the */oauth/authorize* endpoint, log in with the
    user’s credentials, and receive the authorization grant on our callback URL. Next,
    we’ll exchange the grant code for an access token on the */oauth/access_token*
    endpoint. Finally, we’ll make the same request again, providing the access token
    in the header.
  prefs: []
  type: TYPE_NORMAL
- en: The callback URL can be any URL here, as we’re not sending any actual data to
    it. But for a real authorization grant flow, it needs to be an endpoint on your
    application. Usually, an OAuth SDK provides these, as it handles the response
    and tokens.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up the Client</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we start the OAuth flow, we need to create a user and register an OAuth
    client. Open [*https://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/register*](https://www.usemodernfullstack.dev/register)
    in your browser. On the form shown in [Figure 9-2](chapter9.xhtml#fig9-2), create
    a user account with a username and password of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-2: Creating a user
    account with the OAuth provider</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Then proceed to register a client by providing a callback URL ([Figure 9-3](chapter9.xhtml#fig9-3)).
    This callback URL points to the OAuth callback endpoint on our application. Usually,
    the SDK or the OAuth provider supplies you with instructions on how to set this
    up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-3: Registering a
    client application with the OAuth server to receive the client credentials</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The form is prefilled with a callback URL similar to a typical OAuth callback
    structure. Usually, you find them in the SDK’s documentation. Don’t worry that
    the URL *http://localhost:3000/oauth/callback* doesn’t exist on your application.
    For this exercise, we won’t send any actual data to it; instead, we’ll see that
    it’s part of the request and response flow when we go through the API calls. Click
    the button to move on to the next step, where you create the OAuth client. Make
    sure to write down your username, password, client ID, and client secret. You’ll
    need all of these for the next steps. Then click **Register Your OAuth Client**
    to complete the process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logging In to Receive
    the Authorization Grant</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now the user we registered must use their credentials to log in to the OAuth
    provider, allowing the client application to access their resources. We call the
    OAuth REST API endpoint */oauth/authorize* and (as the resource owner) log in
    with our user credentials, which is the first step of the flow. The API response
    returns a redirect to the callback URL, which contains the authorization grant
    in the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real application, the resource owner would click some “Log in with OAuth”
    button and enter their credentials, and the API calls would happen behind the
    scenes. But for the purposes of this exercise, we’ll perform all API requests
    manually. By using the raw API calls, we’ll see the actions that SDKs usually
    abstract. Call the REST endpoint directly with the following cURL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This POST request logs in to the OAuth provider. We set the URL to the *oauth/authenticate*
    endpoint, as well as our <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header and the appropriate <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header, <samp class="SANS_TheSansMonoCd_W5Regular_11">application/x-www-form-urlencoded</samp>,
    for form data.
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to send
    the POST data indicating that we’re looking for an authorization code. To split
    the POST data into readable chunks, we need to use double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>)
    to wrap it and the backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>)
    for line breaks. We add the client ID we received from the OAuth provider and
    the callback URL we discussed earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>
    parameter specifies the permissions we’re asking for, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    parameter contains a unique random string that mitigates cross-site request forgery
    (CSRF) attacks. The OAuth provider should return this <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    parameter along with the authorization code so that we can verify that its value
    hasn’t changed, proving that the response originated from the correct API and
    not from a third party. In addition, we send the user credentials we registered
    before.
  prefs: []
  type: TYPE_NORMAL
- en: The response headers show us that everything worked as expected. The OAuth API
    responds with a status code of *302* and redirects to the callback URL we provided.
    As you can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    header, the redirect to the callback URL contains the authorization grant in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> parameter, as well as
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> parameter we sent.
    Unlike the state, which is just being reflected, the authorization grant is unique
    and depends on the request data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Authorization
    Grant to Get the Access Token</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we use the authorization grant to request an access token from the OAuth
    server. Copy the code you received in the preceding step and use it to request
    the bearer access token with the client credentials from the */oauth/access_token*
    API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This POST request to the OAuth server uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header to accept a JSON response and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header to a value for POST form data. We send the form data itself with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">data-raw</samp> flag. The data contains
    the authorization grant we received in the <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>
    parameter, a <samp class="SANS_TheSansMonoCd_W5Regular_11">grant_type</samp> parameter
    that tells the API endpoint to expect an authorization grant flow, and the same
    redirect URL as before. We also pass in the client ID and secret.
  prefs: []
  type: TYPE_NORMAL
- en: The response has an HTTP status code of *200*, which means the request succeeded.
    In the response body, we received the access token and additional details. Copy
    the access token’s value for the next step.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Access
    Token to Get the Protected Resource</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We now have an access token from the OAuth server that we can use to retrieve
    the protected resource we couldn’t access at the beginning of this exercise. Use
    the same cURL command to request *[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*,
    and replace the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ACCESS_TOKEN</samp>
    placeholder with the access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Bearer</samp> keyword
    and the access token we received from the authorization grant flow in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">access_token</samp> property. When we
    search for the HTTP status code, we see that instead of a code of *401*, we receive
    a code of *200*. On closer inspection, we also see that the response’s body contains
    the secured content.
  prefs: []
  type: TYPE_NORMAL
- en: We manually walked through all the necessary steps for receiving a working access
    token. This exercise is appropriate for educational purposes only; as mentioned
    earlier in this chapter, we usually use an SDK or a library such as *next-auth*
    to implement an OAuth flow.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authentication involves using credentials to authorize access, whereas authorization
    defines and grants access rights. This chapter covered implementing authorization
    with the OAuth2 protocol. You became familiar with the authorization grant flow,
    the most common OAuth flow used in full-stack web applications, and learned how
    to create JWTs. Then you practiced manually working with OAuth, getting and using
    the JWT bearer token, and applying the OAuth flow to your application from a bird’s-eye
    view.
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional resources, tutorials, and specifications at [*https://<wbr>oauth<wbr>.net*](https://oauth.net).
    The next chapter covers Docker, a containerization platform that decouples your
    development environment from your local machine.
  prefs: []
  type: TYPE_NORMAL
