- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STORING
    STATE WITH THE FLIP-FLOP</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Alongside the look-up table, the other main component in an FPGA is the *flip-flop*.
    Flip-flops give FPGAs the ability to remember, or store, state. In this chapter,
    we’ll explore how flip-flops work and learn why they’re important to the functioning
    of FPGAs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Flip-flops make up for a shortcoming of look-up tables. LUTs generate output
    as soon as they’re provided input. If all you had to work with was LUTs, your
    FPGA could perform all the Boolean algebra you might want, but your outputs would
    be determined solely based on the current inputs. The FPGA would know nothing
    about its past state. This would be very limiting. Implementing a counter would
    be impractical, since a counter requires knowledge of a previous value that can
    be incremented; so would storing the result of some math operation as a variable.
    Even something as critical as having a concept of time is impractical with just
    LUTs; you can only calculate values based on the now, not on anything in the past.
    The flip-flop enables these interesting capabilities, which is why it’s critical
    to the operation of an FPGA.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How a Flip-Flop Works</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A flip-flop stores state in the form of a high or low voltage, corresponding
    to a binary 1 or 0 or a true/false value. It does this by periodically checking
    the value on its input, passing that value along to its output, and holding it
    there. Consider the basic diagram of a *D flip-flop* shown in [Figure 4-1](#fig4-1).
    D flip-flops are the most common type of flip-flop in FPGAs, and they’re the focus
    of this chapter. (I’ll drop the *D* in front of *flip-flop* going forward.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A diagram of a
    D flip-flop</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the component has three inputs on the left and one output on the
    right. The top-left input, labeled *D*, is the *data input* to the flip-flop.
    It’s where data, in the form of 1s or 0s, comes in. The bottom-left input, labeled
    with what looks like a greater-than (>) sign, is the *clock input*, which synchronizes
    the performance of the flip-flop. At regular intervals, the clock input triggers
    the flip-flop to take the value from the data input and pass it to the output
    (labeled *Q* in the diagram).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The middle-left input, labeled *En*, is the *clock enable*. As long as the clock
    enable is high, the clock input will continue to trigger the flip-flop to update
    its output. If the clock enable input goes low, however, the flip-flop will ignore
    its clock and data inputs, essentially freezing its current output value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how a flip-flop operates, we need to look more closely
    at the signal coming in to the clock input.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Clock Signal</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *clock signal*, often just called a *clock*, is a digital signal that steadily
    alternates between high and low, as shown in [Figure 4-2](#fig4-2). This signal
    is usually provided via a dedicated electronic component external to the FPGA.
    A clock is key to how FPGAs operate: it triggers other components, such as flip-flops,
    to perform their tasks. If you think of an FPGA as a set of gears, the clock is
    like the big gear that turns all the other gears. If the main gear isn’t spinning,
    the others won’t spin either. You could also think of the clock as the heart of
    the system, since it keeps the beat for the entire FPGA. Every flip-flop in the
    FPGA will be updated on the pulse of the clock’s heartbeat.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A clock signal</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the vertical lines in the clock signal diagram, where the signal jumps
    from low to high or high to low. These abrupt changes in the signal are called
    *edges*. When the clock goes from low to high, it’s called a *rising edge*, and
    when it goes from high to low, it’s called a *falling edge*. Flip-flops are conventionally
    triggered on each rising edge of the clock: whenever the clock signal changes
    from low to high, the flip-flop updates its output to match its data input.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s possible to trigger a flip-flop with the falling edges of a clock, but
    this is* much *less common than using the rising edge.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Every clock has a *duty cycle*, the fraction of time that the signal is high.
    For example, a signal with a 25 percent duty cycle is high one-quarter of the
    time and low three-quarters of the time. Almost all clocks, including the one
    shown in [Figure 4-2](#fig4-2), have a 50 percent duty cycle: they’re half-on,
    half-off.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A clock also has a *frequency*, which is the number of repetitions from low
    to high and back again (called a cycle) in a second. Frequency is measured in
    hertz (Hz), or cycles per second. You may be familiar with your computer’s CPU
    frequency, which can be measured in gigahertz (GHz), where 1 GHz is 1 billion
    Hz. FPGAs don’t often run quite that quickly. More commonly, FPGA clock signals
    run in the tens to hundreds of megahertz (MHz), where 1 MHz is 1 million Hz. As
    an example, the clock on the Go Board (discussed in [Appendix A](appendix_A.xhtml))
    runs at 25 MHz, or 25 million cycles per second.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Another way to describe a clock’s speed is to refer to its *period*, the duration
    of a single clock cycle. You can calculate the period by finding 1 ÷ *frequency*.
    In the case of the Go Board, for instance, the clock period is 40 nanoseconds
    (ns).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Flip-Flop in Action</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A flip-flop operates on the transitions of its clock input. As mentioned previously,
    when a flip-flop sees a rising edge of the clock, it checks the state of the data
    input signal and replicates it at the output—assuming the clock enable pin is
    set to high. This process is called *registering*, as in, “the flip-flop *registers*
    the input data.” Thanks to this terminology, a group of flip-flops is known as
    a *register*, and by extension, a single flip-flop can also be called a *one-bit
    register*. One flip-flop by itself is able to register a single bit of data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To see how registering works in practice, we’ll examine a few example inputs
    to a flip-flop and their corresponding outputs. First, consider [Figure 4-3](#fig4-3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: An example of flip-flop
    behavior</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows three waveforms: the top one (Clk) represents an FPGA’s clock
    signal, the middle one (D) is the data input of a flip-flop, and the bottom one
    (Q) is the flip-flop’s output. Let’s assume the clock enable is high, so the flip-flop
    is always enabled. We can see the waveforms across three cycles of the clock;
    the rising edge of each clock cycle is indicated with the numbers 1, 2, and 3\.
    In between the first and second rising edges of the clock, the D input goes from
    low to high, but notice that the output doesn’t immediately go high when the input
    does. Instead, it takes a bit of time for the flip-flop to register the change
    in the input. Specifically, it takes until the *next rising clock edge* for the
    flip-flop output to follow the input.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The flip-flop looks at the input data and makes the output match the input only
    at the rising edge of the clock, never between edges. In this case, at the rising
    edge of the second clock cycle, the output Q sees that D has gone from low to
    high. At this point, Q takes on the same value as D. On the third rising edge,
    Q again checks the value of D and registers it. Since D hasn’t changed, Q stays
    high. Q also registered D at the rising edge of the first clock cycle, but since
    both D and Q were low at that point, Q didn’t change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Now consider [Figure 4-4](#fig4-4), which shows how a flip-flop responds to
    another example scenario.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: Another example
    of flip-flop behavior</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Here we again see a flip-flop operating over several cycles of the clock. Again,
    let’s assume the flip-flop is always enabled. Between the clock’s first and second
    rising edges, input D goes from low to high. On the second rising edge, Q sees
    that D has gone high, so it toggles from low to high as well. On the third rising
    edge, Q sees D has stayed high, so it stays high, too. Between the third and fourth
    rising edges, D goes low, and the output similarly goes low on the fourth rising
    edge. On the last rising edge, D is still low, so Q stays low as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The previous examples have all assumed the clock enable input is high. Let’s
    now show what happens when the flip-flop’s clock enable isn’t always high. [Figure
    4-5](#fig4-5) shows the exact same Clk and D waveforms as [Figure 4-4](#fig4-4),
    but instead of the clock enable remaining high the whole time, it’s only high
    at the third rising edge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-5.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: Flip-flop behavior
    with the clock enable signal</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: With the clock enable (En) now in play, a completely different output Q is generated.
    Q no longer “sees” that D has gone high on clock cycle two, since the clock enable
    is low at that point. Instead, Q only changes its output from low to high on clock
    cycle three, when the clock enable is high. On clock cycle four, D has gone low,
    but Q doesn’t follow D. Instead, it stays high. This is because the clock enable
    has gone low at that point, locking the output in place. The flip-flop will no
    longer register any changes on D to Q.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: These examples demonstrate flip-flop behavior, showing how a flip-flop’s activity
    is coordinated by a clock. Additionally, we’ve seen how turning off the clock
    enable pin allows flip-flops to retain state, even when the input D is changing.
    This gives flip-flops the ability to store data for a long time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Chain of Flip-Flops</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flip-flops are commonly chained together, with the output from one flip-flop
    going directly into the data input of another flip-flop. For example, [Figure
    4-6](#fig4-6) shows a chain of four flip-flops. For simplicity, let’s assume these
    are always enabled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: A chain of four
    flip-flops</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The four flip-flops, labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>, are chained
    such that the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    goes to the input of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>,
    the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp> goes
    to the input of <samp class="SANS_TheSansMonoCd_W5Regular_11">test3</samp>, and
    so on. All four flip-flops are driven by the same clock. The clock synchronizes
    their operation: with each rising edge of the clock, all four flip-flops will
    check the value on their input and register that value to their output.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp> flip-flop
    registers a change at its input. [Figure 4-7](#fig4-7) illustrates how that change
    will propagate through the flip-flop chain, all the way to the output of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: A change of input
    propagating through the flip-flop chain</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows waveforms for the clock signal, the input and output of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp> flip-flop (<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>, respectively),
    and the output of each subsequent flip-flop. On the first clock cycle rising edge
    (labeled 1), <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp> is low,
    so <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp> stays low as well.
    It’s not until the second rising clock edge that the first flip-flop “sees” that
    the input has changed to high and registers that to its output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    flip-flop’s output is also the input to the <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>
    flip-flop, but notice that the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>
    doesn’t immediately change to high when the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    does. Instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">test2_q</samp> changes
    one clock cycle later, on the third rising clock edge. Then, on the fourth rising
    edge, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">test3_q</samp> go high,
    and finally on the fifth rising edge <samp class="SANS_TheSansMonoCd_W5Regular_11">test4_q</samp>
    goes high and stays high.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了时钟信号、<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>触发器的输入和输出（分别为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>）以及每个后续触发器的输出。在第一个时钟周期的上升沿（标记为1），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>为低，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>也保持为低。直到第二个上升时钟沿，触发器才“看到”输入变为高，并将其注册到输出中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>触发器的输出也是<samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>触发器的输入，但注意到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>的输出并不会在<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>的输出变高时立即变高。相反，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test2_q</samp>会在第三个上升时钟沿时变化。然后，在第四个上升沿时，我们看到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test3_q</samp>变高，最后在第五个上升沿时<samp class="SANS_TheSansMonoCd_W5Regular_11">test4_q</samp>变高并保持高。
- en: By adding three flip-flops behind <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>,
    we’ve delayed the output by three clock cycles as the signal propagates through
    the chain. Each flip-flop in the chain adds a single clock cycle of delay. This
    technique of delaying signals by adding a chain of flip-flops is a useful design
    practice when working with FPGAs. Among other things, designers may chain flip-flops
    to create circuits that can delay or remember data for some amount of time, or
    to convert serial data to parallel data (or vice versa).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>后面添加三个触发器，我们将输出延迟了三个时钟周期，因为信号通过链条传播。链中的每个触发器都会增加一个时钟周期的延迟。这种通过添加触发器链来延迟信号的技术，在使用FPGA时是一个有用的设计实践。设计师们可以通过链式连接触发器来创建电路，以便延迟或记住数据一段时间，或将串行数据转换为并行数据（或反之）。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #3: Blinking an LED</samp>'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #3：闪烁LED</samp>'
- en: Now that you know how flip-flops work, we’ll make use of a couple of them in
    a project where the FPGA must remember information about its own state. Specifically,
    we’re going to toggle the state of an LED each time a switch is released. If the
    LED was off before the switch is released, it should turn on, and if the LED was
    on, it should turn off.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了触发器的工作原理，我们将在一个项目中使用几个触发器，在这个项目中，FPGA必须记住它自身状态的信息。具体来说，我们将每次释放开关时切换LED的状态。如果在释放开关之前LED是关闭的，它应该打开；如果LED是打开的，它应该关闭。
- en: 'This project uses two flip-flops. The first is for remembering the state of
    the LED: whether it’s on or off. Without this memory, the FPGA would have no way
    of knowing whether to toggle the LED each time the switch is released; it won’t
    know if the LED is on and needs to be turned off, or off and needs to be turned
    on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目使用了两个触发器。第一个用于记住LED的状态：它是开着还是关着。如果没有这个记忆功能，FPGA就无法知道每次释放开关时是否需要切换LED的状态；它无法知道LED是开着需要关闭，还是关着需要打开。
- en: 'The second flip-flop allows the FPGA to detect when the switch is released.
    Specifically, we’re looking for the falling edge of the switch’s electrical signal:
    its transition from high to low. A good way to look for a falling edge in an FPGA
    is to register the signal in question by passing it through a flip-flop. When
    the input value of the flip-flop (that is, the unregistered value) is equal to
    0 but the previous output value (the registered value) is equal to 1, then we
    know that a falling edge has occurred. The falling edge of the switch is not to
    be confused with the rising edge of the clock; we’re still using the rising edge
    of the clock to drive all of our flip-flops. [Figure 4-8](#fig4-8) shows the pattern
    to look for.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: Falling edge detection
    using flip-flop</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> is the clock
    signal; <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> represents
    the electrical signal from the switch, which passes into a flip-flop; and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is the flip-flop’s output.
    At the circled rising clock edge, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is low, but <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is
    high. This pattern is how we can detect the falling edge of a signal. One thing
    to note is that while <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    does go low on the rising clock edge, when the logic evaluates the state of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> at that same rising
    clock edge, it will still “see” that <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    is high. Only after some small delay will the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    go low, following the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This project will also require some logic between the two flip-flops, which
    will be implemented in the form of a LUT. This will be your first glimpse of how
    flip-flops and LUTs work together in an FPGA to accomplish tasks. [Figure 4-9](#fig4-9)
    shows an overall block diagram for this project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-9.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: The Project #3
    block diagram</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The output of one of the switches on your development board (SW1) goes into
    the FPGA, where the falling edge detection logic is implemented. The output of
    this logic drives one of the board’s LEDs (D1). Now we’ll look at how to implement
    this design.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can write our LED-toggling code using Verilog or VHDL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We begin by defining two inputs (the clock and the switch) and a single output
    (the LED). Then we create two signals ❶ : <samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>. We do this
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp> keyword (short
    for *register*) in Verilog, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp>
    keyword in VHDL. Ultimately these signals will be implemented as flip-flops, or
    registers, so we prefix their names with the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>.
    It’s good practice to label any signals that you know will become registers <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">signal_name</samp>, as it helps
    keep your code organized and easy to search.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个输入（时钟和开关）和一个输出（LED）。然后我们创建两个信号❶：<samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>。我们通过使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">reg</samp> 关键字（即 *寄存器* 的缩写）在 Verilog 中定义，或者在
    VHDL 中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp> 关键字。最终，这些信号将实现为触发器或寄存器，因此我们在它们的名称前加上字母
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>。将任何你知道会变成寄存器的信号标记为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">signal_name</samp> 是一种良好的编程习惯，因为它有助于保持代码的有序性和易于搜索。
- en: 'Next, we initiate what’s known as an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block in Verilog or a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block in VHDL ❷. This type of code block is triggered by changes in one or more
    signals, as specified by the code block’s *sensitivity list*, which is given in
    parentheses when the block is declared. In this case, the block is sensitive to
    the clock signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    Specifically, this block will be triggered any time the clock changes from a 0
    to a 1; that is, at each rising clock edge. Remember, when you use a clock to
    trigger logic within your FPGA, you’ll almost always be using the clock’s rising
    edges. In Verilog, we indicate this with the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">posedge</samp>
    (short for *positive edge*, another term for *rising edge*) within the sensitivity
    list itself: <samp class="SANS_TheSansMonoCd_W5Regular_11">always @(posedge i_Clk)</samp>.
    In VHDL, however, we only put the signal name in the sensitivity list, and specify
    to watch for rising edges two lines later, with <samp class="SANS_TheSansMonoCd_W5Regular_11">if
    rising_edge(i_Clk) then</samp>.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 Verilog 中初始化一个被称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    的代码块，或者在 VHDL 中初始化一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    代码块❷。这种类型的代码块会在一个或多个信号发生变化时触发，具体由代码块的 *敏感列表* 指定，敏感列表会在声明代码块时放在括号中。在这种情况下，该代码块对时钟信号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> 敏感。具体来说，每当时钟从 0 变为
    1 时，这个代码块就会被触发，也就是说，在每个上升沿时触发。请记住，当你使用时钟来触发 FPGA 中的逻辑时，你几乎总是会使用时钟的上升沿。在 Verilog
    中，我们通过关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">posedge</samp>（即 *正沿*
    的缩写，另一个说法是 *上升沿*）在敏感列表中进行指示：<samp class="SANS_TheSansMonoCd_W5Regular_11">always
    @(posedge i_Clk)</samp>。然而，在 VHDL 中，我们只将信号名称放入敏感列表中，并在两行后指定观察上升沿，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if
    rising_edge(i_Clk) then</samp>。
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, we create the first
    flip-flop of this project by taking the input signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    and registering it into <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    ❸. This line of code will generate a flip-flop with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    on the D input, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    on the Q output, and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>
    going into the clock input. The output of this flip-flop will generate a one-clock-cycle
    delay of any changes to the input. This effectively gives us access to the previous
    state of the switch, which we need to know in order to detect the falling edge
    of the switch’s signal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We next check to see if the switch has been released ❹. To do this, we compare
    the current state of the switch with its previous state, using the flip-flop we
    just created ❸. If the current state (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>)
    is 0 *and* the previous state (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>)
    is 1, then we’ve detected a falling edge, meaning the switch has been released.
    The *and* check will be accomplished with a LUT.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: At this point, perhaps you’ve noticed something surprising. First we assigned
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    ❸, then we checked if <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is 1
    ❹. You might think that since we just assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>, they’d always
    be equal, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    would never be true. Right? Wrong! Assignments in an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block that use
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> don’t occur immediately.
    Instead, they take place on each rising edge of the clock and therefore *are all
    executed at the same time*. If at a rising clock edge <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is 1,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement will evaluate
    as true, even as <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    is simultaneously switching from a 1 to a 0 to match <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re thinking in parallel instead of serially! We’ve generated assignments
    that occur all at once, instead of one at a time. This is completely different
    from traditional programming languages like C and Python, where assignments occur
    one after the other. To further drive this point home, you could move the assignment
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> to the last
    line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, and everything would
    still work the same. Formally, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment a *non-blocking assignment*, meaning it doesn’t prevent (“block”) other
    assignments from taking place at the same time. In [Chapter 10](chapter10.xhtml),
    we’ll revisit this concept and compare non-blocking assignments with blocking
    assignments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, we toggle the state of the LED ❺. Doing so generates the second flip-flop
    used in this project. We take the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>,
    invert it, and store the result back into the flip-flop. That might sound impossible,
    but it’s perfectly valid. The output of the flip-flop will pass through a LUT,
    acting here as a NOT gate, and then be fed back into the flip-flop’s input. This
    way, if the LED was on it’ll turn off, and vice versa.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Constraints</samp>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the code is ready, it’s time to run the tools to build the FPGA image and
    program your board. First, since this project uses a clock, you need to add a
    constraint telling the FPGA tool about the clock’s period. The clock period tells
    the timing tool how much time is available to route wires between flip-flops.
    As clock speed increases, it gets harder for the FPGA to *meet timing*, or achieve
    all the desired tasks within each clock cycle. For slower clocks, with frequencies
    on the order of tens of megahertz, you shouldn’t have any problems meeting timing.
    In general, it’s only when you deal with clocks that are faster than 100 MHz that
    you may start to run into timing issues.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The clock period will vary from one development board to another, and can be
    found in your board’s documentation. To tell Lattice iCEcube2 about the clock
    period, create a new text file with a *.sdc* file extension containing something
    like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a clock with a 40 ns period (25 MHz frequency) and assigns that
    constraint to the signal called <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>
    in your design. This constraint will work for the Go Board, as an example, but
    if your board has a different clock period, replace <samp class="SANS_TheSansMonoCd_W5Regular_11">40.00</samp>
    with the appropriate value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Constraint Files** under **Synthesis Tool** and select the *.sdc*
    file to add it to your project in iCEcube2\. Remember from [Chapter 2](chapter2.xhtml)
    that we previously had a single *.pcf* constraint file telling the tools which
    signals to map to which pins. Now we have an additional constraint file just for
    the clock. Both are critical for getting your FPGA to work correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the *.pcf* file to include the pin corresponding to
    the new clock signal. On the Go Board, for example, the clock is connected to
    pin 15 of the FPGA, so you would need to add the following pin constraint:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Check the schematic for your development board to see which pin has the clock
    as an input, and replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>
    as appropriate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’re now ready to run the build. When you do this, the tools will generate
    some reports. The synthesis report should look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This report tells us that we’re using two register bits ❶, meaning our design
    includes two flip-flops. This is exactly what we expected. The report also shows
    that we’re using one LUT ❸. This single LUT will be able to perform both the AND
    and NOT operations required in the code. Notice, too, that the tools identified
    the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> as a clock
    ❷.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the place and route reports, which you can view in iCEcube2
    by going to **P&R Flow****Output Files****Reports**. There are two reports here.
    The first is a pin report, which tells you which signals were mapped to which
    pins. You can use this to confirm that your signals were mapped correctly. The
    second is the timing report. It has a section labeled “Clock Frequency Summary”
    that should look something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This section tells you if the constraint file was accepted correctly. Here we
    see that the tools have found our clock, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> property indicates
    the tools have recognized a 25 MHz constraint placed on the clock (your number
    will vary, depending on your development board), while the <samp class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp>
    property tells us the maximum frequency at which the FPGA could theoretically
    run our code successfully. In this case, we could run this FPGA at 654.05 MHz
    and it would still be guaranteed to work correctly. That’s quite fast! As long
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp> property
    is higher than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    property, you shouldn’t have any issues running your code. A problem would show
    up here in the form of a *timing error*, which happens when the target clock speed
    is greater than the frequency that the tools can achieve. In [Chapter 7](chapter7.xhtml),
    we’ll take a deeper look at what causes timing errors and how to fix them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve successfully built the FPGA design, you can program your board
    and test the project. Try pushing the switch several times. You should see the
    LED toggle on or off each time the switch is released. Congratulations, you’ve
    got your first flip-flop working!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: However, you may notice something strange going on. The LED may not appear to
    change its state with each release. You might think that the FPGA isn’t registering
    the releases of the switch, but in fact the LED is toggling two or more times
    with each release, so quickly that your eyes don’t see it. The cause is related
    to the physical workings of the switch itself. To solve this issue, the switch
    needs to be *debounced*. You’ll learn what this means and how to do it in the
    next chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Combinational Logic vs. Sequential Logic</samp>
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two kinds of logic that can take place inside an FPGA: combinational
    logic and sequential logic. *Combinational logic* is logic for which the outputs
    are determined by the present inputs, with no memory of the previous state. This
    kind of logic is achieved with LUTs, which you’ll recall generate their output
    based only on their current inputs. *Sequential logic*, on the other hand, is
    logic for which the outputs are determined both by present inputs and previous
    outputs. Sequential logic is achieved with flip-flops, since flip-flops don’t
    immediately register changes on their inputs to their outputs, but rather wait
    until the rising edge of the clock to act on the new input data.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*You may also see combinational logic and sequential logic referred to as*
    combinatorial logic *and* synchronous logic*, respectively.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: It might not be obvious that a flip-flop’s output depends on its previous output,
    so let’s explore an example to make this more concrete. Suppose the flip-flop
    is enabled, its input is low, its clock is low, and the output is low. Then suddenly
    the input goes high, then back low again quickly. What will the output do? Nothing!
    It stays low, since there was no clock edge to trigger a change. Now, what happens
    if that same flip-flop has the same initial conditions, except the output is high?
    In this case, of course, the output will stay high. But if we only looked at the
    inputs (D, En, and Clk), *we would be unable to predict the output state*. You
    need to know what the output of the flip-flop was (its previous state) to determine
    the flip-flop’s current state. That’s why a flip-flop is sequential.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Knowing if your code is going to instantiate LUTs (combinational logic) or flip-flops
    (sequential logic) is critical to being a good FPGA designer, but sometimes it
    can be hard to tell the difference. In particular, an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block (in VHDL) can define a block of either combinational logic or sequential
    logic. We’ll consider examples of each to see how they differ.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s an example of a combinational implementation in Verilog and VHDL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we’ve created an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block with a sensitivity
    list (the signals in the parentheses) that includes two signals: <samp class="SANS_TheSansMonoCd_W5Regular_11">input_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">input_2</samp>. The code block
    performs an AND operation on the two signals.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This block of Verilog or VHDL code will only generate LUTs; it won’t generate
    any flip-flops. For our purposes, flip-flops require a clock input, and there
    is no clock. Since no flip-flops are generated, this is combinational logic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a slight modification to the examples just shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code looks very similar to the previous examples, except now the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block’s sensitivity list has changed to be sensitive to the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    Since the block is sensitive to a clock, it’s now considered sequential logic.
    This block will actually still require a LUT to perform the AND operation, but
    in addition to that the output will utilize a flip-flop, since the clock is gating
    the output from updating all the time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'While all the examples in this section are valid code, I’m going to make a
    suggestion, especially for FPGA beginners: when writing your code, only create
    *sequential* <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> blocks
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks
    (in VHDL). The way to do this is to ensure that the block’s sensitivity list only
    has a clock in it. (A clock and a reset is OK too, as we’ll discuss later in the
    chapter.) Combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    blocks and <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks
    can get you into trouble: you can generate a latch by accident. We’ll explore
    latches in the next section, but basically, they’re bad. Additionally, I find
    code is more readable if you know that every time you come across an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, it
    will always be generating sequential logic.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: As for combinational-only logic, write it outside of an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. In
    Verilog, the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp>
    is useful. In VHDL, you can simply use the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment to create combinational logic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Dangers of Latches</samp>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *latch* is a digital component that can store state without the use of a clock.
    In this way, latches perform a similar function as flip-flops (namely, storing
    state), but the method they use is different since there’s no clock involved.
    Latches are dangerous and can be inadvertently generated when working with combinational
    code. In my career, I’ve never once generated a latch *on purpose*, only by accident.
    It’s highly unlikely that you’d ever actually want to generate a latch either,
    so it’s important to understand how to avoid them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: You always want your FPGA designs to be predictable. Latches are dangerous because
    they violate this principle. FPGA tools have a very difficult time understanding
    the timing relationship of a latch and how other components connected to it will
    perform. If you do manage to create a latch with your code, the FPGA tools will
    scream at you with warnings about the fact that you’ve done a horrible thing.
    Please don’t ignore these warnings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: So how can this happen? A latch is created when you write a combinational <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block or conditional assignment
    (in VHDL) or a combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block (in Verilog) with an *incomplete assignment*, meaning the output isn’t assigned
    under all possible input conditions. This is bad and should be avoided. [Table
    4-1](#tab4-1) shows an example of a truth table that would generate a latch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Truth Table That Creates a Latch</samp>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">Undefined</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: 'This truth table has two inputs and one output. The output is 0 when both inputs
    are 0, and it’s 1 when input A is 0 and input B is 1, or when input A is 1 and
    input B is 0\. But what happens when both inputs are 1? We haven’t explicitly
    stated what will occur. In this case, the FPGA tools assume that the output should
    retain its previous state, much like a flip-flop is capable of doing, but without
    the use of a clock. For example, if the output is 0 and both inputs go high, the
    output will stay 0\. If the output is 1 and both inputs go high, the output will
    stay 1\. This is the behavior that a latch creates: the ability to store state
    without a clock.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how this truth table could be created in Verilog and VHDL.
    Don’t write code like this!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, our <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block is combinational
    because there’s no clock in the sensitivity list ❶ or the block itself, just two
    inputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>.
    We mimic the incomplete truth table assignment of the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    using conditional checks. Notice that we don’t explicitly check the condition
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>
    are both 1\. Big mistake!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to try to synthesize this faulty code, the FPGA tools would generate
    a latch and warn you about it in the synthesis report. The warning would look
    something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The tools are pretty good. They tell you that there’s a latch, they tell you
    which signal it is (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>),
    and they tell you why it might be occurring.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid generating a latch, we could add an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement ❷, which will cover all remaining possibilities. As long as the output
    is defined for all possible inputs, we’ll be safe. An even better solution, however,
    would be not to use a combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block at all.
    I discourage the use of combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks precisely
    because it’s easy to make this mistake of omitting an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement. Instead, we can use a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. Here’s
    what that looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, because
    we’re using a clock in the sensitivity list ❶ and within the block itself. As
    a result, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> will create
    a flip-flop rather than a latch. Flip-flops don’t have the same unpredictable
    timing issues that latches do. Remember that the flip-flop can utilize its <samp
    class="SANS_TheSansMonoCd_W5Regular_11">en</samp> input to retain a value. The
    flip-flop’s <samp class="SANS_TheSansMonoCd_W5Regular_11">en</samp> input will
    be disabled when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp> are both high. This will
    retain the flip-flop’s output with whatever state it had previously, performing
    the same behavior as the latch, but in a safe, predictable way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: One side effect of switching to a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block is that
    it now takes a single clock cycle for the output to be updated. If it’s critical
    that this logic be combinational—with the output updating as soon as one of the
    inputs changes, with no clock delay—then you need to ensure that the output is
    specified for all possible input conditions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other way to generate latches in VHDL. VHDL has the keyword <samp
    class="SANS_TheSansMonoCd_W5Regular_11">when</samp>, which can be used in a conditional
    assignment. Verilog has no equivalent syntax, so this code snippet is for VHDL
    only:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code exists outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block, and again we haven’t explicitly stated what <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    should be assigned to when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp> are both 1, so the
    FPGA tools will infer a latch here. The latch will enable the output to keep its
    previous state, but that’s likely not what we intended. Instead, we should be
    specific with our code and ensure that we have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    condition that sets <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> for
    all possible inputs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Resetting a Flip-Flop</samp>
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flip-flops have an additional input that we haven’t discussed yet, called *set/reset*,
    or often just *reset*. This pin resets the flip-flop back to an initial state,
    which could be 0 or 1\. Resetting flip-flops is useful when the FPGA first powers
    up and initializes. For example, you might want to reset your flip-flops that
    control a state machine to the initial state (we’ll discuss state machines in
    [Chapter 8](chapter8.xhtml)). You might also want to reset a counter to some initial
    value, or reset a filter back to zero. Resetting flip-flops is one method to ensure
    your flip-flops are in a specific state prior to operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of resets: synchronous and asynchronous. *Synchronous resets*
    occur at the same time as the clock edge, whereas *asynchronous resets* can occur
    at any time. You might trigger an asynchronous reset with a button press external
    to the FPGA, for example, since the button press can come at any point in time.
    Let’s look at how to code a reset, starting with a synchronous one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we have an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block with a normal
    sensitivity list; it’s only sensitive to changes of the clock ❶. Inside the block,
    we first check the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    ❷. If it’s high, then we reset the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    to 1\. This is our synchronous reset, since it’s happening on the edge of the
    clock. If <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> is low,
    we proceed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch of the block ❸, where we’d write whatever code we want to be executed under
    normal operating (non-reset) conditions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this example we’re checking if the reset is high. Sometimes resets
    can be active low, however, which is usually indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">_L</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">_n</samp> at the end of the signal
    name. If this were an active low reset, we would check for the signal being 0
    rather than 1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at an asynchronous reset:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we’ve added <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block’s sensitivity list
    ❶. Now, rather than checking the clock state first, we check the reset state first
    ❷. If it’s high, then we perform whatever reset conditions we want, in this case
    setting <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> to 1\. Otherwise,
    we proceed normally ❸.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The choice between synchronous and asynchronous resets should be documented
    in the user guide for your specific FPGA—some FPGAs are optimized to handle one
    or the other. Additionally, resets can create strange bugs if they’re not treated
    properly. Therefore, I strongly recommend consulting the documentation to make
    sure you’re resetting flip-flops correctly for your device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Look-Up Tables and Flip-Flops on a Real
    FPGA</samp>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you understand that LUTs and flip-flops exist on FPGAs, but they may still
    seem a bit abstract. To get a more concrete picture, let’s look at how LUTs and
    flip-flops are actually wired together in a real FPGA. The image in [Figure 4-10](#fig4-10)
    is taken from the datasheet for the Lattice iCE40 LP/HX family of FPGAs, the type
    of FPGA compatible with iCEcube2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*Datasheets* are used throughout the electronics industry to explain the details
    of how a component works. Each FPGA will have at least a few unique datasheets
    with different pieces of information, and more complicated FPGAs can have dozens
    of them.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-10.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: LUTs and flip-flops
    in a real FPGA</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Every FPGA, whether from Lattice, AMD, Intel, or whoever else, will have an
    image very similar to [Figure 4-10](#fig4-10) in its specific family datasheet.
    This particular image shows the basic building block of Lattice iCE40 FPGAs, which
    Lattice calls the *Programmable Logic Block (PLB)*. Each FPGA company has its
    own unique name for these basic building blocks; for example, AMD calls them *Configurable
    Logic Blocks (CLBs)*, while Intel uses *Adaptive Logic Modules (ALMs)*. We’ll
    look at the details of how the PLB from Lattice works as an example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the left side of the image, we see there are eight logic cells in
    each PLB. The right side shows a zoomed-in version of a single logic cell. Inside
    it, notice that there’s a rectangle labeled LUT4\. This is a four-input look-up
    table! There’s also a dark gray box labeled DFF. This is a D flip-flop! The LUT
    and the flip-flop truly are the two most critical components inside an FPGA.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: This diagram is telling us that at the most fundamental level there’s one LUT
    and one flip-flop inside each logic cell, and there are eight logic cells in a
    PLB. The PLB is copy-pasted hundreds or thousands of times inside the FPGA to
    provide enough LUTs and flip-flops to do all the required work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left side of the DFF component (the flip-flop), notice the same three
    inputs we originally saw in [Figure 4-1](#fig4-1): data (D), clock enable (EN),
    and clock (>). The fourth input at the bottom of the component is the set/reset
    (SR) input we discussed in the previous section.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, the clock enable input allows the flip-flop to keep its output
    state for multiple clock cycles. Without the En input, the output would just follow
    the input with one clock cycle of delay. Adding the En input lets the flip-flop
    store a state for a longer duration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to notice in the diagram is the carry logic block, shown above
    and to the left of the LUT4\. This block is mostly used to speed up arithmetic
    functions, such as addition, subtraction, and comparison.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: While reviewing this diagram gave us an interesting look inside an FPGA and
    highlighted the central role of the LUT and the flip-flop, it isn’t critical to
    memorize every detail of the PLB’s architecture. You don’t need to remember all
    the connections and how each is wired to its neighbor. In the real world, you
    write your Verilog or VHDL, and the FPGA tools take care of mapping that code
    onto the FPGA’s resources. This is particularly useful if you want to switch from
    one type of FPGA to another (say, from a Lattice to an AMD). The beauty of Verilog
    and VHDL is that the code is generally portable; the same code works on different
    FPGAs, provided they have enough LUTs and flip-flops to do what you want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter you learned about the flip-flop, which, along with the LUT,
    is one of the two most important components in an FPGA. You saw how flip-flops
    allow FPGAs to keep state, or remember past values, by only registering data from
    the input to the output on the positive edges of a clock signal. You learned how
    logic driven by flip-flops and clock signals is sequential, in contrast to the
    combinational logic of LUTs, and you got your first glimpse of how flip-flops
    and LUTs work together through a project toggling an LED. You also learned how
    to avoid generating latches and how to reset a flip-flop to a default state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, as you build more complex blocks of code, you’ll become
    more familiar with how flip-flops and LUTs interact and see how you can use just
    these two kinds of components to create large, sophisticated FPGA designs. You’ll
    also see the role flip-flops play in keeping track of counters and state machines.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
