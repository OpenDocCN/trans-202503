- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STORING
    STATE WITH THE FLIP-FLOP</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用触发器存储状态</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Alongside the look-up table, the other main component in an FPGA is the *flip-flop*.
    Flip-flops give FPGAs the ability to remember, or store, state. In this chapter,
    we’ll explore how flip-flops work and learn why they’re important to the functioning
    of FPGAs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查找表，FPGA中的另一个主要组件是*触发器*。触发器使得FPGA能够记住或存储状态。在本章中，我们将探讨触发器的工作原理，并了解它们为何对FPGA的功能至关重要。
- en: Flip-flops make up for a shortcoming of look-up tables. LUTs generate output
    as soon as they’re provided input. If all you had to work with was LUTs, your
    FPGA could perform all the Boolean algebra you might want, but your outputs would
    be determined solely based on the current inputs. The FPGA would know nothing
    about its past state. This would be very limiting. Implementing a counter would
    be impractical, since a counter requires knowledge of a previous value that can
    be incremented; so would storing the result of some math operation as a variable.
    Even something as critical as having a concept of time is impractical with just
    LUTs; you can only calculate values based on the now, not on anything in the past.
    The flip-flop enables these interesting capabilities, which is why it’s critical
    to the operation of an FPGA.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器弥补了查找表的一个不足。LUT（查找表）在接收到输入后立即生成输出。如果你只使用LUT，FPGA可以执行所有可能的布尔代数运算，但输出将仅仅基于当前的输入确定。FPGA将无法知道它的过去状态，这会非常有限。例如，实现一个计数器就不现实，因为计数器需要知道一个可以递增的先前值；存储某些数学运算的结果作为变量也是不可能的。仅仅使用LUT，甚至像时间的概念这样的关键操作也无法实现；你只能基于现在来计算值，而不能参考过去的任何信息。触发器赋予了FPGA这些有趣的能力，这也是它在FPGA操作中至关重要的原因。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How a Flip-Flop Works</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">触发器的工作原理</samp>
- en: A flip-flop stores state in the form of a high or low voltage, corresponding
    to a binary 1 or 0 or a true/false value. It does this by periodically checking
    the value on its input, passing that value along to its output, and holding it
    there. Consider the basic diagram of a *D flip-flop* shown in [Figure 4-1](#fig4-1).
    D flip-flops are the most common type of flip-flop in FPGAs, and they’re the focus
    of this chapter. (I’ll drop the *D* in front of *flip-flop* going forward.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器通过高电平或低电平电压的形式存储状态，分别对应二进制的1或0，或者真/假的值。它通过定期检查输入上的值，将该值传递到输出，并保持在那里。考虑图[4-1](#fig4-1)所示的基本*D触发器*图示。D触发器是FPGA中最常见的触发器类型，也是本章的重点。（接下来我将省略*D*，直接称其为*触发器*。）
- en: '![](../images/Figure4-1.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A diagram of a
    D flip-flop</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-1：D触发器的示意图</samp>
- en: Notice that the component has three inputs on the left and one output on the
    right. The top-left input, labeled *D*, is the *data input* to the flip-flop.
    It’s where data, in the form of 1s or 0s, comes in. The bottom-left input, labeled
    with what looks like a greater-than (>) sign, is the *clock input*, which synchronizes
    the performance of the flip-flop. At regular intervals, the clock input triggers
    the flip-flop to take the value from the data input and pass it to the output
    (labeled *Q* in the diagram).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组件左侧有三个输入，右侧有一个输出。左上角的输入标记为*D*，是触发器的*数据输入*。数据（以1或0的形式）通过这里输入。左下角的输入标有类似大于号（>）的符号，是*时钟输入*，它同步触发器的工作。在固定的时间间隔内，时钟输入触发触发器，从数据输入获取值并将其传递到输出（在图示中标记为*Q*）。
- en: The middle-left input, labeled *En*, is the *clock enable*. As long as the clock
    enable is high, the clock input will continue to trigger the flip-flop to update
    its output. If the clock enable input goes low, however, the flip-flop will ignore
    its clock and data inputs, essentially freezing its current output value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 中左侧的输入标记为*En*，即*时钟使能*。只要时钟使能信号为高电平，时钟输入就会持续触发触发器更新其输出。然而，如果时钟使能输入变为低电平，触发器将忽略时钟和数据输入，基本上会冻结当前的输出值。
- en: To better understand how a flip-flop operates, we need to look more closely
    at the signal coming in to the clock input.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解触发器的工作原理，我们需要更仔细地观察进入时钟输入的信号。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Clock Signal</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">时钟信号</samp>
- en: 'A *clock signal*, often just called a *clock*, is a digital signal that steadily
    alternates between high and low, as shown in [Figure 4-2](#fig4-2). This signal
    is usually provided via a dedicated electronic component external to the FPGA.
    A clock is key to how FPGAs operate: it triggers other components, such as flip-flops,
    to perform their tasks. If you think of an FPGA as a set of gears, the clock is
    like the big gear that turns all the other gears. If the main gear isn’t spinning,
    the others won’t spin either. You could also think of the clock as the heart of
    the system, since it keeps the beat for the entire FPGA. Every flip-flop in the
    FPGA will be updated on the pulse of the clock’s heartbeat.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*时钟信号*，通常简称为*时钟*，是一种在高低之间稳定交替的数字信号，如[图 4-2](#fig4-2)所示。这个信号通常通过 FPGA 外部的专用电子元件提供。时钟是
    FPGA 操作的关键：它触发其他组件，如触发器，执行它们的任务。如果你把 FPGA 想象成一组齿轮，那么时钟就像是那个带动其他齿轮转动的大齿轮。如果主齿轮不转动，其他齿轮也不会转动。你也可以把时钟看作系统的心脏，因为它为整个
    FPGA 保持节拍。FPGA 中的每个触发器都会在时钟心跳的脉冲下更新。'
- en: '![](../images/Figure4-2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A clock signal</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-2：时钟信号</samp>
- en: 'Notice the vertical lines in the clock signal diagram, where the signal jumps
    from low to high or high to low. These abrupt changes in the signal are called
    *edges*. When the clock goes from low to high, it’s called a *rising edge*, and
    when it goes from high to low, it’s called a *falling edge*. Flip-flops are conventionally
    triggered on each rising edge of the clock: whenever the clock signal changes
    from low to high, the flip-flop updates its output to match its data input.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意时钟信号图中的竖直线，信号从低到高或从高到低的跳变。这些信号的突变称为*边沿*。当时钟从低到高时，称为*上升沿*；而当时钟从高到低时，称为*下降沿*。触发器通常在时钟的每个上升沿触发：每当时钟信号从低到高变化时，触发器就会更新其输出，以匹配数据输入。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*It’s possible to trigger a flip-flop with the falling edges of a clock, but
    this is* much *less common than using the rising edge.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然可以通过时钟的下降沿触发触发器，但这比使用上升沿*要*少见得多。*'
- en: 'Every clock has a *duty cycle*, the fraction of time that the signal is high.
    For example, a signal with a 25 percent duty cycle is high one-quarter of the
    time and low three-quarters of the time. Almost all clocks, including the one
    shown in [Figure 4-2](#fig4-2), have a 50 percent duty cycle: they’re half-on,
    half-off.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时钟都有一个*占空比*，即信号为高的时间比例。例如，一个 25% 占空比的信号，信号高时占四分之一的时间，低时占四分之三的时间。几乎所有的时钟，包括[图
    4-2](#fig4-2)中所示的时钟，都有 50% 的占空比：它们是半开半关的。
- en: A clock also has a *frequency*, which is the number of repetitions from low
    to high and back again (called a cycle) in a second. Frequency is measured in
    hertz (Hz), or cycles per second. You may be familiar with your computer’s CPU
    frequency, which can be measured in gigahertz (GHz), where 1 GHz is 1 billion
    Hz. FPGAs don’t often run quite that quickly. More commonly, FPGA clock signals
    run in the tens to hundreds of megahertz (MHz), where 1 MHz is 1 million Hz. As
    an example, the clock on the Go Board (discussed in [Appendix A](appendix_A.xhtml))
    runs at 25 MHz, or 25 million cycles per second.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟还有*频率*，即每秒钟从低到高再到低（称为一个周期）的重复次数。频率以赫兹（Hz）来衡量，即每秒钟的周期数。你可能对电脑 CPU 的频率比较熟悉，通常用千兆赫兹（GHz）来表示，其中
    1 GHz 等于 10 亿赫兹。FPGA 的运行速度通常没有那么快。更常见的是，FPGA 时钟信号的频率在几十到几百兆赫（MHz）之间，其中 1 MHz 等于
    100 万赫兹。例如，围棋棋盘上的时钟（在[附录 A](appendix_A.xhtml)中讨论）运行在 25 MHz，即每秒 2500 万个周期。
- en: Another way to describe a clock’s speed is to refer to its *period*, the duration
    of a single clock cycle. You can calculate the period by finding 1 ÷ *frequency*.
    In the case of the Go Board, for instance, the clock period is 40 nanoseconds
    (ns).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 描述时钟速度的另一种方式是指其*周期*，即单个时钟周期的持续时间。你可以通过计算 1 ÷ *频率* 来得到周期。例如，在围棋棋盘的情况下，时钟周期是 40
    纳秒（ns）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Flip-Flop in Action</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">触发器的工作实例</samp>
- en: A flip-flop operates on the transitions of its clock input. As mentioned previously,
    when a flip-flop sees a rising edge of the clock, it checks the state of the data
    input signal and replicates it at the output—assuming the clock enable pin is
    set to high. This process is called *registering*, as in, “the flip-flop *registers*
    the input data.” Thanks to this terminology, a group of flip-flops is known as
    a *register*, and by extension, a single flip-flop can also be called a *one-bit
    register*. One flip-flop by itself is able to register a single bit of data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器在其时钟输入的跃迁上工作。如前所述，当触发器看到时钟的上升沿时，它会检查数据输入信号的状态，并将其复制到输出端——前提是时钟使能引脚设置为高电平。这个过程称为*注册*，也就是说，“触发器*注册*输入数据”。由于这一术语，一组触发器被称为*寄存器*，因此，单个触发器也可以称为*一位寄存器*。一个触发器本身能够注册一个比特的数据。
- en: To see how registering works in practice, we’ll examine a few example inputs
    to a flip-flop and their corresponding outputs. First, consider [Figure 4-3](#fig4-3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解注册操作在实际中的工作方式，我们将检查几个触发器的输入及其对应的输出。首先，考虑 [图 4-3](#fig4-3)。
- en: '![](../images/Figure4-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: An example of flip-flop
    behavior</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-3：触发器行为的一个例子</samp>
- en: 'This figure shows three waveforms: the top one (Clk) represents an FPGA’s clock
    signal, the middle one (D) is the data input of a flip-flop, and the bottom one
    (Q) is the flip-flop’s output. Let’s assume the clock enable is high, so the flip-flop
    is always enabled. We can see the waveforms across three cycles of the clock;
    the rising edge of each clock cycle is indicated with the numbers 1, 2, and 3\.
    In between the first and second rising edges of the clock, the D input goes from
    low to high, but notice that the output doesn’t immediately go high when the input
    does. Instead, it takes a bit of time for the flip-flop to register the change
    in the input. Specifically, it takes until the *next rising clock edge* for the
    flip-flop output to follow the input.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了三种波形：顶部的一个（Clk）代表 FPGA 的时钟信号，中间的一个（D）是触发器的数据输入，底部的一个（Q）是触发器的输出。假设时钟使能信号为高，触发器始终处于启用状态。我们可以看到时钟的三个周期波形；每个时钟周期的上升沿用数字
    1、2 和 3 标示。在时钟的第一次和第二次上升沿之间，D 输入从低电平变为高电平，但请注意，输出不会在输入变高时立即跟随。相反，触发器需要一些时间来注册输入的变化。具体来说，直到*下一个上升沿*，触发器的输出才会跟随输入。
- en: The flip-flop looks at the input data and makes the output match the input only
    at the rising edge of the clock, never between edges. In this case, at the rising
    edge of the second clock cycle, the output Q sees that D has gone from low to
    high. At this point, Q takes on the same value as D. On the third rising edge,
    Q again checks the value of D and registers it. Since D hasn’t changed, Q stays
    high. Q also registered D at the rising edge of the first clock cycle, but since
    both D and Q were low at that point, Q didn’t change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器只在时钟的上升沿查看输入数据，并使输出与输入匹配，绝不会在边沿之间变化。在这种情况下，在第二个时钟周期的上升沿，输出 Q 看到了 D 从低电平变为高电平。此时，Q
    取与 D 相同的值。在第三个上升沿，Q 再次检查 D 的值并注册它。由于 D 没有变化，Q 依然保持高电平。Q 在第一个时钟周期的上升沿也注册了 D，但由于那时
    D 和 Q 都是低电平，Q 并没有发生变化。
- en: Now consider [Figure 4-4](#fig4-4), which shows how a flip-flop responds to
    another example scenario.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 [图 4-4](#fig4-4)，它展示了触发器如何响应另一个例子场景。
- en: '![](../images/Figure4-4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: Another example
    of flip-flop behavior</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-4：另一个触发器行为的例子</samp>
- en: Here we again see a flip-flop operating over several cycles of the clock. Again,
    let’s assume the flip-flop is always enabled. Between the clock’s first and second
    rising edges, input D goes from low to high. On the second rising edge, Q sees
    that D has gone high, so it toggles from low to high as well. On the third rising
    edge, Q sees D has stayed high, so it stays high, too. Between the third and fourth
    rising edges, D goes low, and the output similarly goes low on the fourth rising
    edge. On the last rising edge, D is still low, so Q stays low as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们再次看到触发器在几个时钟周期内的操作。同样，假设触发器始终处于启用状态。在时钟的第一次和第二次上升沿之间，输入 D 从低电平变为高电平。在第二次上升沿，Q
    看到 D 已变高，因此它也从低电平切换为高电平。在第三次上升沿，Q 看到 D 保持高电平，因此 Q 也保持高电平。在第三次和第四次上升沿之间，D 变为低电平，输出也在第四次上升沿变为低电平。在最后一次上升沿，D
    仍为低电平，因此 Q 也保持低电平。
- en: The previous examples have all assumed the clock enable input is high. Let’s
    now show what happens when the flip-flop’s clock enable isn’t always high. [Figure
    4-5](#fig4-5) shows the exact same Clk and D waveforms as [Figure 4-4](#fig4-4),
    but instead of the clock enable remaining high the whole time, it’s only high
    at the third rising edge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例都假设时钟使能输入为高电平。现在让我们展示当触发器的时钟使能不是始终为高时会发生什么。[图 4-5](#fig4-5)展示了与[图 4-4](#fig4-4)完全相同的时钟和数据波形，但时钟使能信号并不是始终为高，而是在第三个上升沿时才为高。
- en: '![](../images/Figure4-5.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: Flip-flop behavior
    with the clock enable signal</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-5：带有时钟使能信号的触发器行为</samp>
- en: With the clock enable (En) now in play, a completely different output Q is generated.
    Q no longer “sees” that D has gone high on clock cycle two, since the clock enable
    is low at that point. Instead, Q only changes its output from low to high on clock
    cycle three, when the clock enable is high. On clock cycle four, D has gone low,
    but Q doesn’t follow D. Instead, it stays high. This is because the clock enable
    has gone low at that point, locking the output in place. The flip-flop will no
    longer register any changes on D to Q.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着时钟使能（En）的参与，生成了完全不同的输出Q。Q不再“看到”在时钟周期二时D变为高电平，因为此时时钟使能为低电平。相反，Q只在时钟周期三时从低变为高，当时钟使能为高电平时。在时钟周期四时，D已变为低电平，但Q并没有跟随D的变化。相反，Q保持为高电平。这是因为此时时钟使能已变为低电平，锁定了输出状态。触发器将不再将D的变化注册到Q上。
- en: These examples demonstrate flip-flop behavior, showing how a flip-flop’s activity
    is coordinated by a clock. Additionally, we’ve seen how turning off the clock
    enable pin allows flip-flops to retain state, even when the input D is changing.
    This gives flip-flops the ability to store data for a long time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了触发器的行为，说明触发器的活动如何通过时钟来协调。此外，我们已经看到关闭时钟使能引脚可以让触发器保持状态，即使输入D在变化。这使得触发器能够长时间存储数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Chain of Flip-Flops</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">触发器链</samp>
- en: Flip-flops are commonly chained together, with the output from one flip-flop
    going directly into the data input of another flip-flop. For example, [Figure
    4-6](#fig4-6) shows a chain of four flip-flops. For simplicity, let’s assume these
    are always enabled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器通常是串联在一起的，一个触发器的输出直接进入另一个触发器的数据输入。例如，[图 4-6](#fig4-6)展示了四个触发器的链式连接。为了简化，假设这些触发器始终是使能的。
- en: '![](../images/Figure4-6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: A chain of four
    flip-flops</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-6：四个触发器的链式连接</samp>
- en: 'The four flip-flops, labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>, are chained
    such that the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    goes to the input of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>,
    the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp> goes
    to the input of <samp class="SANS_TheSansMonoCd_W5Regular_11">test3</samp>, and
    so on. All four flip-flops are driven by the same clock. The clock synchronizes
    their operation: with each rising edge of the clock, all four flip-flops will
    check the value on their input and register that value to their output.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 四个触发器，从<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>，通过链式连接，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>的输出连接到<samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>的输入，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>的输出连接到<samp class="SANS_TheSansMonoCd_W5Regular_11">test3</samp>的输入，依此类推。所有四个触发器都由相同的时钟驱动。时钟同步它们的操作：每当时钟上升沿到来时，所有四个触发器都会检查输入上的值，并将该值注册到输出端。
- en: Suppose the <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp> flip-flop
    registers a change at its input. [Figure 4-7](#fig4-7) illustrates how that change
    will propagate through the flip-flop chain, all the way to the output of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>触发器在其输入端注册了一个变化。[图
    4-7](#fig4-7)展示了这个变化如何传播通过触发器链，直到<samp class="SANS_TheSansMonoCd_W5Regular_11">test4</samp>的输出端。
- en: '![](../images/Figure4-7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: A change of input
    propagating through the flip-flop chain</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-7：输入变化通过触发器链传播</samp>
- en: The figure shows waveforms for the clock signal, the input and output of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp> flip-flop (<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>, respectively),
    and the output of each subsequent flip-flop. On the first clock cycle rising edge
    (labeled 1), <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp> is low,
    so <samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp> stays low as well.
    It’s not until the second rising clock edge that the first flip-flop “sees” that
    the input has changed to high and registers that to its output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    flip-flop’s output is also the input to the <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>
    flip-flop, but notice that the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>
    doesn’t immediately change to high when the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>
    does. Instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">test2_q</samp> changes
    one clock cycle later, on the third rising clock edge. Then, on the fourth rising
    edge, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">test3_q</samp> go high,
    and finally on the fifth rising edge <samp class="SANS_TheSansMonoCd_W5Regular_11">test4_q</samp>
    goes high and stays high.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了时钟信号、<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>触发器的输入和输出（分别为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>）以及每个后续触发器的输出。在第一个时钟周期的上升沿（标记为1），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1_d</samp>为低，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">test1_q</samp>也保持为低。直到第二个上升时钟沿，触发器才“看到”输入变为高，并将其注册到输出中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>触发器的输出也是<samp class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>触发器的输入，但注意到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test2</samp>的输出并不会在<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>的输出变高时立即变高。相反，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test2_q</samp>会在第三个上升时钟沿时变化。然后，在第四个上升沿时，我们看到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">test3_q</samp>变高，最后在第五个上升沿时<samp class="SANS_TheSansMonoCd_W5Regular_11">test4_q</samp>变高并保持高。
- en: By adding three flip-flops behind <samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>,
    we’ve delayed the output by three clock cycles as the signal propagates through
    the chain. Each flip-flop in the chain adds a single clock cycle of delay. This
    technique of delaying signals by adding a chain of flip-flops is a useful design
    practice when working with FPGAs. Among other things, designers may chain flip-flops
    to create circuits that can delay or remember data for some amount of time, or
    to convert serial data to parallel data (or vice versa).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在<samp class="SANS_TheSansMonoCd_W5Regular_11">test1</samp>后面添加三个触发器，我们将输出延迟了三个时钟周期，因为信号通过链条传播。链中的每个触发器都会增加一个时钟周期的延迟。这种通过添加触发器链来延迟信号的技术，在使用FPGA时是一个有用的设计实践。设计师们可以通过链式连接触发器来创建电路，以便延迟或记住数据一段时间，或将串行数据转换为并行数据（或反之）。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #3: Blinking an LED</samp>'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #3：闪烁LED</samp>'
- en: Now that you know how flip-flops work, we’ll make use of a couple of them in
    a project where the FPGA must remember information about its own state. Specifically,
    we’re going to toggle the state of an LED each time a switch is released. If the
    LED was off before the switch is released, it should turn on, and if the LED was
    on, it should turn off.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了触发器的工作原理，我们将在一个项目中使用几个触发器，在这个项目中，FPGA必须记住它自身状态的信息。具体来说，我们将每次释放开关时切换LED的状态。如果在释放开关之前LED是关闭的，它应该打开；如果LED是打开的，它应该关闭。
- en: 'This project uses two flip-flops. The first is for remembering the state of
    the LED: whether it’s on or off. Without this memory, the FPGA would have no way
    of knowing whether to toggle the LED each time the switch is released; it won’t
    know if the LED is on and needs to be turned off, or off and needs to be turned
    on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目使用了两个触发器。第一个用于记住LED的状态：它是开着还是关着。如果没有这个记忆功能，FPGA就无法知道每次释放开关时是否需要切换LED的状态；它无法知道LED是开着需要关闭，还是关着需要打开。
- en: 'The second flip-flop allows the FPGA to detect when the switch is released.
    Specifically, we’re looking for the falling edge of the switch’s electrical signal:
    its transition from high to low. A good way to look for a falling edge in an FPGA
    is to register the signal in question by passing it through a flip-flop. When
    the input value of the flip-flop (that is, the unregistered value) is equal to
    0 but the previous output value (the registered value) is equal to 1, then we
    know that a falling edge has occurred. The falling edge of the switch is not to
    be confused with the rising edge of the clock; we’re still using the rising edge
    of the clock to drive all of our flip-flops. [Figure 4-8](#fig4-8) shows the pattern
    to look for.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个触发器使得 FPGA 能够检测到开关被释放的时刻。具体来说，我们要检测的是开关电信号的下降沿：从高电平到低电平的过渡。在 FPGA 中检测下降沿的一个好方法是将信号通过触发器进行注册。当触发器的输入值（即未注册的值）为
    0，而前一个输出值（即已注册的值）为 1 时，我们就知道发生了下降沿。开关的下降沿不应与时钟的上升沿混淆；我们仍然使用时钟的上升沿来驱动所有的触发器。[图
    4-8](#fig4-8) 显示了需要查找的模式。
- en: '![](../images/Figure4-8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: Falling edge detection
    using flip-flop</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-8：使用触发器进行下降沿检测</samp>
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> is the clock
    signal; <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> represents
    the electrical signal from the switch, which passes into a flip-flop; and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is the flip-flop’s output.
    At the circled rising clock edge, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is low, but <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is
    high. This pattern is how we can detect the falling edge of a signal. One thing
    to note is that while <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    does go low on the rising clock edge, when the logic evaluates the state of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> at that same rising
    clock edge, it will still “see” that <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    is high. Only after some small delay will the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    go low, following the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> 是时钟信号；<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    代表来自开关的电信号，该信号传递到触发器；<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    是触发器的输出。在圈出的上升时钟沿上，我们可以看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    处于低电平，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> 处于高电平。这个模式就是我们如何检测信号的下降沿。需要注意的是，虽然
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> 在上升时钟沿会变为低电平，但当逻辑在同一上升时钟沿评估
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> 的状态时，它仍然会“看到”
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> 为高电平。只有在短暂的延迟后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> 的输出才会变为低电平，跟随 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> 的状态。
- en: This project will also require some logic between the two flip-flops, which
    will be implemented in the form of a LUT. This will be your first glimpse of how
    flip-flops and LUTs work together in an FPGA to accomplish tasks. [Figure 4-9](#fig4-9)
    shows an overall block diagram for this project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目还需要在两个触发器之间实现一些逻辑，形式上将通过 LUT（查找表）来实现。这将是你第一次看到触发器和 LUT 如何在 FPGA 中协同工作来完成任务。[图
    4-9](#fig4-9) 显示了该项目的总体框图。
- en: '![](../images/Figure4-9.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: The Project #3
    block diagram</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-9：项目 #3 的框图</samp>'
- en: The output of one of the switches on your development board (SW1) goes into
    the FPGA, where the falling edge detection logic is implemented. The output of
    this logic drives one of the board’s LEDs (D1). Now we’ll look at how to implement
    this design.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板上的一个开关（SW1）的输出进入 FPGA，其中实现了下降沿检测逻辑。该逻辑的输出驱动着板上的一个 LED（D1）。接下来我们将看看如何实现这个设计。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写代码</samp>
- en: 'We can write our LED-toggling code using Verilog or VHDL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Verilog 或 VHDL 来编写 LED 切换的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We begin by defining two inputs (the clock and the switch) and a single output
    (the LED). Then we create two signals ❶ : <samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>. We do this
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">reg</samp> keyword (short
    for *register*) in Verilog, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp>
    keyword in VHDL. Ultimately these signals will be implemented as flip-flops, or
    registers, so we prefix their names with the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>.
    It’s good practice to label any signals that you know will become registers <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">signal_name</samp>, as it helps
    keep your code organized and easy to search.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个输入（时钟和开关）和一个输出（LED）。然后我们创建两个信号❶：<samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>。我们通过使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">reg</samp> 关键字（即 *寄存器* 的缩写）在 Verilog 中定义，或者在
    VHDL 中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp> 关键字。最终，这些信号将实现为触发器或寄存器，因此我们在它们的名称前加上字母
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>。将任何你知道会变成寄存器的信号标记为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">signal_name</samp> 是一种良好的编程习惯，因为它有助于保持代码的有序性和易于搜索。
- en: 'Next, we initiate what’s known as an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block in Verilog or a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block in VHDL ❷. This type of code block is triggered by changes in one or more
    signals, as specified by the code block’s *sensitivity list*, which is given in
    parentheses when the block is declared. In this case, the block is sensitive to
    the clock signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    Specifically, this block will be triggered any time the clock changes from a 0
    to a 1; that is, at each rising clock edge. Remember, when you use a clock to
    trigger logic within your FPGA, you’ll almost always be using the clock’s rising
    edges. In Verilog, we indicate this with the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">posedge</samp>
    (short for *positive edge*, another term for *rising edge*) within the sensitivity
    list itself: <samp class="SANS_TheSansMonoCd_W5Regular_11">always @(posedge i_Clk)</samp>.
    In VHDL, however, we only put the signal name in the sensitivity list, and specify
    to watch for rising edges two lines later, with <samp class="SANS_TheSansMonoCd_W5Regular_11">if
    rising_edge(i_Clk) then</samp>.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 Verilog 中初始化一个被称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    的代码块，或者在 VHDL 中初始化一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    代码块❷。这种类型的代码块会在一个或多个信号发生变化时触发，具体由代码块的 *敏感列表* 指定，敏感列表会在声明代码块时放在括号中。在这种情况下，该代码块对时钟信号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> 敏感。具体来说，每当时钟从 0 变为
    1 时，这个代码块就会被触发，也就是说，在每个上升沿时触发。请记住，当你使用时钟来触发 FPGA 中的逻辑时，你几乎总是会使用时钟的上升沿。在 Verilog
    中，我们通过关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">posedge</samp>（即 *正沿*
    的缩写，另一个说法是 *上升沿*）在敏感列表中进行指示：<samp class="SANS_TheSansMonoCd_W5Regular_11">always
    @(posedge i_Clk)</samp>。然而，在 VHDL 中，我们只将信号名称放入敏感列表中，并在两行后指定观察上升沿，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if
    rising_edge(i_Clk) then</samp>。
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, we create the first
    flip-flop of this project by taking the input signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    and registering it into <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    ❸. This line of code will generate a flip-flop with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    on the D input, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    on the Q output, and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>
    going into the clock input. The output of this flip-flop will generate a one-clock-cycle
    delay of any changes to the input. This effectively gives us access to the previous
    state of the switch, which we need to know in order to detect the falling edge
    of the switch’s signal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内，我们通过将输入信号<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>注册到<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    ❸，创建了本项目的第一个触发器。此行代码将生成一个触发器，D输入为<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>，Q输出为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>，时钟输入为<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>。此触发器的输出将对输入的任何变化产生一个时钟周期的延迟。这实际上让我们可以访问开关的前一个状态，而我们需要知道这个状态来检测开关信号的下降沿。
- en: We next check to see if the switch has been released ❹. To do this, we compare
    the current state of the switch with its previous state, using the flip-flop we
    just created ❸. If the current state (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>)
    is 0 *and* the previous state (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>)
    is 1, then we’ve detected a falling edge, meaning the switch has been released.
    The *and* check will be accomplished with a LUT.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查开关是否已经释放 ❹。为此，我们将开关的当前状态与其前一个状态进行比较，使用我们刚刚创建的触发器 ❸。如果当前状态（<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>）为0，*并且*前一个状态（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>）为1，则表示我们检测到了下降沿，意味着开关已经释放。*并且*检查将通过查找表（LUT）来完成。
- en: At this point, perhaps you’ve noticed something surprising. First we assigned
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    ❸, then we checked if <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is 1
    ❹. You might think that since we just assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>, they’d always
    be equal, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    would never be true. Right? Wrong! Assignments in an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block that use
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> don’t occur immediately.
    Instead, they take place on each rising edge of the clock and therefore *are all
    executed at the same time*. If at a rising clock edge <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> is 1,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement will evaluate
    as true, even as <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>
    is simultaneously switching from a 1 to a 0 to match <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，也许你已经注意到了一些令人惊讶的地方。首先，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>赋值给了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> ❸，然后我们检查<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>是否为0且<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>为1 ❹。你可能会想，既然我们刚刚将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>赋值给了<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>，它们应该始终相等，那么<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句应该永远不会为真。对吧？错！在<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块中的赋值语句，如果使用的是<samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>，赋值并不会立即发生。相反，它们会在每个时钟上升沿时进行，因此*所有赋值同时执行*。如果在时钟上升沿时<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>为0且<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>为1，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句将被评估为真，即使<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>同时从1切换到0以匹配<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>。
- en: Now we’re thinking in parallel instead of serially! We’ve generated assignments
    that occur all at once, instead of one at a time. This is completely different
    from traditional programming languages like C and Python, where assignments occur
    one after the other. To further drive this point home, you could move the assignment
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp> to the last
    line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, and everything would
    still work the same. Formally, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment a *non-blocking assignment*, meaning it doesn’t prevent (“block”) other
    assignments from taking place at the same time. In [Chapter 10](chapter10.xhtml),
    we’ll revisit this concept and compare non-blocking assignments with blocking
    assignments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在并行思考，而不是串行思考！我们已经生成了同时发生的赋值，而不是逐个赋值。这与传统编程语言如 C 和 Python 完全不同，后者的赋值是一个接一个发生的。为了进一步说明这一点，你可以把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Switch_1</samp>的赋值移到<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块的最后一行，一切仍然会照常工作。从正式角度讲，我们称<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>赋值为*非阻塞赋值*，意味着它不会阻止（“阻塞”）其他赋值同时发生。在[第10章](chapter10.xhtml)中，我们将重新审视这一概念，并比较非阻塞赋值和阻塞赋值。
- en: Once we’re inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, we toggle the state of the LED ❺. Doing so generates the second flip-flop
    used in this project. We take the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>,
    invert it, and store the result back into the flip-flop. That might sound impossible,
    but it’s perfectly valid. The output of the flip-flop will pass through a LUT,
    acting here as a NOT gate, and then be fed back into the flip-flop’s input. This
    way, if the LED was on it’ll turn off, and vice versa.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句，我们就切换 LED 的状态
    ❺。这样就生成了该项目中使用的第二个触发器。我们获取<samp class="SANS_TheSansMonoCd_W5Regular_11">r_LED_1</samp>的当前值，将其反转，并将结果存回触发器中。这个听起来可能不可能，但它完全有效。触发器的输出将通过一个查找表（LUT），在这里充当反向门（NOT
    gate），然后反馈到触发器的输入端。这样，如果 LED 是亮的，它就会熄灭，反之亦然。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Constraints</samp>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加约束</samp>
- en: Once the code is ready, it’s time to run the tools to build the FPGA image and
    program your board. First, since this project uses a clock, you need to add a
    constraint telling the FPGA tool about the clock’s period. The clock period tells
    the timing tool how much time is available to route wires between flip-flops.
    As clock speed increases, it gets harder for the FPGA to *meet timing*, or achieve
    all the desired tasks within each clock cycle. For slower clocks, with frequencies
    on the order of tens of megahertz, you shouldn’t have any problems meeting timing.
    In general, it’s only when you deal with clocks that are faster than 100 MHz that
    you may start to run into timing issues.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码准备好，就该运行工具来构建 FPGA 镜像并编程你的开发板了。首先，由于这个项目使用了时钟，你需要添加一个约束，告诉 FPGA 工具时钟的周期。时钟周期告诉时序工具有多少时间可以在触发器之间布线。随着时钟速度的增加，FPGA
    要*满足时序要求*，即在每个时钟周期内完成所有任务，变得越来越困难。对于频率在数十兆赫兹数量级的较慢时钟，你不应该遇到时序问题。一般来说，只有当时钟速度超过
    100 MHz 时，才可能会开始遇到时序问题。
- en: 'The clock period will vary from one development board to another, and can be
    found in your board’s documentation. To tell Lattice iCEcube2 about the clock
    period, create a new text file with a *.sdc* file extension containing something
    like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟周期会因开发板不同而有所不同，可以在开发板的文档中找到。为了让 Lattice iCEcube2 知道时钟周期，创建一个新的文本文件，文件扩展名为
    *.sdc*，内容可以像下面这样：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a clock with a 40 ns period (25 MHz frequency) and assigns that
    constraint to the signal called <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>
    in your design. This constraint will work for the Go Board, as an example, but
    if your board has a different clock period, replace <samp class="SANS_TheSansMonoCd_W5Regular_11">40.00</samp>
    with the appropriate value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个周期为 40 纳秒（25 MHz频率）的时钟，并将该约束赋给设计中的信号<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>。这个约束适用于
    Go Board 作为示例，但如果你的开发板时钟周期不同，请将<samp class="SANS_TheSansMonoCd_W5Regular_11">40.00</samp>替换为适当的值。
- en: Right-click **Constraint Files** under **Synthesis Tool** and select the *.sdc*
    file to add it to your project in iCEcube2\. Remember from [Chapter 2](chapter2.xhtml)
    that we previously had a single *.pcf* constraint file telling the tools which
    signals to map to which pins. Now we have an additional constraint file just for
    the clock. Both are critical for getting your FPGA to work correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击**约束文件**，位于**综合工具**下，选择*.sdc*文件并将其添加到iCEcube2中的项目中。记住，在[第2章](chapter2.xhtml)中，我们之前有一个单一的*.pcf*约束文件，告诉工具将哪些信号映射到哪些引脚。现在，我们有了一个额外的专门用于时钟的约束文件。这两个文件对确保FPGA正常工作至关重要。
- en: 'We also need to update the *.pcf* file to include the pin corresponding to
    the new clock signal. On the Go Board, for example, the clock is connected to
    pin 15 of the FPGA, so you would need to add the following pin constraint:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新*.pcf*文件，加入与新时钟信号对应的引脚。例如，在Go Board上，时钟连接到FPGA的引脚15，因此您需要添加以下引脚约束：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Check the schematic for your development board to see which pin has the clock
    as an input, and replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>
    as appropriate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检查开发板的原理图，查看哪个引脚作为时钟输入，并根据需要替换<samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建和编程FPGA</samp>
- en: 'You’re now ready to run the build. When you do this, the tools will generate
    some reports. The synthesis report should look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好运行构建了。运行时，工具将生成一些报告。综合报告应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This report tells us that we’re using two register bits ❶, meaning our design
    includes two flip-flops. This is exactly what we expected. The report also shows
    that we’re using one LUT ❸. This single LUT will be able to perform both the AND
    and NOT operations required in the code. Notice, too, that the tools identified
    the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> as a clock
    ❷.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这份报告告诉我们，我们正在使用两个寄存器位❶，这意味着我们的设计包含两个触发器。这正是我们预期的。报告还显示我们使用了一个LUT❸。这个单一的LUT将能够执行代码中所需的与、非操作。还要注意，工具将信号<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>识别为时钟❷。
- en: 'Now let’s look at the place and route reports, which you can view in iCEcube2
    by going to **P&R Flow****Output Files****Reports**. There are two reports here.
    The first is a pin report, which tells you which signals were mapped to which
    pins. You can use this to confirm that your signals were mapped correctly. The
    second is the timing report. It has a section labeled “Clock Frequency Summary”
    that should look something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下布局和布线报告，您可以通过在iCEcube2中转到**P&R流程****输出文件****报告**来查看。这里有两个报告。第一个是引脚报告，它告诉您哪些信号被映射到哪些引脚。您可以用它来确认信号是否正确映射。第二个是时序报告。它有一个名为“时钟频率汇总”的部分，应该类似于下面的内容：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This section tells you if the constraint file was accepted correctly. Here we
    see that the tools have found our clock, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> property indicates
    the tools have recognized a 25 MHz constraint placed on the clock (your number
    will vary, depending on your development board), while the <samp class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp>
    property tells us the maximum frequency at which the FPGA could theoretically
    run our code successfully. In this case, we could run this FPGA at 654.05 MHz
    and it would still be guaranteed to work correctly. That’s quite fast! As long
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp> property
    is higher than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    property, you shouldn’t have any issues running your code. A problem would show
    up here in the form of a *timing error*, which happens when the target clock speed
    is greater than the frequency that the tools can achieve. In [Chapter 7](chapter7.xhtml),
    we’ll take a deeper look at what causes timing errors and how to fix them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节告诉你约束文件是否已正确接受。在这里，我们看到工具已经找到了我们的时钟，<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>属性表明工具已识别时钟上施加了25 MHz的约束（你的数字可能不同，具体取决于开发板），而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp>属性告诉我们FPGA理论上能够成功运行代码的最大频率。在这种情况下，我们可以将FPGA运行在654.05
    MHz下，并且仍然可以保证正确工作。真是相当快！只要<samp class="SANS_TheSansMonoCd_W5Regular_11">Frequency</samp>属性高于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>属性，你就不应当遇到任何问题。若目标时钟频率大于工具能够达到的频率，这里会出现*时序错误*。在[第7章](chapter7.xhtml)中，我们将更深入地探讨时序错误的原因以及如何修复它们。
- en: Now that you’ve successfully built the FPGA design, you can program your board
    and test the project. Try pushing the switch several times. You should see the
    LED toggle on or off each time the switch is released. Congratulations, you’ve
    got your first flip-flop working!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功构建了FPGA设计，可以编程并测试你的项目。尝试多次按下开关。每次开关释放时，你应该看到LED的状态切换。恭喜你，第一次触发器已经工作了！
- en: However, you may notice something strange going on. The LED may not appear to
    change its state with each release. You might think that the FPGA isn’t registering
    the releases of the switch, but in fact the LED is toggling two or more times
    with each release, so quickly that your eyes don’t see it. The cause is related
    to the physical workings of the switch itself. To solve this issue, the switch
    needs to be *debounced*. You’ll learn what this means and how to do it in the
    next chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会注意到一些奇怪的现象。LED的状态似乎没有随着每次开关释放而改变。你可能以为FPGA没有注册开关的释放信号，但实际上LED每次释放时都会迅速切换两次或更多次，以至于你的眼睛没有察觉到。其原因与开关本身的物理特性有关。为了解决这个问题，开关需要进行*去抖动*处理。你将在下一章中学习这是什么意思以及如何处理。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Combinational Logic vs. Sequential Logic</samp>
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">组合逻辑与时序逻辑</samp>
- en: 'There are two kinds of logic that can take place inside an FPGA: combinational
    logic and sequential logic. *Combinational logic* is logic for which the outputs
    are determined by the present inputs, with no memory of the previous state. This
    kind of logic is achieved with LUTs, which you’ll recall generate their output
    based only on their current inputs. *Sequential logic*, on the other hand, is
    logic for which the outputs are determined both by present inputs and previous
    outputs. Sequential logic is achieved with flip-flops, since flip-flops don’t
    immediately register changes on their inputs to their outputs, but rather wait
    until the rising edge of the clock to act on the new input data.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA内部有两种逻辑：组合逻辑和时序逻辑。*组合逻辑*是输出由当前输入决定的逻辑，不记忆先前的状态。这种逻辑通过LUT实现，正如你所记得，LUT仅根据当前输入生成输出。*时序逻辑*则不同，它的输出由当前输入和先前的输出共同决定。时序逻辑通过触发器实现，因为触发器不会立即将输入变化反映到输出，而是等到时钟的上升沿才对新的输入数据做出反应。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You may also see combinational logic and sequential logic referred to as*
    combinatorial logic *and* synchronous logic*, respectively.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能也会看到组合逻辑和时序逻辑分别被称作*组合逻辑*和*同步逻辑*。*'
- en: It might not be obvious that a flip-flop’s output depends on its previous output,
    so let’s explore an example to make this more concrete. Suppose the flip-flop
    is enabled, its input is low, its clock is low, and the output is low. Then suddenly
    the input goes high, then back low again quickly. What will the output do? Nothing!
    It stays low, since there was no clock edge to trigger a change. Now, what happens
    if that same flip-flop has the same initial conditions, except the output is high?
    In this case, of course, the output will stay high. But if we only looked at the
    inputs (D, En, and Clk), *we would be unable to predict the output state*. You
    need to know what the output of the flip-flop was (its previous state) to determine
    the flip-flop’s current state. That’s why a flip-flop is sequential.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不太明显的是，触发器的输出取决于其先前的输出，因此让我们通过一个例子来更具体地说明这个问题。假设触发器已启用，输入为低电平，时钟为低电平，输出为低电平。然后输入突然变为高电平，之后又迅速回到低电平。那么输出会发生什么呢？什么都不发生！它保持低电平，因为没有时钟边缘来触发状态变化。那么，如果该触发器具有相同的初始条件，但输出为高电平，会发生什么呢？当然，在这种情况下，输出将保持高电平。但是，如果我们只看输入（D、En
    和 Clk），*我们将无法预测输出的状态*。你需要知道触发器的输出是什么（它的先前状态），才能确定触发器的当前状态。这就是为什么触发器是顺序逻辑的原因。
- en: Knowing if your code is going to instantiate LUTs (combinational logic) or flip-flops
    (sequential logic) is critical to being a good FPGA designer, but sometimes it
    can be hard to tell the difference. In particular, an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block (in VHDL) can define a block of either combinational logic or sequential
    logic. We’ll consider examples of each to see how they differ.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你的代码是会实例化查找表（组合逻辑）还是触发器（顺序逻辑）对于成为一个优秀的 FPGA 设计师至关重要，但有时很难分辨二者的区别。特别是，一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 块（在 Verilog 中）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块（在 VHDL 中）可以定义一个组合逻辑或顺序逻辑的代码块。我们将考虑每种情况的示例，以查看它们的区别。
- en: 'First, here’s an example of a combinational implementation in Verilog and VHDL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里是一个在 Verilog 和 VHDL 中的组合逻辑实现示例：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we’ve created an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block with a sensitivity
    list (the signals in the parentheses) that includes two signals: <samp class="SANS_TheSansMonoCd_W5Regular_11">input_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">input_2</samp>. The code block
    performs an AND operation on the two signals.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个带有敏感列表（括号中的信号）的 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块，该敏感列表包括两个信号：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">input_1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">input_2</samp>。该代码块对这两个信号执行与操作。
- en: This block of Verilog or VHDL code will only generate LUTs; it won’t generate
    any flip-flops. For our purposes, flip-flops require a clock input, and there
    is no clock. Since no flip-flops are generated, this is combinational logic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Verilog 或 VHDL 代码只会生成查找表（LUT）；它不会生成任何触发器。对于我们的目的来说，触发器需要一个时钟输入，而这里没有时钟。由于没有生成触发器，因此这是组合逻辑。
- en: 'Now consider a slight modification to the examples just shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑对刚才展示的例子做一个轻微的修改：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code looks very similar to the previous examples, except now the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block’s sensitivity list has changed to be sensitive to the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp>.
    Since the block is sensitive to a clock, it’s now considered sequential logic.
    This block will actually still require a LUT to perform the AND operation, but
    in addition to that the output will utilize a flip-flop, since the clock is gating
    the output from updating all the time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与之前的示例非常相似，唯一的不同是现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块的敏感列表已经改变，变得对信号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Clk</samp> 敏感。由于该块对时钟敏感，它现在被认为是顺序逻辑。这个代码块实际上仍然需要一个
    LUT 来执行与操作，但除了这个之外，输出将会使用一个触发器，因为时钟在控制输出的更新频率。
- en: 'While all the examples in this section are valid code, I’m going to make a
    suggestion, especially for FPGA beginners: when writing your code, only create
    *sequential* <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> blocks
    (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks
    (in VHDL). The way to do this is to ensure that the block’s sensitivity list only
    has a clock in it. (A clock and a reset is OK too, as we’ll discuss later in the
    chapter.) Combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    blocks and <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks
    can get you into trouble: you can generate a latch by accident. We’ll explore
    latches in the next section, but basically, they’re bad. Additionally, I find
    code is more readable if you know that every time you come across an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, it
    will always be generating sequential logic.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节中的所有示例代码都是有效的，但我要特别给 FPGA 初学者一个建议：编写代码时，只创建*顺序*的 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    块（在 Verilog 中）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块（在
    VHDL 中）。做到这一点的方法是确保该块的灵敏度列表中只有时钟（时钟和复位也可以，我们将在本章后面讨论）。组合 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    块和 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块可能会导致问题：你可能会无意间生成锁存器。我们将在下一节中探讨锁存器，基本上，它们是坏的。此外，我发现，如果你知道每次遇到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 块或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块时，它总是生成顺序逻辑，代码会更加易读。
- en: As for combinational-only logic, write it outside of an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. In
    Verilog, the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp>
    is useful. In VHDL, you can simply use the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment to create combinational logic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅含组合逻辑的部分，应将其写在< sAmp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    块或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块之外。在 Verilog
    中，关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp> 很有用。在 VHDL 中，你可以简单地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> 赋值语句来创建组合逻辑。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Dangers of Latches</samp>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">锁存器的危险性</samp>
- en: A *latch* is a digital component that can store state without the use of a clock.
    In this way, latches perform a similar function as flip-flops (namely, storing
    state), but the method they use is different since there’s no clock involved.
    Latches are dangerous and can be inadvertently generated when working with combinational
    code. In my career, I’ve never once generated a latch *on purpose*, only by accident.
    It’s highly unlikely that you’d ever actually want to generate a latch either,
    so it’s important to understand how to avoid them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁存器* 是一种可以在不使用时钟的情况下存储状态的数字组件。通过这种方式，锁存器执行的功能与触发器相似（即存储状态），但它们使用的方法不同，因为没有涉及时钟。锁存器很危险，在处理组合逻辑代码时可能会不小心生成它们。在我的职业生涯中，我从未故意生成过锁存器，都是意外产生的。你也很不可能真的需要生成锁存器，因此了解如何避免它们是很重要的。'
- en: You always want your FPGA designs to be predictable. Latches are dangerous because
    they violate this principle. FPGA tools have a very difficult time understanding
    the timing relationship of a latch and how other components connected to it will
    perform. If you do manage to create a latch with your code, the FPGA tools will
    scream at you with warnings about the fact that you’ve done a horrible thing.
    Please don’t ignore these warnings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终希望你的 FPGA 设计是可预测的。锁存器之所以危险，是因为它们违背了这一原则。FPGA 工具在理解锁存器的时序关系以及连接到它的其他组件的表现时非常困难。如果你确实通过代码生成了锁存器，FPGA
    工具会用警告告诉你，你做了一个可怕的事情。请不要忽视这些警告。
- en: So how can this happen? A latch is created when you write a combinational <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block or conditional assignment
    (in VHDL) or a combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    block (in Verilog) with an *incomplete assignment*, meaning the output isn’t assigned
    under all possible input conditions. This is bad and should be avoided. [Table
    4-1](#tab4-1) shows an example of a truth table that would generate a latch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何会发生这种情况呢？当你编写一个组合型 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块或条件赋值（在 VHDL 中）或组合型 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    块（在 Verilog 中）时，如果进行 *不完全赋值*，即在所有可能的输入条件下输出没有被赋值，就会创建一个锁存器。这是错误的，应该避免。[表 4-1](#tab4-1)
    显示了一个会生成锁存器的真值表示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Truth Table That Creates a Latch</samp>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 4-1：</samp> <samp class="SANS_Futura_Std_Book_11">创建锁存器的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出 Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">Undefined</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">未定义</samp> |'
- en: 'This truth table has two inputs and one output. The output is 0 when both inputs
    are 0, and it’s 1 when input A is 0 and input B is 1, or when input A is 1 and
    input B is 0\. But what happens when both inputs are 1? We haven’t explicitly
    stated what will occur. In this case, the FPGA tools assume that the output should
    retain its previous state, much like a flip-flop is capable of doing, but without
    the use of a clock. For example, if the output is 0 and both inputs go high, the
    output will stay 0\. If the output is 1 and both inputs go high, the output will
    stay 1\. This is the behavior that a latch creates: the ability to store state
    without a clock.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个真值表有两个输入和一个输出。当两个输入都为 0 时，输出为 0；当输入 A 为 0 且输入 B 为 1，或者输入 A 为 1 且输入 B 为 0 时，输出为
    1。但是，当两个输入都为 1 时会发生什么呢？我们没有明确说明会发生什么情况。在这种情况下，FPGA 工具假设输出应保持其先前的状态，就像触发器能够做到的那样，但不使用时钟。例如，如果输出为
    0 且两个输入都变高，输出将保持为 0。如果输出为 1 且两个输入都变高，输出将保持为 1。这就是锁存器的行为：在没有时钟的情况下存储状态的能力。
- en: Let’s take a look at how this truth table could be created in Verilog and VHDL.
    Don’t write code like this!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何在 Verilog 和 VHDL 中创建这个真值表。不要像这样写代码！
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, our <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block is combinational
    because there’s no clock in the sensitivity list ❶ or the block itself, just two
    inputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>.
    We mimic the incomplete truth table assignment of the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    using conditional checks. Notice that we don’t explicitly check the condition
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>
    are both 1\. Big mistake!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的< samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或< samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块是组合式的，因为在灵敏度列表❶或块本身中没有时钟，只有两个输入，<
    samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp>和< samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>。我们通过条件检查模拟输出<
    samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>的不完全真值表赋值。请注意，我们没有显式地检查<
    samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp>和< samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>都为1的条件。大错误！
- en: 'If you were to try to synthesize this faulty code, the FPGA tools would generate
    a latch and warn you about it in the synthesis report. The warning would look
    something like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试合成这段有问题的代码，FPGA工具会生成一个锁存器，并在合成报告中给你警告。警告可能是这样的：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The tools are pretty good. They tell you that there’s a latch, they tell you
    which signal it is (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>),
    and they tell you why it might be occurring.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具非常好。它们会告诉你是否有锁存器，并告诉你是哪一个信号（<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>），还会告诉你为什么可能会发生这种情况。
- en: 'To avoid generating a latch, we could add an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement ❷, which will cover all remaining possibilities. As long as the output
    is defined for all possible inputs, we’ll be safe. An even better solution, however,
    would be not to use a combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block at all.
    I discourage the use of combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks precisely
    because it’s easy to make this mistake of omitting an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement. Instead, we can use a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. Here’s
    what that looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免生成锁存器，我们可以添加一个< samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>语句❷，它将覆盖所有剩余的可能性。只要对所有可能的输入定义了输出，我们就能确保安全。然而，一个更好的解决方案是根本不使用组合式<
    samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或< samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块。我不推荐使用组合式<
    samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或< samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块，正因为它容易犯下遗漏<
    samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>语句的错误。相反，我们可以使用顺序式< samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或< samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块。如下所示：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, because
    we’re using a clock in the sensitivity list ❶ and within the block itself. As
    a result, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> will create
    a flip-flop rather than a latch. Flip-flops don’t have the same unpredictable
    timing issues that latches do. Remember that the flip-flop can utilize its <samp
    class="SANS_TheSansMonoCd_W5Regular_11">en</samp> input to retain a value. The
    flip-flop’s <samp class="SANS_TheSansMonoCd_W5Regular_11">en</samp> input will
    be disabled when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp> are both high. This will
    retain the flip-flop’s output with whatever state it had previously, performing
    the same behavior as the latch, but in a safe, predictable way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个顺序的 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块，因为我们在敏感列表 ❶ 中以及块内部使用了时钟。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> 将创建一个触发器，而不是锁存器。触发器没有像锁存器那样不可预测的时序问题。记住，触发器可以利用其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">en</samp> 输入保持一个值。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp> 都为高时，触发器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">en</samp>
    输入将被禁用。这将使触发器保持其先前的输出状态，表现出与锁存器相同的行为，但以安全、可预测的方式进行。
- en: One side effect of switching to a sequential <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block is that
    it now takes a single clock cycle for the output to be updated. If it’s critical
    that this logic be combinational—with the output updating as soon as one of the
    inputs changes, with no clock delay—then you need to ensure that the output is
    specified for all possible input conditions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到顺序 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块的一个副作用是，现在输出更新需要一个完整的时钟周期。如果必须确保该逻辑是组合逻辑——即输出一旦某个输入变化就立即更新，且没有时钟延迟——那么你需要确保在所有可能的输入条件下都为输出指定值。
- en: 'There’s one other way to generate latches in VHDL. VHDL has the keyword <samp
    class="SANS_TheSansMonoCd_W5Regular_11">when</samp>, which can be used in a conditional
    assignment. Verilog has no equivalent syntax, so this code snippet is for VHDL
    only:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VHDL 中，还有一种生成锁存器的方式。VHDL 有一个关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">when</samp>，可以用于条件赋值。Verilog
    没有等效的语法，因此这段代码仅适用于 VHDL：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code exists outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block, and again we haven’t explicitly stated what <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    should be assigned to when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp> are both 1, so the
    FPGA tools will infer a latch here. The latch will enable the output to keep its
    previous state, but that’s likely not what we intended. Instead, we should be
    specific with our code and ensure that we have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    condition that sets <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> for
    all possible inputs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块之外，我们仍然没有明确声明当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_A</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_B</samp>
    都为 1 时 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> 应该赋值为什么，因此 FPGA
    工具将推断出一个锁存器。在这种情况下，锁存器将允许输出保持其先前的状态，但这可能不是我们想要的。相反，我们应该在代码中明确指定，并确保有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    条件来为所有可能的输入设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Resetting a Flip-Flop</samp>
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">重置触发器</samp>
- en: Flip-flops have an additional input that we haven’t discussed yet, called *set/reset*,
    or often just *reset*. This pin resets the flip-flop back to an initial state,
    which could be 0 or 1\. Resetting flip-flops is useful when the FPGA first powers
    up and initializes. For example, you might want to reset your flip-flops that
    control a state machine to the initial state (we’ll discuss state machines in
    [Chapter 8](chapter8.xhtml)). You might also want to reset a counter to some initial
    value, or reset a filter back to zero. Resetting flip-flops is one method to ensure
    your flip-flops are in a specific state prior to operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器有一个额外的输入，我们还没有讨论过，叫做 *set/reset*，或者通常只是 *reset*。这个引脚将触发器重置回初始状态，可能是 0 或 1。复位触发器在
    FPGA 上电初始化时非常有用。例如，你可能希望将控制状态机的触发器复位到初始状态（我们将在[第8章](chapter8.xhtml)讨论状态机）。你也可能希望将计数器复位为某个初始值，或者将滤波器复位为零。复位触发器是确保触发器在操作之前处于特定状态的一种方法。
- en: 'There are two types of resets: synchronous and asynchronous. *Synchronous resets*
    occur at the same time as the clock edge, whereas *asynchronous resets* can occur
    at any time. You might trigger an asynchronous reset with a button press external
    to the FPGA, for example, since the button press can come at any point in time.
    Let’s look at how to code a reset, starting with a synchronous one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 复位有两种类型：同步复位和异步复位。*同步复位*与时钟边缘同时发生，而 *异步复位* 可以在任何时间发生。你可能通过外部按钮按下触发异步复位，例如，因为按钮按下可以在任何时刻发生。让我们先从同步复位开始，看看如何编写复位代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we have an <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block with a normal
    sensitivity list; it’s only sensitive to changes of the clock ❶. Inside the block,
    we first check the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    ❷. If it’s high, then we reset the signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    to 1\. This is our synchronous reset, since it’s happening on the edge of the
    clock. If <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> is low,
    we proceed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch of the block ❸, where we’d write whatever code we want to be executed under
    normal operating (non-reset) conditions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个带有普通敏感度列表的 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块；它只对时钟变化敏感 ❶。在该块内部，我们首先检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 的状态 ❷。如果它为高电平，则将信号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> 重置为 1。这是我们的同步复位，因为它发生在时钟的边缘。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 为低电平，我们将继续执行该块的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 分支 ❸，在这里我们会编写在正常操作（非复位）条件下希望执行的代码。
- en: Notice that in this example we’re checking if the reset is high. Sometimes resets
    can be active low, however, which is usually indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">_L</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">_n</samp> at the end of the signal
    name. If this were an active low reset, we would check for the signal being 0
    rather than 1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，我们检查复位是否为高电平。有时复位是低电平有效的，通常通过信号名称末尾的 <samp class="SANS_TheSansMonoCd_W5Regular_11">_L</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">_n</samp> 来表示。如果这是一个低电平有效的复位，我们将检查信号是否为
    0，而不是 1。
- en: 'Now let’s take a look at an asynchronous reset:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个异步复位的例子：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we’ve added <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block’s sensitivity list
    ❶. Now, rather than checking the clock state first, we check the reset state first
    ❷. If it’s high, then we perform whatever reset conditions we want, in this case
    setting <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp> to 1\. Otherwise,
    we proceed normally ❸.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已将 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 添加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块的敏感度列表中 ❶。现在，我们首先检查复位状态 ❷，而不是时钟状态。如果复位为高电平，我们执行所需的复位条件，在这种情况下将 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Q</samp>
    设置为 1。否则，我们按正常流程执行 ❸。
- en: The choice between synchronous and asynchronous resets should be documented
    in the user guide for your specific FPGA—some FPGAs are optimized to handle one
    or the other. Additionally, resets can create strange bugs if they’re not treated
    properly. Therefore, I strongly recommend consulting the documentation to make
    sure you’re resetting flip-flops correctly for your device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于同步复位和异步复位的选择，应在你特定FPGA的用户指南中进行说明——某些FPGA优化了其中之一。此外，复位如果没有得到正确处理，可能会导致奇怪的错误。因此，我强烈建议查阅文档，确保你正确地为设备复位触发器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Look-Up Tables and Flip-Flops on a Real
    FPGA</samp>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">真实FPGA中的查找表和触发器</samp>
- en: Now you understand that LUTs and flip-flops exist on FPGAs, but they may still
    seem a bit abstract. To get a more concrete picture, let’s look at how LUTs and
    flip-flops are actually wired together in a real FPGA. The image in [Figure 4-10](#fig4-10)
    is taken from the datasheet for the Lattice iCE40 LP/HX family of FPGAs, the type
    of FPGA compatible with iCEcube2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你明白了LUT和触发器存在于FPGA中，但它们可能仍然显得有些抽象。为了更具体地了解它们的实际工作方式，让我们看看LUT和触发器是如何在真实FPGA中连接在一起的。图像来自[图4-10](#fig4-10)，取自Lattice
    iCE40 LP/HX系列FPGA的数据手册，这种FPGA与iCEcube2兼容。
- en: '*Datasheets* are used throughout the electronics industry to explain the details
    of how a component works. Each FPGA will have at least a few unique datasheets
    with different pieces of information, and more complicated FPGAs can have dozens
    of them.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据手册*被电子行业广泛用于解释组件的工作原理。每个FPGA至少有几本独特的数据手册，包含不同的信息，而更复杂的FPGA可能会有几十本。'
- en: '![](../images/Figure4-10.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: LUTs and flip-flops
    in a real FPGA</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-10：真实FPGA中的LUT和触发器</samp>
- en: Every FPGA, whether from Lattice, AMD, Intel, or whoever else, will have an
    image very similar to [Figure 4-10](#fig4-10) in its specific family datasheet.
    This particular image shows the basic building block of Lattice iCE40 FPGAs, which
    Lattice calls the *Programmable Logic Block (PLB)*. Each FPGA company has its
    own unique name for these basic building blocks; for example, AMD calls them *Configurable
    Logic Blocks (CLBs)*, while Intel uses *Adaptive Logic Modules (ALMs)*. We’ll
    look at the details of how the PLB from Lattice works as an example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个FPGA，无论是Lattice、AMD、Intel还是其他公司，都会在其特定系列的数据手册中包含类似于[图4-10](#fig4-10)的图像。这个特定的图像展示了Lattice
    iCE40 FPGA的基本构建块，Lattice称之为*可编程逻辑块（PLB）*。每个FPGA公司都有自己独特的名称来描述这些基本构建块；例如，AMD称其为*可配置逻辑块（CLB）*，而Intel则使用*自适应逻辑模块（ALM）*。我们将以Lattice的PLB为例，详细了解其工作原理。
- en: Looking at the left side of the image, we see there are eight logic cells in
    each PLB. The right side shows a zoomed-in version of a single logic cell. Inside
    it, notice that there’s a rectangle labeled LUT4\. This is a four-input look-up
    table! There’s also a dark gray box labeled DFF. This is a D flip-flop! The LUT
    and the flip-flop truly are the two most critical components inside an FPGA.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像的左侧来看，我们看到每个PLB中有八个逻辑单元。右侧显示的是单个逻辑单元的放大版本。在其中，注意到有一个矩形框标有LUT4\。这就是一个四输入查找表！还有一个深灰色的框，标有DFF。这是一个D触发器！LUT和触发器确实是FPGA内部最关键的两个组件。
- en: This diagram is telling us that at the most fundamental level there’s one LUT
    and one flip-flop inside each logic cell, and there are eight logic cells in a
    PLB. The PLB is copy-pasted hundreds or thousands of times inside the FPGA to
    provide enough LUTs and flip-flops to do all the required work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表告诉我们，在最基本的层面上，每个逻辑单元中都有一个查找表（LUT）和一个触发器（flip-flop），而一个PLB中包含八个逻辑单元。PLB在FPGA内部被复制粘贴成百上千次，以提供足够的LUT和触发器来完成所有必要的工作。
- en: 'On the left side of the DFF component (the flip-flop), notice the same three
    inputs we originally saw in [Figure 4-1](#fig4-1): data (D), clock enable (EN),
    and clock (>). The fourth input at the bottom of the component is the set/reset
    (SR) input we discussed in the previous section.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在DFF组件（触发器）的左侧，注意到我们在[图4-1](#fig4-1)中看到的三个输入：数据（D）、时钟使能（EN）和时钟（>）。组件底部的第四个输入是我们在前一节中讨论过的设置/复位（SR）输入。
- en: As you’ve seen, the clock enable input allows the flip-flop to keep its output
    state for multiple clock cycles. Without the En input, the output would just follow
    the input with one clock cycle of delay. Adding the En input lets the flip-flop
    store a state for a longer duration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，时钟使能输入允许触发器在多个时钟周期中保持其输出状态。如果没有En输入，输出将仅跟随输入，并且有一个时钟周期的延迟。添加En输入后，触发器可以存储一个状态更长的时间。
- en: The last thing to notice in the diagram is the carry logic block, shown above
    and to the left of the LUT4\. This block is mostly used to speed up arithmetic
    functions, such as addition, subtraction, and comparison.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示中最后需要注意的是进位逻辑块，它位于LUT4的上方和左侧。这个块主要用于加速算术运算，如加法、减法和比较。
- en: While reviewing this diagram gave us an interesting look inside an FPGA and
    highlighted the central role of the LUT and the flip-flop, it isn’t critical to
    memorize every detail of the PLB’s architecture. You don’t need to remember all
    the connections and how each is wired to its neighbor. In the real world, you
    write your Verilog or VHDL, and the FPGA tools take care of mapping that code
    onto the FPGA’s resources. This is particularly useful if you want to switch from
    one type of FPGA to another (say, from a Lattice to an AMD). The beauty of Verilog
    and VHDL is that the code is generally portable; the same code works on different
    FPGAs, provided they have enough LUTs and flip-flops to do what you want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然回顾这个图示让我们对FPGA内部有了一个有趣的了解，并突出了LUT和触发器的核心作用，但记住PLB架构的每一个细节并不是至关重要的。你不需要记住所有的连接以及它们如何与邻居连接。在实际应用中，你编写Verilog或VHDL代码，而FPGA工具会处理将代码映射到FPGA资源上的工作。如果你想从一种FPGA切换到另一种（比如从Lattice切换到AMD），这点尤其有用。Verilog和VHDL的优点在于代码通常是可移植的；相同的代码可以在不同的FPGA上运行，只要它们有足够的LUT和触发器来满足你的需求。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned about the flip-flop, which, along with the LUT,
    is one of the two most important components in an FPGA. You saw how flip-flops
    allow FPGAs to keep state, or remember past values, by only registering data from
    the input to the output on the positive edges of a clock signal. You learned how
    logic driven by flip-flops and clock signals is sequential, in contrast to the
    combinational logic of LUTs, and you got your first glimpse of how flip-flops
    and LUTs work together through a project toggling an LED. You also learned how
    to avoid generating latches and how to reset a flip-flop to a default state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了触发器，它与LUT一起，是FPGA中最重要的两个组件之一。你看到触发器如何通过仅在时钟信号的正边沿注册输入到输出的数据，让FPGA保持状态或记住过去的值。你了解了由触发器和时钟信号驱动的逻辑是顺序逻辑，这与LUT的组合逻辑不同，并且你通过一个切换LED的项目首次了解了触发器和LUT如何协同工作。你还学习了如何避免生成锁存器以及如何将触发器重置为默认状态。
- en: In future chapters, as you build more complex blocks of code, you’ll become
    more familiar with how flip-flops and LUTs interact and see how you can use just
    these two kinds of components to create large, sophisticated FPGA designs. You’ll
    also see the role flip-flops play in keeping track of counters and state machines.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，当你构建更复杂的代码模块时，你将更加熟悉触发器和查找表（LUT）如何相互作用，并且你会看到如何仅通过这两种组件来创建大型、复杂的FPGA设计。你还会看到触发器在跟踪计数器和状态机中的作用。
