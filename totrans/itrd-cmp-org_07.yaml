- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SEQUENTIAL LOGIC CIRCUITS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, you learned about combinational logic circuits, which
    are circuits that depend only on their current input. Another way of thinking
    about this is that combinational logic circuits are instantaneous (except for
    the time required for the electronics to settle): their output depends only on
    the input at the time the output is observed. *Sequential logic circuits*, on
    the other hand, depend on both the current and past inputs. They have a time history,
    which can be summarized by the current state of the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: Formally, the *system state* is a description of the system such that the state
    at time *t*[0] and the inputs from time *t*[0] through time *t*[1] uniquely determines
    the state at time *t*[1] and the outputs from time *t*[0] through time *t*[1].
    In other words, the system state provides a summary of everything that has affected
    the system. Knowing the state of a system at any given time *t* tells you everything
    you need to know to specify the system’s behavior from that time on. How it got
    into that state is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of system state is captured in a *finite state machine*, a mathematical
    model of computation that exists in any one of a finite number of states. External
    inputs to a finite state machine cause it to transition from one state to another
    or to the same state, while possibly producing an output. Sequential logic circuits
    are used to implement finite state machines. If a sequential logic circuit is
    designed such that its output depends only on the state it’s in, it’s called a
    *Moore state machine*. If the output also depends on the input causing a transition
    to a state, it’s called a *Mealy state machine*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how *feedback* is used in a logic circuit to keep
    the gates in a particular state over time, thus implementing memory. We’ll use
    *state diagrams* to show how inputs cause a sequential logic circuit to transition
    between states and what the corresponding outputs are. You’ll also learn how sequential
    logic circuits can be synchronized with a clock to provide reliable results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Latches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first sequential logic circuit we’ll look at is a *latch*, a 1-bit storage
    device that can be in one of two states, depending on its input. A latch can be
    constructed by connecting two or more logic gates such that the output from one
    gate feeds into the input of another gate; this keeps the output of both gates
    in the same state as long as power is applied. The state of a latch does not depend
    on time. (The term *latch* is also used for a multiple-bit storage device that
    behaves like the 1-bit device described here.)
  prefs: []
  type: TYPE_NORMAL
- en: '***SR Latch Using NOR Gates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most basic latch is the *Set–Reset (SR)* latch. It has two inputs, *S* and
    *R*, and two states, *set* and *reset*. The state is used as the primary output,
    *Q*. It’s common to also provide the complemented output, ¬*Q*. The SR latch is
    said to be in the set state when the outputs are *Q* = `1` and ¬*Q* = `0`. It’s
    in the reset state when *Q* = `0` and ¬*Q* = `1`. [Figure 7-1](ch07.xhtml#ch7fig1)
    shows a simple implementation of an SR latch using NOR gates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg156_Image_206.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: A NOR gate implementation of an SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: The output of each NOR gate is fed into the input of the other. As I describe
    the behavior of the circuit in this chapter, you’ll see that this feedback is
    what keeps the latch in one state.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four possible input combinations for an SR latch, as detailed in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '***S*** **=** 0**,** ***R*** **=** 0**: Keep current state**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state (*Q* = `1` and ¬*Q* = `0`), an input of *S*
    = `0` and *R* = `0` will cause ¬*Q*, the output of the upper NOR gate, to yield
    ¬(`0` ∨ `1`) = `0` and *Q*, the output of the lower NOR gate, to yield ¬(`0` ∨
    `0`) = `1`. Conversely, if the latch is in the reset state (*Q* = `0` and ¬*Q*
    = `1`), then the output of the upper NOR gate yields ¬(`0` ∨ `0`) = `1`, and the
    lower NOR gate yields ¬(`1` ∨ `0`) = `0`. Thus, the cross-feedback between the
    two NOR gates maintains the current state of the latch.
  prefs: []
  type: TYPE_NORMAL
- en: '***S*** **=** 1**,** ***R*** **=** 0**: Set (*****Q*** **=** 1**)**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the reset state, these inputs cause the output of the upper
    NOR gate to be ¬(`1` ∨ `0`) = `0`, thus changing ¬*Q* to `0`. This is fed back
    to the input of the lower NOR gate to yield ¬(`0` ∨ `0`) = `1`. The feedback from
    the output of the lower NOR gate to the input of the upper NOR gate keeps the
    output of the upper gate at ¬(`1` ∨ `1`) = `0`. The latch has then moved into
    the set state (*Q* = `1` and ¬*Q* = `0`).
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state, the upper NOR gate yields ¬(`1` ∨ `1`) = `0`
    and the output of the lower NOR gate is ¬(`0` ∨ `0`) = `1`. The latch thus remains
    in the set state.
  prefs: []
  type: TYPE_NORMAL
- en: '***S*** **=** 0**,** ***R*** **=** 1**: Reset (*****Q*** **=** 0**)**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state, the lower NOR gate yields ¬(`0` ∨ `1`) = `0`,
    thus changing *Q* to be `0`. This is fed back to the input of the upper NOR gate
    to yield ¬(`0` ∨ `0`) = `1`. The feedback from the output of the upper NOR gate
    to the input of the lower NOR gate keeps the output of the lower gate at ¬(`1`
    ∨ `1`) = `0`. The latch has then moved into the reset state (*Q* = `0` and ¬*Q*
    = `1`).
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is already in the reset state, the lower NOR gate yields ¬(`1`
    ∨ `1`) = `0` and the output of the upper NOR gate is ¬(`0` ∨ `0`) = `1`, so the
    latch remains in the reset state.
  prefs: []
  type: TYPE_NORMAL
- en: '***S*** **=** 1**,** ***R*** **=** 1**: Not allowed**'
  prefs: []
  type: TYPE_NORMAL
- en: If *Q* = `0` and ¬*Q* = `1`, the upper NOR gate yields ¬(`1` ∨ `0`) = `0`. This
    is fed back to the input of the lower NOR gate to yield ¬(`0` ∨ `1`) = `0`. This
    would give *Q* = ¬*Q*, which is inconsistent with the laws of Boolean algebra.
  prefs: []
  type: TYPE_NORMAL
- en: If *Q* = `1` and ¬*Q* = `0`, the lower NOR gate yields ¬(`0` ∨ `1`) = `0`. This
    is fed back to the input of the upper NOR gate to yield ¬(`1` ∨ `0`) = `0`. This
    would also give *Q* = ¬*Q*, which is inconsistent. Circuits must be designed to
    prevent this input combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, we can represent this logic visually. [Figure 7-2](ch07.xhtml#ch7fig2)
    introduces a graphic way to show the behavior of a NOR gate SR latch: the state
    diagram. In this figure, the current state is shown in the bubbles and the corresponding
    primary output is below the state. The lines with arrows show the possible transitions
    between the states and are labeled with the inputs that cause the transition to
    the next state.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg158_Image_207.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: A state diagram for a NOR gate SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two circles in [Figure 7-2](ch07.xhtml#ch7fig2) show the two possible states
    of the SR latch: set or reset. The labels on the lines show the combination of
    inputs, *SR*, that causes each state transition. For example, when the latch is
    in the reset state, there are two possible inputs, *SR* = `00` and *SR* = `01`,
    that cause it to remain in that state. The input *SR* = `10` causes it to transition
    to the set state. Since the output is dependent only on the state—and not on the
    input—a latch is a Moore state machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Those familiar with graph theory will recognize that a state diagram is a directed
    graph: the states are the vertices and the inputs that cause transitions are the
    edges. Although they are beyond the scope of this book, tools from graph theory
    can be useful in the design process.'
  prefs: []
  type: TYPE_NORMAL
- en: As in graph theory, we can also show the same behavior in a tabular form using
    a *state transition table*, as shown in [Table 7-1](ch07.xhtml#ch7tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** A NOR Gate SR Latch State Transition Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***S*** | ***R*** | ***Q*** | ***Q***[***next***] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | x |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | x |'
  prefs: []
  type: TYPE_TB
- en: In [Table 7-1](ch07.xhtml#ch7tab1), *S* and *R* are the inputs, *Q* is the output
    in the current state, and *Q[next]* shows the output in the state that results
    from the corresponding input. The x in the bottom two rows indicates an impossible
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Both inputs to a NOR gate SR latch are normally held at `0`, which maintains
    the current state, giving the output *Q*. Momentarily changing only *R* to `1`
    causes the state to go to reset, which changes the output to *Q* = `0`, as shown
    in the *Q[next]* column of the state transition table. Momentarily changing only
    *S* to `1` causes the state to go to set, giving the output *Q* = `1`.
  prefs: []
  type: TYPE_NORMAL
- en: As described earlier, the input combination *S* = *R* = `1` is not allowed because
    that would cause an inconsistent state for the SR latch, as indicated in the prohibited
    rows of the state transition table by an x in the *Q[next]* column.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***SR Latch Using NAND Gates***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The physics of their construction tends to make NAND gates faster than NOR
    gates. Let’s start with the equation for the output of a NOR gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg159_Image_208.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From De Morgan’s law, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg159_Image_209.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows that a NAND gate is functionally equivalent to a NOR gate if we complement
    the two inputs, except that the output is complemented.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to the circuit shown in [Figure 7-3](ch07.xhtml#ch7fig3), with ¬*S*
    and ¬*R* as the inputs. To emphasize the logical duality of the two designs, NAND
    and NOR, I have drawn the circuit with the output *Q* at the top and ¬*Q* on the
    bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg159_Image_210.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: A NAND gate implementation of an SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the NOR gate SR latch, the NAND gate SR latch is said to be in the set
    state when the outputs are *Q* = `1` and ¬*Q* = `0`; it’s in the reset state when
    *Q* = `0` and ¬*Q* = `1`. There are four possible input combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '¬***S*** **=** 1**,** ¬***R*** **=** 1**: Keep current state**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state (*Q* = `1` and ¬*Q* = `0`), the upper NAND
    gate yields ¬(`1` ∧ `0`) = `1`, and the lower NAND gate yields ¬(`1` ∧ `1`) =
    `0`. If *Q* = `0` and ¬*Q* = `1`, the latch is in the reset state; the upper NAND
    gate yields ¬(`1` ∧ `1`) = `0`, and the lower NAND gate yields ¬(`0` ∧ `1`) =
    `1`. The cross feedback between the two NAND gates maintains the state of the
    latch.
  prefs: []
  type: TYPE_NORMAL
- en: '¬***S*** **=** 0**,** ¬***R*** **=** 1**: Set (*****Q*** **=** 1**)**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the reset state, the upper NAND gate yields ¬(`0` ∧ `1`)
    = `1`, thus changing *Q* to be `1`. This is fed back to the input of the lower
    NAND gate to yield ¬(`1` ∧ `1`) = `0`. The feedback from the output of the lower
    NAND gate to the input of the upper NAND gate keeps the output of the upper gate
    at ¬(`0` ∧ `0`) = `1`. The latch has moved into the set state (*Q* = `1` and ¬*Q*
    = `0`).
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is already in the set state, then the upper NAND gate yields ¬(`0`
    ∧ *mathtt*0) = `1`, and the output of the lower NAND gate is ¬(`1` ∧ `1`) = `0`.
    The latch thus remains in the set state.
  prefs: []
  type: TYPE_NORMAL
- en: '¬***S*** **=** 1**,** ¬***R*** **=** 0**: Reset (*****Q*** **=** 0**)**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state, the lower NAND gate yields ¬(`1` ∧ `0`) =
    `1`. This is fed back to the input of the upper NAND gate, thereby making *Q*
    = ¬(`1` ∧ `1`) = `0`. The feedback from the output of the upper NAND gate to the
    input of the lower NAND gate keeps the output of the lower gate at ¬(`0` ∧ `0`)
    = `1`, so the latch moves into the reset state (*Q* = `0` and ¬*Q* = `1`).
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is already in the reset state, the lower NAND gate yields ¬(`0`
    ∧ `0`) = `1`, and the output of the upper NAND gate is ¬(`1` ∧ `1`) = `0`. The
    latch remains in the reset state.
  prefs: []
  type: TYPE_NORMAL
- en: '¬***S*** **=** 0**,** ¬***R*** **=** 0**: Not allowed**'
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the reset state, the upper NAND gate yields ¬(`0` ∧ `1`)
    = `1`. This is fed back to the input of the lower NAND gate to yield ¬(`1` ∧ `0`)
    = `1`. This would give *Q* = ¬*Q*, which is inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: If the latch is in the set state, the lower NAND gate yields ¬(`1` ∧ `0`) =
    `1`. This is fed back to the input of the upper NAND gate to yield ¬(`0` ∧ `1`)
    = `1`. This would also give *Q* = ¬*Q*, which is inconsistent. Circuits must be
    designed to prevent this input combination.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](ch07.xhtml#ch7fig4) shows the behavior of a NAND gate SR latch
    using a state diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg160_Image_211.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A NAND gate SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this with the NOR gate SR latch in [Figure 7-2](ch07.xhtml#ch7fig2),
    you can see that they both describe the same behavior. For example, an input of
    *SR* = `10` to the NOR gate SR latch will place it in the set state, while an
    input of
  prefs: []
  type: TYPE_NORMAL
- en: ¬*S¬R* = `01` to the NAND gate SR latch will place it in the set state. I find
    that I have to think carefully about this when analyzing circuits. An off-by-one
    error when there are only two choices can cause behavior opposite to what I want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-2](ch07.xhtml#ch7tab2) is a state transition table for a NAND gate
    SR latch.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** A NAND Gate SR Latch State Transition Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***¬******S*** | ***¬******R*** | ***Q*** | ***Q****[next]*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | x |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | x |'
  prefs: []
  type: TYPE_TB
- en: Placing `0` on both inputs at the same time causes a problem—namely, that the
    outputs of both NAND gates would become `1`. In other words, *Q* = ¬*Q* = `1`,
    which is logically impossible. The circuit design must prevent this input combination.
    The x in the bottom two rows indicates an impossible condition.
  prefs: []
  type: TYPE_NORMAL
- en: The SR latch implemented with two NAND gates can be thought of as the complement
    of the NOR gate SR latch. The state is maintained by holding both ¬*S* and ¬*R*
    at `1`. Momentarily changing ¬*S* to `0` causes the state to be set with the output
    *Q* = `1`, and setting ¬*R* = `0` causes it to be reset with the output *Q* =
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have been looking at a single latch. The problem here is that the
    state of the latch, and its output, will change whenever the input changes. In
    a computer, it would be interconnected with many other devices, each changing
    state with new inputs. It takes time for each device to change state and for its
    output(s) to propagate to the next device(s). The precise timing depends on slight
    manufacturing differences in the devices, so the results can be unreliable. We
    need a means for synchronizing the activity to bring some order to the operations.
    We’ll start by adding an *Enable* input to the SR latch, which will allow us to
    control more precisely when the inputs will be allowed to affect the state.
  prefs: []
  type: TYPE_NORMAL
- en: '***SR Latch with Enable***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can get better control over the SR latch by adding two NAND gates to provide
    an *Enable* input. Connecting the outputs of these two NAND gates to the inputs
    of a ¬*S¬R* latch gives us a *gated SR latch*, as depicted in [Figure 7-5](ch07.xhtml#ch7fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg161_Image_212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: A gated SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: In this circuit, the outputs of both the control NAND gates remain at `1` as
    long as *Enable* = `0`. This sends ¬*S* = `1` and ¬*R* = `1` to the inputs of
    the ¬*S¬R* latch portion of this circuit, which causes the state to remain the
    same. By AND-ing the additional *Enable* input with the *S* and *R* input lines,
    we can control the time when the state should be changed to the next value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-3](ch07.xhtml#ch7tab3) shows the state behavior of the SR latch with
    the *Enable* control.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** A Gated SR Latch State Transition Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***Enable*** | ***S*** | ***R*** | ***Q*** | ***Q****[next]*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | — | — | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | — | — | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `0` | x |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | x |'
  prefs: []
  type: TYPE_TB
- en: In [Table 7-3](ch07.xhtml#ch7tab3), a — indicates that an input does not matter
    and an x indicates a prohibited result. As explained earlier, the design must
    prevent input combinations that would produce prohibited results. The state of
    the latch can follow the *S* and *R* inputs only when *Enable* = `1`. Such a device
    is said to be *level-triggered*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll simplify the gated SR latch and create a latch that
    takes a single data input, *D*, with control over when this input will affect
    the state of the latch.
  prefs: []
  type: TYPE_NORMAL
- en: '***The D Latch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *D latch* allows us to store the value of 1 bit. We start with the truth table
    in [Table 7-4](ch07.xhtml#ch7tab4), which includes the rows from [Table 7-3](ch07.xhtml#ch7tab3)
    where *Enable* = `1` and *R* = ¬*S*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-4:** A Truth Table for a D Latch with *Enable*'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***Enable*** | ***S*** | ***R*** | ***D*** | ***Q*** | ***Q****[next]***
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | — | — | — | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | — | — | — | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `0` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: 'We’re looking for a design that will have two inputs: one for *Enable* and
    the other for *D* (short for data). We want *D* = `1` to set the state, giving
    the output *Q* = `1`, and *D* = `0` to reset it, giving the output *Q* = `0`,
    when the *Enable* line becomes `1`. The value of *D* should have no effect on
    the state when *Enable* = `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can construct a gated D latch from a gated SR latch by adding a NOT gate,
    as shown in [Figure 7-6](ch07.xhtml#ch7fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg163_Image_213.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: A gated D latch constructed from an SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: The one data input, *D*, is fed to the *S* side of the SR latch; the complement
    of the data value is fed to the *R* side.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a circuit that can store 1 bit of data using the *D* input and
    can be synchronized with other operations using the *Enable* input. However, there
    are some problems with the D latch. The state of a D latch can be affected by
    the input while the D latch is enabled. Thus, its output can change while the
    latch is enabled, making it difficult to synchronize reliably with other devices.
  prefs: []
  type: TYPE_NORMAL
- en: This scheme does work well when the latch should remain in one state for an
    extended period. In general, latches work for operations where we want to select
    a state and leave it for a period of time that is not synchronized with other
    operations in the computer. An example is an I/O port, where the timing is dependent
    on the behavior of the device connected to the port. For instance, a running program
    cannot know when the user will press a key on the keyboard. When a key is pressed,
    the program may not be ready for the character, so the binary code for the character
    should be latched at the input port. Once the character code is stored at the
    input port, the latch will be disabled until the program reads the character code
    from the latch.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the computing operations within the CPU and main memory must be coordinated
    in time. Connecting many circuits to the same clock signal allows us to synchronize
    their operations. Let’s consider how we might synchronize a D latch connected
    in a circuit. We could feed an input to this D latch and enable the latch with
    a clock signal, but its output can change if the input changes, making its output
    unreliable during the time it’s enabled. If the output from our D latch is connected
    to the input of another device, the input to this second device is thus unreliable
    while our D latch is enabled. To avoid this problem and provide a reliable input,
    we should disable our D latch once it has settled.
  prefs: []
  type: TYPE_NORMAL
- en: It also takes some time, called *propagation delay*, for the output of our D
    latch to reach the input of the second device, due to the physics of the connections.
    So, this second device should be disabled until the input to our D latch is reliable
    and we have allowed for the propagation delay.
  prefs: []
  type: TYPE_NORMAL
- en: While the second device is disabled and waiting for a reliable input from our
    D latch, its output (from the previous clock cycle) is reliable. So, if it’s connected
    to the input of yet another device, this third device can be enabled. This leads
    to a scheme where every other device is enabled, while the alternate devices are
    disabled. After waiting for a period equal to the sum of the longest settling
    time and propagation delay time of all the devices connected together, the disabled
    devices are enabled and the enabled devices are disabled. The digital `1`s and
    `0`s are propagated through this circuit of devices by means of this alternating
    enable/disable cycle.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably imagine, coordinating this flipping back and forth between
    enabled and disabled can be difficult. I’ll give you a solution to this problem
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flip-Flops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While a latch could be controlled by the levels of a clock signal, its output
    would be affected by any changes in its input during the portion of time when
    the clock signal enables the latch. A *flip-flop* provides an output at a specific
    time in the clock cycle, such as when the clock signal transitions from `0` to
    `1`. Because the output becomes available at a clock signal transition point,
    it is said to be *edge triggered*. After the trigger event, the output of a flip-flop
    remains throughout the duration of the clock cycle. This provides the reliability
    needed to connect many flip-flops in a circuit and synchronize their operations
    with one clock. I’ll start this section with a discussion of clocks, and then
    we’ll look at a few examples of flip-flops.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The terminology varies. Some people also call latches* flip-flops*. I will
    use the term* latch *to mean a level-triggered device, with no timing considerations,
    and* flip-flop *to mean an edge-triggered device controlled by a clock signal.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Clocks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sequential logic circuits have a time history, summarized in their state. We
    keep track of time with a *clock*, a device that provides an electronic *clock
    signal*. This is typically a square wave that alternates between the `0` and `1`
    levels, as shown in [Figure 7-7](ch07.xhtml#ch7fig7). This signal is used as the
    enabling/disabling input to devices that need to be synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg164_Image_214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: A typical clock signal used to synchronize sequential logic circuits*'
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve reliable behavior, most synchronous circuits use edge-triggered
    devices. The amount of time spent at each level is usually the same, and either
    the positive-going (`0` to `1`) or negative-going (`1` to `0`) edge of a clock
    signal may be used.
  prefs: []
  type: TYPE_NORMAL
- en: The clock frequency must be slow enough that the circuit elements have time
    to complete their operations before the next clock transition occurs. For example,
    reliable operation of a latch or flip-flop requires that the input signal be stable
    for a period of time, called the *setup time*, before the device is enabled. The
    input signal must remain stable for another period of time, the *hold time*, after
    the start of the enabling signal. In practice, these times can vary with temperature,
    manufacturing variations, and so forth. Hardware designers need to consult manufacturers’
    specifications for the limits of these time values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few examples of flip-flop circuits that can be controlled by
    a clock.
  prefs: []
  type: TYPE_NORMAL
- en: '***D Flip-Flop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin by connecting a clock signal to the *Enable* input of the gated
    D latch in [Figure 7-6](ch07.xhtml#ch7fig6). Here, the input affects the output
    as long as *Enable* = `1`. The problem is that if the input changes while *Enable*
    = `1`, the output will also change, leading to an unreliable design.
  prefs: []
  type: TYPE_NORMAL
- en: One way to isolate the output from input changes is to connect the outputs of
    our D latch to the inputs of an SR latch in a primary/secondary configuration,
    as shown in [Figure 7-8](ch07.xhtml#ch7fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg165_Image_215.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: A D flip-flop, positive-edge triggering*'
  prefs: []
  type: TYPE_NORMAL
- en: The primary portion of the D flip-flop processes the input and provides a reliable
    input to the secondary portion for final output. The bit we want to store, `0`
    or `1`, is fed to the *D* input of the D latch, and the clock signal is fed to
    the *CLK* input. The uncomplemented output of the D latch is fed to the *S* input,
    and its complemented output is fed to the *R* input of the SR latch. The final
    output of the D flip-flop is the output from the SR latch.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll walk you through how this circuit works. The behavior of the primary portion
    is shown in the truth table for a D latch in [Table 7-4](ch07.xhtml#ch7tab4).
    The behavior of the secondary portion is shown in the truth table for an SR latch
    in [Table 7-3](ch07.xhtml#ch7tab3). [Figure 7-9](ch07.xhtml#ch7fig9) shows the
    timing of the key points in our D flip-flop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg166_Image_216.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: The timing of a D flip-flop*'
  prefs: []
  type: TYPE_NORMAL
- en: The data input, *D*, in [Figure 7-9](ch07.xhtml#ch7fig9) is not in complete
    synchrony with the clock signal, and its timing is somewhat irregular. This can
    occur due to propagation delays, interference from other components, temperature
    gradients in the circuits, and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start at the point where CLK first goes to `0`. This signal is inverted,
    which enables the D latch. The output of the D latch, *S*, follows the *D* input,
    going from `0` to `1`. The second inverter in the CLK path to the SR latch disables
    it, latching the flip-flop output, *Q*, at the `0` level.
  prefs: []
  type: TYPE_NORMAL
- en: When the CLK signal goes to `1`, the D latch is disabled, which latches its
    outputs, *S* and *R*, at `1` and `0`. This presents stable inputs to the SR latch
    during this clock half-cycle. The twice-inverted CLK signal enables the SR latch,
    which causes the output of the flip-flop, *Q*, to go to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The CLK signal then goes to `0`, disabling the SR latch in the secondary portion,
    which remains latched at the `1` level for this clock half-cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the flip-flop introduces a time delay of one-half clock cycle between
    accepting an input and providing an output, but the output is stable for an entire
    clock period. The output is available at a precise point in time, the `0` to `1`
    transition. This is called *positive-edge triggering*. If the first NOT gate connected
    to the CLK signal in [Figure 7-8](ch07.xhtml#ch7fig8) were removed, we would have
    a D flip-flop with *negative-edge triggering*.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a flip-flop must be set to a known value before the clocking begins—for
    example, when a computer is first starting up. These known values are input independently
    of the clock process; hence, they are *asynchronous inputs*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-10](ch07.xhtml#ch7fig10) shows a D flip-flop with an *asynchronous
    preset* (*PR*) input added to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_217.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: A positive-edge triggering D flip-flop with an asynchronous preset*'
  prefs: []
  type: TYPE_NORMAL
- en: When a `1` is applied to the *PR* input, *Q* becomes `1` and ¬*Q* becomes `0`,
    regardless of what the other inputs are—even CLK. It is also common to have an
    asynchronous clear input (*CLR*) that sets the state (and output) to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: There are more efficient circuits for implementing edge-triggered D flip-flops,
    but this discussion shows that they can be constructed from ordinary logic gates.
    They are economical and efficient, so they are widely used in *very large scale
    integration (VLSI)* circuits, which are circuits that include billions of transistor
    gates on a single semiconductor microchip.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than draw the implementation details for each D flip-flop, circuit designers
    use the symbols shown in [Figure 7-11](ch07.xhtml#ch7fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg167_Image_218.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: The symbols used for D flip-flops: (a) positive-edge triggering,
    (b) negative-edge triggering*'
  prefs: []
  type: TYPE_NORMAL
- en: The various inputs and outputs are labeled in [Figure 7-11](ch07.xhtml#ch7fig11).
    Hardware designers typically use *Ǭ* instead of ¬*Q*. It’s common to label the
    flip-flop as *Qn*, where *n* = 1, 2, . . . , which is used to identify the flip-flop
    within the overall circuit. The small circle at the clock input in [Figure 7-11](ch07.xhtml#ch7fig11)(b)
    means that this D flip-flop is triggered by a negative-going clock transition.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen some logic components that save state, let’s look at the
    process of designing sequential logic circuits using these components.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Designing Sequential Logic Circuits**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll consider a general set of steps for designing sequential logic circuits.
    Design in any field is usually iterative, as you have no doubt learned from your
    programming experience. You start with a design, analyze it, and then refine the
    design to make it faster, less expensive, and so on. After you’ve gained some
    experience, the design process usually requires fewer iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are a good method for building a first working design:'
  prefs: []
  type: TYPE_NORMAL
- en: From the plain-language description of the problem, create a state transition
    table and state diagram showing what the circuit must do. These form the basic
    technical specifications for the circuit you will be designing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a binary code for the states and create a binary-coded version of the
    state table and/or state diagram. For *N* states, the code will need log[2] *N*
    bits. Any code will work, but some codes may lead to simpler combinational logic
    in the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a type of flip-flop. This choice is often dictated by the components
    you have on hand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the inputs required to each flip-flop to cause each of the required
    transitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify the inputs to each flip-flop. Karnaugh maps or algebraic methods are
    good tools for the simplification process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 5 may cause you to rethink your choice of type of flip-flop. The three
    steps of flip-flop choice, determining inputs, and simplification may need to
    be repeated several times to reach a good design. The following two examples illustrate
    this process. You can think of these as guided “Your Turn” exercises; if you have
    access to a digital circuit simulator, or the required hardware, I suggest you
    use those resources to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Counter***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We want to design a counter that has an *Enable* input. When *Enable* = `1`,
    it increments through the sequence 0, 1, 2, 3, 0, 1, . . . , incrementing with
    each clock tick. *Enable* = `0` causes the counter to remain in its current state.
    The output is the sequence number in 2-bit binary. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Create a state transition table and state diagram.**'
  prefs: []
  type: TYPE_NORMAL
- en: At each clock tick, the counter increments by 1 if *Enable* = `1`. If *Enable*
    = `0`, it remains in the current state. [Figure 7-12](ch07.xhtml#ch7fig12) shows
    the four states—0, 1, 2, and 3—and the corresponding 2-bit output for each state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg169_Image_219.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: A state diagram for a counter that cycles through 0, 1, 2, 3,
    0, 1, . . .*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-5](ch07.xhtml#ch7tab5) shows the state transition table for this counter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-5:** A State Transition Table for the Counter'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ***Enable*** = 0 | ***Enable*** = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Current ***n***** | **Next ***n***** | **Next ***n***** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: When *Enable* = `0`, the counter is essentially turned off; when *Enable* =
    `1`, the counter automatically increments by 1, wrapping around to 0 after it
    reaches its limit of 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Create a binary-coded version of the state table/state diagram.**'
  prefs: []
  type: TYPE_NORMAL
- en: With four states, we need 2 bits. We’ll let *n* be the state, which we represent
    with the 2-bit binary number *n*[1]*n*[0]. [Table 7-6](ch07.xhtml#ch7tab6) shows
    the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-6:** A State Transition Table for a 2-Bit Counter'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Current** | **Next** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ***Enable*** | ***n***[1] | ***n***[0] | ***n***[1] | ***n***[0] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '**Step 3: Select a flip-flop.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use D flip-flops. After going through the design, we may decide that another
    flip-flop might work better. We could then come back to this step and go through
    the remaining steps again. An experienced designer may have some insight into
    the problem that would suggest starting with another type of flip-flop. Often,
    any potential savings in cost or power consumption do not justify changing to
    another type of flip-flop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Determine the inputs to the flip-flops.**'
  prefs: []
  type: TYPE_NORMAL
- en: We need two flip-flops, one for each bit. A D flip-flop simply stores the value
    of its input on the next clock cycle, so the inputs that cause each flip-flop
    to change to the next state are shown under the two “Next” columns in [Table 7-6](ch07.xhtml#ch7tab6).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the Boolean equations that show the logical combinations of the
    inputs, *Enable* and the current *n*[1] and *n*[0], that produce the required
    inputs. We’ll use *E* for *Enable* and *D*[1] and *D*[0] for the inputs to the
    respective D flip-flops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg170_Image_220.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Step 5: Simplify the required inputs.**'
  prefs: []
  type: TYPE_NORMAL
- en: We can use Karnaugh maps to find a simpler solution, as shown in [Figure 7-13](ch07.xhtml#ch7fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg170_Image_221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Karnaugh maps for a 2-bit counter implemented with D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Karnaugh maps allow us to simplify the Boolean equations for the input
    to each flip-flop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg170_Image_222.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Step 6: Draw the circuit.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use a PLA (introduced in “Programmable Logic Array” on [page 120](ch06.xhtml#ch06lev2sec5)
    in [Chapter 6](ch06.xhtml)) to generate the inputs to the two D flip-flops. [Figure
    7-14](ch07.xhtml#ch7fig14) shows our resulting circuit used to implement this
    counter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg171_Image_223.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: A 2-bit counter implemented with a PLA and two D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-15](ch07.xhtml#ch7fig15) shows the timing of the binary counter when
    progressing through the sequence 3, 0, 1, 2, 3 (`11, 00, 01, 10, 11`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg171_Image_224.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: The timing of a 2-bit counter implemented with D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: '*D[i]* is the input to the *i*th D flip-flop, and *n[i]* is its output. Remember
    that when the *i*th input, *D[i]*, is applied to its D flip-flop, the output of
    the flip-flop does not change until the second half of the clock cycle. This can
    be seen when comparing the trace for the corresponding output, *n[i]*, in the
    figure.'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Branch Predictor***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our second example, we’ll design a branch predictor. This example is a bit
    more complicated than the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for very inexpensive microcontrollers, most modern CPUs execute instructions
    in stages. Each stage consists of hardware that is specialized to perform the
    operations in that stage. An instruction passes through each stage in an assembly-line
    fashion. For example, if you were to create an assembly line to manufacture wooden
    chairs, you could do it in three stages: saw the wood to make the parts for the
    chair, assemble the parts, and paint the chair. The hardware needed at each stage
    would be saw, hammer and screwdriver, and paintbrush.'
  prefs: []
  type: TYPE_NORMAL
- en: The arrangement of specialized hardware in the CPU is called a *pipeline*. The
    hardware in the first stage is designed to fetch an instruction from memory, as
    you’ll see in [Chapter 9](ch09.xhtml). After an instruction is fetched from memory,
    it passes on to the next stage of the pipeline, where it is decoded. Simultaneously,
    the first stage of the pipeline fetches the next instruction from memory. The
    result is that the CPU is working on several instructions at the same time. This
    provides some parallelism, thus improving execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all programs contain *conditional branch points*—places where the next
    instruction to be fetched can be in one of two different memory locations. Unfortunately,
    there is no way to know which of the two instructions to fetch until the decision-making
    instruction has moved several stages into the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain execution speed, as soon as a conditional branch instruction has
    passed on from the fetch stage, it’s helpful if the CPU can predict where to fetch
    the next instruction from. Then it can go ahead and do so. If the prediction was
    wrong, the CPU simply ignores the work it has done on the predicted instruction
    by flushing out the pipeline and fetching the other instruction, which enters
    the beginning of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll design a circuit that predicts whether a conditional
    branch will be taken. The predictor will continue to predict the same outcome,
    and the branch will be either taken or not taken, until it makes two mistakes
    in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps we will follow in designing our branch predictor circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Create a state table and state diagram.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Yes to indicate when the branch is taken and No to indicate when it
    isn’t. The state diagram in [Figure 7-16](ch07.xhtml#ch7fig16) shows the four
    possible states.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg173_Image_225.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: The four possible states for our branch predictor*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin in the No state. Here, the branch was not taken at least the last
    two times this instruction was executed. The output is to predict that it will
    also not be taken this time. The input to the circuit is whether the branch has
    actually been taken when the instruction has completed execution.
  prefs: []
  type: TYPE_NORMAL
- en: The arc labeled Actual = Not Taken in [Figure 7-16](ch07.xhtml#ch7fig16) loops
    back to the No state, with the prediction (the output) that the branch will not
    be taken the next time the instruction is executed. If the branch is taken, the
    Actual = Taken arc shows that the circuit moves into the No–Error state to indicate
    one error in the prediction. But because it must be wrong twice in a row to change
    our prediction, the circuit is still predicting Don’t Take as the output.
  prefs: []
  type: TYPE_NORMAL
- en: From the No–Error state, if the branch is not taken (the prediction is correct),
    the circuit returns to the No state. However, if the branch is taken, the circuit
    predicted incorrectly twice in a row, so the circuit moves to the Yes state and
    the output is to predict Take.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave tracing through the remainder of this state diagram as an exercise
    for you. Once you’re satisfied with how it works, take a look at [Table 7-7](ch07.xhtml#ch7tab7),
    which provides the technical specifications for our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-7:** The Branch Predictor State Table'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | **Actual = Not Taken** | **Actual = Taken** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Current state** | **Prediction** | **Next state** | **Prediction** | **Next
    state** | **Prediction** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | Don’t Take | No | Don’t Take | No–Error | Don’t Take |'
  prefs: []
  type: TYPE_TB
- en: '| No–Error | Don’t Take | No | Don’t Take | Yes | Take |'
  prefs: []
  type: TYPE_TB
- en: '| Yes–Error | Take | No | Don’t Take | Yes | Take |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | Take | Yes–Error | Take | Yes | Take |'
  prefs: []
  type: TYPE_TB
- en: When the result of the conditional branch (taken or not taken) is determined
    in the pipeline, [Table 7-7](ch07.xhtml#ch7tab7) shows the next state and the
    corresponding prediction. This prediction will be used to determine which of the
    two possible addresses—the address of the next instruction or the address of the
    branch target—to store for use the next time this instruction is encountered in
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Represent the states.**'
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, we’ll choose a binary code for the state, *s*[1]*s*[0], as
    shown in [Table 7-8](ch07.xhtml#ch7tab8).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-8:** The States of the Branch Predictor'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | ***s***[1] | ***s***[0] | **Prediction** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No | `0` | `0` | Don’t Take |'
  prefs: []
  type: TYPE_TB
- en: '| No–Error | `0` | `1` | Don’t Take |'
  prefs: []
  type: TYPE_TB
- en: '| Yes–Error | `1` | `0` | Take |'
  prefs: []
  type: TYPE_TB
- en: '| Yes | `1` | `1` | Take |'
  prefs: []
  type: TYPE_TB
- en: The prediction is 1 bit, *s*[1], which is `0` if the prediction is Don’t Take
    and `1` if the prediction is Take.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the input, Actual, be `0` when the branch is not taken and `1` when
    it is taken and using the state notation of [Table 7-8](ch07.xhtml#ch7tab8), we
    get the state transition table shown in [Table 7-9](ch07.xhtml#ch7tab9).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-9:** The State Transition Table for the Branch Predictor'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Current** | **Next** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Actual** | ***s***[1] | ***s***[0] | ***s***[1] | ***s***[0] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `1` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `0` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: When the conditional branch instruction reaches a point in the pipeline where
    it is determined whether the branch should be taken or not, this information is
    used as the input, Actual, to the predictor circuit, which transforms the state
    from Current to Next for the next time this instruction is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Select a flip-flop.**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use D flip-flops again here, with the same caveats as in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Determine the inputs to the flip-flops.**'
  prefs: []
  type: TYPE_NORMAL
- en: We need two flip-flops, one for each bit. A D flip-flop simply stores the value
    of its input on the next clock cycle, so the inputs that cause each flip-flop
    to change to the next state are shown under the two “Next” columns in [Table 7-9](ch07.xhtml#ch7tab9).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the Boolean equations that show the logical combinations of the
    three signals, Actual and the Current *s*[1] and *s*[0] that produce the required
    input to each D flip-flop to cause it to go to the Next *s*[1] and *s*[0]. We’ll
    use *A* for Actual and *D*[1] and *D*[0] for the inputs to the respective D flip-flops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg175_Image_226.jpg) **Step 5: Simplify the required inputs.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by using the following Boolean identities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg176_Image_227.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our equations become:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg176_Image_228.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Step 6: Draw the circuit.**'
  prefs: []
  type: TYPE_NORMAL
- en: In this circuit, the input is Actual = `0` if the branch was not taken the last
    time and Actual = `1` if it was taken. As with our counter, we’ll use a PLA with
    our two D flip-flops, as shown in [Figure 7-17](ch07.xhtml#ch7fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg176_Image_229.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The branch predictor circuit using a PLA and two D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows the simplest method of branch prediction. More complex methods
    exist, and there is also ongoing research into branch prediction’s effectiveness.
    Although it can speed up some algorithms, the additional hardware required for
    branch prediction consumes more electrical power, which is a concern in battery-powered
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used D flip-flops and PLAs in both of these example designs, but as usual,
    the choice of components depends on multiple factors: cost, availability of components,
    design tools, design time, power usage, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1     Redesign the 2-bit counter in [Figure 7-14](ch07.xhtml#ch7fig14) to
    use individual gates instead of a PLA.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2     Redesign the branch predictor in [Figure 7-17](ch07.xhtml#ch7fig17)
    to use individual gates instead of a PLA.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sequential logic circuits**   These depend on both the current and past inputs.
    They have a time history, which can be summarized by the current state of the
    circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latch**   A device that stores 1 bit of data. The ability to change the value
    of the bit is controlled by the level of an enabling signal; this is called level
    triggering.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flip-flop**   A device that stores 1 bit of data. The ability to change the
    value of the bit is controlled by the transition of a clock signal; this is called
    edge triggering.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SR latch**   The state of an SR latch depends on its input and is either
    set or reset.'
  prefs: []
  type: TYPE_NORMAL
- en: '**D flip-flop**   A D flip-flop stores 1 bit of data. By connecting two latches
    in a primary–secondary configuration, the output is isolated from the input, allowing
    a flip-flop to be synchronized with a clock signal. The output of a D flip-flop
    can be changed only once per clock cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: You saw two examples of designing sequential logic circuits with D flip-flops
    and PLAs in this chapter. In the next chapter, you’ll learn about some of the
    various memory structures used in a computer system.
  prefs: []
  type: TYPE_NORMAL
