- en: '[12](nsp-boxall502581-0008.xhtml#rch12)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AVR and the I ² C Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *Inter-Integrated Circuit* bus, or *I* ² *C* , is another popular type of
    data bus. Originally devised by Philips (now NXP), this bus is designed to enable
    one or many devices to transmit and receive data to and from a host device such
    as a microcontroller over short distances. This chapter shows you how to set up
    the I ² C and use it to communicate with external ICs by learning the required
    functions and hardware and exploring some examples of popular I ² C devices.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to increase the operating speed of AVR microcontrollers, enabling
    you to implement the I ² C data bus with an AVR. After learning how to control
    the MCP23017 I ² C 16-bit I/O expander IC and store and retrieve data from an
    external I ² C EEPROM, you’ll use the DS3231 I ² C real-time clock IC for the
    first time.
  prefs: []
  type: TYPE_NORMAL
- en: There are thousands of devices that use the I ² C bus, from display and motor
    controllers to sensors and more. After working through this chapter, you’ll be
    prepared to harness these devices to make more complex projects like weather monitoring
    and display solutions, multiple-servo robots, and projects that require adding
    more I/O ports to your microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '[Increasing AVR Speed](nsp-boxall502581-0008.xhtml#rah1401)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, your AVR projects have been running with a CPU speed of 1 MHz,
    using the AVR’s internal oscillator to generate the required clock signal for
    timing and other operations. This minimized complications and reduced the number
    of required parts for the circuits. At times, however, you may need to work with
    parts that require a faster data bus. These parts include those that communicate
    with microcontrollers using the I ² C bus. In order to use this bus, you’ll need
    to know how to run your projects with a higher CPU speed to generate faster clock
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'To increase the ATmega328P-PU’s CPU speed, you’ll need to make two modifications:
    one to the hardware and one to the project’s Makefile. To alter the hardware,
    you’ll need three more components: two 22 pF ceramic capacitors and one 16 MHz
    *crystal oscillator* . More commonly known as *crystals* , these oscillators create
    an electrical signal with an exactly accurate frequency, in this case 16 MHz.
    [Figure 12-1](nsp-boxall502581-0022.xhtml#f12001) shows the crystal we’ll use.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 16 MHz crystal oscillator](images/nsp-boxall502581-f12001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: A 16 MHz crystal oscillator'
  prefs: []
  type: TYPE_NORMAL
- en: Crystals are not polarized. The schematic symbol for our 16 MHz crystal is shown
    in [Figure 12-2](nsp-boxall502581-0022.xhtml#f12002) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a 16 MHz crystal oscillator](images/nsp-boxall502581-f12002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Crystal oscillator schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The crystal determines the microcontroller’s speed of operation. For example,
    the circuit we will be assembling runs at 16 MHz, which means it can execute 16 million
    processor instructions per second. That doesn’t mean it can execute a line of
    code or function that rapidly, of course, since it takes many processor instructions
    to execute a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The schematic in [Figure 12-3](nsp-boxall502581-0022.xhtml#f12003) shows the
    additional circuitry required to connect a crystal to an ATmega328P-PU microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic for an ATmega328P-PU with an external crystal](images/nsp-boxall502581-f12003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: ATmega328P-PU with external crystal circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the hardware changes mentioned above, you’ll also need to edit the
    project’s Makefile to tell the toolchain to set the microcontroller to operate
    at 16 MHz. This will be necessary for all projects using an external crystal.
    To do this for this chapter’s [first project](nsp-boxall502581-0022.xhtml#pro49)
    , open the Makefile found in the *Project 49* subfolder of the book’s *Chapter
    11* folder. Scroll down to line 21, labeled `FUSES` , and update it to match the
    following line of code (don’t forget to save the file when you’re done):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note It’s a good idea to store different Makefiles separately so you can easily
    copy them into project folders of your own when required. If you have downloaded
    the code for this book from the No Starch Press website, the Makefiles are already
    set up in this way for each project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing the I ² C Bus](nsp-boxall502581-0008.xhtml#rah1402)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I ² C bus works similarly to the SPI bus, in that data is again transmitted
    and received in serial fashion along one wire to or from the microcontroller (the
    *serial data line* , usually called *SDA* ), while another wire carries the clock
    signal (the *serial clock line* , usually called *SCL* or *SCK* ). That signal
    is synchronized with the data signal for accurate data transmission. The clock
    signal frequency for our projects is 100 kHz.
  prefs: []
  type: TYPE_NORMAL
- en: Note The I ² C is a bidirectional bus, in that data is transmitted or received
    along one wire. Because the clock signal is carried on another wire, some suppliers,
    such as Microchip, call the I ² C the *two-wire serial interface (TWI)* .
  prefs: []
  type: TYPE_NORMAL
- en: On the I ² C bus, the microcontroller acts as the *primary* device, and each
    IC on the bus is a *secondary* . Each secondary has its own address, a 7-bit number
    that allows the microcontroller to communicate with that device. Each device usually
    has a range of I ² C bus addresses to choose from, detailed in the manufacturer’s
    data sheet. If an IC has two or more potential I ² C bus addresses, we determine
    which address to use by wiring the IC pins in a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-4](nsp-boxall502581-0022.xhtml#f12004) shows an example of the I
    ² C bus in action as captured using a DSO.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a DSO displaying the data and clock lines of an I2C bus with
    bytes of data traveling in both directions between the primary and secondary devices](images/nsp-boxall502581-f12004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: Data traversing the I ² C bus'
  prefs: []
  type: TYPE_NORMAL
- en: Once activated, using the I ² C bus follows a simple logical pattern, as shown
    in [Figure 12-4](nsp-boxall502581-0022.xhtml#f12004) . Both lines of the bus are
    held at high; we connect them to 5 V via pullup resistors. We send a start signal
    through the primary device (the microcontroller) by setting the data line low
    and then starting the clock signal on the clock line. Next, we send the 7 bits
    of the address of the device with which we want to communicate, followed by a
    0 (which tells the device we want to write to it) or a 1 (which tells the device
    we want it to send us data).
  prefs: []
  type: TYPE_NORMAL
- en: The secondary device will then either acknowledge that it has received the byte
    from the primary device by sending an *ACK bit* (a 0) or, if there was an error,
    send a *NACK bit* (a 1) for “not acknowledged,” indicating that the primary device
    should stop sending. The secondary may also send a NACK if it has finished sending
    data back to the primary.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this in action in [Figure 12-4](nsp-boxall502581-0022.xhtml#f12004)
    , as the primary starts the I ² C bus, then sends a `0x20+0` to tell the secondary
    device it is writing data, then sends another two bytes of data to the secondary
    device. Hexadecimal is the preferred base system used with the I ² C bus in code,
    but you can use binary or decimal if it’s easier or makes more sense to you. This
    may seem complex, but after examining the projects in this chapter, you’ll be
    well on your way to I ² C expertise.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pin Connections and Voltages](nsp-boxall502581-0008.xhtml#rbh1401)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each I ² C device uses two pins—usually labeled SCL and SDA, as mentioned earlier—to
    communicate. These pins connect to matching pins on the microcontroller. If you
    have multiple I ² C devices, they all make the same connections back to the microcontroller.
    Finally, a pullup resistor is placed between 5 V (the supply voltage) and each
    of the I ² C lines. [Figure 12-5](nsp-boxall502581-0022.xhtml#f12005) shows a
    simplified example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simplified diagram of I2C bus wiring](images/nsp-boxall502581-f12005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Simplified example of I ² C bus wiring'
  prefs: []
  type: TYPE_NORMAL
- en: As with the SPI bus, your I ² C bus device must operate or tolerate operating
    at 5 V, since the microcontroller runs on 5 V in our projects. Be sure to check
    with the seller or manufacturer before use. If you simply must use an I ² C bus
    device that operates at a reduced voltage, such as 3.3 V, use an I ² C-compatible
    level converter like the unit mentioned in [Chapter 11](nsp-boxall502581-0021.xhtml#ch11)
    , PMD Way part number 441079.
  prefs: []
  type: TYPE_NORMAL
- en: Again, using these level converters is simple. Use one pair of channels for
    the I ² C bus, with the 5 V wires on the HV pads and the matching lower-voltage
    wires on the LV pads, and connect GND on both sides to the board.
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing to I ² C Devices](nsp-boxall502581-0008.xhtml#rbh1402)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show you how to implement the I ² C bus, I’ll first explain how to write
    data to I ² C devices, then follow with reading data later in the chapter. Writing
    data to I ² C bus devices requires five functions that don’t exist in our AVR
    toolchain, so we use the following custom functions to complete the necessary
    operations. These functions are included in this chapter’s I ² C bus projects.
  prefs: []
  type: TYPE_NORMAL
- en: Enable the I ² C Bus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `I2Cenable()` function converts the two GPIO pins (PC5 and PC4 on the ATmega328P-PU)
    from normal use to I ² C bus pins (SCL and SDA, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first set the *TWBR (TWI Bit Rate Register)* , which is used in the formula
    provided by Microchip to determine the I ² C bus clock speed. Here we use the
    value 72, which results in the microcontroller dividing the CPU speed down to
    100 kHz for our clock. We also set the *TWEN (Two-Wire Enable)* bit in the *TWCR
    (Two-Wire Control Register)* to 1, which turns the GPIO pins into I ² C bus pins
    SCL and SDA.
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the I ² C Bus to Complete
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Bus operations are not instantaneous, so we use the `I2Cwait()` function after
    other I ² C bus commands to allow for data transmission to complete before executing
    another operation on the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can check if the bus is busy by looking at the *TWINT (Two-Wire Interrupt)*
    bit of the TWCR register. This code sets the TWINT bit to 1 when the bus is free
    for another operation, so the code does nothing while TWINT is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Start the I ² C Bus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `I2CstartWait()` function starts the process of sending data to a device
    on the I ² C bus. It sends the secondary address to enable the required device on
    the bus and awaits that device’s acknowledgment that it is ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function first sets a start condition on the bus by setting TWINT in the
    TWCR register to 1, setting the start condition on with TWSTA (two-wire interface
    start condition), and activating the bus with TWEN ❶. We wait for those operations
    to complete ❷, then load the value of the TWSR register ❸ and continue only if
    the status bits TWS3 and TWS4 are not set to 1\. If set to 1, these bits indicate
    that a start condition or repeated start condition was not successfully sent,
    so we can’t continue.
  prefs: []
  type: TYPE_NORMAL
- en: At this point the bus initialization has been successful, so we now send the
    secondary address to enable the required device on the bus. We do so by loading
    the address into the TWDR register ❹, then sending it off by setting TWINT and
    TWEN in the TWCR register to 1\. This is followed by a short wait to give time
    for the transmission to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Once again we check the status of the I ² C bus by loading the value of the
    TWSR register ❺, and we continue only if the secondary device is not busy or if
    the secondary device didn’t acknowledge the write. If it is busy or didn’t acknowledge,
    we send an I ² C stop command ❻ and wait for that instruction to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Write to the I ² C Bus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This function simply sends a byte of data along the I ² C bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once I ² C bus communication has been initialized and we’ve started the I ²
    C bus, we use this function to write a byte of data to the device being addressed.
    We load the data into the TWDR register, and then send it out using the TWCR register.
    We then wait a moment for the process to complete. You can call this function
    two or more times in a row to send multiple bytes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the I ² C Bus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `I2Cstop()` function releases the GPIO pins from I ² C bus duty and sets
    them back to normal duty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When your code is finished with the I ² C bus, use this function to stop the
    bus and release the GPIO pins used for SDA and SCL back to normal duty. The bus
    is stopped by three bit changes:'
  prefs: []
  type: TYPE_NORMAL
- en: • Setting the TWINT bit to 1 tells the microcontroller you’re finished using
    the bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Setting the TWSTO bit to 1 puts a stop condition on the bus, telling the devices
    on the bus that the bus is being deactivated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Setting the TWEN bit to 1 disables bus operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s turn theory into practice by using some interesting devices over the
    I ² C bus with the ATmega328P-PU. Our first such device will be the Microchip
    MCP23017, which adds 16 more I/O pins to our microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 49: Using the MCP23017 16-Bit I/O Expander](nsp-boxall502581-0008.xhtml#rpro49)'
  prefs: []
  type: TYPE_NORMAL
- en: When your AVR-based project doesn’t have enough digital GPIO pins, you can add
    16 more at a time with the Microchip MCP23017, shown in [Figure 12-6](nsp-boxall502581-0022.xhtml#f12006)
    . We’ll use the MCP23017 for the first time in this project, which doubles as
    a demonstration of writing data to the I ² C bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the MCP23017](images/nsp-boxall502581-f12006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: Microchip MCP23017 16-bit I/O expander'
  prefs: []
  type: TYPE_NORMAL
- en: The MCP23017 has eight possible bus addresses, so you can connect a maximum
    of eight on the same bus, giving you up to 128 GPIO pins. The I/O pins are arranged
    in two banks of eight, as shown in the schematic symbol in [Figure 12-7](nsp-boxall502581-0022.xhtml#f12007)
    . Each pin can handle up to 20 mA of current, though the entire MCP23017 has a
    continuous maximum of 125 mA.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the MCP23017](images/nsp-boxall502581-f12007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-7: Microchip MCP23017 schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: To set the I ² C bus address, you need to connect the pins labeled A0 to A2
    to combinations of 5 V or GND. If you’re using one MCP23017, you can set the bus
    address to `0x20` by connecting the three pins to GND. If you’re using two or
    more MCP23017s, or need to let another device use the `0x20` address, refer to
    [Table 12-1](nsp-boxall502581-0022.xhtml#tab1201) for your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 12-1 : MCP23017 I ² C Bus Address Configuration |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bus address | Pin A2 | Pin A1 | Pin A0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x20` | GND | GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x21` | GND | GND | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x22` | GND | 5 V | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x23` | GND | 5 V | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x24` | 5 V | GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x25` | 5 V | GND | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x26` | 5 V | 5 V | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x27` | 5 V | 5 V | 5 V |'
  prefs: []
  type: TYPE_TB
- en: As mentioned earlier, the bus address is a 7-bit number, which we complete to
    an 8-bit number by adding a 0 or 1 at the end for writing to the bus or reading
    the bus, respectively. You can create this 8-bit number by bit-shifting a 1 from
    the right, using a `<<1` to create the address for writing— `0x20<<1` , for example—or
    converting the address to the result, which in this example would be `0x40` .
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the MCP23017 also involves writing to its configuration registers,
    each of which has its own address. To use the pins as outputs, we set the I/O
    direction registers for both banks of eight pins. These are known as the GPIOA
    and GPIOB registers for banks A and B, whose addresses are `0x12` and `0x13` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve addressed these registers, we send a 0 to each to set the pins as
    outputs. For example, to set the GPIOA register to outputs, we’d send the following
    sequence of data to the I ² C bus: `0x20<<1` or `0x40` (the MCP23017 I ² C bus
    address for writing), then `0x12` (the GPIOA register address), then `0x00` (0).
    Let’s do this now in our project.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1403)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MCP23017 16-bit I/O IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Up to 16 LEDs (D1–D16)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Up to 16 560 Ω resistors (R1–R16)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 4.7 kΩ resistors (R17–R18)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 12-8](nsp-boxall502581-0022.xhtml#f12008)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 49](images/nsp-boxall502581-f12008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-8: Schematic for [Project 49](nsp-boxall502581-0022.xhtml#pro49)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1404)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 49* subfolder of this book’s
    *Chapter 12* folder, and enter the command `make flash` . After a few moments,
    each bank of LEDs should repeatedly display the count between 0 and 255 in binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the five I ² C functions described in the previous section to
    simplify data transmission. The initialization function ❶ facilitates using the
    MCP23017\. This sets up the GPIOA and GPIOB registers to make all the I/O pins
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize the I ² C bus ❷ and address each GPIO bank to control the
    outputs. We start the I ² C bus ❸, then address the GPIO registers by sending
    their addresses ❹. Then we send the data to control the registers ❺ and stop the
    I ² C bus ❻. Following this, after restarting the I ² C bus, the code selects
    the second bank of the MCP23017 ❼, sends the data ❽, and again stops the bus ❾.
  prefs: []
  type: TYPE_NORMAL
- en: As this project is intended to demonstrate all possible output combinations,
    it sends a decimal number generated by the `for` loop. However, you can also use
    a binary number if it helps with visualizing which of the output pins to control.
    For example, if you want to turn on pins 7, 4, and 0 in a bank, you can send `0b10010001`
    rather than `145` in decimal, and the corresponding outputs will go high. Notice
    how the physical pin numbers match the ones in the binary number.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to harness the MCP23017, let’s move on to reading data
    from an I ² C device.
  prefs: []
  type: TYPE_NORMAL
- en: '[Reading Data from I ² C Devices](nsp-boxall502581-0008.xhtml#rah1403)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you can write to an I ² C device, it’s time to learn how to read data—such
    as sensor data, external memory, and other types of output—from these devices.
    To read data, after initializing the I ² C bus as normal, we use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time we add a 1 at the end of the 7-bit bus address (instead of a 0, for
    writing). Once the secondary device receives this address byte, it knows to send
    back one or more bytes of data to the bus for the primary device to receive.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the correct bus address to use to read from a device, take the
    device’s I ² C address and convert it to binary. For example, the address `0x50`
    converts to `1010000` in binary. Add a 1 at the end so you end up with `10100001`
    , then convert this back to hexadecimal, which results in `0xA1` .
  prefs: []
  type: TYPE_NORMAL
- en: Note If you don’t have a calculator capable of converting from binary to decimal
    to hexadecimal and vice versa, a useful website for various mathematical conversions
    is [https://www.rapidtables.com/convert/number/](https://www.rapidtables.com/convert/number/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use one of two new functions, `I2Cread()` or `I2CreadACK()` . `I2Cread()`
    waits for a byte of data to come back from the secondary device (without an acknowledge
    bit) and places it in a byte variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function enables the primary device to receive a byte of data by first
    setting TWINT and TWEN to enable the bus and free it for use. After waiting for
    the operation to complete, the byte of data received from the secondary device
    is available in the TWDR register, and it’s then passed as the result of the function
    with `return TWDR;` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `I2Cread()` , `I2CreadACK()` waits for a byte from the secondary device
    and places it in a byte variable, but it also considers the acknowledge bit from
    the secondary device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This time, in addition to setting TWINT and TWEN, we set TWEA in TWCR to 1\.
    This generates the ACK (acknowledge bit) on the bus when the primary device has
    successfully received the byte of data.
  prefs: []
  type: TYPE_NORMAL
- en: We pick which read function to use based on the parameters of the secondary
    device. Some devices require the ACK bit before sending more data, and some do
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the full complement of functions for using the I ² C bus, let’s
    put them to use in the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 50: Using an External IC EEPROM](nsp-boxall502581-0008.xhtml#rpro50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 39](nsp-boxall502581-0019.xhtml#pro39) in [Chapter 9](nsp-boxall502581-0019.xhtml#ch09)
    showed how to use the ATmega328P-PU’s internal EEPROM to store data that you don’t
    want to delete when you remove the power source. Taking this idea further, you
    can also use external EEPROM ICs that have more storage space and allow you to
    build projects with microcontrollers that don’t have their own EEPROMs.'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we’ll use the Microchip 24LC512-E/P EEPROM IC, an example
    of which is shown in [Figure 12-9](nsp-boxall502581-0022.xhtml#f12009) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 24LC512-E/P EEPROM IC](images/nsp-boxall502581-f12009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-9: Microchip 24LC512-E/P external EEPROM IC'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-10](nsp-boxall502581-0022.xhtml#f12010) shows the Microchip 24LC512-E/P’s
    schematic symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the 24LC512-E/P](images/nsp-boxall502581-f12010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-10: Microchip 24LC512-E/P schematic symbol'
  prefs: []
  type: TYPE_NORMAL
- en: As with most other I ² C devices, you can set this IC’s 7-bit address by connecting
    the combination of pins A0, A1, and A2 to power or GND. If you’re using one 24LC512-E/P,
    you can set the bus address to `0x50` by connecting the three A pins to GND. If
    you’re using two or more, or need to let another secondary device use the `0x50`
    address; refer to [Table 12-2](nsp-boxall502581-0022.xhtml#tab1202) for your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 12-2 : 24LC512-E/P I ² C Bus Address Configuration |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bus address | Pin A2 | Pin A1 | Pin A0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x50` | GND | GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x51` | GND | GND | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x52` | GND | 5 V | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x53` | GND | 5 V | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x54` | 5 V | GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x55` | 5 V | GND | 5 V |'
  prefs: []
  type: TYPE_TB
- en: '| `0x56` | 5 V | 5 V | GND |'
  prefs: []
  type: TYPE_TB
- en: '| `0x57` | 5 V | 5 V | 5 V |'
  prefs: []
  type: TYPE_TB
- en: The 24LC512-E/P can store up to 512KB of data (or, divided by 8, 64,000 bytes).
    This project demonstrates how to write and read bytes of data to the EEPROM for
    integration into other projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1405)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Microchip 24LC512-E/P EEPROM IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 4.7 kΩ resistors (R1–R2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MAX7219 eight-digit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 12-11](nsp-boxall502581-0022.xhtml#f12011)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 50](images/nsp-boxall502581-f12011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-11: Schematic for [Project 50](nsp-boxall502581-0022.xhtml#pro50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1406)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 50* subfolder of this book’s
    *Chapter 12* folder, and enter the command `make flash` . After a few moments,
    the MAX7219 display should rapidly display the numbers between 0 and 255, writing
    these values to the EEPROM. Then it should display these numbers again at a slower
    pace as it reads them from the EEPROM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code to see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code reuses functions from previous projects, such as the MAX7219 functions
    from [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) and the I ² C bus functions
    from this chapter’s [Project 49](nsp-boxall502581-0022.xhtml#pro49) ; the new
    code is contained in the main loop. In summary, it writes and retrieves the values
    0 through 255 to and from EEPROM locations 0 through 255\. This is accomplished
    in the write and read loops in the main section of the code.
  prefs: []
  type: TYPE_NORMAL
- en: To write values to the EEPROM, we first start the bus and wait for acknowledgment
    ❶ in our write loop, using the “write” form of the bus address. The EEPROM is
    now expecting 2 bytes of data, which represent the address (or location) in the
    EEPROM’s memory to deal with (in this case, write to). It expects 2 bytes of data
    because there are more than 256 possible locations. Therefore, the code creates
    the variable `i` in the loop as a 16-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: We send the “high byte” of the address ❷, which details the part of the address
    above 255, and follow it with the “low byte,” which details the part of the address
    equal to or less than 255 ❸. Then we send the value to store to the EEPROM ❹,
    and the MAX7219 display shows that value for our reference.
  prefs: []
  type: TYPE_NORMAL
- en: To read the values from the EEPROM, we first start the bus and wait for acknowledgment
    ❺ in our read loop, again using the “write” form of the bus address, then send
    the high ❻ and low ❼ bytes of the address as we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to retrieve data from the EEPROM, we restart the I ² C bus ❽ by using
    the read form of the bus address. We then use our new `I2Cread()` function to
    take the byte sent from the EEPROM back to the microcontroller and store it in
    the variable `j` ❾. Now that we have the data from the EEPROM, we stop using the
    I ² C bus ⓿ and show the values on the MAX7219 display module for reference.
  prefs: []
  type: TYPE_NORMAL
- en: More on the High Byte and Low Byte
  prefs: []
  type: TYPE_NORMAL
- en: We need to split 16-bit integers into high and low bytes to send them along
    the I ² C (or SPI) data bus. This involves bit-shifting the whole 16-bit number
    8 bits to the right to determine the high byte, then sending the low byte by simply
    using the 16-bit number in an 8-bit operation, as doing this effectively removes
    the high byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the number 41,217\. That’s greater than 255, so we need
    2 bytes of data to represent it in AVR operations. If you convert 41,217 to binary,
    you’ll see that it uses 16 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '1010000100000001'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the 8-bit high byte by bit-shifting the entire number 8 bits to the
    right. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10100001` 00000001 >> 8 = `10100001` // Our high byte'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the low byte by simply using it in an 8-bit operation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: I2Cwrite( `10100001` 00000001)
  prefs: []
  type: TYPE_NORMAL
- en: This has the same effect as `I2Cwrite(00000001)` .
  prefs: []
  type: TYPE_NORMAL
- en: This project provided a neat demonstration not only of writing and reading bytes
    of data to and from an I ² C-based device but also of the framework for storing
    data in external EEPROM IC. In the [next project](nsp-boxall502581-0022.xhtml#pro51)
    , we’ll move on to our final I ² C bus device, the DS3231—a *real-time clock (RTC)*
    IC that allows you to add time and date information to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 51: Using the DS3231 Real-Time Clock](nsp-boxall502581-0008.xhtml#rpro51)'
  prefs: []
  type: TYPE_NORMAL
- en: Once set with the current time and date, an RTC provides accurate time and date
    data on request. RTCs allow you to build a variety of interesting projects, from
    simple clocks to data-logging devices, alarms, and more. In this project, you’ll
    create a clock that displays the current date and time in 24-hour format using
    an RTC and the MAX7219 display module.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find many different RTC ICs on the market, some more accurate than others.
    In this chapter, we’ll use the Maxim DS3231; it doesn’t require any external circuitry
    other than a backup battery, it’s incredibly accurate, and it’s quite robust in
    module form.
  prefs: []
  type: TYPE_NORMAL
- en: The DS3231 is available as a breakout board from various retailers, including
    the version from PMD Way (part number 883422) shown in [Figure 12-12](nsp-boxall502581-0022.xhtml#f12012)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of PMD Way part number 883422](images/nsp-boxall502581-f12012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-12: A DS3231 real-time clock IC module'
  prefs: []
  type: TYPE_NORMAL
- en: Using a breakout board means you don’t need to worry about support circuitry
    like pullup resistors for the DS3231, nor connecting a backup battery, as the
    board takes care of all this for you. All you need to do is insert a CR2032 coin-cell
    battery for the backup and connect jumper wires to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting the breakout board to your project is easy: just use V [CC] (for
    5 V), GND, SCL, and SDA connections. The DS3231 has a fixed I ² C bus address
    of `0x68` , which converts to a write address of `0xD0` and a read address of
    `0xD1` .'
  prefs: []
  type: TYPE_NORMAL
- en: It has a group of registers it uses to store time and date information, starting
    at `0x00` and increasing sequentially, as shown in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 12-3 : DS3231 Data Registers |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Address | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00` | Seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `0x01` | Minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `0x02` | Hours |'
  prefs: []
  type: TYPE_TB
- en: '| `0x03` | Day of week (1 = Sunday, 7 = Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| `0x04` | Day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `0x05` | Month |'
  prefs: []
  type: TYPE_TB
- en: '| `0x06` | Year (two-digit) |'
  prefs: []
  type: TYPE_TB
- en: In this project, we’ll use only the registers shown in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203)
    . However, the data sheet details more that you can investigate; it’s available
    at [https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html](https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Data is stored in the DS3231 registers using *binary-coded decimal (BCD)* format,
    which assigns a four-digit binary code to each digit in a decimal number. Therefore,
    we’ll use simple BCD-to-decimal conversions in our code.
  prefs: []
  type: TYPE_NORMAL
- en: To set the time and date, we’ll write the bytes of data in order from `0x00`
    using our I ² C bus write function. To retrieve the data, we can either read from
    a particular address, as we did with the EEPROM in [Project 50](nsp-boxall502581-0022.xhtml#pro50)
    , or start a read at `0x00` with ACK, causing the DS3231 to send the rest of the
    data one byte at a time from each sequential register. We’ll use this latter method
    in our project’s code. But first, let’s assemble the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1407)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build your circuit, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • DS3231 RTC module with backup battery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 22 pF ceramic capacitors (C1–C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 470 μF 16 V electrolytic capacitor (C3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 16 MHz crystal oscillator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • MAX7219 eight-digit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 12-13](nsp-boxall502581-0022.xhtml#f12013)
    . Don’t forget to connect the MAX7219 and DS3231 boards to 5 V and GND as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 51](images/nsp-boxall502581-f12013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-13: Schematic for [Project 51](nsp-boxall502581-0022.xhtml#pro51)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1408)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before uploading the code to the microcontroller as normal, open the *main.c*
    file found in the *Project 51* subfolder of this book’s *Chapter 12* folder in
    your text editor and scroll down to line 309\. Remove the comment slashes in front
    of the function `setTimeDS3231()` . Next, update the parameters in that function
    to match your current date and time. The parameters, in order, are: hours (in
    24-hour format), minutes, seconds, day of the week (1 to 7), date (1 to 31), month,
    year (00 to 99). For example, assuming you consider Sunday the first day of the
    week—in some areas Monday is considered the first day, so Monday would be 1—if
    the time is 2:32 PM (that is, 14:32) on Tuesday, November 1, 2022, you would change
    the line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now save the file, and execute the `make flash` command as usual from the terminal
    window. Then reopen the *main.c* file, replace the comment slashes in front of
    the `setTimeDS3231()` function, save the file, and reflash the code. The first
    flash sets the time and date, and the second deactivates the setting every time
    the microcontroller is reset or power-cycled. If you skipped this second flash,
    the project would set the same time and date after every reset.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished, you should see the current time then date alternately
    displayed on the MAX7219 module. Congratulations—you’ve made your own digital
    clock!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s examine the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this code reuses some functions you’ve seen in previous projects
    (namely, the functions for the MAX7219 display in [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    from [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) and the I ² C bus functions
    from this chapter’s [Project 49](nsp-boxall502581-0022.xhtml#pro49) ).
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare the variables to deal with the time and date information ❶.
    These variables will hold the data to write to the DS3231 and receive data from
    the DS3231\. As mentioned earlier, the DS3231 works with data in binary-coded
    decimal format, so the code includes functions to convert integers to and from
    BCD ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The `setTimeDS3231()` function accepts the time, day of week, and date and sends
    them to the DS3231 ❸. It first writes to the DS3231 to set the register to address
    ( `0x00` ), then sequentially writes each byte of data in the order described
    in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203) . Note that each I ² C write
    function uses the decimal-to-BCD function.
  prefs: []
  type: TYPE_NORMAL
- en: The `readTimeDS3231()` function ❹ retrieves the time and date information. It
    requests a byte of data from the DS3231 register `0x00` , and as the function
    uses ACK in the read process, the DS3231 will sequentially send the following
    bytes of data from the registers. This means we can simply use `I2CreadACK()`
    seven times to retrieve all the required data. As we’re retrieving data from the
    DS3231, we use the BCD-to-decimal function within the I ² C read functions.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the `displayTimeMAX7219()` function ❺, which organizes the time and
    date data into digits and shows them on the MAX7219 display. It shows the time
    first, then the date after a short delay. You can remove the date display and
    just let your clock run continuously, if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: The entire project is wrapped up in the main loop, where we initialize the GPIO,
    I ² C, and SPI bus, then simply call the display function ❻ and delay until it
    is called again. For a challenge, why not write your own I ² C and DS3231 libraries
    for future reference, or make an alarm clock as well?
  prefs: []
  type: TYPE_NORMAL
- en: There’s still plenty more to learn, including new information on how to display
    data on popular character liquid crystal display modules, which we’ll explore
    in the [next chapter](nsp-boxall502581-0023.xhtml#ch13) .
  prefs: []
  type: TYPE_NORMAL
