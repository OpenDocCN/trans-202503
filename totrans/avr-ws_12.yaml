- en: '[12](nsp-boxall502581-0008.xhtml#rch12)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[12](nsp-boxall502581-0008.xhtml#rch12)'
- en: AVR and the I ² C Bus
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVR 和 I ² C 总线
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: The *Inter-Integrated Circuit* bus, or *I* ² *C* , is another popular type of
    data bus. Originally devised by Philips (now NXP), this bus is designed to enable
    one or many devices to transmit and receive data to and from a host device such
    as a microcontroller over short distances. This chapter shows you how to set up
    the I ² C and use it to communicate with external ICs by learning the required
    functions and hardware and exploring some examples of popular I ² C devices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成电路间总线*，或 *I* ² *C*，是另一种常见的数据总线类型。最初由飞利浦（现在是 NXP）设计，该总线旨在使一个或多个设备能够在短距离内与主设备（如微控制器）进行数据传输和接收。本章将向你展示如何设置
    I ² C，并使用它与外部 IC 进行通信，通过学习所需的功能和硬件，并探索一些流行的 I ² C 设备示例。'
- en: You’ll learn how to increase the operating speed of AVR microcontrollers, enabling
    you to implement the I ² C data bus with an AVR. After learning how to control
    the MCP23017 I ² C 16-bit I/O expander IC and store and retrieve data from an
    external I ² C EEPROM, you’ll use the DS3231 I ² C real-time clock IC for the
    first time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何提高 AVR 微控制器的工作速度，使你能够在 AVR 上实现 I ² C 数据总线。在学习如何控制 MCP23017 I ² C 16 位
    I/O 扩展 IC 并从外部 I ² C EEPROM 存储和检索数据后，你将首次使用 DS3231 I ² C 实时钟 IC。
- en: There are thousands of devices that use the I ² C bus, from display and motor
    controllers to sensors and more. After working through this chapter, you’ll be
    prepared to harness these devices to make more complex projects like weather monitoring
    and display solutions, multiple-servo robots, and projects that require adding
    more I/O ports to your microcontroller.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有成千上万的设备使用 I ² C 总线，从显示器和电机控制器到传感器等。完成本章内容后，你将准备好利用这些设备来实现更复杂的项目，如天气监测和显示解决方案、多舵机机器人，以及需要为微控制器添加更多
    I/O 端口的项目。
- en: '[Increasing AVR Speed](nsp-boxall502581-0008.xhtml#rah1401)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[提高 AVR 速度](nsp-boxall502581-0008.xhtml#rah1401)'
- en: Up until now, your AVR projects have been running with a CPU speed of 1 MHz,
    using the AVR’s internal oscillator to generate the required clock signal for
    timing and other operations. This minimized complications and reduced the number
    of required parts for the circuits. At times, however, you may need to work with
    parts that require a faster data bus. These parts include those that communicate
    with microcontrollers using the I ² C bus. In order to use this bus, you’ll need
    to know how to run your projects with a higher CPU speed to generate faster clock
    signals.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的 AVR 项目一直以 1 MHz 的 CPU 速度运行，使用 AVR 的内部振荡器生成所需的时钟信号，用于定时和其他操作。这种方式最小化了复杂性，并减少了电路所需的零件数量。然而，有时你可能需要使用需要更快数据总线的部件。这些部件包括那些通过
    I ² C 总线与微控制器通信的部件。为了使用这个总线，你需要了解如何通过更高的 CPU 速度来运行你的项目，从而生成更快的时钟信号。
- en: 'To increase the ATmega328P-PU’s CPU speed, you’ll need to make two modifications:
    one to the hardware and one to the project’s Makefile. To alter the hardware,
    you’ll need three more components: two 22 pF ceramic capacitors and one 16 MHz
    *crystal oscillator* . More commonly known as *crystals* , these oscillators create
    an electrical signal with an exactly accurate frequency, in this case 16 MHz.
    [Figure 12-1](nsp-boxall502581-0022.xhtml#f12001) shows the crystal we’ll use.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要提高 ATmega328P-PU 的 CPU 速度，你需要进行两项修改：一项是硬件修改，另一项是项目的 Makefile 修改。为了改变硬件，你需要额外的三个组件：两个
    22 pF 陶瓷电容和一个 16 MHz *晶体振荡器*。这些通常被称为 *晶体*，它们能产生一个准确频率的电信号，在本例中是 16 MHz。[图 12-1](nsp-boxall502581-0022.xhtml#f12001)
    显示了我们将使用的晶体。
- en: '![Photo of a 16 MHz crystal oscillator](images/nsp-boxall502581-f12001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![16 MHz 晶体振荡器照片](images/nsp-boxall502581-f12001.jpg)'
- en: 'Figure 12-1: A 16 MHz crystal oscillator'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：16 MHz 晶体振荡器
- en: Crystals are not polarized. The schematic symbol for our 16 MHz crystal is shown
    in [Figure 12-2](nsp-boxall502581-0022.xhtml#f12002) .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体是非极化的。我们的 16 MHz 晶体的原理符号如 [图 12-2](nsp-boxall502581-0022.xhtml#f12002) 所示。
- en: '![Schematic symbol for a 16 MHz crystal oscillator](images/nsp-boxall502581-f12002.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![16 MHz 晶体振荡器原理符号](images/nsp-boxall502581-f12002.jpg)'
- en: 'Figure 12-2: Crystal oscillator schematic symbol'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：晶体振荡器原理符号
- en: The crystal determines the microcontroller’s speed of operation. For example,
    the circuit we will be assembling runs at 16 MHz, which means it can execute 16 million
    processor instructions per second. That doesn’t mean it can execute a line of
    code or function that rapidly, of course, since it takes many processor instructions
    to execute a single line of code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体决定了微控制器的工作速度。例如，我们将组装的电路工作在16 MHz，这意味着它每秒可以执行1600万条处理器指令。当然，这并不意味着它可以如此快速地执行一行代码或函数，因为执行单行代码需要许多处理器指令。
- en: The schematic in [Figure 12-3](nsp-boxall502581-0022.xhtml#f12003) shows the
    additional circuitry required to connect a crystal to an ATmega328P-PU microcontroller.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](nsp-boxall502581-0022.xhtml#f12003)中的原理图展示了将晶体连接到ATmega328P-PU微控制器所需的附加电路。'
- en: '![Schematic for an ATmega328P-PU with an external crystal](images/nsp-boxall502581-f12003.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![带外部晶体的ATmega328P-PU原理图](images/nsp-boxall502581-f12003.jpg)'
- en: 'Figure 12-3: ATmega328P-PU with external crystal circuit'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：带外部晶体电路的ATmega328P-PU
- en: 'Along with the hardware changes mentioned above, you’ll also need to edit the
    project’s Makefile to tell the toolchain to set the microcontroller to operate
    at 16 MHz. This will be necessary for all projects using an external crystal.
    To do this for this chapter’s [first project](nsp-boxall502581-0022.xhtml#pro49)
    , open the Makefile found in the *Project 49* subfolder of the book’s *Chapter
    11* folder. Scroll down to line 21, labeled `FUSES` , and update it to match the
    following line of code (don’t forget to save the file when you’re done):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述硬件更改外，你还需要编辑项目的Makefile，以告诉工具链将微控制器设置为16 MHz运行。这对于所有使用外部晶体的项目都是必要的。要为本章的[第一个项目](nsp-boxall502581-0022.xhtml#pro49)执行此操作，打开位于本书*第11章*文件夹中的*Project
    49*子文件夹中的Makefile。向下滚动到第21行，标记为`FUSES`，并将其更新为以下代码行（完成后别忘了保存文件）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note It’s a good idea to store different Makefiles separately so you can easily
    copy them into project folders of your own when required. If you have downloaded
    the code for this book from the No Starch Press website, the Makefiles are already
    set up in this way for each project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注：将不同的Makefile单独存储是一个好主意，这样你可以在需要时将它们轻松复制到自己的项目文件夹中。如果你从No Starch Press网站下载了本书的代码，Makefile已经为每个项目设置好了。
- en: '[Introducing the I ² C Bus](nsp-boxall502581-0008.xhtml#rah1402)'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍I ² C总线](nsp-boxall502581-0008.xhtml#rah1402)'
- en: The I ² C bus works similarly to the SPI bus, in that data is again transmitted
    and received in serial fashion along one wire to or from the microcontroller (the
    *serial data line* , usually called *SDA* ), while another wire carries the clock
    signal (the *serial clock line* , usually called *SCL* or *SCK* ). That signal
    is synchronized with the data signal for accurate data transmission. The clock
    signal frequency for our projects is 100 kHz.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: I ² C总线的工作方式类似于SPI总线，即数据通过一根电缆以串行方式传输和接收，往返于微控制器（*串行数据线*，通常称为*SDA*），而另一根电缆则传输时钟信号（*串行时钟线*，通常称为*SCL*或*SCK*）。该信号与数据信号同步，以确保准确的数据传输。我们项目的时钟信号频率为100
    kHz。
- en: Note The I ² C is a bidirectional bus, in that data is transmitted or received
    along one wire. Because the clock signal is carried on another wire, some suppliers,
    such as Microchip, call the I ² C the *two-wire serial interface (TWI)* .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注：I ² C是一个双向总线，数据沿一根线传输或接收。由于时钟信号通过另一根线传输，因此一些供应商（如Microchip）称I ² C为*双线串行接口（TWI）*。
- en: On the I ² C bus, the microcontroller acts as the *primary* device, and each
    IC on the bus is a *secondary* . Each secondary has its own address, a 7-bit number
    that allows the microcontroller to communicate with that device. Each device usually
    has a range of I ² C bus addresses to choose from, detailed in the manufacturer’s
    data sheet. If an IC has two or more potential I ² C bus addresses, we determine
    which address to use by wiring the IC pins in a certain way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在I ² C总线上，微控制器充当*主设备*，总线上的每个IC都是*从设备*。每个从设备都有自己的地址，这是一个7位数字，允许微控制器与该设备进行通信。每个设备通常有一系列可供选择的I
    ² C总线地址，详细信息请参阅制造商的数据手册。如果一个IC有两个或多个潜在的I ² C总线地址，我们通过以特定方式连接IC引脚来决定使用哪个地址。
- en: '[Figure 12-4](nsp-boxall502581-0022.xhtml#f12004) shows an example of the I
    ² C bus in action as captured using a DSO.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-4](nsp-boxall502581-0022.xhtml#f12004)展示了I ² C总线在工作中的一个示例，通过数字示波器（DSO）捕获。'
- en: '![Screenshot of a DSO displaying the data and clock lines of an I2C bus with
    bytes of data traveling in both directions between the primary and secondary devices](images/nsp-boxall502581-f12004.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![显示 I2C 总线数据和时钟线的示波器截图，数据字节在主设备和从设备之间双向传输](images/nsp-boxall502581-f12004.jpg)'
- en: 'Figure 12-4: Data traversing the I ² C bus'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：数据在 I ² C 总线上的传输
- en: Once activated, using the I ² C bus follows a simple logical pattern, as shown
    in [Figure 12-4](nsp-boxall502581-0022.xhtml#f12004) . Both lines of the bus are
    held at high; we connect them to 5 V via pullup resistors. We send a start signal
    through the primary device (the microcontroller) by setting the data line low
    and then starting the clock signal on the clock line. Next, we send the 7 bits
    of the address of the device with which we want to communicate, followed by a
    0 (which tells the device we want to write to it) or a 1 (which tells the device
    we want it to send us data).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活，使用 I ² C 总线遵循一个简单的逻辑模式，如[图 12-4](nsp-boxall502581-0022.xhtml#f12004)所示。总线的两条线保持在高电平；我们通过上拉电阻将它们连接到
    5 V。我们通过设置数据线为低电平并在时钟线上启动时钟信号来向主设备（微控制器）发送开始信号。接下来，我们发送与我们希望通信的设备的 7 位地址，之后跟随一个
    0（表示我们想写入数据）或一个 1（表示我们希望设备向我们发送数据）。
- en: The secondary device will then either acknowledge that it has received the byte
    from the primary device by sending an *ACK bit* (a 0) or, if there was an error,
    send a *NACK bit* (a 1) for “not acknowledged,” indicating that the primary device
    should stop sending. The secondary may also send a NACK if it has finished sending
    data back to the primary.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从设备要么通过发送*ACK 位*（0）确认已接收到来自主设备的字节，要么如果发生错误，则发送*NACK 位*（1），表示“未确认”，并指示主设备停止发送。如果从设备已经完成向主设备发送数据，它也可能发送
    NACK。
- en: You can see this in action in [Figure 12-4](nsp-boxall502581-0022.xhtml#f12004)
    , as the primary starts the I ² C bus, then sends a `0x20+0` to tell the secondary
    device it is writing data, then sends another two bytes of data to the secondary
    device. Hexadecimal is the preferred base system used with the I ² C bus in code,
    but you can use binary or decimal if it’s easier or makes more sense to you. This
    may seem complex, but after examining the projects in this chapter, you’ll be
    well on your way to I ² C expertise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 12-4](nsp-boxall502581-0022.xhtml#f12004)中看到这个操作示例，主设备启动 I ² C 总线，然后发送`0x20+0`告诉从设备它正在写数据，接着再发送两字节的数据到从设备。十六进制是与
    I ² C 总线一起使用的首选进制系统，但如果使用二进制或十进制对你来说更简单或更合适，也可以使用。这看起来可能很复杂，但在查看本章中的项目后，你将能很快掌握
    I ² C 技术。
- en: '[Pin Connections and Voltages](nsp-boxall502581-0008.xhtml#rbh1401)'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[引脚连接和电压](nsp-boxall502581-0008.xhtml#rbh1401)'
- en: Each I ² C device uses two pins—usually labeled SCL and SDA, as mentioned earlier—to
    communicate. These pins connect to matching pins on the microcontroller. If you
    have multiple I ² C devices, they all make the same connections back to the microcontroller.
    Finally, a pullup resistor is placed between 5 V (the supply voltage) and each
    of the I ² C lines. [Figure 12-5](nsp-boxall502581-0022.xhtml#f12005) shows a
    simplified example of this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 I ² C 设备使用两个引脚——通常标记为 SCL 和 SDA，如前所述——进行通信。这些引脚连接到微控制器上的相应引脚。如果你有多个 I ² C
    设备，它们都通过相同的连接回到微控制器。最后，在 5 V（供电电压）和每条 I ² C 线之间放置一个上拉电阻。[图 12-5](nsp-boxall502581-0022.xhtml#f12005)展示了这个简化示例。
- en: '![Simplified diagram of I2C bus wiring](images/nsp-boxall502581-f12005.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![简化的 I2C 总线布线示意图](images/nsp-boxall502581-f12005.jpg)'
- en: 'Figure 12-5: Simplified example of I ² C bus wiring'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：I ² C 总线布线的简化示例
- en: As with the SPI bus, your I ² C bus device must operate or tolerate operating
    at 5 V, since the microcontroller runs on 5 V in our projects. Be sure to check
    with the seller or manufacturer before use. If you simply must use an I ² C bus
    device that operates at a reduced voltage, such as 3.3 V, use an I ² C-compatible
    level converter like the unit mentioned in [Chapter 11](nsp-boxall502581-0021.xhtml#ch11)
    , PMD Way part number 441079.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SPI 总线一样，你的 I ² C 总线设备必须在 5 V 下工作或能够容忍 5 V 的工作，因为我们的项目中微控制器运行在 5 V 下。在使用之前，确保与卖家或制造商确认。如果你必须使用一个工作在低电压（如
    3.3 V）的 I ² C 总线设备，可以使用像[第 11 章](nsp-boxall502581-0021.xhtml#ch11)中提到的 I ² C 兼容电平转换器，PMD
    Way 部件号 441079。
- en: Again, using these level converters is simple. Use one pair of channels for
    the I ² C bus, with the 5 V wires on the HV pads and the matching lower-voltage
    wires on the LV pads, and connect GND on both sides to the board.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用这些电平转换器非常简单。只需使用一对通道连接I²C总线，将5V电缆连接到HV焊盘，并将匹配的低电压电缆连接到LV焊盘，同时将GND两侧连接到电路板。
- en: '[Writing to I ² C Devices](nsp-boxall502581-0008.xhtml#rbh1402)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[写入I²C设备](nsp-boxall502581-0008.xhtml#rbh1402)'
- en: To show you how to implement the I ² C bus, I’ll first explain how to write
    data to I ² C devices, then follow with reading data later in the chapter. Writing
    data to I ² C bus devices requires five functions that don’t exist in our AVR
    toolchain, so we use the following custom functions to complete the necessary
    operations. These functions are included in this chapter’s I ² C bus projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示如何实现I²C总线，我将首先解释如何向I²C设备写入数据，然后在本章后面介绍如何读取数据。写入数据到I²C总线设备需要五个在我们AVR工具链中不存在的函数，因此我们使用以下自定义函数来完成必要的操作。这些函数包含在本章的I²C总线项目中。
- en: Enable the I ² C Bus
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用I²C总线
- en: 'The `I2Cenable()` function converts the two GPIO pins (PC5 and PC4 on the ATmega328P-PU)
    from normal use to I ² C bus pins (SCL and SDA, respectively):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2Cenable()`函数将两个GPIO引脚（ATmega328P-PU上的PC5和PC4）从常规用途转换为I²C总线引脚（分别为SCL和SDA）：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first set the *TWBR (TWI Bit Rate Register)* , which is used in the formula
    provided by Microchip to determine the I ² C bus clock speed. Here we use the
    value 72, which results in the microcontroller dividing the CPU speed down to
    100 kHz for our clock. We also set the *TWEN (Two-Wire Enable)* bit in the *TWCR
    (Two-Wire Control Register)* to 1, which turns the GPIO pins into I ² C bus pins
    SCL and SDA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置*TWBR (TWI比特率寄存器)*，该寄存器用于根据Microchip提供的公式来确定I²C总线的时钟速度。在这里，我们使用值72，这使得微控制器将CPU的速度分频到100
    kHz，作为我们的时钟。我们还将*TWEN (双线使能)*位设置为1，这会将GPIO引脚转换为I²C总线引脚SCL和SDA。
- en: Wait for the I ² C Bus to Complete
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待I²C总线完成
- en: 'Bus operations are not instantaneous, so we use the `I2Cwait()` function after
    other I ² C bus commands to allow for data transmission to complete before executing
    another operation on the bus:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总线操作不是瞬间完成的，因此我们在执行其他I²C总线命令后，使用`I2Cwait()`函数来等待数据传输完成，然后再执行总线上的其他操作：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can check if the bus is busy by looking at the *TWINT (Two-Wire Interrupt)*
    bit of the TWCR register. This code sets the TWINT bit to 1 when the bus is free
    for another operation, so the code does nothing while TWINT is 0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看TWCR寄存器的*TWINT (双线中断)*位来检查总线是否繁忙。当总线空闲时，该代码将TWINT位设置为1，因此当TWINT为0时，代码什么也不做。
- en: Start the I ² C Bus
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动I²C总线
- en: 'The `I2CstartWait()` function starts the process of sending data to a device
    on the I ² C bus. It sends the secondary address to enable the required device on
    the bus and awaits that device’s acknowledgment that it is ready for use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2CstartWait()`函数启动向I²C总线上的设备发送数据的过程。它发送二级地址以启用总线上的所需设备，并等待该设备的确认，表明它已准备好使用：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function first sets a start condition on the bus by setting TWINT in the
    TWCR register to 1, setting the start condition on with TWSTA (two-wire interface
    start condition), and activating the bus with TWEN ❶. We wait for those operations
    to complete ❷, then load the value of the TWSR register ❸ and continue only if
    the status bits TWS3 and TWS4 are not set to 1\. If set to 1, these bits indicate
    that a start condition or repeated start condition was not successfully sent,
    so we can’t continue.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先通过将TWCR寄存器中的TWINT设置为1，设置总线上的启动条件，然后通过设置TWSTA（双线接口启动条件）和激活总线（TWEN❶）来启动。我们等待这些操作完成❷，然后加载TWSR寄存器的值❸，仅当状态位TWS3和TWS4未设置为1时才继续。如果设置为1，这些位表示启动条件或重复启动条件未成功发送，因此我们无法继续。
- en: At this point the bus initialization has been successful, so we now send the
    secondary address to enable the required device on the bus. We do so by loading
    the address into the TWDR register ❹, then sending it off by setting TWINT and
    TWEN in the TWCR register to 1\. This is followed by a short wait to give time
    for the transmission to complete.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，公交初始化已经成功，因此我们现在发送二级地址以启用总线上的所需设备。我们通过将地址加载到TWDR寄存器❹中，然后通过将TWCR寄存器中的TWINT和TWEN设置为1来发送它。接下来会有一个短暂的等待时间，以便完成传输。
- en: Once again we check the status of the I ² C bus by loading the value of the
    TWSR register ❺, and we continue only if the secondary device is not busy or if
    the secondary device didn’t acknowledge the write. If it is busy or didn’t acknowledge,
    we send an I ² C stop command ❻ and wait for that instruction to finish.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次通过加载 TWSR 寄存器的值 ❺ 来检查 I ² C 总线的状态，只有在从设备未忙碌或未确认写入时，我们才会继续。如果设备忙碌或未确认，我们将发送
    I ² C 停止命令 ❻ 并等待该指令完成。
- en: Write to the I ² C Bus
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向 I ² C 总线写数据
- en: 'This function simply sends a byte of data along the I ² C bus:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数仅通过 I ² C 总线发送一个字节的数据：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once I ² C bus communication has been initialized and we’ve started the I ²
    C bus, we use this function to write a byte of data to the device being addressed.
    We load the data into the TWDR register, and then send it out using the TWCR register.
    We then wait a moment for the process to complete. You can call this function
    two or more times in a row to send multiple bytes of data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 I ² C 总线通信初始化完成并启动，我们使用此功能向被寻址的设备写入一个字节的数据。我们将数据加载到 TWDR 寄存器中，然后通过 TWCR 寄存器发送出去。接着我们等待片刻，直到该过程完成。你可以连续调用此函数两次或更多次，以发送多个字节的数据。
- en: Stop the I ² C Bus
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止 I ² C 总线
- en: 'The `I2Cstop()` function releases the GPIO pins from I ² C bus duty and sets
    them back to normal duty:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2Cstop()` 函数释放 GPIO 引脚的 I ² C 总线功能，并将其恢复为正常工作：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When your code is finished with the I ² C bus, use this function to stop the
    bus and release the GPIO pins used for SDA and SCL back to normal duty. The bus
    is stopped by three bit changes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码完成了 I ² C 总线的操作后，使用此功能停止总线并将用于 SDA 和 SCL 的 GPIO 引脚恢复为正常工作状态。通过三个位的变化来停止总线操作：
- en: • Setting the TWINT bit to 1 tells the microcontroller you’re finished using
    the bus.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 将 TWINT 位设置为 1，表示微控制器完成了对总线的使用。
- en: • Setting the TWSTO bit to 1 puts a stop condition on the bus, telling the devices
    on the bus that the bus is being deactivated.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 将 TWSTO 位设置为 1，向总线发送停止条件，告知总线上的设备总线正在停用。
- en: • Setting the TWEN bit to 1 disables bus operation.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 将 TWEN 位设置为 1 禁用总线操作。
- en: Now let’s turn theory into practice by using some interesting devices over the
    I ² C bus with the ATmega328P-PU. Our first such device will be the Microchip
    MCP23017, which adds 16 more I/O pins to our microcontroller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将理论付诸实践，使用 ATmega328P-PU 通过 I ² C 总线控制一些有趣的设备。我们的第一个设备将是 Microchip MCP23017，它为我们的微控制器添加了
    16 个 I/O 引脚。
- en: '[Project 49: Using the MCP23017 16-Bit I/O Expander](nsp-boxall502581-0008.xhtml#rpro49)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 49：使用 MCP23017 16 位 I/O 扩展器](nsp-boxall502581-0008.xhtml#rpro49)'
- en: When your AVR-based project doesn’t have enough digital GPIO pins, you can add
    16 more at a time with the Microchip MCP23017, shown in [Figure 12-6](nsp-boxall502581-0022.xhtml#f12006)
    . We’ll use the MCP23017 for the first time in this project, which doubles as
    a demonstration of writing data to the I ² C bus.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 AVR 基础项目没有足够的数字 GPIO 引脚时，你可以通过 Microchip MCP23017 添加 16 个额外的引脚，如[图 12-6](nsp-boxall502581-0022.xhtml#f12006)所示。我们将在本项目中首次使用
    MCP23017，并将其作为向 I ² C 总线写数据的演示。
- en: '![Photo of the MCP23017](images/nsp-boxall502581-f12006.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![MCP23017 照片](images/nsp-boxall502581-f12006.jpg)'
- en: 'Figure 12-6: Microchip MCP23017 16-bit I/O expander'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：Microchip MCP23017 16 位 I/O 扩展器
- en: The MCP23017 has eight possible bus addresses, so you can connect a maximum
    of eight on the same bus, giving you up to 128 GPIO pins. The I/O pins are arranged
    in two banks of eight, as shown in the schematic symbol in [Figure 12-7](nsp-boxall502581-0022.xhtml#f12007)
    . Each pin can handle up to 20 mA of current, though the entire MCP23017 has a
    continuous maximum of 125 mA.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MCP23017 有八个可能的总线地址，因此你可以在同一总线上连接最多八个设备，从而获得多达 128 个 GPIO 引脚。I/O 引脚按两组各八个排列，如[图
    12-7](nsp-boxall502581-0022.xhtml#f12007)中的电路符号所示。每个引脚最多可处理 20 mA 电流，尽管整个 MCP23017
    的最大连续电流为 125 mA。
- en: '![Schematic symbol for the MCP23017](images/nsp-boxall502581-f12007.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![MCP23017 电路符号](images/nsp-boxall502581-f12007.jpg)'
- en: 'Figure 12-7: Microchip MCP23017 schematic symbol'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-7：Microchip MCP23017 电路符号
- en: To set the I ² C bus address, you need to connect the pins labeled A0 to A2
    to combinations of 5 V or GND. If you’re using one MCP23017, you can set the bus
    address to `0x20` by connecting the three pins to GND. If you’re using two or
    more MCP23017s, or need to let another device use the `0x20` address, refer to
    [Table 12-1](nsp-boxall502581-0022.xhtml#tab1201) for your configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 I ² C 总线地址，你需要将标记为 A0 到 A2 的引脚连接到 5 V 或 GND 的组合。如果你只使用一个 MCP23017，你可以通过将三个引脚连接到
    GND，将总线地址设置为 `0x20`。如果你使用两个或更多 MCP23017，或者需要让另一个设备使用 `0x20` 地址，请参考[表 12-1](nsp-boxall502581-0022.xhtml#tab1201)进行配置。
- en: '| Table 12-1 : MCP23017 I ² C Bus Address Configuration |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 表 12-1 : MCP23017 I ² C 总线地址配置 |'
- en: '| --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Bus address | Pin A2 | Pin A1 | Pin A0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 总线地址 | 引脚 A2 | 引脚 A1 | 引脚 A0 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x20` | GND | GND | GND |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `0x20` | GND | GND | GND |'
- en: '| `0x21` | GND | GND | 5 V |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `0x21` | GND | GND | 5 V |'
- en: '| `0x22` | GND | 5 V | GND |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `0x22` | GND | 5 V | GND |'
- en: '| `0x23` | GND | 5 V | 5 V |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0x23` | GND | 5 V | 5 V |'
- en: '| `0x24` | 5 V | GND | GND |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0x24` | 5 V | GND | GND |'
- en: '| `0x25` | 5 V | GND | 5 V |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0x25` | 5 V | GND | 5 V |'
- en: '| `0x26` | 5 V | 5 V | GND |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `0x26` | 5 V | 5 V | GND |'
- en: '| `0x27` | 5 V | 5 V | 5 V |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `0x27` | 5 V | 5 V | 5 V |'
- en: As mentioned earlier, the bus address is a 7-bit number, which we complete to
    an 8-bit number by adding a 0 or 1 at the end for writing to the bus or reading
    the bus, respectively. You can create this 8-bit number by bit-shifting a 1 from
    the right, using a `<<1` to create the address for writing— `0x20<<1` , for example—or
    converting the address to the result, which in this example would be `0x40` .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，总线地址是一个 7 位数字，通过在末尾添加 0 或 1 来补充为 8 位数字，以便写入或读取总线。你可以通过将 1 从右边位移来创建这个 8
    位数字，使用 `<<1` 来创建写入地址，例如 `0x20<<1`，或转换地址为结果，这在本例中是 `0x40`。
- en: Controlling the MCP23017 also involves writing to its configuration registers,
    each of which has its own address. To use the pins as outputs, we set the I/O
    direction registers for both banks of eight pins. These are known as the GPIOA
    and GPIOB registers for banks A and B, whose addresses are `0x12` and `0x13` .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 控制 MCP23017 还涉及写入其配置寄存器，每个寄存器都有自己的地址。为了将引脚设置为输出，我们需要设置两个 8 引脚的 I/O 方向寄存器。它们分别称为
    GPIOA 和 GPIOB 寄存器，地址为 `0x12` 和 `0x13`。
- en: 'Once we’ve addressed these registers, we send a 0 to each to set the pins as
    outputs. For example, to set the GPIOA register to outputs, we’d send the following
    sequence of data to the I ² C bus: `0x20<<1` or `0x40` (the MCP23017 I ² C bus
    address for writing), then `0x12` (the GPIOA register address), then `0x00` (0).
    Let’s do this now in our project.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问了这些寄存器，就会向每个寄存器发送一个 0，以将引脚设置为输出。例如，为了将 GPIOA 寄存器设置为输出，我们会向 I ² C 总线发送以下数据序列：`0x20<<1`
    或 `0x40`（这是 MCP23017 的 I ² C 总线写入地址），然后是 `0x12`（GPIOA 寄存器地址），接着是 `0x00`（0）。现在我们在项目中实现这一操作。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1403)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1403)'
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建电路，你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • MCP23017 16-bit I/O IC
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MCP23017 16 位 I/O 集成电路
- en: • Up to 16 LEDs (D1–D16)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 多达 16 个 LED（D1–D16）
- en: • Up to 16 560 Ω resistors (R1–R16)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 多达 16 个 560 Ω 电阻（R1–R16）
- en: • Two 4.7 kΩ resistors (R17–R18)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 4.7 kΩ 电阻（R17–R18）
- en: • Two 22 pF ceramic capacitors
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 22 pF 陶瓷电容
- en: • 16 MHz crystal oscillator
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16 MHz 晶体振荡器
- en: • Jumper wires
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 12-8](nsp-boxall502581-0022.xhtml#f12008)
    .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图 [Figure 12-8](nsp-boxall502581-0022.xhtml#f12008) 所示组装电路。
- en: '![Schematic diagram for Project 49](images/nsp-boxall502581-f12008.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Project 49 原理图](images/nsp-boxall502581-f12008.jpg)'
- en: 'Figure 12-8: Schematic for [Project 49](nsp-boxall502581-0022.xhtml#pro49)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-8： [Project 49 原理图](nsp-boxall502581-0022.xhtml#pro49)
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1404)'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1404)'
- en: Open a terminal window, navigate to the *Project 49* subfolder of this book’s
    *Chapter 12* folder, and enter the command `make flash` . After a few moments,
    each bank of LEDs should repeatedly display the count between 0 and 255 in binary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，进入本书*第 12 章*文件夹下的 *Project 49* 子文件夹，并输入命令 `make flash`。几秒钟后，每组 LED 应该会反复显示
    0 到 255 之间的二进制计数。
- en: 'Let’s examine the code to see how this is done:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下代码，看看是如何实现的：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code uses the five I ² C functions described in the previous section to
    simplify data transmission. The initialization function ❶ facilitates using the
    MCP23017\. This sets up the GPIOA and GPIOB registers to make all the I/O pins
    outputs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了上一节中描述的五个 I ² C 函数，以简化数据传输。初始化函数 ❶ 便于使用 MCP23017。这将设置 GPIOA 和 GPIOB 寄存器，使所有
    I/O 引脚为输出。
- en: Next, we initialize the I ² C bus ❷ and address each GPIO bank to control the
    outputs. We start the I ² C bus ❸, then address the GPIO registers by sending
    their addresses ❹. Then we send the data to control the registers ❺ and stop the
    I ² C bus ❻. Following this, after restarting the I ² C bus, the code selects
    the second bank of the MCP23017 ❼, sends the data ❽, and again stops the bus ❾.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化 I ² C 总线 ❷ 并寻址每个 GPIO 扩展块以控制输出。我们启动 I ² C 总线 ❸，然后通过发送其地址 ❹ 来寻址 GPIO
    寄存器。接着我们发送数据来控制寄存器 ❺ 并停止 I ² C 总线 ❻。之后，在重新启动 I ² C 总线后，代码选择 MCP23017 的第二个扩展块 ❼，发送数据
    ❽，然后再次停止总线 ❾。
- en: As this project is intended to demonstrate all possible output combinations,
    it sends a decimal number generated by the `for` loop. However, you can also use
    a binary number if it helps with visualizing which of the output pins to control.
    For example, if you want to turn on pins 7, 4, and 0 in a bank, you can send `0b10010001`
    rather than `145` in decimal, and the corresponding outputs will go high. Notice
    how the physical pin numbers match the ones in the binary number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目旨在演示所有可能的输出组合，因此它通过 `for` 循环发送一个生成的十进制数。然而，如果你想更直观地控制哪些输出引脚，可以使用二进制数。例如，如果你想打开第
    7、4 和 0 引脚，你可以发送 `0b10010001` 而不是十进制数 `145`，这样相应的输出引脚就会被激活。注意，物理引脚编号与二进制数中的编号是匹配的。
- en: Now that you know how to harness the MCP23017, let’s move on to reading data
    from an I ² C device.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用 MCP23017，接下来我们学习如何从 I ² C 设备读取数据。
- en: '[Reading Data from I ² C Devices](nsp-boxall502581-0008.xhtml#rah1403)'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[从 I ² C 设备读取数据](nsp-boxall502581-0008.xhtml#rah1403)'
- en: 'Now that you can write to an I ² C device, it’s time to learn how to read data—such
    as sensor data, external memory, and other types of output—from these devices.
    To read data, after initializing the I ² C bus as normal, we use this function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以向 I ² C 设备写入数据，是时候学习如何从这些设备中读取数据了——例如传感器数据、外部存储器和其他类型的输出。读取数据时，在正常初始化
    I ² C 总线后，我们使用这个函数：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time we add a 1 at the end of the 7-bit bus address (instead of a 0, for
    writing). Once the secondary device receives this address byte, it knows to send
    back one or more bytes of data to the bus for the primary device to receive.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在 7 位总线地址的末尾加一个 1（而不是 0，用于写入）。一旦从设备接收到这个地址字节，它就知道将一个或多个字节的数据发送回总线，以供主设备接收。
- en: To determine the correct bus address to use to read from a device, take the
    device’s I ² C address and convert it to binary. For example, the address `0x50`
    converts to `1010000` in binary. Add a 1 at the end so you end up with `10100001`
    , then convert this back to hexadecimal, which results in `0xA1` .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定从设备读取数据时应使用的正确总线地址，将设备的 I ² C 地址转换为二进制。例如，地址 `0x50` 转换为二进制是 `1010000`。在末尾加一个
    1，得到 `10100001`，然后再转换回十六进制，得到 `0xA1`。
- en: Note If you don’t have a calculator capable of converting from binary to decimal
    to hexadecimal and vice versa, a useful website for various mathematical conversions
    is [https://www.rapidtables.com/convert/number/](https://www.rapidtables.com/convert/number/)
    .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你没有能够进行二进制、十进制和十六进制转换的计算器，一个有用的在线网站可以进行各种数学转换：[https://www.rapidtables.com/convert/number/](https://www.rapidtables.com/convert/number/)。
- en: 'Next, we use one of two new functions, `I2Cread()` or `I2CreadACK()` . `I2Cread()`
    waits for a byte of data to come back from the secondary device (without an acknowledge
    bit) and places it in a byte variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用两个新函数之一，`I2Cread()` 或 `I2CreadACK()`。`I2Cread()` 等待从从设备返回一个字节的数据（没有确认位），并将其放入一个字节变量中：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function enables the primary device to receive a byte of data by first
    setting TWINT and TWEN to enable the bus and free it for use. After waiting for
    the operation to complete, the byte of data received from the secondary device
    is available in the TWDR register, and it’s then passed as the result of the function
    with `return TWDR;` .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使主设备能够接收一个字节的数据，首先通过设置 TWINT 和 TWEN 来启用总线并释放其使用权限。等待操作完成后，从从设备接收到的字节数据会存储在
    TWDR 寄存器中，然后通过 `return TWDR;` 返回该字节数据。
- en: 'Like `I2Cread()` , `I2CreadACK()` waits for a byte from the secondary device
    and places it in a byte variable, but it also considers the acknowledge bit from
    the secondary device:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `I2Cread()` 类似，`I2CreadACK()` 等待从从设备接收一个字节的数据并将其放入一个字节变量中，但它还考虑了从设备的确认位：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time, in addition to setting TWINT and TWEN, we set TWEA in TWCR to 1\.
    This generates the ACK (acknowledge bit) on the bus when the primary device has
    successfully received the byte of data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，除了设置 TWINT 和 TWEN，我们还将 TWCR 中的 TWEA 设置为 1。这会在主设备成功接收到数据字节时，在总线上生成 ACK（确认位）。
- en: We pick which read function to use based on the parameters of the secondary
    device. Some devices require the ACK bit before sending more data, and some do
    not.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据次要设备的参数选择使用哪个读取功能。有些设备在发送更多数据之前需要 ACK 位，而有些则不需要。
- en: Now that we have the full complement of functions for using the I ² C bus, let’s
    put them to use in the following projects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了完整的 I²C 总线使用功能，接下来可以将它们应用到以下项目中。
- en: '[Project 50: Using an External IC EEPROM](nsp-boxall502581-0008.xhtml#rpro50)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目50：使用外部IC EEPROM](nsp-boxall502581-0008.xhtml#rpro50)'
- en: '[Project 39](nsp-boxall502581-0019.xhtml#pro39) in [Chapter 9](nsp-boxall502581-0019.xhtml#ch09)
    showed how to use the ATmega328P-PU’s internal EEPROM to store data that you don’t
    want to delete when you remove the power source. Taking this idea further, you
    can also use external EEPROM ICs that have more storage space and allow you to
    build projects with microcontrollers that don’t have their own EEPROMs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 39](nsp-boxall502581-0019.xhtml#pro39) 在[第9章](nsp-boxall502581-0019.xhtml#ch09)中展示了如何使用
    ATmega328P-PU 内部 EEPROM 存储在断电时不想删除的数据。进一步拓展这一思路，你还可以使用外部 EEPROM IC，它们提供更大的存储空间，允许你构建没有自己
    EEPROM 的微控制器项目。'
- en: For this project, we’ll use the Microchip 24LC512-E/P EEPROM IC, an example
    of which is shown in [Figure 12-9](nsp-boxall502581-0022.xhtml#f12009) .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用 Microchip 24LC512-E/P EEPROM IC，示例见[图12-9](nsp-boxall502581-0022.xhtml#f12009)。
- en: '![Photo of a 24LC512-E/P EEPROM IC](images/nsp-boxall502581-f12009.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![24LC512-E/P EEPROM IC 的照片](images/nsp-boxall502581-f12009.jpg)'
- en: 'Figure 12-9: Microchip 24LC512-E/P external EEPROM IC'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-9：Microchip 24LC512-E/P 外部 EEPROM IC
- en: '[Figure 12-10](nsp-boxall502581-0022.xhtml#f12010) shows the Microchip 24LC512-E/P’s
    schematic symbol.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-10](nsp-boxall502581-0022.xhtml#f12010) 显示了 Microchip 24LC512-E/P 的原理图符号。'
- en: '![Schematic symbol for the 24LC512-E/P](images/nsp-boxall502581-f12010.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![24LC512-E/P 的原理图符号](images/nsp-boxall502581-f12010.jpg)'
- en: 'Figure 12-10: Microchip 24LC512-E/P schematic symbol'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-10：Microchip 24LC512-E/P 原理图符号
- en: As with most other I ² C devices, you can set this IC’s 7-bit address by connecting
    the combination of pins A0, A1, and A2 to power or GND. If you’re using one 24LC512-E/P,
    you can set the bus address to `0x50` by connecting the three A pins to GND. If
    you’re using two or more, or need to let another secondary device use the `0x50`
    address; refer to [Table 12-2](nsp-boxall502581-0022.xhtml#tab1202) for your configuration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数其他 I²C 设备一样，你可以通过将 A0、A1 和 A2 引脚连接到电源或 GND 来设置该 IC 的 7 位地址。如果你只使用一个 24LC512-E/P，可以通过将这三个
    A 引脚连接到 GND，将总线地址设置为 `0x50`。如果你使用两个或更多，或者需要让另一个次级设备使用 `0x50` 地址，请参考[表12-2](nsp-boxall502581-0022.xhtml#tab1202)
    进行配置。
- en: '| Table 12-2 : 24LC512-E/P I ² C Bus Address Configuration |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 表 12-2：24LC512-E/P I²C总线地址配置 |'
- en: '| --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Bus address | Pin A2 | Pin A1 | Pin A0 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 总线地址 | 引脚 A2 | 引脚 A1 | 引脚 A0 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x50` | GND | GND | GND |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `0x50` | GND | GND | GND |'
- en: '| `0x51` | GND | GND | 5 V |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `0x51` | GND | GND | 5 V |'
- en: '| `0x52` | GND | 5 V | GND |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `0x52` | GND | 5 V | GND |'
- en: '| `0x53` | GND | 5 V | 5 V |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `0x53` | GND | 5 V | 5 V |'
- en: '| `0x54` | 5 V | GND | GND |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `0x54` | 5 V | GND | GND |'
- en: '| `0x55` | 5 V | GND | 5 V |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `0x55` | 5 V | GND | 5 V |'
- en: '| `0x56` | 5 V | 5 V | GND |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `0x56` | 5 V | 5 V | GND |'
- en: '| `0x57` | 5 V | 5 V | 5 V |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `0x57` | 5 V | 5 V | 5 V |'
- en: The 24LC512-E/P can store up to 512KB of data (or, divided by 8, 64,000 bytes).
    This project demonstrates how to write and read bytes of data to the EEPROM for
    integration into other projects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 24LC512-E/P 可以存储最多 512KB 的数据（或者，除以 8，约 64,000 字节）。本项目演示了如何向 EEPROM 写入和读取数据字节，并将其集成到其他项目中。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1405)'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1405)'
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建电路，你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Microchip 24LC512-E/P EEPROM IC
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • Microchip 24LC512-E/P EEPROM IC
- en: • Two 4.7 kΩ resistors (R1–R2)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 4.7 kΩ 电阻（R1–R2）
- en: • Two 22 pF ceramic capacitors (C1–C2)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 22 pF 陶瓷电容（C1–C2）
- en: • 470 μF 16 V electrolytic capacitor (C3)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 470 μF 16 V 电解电容（C3）
- en: • 16 MHz crystal oscillator
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16 MHz 晶体振荡器
- en: • MAX7219 eight-digit module
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MAX7219 八位数字模块
- en: • Jumper wires
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 12-11](nsp-boxall502581-0022.xhtml#f12011)
    .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图12-11](nsp-boxall502581-0022.xhtml#f12011) 所示组装电路。
- en: '![Schematic diagram for Project 50](images/nsp-boxall502581-f12011.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![项目50的电路图](images/nsp-boxall502581-f12011.jpg)'
- en: 'Figure 12-11: Schematic for [Project 50](nsp-boxall502581-0022.xhtml#pro50)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12-11: [项目 50](nsp-boxall502581-0022.xhtml#pro50)的电路图'
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1406)'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1406)'
- en: Open a terminal window, navigate to the *Project 50* subfolder of this book’s
    *Chapter 12* folder, and enter the command `make flash` . After a few moments,
    the MAX7219 display should rapidly display the numbers between 0 and 255, writing
    these values to the EEPROM. Then it should display these numbers again at a slower
    pace as it reads them from the EEPROM.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到本书*第12章*文件夹下的*项目50*子文件夹，并输入命令`make flash`。片刻之后，MAX7219显示屏应该会快速显示0到255之间的数字，将这些值写入EEPROM。然后，它会以较慢的速度再次显示这些数字，读取EEPROM中的值。
- en: 'Let’s examine the code to see how this is done:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，看看这是如何完成的：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code reuses functions from previous projects, such as the MAX7219 functions
    from [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) and the I ² C bus functions
    from this chapter’s [Project 49](nsp-boxall502581-0022.xhtml#pro49) ; the new
    code is contained in the main loop. In summary, it writes and retrieves the values
    0 through 255 to and from EEPROM locations 0 through 255\. This is accomplished
    in the write and read loops in the main section of the code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码重用了之前项目中的函数，例如[第11章](nsp-boxall502581-0021.xhtml#ch11)中的MAX7219函数和本章[项目
    49](nsp-boxall502581-0022.xhtml#pro49)中的I²C总线函数；新代码包含在主循环中。总之，它将值0到255写入并从EEPROM的0到255位置读取。这在代码的写入和读取循环中完成。
- en: To write values to the EEPROM, we first start the bus and wait for acknowledgment
    ❶ in our write loop, using the “write” form of the bus address. The EEPROM is
    now expecting 2 bytes of data, which represent the address (or location) in the
    EEPROM’s memory to deal with (in this case, write to). It expects 2 bytes of data
    because there are more than 256 possible locations. Therefore, the code creates
    the variable `i` in the loop as a 16-bit integer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向EEPROM写入数据，我们首先启动总线，并在写入循环中等待确认 ❶，使用总线地址的“写入”形式。现在，EEPROM期待接收2字节数据，这2字节表示EEPROM内存中的地址（或位置）（在本例中是写入）。它需要2字节数据，因为有超过256个可能的地址。因此，代码在循环中创建变量`i`，作为16位整数。
- en: We send the “high byte” of the address ❷, which details the part of the address
    above 255, and follow it with the “low byte,” which details the part of the address
    equal to or less than 255 ❸. Then we send the value to store to the EEPROM ❹,
    and the MAX7219 display shows that value for our reference.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送地址的“高字节” ❷，它详细说明了地址中大于255的部分，然后跟随发送“低字节”，它详细说明了地址中小于或等于255的部分 ❸。然后，我们将值发送到EEPROM进行存储
    ❹，MAX7219显示屏会显示该值供我们参考。
- en: To read the values from the EEPROM, we first start the bus and wait for acknowledgment
    ❺ in our read loop, again using the “write” form of the bus address, then send
    the high ❻ and low ❼ bytes of the address as we did previously.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从EEPROM读取值，我们首先启动总线，并在读取循环中等待确认 ❺，同样使用总线地址的“写入”形式，然后像之前一样发送高 ❻ 和低 ❼ 字节的地址。
- en: Next, to retrieve data from the EEPROM, we restart the I ² C bus ❽ by using
    the read form of the bus address. We then use our new `I2Cread()` function to
    take the byte sent from the EEPROM back to the microcontroller and store it in
    the variable `j` ❾. Now that we have the data from the EEPROM, we stop using the
    I ² C bus ⓿ and show the values on the MAX7219 display module for reference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了从EEPROM检索数据，我们通过使用总线地址的读取形式重新启动I²C总线 ❽。然后，我们使用新的`I2Cread()`函数将从EEPROM发送的字节取回到微控制器，并将其存储在变量`j`中
    ❾。现在我们从EEPROM获取了数据，停止使用I²C总线 ⓿，并将这些值显示在MAX7219显示模块上供参考。
- en: More on the High Byte and Low Byte
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于高字节和低字节的内容
- en: We need to split 16-bit integers into high and low bytes to send them along
    the I ² C (or SPI) data bus. This involves bit-shifting the whole 16-bit number
    8 bits to the right to determine the high byte, then sending the low byte by simply
    using the 16-bit number in an 8-bit operation, as doing this effectively removes
    the high byte.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将16位整数拆分为高字节和低字节，以便通过I²C（或SPI）数据总线发送它们。这涉及到将整个16位数字右移8位以确定高字节，然后通过简单地使用16位数字进行8位操作来发送低字节，因为这样做实际上会移除高字节。
- en: 'For example, consider the number 41,217\. That’s greater than 255, so we need
    2 bytes of data to represent it in AVR operations. If you convert 41,217 to binary,
    you’ll see that it uses 16 bits:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑数字 41,217。它大于 255，因此我们需要 2 个字节的数据来表示它在 AVR 操作中。如果将 41,217 转换为二进制，你会看到它使用了
    16 位：
- en: '1010000100000001'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '1010000100000001'
- en: 'We create the 8-bit high byte by bit-shifting the entire number 8 bits to the
    right. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将整个数字向右移 8 位来创建 8 位高字节。例如：
- en: '`10100001` 00000001 >> 8 = `10100001` // Our high byte'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`10100001` 00000001 >> 8 = `10100001` // 我们的高字节'
- en: 'We then create the low byte by simply using it in an 8-bit operation. For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过简单地将它用于 8 位操作来创建低字节。例如：
- en: I2Cwrite( `10100001` 00000001)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: I2Cwrite( `10100001` 00000001)
- en: This has the same effect as `I2Cwrite(00000001)` .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `I2Cwrite(00000001)` 的效果相同。
- en: This project provided a neat demonstration not only of writing and reading bytes
    of data to and from an I ² C-based device but also of the framework for storing
    data in external EEPROM IC. In the [next project](nsp-boxall502581-0022.xhtml#pro51)
    , we’ll move on to our final I ² C bus device, the DS3231—a *real-time clock (RTC)*
    IC that allows you to add time and date information to your projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目不仅展示了如何将字节数据读写到基于 I²C 的设备，还展示了如何在外部 EEPROM 芯片中存储数据的框架。在[下一个项目](nsp-boxall502581-0022.xhtml#pro51)中，我们将继续讨论我们最后一个
    I²C 总线设备——DS3231，这是一个*实时钟（RTC）*芯片，允许你将时间和日期信息添加到你的项目中。
- en: '[Project 51: Using the DS3231 Real-Time Clock](nsp-boxall502581-0008.xhtml#rpro51)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 51：使用 DS3231 实时钟](nsp-boxall502581-0008.xhtml#rpro51)'
- en: Once set with the current time and date, an RTC provides accurate time and date
    data on request. RTCs allow you to build a variety of interesting projects, from
    simple clocks to data-logging devices, alarms, and more. In this project, you’ll
    create a clock that displays the current date and time in 24-hour format using
    an RTC and the MAX7219 display module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了当前时间和日期，RTC 可以在请求时提供准确的时间和日期数据。RTC 允许你构建各种有趣的项目，从简单的时钟到数据记录设备、报警器等。在本项目中，你将创建一个时钟，使用
    RTC 和 MAX7219 显示模块以 24 小时格式显示当前的日期和时间。
- en: You’ll find many different RTC ICs on the market, some more accurate than others.
    In this chapter, we’ll use the Maxim DS3231; it doesn’t require any external circuitry
    other than a backup battery, it’s incredibly accurate, and it’s quite robust in
    module form.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多不同的 RTC 芯片，有些比其他的更精确。在本章中，我们将使用 Maxim DS3231；它除了备份电池外不需要任何外部电路，精度非常高，而且在模块形式中相当坚固。
- en: The DS3231 is available as a breakout board from various retailers, including
    the version from PMD Way (part number 883422) shown in [Figure 12-12](nsp-boxall502581-0022.xhtml#f12012)
    .
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: DS3231 可作为扩展板从各种零售商处购买，包括 PMD Way 的版本（零件编号 883422），如[图 12-12](nsp-boxall502581-0022.xhtml#f12012)所示。
- en: '![Photo of PMD Way part number 883422](images/nsp-boxall502581-f12012.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![PMD Way 零件编号 883422 的照片](images/nsp-boxall502581-f12012.jpg)'
- en: 'Figure 12-12: A DS3231 real-time clock IC module'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-12：DS3231 实时钟 IC 模块
- en: Using a breakout board means you don’t need to worry about support circuitry
    like pullup resistors for the DS3231, nor connecting a backup battery, as the
    board takes care of all this for you. All you need to do is insert a CR2032 coin-cell
    battery for the backup and connect jumper wires to your project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展板意味着你不需要担心 DS3231 的支持电路，如上拉电阻，也无需连接备份电池，因为板子会为你处理所有这些。你只需要插入一个 CR2032 的纽扣电池作为备份，并将跳线连接到你的项目上。
- en: 'Connecting the breakout board to your project is easy: just use V [CC] (for
    5 V), GND, SCL, and SDA connections. The DS3231 has a fixed I ² C bus address
    of `0x68` , which converts to a write address of `0xD0` and a read address of
    `0xD1` .'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将扩展板连接到你的项目非常简单：只需使用 V [CC]（5V），GND，SCL 和 SDA 连接。DS3231 具有固定的 I²C 总线地址 `0x68`，转换为写地址
    `0xD0` 和读地址 `0xD1`。
- en: It has a group of registers it uses to store time and date information, starting
    at `0x00` and increasing sequentially, as shown in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203)
    .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一组寄存器用于存储时间和日期信息，从`0x00`开始，依次递增，如[表 12-3](nsp-boxall502581-0022.xhtml#tab1203)所示。
- en: '| Table 12-3 : DS3231 Data Registers |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 表 12-3 ：DS3231 数据寄存器 |'
- en: '| --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Address | Function |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 地址 | 功能 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0x00` | Seconds |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0x00` | 秒 |'
- en: '| `0x01` | Minutes |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0x01` | 分钟 |'
- en: '| `0x02` | Hours |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0x02` | 小时 |'
- en: '| `0x03` | Day of week (1 = Sunday, 7 = Saturday) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `0x03` | 星期几（1 = 星期天，7 = 星期六） |'
- en: '| `0x04` | Day of month |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `0x04` | 月日 |'
- en: '| `0x05` | Month |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `0x05` | 月份 |'
- en: '| `0x06` | Year (two-digit) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `0x06` | 年份（两位数） |'
- en: In this project, we’ll use only the registers shown in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203)
    . However, the data sheet details more that you can investigate; it’s available
    at [https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html](https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html)
    .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将仅使用[表 12-3](nsp-boxall502581-0022.xhtml#tab1203)中显示的寄存器。然而，数据表中有更多内容供您查阅，您可以通过以下网址访问：[https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html](https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html)。
- en: Data is stored in the DS3231 registers using *binary-coded decimal (BCD)* format,
    which assigns a four-digit binary code to each digit in a decimal number. Therefore,
    we’ll use simple BCD-to-decimal conversions in our code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以 *二进制编码十进制（BCD）* 格式存储在 DS3231 寄存器中，该格式为十进制数字中的每一位分配一个四位二进制代码。因此，我们将在代码中使用简单的
    BCD 到十进制转换。
- en: To set the time and date, we’ll write the bytes of data in order from `0x00`
    using our I ² C bus write function. To retrieve the data, we can either read from
    a particular address, as we did with the EEPROM in [Project 50](nsp-boxall502581-0022.xhtml#pro50)
    , or start a read at `0x00` with ACK, causing the DS3231 to send the rest of the
    data one byte at a time from each sequential register. We’ll use this latter method
    in our project’s code. But first, let’s assemble the hardware.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置时间和日期，我们将按顺序从 `0x00` 开始写入数据字节，使用我们的 I²C 总线写入函数。要获取数据，我们可以像在[项目 50](nsp-boxall502581-0022.xhtml#pro50)中使用
    EEPROM 时一样，从特定地址读取，或者从 `0x00` 开始读取并发送 ACK，这将导致 DS3231 从每个顺序寄存器按字节发送其余数据。在我们项目的代码中，我们将使用后一种方法。但首先，让我们先组装硬件。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1407)'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh1407)'
- en: 'To build your circuit, you’ll need the following hardware:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建电路，您需要以下硬件：
- en: • USBasp programmer
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • 5 V breadboard power supply
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 5 V 面包板电源
- en: • ATmega328P-PU microcontroller
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • DS3231 RTC module with backup battery
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • DS3231 RTC 模块与备份电池
- en: • Two 22 pF ceramic capacitors (C1–C2)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 22 pF 陶瓷电容器（C1–C2）
- en: • 470 μF 16 V electrolytic capacitor (C3)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 470 μF 16 V 电解电容器（C3）
- en: • 16 MHz crystal oscillator
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 16 MHz 晶体振荡器
- en: • MAX7219 eight-digit module
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • MAX7219 八位数码管模块
- en: • Jumper wires
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: Assemble your circuit as shown in [Figure 12-13](nsp-boxall502581-0022.xhtml#f12013)
    . Don’t forget to connect the MAX7219 and DS3231 boards to 5 V and GND as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 12-13](nsp-boxall502581-0022.xhtml#f12013)所示组装电路。不要忘记将 MAX7219 和 DS3231
    板连接到 5 V 和 GND。
- en: '![Schematic diagram for Project 51](images/nsp-boxall502581-f12013.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![项目 51 原理图](images/nsp-boxall502581-f12013.jpg)'
- en: 'Figure 12-13: Schematic for [Project 51](nsp-boxall502581-0022.xhtml#pro51)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12-13: [项目 51](nsp-boxall502581-0022.xhtml#pro51)原理图'
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1408)'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh1408)'
- en: 'Before uploading the code to the microcontroller as normal, open the *main.c*
    file found in the *Project 51* subfolder of this book’s *Chapter 12* folder in
    your text editor and scroll down to line 309\. Remove the comment slashes in front
    of the function `setTimeDS3231()` . Next, update the parameters in that function
    to match your current date and time. The parameters, in order, are: hours (in
    24-hour format), minutes, seconds, day of the week (1 to 7), date (1 to 31), month,
    year (00 to 99). For example, assuming you consider Sunday the first day of the
    week—in some areas Monday is considered the first day, so Monday would be 1—if
    the time is 2:32 PM (that is, 14:32) on Tuesday, November 1, 2022, you would change
    the line to:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在按常规将代码上传到微控制器之前，请在文本编辑器中打开本书*第 12 章*文件夹中的*Project 51*子文件夹中的*main.c*文件，并滚动到第
    309 行。去掉`setTimeDS3231()`函数前的注释符号。接下来，更新该函数中的参数以匹配您当前的日期和时间。参数按顺序为：小时（24 小时制），分钟，秒，星期几（1
    至 7），日期（1 至 31），月份，年份（00 至 99）。例如，假设您认为星期日是每周的第一天——在某些地区，星期一被认为是第一天，因此星期一是 1——如果时间是
    2022 年 11 月 1 日（星期二）下午 2:32（即 14:32），您应将该行更改为：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now save the file, and execute the `make flash` command as usual from the terminal
    window. Then reopen the *main.c* file, replace the comment slashes in front of
    the `setTimeDS3231()` function, save the file, and reflash the code. The first
    flash sets the time and date, and the second deactivates the setting every time
    the microcontroller is reset or power-cycled. If you skipped this second flash,
    the project would set the same time and date after every reset.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，并像往常一样从终端窗口执行 `make flash` 命令。然后重新打开 *main.c* 文件，取消注释 `setTimeDS3231()`
    函数前面的注释符号，保存文件并重新烧录代码。第一次烧录设置时间和日期，第二次则在每次微控制器重置或断电重启时停用设置。如果你跳过了第二次烧录，项目会在每次重置后设置相同的时间和日期。
- en: Once you’ve finished, you should see the current time then date alternately
    displayed on the MAX7219 module. Congratulations—you’ve made your own digital
    clock!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你应该能在 MAX7219 模块上交替显示当前时间和日期。恭喜你——你已经制作了自己的数字时钟！
- en: 'Now let’s examine the code to see how this works:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下代码，看看它是如何工作的：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once again, this code reuses some functions you’ve seen in previous projects
    (namely, the functions for the MAX7219 display in [Project 46](nsp-boxall502581-0021.xhtml#pro46)
    from [Chapter 11](nsp-boxall502581-0021.xhtml#ch11) and the I ² C bus functions
    from this chapter’s [Project 49](nsp-boxall502581-0022.xhtml#pro49) ).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这段代码重用了你在之前项目中看到的一些函数（即，[第 46 项目](nsp-boxall502581-0021.xhtml#pro46) 中
    MAX7219 显示函数以及本章 [第 49 项目](nsp-boxall502581-0022.xhtml#pro49) 中的 I²C 总线函数）。
- en: First, we declare the variables to deal with the time and date information ❶.
    These variables will hold the data to write to the DS3231 and receive data from
    the DS3231\. As mentioned earlier, the DS3231 works with data in binary-coded
    decimal format, so the code includes functions to convert integers to and from
    BCD ❷.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明用于处理时间和日期信息的变量 ❶。这些变量将保存写入 DS3231 和从 DS3231 接收的数据。如前所述，DS3231 使用二进制编码十进制（BCD）格式的数据，因此代码中包含了将整数转换为
    BCD 以及从 BCD 转换回整数的函数 ❷。
- en: The `setTimeDS3231()` function accepts the time, day of week, and date and sends
    them to the DS3231 ❸. It first writes to the DS3231 to set the register to address
    ( `0x00` ), then sequentially writes each byte of data in the order described
    in [Table 12-3](nsp-boxall502581-0022.xhtml#tab1203) . Note that each I ² C write
    function uses the decimal-to-BCD function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeDS3231()` 函数接受时间、星期几和日期，并将其发送到 DS3231 ❸。它首先写入 DS3231 设置寄存器到地址（`0x00`），然后按
    [表格 12-3](nsp-boxall502581-0022.xhtml#tab1203) 中描述的顺序依次写入每个数据字节。请注意，每个 I²C 写入函数使用的是十进制到
    BCD 的转换函数。'
- en: The `readTimeDS3231()` function ❹ retrieves the time and date information. It
    requests a byte of data from the DS3231 register `0x00` , and as the function
    uses ACK in the read process, the DS3231 will sequentially send the following
    bytes of data from the registers. This means we can simply use `I2CreadACK()`
    seven times to retrieve all the required data. As we’re retrieving data from the
    DS3231, we use the BCD-to-decimal function within the I ² C read functions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`readTimeDS3231()` 函数 ❹ 检索时间和日期信息。它从 DS3231 寄存器 `0x00` 请求一个数据字节，由于该函数在读取过程中使用了
    ACK，DS3231 会依次发送来自各寄存器的后续数据字节。这意味着我们可以简单地使用 `I2CreadACK()` 函数调用七次来检索所有所需的数据。在检索
    DS3231 数据时，我们在 I²C 读取函数中使用 BCD 到十进制的转换函数。'
- en: Next comes the `displayTimeMAX7219()` function ❺, which organizes the time and
    date data into digits and shows them on the MAX7219 display. It shows the time
    first, then the date after a short delay. You can remove the date display and
    just let your clock run continuously, if you prefer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `displayTimeMAX7219()` 函数 ❺，它将时间和日期数据组织成数字并显示在 MAX7219 显示屏上。它首先显示时间，然后在短暂延迟后显示日期。如果你愿意，可以删除日期显示，让时钟持续运行。
- en: The entire project is wrapped up in the main loop, where we initialize the GPIO,
    I ² C, and SPI bus, then simply call the display function ❻ and delay until it
    is called again. For a challenge, why not write your own I ² C and DS3231 libraries
    for future reference, or make an alarm clock as well?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目被包装在主循环中，在这里我们初始化 GPIO、I²C 和 SPI 总线，然后简单地调用显示函数 ❻，并延迟直到再次调用。作为挑战，为什么不为将来参考编写你自己的
    I²C 和 DS3231 库，或者制作一个闹钟呢？
- en: There’s still plenty more to learn, including new information on how to display
    data on popular character liquid crystal display modules, which we’ll explore
    in the [next chapter](nsp-boxall502581-0023.xhtml#ch13) .
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多内容需要学习，包括如何在流行的字符液晶显示模块上显示数据的新信息，我们将在 [下一章](nsp-boxall502581-0023.xhtml#ch13)
    中进行探讨。
