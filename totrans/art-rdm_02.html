<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_39"/><strong><span class="big">2</span><br/>HIDING INFORMATION</strong></h2>
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>
<p class="noindent"><em>Steganography</em>, from the Greek term for “covered writing,” is the art of concealing a message so that adversaries aren’t aware that the message is present. Unlike cryptography, which relies on the difficulty of undoing the algorithm that generated the encrypted message, steganography relies on secrecy. Anyone can read the covered message if they know how the message is hidden. If the art of hiding a message is called steganography, then <em>steganalysis</em> is the process of detecting hidden messages. It’s a classic arms race: steganographers improve their techniques while steganalysis attempts to thwart them.</p>
<p class="indent">While steganography exists anywhere a 0 and 1 can be hidden, it is most commonly found in text, binary files, audio, video, and images. Excepting video, these are also the targets of our experiments.</p>
<span epub:type="pagebreak" id="page_40"/>
<h3 class="h3" id="ch00lev1_12"><strong>In Strings</strong></h3>
<p class="noindent">This section presents two experiments with text. The first hides a message in a string of words using a fixed offset, and the second uses random offsets.</p>
<div class="box">
<p class="box-title"><strong>A BRIEF HISTORY OF DECEPTION</strong></p>
<p class="box-para">Steganography has been around for a long time, in close association with cryptography.</p>
<p class="box-para">In the 5th century BCE, the ancient Greek author, Herodotus, related a story about Histiaeus, exiled tyrant of Miletus, in what is now modern-day Turkey. He claims that Histiaeus shaved the head of a slave and tattooed a message on his scalp, then waited for the man’s hair to grow back before sending him to Miletus. Friends of Histiaeus shaved the man’s head and read the message—instructions to revolt against the Persians. Ultimately, the revolt failed and Histiaeus’s head was sent to the Persian king, Darius.</p>
<p class="box-para">In 1605, Sir Francis Bacon developed a secretive communication method that combines steganography and cryptography. First, Bacon devised a five-digit binary code for each letter of the alphabet. Then, he used the cipher to hide messages in ordinary text with slight modifications to the font to indicate a 0 or 1 (Bacon used “a” and “b” in place of 0 and 1).</p>
<p class="box-para">For example, we might hide the message “EAT AT JOES” using this cipher as:</p>
<pre class="pre4">alIce openeD thE Door anD foUNd ThaT iT LEd inTo a SmaLl passage
aabaa aaaaab aab baaa aab aabba baab ab bba aaba a baaba</pre>
<p class="box-para">The first line shows the text, a line from <em>Alice’s Adventures in Wonderland</em>, where lowercase letters represent “a” and uppercase represent “b.” In practice, the font used for “a” letters would be almost, but not quite, the same as the font used for “b” letters. The actual Bacon cipher for each letter of the message is on the second line. To figure out the message, we organize the letters in groups of five like so:</p>
<div class="image"><img alt="Image" src="../images/f0040-01.jpg"/></div>
</div>
<h4 class="h4" id="ch00lev2_14"><em><strong>Fixed Offset</strong></em></h4>
<p class="noindent">During WWI, a German spy sent the following message from New York:</p>
<p class="bqpara">Apparently neutral’s protest is thoroughly discounted and ignored. Isman hard hit. Blockade issue affects pretext for embargo on by-products, ejecting suets and vegetable oils.</p>
<p class="indent">The missive contains a hidden message. Extracting the second letter of each word gives us:</p>
<p class="bqpara">Pershing sails from NY June 1.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_41"/>Note that we’re interpreting the final “i” as “1.” The message was useless in the end as Pershing sailed from New York on May 28.</p>
<p class="indent">While using the second letter is better than the first as it’s more challenging to accidentally spot the message, security is still low. However, this idea provides a starting point for hiding messages in a string of words. Let’s begin by developing a script to embed a text message using words from a <em>pool text</em>, a large text document from which we select words, and a selected letter offset from the beginning of each word. There is no randomness to this example, but it sets us up for the following experiment.</p>
<p class="indent">Here’s our approach:</p>
<ol>
<li class="noindent">Select a letter offset from the beginning of the word. The German spy used an offset of one for the second letter of each word. Recall that computer scientists use zero-based numbering, starting at 0 rather than 1.</li>
<li class="noindent">Hide a source message, text only, by selecting words from a pool text—for example, a book—such that the current letter of the word is the offset letter of the selected word.</li>
<li class="noindent">Write the resulting list of words to disk as the hidden message.</li>
</ol>
<p class="noindent">The source code we need is in <em>steg_simple.py</em>. I suggest reviewing it before continuing. Notice that the file does not import <span class="literal">RE</span>; there is nothing random here.</p>
<p class="indent">To learn how it works, here’s an example that hides the contents of <em>message.txt</em> using words selected from <em>alice.txt</em> with an offset of 2:</p>
<pre class="pre3">Three may keep a secret, if two of them are dead.</pre>
<p class="indent">Use the command line</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_simple.py encode 2 message.txt alice.txt output.txt</span></pre>
<p class="noindent">to produce the following in <em>output.txt</em>:</p>
<pre class="pre3">GET SCHOOLROOM VERY THERE ONE COME THAT SAYING LIKE THE
SHE HAPPENED THAT WAS THE NECK WORDS THE LITTLE ALICE
TOFFEE HOT NOW THOUGHT DOOR OFF INTO ASHAMED GREAT
MOMENT TEARS LARGE DEEP AND THE HEARD AND</pre>
<p class="indent">The offset is zero-based, meaning an offset of 0 uses the first letter, so an offset of 2 uses the third letter. With that in mind, we see the embedded message as:</p>
<pre class="pre3">GE<span class="underline">T</span> SC<span class="underline">H</span>OOLROOM VE<span class="underline">R</span>Y TH<span class="underline">E</span>RE ON<span class="underline">E</span> CO<span class="underline">M</span>E TH<span class="underline">A</span>T SA<span class="underline">Y</span>ING LI<span class="underline">K</span>E TH<span class="underline">E</span> SH<span class="underline">E</span> HA<span class="underline">P</span>PENED
TH<span class="underline">A</span>T WA<span class="underline">S</span> TH<span class="underline">E</span> NE<span class="underline">C</span>K WO<span class="underline">R</span>DS TH<span class="underline">E</span> LI<span class="underline">T</span>TLE AL<span class="underline">I</span>CE TO<span class="underline">F</span>FEE HO<span class="underline">T</span> NO<span class="underline">W</span> TH<span class="underline">O</span>UGHT DO<span class="underline">O</span>R
OF<span class="underline">F</span> IN<span class="underline">T</span>O AS<span class="underline">H</span>AMED GR<span class="underline">E</span>AT MO<span class="underline">M</span>ENT TE<span class="underline">A</span>RS LA<span class="underline">R</span>GE DE<span class="underline">E</span>P AN<span class="underline">D</span> TH<span class="underline">E</span> HE<span class="underline">A</span>RD AN<span class="underline">D</span></pre>
<p class="noindent">Every underlined letter of which is the message:</p>
<pre class="pre3">THREE MAY KEEP A SECRET IF TWO OF THEM ARE DEAD</pre>
<p class="indent"><span epub:type="pagebreak" id="page_42"/>First, <em>steg_simple.py</em> reads the message file, removes any characters that aren’t letters, and then uppercases the remaining characters. The result is a Python list of the words in the message. The pool text receives similar treatment.</p>
<p class="indent">Next, <em>steg_simple.py</em> processes each word of the message, letter by letter, scanning the pool text for words where the offset letter matches the current message letter. Each match is appended to the output list of words. When all message letters have been similarly processed, the output list is written to disk.</p>
<p class="indent">Changing the offset modifies the output list; for example, making it 3 in the previous listing results in the following:</p>
<pre class="pre3">SIT<span class="underline">T</span>ING NOT<span class="underline">H</span>ING THE<span class="underline">R</span>E ITS<span class="underline">E</span>LF LAT<span class="underline">E</span> SEE<span class="underline">M</span>ED STR<span class="underline">A</span>IGHT VER<span class="underline">Y</span> LOO<span class="underline">K</span> TRI<span class="underline">E</span>D
MAK<span class="underline">E</span> DRO<span class="underline">P</span> MAN<span class="underline">A</span>GED HER<span class="underline">S</span>ELF AFT<span class="underline">E</span>R WHI<span class="underline">C</span>H NEA<span class="underline">R</span> MIL<span class="underline">E</span>S SOR<span class="underline">T</span> LAT<span class="underline">I</span>TUDE ROO<span class="underline">F</span>
LIT<span class="underline">T</span>LE FLO<span class="underline">W</span>ERS THR<span class="underline">O</span>UGH THR<span class="underline">O</span>UGH HAL<span class="underline">F</span> ANO<span class="underline">T</span>HER WIT<span class="underline">H</span> WIS<span class="underline">E</span> THE<span class="underline">M</span> USU<span class="underline">A</span>LLY
CHE<span class="underline">R</span>RYTART PIN<span class="underline">E</span>APPLE SAI<span class="underline">D</span> LIK<span class="underline">E</span> CHE<span class="underline">A</span>TED FON<span class="underline">D</span></pre>
<p class="indent">Now that we’ve embedded the message, let’s get it back:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_simple.py decode 2 output.txt tmp.txt</span></pre>
<p class="indent">The <em>tmp.txt</em> file contains the following:</p>
<pre class="pre3">THREEMAYKEEPASECRETIFTWOOFTHEMAREDEAD</pre>
<p class="indent">We’ve lost punctuation and spaces, and the message is screaming at us in all caps, but it’s discernible.</p>
<p class="indent">Now let’s walk through the source code for this example. Both the input message and, if encoding, the pool file are run through <span class="literal">ProcessText</span> to remove non-letters and return a list of words, as shown in <a href="ch02.xhtml#ch02list01">Listing 2-1</a>.</p>
<pre class="pre">def ProcessText(s):
    s = s.upper().split()
    text = []
    for t in s:
        z = ""
        for c in t:
            if (c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
                z += c
        text.append(z)
    return text</pre>
<p class="list" id="ch02list01"><em>Listing 2-1: Converting a string of text to a list of words</em></p>
<p class="indent">The outer loop processes the list of words generated by the first line (<span class="literal">s</span>). This list still contains non-space characters. The inner loop over the characters of each word in <span class="literal">s</span> builds the letters-only version and appends it to <span class="literal">text</span>. When all is said and done, the function returns <span class="literal">text</span>.</p>
<p class="indent">The bottom of <em>steg_simple.py</em> interprets the command line according to the mode, encode or decode. The code is shown in <a href="ch02.xhtml#ch02list02">Listing 2-2</a>.</p>
<span epub:type="pagebreak" id="page_43"/>
<pre class="pre">offset = int(sys.argv[2])
if (sys.argv[1] == "encode"):
    sfile = sys.argv[3]
    pfile = sys.argv[4]
    dfile = sys.argv[5]
    Encode(offset, sfile, pfile, dfile)
elif (sys.argv[1] == "decode"):
    dfile = sys.argv[3]
    sfile = sys.argv[4]
    Decode(offset, dfile, sfile)
else:
    print("Unknown option")</pre>
<p class="list" id="ch02list02"><em>Listing 2-2: Parsing the command line</em></p>
<p class="noindent">All the action is in <span class="literal">Encode</span> and <span class="literal">Decode</span>. Let’s begin with <span class="literal">Encode</span>, as in <a href="ch02.xhtml#ch02list03">Listing 2-3</a>.</p>
<pre class="pre">def Encode(offset, sfile, pfile, dfile):
 <span class="ent">➊</span> msg = ProcessText(open(sfile).read())
    pool= ProcessText(open(pfile).read())
    enc = []
    idx = 0
 <span class="ent">➋</span> for word in msg:
        for c in word:
            done = False
            while (not done) and (idx &lt; len(pool)):
                if (len(pool[idx]) &lt;= offset):
                    pass
                elif (pool[idx][offset] != c):
                    pass
                else:
                    enc.append(pool[idx])
                    done = True
                idx += 1
 <span class="ent">➌</span> with open(dfile, "w") as f:
        f.write(" ".join(enc)+"\n")</pre>
<p class="list" id="ch02list03"><em>Listing 2-3: Encoding the message</em></p>
<p class="indent">First, <span class="literal">Encode</span> reads and processes both the message and pool text <span class="ent">➊</span>. Next comes a triply nested loop <span class="ent">➋</span>, first to process each word of the message (<span class="literal">msg</span>), then character by character (<span class="literal">c</span>), and lastly to search the pool text (<span class="literal">pool</span>) for a word where the offset character matches. The index into the pool text (<span class="literal">idx</span>) is set to zero initially and only ever incremented afterward, so the per-character search does not begin from the start each time but continues moving through the pool text file. In theory, this means the set of selected words is more diverse, as the same word is not selected repeatedly to match the same character of the message.</p>
<p class="indent"><span epub:type="pagebreak" id="page_44"/>After processing the entire message, <span class="literal">enc</span> contains the selected words in order. All that remains is to dump them to disk <span class="ent">➌</span>. Notice the Python idiom to convert a list of words into a single string by calling the <span class="literal">join</span> method on a string constant (a space) before appending a final newline character.</p>
<p class="indent">Decoding a message is less involved, as shown in <a href="ch02.xhtml#ch02list04">Listing 2-4</a>.</p>
<pre class="pre">def Decode(offset, dfile, sfile):
    enc = ProcessText(open(dfile).read())
    plain = ""
    for w in enc:
        plain += w[offset]
    with open(sfile, "w") as f:
        f.write(plain+"\n")</pre>
<p class="list" id="ch02list04"><em>Listing 2-4: Decoding the message</em></p>
<p class="indent"><span class="literal">Decode</span> processes the encoded message file to make a list of words (<span class="literal">enc</span>). Then the function examines each word, extracts the <span class="literal">offset</span> letter, and adds it to <span class="literal">plain</span>, the output string. Finally, <span class="literal">Decode</span> dumps the output string to the decoded message file.</p>
<h4 class="h4" id="ch00lev2_15"><em><strong>Random Offset</strong></em></h4>
<p class="noindent">The previous experiment works, but it’s not too difficult to defeat. A bit of trial and error will locate the offset and reveal the hidden message. We can do slightly better by changing the offset at random so that the third letter of the first word is important, the fifth letter of the second, the first followed by the third again, and so on. The result is still not particularly secure but is likely to confound accidental discovery of the message.</p>
<p class="indent">The file <em>steg_text.py</em> implements this approach and introduces us to a technique we’ll use throughout the remainder of the chapter, namely using a randomness engine with a fixed seed to generate a deterministic sequence of randomly selected offsets. Let’s take a look at what this approach buys us.</p>
<p class="indent">First, we run <em>steg_text.py</em> on the same input message as the quotation about not sharing secrets. In this case, the command line is:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_text.py message.txt alice.txt output.txt</span>
Your secret key is 499377</pre>
<p class="noindent">Take note of the “secret key,” which is, in reality, a pseudorandom number generator seed. We won’t be able to recover the hidden message without it.</p>
<p class="indent">Each run of <em>steg_text.py</em> produces a new <em>output.txt</em> and secret key. For the previous run, <em>output.txt</em> became:</p>
<pre class="pre3">I<span class="underline">T</span> W<span class="underline">H</span>AT THE<span class="underline">R</span>E TH<span class="underline">E</span> H<span class="underline">E</span>AR SEE<span class="underline">M</span>ED N<span class="underline">A</span>TURAL VER<span class="underline">Y</span> S<span class="underline">K</span>URRIED H<span class="underline">E</span> ALIC<span class="underline">E</span> U<span class="underline">P</span>
DE<span class="underline">A</span>R THI<span class="underline">S</span> DIFF<span class="underline">E</span>RENT VOI<span class="underline">C</span>E C<span class="underline">R</span>OCODILE WAT<span class="underline">E</span>RS I<span class="underline">T</span> THE<span class="underline">I</span>R BE<span class="underline">F</span>ORE THA<span class="underline">T</span>
RAIL<span class="underline">W</span>AY WO<span class="underline">O</span>DEN SO<span class="underline">O</span>N HAL<span class="underline">F</span> SI<span class="underline">T</span>S CATC<span class="underline">H</span>ING TH<span class="underline">E</span> TRE<span class="underline">M</span>BLING T<span class="underline">A</span>IL YOUA<span class="underline">R</span>E
W<span class="underline">E</span>NT HUN<span class="underline">D</span>RED TH<span class="underline">E</span> ANIM<span class="underline">A</span>LS BIR<span class="underline">D</span>S</pre>
<span epub:type="pagebreak" id="page_45"/><p class="noindent">This corresponds to per-word offsets of:</p>
<pre class="pre3">1132131311412343131323422324231413243
THREEMAYKEEPASECRETIFTWOOFTHEMAREDEAD</pre>
<p class="noindent">The offsets are selected pseudorandomly using the reported seed, which here is 499,377.</p>
<p class="indent">To recover the original message, use:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_text.py 499377 output.txt tmp.txt</span>
&gt; <span class="codestrong1">cat tmp.txt</span>
THREEMAYKEEPASECRETIFTWOOFTHEMAREDEAD</pre>
<p class="indent">With <em>steg_text.py</em>, the output is harder to parse because the offsets are random. If we knew there was a hidden message, it would require effort to recover it because of the many paths through the letters of each word. For example, <a href="ch02.xhtml#ch02fig01">Figure 2-1</a> shows every path through the first three words, for a total of 40 combinations.</p>
<div class="image"><img alt="Image" id="ch02fig01" src="../images/02fig01.jpg"/></div>
<p class="figcap"><em>Figure 2-1: All the paths through the first three words</em></p>
<p class="indent">Each combination is as follows:</p>
<div class="image1"><img alt="Image" src="../images/f0045-01.jpg"/></div>
<p class="noindent">The combinations ITH, ITE, TWE, THE, THR, TAR, TAH are the only possible beginnings of common English words, for example: Ithaca, item, tweet, theme, three, tarnish, and tahini. The fourth word, THE, adds one more letter to each of the existing prefixes, of which only THRE and TART seem plausible. The following word, HEAR, makes it clear that the first word of the message is likely THREE or the beginning of the next word after TART, assuming the message isn’t itself encrypted.</p>
<p class="indent">The source code for this example is similar to <em>steg_simple.py</em> and uses the same <span class="literal">ProcessText</span> function shown in <a href="ch02.xhtml#ch02list01">Listing 2-1</a>. The important parts for us are the encoder and decoder functions. Let’s start with the encoder, shown in <a href="ch02.xhtml#ch02list05">Listing 2-5</a>.</p>
<span epub:type="pagebreak" id="page_46"/>
<pre class="pre">def Encode(mfile, pfile, ofile):
    msg = ProcessText(open(mfile).read())
    pool= ProcessText(open(pfile).read())
  <span class="ent">➊</span> key = RE(mode='int', low=10000, high=1000000).random()
    rng = RE(mode='int', low=1, high=5, seed=key)
    enc = []
    idx = 0
    for word in msg:
        for c in word:
         <span class="ent">➋</span> offset = rng.random()
            done = False
            while (not done) and (idx &lt; len(pool)):
                if (len(pool[idx]) &lt;= offset):
                    pass
                elif (pool[idx][offset] != c):
                    pass
                else:
                    enc.append(pool[idx])
                    done = True
                idx += 1
    with open(ofile, "w") as f:
        f.write(" ".join(enc)+"\n")
 <span class="ent">➌</span> print("Your secret key is %d" % key)</pre>
<p class="list" id="ch02list05"><em>Listing 2-5: Encoding with random offsets</em></p>
<p class="indent">As with <em>steg_simple.py</em>, the message and pool files are loaded and processed. The secret key is selected using the default randomness engine, PCG64 <span class="ent">➊</span>. With <span class="literal">key</span> in hand, a new generator is initialized with <span class="literal">key</span> as the seed (<span class="literal">rng</span>).</p>
<p class="indent">Each letter of the message is encoded by searching the pool for a matching word, but this time, the generator <span class="ent">➋</span> returns the <span class="literal">offset</span> to use. After all message letters have been processed, the function writes the final output file and reports the secret key <span class="ent">➌</span>. Compare <a href="ch02.xhtml#ch02list05">Listing 2-5</a> with <a href="ch02.xhtml#ch02list03">Listing 2-3</a>; the fixed <span class="literal">offset</span> is now replaced by a randomly generated one.</p>
<p class="indent">The decoder is shown in <a href="ch02.xhtml#ch02list06">Listing 2-6</a>.</p>
<pre class="pre">def Decode(key, ofile, mfile):
    enc = ProcessText(open(ofile).read())
    rng = RE(mode='int', low=1, high=5, seed=key)
    plain = ""
    for w in enc:
        plain += w[rng.random()]
    with open(mfile, "w") as f:
        f.write(plain+"\n")</pre>
<p class="list" id="ch02list06"><em>Listing 2-6: Decoding with random offsets</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_47"/>The secret key forms the seed for the generator; then, the message is decoded word by word using the next value from the generator before writing the message to disk.</p>
<p class="indent">Some may object at this point as the experiments select words that, while actual words, do not form a meaningful sentence, which might tip off an adversary. I agree. My defense is that a simple program cannot generate a meaningful sentence, but we are still embedding a message and therefore following the spirit of steganography, if not the absolute law of it. Fear not; experiments later in the chapter produce unambiguous results.</p>
<p class="indent">Steganography with text is merely a warm-up exercise, as we can make better use of what the digital age offers. So let’s leave text behind and progress to hiding arbitrary files in other files.</p>
<h3 class="h3" id="ch00lev1_13"><strong>In Random Data</strong></h3>
<p class="noindent">In <a href="ch01.xhtml">Chapter 1</a>, we used <span class="literal">ent</span> as a tool to help us decide whether a file contains random data. Here we’ll embed an arbitrary file inside a file of random data so that tools like <span class="literal">ent</span> still lead us to believe the file contains random data, even though it no longer does. This is true steganography in that the file appears random both before and after embedding the data we wish to hide.</p>
<p class="indent">To accomplish our goal, we need to think in terms of bits, not characters and words. The file we want to hide, as well as the pool file, is merely a stream of bits; we don’t care what those bits represent. The idea, then, is to randomly scatter the bits of the source file throughout the bits of the pool file.</p>
<p class="indent">For example, if we want to hide source bits 11011011 in</p>
<p class="center">110101011000101010010110101011001010010111</p>
<p class="noindent">then we need to scatter the bits randomly</p>
<p class="center">110<span class="underline">1</span>0101100<span class="underline">1</span>101010010<span class="underline">0</span><span class="underline">1</span>01010<span class="underline">1</span>10<span class="underline">0</span>1<span class="underline">1</span>100101<span class="underline">1</span>1</p>
<p class="noindent">in such a way that we can recover the random bit positions later on to reconstruct the original file.</p>
<p class="indent">This approach works if the pool file is substantially larger than the file we wish to hide. For any source bit, the probability that the pool file bit we select is already the same value is 50 percent because we assume the pool file to be random. Therefore, with enough pool file bits and random placement of the source file bits, we don’t expect most tools like <span class="literal">ent</span> to pick up that the file has been modified. However, the proper ratio between hidden bits and pool file bits is difficult to ascertain. Fewer hidden bits are better, but how many can we insert until they become noticeable? We’ll perform a simple experiment shortly to try to figure out the answer.</p>
<p class="indent">We’re almost ready to think about coding. Our plan is to randomly scatter the source file bits throughout the bits of the pool file. We can get the random bit positions by using <span class="literal">RE</span> with a fixed seed value to generate a sequence of random offset values, one for each source bit.</p>
<p class="indent">But while we can undoubtedly encode the source file with what we have, can we get it back? How many bits do we read out of the encoded file? We <span epub:type="pagebreak" id="page_48"/>don’t know how long the source file was, so we need to encode not only the source file but also its length.</p>
<p class="indent">For example, if the source file is 10,356 bytes long, we need to encode not only all 8 × 10,356 = 82,848 bits of the file but also the number of bytes we encoded. We’ll use 32 bits to encode the file length, so we will encode 82,848 + 32 = 82,880 bits, the first 32 representing the encoded file length in bytes. Then, to recover the file, we read 32 bits and form the length to know how many additional bits to extract.</p>
<p class="indent">Let’s lay out the steps. To encode a file:</p>
<ol>
<li class="noindent">Read the source file and convert it to a list of bits.</li>
<li class="noindent">Prepend the list of bits by the 32 bits from the length of the source file.</li>
<li class="noindent">Read the pool file and convert it to a list of bits.</li>
<li class="noindent">Generate a random list of offset positions, one for each source bit, using the supplied key as the seed.</li>
<li class="noindent">Set the pool bit at each offset position to the corresponding source bit value.</li>
<li class="noindent">Convert the pool bits back to a set of bytes and write them to disk.</li>
</ol>
<p class="noindent">To decode a file:</p>
<ol>
<li class="noindent">Read the encoded file and convert it to a list of bits.</li>
<li class="noindent">Generate 32 offset positions using the supplied key as the seed.</li>
<li class="noindent">Calculate the file length and number of bits to read.</li>
<li class="noindent">Generate offset positions for that many bits.</li>
<li class="noindent">Collect the bits at those positions and convert them to bytes.</li>
<li class="noindent">Write the bytes to disk as the extracted file.</li>
</ol>
<p class="indent">It seems complicated, and there is some accounting to keep track of, but in the end it’s straightforward: we’ll randomly scatter the source file bits throughout the pool file and then collect them to extract the source file.</p>
<p class="indent">Before we get to the code, we’ll first learn how to run it so you can experiment. To use the code, we need a file to embed and a pool file. The book’s GitHub repository contains <em>RandomDotOrg_sm.bin</em>, a 5MB file of random data from <em><a href="http://random.org">random.org</a></em> that is used with permission. It will be the pool file for this example. As we can see, <span class="literal">ent</span> likes this file:</p>
<pre class="pre">entropy: 7.999969
chi2   : 84.34
mean   : 127.4992
pi     : 3.140270649 (0.04)
corr   : 0.000322</pre>
<p class="indent">As for the source file, look in the directory <em>test_images</em>, which contains a collection of standard image-processing test images of various types and <span epub:type="pagebreak" id="page_49"/>sizes. We’ll use these again later in the chapter when we experiment with hiding files in images. Presently, we want <em>boat.png</em>, shown in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a>.</p>
<div class="image"><img alt="Image" id="ch02fig02" src="../images/02fig02.jpg"/></div>
<p class="figcap"><em>Figure 2-2: The boat image</em></p>
<p class="indent">The code we need is in <em>steg_random.py</em>. To encode a file, use a command line like this:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_random.py 12345 test_images/boat.png output.bin data/RandomDotOrg_sm.bin</span></pre>
<p class="noindent">The code takes about 30 seconds to run. When it finishes, the <em>output.bin</em> file contains the hidden image. Does <span class="literal">ent</span> still like this file? It does:</p>
<pre class="pre">entropy: 7.999969
chi2   : 86.38
mean   : 127.4903
pi     : 3.140005417 (0.05)
corr   : 0.000403</pre>
<p class="indent">To recover the image, run <em>steg_random.py</em> a second time using the same key (12345):</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_random.py 12345 output.bin tmp.png</span></pre>
<p class="noindent">The file <em>tmp.png</em> now contains the boat image.</p>
<p class="indent">The code in <em>make_random.py</em> generates files of random bytes using the random number generators available in the <span class="literal">RE</span> class. I recommend using this <span epub:type="pagebreak" id="page_50"/>code to create pool files for your experiments. For example, use the following to generate a file of 5 million bytes using the Mersenne Twister:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 make_random.py 5000000 none mt19937.bin mt19937</span></pre>
<p class="noindent">As with most programs, running <em>make_random.py</em> without arguments tells us how to use the code.</p>
<h4 class="h4" id="ch00lev2_16"><em><strong>How Much Can You Hide?</strong></em></h4>
<p class="noindent">Let’s try to figure out how many bits we can hide before tools like <span class="literal">ent</span> give suspicious results. To do so, we need the code in <em>steg_random_test.py</em>. I’ll let you read the code; it’s a simple script that does the following:</p>
<ol>
<li class="noindent">Uses <em>make_random.py</em> to make a random file of 10 million bytes</li>
<li class="noindent">Uses <em>steg_random.py</em> to embed ever-larger files that are nothing but the letter <em>A</em> repeated</li>
<li class="noindent">Runs <span class="literal">ent</span> on the result and extracts the estimated value of <em>π</em></li>
<li class="noindent">Plots the estimate of <em>π</em> as a function of the embedded file size</li>
</ol>
<p class="indent">Repeating the letter <em>A</em> creates a file that is the antithesis of random; it’s as nonrandom as possible, with an entropy of zero. Therefore, it’s the worst possible file to embed, which will have the most negative effect on the output. There’s nothing special about the letter <em>A</em>; any single-byte value will do.</p>
<p class="indent"><a href="ch02.xhtml#ch02fig03">Figure 2-3</a> shows the result.</p>
<div class="image"><img alt="Image" id="ch02fig03" src="../images/02fig03.jpg"/></div>
<p class="figcap"><em>Figure 2-3: The effect on the estimate of π when embedding ever-larger files of</em> A <em>repeated</em></p>
<p class="indent">There’s a linear relationship between the estimate of <em>π</em> and the embedded number of <em>A</em>s. The pool file on its own gives an estimate that is 0.01 percent off, which is good. Hiding 50,000 <em>A</em>s bumps the error to <span epub:type="pagebreak" id="page_51"/>0.05 percent, which is also not likely to raise eyebrows. However, 100,000 <em>A</em>s changes the error to 0.5 percent, which is starting to look suspicious.</p>
<p class="indent">Since the pool file had 10 million bytes, 100,000 bytes is equal to 10<sup>5</sup>/10<sup>7</sup> = 0.01 = 1 percent, implying that hiding files that are less than 1 percent the size of the pool file should, in general, result in an output file that won’t be noticed.</p>
<p class="indent">For example, <a href="ch02.xhtml#ch02tab01">Table 2-1</a> shows the estimated π values from <span class="literal">ent</span> for a pool file (using <span class="literal">urandom</span>) of 10 million bytes along with the output of <em>steg_random.py</em> when hiding 100,000 bytes that are all <em>A</em>s, the first 100,000 characters of <em>alice.txt</em>, or another random file of bytes using <span class="literal">RDRAND</span>.</p>
<p class="tabcap" id="ch02tab01"><strong>Table 2-1:</strong> Estimated π Values by Hidden File Type</p>
<table class="table-h">
<colgroup>
<col style="width:60%"/>
<col style="width:40%"/>
</colgroup>
<thead>
<tr>
<th class="tab_th"><strong>Hidden file type</strong></th>
<th class="tab_th"><strong>Estimated <em>π</em> values</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="bg1"><span class="literal">urandom</span> pool</td>
<td class="bg1">3.142167657 (0.02%)</td>
</tr>
<tr>
<td class="bg">Hide <span class="literal">RDRAND</span></td>
<td class="bg">3.142429257 (0.03%)</td>
</tr>
<tr>
<td class="bg1">Hide <em>alice.txt</em></td>
<td class="bg1">3.146091658 (0.14%)</td>
</tr>
<tr>
<td class="bg">Hide <em>A</em>s</td>
<td class="bg">3.157525263 (0.51%)</td>
</tr>
</tbody>
</table>
<p class="indent">These results hint that, for a hidden file that’s 1 percent the size of the pool file, we should expect a tool like <span class="literal">ent</span> to show a slight increase in metrics related to nonrandomness, like a larger error in estimating <em>π</em>. Note that <em>alice.txt</em> is a text file, so we can expect a binary file to do even better. The moral of the story is: hide your data in a random file that is at least 100 times larger than the data itself.</p>
<p class="indent">Now let’s take a look at the code.</p>
<h4 class="h4" id="ch00lev2_17"><em><strong>The steg_random.py Code</strong></em></h4>
<p class="noindent">The code in <em>steg_random.py</em> is slightly more complex than the code we’ve used so far. I suggest reviewing <em>steg_random.py</em> before continuing. You’ll see two utility functions, <span class="literal">MakeBit</span> and <span class="literal">MakeByte</span>. We’ll use these functions here and in the following sections, so we’ll define them before moving on to the encode and decode functions.</p>
<h5 class="h5"><strong>Converting Between Bits and Bytes</strong></h5>
<p class="noindent">We intend to work with bits and bytes, so it helps to have functions that convert between the two. This is the point of <span class="literal">MakeBit</span> and <span class="literal">MakeByte</span>. <a href="ch02.xhtml#ch02list07">Listing 2-7</a> shows <span class="literal">MakeBit</span>.</p>
<pre class="pre">def MakeBit(byt):
    b = np.zeros(8*len(byt), dtype="uint8")
    k = 0 
    for v in byt:
        s = format(v, "08b")
        for c in s:
            b[k] = int(c)
            k += 1
    return b</pre>
<span epub:type="pagebreak" id="page_52"/>
<p class="list" id="ch02list07"><em>Listing 2-7: Converting bytes to bits</em></p>
<p class="indent">The argument (<span class="literal">byt</span>) is an array of bytes that we want to turn into an output array of bits (<span class="literal">b</span>). There are eight bits per byte, so we define <span class="literal">b</span> up front and then fill it in by processing the bytes in <span class="literal">byte</span> one by one using the <span class="literal">for</span> loop.</p>
<p class="indent">For each byte, we ask Python to convert it to a binary string (<span class="literal">s</span>), being careful to insist on leading zeros. Then, we place each bit into the output array using an ever-increasing index (<span class="literal">k</span>) before returning to the caller.</p>
<p class="indent">We also need to convert an array of bits back to an array of bytes; <span class="literal">MakeByte</span> is shown in <a href="ch02.xhtml#ch02list08">Listing 2-8</a>.</p>
<pre class="pre">def MakeByte(b):
    n = len(b)//8
    t = b.reshape((n,8))
    byt = np.zeros(n, dtype="uint8")
    for i in range(n):
        v = (t[i] * np.array([128,64,32,16,8,4,2,1])).sum()
        byt[i] = v
    return byt</pre>
<p class="list" id="ch02list08"><em>Listing 2-8: Converting bits to bytes</em></p>
<p class="indent">The argument is an array of bits (<span class="literal">b</span>), so its length will be a multiple of eight. Therefore, <span class="literal">n</span> is the number of bytes we need in the output array. To get the bytes, we first reshape <span class="literal">b</span> to group every eight bits. In other words, if the array is a vector of 32 bits</p>
<pre class="pre">11010101001011101101011001010100</pre>
<p class="noindent">it becomes</p>
<pre class="pre">11010101
00101110
11010110
01010100</pre>
<p class="noindent">in <span class="literal">t</span>, a 4×8 array of bits representing 4 bytes.</p>
<p class="indent">Next, we multiply each row of <span class="literal">t</span> by the vector representing the place value of each bit in a byte. Finally, we sum the resulting vector to give the actual byte value (<span class="literal">v</span>), which we place into the output array, <span class="literal">byt</span>.</p>
<p class="indent">Now, let’s learn how to hide bits in a random file.</p>
<h5 class="h5"><strong>Encoding a File</strong></h5>
<p class="noindent">Encoding a file is accomplished by the cleverly named <span class="literal">Encode</span> function:</p>
<span epub:type="pagebreak" id="page_53"/>
<pre class="pre">def Encode(key, sfile, dfile, pfile):
    src = np.fromfile(sfile, dtype="uint8")
    s = format(len(src), "08x")
    b3 = int(s[0:2],16);  b2 = int(s[2:4],16)
    b1 = int(s[4:6],16);  b0 = int(s[6:8],16)
    src = MakeBit(np.hstack(([b3,b2,b1,b0],src)))

    step = RE(mode="int", low=1, high=16, seed=key).random(len(src))
    idx = [step[0]]
    for i in range(1, len(step)):
        idx.append(idx[-1]+step[i])

    pool = MakeBit(np.fromfile(pfile, dtype="uint8"))
    if (len(pool) &lt;= idx[-1]):
        print("Pool file is too small")
        exit(1)

    for i in range(len(src)):
        pool[idx[i]] = src[i]

    dest = MakeByte(pool)
    dest.tofile(dfile)</pre>
<p class="noindent">Our goal is to randomly scatter the bits of the source file (<span class="literal">sfile</span>) among the bits of the pool file (<span class="literal">pfile</span>) and dump the result to the destination file (<span class="literal">dfile</span>). The seed for the generator is in <span class="literal">key</span>.</p>
<p class="indent">In the first code paragraph, we read the source file into an array of bytes (<span class="literal">src</span>). As discussed previously, we also need to encode the length of the file, which we do by representing the number of bytes as a hexadecimal string (<span class="literal">s</span>). We’re using an unsigned 32-bit integer as the file length, so we can only hide files less than 4,294,967,296 bytes. That shouldn’t be a problem for us. The individual bytes representing the length are extracted from <span class="literal">s</span> and interpreted as hexadecimal numbers from the most significant (<span class="literal">b3</span>) down to the least (<span class="literal">b0</span>). As <span class="literal">src</span> is still a vector of bytes, we add the 4 bytes of the length to the beginning using NumPy’s <span class="literal">hstack</span> function. Finally, we use <span class="literal">MakeBit</span> to convert <span class="literal">src</span> to a vector of bits.</p>
<p class="indent">In the second code paragraph, we construct <span class="literal">idx</span>, a vector of ever-increasing offsets, one per bit of <span class="literal">src</span>. These are the positions in the pool that will be updated with <span class="literal">src</span>’s bit values. First, <span class="literal">step</span> is a vector of offsets from a low of 1 to a high of 15 bits. Note the use of <span class="literal">key</span> to set the seed. The <span class="literal">idx</span> vector is constructed from the offsets by adding each offset to the last element of <span class="literal">idx</span> before appending the new offset to <span class="literal">idx</span>.</p>
<p class="indent">The third paragraph reads the pool file as a vector of bits (<span class="literal">pool</span>). If the pool file is too short to accommodate all the bit offset positions in <span class="literal">idx</span>, the program delivers a terse message and abruptly ends.</p>
<p class="indent">At this point, we have all we need: <span class="literal">src</span> as bits, <span class="literal">pool</span> as bits, and <span class="literal">idx</span> telling us where the bits of <span class="literal">src</span> go. Therefore, the fourth paragraph is a simple loop <span epub:type="pagebreak" id="page_54"/>setting the proper bit of <span class="literal">pool</span> to the corresponding bit of <span class="literal">src</span>. We march through <span class="literal">src</span> sequentially, and <span class="literal">idx</span> likewise, but the values in <span class="literal">idx</span> are the positions in <span class="literal">pool</span> that get updated.</p>
<p class="indent">The final paragraph converts the now updated <span class="literal">pool</span> into a vector of bytes and writes it to the destination file (<span class="literal">dfile</span>).</p>
<p class="indent">We can officially encode a file; now let’s get it back.</p>
<h5 class="h5"><strong>Decoding a File</strong></h5>
<p class="noindent">Decoding a file uses the similarly named <span class="literal">Decode</span> function:</p>
<pre class="pre">def Decode(key, sfile, dfile):
    src = MakeBit(np.fromfile(sfile, dtype="uint8"))

    rng = RE(mode="int", low=1, high=16, seed=key)
    step = rng.random(32)
    bits = []
    idx = [step[0]]
    for i in range(1, len(step)):
        idx.append(idx[-1]+step[i])
    for i in range(len(idx)):
        bits.append(src[idx[i]])
    n = MessageLength(bits)

    offset = idx[-1]
    step = rng.random(8*n)
    idx = [offset + step[0]]
    bits = []
    for i in range(1, len(step)):
        idx.append(idx[-1]+step[i])
    for i in range(len(idx)):
        bits.append(src[idx[i]])
    dest = MakeByte(np.array(bits))
    dest.tofile(dfile)</pre>
<p class="indent">Here, <span class="literal">sfile</span> is the name of the file generated by <span class="literal">Encode</span> and <span class="literal">dfile</span> is the name of the desired output file. Note that <span class="literal">key</span> must match the value used to encode.</p>
<p class="indent">The code first reads the encoded file and immediately converts it to a vector of bits (<span class="literal">src</span>).</p>
<p class="indent">In the following code paragraph, the properly seeded generator is created (<span class="literal">rng</span>). Notice the <span class="literal">RE</span> instantiation: integer, default PCG64 generator, low of 1 and high of 15, with the seed. This is the configuration used for encoding, as it must be.</p>
<p class="indent">The first 32 encoded bits are extracted by adding the 32 values in <span class="literal">step</span> to each final offset in <span class="literal">idx</span>, as for <span class="literal">Encode</span>. The resulting <span class="literal">bits</span> are passed to the helper function, <span class="literal">MessageLength</span>, as in <a href="ch02.xhtml#ch02list09">Listing 2-9</a>.</p>
<span epub:type="pagebreak" id="page_55"/>
<pre class="pre">def MessageLength(bits):
    b = MakeByte(np.array(bits))
    n = 256**3*b[0] + 256**2*b[1] + 256*b[2] + b[3]
    return n</pre>
<p class="list" id="ch02list09"><em>Listing 2-9: Converting 32 bits to an unsigned integer</em></p>
<p class="noindent">This function makes the 32-bit vector a vector of 4 bytes (<span class="literal">b</span>); multiplies each byte, highest-order byte first, by the proper place value; and sums to get the actual encoded file length in bytes (<span class="literal">n</span>). Working with the bytes of the 32-bit value is the same as treating it like a base-256 number, hence the exponents on 256.</p>
<p class="indent">In the final paragraph, the bit positions for the remainder of the encoded file are calculated from <span class="literal">step</span> and <span class="literal">idx</span> as before, but we need to add the extra offset to account for the 32 bits already read. Once <span class="literal">idx</span> is constructed, it is immediately used to extract the <span class="literal">bits</span>. All bits collected are converted to bytes (<span class="literal">dest</span>) and finally dumped to the output file (<span class="literal">dfile</span>).</p>
<p class="indent">Whew! Much is happening in <em>steg_random.py</em>. Thankfully, most of it transfers to the remaining two sections of this chapter, where we hide data in audio files and images. Let’s learn to whisper carefully so that no one hears us unless we want them to.</p>
<h3 class="h3" id="ch00lev1_14"><strong>In an Audio File</strong></h3>
<p class="noindent">Digital audio is ubiquitous and a natural target for steganography. This section explores how to embed files in digital audio, specifically WAV files. Our approach is similar to the previous section: we’ll scatter the bits of the file across the digital samples. However, instead of altering random bits, we’ll alter the least-significant bit to minimize the impact and make the message essentially silent.</p>
<p class="indent">The file we need is <em>steg_audio.py</em>. Be sure to review the file before proceeding. You’ll notice it uses <span class="literal">MakeBit</span> and <span class="literal">MakeByte</span>, which we have worked with before—see <a href="ch02.xhtml#ch02list07">Listings 2-7</a> and <a href="ch02.xhtml#ch02list08">2-8</a>, respectively. Likewise, you’ll also see <span class="literal">MessageLength</span> (<a href="ch02.xhtml#ch02list09">Listing 2-9</a>).</p>
<p class="indent">We discussed digital sampling in <a href="ch01.xhtml">Chapter 1</a> when generating random bits from the microphone input. At that time, we wanted 32-bit floating-point samples. Here, we’ll use more common signed 16-bit samples in the range [–32,768, 32,767]. Such samples use two bytes each. We’ll restrict ourselves to changing only the least-significant bit, thereby altering the sample value by at most 1, which no one will hear.</p>
<p class="indent">WAV files are not compressed and, therefore, might be rather large. Most internet audio is in the form of MP3s, which employ <em>lossy compression</em>. The human auditory system doesn’t need all the information in raw audio samples—about 90 percent or so can be discarded, which is the “loss.” However, as we’re planning on using the simplest of audio steganography approaches, and our hidden file will be lost if the file is converted to an MP3, we must use the full WAV file. There are more sophisticated types of audio <span epub:type="pagebreak" id="page_56"/>steganography that employ characters, like echoes, that survive the compression process, but this is out of the scope of this book.</p>
<p class="indent">The algorithm’s needs are quite close to that of the previous section:</p>
<ol>
<li class="noindent">Read the source file and convert it to bits along with the file length in bytes.</li>
<li class="noindent">Read the original WAV file, ensure the source file will fit, and work with only one channel if it’s stereo.</li>
<li class="noindent">Generate a random but ever-increasing list of indices into the WAV samples, one for each bit of the source file.</li>
<li class="noindent">Alter bit 0 of the selected samples to match the corresponding source file bit.</li>
<li class="noindent">Write the altered samples to a new audio file.</li>
</ol>
<p class="indent">We’ll first use the code to hide files, then we’ll explore the code itself.</p>
<h4 class="h4" id="ch00lev2_18"><em><strong>A Quiet Live Performance</strong></em></h4>
<p class="noindent">Let’s play around with <em>steg_audio.py</em> before walking through the code. The book’s GitHub repository includes several sample WAV files courtesy of composer Paul Kneusel (<em><a href="https://www.paulkneusel.com">https://www.paulkneusel.com</a></em>). First, let’s hide an image in <em>Fireflies</em>, a live performance in 2016 by pianist Kristen Kosey. <em>Fireflies</em> is a quiet piece, thereby increasing the probability that we’ll hear any effect from altering the samples. Here’s the command line:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_audio.py 2718281828 test_images/tulips_gray.png tmp.wav Fireflies.wav</span>
Using 3712480 samples to store the file</pre>
<p class="indent">First, we supply the secret key, 2718281828, then the file to embed, <em>tulips_gray.png</em>, followed by the output filename, <em>tmp.wav</em>, and finally the source WAV file, <em>Fireflies.wav</em>. The code informs us that it used 3,712,480 samples to store the bits of <em>tulips_gray.png</em>. Bonus points for readers who recognize the secret key.</p>
<p class="indent">As before, we recover the hidden file with the same code:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_audio.py 2718281828 tmp.wav tmp.png</span></pre>
<p class="noindent">This produces <em>tmp.png</em>, the original image file shown in <a href="ch02.xhtml#ch02fig04">Figure 2-4</a>.</p>
<span epub:type="pagebreak" id="page_57"/>
<div class="image"><img alt="Image" id="ch02fig04" src="../images/02fig04.jpg"/></div>
<p class="figcap"><em>Figure 2-4: The recovered image</em></p>
<p class="indent">Play the output file, <em>tmp.wav</em>. Listen closely and try to hear the difference between <em>tmp.wav</em> and the original <em>Fireflies.wav</em>. The image file is well-hidden and utterly imperceptible. This is steganography as it should be: unnoticed.</p>
<p class="indent">Okay, <em>steg_audio.py</em> works, but what did it really do? We need to change the least-significant bit of each sample to match the corresponding bit of the file we’re hiding. Let’s look at the first eight bits of <em>tulips_gray.png</em> along with the corresponding sample offsets and the samples themselves, as in <a href="ch02.xhtml#ch02tab02">Table 2-2</a>.</p>
<p class="tabcap" id="ch02tab02"><strong>Table 2-2:</strong> The First Eight Bits of <em>tulips_gray.png</em> with Offsets and Samples</p>
<table class="table-h">
<colgroup>
<col style="width:10%"/>
<col style="width:15%"/>
<col style="width:15%"/>
<col style="width:10%"/>
<col style="width:15%"/>
<col style="width:10%"/>
<col style="width:10%"/>
<col style="width:15%"/>
</colgroup>
<thead>
<tr>
<th class="tab_th"> </th>
<th class="tab_th"><strong>0</strong></th>
<th class="tab_th"><strong>1</strong></th>
<th class="tab_th"><strong>2</strong></th>
<th class="tab_th"><strong>3</strong></th>
<th class="tab_th"><strong>4</strong></th>
<th class="tab_th"><strong>5</strong></th>
<th class="tab_th"><strong>6</strong></th>
<th class="tab_th"><strong>7</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="bg1"><strong>Bits</strong></td>
<td class="bg1">1</td>
<td class="bg1">0</td>
<td class="bg1">0</td>
<td class="bg1">0</td>
<td class="bg1">1</td>
<td class="bg1">0</td>
<td class="bg1">0</td>
<td class="bg1">1</td>
</tr>
<tr>
<td class="bg"><strong>Offsets</strong></td>
<td class="bg">35</td>
<td class="bg">36</td>
<td class="bg">50</td>
<td class="bg">68</td>
<td class="bg">85</td>
<td class="bg">90</td>
<td class="bg">92</td>
<td class="bg">99</td>
</tr>
<tr>
<td class="bg1"><strong>Samples</strong></td>
<td class="bg1">65,533</td>
<td class="bg1">5</td>
<td class="bg1">7</td>
<td class="bg1">65,532</td>
<td class="bg1">65,535</td>
<td class="bg1">65,532</td>
<td class="bg1">5</td>
<td class="bg1">65,534</td>
</tr>
</tbody>
</table>
<p class="indent">Sample 35 has value 65,533, and we want the least-significant bit of sample 35 to be a 1. Likewise, sample 36 is 5, and we want its least-significant bit to be a 0, and so on.</p>
<p class="indent">We previously discussed that WAV files use signed 16-bit integers in the range [–32,768, 32,767]. This is true, but when we read the audio samples, we interpret them as unsigned integers in the range [0, 65,535] instead to avoid working with negative numbers. We’ll change the interpretation back to signed 16-bit integers before writing the output WAV file.</p>
<p class="indent"><span epub:type="pagebreak" id="page_58"/>We want sample 35, currently 65,533, to be such that the first bit is a 1. We have a few options to accomplish this. For one, we can use low-level bit operations. But notice that when bit 0 of an integer is a 1 the number is odd, and when it’s a 0 the number is even. In this case, 65,533 is odd, meaning bit 0 is already a 1, so we leave the sample as is.</p>
<p class="indent">The second sample is currently a 5, but we want bit 0 to be a 0. As 5 is an odd number, we subtract 1 to make the new sample value a 4 with bit 0 a 0, as desired. This process repeats for each bit of the file we’re hiding. Either the sample’s least-significant bit is already correct, or it’s off by one, requiring us to add or subtract 1. To summarize: we add 1 only if we need the sample to be an odd number; likewise, we subtract 1 only if we want the sample to be an even number.</p>
<p class="indent">Let’s return to my arrogant statement about the image file being “utterly imperceptible.” Suppose an adversary were to acquire the original <em>Fireflies</em> sound file. A bit-by-bit comparison of the samples might offer a clue that something is up, but we changed samples only when they needed to be changed. Therefore, merely extracting samples that differ between the suspect WAV file and the original won’t be enough to discover the hidden file because, on average, only half the samples used to encode the file will need to be altered. In other words, it’s doubtful the original file can be recovered without knowledge of the distribution of the samples used.</p>
<p class="indent">What if the adversary had only the altered WAV file? In that case, a savvy adversary suspecting steganography might decide that the least-significant bit of the samples is the one that is likely changed because altering other bits would produce noise when the WAV file is played, and none is present. This suspicion might prompt the adversary to examine the distribution of bit 0 across the samples and compare it with other WAV files.</p>
<p class="indent">If you run <em>steg_audio_test.py</em>, you’ll be presented with this output:</p>
<pre class="pre">Fireflies: [5104781 5103286] 0.6398434737379124
Attitude : [1863322 1860129] 0.09798008575083986
Fun-Key  : [1664208 1661616] 0.15522993473071336
Encoded  : [5093639 5114428] 7.681149082012241e-11</pre>
<p class="noindent">Each line reports the distribution of bit 0 across the samples in the corresponding WAV file. For instance, <em>Fireflies.wav</em> has 5,104,781 even samples and 5,103,286 odd samples (for channel 0 only). The final value in each row is the p-value for a <em>χ</em><sup>2</sup> test asking whether the even and odd sample counts are as expected if the evenness or oddness of a sample’s value is random. Only the first few digits of the p-value are meaningful.</p>
<p class="indent">Recall that p-values above 0.05 indicate support for the null hypothesis, the claim that the samples are equally likely to be even or odd. The p-values for Fireflies, Attitude, and Fun-Key are all in good agreement with the null hypothesis.</p>
<p class="indent">The final line, <span class="literal">Encoded</span>, shows the distribution for <em>tmp.wav</em>, the version of Fireflies with <em>tulips_gray.png</em> hidden inside it. Here, the p-value is 7 × 10<sup>–11</sup>, which is as good an approximation of 0 as any. In other words, the <em>χ</em><sup>2</sup> test <span epub:type="pagebreak" id="page_59"/>tells us that bit 0 is <em>not</em> in accordance with the null hypothesis—massively so. Upon seeing these results, our adversary would be convinced that something fishy is going on.</p>
<p class="indent">So, is my arrogance justified? No, not at all. A simple statistical test, combined with a bit of thought about how one might hide information in a WAV file, has given strong support to the notion that this particular WAV file has been manipulated. Also, even though our adversary strongly suspects we’ve manipulated the WAV file, they’re still unable to extract the information because they don’t know <em>which</em> bits were altered.</p>
<p class="indent">I encourage you to experiment with <em>steg_audio.py</em> and WAV files you have on hand. When you’re ready, read on to walk through the code.</p>
<h4 class="h4" id="ch00lev2_19"><em><strong>The steg_audio.py Code</strong></em></h4>
<p class="noindent">The file <em>steg_audio.py</em> consists of five functions and a small driver at the bottom. We’re already familiar with the <span class="literal">MakeBit</span>, <span class="literal">MakeByte</span>, and <span class="literal">MessageLength</span> functions (see <a href="ch02.xhtml#ch02list07">Listings 2-7</a>, <a href="ch02.xhtml#ch02list08">2-8</a>, and <a href="ch02.xhtml#ch02list09">2-9</a>).</p>
<p class="indent">The remaining two are the <span class="literal">Encode</span> and <span class="literal">Decode</span> functions. You might notice a trend here. The overall structure of <em>steg_audio.py</em> matches the structure of <em>steg_random.py</em>. Let’s peruse <span class="literal">Encode</span> to follow the process in this case. It’s best to absorb the function piecemeal, so <a href="ch02.xhtml#ch02list010">Listing 2-10</a> shows the first part.</p>
<pre class="pre">def Encode(key, sfile, dfile, pfile):
    src = np.fromfile(sfile, dtype="uint8")
    s = format(len(src), "08x")
    b3 = int(s[0:2],16);  b2 = int(s[2:4],16)
    b1 = int(s[4:6],16);  b0 = int(s[6:8],16)
    src = MakeBit(np.hstack(([b3,b2,b1,b0],src)))

    sample_rate, wav = wavread(pfile)
    if (wav.ndim == 2): 
        samples = wav[:,0].astype("uint16")
    else:
        samples = wav.astype("uint16")

    if (len(src) &gt; len(samples)):
        print("The input WAV file is too short")
        exit(1)
    else:
        print("Using %d samples to store the file" % len(src))</pre>
<p class="list" id="ch02list010"><em>Listing 2-10: Hiding data in an audio file (part 1)</em></p>
<p class="indent">The first paragraph of <a href="ch02.xhtml#ch02list010">Listing 2-10</a> is identical to the corresponding code in <em>steg_random.py</em>. The file to embed is loaded and converted to bits after prepending the file size in bytes (<span class="literal">src</span>).</p>
<p class="indent">The second paragraph reads the audio file, keeping the sampling rate (<span class="literal">sample_rate</span>) and the raw samples as signed 16-bit integers (<span class="literal">raw</span>). Next, the <span class="literal">if</span> interprets the samples as unsigned 16-bit integers while also selecting <span epub:type="pagebreak" id="page_60"/>channel 0 if more than one channel exists. The net result is <span class="literal">samples</span>, the actual values we’ll update. The third paragraph is a sanity check to see if there are enough samples to hide the source file.</p>
<p class="indent"><a href="ch02.xhtml#ch02list011">Listing 2-11</a> shows the remainder of <span class="literal">Encode</span>.</p>
<pre class="pre">    step = RE(seed=key, mode="int", low=1, high=5).random(len(src))
    idx = [step[0]]
    for i in range(1, len(src)):
        idx.append(idx[-1]+step[i])
    
    if (len(samples) &lt;= idx[-1]):
        print("Audio file too short")
        exit(1)

    for i in range(len(src)):
        if (src[i] == 0): 
            if ((samples[idx[i]] % 2) == 1): 
                samples[idx[i]] -= 1
        else:
            if ((samples[idx[i]] % 2) == 0):
                samples[idx[i]] += 1

    out = samples.astype("int16")
    if (wav.ndim == 2):
        wav[:,0] = out
        wavwrite(dfile, sample_rate, wav)
    else:
        wavwrite(dfile, sample_rate, out)</pre>
<p class="list" id="ch02list011"><em>Listing 2-11: Hiding data in an audio file (part 2)</em></p>
<p class="indent">With the samples prepared, we’re ready to hide some data. First, we create a vector of offsets using the supplied key (<span class="literal">step</span>). We did the same with <em>steg_random.py</em>. The offsets are used to build <span class="literal">idx</span>, a vector of samples to modify. A final sanity check confirms there are enough samples.</p>
<p class="indent">The second <span class="literal">for</span> loop sets the least-significant bit of the selected samples, altering it by 1 as necessary to make it odd or even depending on the current bit (<span class="literal">src[i]</span>).</p>
<p class="indent">The loop body needs some explanation. If the current source bit is a 0, there are two possibilities for the current sample (<span class="literal">samples[idx[i]]</span>). If the sample is odd, meaning the remainder after dividing by 2 is 1, we subtract 1 from the sample to make it even. Otherwise, the bit we want to store is a 1, meaning we check to see if the sample is currently even, and if it is, we add 1 to make it odd.</p>
<p class="indent">The final paragraph reinterprets the samples as signed integers (<span class="literal">out</span>) and writes them to disk using the original sample rate. If the audio file is stereo, channel 0 is updated, leaving the other channels as they were.</p>
<p class="indent"><span epub:type="pagebreak" id="page_61"/>To extract a hidden file, we reverse the process with <span class="literal">Decode</span>, as shown in <a href="ch02.xhtml#ch02list012">Listing 2-12</a>.</p>
<pre class="pre">def Decode(key, sfile, dfile):
    sample_rate, wav = wavread(sfile)
    if (wav.ndim == 2):
        samples = wav[:,0].astype("uint16")
    else:
        samples = wav.astype("uint16")

    rng = RE(mode="int", low=1, high=5, seed=key)
    step = rng.random(32)
    bits = []
    idx = [step[0]]
    for i in range(1, len(step)):
        idx.append(idx[-1]+step[i])
    for i in range(len(idx)):
        bits.append(samples[idx[i]] % 2)
    n = MessageLength(bits)

    offset = idx[-1]
    step = rng.random(8*n)
    idx = [offset + step[0]]
    bits = []
    for i in range(1, len(step)):
        idx.append(idx[-1]+step[i])
    for i in range(len(idx)):
        bits.append(samples[idx[i]] % 2)

    msg = MakeByte(np.array(bits))
    msg.tofile(dfile)</pre>
<p class="list" id="ch02list012"><em>Listing 2-12: Decoding data hidden in an audio file</em></p>
<p class="indent">There are four steps: read the encoded WAV file as unsigned integer samples, generate the same set of indices as used to encode the file, extract the bits, and write them to disk.</p>
<p class="indent">In the second paragraph, the pseudorandom generator is configured as in <span class="literal">Encode</span> before generating the first 32 step values to extract the encoded file length. We need the length to know how many samples to query to reconstruct the hidden file. Notice the call to <span class="literal">MessageLength</span>, <a href="ch02.xhtml#ch02list09">Listing 2-9</a>.</p>
<p class="indent">In the third paragraph, the actual bits of the file are extracted now that we know how many there are. To finish, the bits are converted to bytes and written to the output file (<span class="literal">dfile</span>).</p>
<p class="indent">Let’s try hiding data in images next. The process is similar to hiding data in a file of random bytes or in an audio file, but we’ll dispense with the notion of a secret key.</p>
<span epub:type="pagebreak" id="page_62"/>
<h3 class="h3" id="ch00lev1_15"><strong>In an Image File</strong></h3>
<p class="noindent">For the final experiment of this chapter, we’ll hide files in images. The method should be familiar: we’ll scatter the bits of the file across the pixels of the image by making small changes to the existing pixel colors. This is the most compact experiment in terms of code, but we need to discuss a few things about digital images before diving in. Specifically, we need to understand how computers store and interpret images, after which I can describe the algorithm. Experiments follow before a code walkthrough. You know the drill.</p>
<h4 class="h4" id="ch00lev2_20"><em><strong>Defining Image Formats</strong></em></h4>
<p class="noindent">The phrase “image format” has multiple meanings, especially when working in Python.</p>
<p class="indent">The first references how the image is stored on disk. There are many options that fall primarily into two camps: lossy and lossless.</p>
<p class="indent">Lossy image formats compress by throwing information away, much like an MP3 file. The information retained is sufficient to reconstruct the image to some level of fidelity with the original. The most common lossy image format is JPEG, which usually has a <em>.jpg</em> file extension. This format uses discrete cosine transforms across small patches to retain essential levels of detail while discarding those that don’t contribute substantially to the reconstruction of the image.</p>
<p class="indent">Lossless image formats either retain all pixel information or compress the image losslessly, meaning the recovered data is a bit-for-bit match with the original, uncompressed image. The most common lossless image format is PNG (<em>.png</em>). We’ll restrict ourselves to using only PNG files, as lossy formats like JPEG aren’t acceptable for the same reason MP3 files aren’t: the subtle changes made to the image will be lost. Advanced steganographic techniques are robust to lossy formats, but they are far beyond what we can explore here.</p>
<p class="indent">“Image format” also refers to the pixels themselves, with the main divisions being grayscale and color.</p>
<p class="indent">A grayscale image is the simplest: each pixel is a single number, a byte, representing the intensity of the pixels from black (0) to white (255) and shades of gray in between. Grayscale images with 16-bit pixels are rare, so we’ll ignore them here.</p>
<p class="indent">Computers have many options when representing color images. It’s most common to separate the color of each pixel into a combination of red, green, and blue. That is, a pixel showing as a whitish red can be represented as a mix of red, green, and blue that arrives at that color. The red, green, and blue <em>channels</em> are typically bytes, with 0 meaning none of that color and 255 being maximum intensity for that color. For example, the whitish red color is <span class="literal">A94141</span>, which is a triplet of hexadecimal numbers for the amount of red, green, and blue. Converting the hexadecimal to decimal, we have 169 out of 255 red, 65 green, and 65 blue.</p>
<span epub:type="pagebreak" id="page_63"/>
<h4 class="h4" id="ch00lev2_21"><em><strong>Using NumPy and PIL</strong></em></h4>
<p class="noindent">To NumPy, a grayscale image is a 2D array of bytes. Likewise, a color image, or RGB image, is a 3D array of bytes—one 2D array for each color channel. We’ll use RGB images for the upcoming experiments. If a grayscale image is loaded, it will be converted to RGB by duplicating the grayscale values for each channel.</p>
<p class="indent">NumPy will use the images as arrays, but how do we get them into Python in the first place? For that, we need the <em>Python Imaging Library (PIL)</em>, now called <em>Pillow</em>. It’s included with most Linux distributions and is available for Windows and macOS. For Linux and macOS, enter the following:</p>
<pre class="pre">&gt; <span class="codestrong1">pip install pillow</span></pre>
<p class="noindent">Any version 8.4 or later should work. We need it only to read and write image files.</p>
<p class="indent">The book’s GitHub page includes a collection of standard test images. We’ve used several already without bringing them into Python. Let’s remedy that now:</p>
<pre class="pre">&gt;&gt;&gt; <span class="codestrong1">import numpy as np</span>
&gt;&gt;&gt; <span class="codestrong1">from PIL import Image</span>
&gt;&gt;&gt; <span class="codestrong1">im = Image.open("apples.png")</span>
&gt;&gt;&gt; <span class="codestrong1">d = np.array(im)</span>
&gt;&gt;&gt; <span class="codestrong1">d.shape</span>
(352, 375, 3)
&gt;&gt;&gt; <span class="codestrong1">im = Image.open("barbara.png")</span>
&gt;&gt;&gt; <span class="codestrong1">d = np.array(im)</span>
&gt;&gt;&gt; <span class="codestrong1">d.shape</span>
(256, 256)
&gt;&gt;&gt; <span class="codestrong1">im = Image.open("barbara.png").convert("RGB")</span>
&gt;&gt;&gt; <span class="codestrong1">d = np.array(im)</span>
&gt;&gt;&gt; <span class="codestrong1">d.shape</span>
(256, 256, 3)</pre>
<p class="indent">Here, I’m showing the Python prompt and the commands entered manually. The first two lines load NumPy and PIL’s <span class="literal">Image</span> class. We only need <span class="literal">Image</span>.</p>
<p class="indent">The next two lines load the file <em>apples.png</em> into <span class="literal">im</span>, an instance of the <span class="literal">Image</span> class. To make the image a NumPy array, pass it to <span class="literal">np.array</span> to create <span class="literal">d</span>. Notice <span class="literal">d</span>’s shape: (352, 375, 3). The image has 352 rows, its height, and 375 columns, its width. The final dimension is 3 for the red, green, and blue channels.</p>
<p class="indent">The following two lines load <em>barbara.png</em> and convert it to a NumPy array. In this case, the array has only two dimensions: height and width, both 256. This is a grayscale file with one channel.</p>
<p class="indent">The final three commands load <em>barbara.png</em> a second time but immediately pass the image to the <span class="literal">Image</span>’s <span class="literal">convert</span> method to turn it into an RGB <span epub:type="pagebreak" id="page_64"/>image. The NumPy array now has three dimensions, though as a grayscale image, each color channel is the same.</p>
<p class="indent">While many books have been written on image processing in Python, fortunately all we need to know is how to open an image file, ensure that it’s RGB, turn it into a NumPy array, and write a NumPy array to disk as an image. Continuing with the previous example:</p>
<pre class="pre">&gt;&gt;&gt; <span class="codestrong1">d = np.array(Image.open("apples.png"))</span>
&gt;&gt;&gt; <span class="codestrong1">t = d[:,:,0]</span>
&gt;&gt;&gt; <span class="codestrong1">d[:,:,0] = d[:,:,1]</span>
&gt;&gt;&gt; <span class="codestrong1">d[:,:,1] = t</span>
&gt;&gt;&gt; <span class="codestrong1">im = Image.fromarray(d)</span>
&gt;&gt;&gt; <span class="codestrong1">im.save("bad_apples.png")</span></pre>
<p class="indent">The first line rereads <em>apples.png</em> and then immediately changes it into a NumPy array. We’ll use this idiom consistently.</p>
<p class="indent">The next three lines swap the red and green color channels. Read through them carefully. Since NumPy makes the third index the channel, we need to explicitly mention the height and width.</p>
<p class="indent">The next line uses <span class="literal">Image</span>’s <span class="literal">fromarray</span> method to change <span class="literal">d</span> into an <span class="literal">Image</span> object: <span class="literal">im</span>. The final line writes the altered image to disk as <em>bad_apples.png</em> using the <span class="literal">save</span> method. PIL uses the file extension to specify the format, in this case a PNG file. Open <em>bad_apples.png</em> to learn why I picked that name.</p>
<h4 class="h4" id="ch00lev2_22"><em><strong>Hiding Bits in Pixels</strong></em></h4>
<p class="noindent">In order to scatter the bits of the hidden file throughout the pixels of the image, we need to load the source file and convert it to bits using <em>MakeBit</em>. Then we load the image file, confirm it’s an RGB image, and convert it to a NumPy array.</p>
<p class="indent">Our previous experiments altered bits of the pool file to make them match the bits of the source file. The sequence of random offsets into the pool file was reproducible because we set the randomness engine’s seed to the secret key. While we could do the same here, we’ll take a different approach. Variety is the spice of life, as they say.</p>
<p class="indent">We’ll use the unaltered image as our key. When hiding a file, we’ll initialize the randomness engine without setting the seed, meaning each run of the code hides the same file in different locations in the image. Because we’re altering specific bits, we’ll know which bits we altered by using the unaltered image. To simplify things, we’ll do much as we did for the audio samples: one bit of the hidden file per byte of the image file.</p>
<p class="indent">While we could set the least-significant bit of the pixel, as we did for the audio file, we’d never be able to detect where the image pixel already had the proper bit value. And since we’re abandoning the secret key to get a unique set of altered pixels per run, we’d never know which pixels happened to have the proper bit value by chance.</p>
<p class="indent">Instead of looking for bit 0 of the pixel to be 0 or 1, or equivalently asking if the pixel is even or odd, we’ll encode 0 bits by adding 1 to the pixel <span epub:type="pagebreak" id="page_65"/>and 1 bits by adding 2. In this scenario, any pixel of the unaltered image that isn’t the same as the corresponding pixel of the altered image holds a bit of the hidden file.</p>
<p class="indent">In RGB images, each pixel is actually three bytes; we can alter any of them. When we implement the algorithm, we’ll <em>unravel</em> the image by asking NumPy to turn the three-dimensional array into a single vector, which is how the image data is stored in the computer’s memory. Where specific red, green, and blue bytes end up in the unraveled array is irrelevant as long as NumPy makes the process repeatable, which it does.</p>
<p class="indent">With the image bytes as a vector, we select a subset of locations—as many as there are bits in the hidden file—and alter them by adding 1 if the corresponding bit is a 0, or 2 if the bit is a 1.</p>
<p class="indent">Bytes are unsigned numbers in the range [0, 255], meaning if the pixel value is 255 and we add 1 to encode a 0, we’ll wrap around to 0 (or 1 if adding 2 for a 1 bit). That won’t do at all, so we make an executive decision: before encoding, we’ll alter all image pixel bytes greater than 253 and set them to 253 so that adding 1 gives us 254 and adding 2 gives 255; hence no overflow.</p>
<p class="indent">We’re able to alter the image pixel bytes for two reasons: the code will do this for the unaltered image each time, even when decoding, so it’s reproducible; and because the bytes represent color values, the difference between 255 and 253 is too subtle to see, especially when there’s a global change in overall color intensity or shade.</p>
<p class="indent">The resulting code is <em>steg_image.py</em>, which I encourage you to study before reading further. I’ll walk through the code after we experiment with it.</p>
<p class="indent">This approach is just as fragile as the audio approach. We’ll throw away the encoding if we store our encoded image using a lossy image format like JPEG. We can use a JPEG as the original image because NumPy will decode it the same way each time, but even that might be a risk because a future version of NumPy might alter the algorithm used to decode the image (this is unlikely, but possible). Again, we’ll restrict ourselves to using only losslessly compressed PNG files.</p>
<p class="indent">Now, let’s have some fun!</p>
<h4 class="h4" id="ch00lev2_23"><em><strong>Hiding One Image in Another</strong></em></h4>
<p class="noindent">For our first experiment, we’ll hide an image (<em>cameraman.png</em>) within a second image (<em>apples.png</em>). The command line we need is:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_image.py encode test_images/cameraman.png test_images/apples.png tmp.png</span></pre>
<p class="noindent">We tell <em>steg_image.py</em> we want to encode, then provide the file to encode (<em>cameraman.png</em>) followed by the reference image (<em>apples.png</em>) and the output image file, <em>tmp.png</em>.</p>
<p class="indent">Open both <em>apples.png</em> and <em>tmp.png</em> and look carefully, flipping rapidly between the two if your software allows. Do you see any differences? A meticulous examination might reveal some, but my eye doesn’t notice anything.</p>
<p class="indent"><span epub:type="pagebreak" id="page_66"/>To recover <em>cameraman.png</em>, use:</p>
<pre class="pre">&gt; <span class="codestrong1">python3 steg_image.py decode tmp.png test_images/apples.png output.png</span></pre>
<p class="indent">The <em>cameraman.png</em> file is 16 percent the size of <em>apples.png</em>, and was easily hidden among the apples. How large can the file be before we notice it?</p>
<p class="indent">If you run <em>steg_image_test.py</em>, then you’ll get a new output directory, <em>steg_image_test</em>, containing multiple images with names like <em>apple_A_0.60.png</em> and <em>violet_rand_0.40.png</em>. The files are images, each hiding either a specific number of <em>A</em>s or random data read from <span class="literal">RDRAND</span>. The first part of the name is the test image source, <em>apples.png</em> or <em>violet.png</em>. The latter is a 512×512-pixel image of a light violet color.</p>
<p class="indent">The fraction in each name is the fraction of the reference pixel images used to hold the encoded data. For example, <em>apple_A_0.60.png</em> is hiding the letter <em>A</em> so that 60 percent of the pixels in <em>apples.png</em> have been modified. The fractions start at 5 percent and go up to 99 percent. Take a look at these output files, especially the violet ones. Even when 99 percent of the pixels have been modified with either the same byte repeated or highly random bytes, we’re unable to see a difference between the output image file and the original. This is an example of imperceptible steganography. For brevity, I won’t discuss <em>steg_image_test.py</em> in detail, but do take a look at it.</p>
<p class="indent">We’ve hidden an image in another image. What’s stopping us from hiding a message in an image, then hiding the image with the hidden message in another image, and so on, to produce a final output image with a set of Russian doll images inside it? Why, nothing at all. Let’s do it.</p>
<p class="indent">The script we want to run is in <em>russian_dolls_example</em>, which is shown in <a href="ch02.xhtml#ch02list013">Listing 2-13</a>.</p>
<pre class="pre">echo "Encoding..."
python3 steg_image.py encode kilroy.txt       test_images/apples_32.png   /tmp/encode0.png
python3 steg_image.py encode /tmp/encode0.png test_images/peppers_128.png /tmp/encode1.png
python3 steg_image.py encode /tmp/encode1.png test_images/fruit2.png      /tmp/encode2.png
python3 steg_image.py encode /tmp/encode2.png test_images/tulips.png      russian_dolls.png
echo "Decoding..."
python3 steg_image.py decode russian_dolls.png test_images/tulips.png      /tmp/decode0.png
python3 steg_image.py decode /tmp/decode0.png  test_images/fruit2.png      /tmp/decode1.png
python3 steg_image.py decode /tmp/decode1.png  test_images/peppers_128.png /tmp/decode2.png
python3 steg_image.py decode /tmp/decode2.png  test_images/apples_32.png   output.txt</pre>
<p class="list" id="ch02list013"><em>Listing 2-13: Encoding and decoding Russian dolls</em></p>
<p class="noindent">This is a shell script you can run with:</p>
<pre class="pre">&gt; <span class="codestrong1">sh russian_dolls_example</span></pre>
<p class="noindent">When finished, take a look at the image with all the nested images and the original message, <em>russian_dolls.png</em>. Then compare the source file, <em>kilroy.txt</em>, with <em>output.txt</em> to see that they are the same. The intermediate images with each stage of the encoding process are in the system <em>tmp</em> directory.</p>
<span epub:type="pagebreak" id="page_67"/>
<p class="indent"><a href="ch02.xhtml#ch02fig05">Figure 2-5</a> shows the process of building a stack of Russian dolls.</p>
<div class="image"><img alt="Image" id="ch02fig05" src="../images/02fig05.jpg"/></div>
<p class="figcap"><em>Figure 2-5: Building a stack of Russian dolls</em></p>
<p class="indent">First, the text message “Kilroy was here” is hidden in the small version of the apples image. Then, that image is hidden in the peppers image, which is hidden in the fruit image, all of which are hidden in the tulips image as the final output. Reversing the process to decode step by step delivers the original message: Kilroy was here.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The phrase “Kilroy was here” was used by American and British troops in WWII, partly as a joke and partly to mark places where they had already been. It caught on after the war, becoming an early meme of sorts, often with a silly character face to accompany the message.</em></p>
</div>
<p class="indent">Let’s walk through the code to see where Kilroy has been.</p>
<h4 class="h4" id="ch00lev2_24"><em><strong>The steg_image.py Code</strong></em></h4>
<p class="noindent">Of all our experiments, <em>steg_image.py</em> is perhaps the simplest. It uses both <span class="literal">MakeBit</span> and <span class="literal">MakeByte</span>, and has a simple driver to call <span class="literal">Encode</span> and <span class="literal">Decode</span>. Let’s focus on those two functions, beginning with <span class="literal">Encode</span>, shown in <a href="ch02.xhtml#ch02list014">Listing 2-14</a>.</p>
<pre class="pre">def Encode(mfile, sfile, dfile):
 <span class="ent">➊</span> msg = MakeBit(np.fromfile(mfile, dtype="uint8"))
    simg = np.array(Image.open(sfile).convert("RGB"))
    simg[np.where(simg &gt; 253)] = 253
    row, col, channel = simg.shape
 <span epub:type="pagebreak" id="page_68"/><span class="ent">➋</span> simg = simg.ravel()
    if (len(msg) &gt; len(simg)):
        print("Message file too long")
        exit(1)
 <span class="ent">➌</span> rng = RE(kind="mt19937")
    p = np.arange(len(simg))
    np.random.shuffle(p)
    p = p[:len(msg)]
    p.sort()
 <span class="ent">➍</span> for i in range(len(p)):
        simg[p[i]] += msg[i]+1
    simg = simg.reshape((row, col, channel))
    Image.fromarray(simg).save(dfile)</pre>
<p class="list" id="ch02list014"><em>Listing 2-14: Hiding a file in an image</em></p>
<p class="indent">The file to hide (<span class="literal">mfile</span>) is read as bytes and immediately converted into a vector of bits <span class="ent">➊</span>. The reference image is read next, as RGB if not already, and then converted to a NumPy array (<span class="literal">simg</span>).</p>
<p class="indent">As mentioned previously, we need to prevent overflow when encoding bits, so we use NumPy’s <span class="literal">where</span> function to locate the places in the image that are greater than 253. The <span class="literal">where</span> function returns a collection of indices, regardless of the dimensionality of <span class="literal">simg</span>, that are immediately used to change said locations to 253, the new maximum. This covers all red, green, and blue parts of the image.</p>
<p class="indent">We intend to use the image as a vector, so we next grab the actual row, column, and channel (= 3) numbers to use later when re-forming the image.</p>
<p class="indent">Next, we tell NumPy to make the three-dimensional image array a vector by calling <span class="literal">ravel</span> <span class="ent">➋</span>. In NumPy, the word <em>ravel</em> is a contronym, a word that is its own antonym. In this case, ravel means to <em>unravel</em>, to change the array into a vector, a one-dimensional beast. After <span class="literal">ravel</span> is called, <span class="literal">simg</span> is a vector of the bytes of the image. We don’t care about where each specific red, green, and blue byte landed; NumPy applies <span class="literal">ravel</span> consistently.</p>
<p class="indent">We have the image as a vector of bytes and the source file as a vector of bits. To scatter the bits across the bytes, we need a vector of locations; that’s the purpose of <span class="literal">rng</span> <span class="ent">➌</span>. First, we initialize <span class="literal">rng</span> using the Mersenne Twister. The following four lines build the vector of indices, the bytes we’ll modify (<span class="literal">p</span>).</p>
<p class="indent">We want <span class="literal">p</span> to have as many elements as bits in <span class="literal">src</span>. First, we set <span class="literal">p</span> to 0, 1, 2, . . . , <em>n</em> – 1 for the <em>n</em> number of bytes in the image, <span class="literal">simg</span>. The resulting vector is shuffled to create a unique permutation of the values.</p>
<p class="indent">The following two lines keep as many elements of <span class="literal">p</span> as we need to place each bit of the source file (<span class="literal">msg</span>) and sort <span class="literal">p</span> so the list of indices is in order numerically. This last step is necessary because we’re not setting <span class="literal">rng</span>’s seed, so we must apply some order to the image bytes updated to preserve the order of the bits in <span class="literal">msg</span>. You’ll see what I mean when we review <span class="literal">Decode</span>.</p>
<p class="indent">To scatter the bits of <span class="literal">msg</span> we need only iterate over them and use the corresponding index in <span class="literal">p</span> <span class="ent">➍</span>. We add the bit value plus 1 so that 0 bits become 1 <span epub:type="pagebreak" id="page_69"/>and 1 bit becomes 2. This change lets us detect all altered bits by using the reference image as the key.</p>
<p class="indent">Finally, we <span class="literal">reshape</span> the updated image bytes to create the 3D output array. Notice that <span class="literal">reshape</span> applies the proper reinterpretation of the bytes in memory, an interpretation that matches the order used by <span class="literal">ravel</span>. In other words, <span class="literal">reshape</span> ravels the array in the opposite sense of the word. The array is passed to the PIL <span class="literal">Image</span> class to be output as a PNG file.</p>
<p class="indent">As shown in <a href="ch02.xhtml#ch02list015">Listing 2-15</a>, <span class="literal">Decode</span> recovers hidden files using the reference image as a key.</p>
<pre class="pre">def Decode(dfile, sfile, mfile):
    dimg = np.array(Image.open(dfile)).ravel()
    simg = np.array(Image.open(sfile).convert("RGB")).ravel()
    simg[np.where(simg &gt; 253)] = 253
    i = np.where(dimg != simg)
    d = dimg[i] - simg[i] - 1
    b = MakeByte(d.astype("uint8"))
    b.tofile(mfile)</pre>
<p class="list" id="ch02list015"><em>Listing 2-15: Decoding an image</em></p>
<p class="indent"><span class="literal">Decode</span> loads two image files, the one with the hidden data (<span class="literal">dimg</span>) and the reference image (<span class="literal">simg</span>), as NumPy arrays. The function then immediately converts both image files to vectors of bytes, and the reference image is passed through <span class="literal">convert</span> to make it an RGB image, as <span class="literal">Encode</span> did. Also as in <span class="literal">Encode</span>, reference image byte values above 253 are set to 253.</p>
<p class="indent">NumPy’s <span class="literal">where</span> returns all the locations where the two images disagree. Because we assume the reference image is <em>exactly</em> the same image used when creating <span class="literal">dimg</span>, any differences represent bits of the hidden file.</p>
<p class="indent">The difference between the encoded image and the reference image gives us the bit values, but as 1 and 2, not 0 and 1. Therefore, we subtract one more to make <span class="literal">d</span> the vector of hidden bit values. Because we insisted that the bytes were altered in numerical order when encoding, the order in which the difference appears in the image matches the proper order for the output bits. In other words, we don’t need to sort anything; the indices returned by <span class="literal">where</span> are already in sorted order.</p>
<p class="indent">The remaining two lines convert <span class="literal">d</span> to bytes and write them to the output file (<span class="literal">mfile</span>).</p>
<h3 class="h3" id="ch00lev1_16"><strong>Exercises</strong></h3>
<p class="noindent">Steganography offers many possibilities. Here are some to explore and contemplate:</p>
<ul>
<li class="noindent">Bacon’s cipher uses subtle changes in the type to embed binary codes representing letters. What needs to change to embed arbitrary binary data in a text block? What about using spaces between words with a proportional font?</li>
<li class="noindent"><span epub:type="pagebreak" id="page_70"/>Make your own “spaceship cipher” to hide secret messages in drawings. This might be a good activity for the kids.</li>
<li class="noindent">Our text experiments neglected to encode the spaces between words. Remedy that oversight.</li>
<li class="noindent">Can you think of a simple sentence structure with many word options and use that to encode a text message à la <em>steg_text.py</em>? Generate random sentences using a large pool of adjectives, adverbs, nouns, and verbs, so the output reads as grammatically correct sentences.</li>
<li class="noindent">We used channel 0 when hiding data in audio files. Use both stereo channels to double the amount of data that can be encoded.</li>
<li class="noindent">Replicate hiding binary data in a file of random bytes, but substitute an audio file of white noise (random samples). This removes the restriction on changing only the lowest-order bit of each sample. How much data can you fit using both channels before the sound changes? What does a file of random bytes sound like in the first place? Might sound be a good way to detect randomness in data?</li>
<li class="noindent">Lossy image compression destroys our simple approach of changing byte values to encode information. How might we add redundancy so that the message persists even after using JPEG compression?</li>
<li class="noindent">What happens to image encoding when the image is resized? Can you think of a way to preserve the message using nearest-neighbor sampling? Nearest-neighbor sampling duplicates existing pixels when expanding the image and throws pixels away when shrinking the image, that is, it does not interpolate.</li>
</ul>
<p class="noindent">Let me know what you think and how it goes.</p>
<h3 class="h3" id="ch00lev1_17"><strong>Summary</strong></h3>
<p class="noindent">This chapter explored randomness and steganography, the hiding of information. We first defined the term, and then contemplated a smattering of historical uses. That section alone could easily be a separate book, but it set the stage for the experiments.</p>
<p class="indent">First, we hid text in other text using random selections of letters in a list of discrete words. Pseudorandom generators proved helpful with the seed, the secret key necessary for correctly decoding the hidden message.</p>
<p class="indent">The following experiment worked with a file of random bytes. The hidden data was scattered, bit by bit, throughout the random data, again using the pseudorandom generator seed as the secret key. We found that a ratio of about 100:1 between the size of the random data and the hidden data generally preserved sufficient randomness in the output to properly conceal our message.</p>
<p class="indent">Then we scattered the bits of the hidden file across bit 0 of a set of WAV sound samples; this led to an output audio file that gave no auditory indication it had been altered. However, a statistical test on the distribution of <span epub:type="pagebreak" id="page_71"/>bit 0 for the WAV file revealed evidence of tampering, though extraction of the hidden data remained extremely difficult.</p>
<p class="indent">Finally, we used the color information in a reference image to embed a file. In this experiment, no secret key was necessary; the reference file itself was the key. Each encoding generated a different collection of altered image bytes at the expense of requiring the entire reference image as the key. We learned how computers store and manipulate color images and how to work with image data in NumPy. We’ll use this knowledge again in <a href="ch05.xhtml">Chapter 5</a>.</p>
<p class="indent">It isn’t difficult to imagine illegitimate uses of steganography. I’m reminded here of the wisdom of Ben Parker: with great power comes great responsibility. If you’re inclined to use steganography for something other than simple “I wonder if it would work” experiments, think carefully about it, put this book down, get a cup of coffee, take a walk, and forget about it.</p>
<p class="indent">The next chapter introduces us to the vast, randomness-heavy world of simulation. I think it’ll be fun. I hope you agree.</p>
<p class="noindentt">Read <em>poem.txt</em>. It’s an Easter egg.<span epub:type="pagebreak" id="page_72"/></p>
</body></html>