<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_305"/><strong><span class="big">15</span><br/>SPECIAL USES OF SUBFUNCTIONS</strong></h2>&#13;
<div class="image1"><img src="../images/pg297_Image_276.jpg" alt="Image" width="192" height="195"/></div>&#13;
<p class="noindentz">As you learned in <a href="ch14.xhtml">Chapter 14</a>, the most common use of a subfunction is to break a problem into smaller, easier-to-solve subproblems. This is the foundation of <em>recursion</em>, the subject of the first half of this chapter.</p>&#13;
<p class="indent">After I cover recursion, I’ll show you another use of subfunctions: directly accessing hardware features in assembly language that may not be easily accessible in a higher-level language.</p>&#13;
<h3 class="h3" id="ch15lev1sec1"><strong>Recursion</strong></h3>&#13;
<p class="noindent">Many computer solutions involve repetitive actions. You learned how to use iteration—<code>while</code>, <code>for</code>, and <code>do-while</code> loops—to perform repetitive actions in <a href="ch13.xhtml">Chapter 13</a>. While iteration can be used to solve any repetitive problem, some solutions are described more succinctly using recursion.</p>&#13;
<p class="indent">A <em>recursive algorithm</em> is an algorithm that calls itself to compute a simpler case of the problem and uses that result to compute the more complex case at hand. The recursive calls continue until the simpler case reaches a <em>base case</em>, which is a case that is easily computed by itself. At this point, the recursive algorithm returns the base case value to the next more complex case, <span epub:type="pagebreak" id="page_306"/>where the value is used in that computation. This return/compute process continues, performing increasingly complex computations along the way, until we arrive at the solution for the original case.</p>&#13;
<p class="indent">Let’s look at an example. In mathematics, we denote the factorial operation on positive integers with an !, which can be defined recursively:</p>&#13;
<p class="center"><img src="../images/pg334_Image_282a.jpg" alt="Image" width="137" height="47"/></p>&#13;
<p class="indent">The first equation shows that <em>n</em>! is defined by computing a simpler case of itself, (<em>n</em> – 1)!. This computation is performed repetitively until we reach the base case of <em>n</em> = 0. Then we work our way back out, computing each <em>n</em>! along the way.</p>&#13;
<p class="indent">For comparison, the iterative definition of the factorial operation is:</p>&#13;
<p class="center"><img src="../images/pg334_Image_282b.jpg" alt="Image" width="299" height="47"/></p>&#13;
<p class="indent">Although both forms of defining the factorial operation involve the same number of computations, the recursive form is more concise and perhaps more intuitive to some people.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list1">Listings 15-1</a> to <a href="ch15.xhtml#ch15list3">15-3</a> show a program that uses a function, <code>factorial</code>, to compute 3!. You’ll see the reason for using a small, fixed value when we use <code>gdb</code> to examine the behavior of the program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>three_factorial.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Compute 3 factorial.&#13;
&#13;
 #include &lt;stdio.h&gt;&#13;
 #include "factorial.h"&#13;
&#13;
 int main(void)&#13;
 {&#13;
     unsigned int x = 3;&#13;
     unsigned int y;&#13;
  &#13;
     y = factorial(x);&#13;
     printf("%u! = %u\n", x, y);&#13;
&#13;
     return 0;&#13;
 }</pre>&#13;
<p class="list" id="ch15list1"><em>Listing 15-1: A program to compute 3!</em></p>&#13;
<p class="noindent">The mathematical factorial function is defined for nonnegative integers, so we use <code>unsigned int</code>s.</p>&#13;
<p class="indent">There is nothing remarkable about the header file for the <code>factorial</code> function, shown in <a href="ch15.xhtml#ch15list2">Listing 15-2</a>.</p>&#13;
<span epub:type="pagebreak" id="page_307"/>&#13;
<div class="note6">&#13;
<p class="notep"><em>factorial.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Return n factorial.&#13;
 &#13;
 #ifndef FACTORIAL_H&#13;
 #define FACTORIAL_H&#13;
 unsigned int factorial(unsigned int n);&#13;
 #endif</pre>&#13;
<p class="list" id="ch15list2"><em>Listing 15-2: The header file for the function to compute</em> n<em>!</em></p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list3">Listing 15-3</a> shows that the <code>factorial</code> function calls itself to perform a simpler computation, (<em>n</em> – 1)!, so it can easily compute <em>n</em>!.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>factorial.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Return n factorial.&#13;
&#13;
 #include "factorial.h"&#13;
&#13;
 unsigned int factorial(unsigned int n)&#13;
 {&#13;
     unsigned int current = 1;   // Assume base case&#13;
&#13;
  <span class="ent">➊</span> if (n != 0) {&#13;
      <span class="ent">➋</span> current = n * factorial(n - 1);&#13;
     }&#13;
     return current;&#13;
 }</pre>&#13;
<p class="list" id="ch15list3"><em>Listing 15-3: A function to compute</em> n<em>!</em></p>&#13;
<p class="indent">The <code>factorial</code> function first checks for the base case of <em>n</em> = 0 <span class="ent">❶</span>. If we’re at the base case, the current result is 1. If we’re not at the base case, the <code>factorial</code> function calls the <code>factorial</code> function to compute (<em>n</em> – 1)! and multiplies the result by <em>n</em> to get <em>n</em>!<span class="ent">❷</span>.</p>&#13;
<p class="indent">The assembly language for the <code>main</code> function is unremarkable, but let’s look at what the compiler generated for the <code>factorial</code> function, shown in <a href="ch15.xhtml#ch15list4">Listing 15-4</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>factorial.s</em></p>&#13;
</div>&#13;
<pre class="pre">         .arch armv8-a&#13;
         .file   "factorial.c"&#13;
         .text&#13;
         .align  2&#13;
         .global factorial&#13;
         .type   factorial, %function&#13;
 factorial:&#13;
         stp     x29, x30, [sp, -48]!&#13;
         mov     x29, sp&#13;
      <span class="ent">➊</span> str     w0, [sp, 28]&#13;
         mov     w0, 1&#13;
         str     w0, [sp, 44]&#13;
         ldr     w0, [sp, 28]&#13;
      <span class="ent">➋</span> cmp     w0, 0             /// Check for base case&#13;
         beq     .L2&#13;
         ldr     w0, [sp, 28]&#13;
         sub     w0, w0, #1        /// n - 1&#13;
      <span class="ent">➌</span> bl      factorial         /// Recursive call&#13;
         mov     w1, w0&#13;
         ldr     w0, [sp, 28]&#13;
      <span class="ent">➍</span> mul     w0, w0, w1        /// n * (n - 1)!&#13;
         str     w0, [sp, 44]&#13;
 .L2:&#13;
         ldr     w0, [sp, 44]&#13;
         ldp     x29, x30, [sp], 48&#13;
         ret&#13;
         .size   factorial, .-factorial&#13;
         .ident  "GCC: Debian 12.2.0-14) 12.2.0"&#13;
         .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_308"/>&#13;
<p class="list" id="ch15list4"><em>Listing 15-4: The compiler-generated assembly language for the function in <a href="ch15.xhtml#ch15list3">Listing 15-3</a></em></p>&#13;
<p class="indent">The algorithm used in the <code>factorial</code> function is a simple <code>if</code> construct, which you learned about in <a href="ch13.xhtml">Chapter 13</a> <span class="ent">❷</span>. The important part of a recursive function is that we need to save any arguments passed to it in registers so these registers can be reused to pass arguments in the recursive call to the function.</p>&#13;
<p class="indent">For example, the <code>factorial</code> function takes one argument, <code>n</code>, which is passed in the <code>w0</code> register. From <a href="ch11.xhtml#ch11tab3">Table 11-3</a> in <a href="ch11.xhtml">Chapter 11</a>, we know that we don’t need to save the content of <code>x0</code> in our function, but we need to use the <code>w0</code> portion of <code>x0</code> for the recursive call with the new value, <code>(n - 1)</code> <span class="ent">❸</span>. And when the recursive call returns, we need the original value of <code>n</code> to compute <code>n * (n - 1)!</code>. The compiler has allocated space in the stack frame for saving <code>n</code> <span class="ent">❶</span>.</p>&#13;
<p class="indent">We haven’t discussed the <code>mul</code> instruction yet. As you might guess, the <code>mul</code> instruction in <a href="ch15.xhtml#ch15list4">Listing 15-4</a> multiplies the integer in <code>w0</code> by the one in <code>w1</code>, leaving the product in <code>w0</code> <span class="ent">❹</span>. The details of multiplication instructions are somewhat complex. I’ll cover them in <a href="ch16.xhtml">Chapter 16</a>.</p>&#13;
<p class="indent">We can simplify the <code>factorial</code> function a little by writing it directly in assembly language. Let’s start by designing our stack frame, as shown in <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>.</p>&#13;
<div class="image"><img id="ch15fig1" src="../images/pg336_Image_282.jpg" alt="Image" width="437" height="197"/></div>&#13;
<p class="figcap"><em>Figure 15-1: The stack frame design for the</em> <span class="codeitalic">factorial</span> <em>function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_309"/><a href="ch15.xhtml#ch15list5">Listing 15-5</a> shows our assembly language version.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>factorial.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Compute n factorial.&#13;
// Calling sequence:&#13;
//    w0 &lt;- n&#13;
//    Returns n!&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    n, 16&#13;
     <span class="ent">➊</span> .equ    FRAME, 32&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global factorial&#13;
        .type   factorial, %function&#13;
factorial:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
&#13;
        str     w0, [sp, n]           // Save n&#13;
        mov     w1, w0                //   and make a copy&#13;
        mov     w0, 1                 // Assume base case, 0! = 1&#13;
     <span class="ent">➋</span> cbz     w1, base_case         // Check for base case&#13;
        sub     w0, w1, 1             // No,&#13;
        bl      factorial             //   compute (n - 1)!&#13;
        ldr     w1, [sp, n]           // Get n&#13;
     <span class="ent">➌</span> mul     w0, w0, w1            // n * (n - 1)!&#13;
base_case:&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret                           // Back to caller</pre>&#13;
<p class="list" id="ch15list5"><em>Listing 15-5: A function to compute</em> n<em>!</em></p>&#13;
<p class="indent">There are a few key differences to note here. First, I don’t know why the compiler allocated 48 bytes for the stack frame (see <a href="ch15.xhtml#ch15list4">Listing 15-4</a>), but we only need 32 bytes <span class="ent">❶</span>. Second, we’re using a local variable for the input <code>n</code>. The compiler uses a local variable for the result of the computation <code>n * (n - 1)!</code>, but we’re leaving it in the <code>w0</code> register <span class="ent">❸</span>. Third, we use the <code>cbz</code> instruction instead of the <code>cmp</code>/<code>beq</code> pair the compiler used <span class="ent">❷</span>.</p>&#13;
<p class="indent">Recursive algorithms can be simple and elegant, but they make heavy use of the stack. I used our assembly language version of <code>factorial</code> (and the C header file in <a href="ch15.xhtml#ch15list2">Listing 15-2</a>) with the <code>main</code> function of <a href="ch15.xhtml#ch15list1">Listing 15-1</a> and ran the program under <code>gdb</code> so we can take a look at the stack usage:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">l factorial</span>&#13;
   11              .text&#13;
   12              .align  2&#13;
   13              .global factorial&#13;
   14              .type   factorial, %function&#13;
   15      factorial:&#13;
   16              stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
   17              mov     fp, sp                // Set our frame pointer&#13;
   18&#13;
   19              str     w0, [sp, n]           // Save n&#13;
   20              mov     w1, w0                //   and make a copy&#13;
   (gdb) &#13;
   21              mov     w0, 1                 // Assume base case, 0! = 1&#13;
   22              cbz     w1, base_case         // Check for base case&#13;
   23              sub     w0, w1, 1             // No,&#13;
<span class="ent">➊</span> 24              bl      factorial             //   compute (n - 1)!&#13;
   25              ldr     w1, [sp, n]           // Get n&#13;
   26              mul     w0, w0, w1            // n * (n - 1)!&#13;
<span class="ent">➋</span> 27      base_case:&#13;
   28              ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
   29              ret                           // Back to caller&#13;
   (gdb) <span class="codestrong1">b 24</span>&#13;
   Breakpoint 1 at 0x7cc: file factorial.s, line 24.&#13;
   (gdb) <span class="codestrong1">b 27</span>&#13;
   Breakpoint 2 at 0x7d8: file factorial.s, line 28.</pre>&#13;
<span epub:type="pagebreak" id="page_310"/>&#13;
<p class="indent">I set two breakpoints, one at the recursive call to <code>factorial</code> <span class="ent">❶</span> and the other at the point where the function’s algorithm ends <span class="ent">❷</span>. Each time the program breaks back into <code>gdb</code>, we’ll look at the input value to this call to <code>factorial</code>, the input value we’re passing to the next call to <code>factorial</code>, <code>pc</code>, and the stack frame for each call to <code>factorial</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/bob/chapter_15/factorial_asm/three_factorial &#13;
&#13;
Breakpoint 1, factorial () at factorial.s:24&#13;
24              bl      factorial             //    Compute (n - 1)!&#13;
(gdb) <span class="codestrong1">i r x0 x1 sp pc</span>&#13;
x0             0x2                 2&#13;
x1             0x3                 3&#13;
sp             0x7fffffef40        0x7fffffef40&#13;
pc             0x55555507cc        0x55555507cc &lt;factorial+28&gt;&#13;
(gdb) <span class="codestrong1">x/4gx 0x7fffffef40</span>&#13;
0x7fffffef40:   0x0000007fffffef60   <span class="ent">➊</span> 0x000000555555078c&#13;
0x7fffffef50:<span class="ent">➋</span> 0x0000005500000003      0x0000000000000000</pre>&#13;
<p class="indent">The <code>main</code> function called the <code>factorial</code> function with <code>3</code> as the input, which is saved on the stack <span class="ent">❷</span>. When viewing this display, remember that the input is a 32-bit <code>int</code>. Each item on the stack is 64 bits wide, so this <code>int</code> is stored in the low-order 32 bits of this stack location. Looking at the 32 bytes of the stack frame, we see the return address back to <code>main</code> <span class="ent">❶</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_311"/>We’re now ready to call <code>factorial</code> with the input <code>(3 - 1) = 2</code> in register <code>w0</code>. When we continue running the program, it will break at the same place in <code>factorial</code> because the function calls itself before returning to <code>main</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
&#13;
Breakpoint 1, factorial () at factorial.s:24&#13;
24              bl      factorial             //    Compute (n - 1)!&#13;
(gdb) <span class="codestrong1">i r x0 x1 sp pc</span>&#13;
x0             0x1                 1&#13;
x1             0x2                 2&#13;
sp          <span class="ent">➊</span> 0x7fffffef20        0x7fffffef20&#13;
pc             0x55555507cc        0x55555507cc &lt;factorial+28&gt;&#13;
(gdb) <span class="codestrong1">x/8gx 0x7fffffef20</span>&#13;
0x7fffffef20:   0x0000007fffffef40   <span class="ent">➋</span> 0x00000055555507d0&#13;
0x7fffffef30:<span class="ent">➌</span> 0x0000007f00000002      0x000000555555081c&#13;
0x7fffffef40:   0x0000007fffffef60      0x000000555555078c&#13;
0x7fffffef50:   0x0000005500000003      0x0000000000000000</pre>&#13;
<p class="indent">The <code>factorial</code> function has added another 32-byte stack frame onto the stack <span class="ent">❶</span>. The input to this call to <code>factorial</code>, <code>2</code>, has been saved in this new stack frame <span class="ent">❸</span>.</p>&#13;
<p class="indent">The program counter, <code>pc</code>, shows that the <code>bl factorial</code> instruction is located at <code>0x55555507cc</code>. All instructions in the A64 architecture are 32 bits wide, so all recursive calls to the <code>factorial</code> function will return to location <code>0x55555507cc + 0x4 = 0x55555507d0</code> in the function. This is the return address stored in the frame record <span class="ent">❷</span>.</p>&#13;
<p class="indent">If we enter <span class="codestrong">c</span> (continue) two more times, we finally reach the point where the program flow leaves the fourth call to <code>factorial</code>, breaking at the second breakpoint:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
&#13;
Breakpoint 2, base_case () at factorial.s:28&#13;
28              ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
(gdb) <span class="codestrong1">i r x0 x1 sp pc</span>&#13;
x0             0x1                 1&#13;
x1             0x0                 0&#13;
sp             0x7fffffeee0        0x7fffffeee0&#13;
pc             0x55555507d8        0x55555507d8 &lt;base_case&gt;&#13;
(gdb) <span class="codestrong1">x/16gx 0x7fffffeee0</span> (@\label{pg:recurse}@)&#13;
0x7fffffeee0:   0x0000007fffffef00      0x00000055555507d0&#13;
0x7fffffeef0:<span class="ent">➊</span> 0x0000000000000000      0x0000000000000000&#13;
0x7fffffef00:   0x0000007fffffef20      0x00000055555507d0&#13;
0x7fffffef10:   0x0000007f00000001      0x0000000000000000&#13;
0x7fffffef20:   0x0000007fffffef40      0x00000055555507d0&#13;
0x7fffffef30:   0x0000007f00000002      0x000000555555081c&#13;
0x7fffffef40:   0x0000007fffffef60      0x000000555555078c&#13;
0x7fffffef50:   0x0000005500000003      0x0000000000000000</pre>&#13;
<span epub:type="pagebreak" id="page_312"/>&#13;
<p class="indent">This view shows that each time <code>factorial</code> was called, it created a new stack frame. It also shows where the input to each call of <code>factorial</code> has been saved on the stack, the last one being <code>0</code> <span class="ent">❶</span>. Since this is the base case, the program flow went directly to the end of the function.</p>&#13;
<p class="indent">The return address stored in the frame records of the top three stack frames is <code>0x00000055555507d0</code>. When each recursive call to <code>factorial</code> returns, it returns to the instruction immediately following the <code>bl factorial</code> instruction in the <code>factorial</code> function itself. When we continue execution of the program, it again breaks at our second breakpoint:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
&#13;
Breakpoint 2, base_case () at factorial.s:28&#13;
28              ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
(gdb) <span class="codestrong1">i r x0 x1 sp pc</span>&#13;
x0             0x1                 1&#13;
x1             0x1                 1&#13;
sp             0x7fffffef00        0x7fffffef00&#13;
pc             0x55555507d8        0x55555507d8 &lt;base_case&gt;&#13;
(gdb) <span class="codestrong1">x/12gx 0x7fffffef00</span>&#13;
0x7fffffef00:   0x0000007fffffef20      0x00000055555507d0&#13;
0x7fffffef10:   0x0000007f00000001      0x0000000000000000&#13;
0x7fffffef20:   0x0000007fffffef40      0x00000055555507d0&#13;
0x7fffffef30:   0x0000007f00000002      0x000000555555081c&#13;
0x7fffffef40:   0x0000007fffffef60      0x000000555555078c&#13;
0x7fffffef50:   0x0000005500000003      0x0000000000000000</pre>&#13;
<p class="indent">Comparing this display with the previous display, we can see that the top frame record—the one created when <code>factorial</code> was called with the base case of <code>0</code> as input—has been removed from the stack.</p>&#13;
<p class="indent">When we continue, the program breaks again at the second breakpoint before returning from this invocation of <code>factorial</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
&#13;
Breakpoint 2, base_case () at factorial.s:28&#13;
28              ldp     fp, lr, [sp], FRAME   // Delete stack frame</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_313"/>Using the continue command (<code>c</code>) once more takes us back to the original call to <code>factorial</code> from <code>main</code>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
&#13;
Breakpoint 2, base_case () at factorial.s:28&#13;
28              ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
(gdb) <span class="codestrong1">i r x0 x1 sp pc</span>&#13;
x0             0x6                 6&#13;
x1             0x3                 3&#13;
sp             0x7fffffef40        0x7fffffef40&#13;
pc             0x55555507d8        0x55555507d8 &lt;base_case&gt;&#13;
(gdb) <span class="codestrong1">x/4gx 0x7fffffef40</span>&#13;
0x7fffffef40:   0x0000007fffffef60   <span class="ent">➊</span> 0x000000555555078c&#13;
0x7fffffef50:   0x0000005500000003      0x0000000000000000</pre>&#13;
<p class="indent">The return address in the frame record is back in <code>main</code> <span class="ent">❶</span>. When we continue, <code>main</code> prints the result for us:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
3! = 6&#13;
[Inferior 1 (process 2310) exited normally]&#13;
(gdb)</pre>&#13;
<p class="noindent">The debugger has also printed some information about the process for us. We’re still in <code>gdb</code> and need to quit that.</p>&#13;
<p class="indent">Looking back at the stack display when the program is at the base case (<a href="ch15.xhtml#page_311">page 311</a>), notice that each call to the recursive function creates another stack frame. We used a small number in this example, but computing the factorial of a large number would use a lot of stack space. And since there is a call to a function in each repetition, recursive algorithms can be time-consuming.</p>&#13;
<p class="indent">Every recursive solution has an equivalent iterative solution, which is usually more efficient, both in time and in stack usage. For example, the iterative algorithm to compute the factorial of an integer (see <a href="ch15.xhtml#page_306">page 306</a>) is simple, so an iterative solution might be preferable. However, many problems (such as some sorting algorithms) lend themselves more naturally to a recursive solution. For such problems, the increased simplicity of the code is often worth the cost of recursion.</p>&#13;
<p class="indent">We would typically write a recursive function in a higher-level language, but I used assembly language here so you can gain an understanding of how recursion works. Next, I’ll show you how to use assembly language to access hardware features that might not be directly accessible in the high-level language you’re using.</p>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_314"/><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch15exe1">15.1     Enter the C program in <a href="ch15.xhtml#ch15list1">Listings 15-1</a> to <a href="ch15.xhtml#ch15list3">15-3</a>. Run your program under <code>gdb</code>, with breakpoints at the beginning of the <code>if</code> statement and at the <code>return</code> statement. Each time it breaks, you should see the value of <code>n</code> that was the input to the current call to <code>factorial</code>. The <code>bt</code> (backtrace) and <code>info f</code> (frame information) <code>gdb</code> commands will give you more information about the stack frames, which can be helpful in debugging recursive C functions.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec2"><strong>Accessing CPU Features in Assembly Language</strong></h3>&#13;
<p class="noindent">In <a href="ch14.xhtml">Chapter 14</a>, it may have seemed a bit silly to create a whole subfunction just to add two integers for the <code>sum_ints</code> program (see <a href="ch14.xhtml#ch14list8">Listing 14-8</a>), which can be done with a single instruction. But as you learned in <a href="ch03.xhtml">Chapter 3</a>, even simple addition can produce carry or overflow.</p>&#13;
<p class="indent">The <code>add</code> and <code>sub</code> instructions you learned about in <a href="ch11.xhtml">Chapter 11</a> have no effect on the condition flags, but the A64 architecture includes variants of <code>add</code> and <code>sub</code>, <code>adds</code> and <code>subs</code>, that will set the condition flags in the <code>nzcv</code> register according to the result of the operation.</p>&#13;
<p class="indent">C and C++ don’t provide a way to check the overflow or carry flags in the <code>nzcv</code> register. In this section, I’ll show you two ways to use assembly language in C programs to indicate when there is overflow from addition: we can write a separate function in assembly language that is callable from our C code, or we can embed assembly language directly within our C code.</p>&#13;
<h4 class="h4" id="ch15lev2sec1"><em><strong>Writing a Separate Function</strong></em></h4>&#13;
<p class="noindent">I’ll start by rewriting the <code>sum_ints</code> program from <a href="ch14.xhtml">Chapter 14</a> in C so that it warns the user if the addition produces overflow. I’ll check for overflow in the subfunction <code>add_two</code>, and I’ll pass the result back to the <code>main</code> function using the return mechanism.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list6">Listing 15-6</a> shows the modified <code>main</code> function that checks the return value from the <code>add_two</code> function for overflow.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and show if there is overflow.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_two.h"&#13;
&#13;
int main(void)&#13;
{&#13;
    int x, y, z, overflow;&#13;
  &#13;
    printf("Enter an integer: ");&#13;
    scanf("%i", &amp;x);&#13;
    printf("Enter an integer: ");&#13;
    scanf("%i", &amp;y);&#13;
    overflow = add_two(&amp;z, x, y);&#13;
    printf("%i + %i = %i\n", x, y, z);&#13;
    if (overflow)&#13;
        printf("** Overflow occurred **\n");&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_315"/>&#13;
<p class="list" id="ch15list6"><em>Listing 15-6: A program to add two integers and show if there is overflow</em></p>&#13;
<p class="indent">Next, I’ll rewrite the <code>add_two</code> function such that it returns 0 if there is no overflow and 1 if there is overflow (recall that in C, zero is logically false and a nonzero value is true). I’ll assign this result to the variable <code>overflow</code> in <code>main</code>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list7">Listing 15-7</a> shows the header file for the new <code>add_two</code> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and return 1 for overflow, 0 for no overflow.&#13;
&#13;
#ifndef ADD_TWO_H&#13;
#define ADD_TWO_H&#13;
int add_two(int *a, int b, int c);&#13;
#endif</pre>&#13;
<p class="list" id="ch15list7"><em>Listing 15-7: The header file for the</em> <span class="codeitalic">add_two</span> <em>function</em></p>&#13;
<p class="indent">The only change in the function declaration is returning an <code>int</code> instead of <code>void</code>. We need to add a check for overflow in the definition of the <code>add_two</code> function, as shown in <a href="ch15.xhtml#ch15list8">Listing 15-8</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and return 1 for overflow, 0 for no overflow.&#13;
&#13;
#include "add_two.h"&#13;
&#13;
int add_two(int *a, int b, int c)&#13;
{&#13;
    int sum;&#13;
    int overflow = 0;   // Assume no overflow&#13;
  &#13;
    sum = b + c;&#13;
 <span class="ent">➊</span> if (((b &gt; 0) &amp;&amp; (c &gt; 0) &amp;&amp; (sum &lt; 0)) ||&#13;
            ((b &lt; 0) &amp;&amp; (c &lt; 0) &amp;&amp; (sum &gt; 0))) {&#13;
        overflow = 1;&#13;
    }&#13;
    *a = sum;&#13;
&#13;
    return overflow;&#13;
}</pre>&#13;
<p class="list" id="ch15list8"><em>Listing 15-8: A function to add two integers and return an overflow indication</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>You learned in <a href="ch03.xhtml">Chapter 3</a> that if adding two integers of the same sign gives a result of the opposite sign, you have overflow, so we use this logic as the check for overflow <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15list9">Listing 15-9</a> shows the assembly language generated by the compiler from this C source.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "add_two.c"&#13;
        .text&#13;
        .align  2&#13;
        .global add_two&#13;
        .type   add_two, %function&#13;
add_two:&#13;
        sub     sp, sp, #32&#13;
        str     x0, [sp, 12]    /// a&#13;
        str     w1, [sp, 8]     /// b&#13;
        str     w2, [sp]        /// c&#13;
        str     wzr, [sp, 28]   /// overflow = 0;&#13;
        ldr     w1, [sp, 12]&#13;
        ldr     w0, [sp, 8]&#13;
        add     w0, w1, w0&#13;
        str     w0, [sp, 24]&#13;
     <span class="ent">➊</span> ldr     w0, [sp, 12]    /// Start overflow check&#13;
        cmp     w0, 0&#13;
        ble     .L2&#13;
        ldr     w0, [sp, 8]&#13;
        cmp     w0, 0&#13;
        ble     .L2&#13;
        ldr     w0, [sp, 24]&#13;
        cmp     w0, 0&#13;
        blt     .L3&#13;
.L2:&#13;
        ldr     w0, [sp, 12]&#13;
        cmp     w0, 0&#13;
        bge     .L4&#13;
        ldr     w0, [sp, 8]&#13;
        cmp     w0, 0&#13;
        bge     .L4&#13;
        ldr     w0, [sp, 24]&#13;
        cmp     w0, 0&#13;
        ble     .L4&#13;
.L3:&#13;
        mov     w0, 1&#13;
        str     w0, [sp, 28]    /// overflow = 1;&#13;
.L4:&#13;
        ldr     x0, [sp]&#13;
        ldr     w1, [sp, 24]&#13;
        str     w1, [x0]&#13;
        ldr     w0, [sp, 28]&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   addTwo, .-addTwo&#13;
        .ident  "GCC: Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_317"/>&#13;
<p class="list" id="ch15list9"><em>Listing 15-9: The compiler-generated assembly language for the</em> <span class="codeitalic">add_two</span> <em>function in <a href="ch15.xhtml#ch15list8">Listing 15-8</a></em></p>&#13;
<p class="indent">As you can see, it takes about 20 instructions to check for overflow in C <span class="ent">❶</span>. In <a href="ch15.xhtml#ch15list10">Listing 15-10</a>, I rewrite the <code>add_two</code> function in assembly language so I can use the <code>adds</code> instruction for the addition operation and then detect overflow from the condition flags in the <code>nzcv</code> register.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and output the sum; return overflow T or F.&#13;
// Calling sequence:&#13;
//    x0 &lt;- address a, for output&#13;
//    w1 &lt;- integer b&#13;
//    w2 &lt;- integer c&#13;
//    Returns 1 for overflow, 0 for no overflow&#13;
        .arch armv8-a&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global add_two&#13;
        .type   add_two, %function&#13;
add_two:&#13;
        adds    w1, w1, w2            // Add and set condition flags&#13;
        str     w1, [x0]              // Store output&#13;
     <span class="ent">➊</span> cinc    w0, wzr, vs           // Overflow flag&#13;
        ret                           // Back to caller</pre>&#13;
<p class="list" id="ch15list10"><em>Listing 15-10: The</em> <span class="codeitalic">add_two</span> <em>function with overflow detection in assembly language</em></p>&#13;
<p class="indent">I didn’t create a stack frame for this very simple leaf function because it is unlikely we would ever modify this function to call another function.</p>&#13;
<p class="indent">I used the <code>cinc</code> instruction <span class="ent">❶</span> to read the overflow flag in the <code>nzcv</code> register and load the <code>w0</code> register with either a <code>0</code> or a <code>1</code>, depending on whether the overflow flag is <code>0</code> or <code>1</code>:</p>&#13;
<h5 class="h5" id="ch15lev3sec1"><span class="codestrong">cinc</span><strong>—Conditional increment</strong></h5>&#13;
<p class="noindentin"><code>cinc w</code><span class="codeitalic">d</span> <code>, w</code><span class="codeitalic">s</span> <code>,</code> <span class="codeitalic">cond</span> moves the value in <code>w</code><span class="codeitalic">s</span> to <code>w</code><span class="codeitalic">d</span>, adding 1 to the value if <span class="codeitalic">cond</span> is true.</p>&#13;
<p class="noindentin"><code>cinc x</code><span class="codeitalic">d</span> <code>, x</code><span class="codeitalic">s</span> <code>,</code> <span class="codeitalic">cond</span> moves the value in <code>x</code><span class="codeitalic">s</span> to <code>x</code><span class="codeitalic">d</span>, adding 1 to the value if <span class="codeitalic">cond</span> is true.</p>&#13;
<p class="indentgt">The possible values for <span class="codeitalic">cond</span> are given in <a href="ch13.xhtml#ch13tab1">Table 13-1</a> in <a href="ch13.xhtml">Chapter 13</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_318"/>Using the assembly language version of <code>add_two</code> in <a href="ch15.xhtml#ch15list10">Listing 15-10</a> with the <code>main</code> function in <a href="ch15.xhtml#ch15list6">Listing 15-6</a> shows one of the reasons for writing a subfunction in assembly language. It allows us to access a feature of the CPU, the <code>V</code> flag in the <code>nzcv</code> register, that is not accessible in C, the higher-level language we’re using. Writing in assembly language allows us to ensure that there are no intervening instructions that might change the flags between the operation (addition, in this example) and the flag check.</p>&#13;
<p class="indent">This example also illustrates a common use of the return value. Inputs and outputs are often passed in the argument list, with supplemental information about the computation carried in the return value.</p>&#13;
<p class="indent">That said, calling a function to simply add two numbers is inefficient. In the next section, we’ll look at a common extension to C that allows us to insert assembly language directly in our C code.</p>&#13;
<h4 class="h4" id="ch15lev2sec2"><em><strong>Using Inline Assembly Language</strong></em></h4>&#13;
<p class="noindent">Like many C compilers, <code>gcc</code> includes an extension to the standard C language that allows us to embed assembly language in our C code, usually called <em>inline assembly</em>. Doing so can be complex. We’ll look at a simple case here. You can read the details at <em><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html</a></em>, or you can use the <code>info gcc</code> command and select <strong>C Extensions ▶ Using Assembly Language with C ▶ Extended Asm</strong>.</p>&#13;
<p class="indent">The <code>gcc</code> compiler uses the following general form for embedding assembly language in C, which starts with the <code>asm</code> keyword:</p>&#13;
<pre class="pre">asm <span class="codeitalic1">asm-qualifiers</span> (<span class="codeitalic1">assembly language statements</span> &#13;
               : <span class="codeitalic1">output operands</span>&#13;
               : <span class="codeitalic1">input operands</span>&#13;
               : <span class="codeitalic1">clobbers</span>);</pre>&#13;
<p class="indent">The <span class="codeitalic">asm-qualifiers</span> are used to help the compiler optimize the C code, a topic that is beyond the scope of this book. We’re not asking the compiler to optimize our C code, so we won’t use <span class="codeitalic">asm-qualifiers</span>.</p>&#13;
<p class="indent">The <span class="codeitalic">output operands</span> are the C variables that could be changed by the <span class="codeitalic">assembly language statements</span>, thus acting as outputs from the <span class="codeitalic">assembly language statements</span>. The <span class="codeitalic">input operands</span> refer to the C variables that are used by the <span class="codeitalic">assembly language statements</span> but are not changed, thus acting as inputs to the <span class="codeitalic">assembly language statements</span>. The <span class="codeitalic">clobbers</span> are the registers that get explicitly changed by the <span class="codeitalic">assembly language statements</span>, thus telling the compiler about the possible changes in these registers.</p>&#13;
<p class="indent">In <a href="ch15.xhtml#ch15list11">Listing 15-11</a>, I use inline assembly language to check for overflow in the addition.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and show if there is overflow.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
int main(void)&#13;
{&#13;
    int x, y, z, overflow;&#13;
    &#13;
    printf("Enter an integer: ");&#13;
    scanf("%i", &amp;x);&#13;
    printf("Enter an integer: ");&#13;
    scanf("%i", &amp;y);&#13;
&#13;
 <span class="ent">➊</span> asm ("adds %w0, %w2, %w3\n"&#13;
        "cinc %w1, wzr, vs"&#13;
     <span class="ent">➋</span> : "=r" (z), "=r" (overflow)&#13;
     <span class="ent">➌</span> : "r" (x), "r" (y));&#13;
&#13;
    printf("%i + %i = %i\n", x, y, z);&#13;
    if (overflow)&#13;
        printf("** Overflow occurred **\n");&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_319"/>&#13;
<p class="list" id="ch15list11"><em>Listing 15-11: A program to add two integers and show if there’s overflow</em></p>&#13;
<p class="indent">The first thing to note about the code here is that it’s important to place the <code>adds</code> instruction in assembly language so we can check for overflow immediately after the instruction is executed <span class="ent">❶</span>. If we were to do the addition in C, the compiler would use the <code>add</code> instruction, as in <a href="ch15.xhtml#ch15list9">Listing 15-9</a>, which does not set the condition flags.</p>&#13;
<p class="indent">There is a template for each assembly language instruction as a text string enclosed in quotes <span class="ent">❶</span>. The operands for each instruction are numbered according to their relative position on the <em>output:input</em> operand list, starting from 0. I preface the variable numbers with <code>w</code> in the assembly language template to tell the compiler that these are word (32-bit) values. Remember that assembly language code is line-oriented, so it’s important to place a newline character, <code>\n</code>, at the end of each assembly language statement. The newline is not needed at the end of the last assembly language statement.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be careful not to confuse operand numbers with register numbers.</em> <span class="codeitalic">%w0</span> <em>is the 32-bit value of the first operand on our</em> output:input <em>operand list, and</em> <span class="codeitalic">w0</span> <em>is the low-order 32 bits of the</em> <span class="codeitalic">x0</span> <em>register.</em></p>&#13;
</div>&#13;
<p class="indent">The syntax for each output or input operand is:</p>&#13;
<pre class="pre">"<span class="codeitalic1">constraint</span> " (<span class="codeitalic1">C variable name</span> )</pre>&#13;
<p class="noindent">In our program, <code>z</code> is in position 0 and <code>overflow</code> is in position 1 <span class="ent">❷</span>; <code>x</code> is in position 2 and <code>y</code> is in position 3 <span class="ent">❸</span>.</p>&#13;
<p class="indent">The <span class="codeitalic">constraint</span> tells the compiler what kind of operand it can use in the assembly language template. For example, <code>"m"</code> means the compiler should <span epub:type="pagebreak" id="page_320"/>use a memory location and <code>"r"</code> means it should use a register. Prefixing the kind with <code>=</code> tells the compiler that our assembly language stores a value there. The <code>"=r" (z)</code> constraint thus tells the compiler that it needs to use a register for the <code>%w0</code> operand, that our assembly language will store a value in that register, and to store the value in that register in the C variable <code>z</code> <span class="ent">❷</span>. The <code>"r" (x)</code> constraint tells the compiler to use a register for the value in the C variable <code>x</code>, but our assembly language does not change the value in that register <span class="ent">❸</span>.</p>&#13;
<p class="indent">Be aware that when you use inline assembly language, the compiler could generate assembly language for your C code that does not work well with your assembly language. It’s a good idea to generate the assembly language for the entire function (using the <code>-S</code> compiler option) and read it carefully to make sure the function is doing what you intend. We’ll do this in <a href="ch15.xhtml#ch15list12">Listing 15-12</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "sum_ints.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "Enter an integer: "&#13;
        .align  3&#13;
.LC1:&#13;
        .string "%i"&#13;
        .align  3&#13;
.LC2:&#13;
        .string "%i + %i = %i\n"&#13;
        .align  3&#13;
.LC3:&#13;
        .string "** Overflow occurred **"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        add     x0, sp, 20&#13;
        mov     x1, x0&#13;
        adrp    x0, .LC1&#13;
        add     x0, x0, :lo12:.LC1&#13;
        bl      __isoc99_scanf&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        add     x0, sp, 16&#13;
        mov     x1, x0&#13;
        adrp    x0, .LC1&#13;
        add     x0, x0, :lo12:.LC1&#13;
        bl      __isoc99_scanf&#13;
     <span class="ent">➊</span> ldr     w0, [sp, 20]    /// w0 &lt;- x&#13;
        ldr     w1, [sp, 16]    /// w1 &lt;- y&#13;
#APP&#13;
// 14 "sumInts.c" 1&#13;
        adds w1, w0, w1&#13;
csinc w0, wzr, wzr, vc&#13;
// 0 "" 2&#13;
#NO_APP&#13;
     <span class="ent">➋</span> str     w1, [sp, 28]    /// z &lt;- result of addition&#13;
        str     w0, [sp, 24]    /// overflow &lt;- overflow flag&#13;
        ldr     w0, [sp, 20]&#13;
        ldr     w1, [sp, 16]&#13;
        ldr     w3, [sp, 28]&#13;
        mov     w2, w1&#13;
        mov     w1, w0&#13;
        adrp    x0, .LC2&#13;
        add     x0, x0, :lo12:.LC2&#13;
        bl      printf&#13;
        ldr     w0, [sp, 24]&#13;
        cmp     w0, 0&#13;
        beq     .L2&#13;
        adrp    x0, .LC3&#13;
        add     x0, x0, :lo12:.LC3&#13;
        bl      puts&#13;
.L2:&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_321"/>&#13;
<p class="list" id="ch15list12"><em>Listing 15-12: The compiler-generated code for inline assembly</em></p>&#13;
<p class="indent">We told the compiler that the assembly language we’ve inserted uses registers for the inputs (<code>"r"</code>), so it loads the values from the C variables into registers <span class="ent">❶</span>. Similarly, we specified that we’re using registers for the outputs in our assembly language (<code>"=r"</code>), and the compiler stores the values from the registers into the C variables <span class="ent">❷</span>.</p>&#13;
<p class="indent">If you think inline assembly looks tricky, you’re right. The C language standard lists inline assembly as a common extension to the language but <span epub:type="pagebreak" id="page_322"/>points out that extensions are not part of the standard. This means that using inline assembly in C code may not work if you use a different compiler, even on the same computer. In most cases, if I need to use assembly language, I use a separate function, as we did in <a href="ch15.xhtml#ch15list10">Listing 15-10</a>, which is portable between compilers.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch15exe2">15.2     Modify the C program in <a href="ch15.xhtml#ch15list6">Listings 15-6</a>, <a href="ch15.xhtml#ch15list7">15-7</a>, and <a href="ch15.xhtml#ch15list8">15-8</a> to use <code>unsigned int</code>s and tell the user when the addition produces carry. It will declare the variables as follows:</p>&#13;
<pre class="preb">unsigned int x = 0, y = 0, z;</pre>&#13;
<p class="box-listno">The formatting code for reading and printing the values of the <code>unsigned int</code>s is <code>%u</code>. Here’s an example:</p>&#13;
<pre class="preb">scanf("%u", &amp;x);</pre>&#13;
<p class="box-list1" id="ch15exe3">15.3     Modify the program in <a href="ch15.xhtml#ch15list11">Listing 15-11</a> to use <code>unsigned int</code>s and tell the user when the addition produces carry.</p>&#13;
<p class="box-list1" id="ch15exe4">15.4     Modify the program in <a href="ch15.xhtml#ch15list11">Listing 15-11</a> to use <code>register int</code>s for the <code>z</code> and <code>overflow</code> variables. How does this change the compiler-generated assembly language?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec3"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Recursion</strong> Allows for simple and elegant solutions to some problems, but uses a lot of stack space.</p>&#13;
<p class="noindentin"><strong>Accessing hardware features</strong> Most programming languages do not allow direct access to all the hardware features in a computer. Using an assembly language subfunction or inline assembly language may be the best solution.</p>&#13;
<p class="noindentin"><strong>Inline assembly</strong> Allows us to embed assembly language in our C code frame pointer and the return address to the calling function.</p>&#13;
<p class="indentgt">Now that you know some common ways to use functions in a program, we’ll move on to multiplication, division, and logic operations. In the next chapter, you’ll learn how to convert a string of numerals in ASCII code to the integer they represent.</p>&#13;
</div>
</div>
</body></html>