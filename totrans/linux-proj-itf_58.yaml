- en: 'Chapter 58. Sockets: Fundamentals of TCP/IP Networks'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第58章：套接字：TCP/IP网络基础
- en: This chapter provides an introduction to computer networking concepts and the
    TCP/IP networking protocols. An understanding of these topics is necessary to
    make effective use of Internet domain sockets, which are described in the next
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了计算机网络概念和TCP/IP网络协议。理解这些内容是有效使用互联网域套接字所必需的，互联网域套接字将在下一章中描述。
- en: Starting in this chapter, we begin mentioning various *Request for Comments*
    (RFC) documents. Each of the networking protocols discussed in this book is formally
    described in an RFC. We provide further information about RFCs, as well as a list
    of RFCs of particular relevance to the material covered in this book, in Section
    58.7.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将提到各种*请求评论*（RFC）文档。本书中讨论的每个网络协议都有一个正式描述的RFC。我们将在第58.7节提供有关RFC的更多信息，以及与本书内容相关的RFC列表。
- en: Internets
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网
- en: An *internetwork* or, more commonly, *internet* (with a lowercase *i*), connects
    different computer networks, allowing hosts on all of the networks to communicate
    with one another. In other words, an internet is a network of computer networks.
    The term *subnetwork*, or *subnet*, is used to refer to one of the networks composing
    an internet. An internet aims to hide the details of different physical networks
    in order to present a unified network architecture to all hosts on the connected
    networks. This means, for example, that a single address format is used to identify
    all hosts in the internet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Internetwork*（或更常见的*internet*，首字母小写的*i*）连接不同的计算机网络，使所有网络中的主机能够相互通信。换句话说，互联网是计算机网络的网络。术语*子网络*（或*subnet*）用于指代组成互联网的其中一个网络。互联网的目的是隐藏不同物理网络的细节，以便向连接网络上的所有主机呈现统一的网络架构。这意味着，例如，所有主机在互联网中的地址格式是统一的。'
- en: Although various internetworking protocols have been devised, TCP/IP has become
    the dominant protocol suite, supplanting even the proprietary networking protocols
    that were formerly common on local and wide area networks. The term *Internet*
    (with an uppercase *I*) is used to refer to the TCP/IP internet that connects
    millions of computers globally.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经制定了各种互联网络协议，但TCP/IP已成为主流协议套件，甚至取代了以前在局域网和广域网中常见的专有网络协议。术语*互联网*（首字母大写的*I*）用于指代连接全球数百万台计算机的TCP/IP互联网。
- en: The first widespread implementation of TCP/IP appeared with 4.2BSD in 1983.
    Several implementations of TCP/IP are derived directly from the BSD code; other
    implementations, including the Linux implementation, are written from scratch,
    taking the operation of the BSD code as a reference standard defining the operation
    of TCP/IP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP的首次广泛实现出现在1983年的4.2BSD中。多个TCP/IP实现直接源自BSD代码；其他实现，包括Linux实现，是从头编写的，以BSD代码的操作为参考标准，定义TCP/IP的操作。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: TCP/IP grew out of a project sponsored by the US Department of Defense Advanced
    Research Projects Agency (ARPA, later DARPA, with the *D* for Defense) to devise
    a computer networking architecture to be used in the ARPANET, an early wide area
    network. During the 1970s, a new family of protocols was designed for the ARPANET.
    Accurately, these protocols are known as the DARPA Internet protocol suite, but
    more usually they are known as the TCP/IP protocol suite, or simply TCP/IP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP源自美国国防部高级研究计划局（ARPA，后来的DARPA，*D*代表Defense）资助的一个项目，旨在设计一种计算机网络架构，用于ARPANET——一个早期的广域网。在1970年代，为ARPANET设计了一种新的协议族。准确地说，这些协议被称为DARPA互联网协议套件，但更常见的名称是TCP/IP协议套件，简称TCP/IP。
- en: The web page [http://www.isoc.org/internet/history/brief.shtml](http://www.isoc.org/internet/history/brief.shtml)
    provides a brief history of the Internet and TCP/IP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网页[http://www.isoc.org/internet/history/brief.shtml](http://www.isoc.org/internet/history/brief.shtml)提供了互联网和TCP/IP的简要历史。
- en: '[Figure 58-1](ch58.html#an_internet_using_a_router_to_connect_tw "Figure 58-1. An
    internet using a router to connect two networks") shows a simple internet. In
    this diagram, the machine `tekapo` is an example of a *router*, a computer whose
    function is to connect one subnetwork to another, transferring data between them.
    As well as understanding the internet protocol being used, a router must also
    understand the (possibly) different data-link-layer protocols used on each of
    the subnets that it connects.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 58-1](ch58.html#an_internet_using_a_router_to_connect_tw "图 58-1. 使用路由器连接两个网络的互联网")
    显示了一个简单的互联网。在此图中，机器 `tekapo` 是 *路由器* 的例子，一台计算机，其功能是将一个子网络连接到另一个子网络，传输数据。在理解所使用的互联网协议的同时，路由器还必须理解它所连接的每个子网上（可能不同的）数据链路层协议。'
- en: A router has multiple network interfaces, one for each of the subnets to which
    it is connected. The more general term *multihomed host* is used for any host—not
    necessarily a router—with multiple network interfaces. (Another way of describing
    a router is to say that it is a multihomed host that forwards packets from one
    subnet to another.) A multihomed host has a different network address for each
    of its interfaces (i.e., a different address on each of the subnets to which it
    is connected).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器具有多个网络接口，每个接口连接一个子网。更为通用的术语 *多宿主主机* 用来描述任何具有多个网络接口的主机——不仅限于路由器。（另一种描述路由器的方式是：它是一个多宿主主机，将数据包从一个子网转发到另一个子网。）多宿主主机的每个接口都有不同的网络地址（即，它连接的每个子网上都有一个不同的地址）。
- en: '![An internet using a router to connect two networks](figs/web/58-1_SOCKNW-internet-scale90.png.jpg)Figure 58-1. An
    internet using a router to connect two networks'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用路由器连接两个网络的互联网](figs/web/58-1_SOCKNW-internet-scale90.png.jpg)图 58-1. 使用路由器连接两个网络的互联网'
- en: Networking Protocols and Layers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络协议与层次结构
- en: A *networking protocol* is a set of rules defining how information is to be
    transmitted across a network. Networking protocols are generally organized as
    a series of *layers*, with each layer building on the layer below it to add features
    that are made available to higher layers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络协议* 是一组定义如何在网络中传输信息的规则。网络协议通常被组织为一系列 *层*，每一层都在其下层的基础上构建，添加可以供上层使用的功能。'
- en: The *TCP/IP protocol suite* is a layered networking protocol ([Figure 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite
    "Figure 58-2. Protocols in the TCP/IP suite")). It includes the *Internet Protocol*
    (IP) and various protocols layered above it. (The code that implements these various
    layers is commonly referred to as a *protocol stack*.) The name TCP/IP derives
    from the fact that the *Transmission Control Protocol* (TCP) is the most heavily
    used transport-layer protocol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP/IP 协议套件* 是一个分层的网络协议（[图 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite
    "图 58-2. TCP/IP 协议套件中的协议")）。它包括 *互联网协议*（IP）以及位于其之上的各种协议。（实现这些不同层的代码通常被称为 *协议栈*。）TCP/IP
    这个名称来源于 *传输控制协议*（TCP），因为它是最广泛使用的传输层协议。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have omitted a range of other TCP/IP protocols from [Figure 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite
    "Figure 58-2. Protocols in the TCP/IP suite") because they are not relevant to
    this chapter. The *Address Resolution Protocol* (ARP) is concerned with mapping
    Internet addresses to hardware (e.g., Ethernet) addresses. The *Internet Control
    Message Protocol* (ICMP) is used to convey error and control information across
    the network. (ICMP is used by the *ping* program, which is frequently employed
    to check whether a particular host is alive and visible on a TCP/IP network, and
    by *traceroute*, which traces the path of an IP packet through the network.) The
    *Internet Group Management Protocol* (IGMP) is used by hosts and routers that
    support multicasting of IP datagrams.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从 [图 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite "图 58-2. TCP/IP
    协议套件中的协议") 中省略了其他一些 TCP/IP 协议，因为它们与本章无关。*地址解析协议*（ARP）用于将互联网地址映射到硬件地址（例如以太网地址）。*互联网控制消息协议*（ICMP）用于在网络中传递错误和控制信息。（ICMP
    被 *ping* 程序使用，常用于检查某一主机是否存活并在 TCP/IP 网络中可见，此外还被 *traceroute* 使用，用于追踪 IP 数据包在网络中的路径。）*互联网组管理协议*（IGMP）用于支持
    IP 数据报多播的主机和路由器。
- en: '![Protocols in the TCP/IP suite](figs/web/58-2_SOCKNW-IP-protocols.png.jpg)Figure 58-2. Protocols
    in the TCP/IP suite'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![TCP/IP 协议套件中的协议](figs/web/58-2_SOCKNW-IP-protocols.png.jpg)图 58-2. TCP/IP
    协议套件中的协议'
- en: One of the notions that lends great power and flexibility to protocol layering
    is *transparency*—each protocol layer shields higher layers from the operation
    and complexity of lower layers. Thus, for example, an application making use of
    TCP only needs to use the standard sockets API and to know that it is employing
    a reliable, byte-stream transport service. It doesn’t need to understand the details
    of the operation of TCP. (When we look at socket options in [Socket Options](ch61.html#socket_options
    "Socket Options"), we’ll see that this doesn’t always strictly hold true; occasionally,
    an application does need to know some of the details of the operation of the underlying
    transport protocol.) Nor does the application need to know the details of the
    operation of IP or of the data-link layer. From the point of view of the applications,
    it is as though they are communicating directly with each other via the sockets
    API, as shown in [Figure 58-3](ch58.html#layered_communication_via_the_tcp_solidu
    "Figure 58-3. Layered communication via the TCP/IP protocols"), where the dashed
    horizontal lines represent the virtual communication paths between corresponding
    application, TCP, and IP entities on the two hosts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 协议分层赋予协议强大灵活性的概念之一是*透明性*——每一层协议都将上层与下层的操作和复杂性隔离开来。因此，例如，使用 TCP 的应用程序只需使用标准的套接字
    API，并知道它正在使用一个可靠的字节流传输服务。它不需要了解 TCP 操作的细节。（当我们查看[套接字选项](ch61.html#socket_options
    "Socket Options")时，会看到这并不总是严格成立；有时，应用程序确实需要知道一些底层传输协议操作的细节。）应用程序也不需要了解 IP 或数据链路层操作的细节。从应用程序的角度来看，就像它们通过套接字
    API 直接相互通信，如[图 58-3](ch58.html#layered_communication_via_the_tcp_solidu "Figure 58-3. Layered
    communication via the TCP/IP protocols")所示，其中虚线水平线表示两个主机上的应用程序、TCP 和 IP 实体之间的虚拟通信路径。
- en: Encapsulation
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is an important principle of a layered networking protocol. [Figure 58-4](ch58.html#encapsulation_within_the_tcp_solidus_ip
    "Figure 58-4. Encapsulation within the TCP/IP protocol layers") shows an example
    of encapsulation in the TCP/IP protocol layers. The key idea of encapsulation
    is that the information (e.g., application data, a TCP segment, or an IP datagram)
    passed from a higher layer to a lower layer is treated as opaque data by the lower
    layer. In other words, the lower layer makes no attempt to interpret information
    sent from the upper layer, but merely places that information inside whatever
    type of packet is used in the lower layer and adds its own layer-specific header
    before passing the packet down to the next lower layer. When data is passed up
    from a lower layer to a higher layer, a converse unpacking process takes place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是分层网络协议的重要原则。[图 58-4](ch58.html#encapsulation_within_the_tcp_solidus_ip "Figure 58-4. Encapsulation
    within the TCP/IP protocol layers")展示了 TCP/IP 协议层中封装的一个例子。封装的关键思想是，传递给下层的信息（例如应用数据、TCP
    段或 IP 数据报）被下层视为不透明数据。换句话说，下层不会尝试解释来自上层的信息，而只是将该信息放入下层使用的任何类型的数据包中，并在将数据包传递给下一层时添加其特有的头部。当数据从下层传递到上层时，会进行相反的解包过程。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t show it in [Figure 58-4](ch58.html#encapsulation_within_the_tcp_solidus_ip
    "Figure 58-4. Encapsulation within the TCP/IP protocol layers"), but the concept
    of encapsulation also extends down into the data-link layer, where IP datagrams
    are encapsulated inside network frames. Encapsulation may also extend up into
    the application layer, where the application may perform its own packaging of
    data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图 58-4](ch58.html#encapsulation_within_the_tcp_solidus_ip "Figure 58-4. Encapsulation
    within the TCP/IP protocol layers")中没有展示这一点，但封装的概念也延伸到数据链路层，在那里，IP 数据报被封装在网络帧中。封装也可能延伸到应用层，在那里应用程序可能会执行自己的数据打包。
- en: The Data-Link Layer
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据链路层
- en: The lowest layer in [Figure 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite
    "Figure 58-2. Protocols in the TCP/IP suite") is the *data-link layer*, which
    consists of the device driver and the hardware interface (network card) to the
    underlying physical medium (e.g., a telephone line, a coaxial cable, or a fiber-optic
    cable). The data-link layer is concerned with transferring data across a physical
    link in a network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite "Figure 58-2. Protocols
    in the TCP/IP suite")中最底层是*数据链路层*，它由设备驱动程序和硬件接口（网络卡）组成，连接到底层的物理介质（例如电话线、同轴电缆或光纤电缆）。数据链路层负责在网络中的物理链路上传输数据。'
- en: To transfer data, the data-link layer encapsulates datagrams from the network
    layer into units called *frames*. In addition to the data to be transmitted, each
    frame includes a header containing, for example, the destination address and frame
    size. The data-link layer transmits the frames across the physical link and handles
    acknowledgements from the receiver. (Not all data-link layers use acknowledgements.)
    This layer may perform error detection, retransmission, and flow control. Some
    data-link layers also split large network packets into multiple frames and reassemble
    them at the receiver.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传输数据，数据链路层将来自网络层的数据报封装成称为*帧*的单元。除了待传输的数据，每个帧还包括一个头部，头部中包含目的地址和帧大小等信息。数据链路层通过物理链路传输帧，并处理来自接收方的确认。
    （并非所有的数据链路层都使用确认。）此层还可能执行错误检测、重传和流量控制。一些数据链路层还将大的网络数据包分割成多个帧，并在接收方重新组装。
- en: From an application-programming point of view, we can generally ignore the data-link
    layer, since all communication details are handled in the driver and hardware.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序编程的角度来看，我们通常可以忽略数据链路层，因为所有通信细节都由驱动程序和硬件处理。
- en: One characteristic of the data-link layer that is important for our discussion
    of IP is the *maximum transmission unit* (MTU). A data-link layer’s MTU is the
    upper limit that the layer places on the size of a frame. Different data-link
    layers have different MTUs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层的一个特点，对于我们讨论IP非常重要，即*最大传输单元*（MTU）。数据链路层的MTU是该层对帧大小的上限。不同的数据链路层有不同的MTU。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The command *netstat -i* displays a list of the system’s network interfaces,
    along with their MTUs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令*netstat -i*显示系统的网络接口列表及其最大传输单元（MTU）。
- en: '![Layered communication via the TCP/IP protocols](figs/web/58-3_SOCKNW-IP-layers.png.jpg)Figure 58-3. Layered
    communication via the TCP/IP protocols![Encapsulation within the TCP/IP protocol
    layers](figs/web/58-4_SOCKNW-encapsulation.png.jpg)Figure 58-4. Encapsulation
    within the TCP/IP protocol layers'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过TCP/IP协议进行分层通信](figs/web/58-3_SOCKNW-IP-layers.png.jpg)图58-3. 通过TCP/IP协议进行分层通信![TCP/IP协议层内的封装](figs/web/58-4_SOCKNW-encapsulation.png.jpg)图58-4.
    TCP/IP协议层内的封装'
- en: 'The Network Layer: IP'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络层：IP
- en: 'Above the data-link layer is the *network layer*, which is concerned with delivering
    packets (data) from the source host to the destination host. This layer performs
    a variety of tasks, including:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层之上是*网络层*，该层负责将数据包（数据）从源主机传输到目标主机。此层执行多种任务，包括：
- en: breaking data into fragments small enough for transmission via the data-link
    layer (if necessary);
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据分割成足够小的碎片，以便通过数据链路层进行传输（如果需要）；
- en: routing data across the internet; and
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上路由数据；以及
- en: providing services to the transport layer.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向传输层提供服务。
- en: 'In the TCP/IP protocol suite, the principal protocol in the network layer is
    IP. The version of IP that appeared in the 4.2BSD implementation was IP version
    4 (IPv4). In the early 1990s, a revised version of IP was devised: IP version
    6 (IPv6). The most notable difference between the two versions is that IPv4 identifies
    subnets and hosts using 32-bit addresses, while IPv6 uses 128-bit addresses, thus
    providing a much larger range of addresses to be assigned to hosts. Although IPv4
    is still the predominant version of IP in use on the Internet, in coming years,
    it should be supplanted by IPv6\. Both IPv4 and IPv6 support the higher UDP and
    TCP transport-layer protocols (as well as many other protocols).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP/IP协议族中，网络层的主要协议是IP。在4.2BSD实现中出现的IP版本是IP版本4（IPv4）。在1990年代初期，制定了IP的修订版本：IP版本6（IPv6）。这两个版本之间最显著的区别是，IPv4使用32位地址标识子网和主机，而IPv6使用128位地址，因此可以为主机分配更大的地址范围。尽管IPv4仍然是互联网中使用的主要IP版本，但在未来几年，IPv6将取代它。IPv4和IPv6都支持更高层次的UDP和TCP传输层协议（以及许多其他协议）。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although a 32-bit address space theoretically permits billions of IPv4 network
    addresses to be assigned, the manner in which addresses were structured and allocated
    meant that the practical number of available addresses was far lower. The possible
    exhaustion of the IPv4 address space was one of the primary motivations for the
    creation of IPv6.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理论上32位地址空间允许为IPv4网络地址分配数十亿个地址，但由于地址结构和分配方式，实际可用的地址数远低于此。IPv4地址空间可能耗尽是创建IPv6的主要动机之一。
- en: A short history of IPv6 can be found at [http://www.laynetworks.com/IPv6.htm](http://www.laynetworks.com/IPv6.htm).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 IPv6 的简短历史可以在 [http://www.laynetworks.com/IPv6.htm](http://www.laynetworks.com/IPv6.htm)
    查找。
- en: The existence of IPv4 and IPv6 begs the question, “What about IPv5?” There never
    was an IPv5 as such. Each IP datagram header includes a 4-bit version number field
    (thus, IPv4 datagrams always have the number 4 in this field), and the version
    number 5 was assigned to an experimental protocol, *Internet Stream Protocol*.
    (Version 2 of this protocol, abbreviated as ST-II, is described in RFC 1819.)
    Initially conceived in the 1970s, this connection-oriented protocol was designed
    to support voice and video transmission, and distributed simulation. Since the
    IP datagram version number 5 was already assigned, the successor to IPv4 was assigned
    the version number 6.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 和 IPv6 的存在引发了一个问题，“那 IPv5 呢？” 事实上，根本没有所谓的 IPv5。每个 IP 数据报文头部包含一个 4 位的版本号字段（因此，IPv4
    数据报文在该字段中始终为数字 4），版本号 5 被分配给一种实验性协议——*互联网流协议*（Internet Stream Protocol）。(该协议的版本
    2，缩写为 ST-II，在 RFC 1819 中有描述。) 该协议最初于 1970 年代构思，是一种面向连接的协议，旨在支持语音和视频传输以及分布式仿真。由于
    IP 数据报文的版本号 5 已被分配，IPv4 的继任者被分配了版本号 6。
- en: '[Figure 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite "Figure 58-2. Protocols
    in the TCP/IP suite") shows a *raw* socket type (`SOCK_RAW`), which allows an
    application to communicate directly with the IP layer. We don’t describe the use
    of raw sockets, since most applications employ sockets over one of the transport-layer
    protocols (TCP or UDP). Raw sockets are described in [Chapter 28](ch28.html "Chapter 28. Process
    Creation and Program Execution in More Detail") of [Stevens et al., 2004]. One
    instructive example of the use of raw sockets is the *sendip* program ([http://www.earth.li/projectpurple/progs/sendip.html](http://www.earth.li/projectpurple/progs/sendip.html)),
    which is a command-line-driven tool that allows the construction and transmission
    of IP datagrams with arbitrary contents (including options to construct UDP datagrams
    and TCP segments).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 58-2](ch58.html#protocols_in_the_tcp_solidus_ip_suite "图 58-2. TCP/IP 套件中的协议")
    显示了一个 *原始* 套接字类型（`SOCK_RAW`），它允许应用程序直接与 IP 层通信。我们不描述原始套接字的使用，因为大多数应用程序使用基于传输层协议（TCP
    或 UDP）的套接字。原始套接字的描述可以参见 [第 28 章](ch28.html "第 28 章. 进程创建和程序执行的更多细节")，来自 [Stevens
    等人，2004]。一个使用原始套接字的有教育意义的例子是 *sendip* 程序（[http://www.earth.li/projectpurple/progs/sendip.html](http://www.earth.li/projectpurple/progs/sendip.html)），这是一个基于命令行的工具，允许构建和传输具有任意内容的
    IP 数据报文（包括构建 UDP 数据报文和 TCP 段的选项）。'
- en: IP transmits datagrams
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IP 传输数据报文
- en: IP transmits data in the form of datagrams (packets). Each datagram sent between
    two hosts travels independently across the network, possibly taking a different
    route. An IP datagram includes a header, which ranges in size from 20 to 60 bytes.
    The header contains the address of the target host, so that the datagram can be
    routed through the network to its destination, and also includes the originating
    address of the packet, so that the receiving host knows the origin of the datagram.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IP 以数据报文（包）的形式传输数据。每个在两个主机之间发送的数据报文都独立地穿越网络，可能会选择不同的路径。一个 IP 数据报文包含一个头部，头部大小范围从
    20 到 60 字节。头部包含目标主机的地址，以便数据报文能够通过网络被路由到目的地，还包含数据包的源地址，以便接收主机知道数据报文的来源。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible for a sending host to spoof the originating address of a packet,
    and this forms the basis of a TCP denial-of-service attack known as SYN-flooding.
    [Lemon, 2002] describes the details of this attack and the measures used by modern
    TCP implementations to deal with it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 发送主机可能伪造数据包的源地址，这为一种 TCP 拒绝服务攻击——SYN 洪泛攻击（SYN-flooding）——提供了基础。 [Lemon, 2002]
    描述了这种攻击的细节以及现代 TCP 实现中用来应对它的措施。
- en: An IP implementation may place an upper limit on the size of datagrams that
    it supports. All IP implementations must permit datagrams at least as large as
    the limit specified by IP’s *minimum reassembly buffer size*. In IPv4, this limit
    is 576 bytes; in IPv6, it is 1500 bytes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IP 实现可能会限制它所支持的数据报文的最大大小。所有的 IP 实现必须至少允许数据报文的大小与 IP 的 *最小重组缓冲区大小* 相等。在 IPv4
    中，这个限制是 576 字节；在 IPv6 中，它是 1500 字节。
- en: IP is connectionless and unreliable
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IP 是无连接的且不可靠的
- en: 'IP is described as a *connectionless* protocol, since it doesn’t provide the
    notion of a virtual circuit connecting two hosts. IP is also an *unreliable* protocol:
    it makes a “best effort” to transmit datagrams from the sender to the receiver,
    but doesn’t guarantee that packets will arrive in the order they were transmitted,
    that they won’t be duplicated, or even that they will arrive at all. Nor does
    IP provide error recovery (packets with header errors are silently discarded).
    Reliability must be provided either by using a reliable transport-layer protocol
    (e.g., TCP) or within the application itself.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: IP 被描述为一个 *无连接* 协议，因为它不提供连接两个主机的虚拟电路的概念。IP 也是一个 *不可靠* 协议：它尽力将数据报从发送方传输到接收方，但不能保证数据包按发送顺序到达，也不能保证数据包不会重复，甚至不能保证数据包一定会到达。IP
    也不提供错误恢复（带有头部错误的数据包会被默默丢弃）。可靠性必须通过使用可靠的传输层协议（如 TCP）或在应用程序内部提供。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IPv4 provides a checksum for the IP header, which allows the detection of errors
    in the header, but doesn’t provide any error detection for the data transmitted
    within the packet. IPv6 doesn’t provide a checksum in the IP header, relying on
    higher-layer protocols to provide error checking and reliability as required.
    (UDP checksums are optional with IPv4, but generally enabled; UDP checksums are
    mandatory with IPv6\. TCP checksums are mandatory with both IPv4 and IPv6.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 为 IP 头部提供了校验和，用于检测头部的错误，但不提供对数据包内传输数据的错误检测。IPv6 不提供 IP 头部的校验和，而是依赖更高层协议根据需要提供错误检查和可靠性。（在
    IPv4 中，UDP 校验和是可选的，但通常启用；在 IPv6 中，UDP 校验和是强制的。TCP 校验和在 IPv4 和 IPv6 中都是强制的。）
- en: Duplication of IP datagrams may occur because of techniques employed by some
    data-link layers to ensure reliability or when IP datagrams are tunneled through
    some non-TCP/IP network that employs retransmission.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些数据链路层采用了确保可靠性的技术，或者当 IP 数据报通过某些非 TCP/IP 网络隧道传输并使用重传时，可能会发生 IP 数据报的重复。
- en: IP may fragment datagrams
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IP 可能会对数据报进行分片。
- en: IPv4 datagrams can be up to 65,535 bytes. By default, IPv6 allows datagrams
    of up to 65,575 bytes (40 bytes for the header, 65,535 bytes for data), and provides
    an option for larger datagrams (so-called *jumbograms*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 数据报可以最大为 65,535 字节。默认情况下，IPv6 允许最大为 65,575 字节的数据报（40 字节用于头部，65,535 字节用于数据），并提供了更大数据报的选项（所谓的
    *jumbograms*）。
- en: We noted earlier that most data-link layers impose an upper limit (the MTU)
    on the size of data frames. For example, this upper limit is 1500 bytes on the
    commonly used Ethernet network architecture (i.e., much smaller than the maximum
    size of an IP datagram). IP also defines the notion of the *path MTU*. This is
    the minimum MTU on all of the data-link layers traversed on the route from the
    source to the destination. (In practice, the Ethernet MTU is often the minimum
    MTU in a path.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，大多数数据链路层会对数据帧的大小施加上限（即 MTU）。例如，在常用的以太网网络架构中，这个上限为 1500 字节（即比 IP 数据报的最大大小要小得多）。IP
    还定义了 *路径 MTU* 的概念。这是从源到目的地路径上所有数据链路层的最小 MTU。（实际上，以太网 MTU 通常是路径中最小的 MTU。）
- en: When an IP datagram is larger than the MTU, IP fragments (breaks up) the datagram
    into suitably sized units for transmission across the network. These fragments
    are then reassembled at the final destination to re-create the original datagram.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 IP 数据报大于 MTU 时，IP 会对数据报进行分片（将数据报分割为适当大小的单元，以便在网络上传输）。这些分片随后会在最终目的地重新组装，以重新创建原始数据报。
- en: (Each IP fragment is itself an IP datagram that contains an offset field giving
    the location of that fragment within the original datagram.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （每个 IP 分片本身就是一个 IP 数据报，包含一个偏移字段，表示该分片在原始数据报中的位置。）
- en: IP fragmentation occurs transparently to higher protocol layers, but nevertheless
    is generally considered undesirable ([Kent & Mogul, 1987]). The problem is that,
    because IP doesn’t perform retransmission, and a datagram can be reassembled at
    the destination only if all fragments arrive, the entire datagram is unusable
    if any fragment is lost or contains transmission errors. In some cases, this can
    lead to significant rates of data loss (for higher protocol layers that don’t
    perform retransmission, such as UDP) or degraded transfer rates (for higher protocol
    layers that do perform retransmission, such as TCP). Modern TCP implementations
    employ algorithms (*path MTU discovery*) to determine the MTU of a path between
    hosts, and accordingly break up the data they pass to IP, so that IP is not asked
    to transmit datagrams that exceed this size. UDP provides no such mechanism, and
    we consider how UDP-based applications can deal with the possibility of IP fragmentation
    in [User Datagram Protocol (UDP)](ch58.html#user_datagram_protocol_open_parenthesis
    "User Datagram Protocol (UDP)").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: IP 分片对更高层协议透明，但仍然通常被认为是不可取的（[Kent & Mogul, 1987]）。问题在于，由于 IP 不执行重传，并且只有在所有分片都到达时，数据报才能在目的地重新组装，如果任何一个分片丢失或包含传输错误，整个数据报都无法使用。在某些情况下，这可能导致数据丢失的比率显著增加（对于不执行重传的更高层协议，如
    UDP）或传输速率降低（对于执行重传的更高层协议，如 TCP）。现代 TCP 实现使用算法（*路径 MTU 发现*）来确定主机之间路径的最大传输单元（MTU），并据此拆分它们传递给
    IP 的数据，以便 IP 不会被要求传输超过此大小的数据报。UDP 没有提供类似的机制，我们在 [用户数据报协议 (UDP)](ch58.html#user_datagram_protocol_open_parenthesis
    "用户数据报协议 (UDP)") 中讨论了基于 UDP 的应用程序如何处理 IP 分片的可能性。
- en: IP Addresses
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 地址
- en: 'An IP address consists of two parts: a network ID, which specifies the network
    on which a host resides, and a host ID, which identifies the host within that
    network.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IP 地址由两部分组成：网络 ID，指定主机所在的网络，以及主机 ID，用于标识该网络中的主机。
- en: IPv4 addresses
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv4 地址
- en: An IPv4 address consists of 32 bits ([Figure 58-5](ch58.html#an_ipv4_network_address_and_correspondin
    "Figure 58-5. An IPv4 network address and corresponding network mask")). When
    expressed in human-readable form, these addresses are normally written in *dotted-decimal
    notation*, with the 4 bytes of the address being written as decimal numbers separated
    by dots, as in 204.152.189.116.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv4 地址由 32 位组成（[图 58-5](ch58.html#an_ipv4_network_address_and_correspondin
    "图 58-5. 一个 IPv4 网络地址及相应的网络掩码")）。当以人类可读的形式表示时，这些地址通常以 *点分十进制表示法* 编写，其中地址的 4 个字节作为十进制数字写出，并用点分隔，如
    204.152.189.116。
- en: '![An IPv4 network address and corresponding network mask](figs/web/58-5_SOCKNW-IPv4-address-scale90.png)Figure 58-5. An
    IPv4 network address and corresponding network mask'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![IPv4 网络地址及相应网络掩码](figs/web/58-5_SOCKNW-IPv4-address-scale90.png)图 58-5. 一个
    IPv4 网络地址及相应的网络掩码'
- en: 'When an organization applies for a range of IPv4 addresses for its hosts, it
    receives a 32-bit network address and a corresponding 32-bit *network mask*. In
    binary form, this mask consists of a sequence of 1s in the leftmost bits, followed
    by a sequence of 0s to fill out the remainder of the mask. The 1s indicate which
    part of the address contains the assigned network ID, while the 0s indicate which
    part of the address is available to the organization to assign as unique host
    IDs on its network. The size of the network ID part of the mask is determined
    when the address is assigned. Since the network ID component always occupies the
    leftmost part of the mask, the following notation is sufficient to specify the
    range of assigned addresses:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组织为其主机申请一系列 IPv4 地址时，它会收到一个 32 位的网络地址和一个相应的 32 位 *网络掩码*。以二进制形式表示，这个掩码由最左边的一串
    1 和后面的 0 组成，0 用来填补掩码的剩余部分。1 表示地址中哪部分包含分配的网络 ID，而 0 表示地址中哪部分可以分配给组织作为其网络中的唯一主机
    ID。掩码中网络 ID 部分的大小是在分配地址时确定的。由于网络 ID 部分始终占据掩码的最左边，因此使用以下符号足以指定分配的地址范围：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `/24` indicates that the network ID part of the assigned address consists
    of the leftmost 24 bits, with the remaining 8 bits specifying the host ID. Alternatively,
    we could say that the network mask in this case is `255.255.255.0` in dotted-decimal
    notation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`/24` 表示分配的地址的网络 ID 部分由最左边的 24 位组成，剩下的 8 位则指定主机 ID。或者，我们可以说，在这种情况下，网络掩码是 `255.255.255.0`，以点分十进制表示。'
- en: An organization holding this address can assign 254 unique Internet addresses
    to its computers—`204.152.189.1` through `204.152.189.254`. Two addresses can’t
    be assigned. One of these is the address whose host ID is all 0 bits, which is
    used to identify the network itself. The other is the address whose host ID is
    all 1 bits—`204.152.189.255` in this example—which is the *subnet broadcast address*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有此地址的组织可以为其计算机分配254个独特的互联网地址——`204.152.189.1`到`204.152.189.254`。有两个地址不能分配。其中一个是主机ID全为0位的地址，用于标识网络本身。另一个是主机ID全为1位的地址——在此示例中为`204.152.189.255`——它是*子网广播地址*。
- en: Certain IPv4 addresses have special meanings. The special address `127.0.0.1`
    is normally defined as the *loopback address*, and is conventionally assigned
    the hostname `localhost`. (Any address on the network `127.0.0.0/8` can be designated
    as the IPv4 loopback address, but `127.0.0.1` is the usual choice.) A datagram
    sent to this address never actually reaches the network, but instead automatically
    loops back to become input to the sending host. Using this address is convenient
    for testing client and server programs on the same host. For use in a C program,
    the integer constant `INADDR_LOOPBACK` is defined for this address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 某些IPv4地址具有特殊含义。特殊地址`127.0.0.1`通常被定义为*回环地址*，并习惯性地分配主机名`localhost`。（任何位于`127.0.0.0/8`网络中的地址都可以指定为IPv4回环地址，但通常选择`127.0.0.1`。）发送到该地址的数据报永远不会实际到达网络，而是自动回送并成为发送主机的输入。使用该地址在同一主机上测试客户端和服务器程序非常方便。在C程序中，定义了整数常量`INADDR_LOOPBACK`来表示该地址。
- en: The constant `INADDR_ANY` is the so-called IPv4 *wildcard address*. The wildcard
    IP address is useful for applications that bind Internet domain sockets on multihomed
    hosts. If an application on a multihomed host binds a socket to just one of its
    host’s IP addresses, then that socket can receive only UDP datagrams or TCP connection
    requests sent to that IP address. However, we normally want an application on
    a multihomed host to be able to receive datagrams or connection requests that
    specify any of the host’s IP addresses, and binding the socket to the wildcard
    IP address makes this possible. SUSv3 doesn’t specify any particular value for
    `INADDR_ANY`, but most implementations define it as `0.0.0.0` (all zeros).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`INADDR_ANY`是所谓的IPv4*通配符地址*。通配符IP地址对于在多网卡主机上绑定互联网域套接字的应用程序非常有用。如果一个应用程序在多网卡主机上仅绑定到其中一个IP地址的套接字，那么该套接字只能接收发送到该IP地址的UDP数据报或TCP连接请求。然而，我们通常希望多网卡主机上的应用程序能够接收指定任何主机IP地址的数据报或连接请求，绑定到通配符IP地址可以实现这一点。SUSv3并未为`INADDR_ANY`指定任何特定值，但大多数实现将其定义为`0.0.0.0`（全零）。
- en: 'Typically, IPv4 addresses are *subnetted*. Subnetting divides the host ID part
    of an IPv4 address into two parts: a subnet ID and a host ID ([Figure 58-6](ch58.html#ipv4_subnetting
    "Figure 58-6. IPv4 subnetting")). (The choice of how the bits of the host ID are
    divided is made by the local network administrator.) The rationale for subnetting
    is that an organization often doesn’t attach all of its hosts to a single network.
    Instead, the organization may operate a set of subnetworks (an “internal internetwork”),
    with each subnetwork being identified by the combination of the network ID plus
    the subnet ID. This combination is usually referred to as the *extended network
    ID*. Within a subnet, the subnet mask serves the same role as described earlier
    for the network mask, and we can use a similar notation to indicate the range
    of addresses assigned to a particular subnet.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IPv4地址是*子网划分*的。子网划分将IPv4地址中的主机ID部分分为两部分：子网ID和主机ID（[图58-6](ch58.html#ipv4_subnetting
    "图58-6. IPv4子网划分")）。 （如何划分主机ID的位由本地网络管理员决定。）子网划分的原理是，组织通常不会将所有主机连接到同一个网络。相反，组织可能会操作一组子网络（“内部互联网络”），每个子网络通过网络ID加子网ID的组合进行标识。这个组合通常被称为*扩展网络ID*。在子网内，子网掩码与之前描述的网络掩码具有相同的作用，我们可以使用类似的表示法来指示分配给特定子网的地址范围。
- en: For example, suppose that our assigned network ID is `204.152.189.0/24`, and
    we choose to subnet this address range by splitting the 8 bits of the host ID
    into a 4-bit subnet ID and a 4-bit host ID. Under this scheme, the subnet mask
    would consist of 28 leading ones, followed by 4 zeros, and the subnet with the
    ID of 1 would be designated as `204.152.189.16/28`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们分配的网络 ID 是 `204.152.189.0/24`，并选择通过将主机 ID 的 8 位分割成 4 位子网 ID 和 4 位主机 ID
    来对子网进行划分。在这种方案下，子网掩码将由 28 个前导 1 后跟 4 个 0 组成，ID 为 1 的子网将被指定为 `204.152.189.16/28`。
- en: '![IPv4 subnetting](figs/web/58-6_SOCKNW-IPv4-address-subnet.png.jpg)Figure 58-6. IPv4
    subnetting'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![IPv4 子网划分](figs/web/58-6_SOCKNW-IPv4-address-subnet.png.jpg)图 58-6. IPv4
    子网划分'
- en: IPv6 addresses
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6 地址
- en: The principles of IPv6 addresses are similar to IPv4 addresses. The key difference
    is that IPv6 addresses consist of 128 bits, and the first few bits of the address
    are a *format prefix*, indicating the address type. (We won’t go into the details
    of these address types; see [Appendix A](apa.html "Appendix A. Tracing System
    Calls") of [Stevens et al., 2004] and RFC 3513 for details.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址的原理与 IPv4 地址类似。主要区别在于，IPv6 地址由 128 位组成，地址的前几位是一个*格式前缀*，用于指示地址类型。（我们不会详细介绍这些地址类型；请参阅
    [附录 A](apa.html "附录 A. 跟踪系统调用")，以及 [Stevens 等人，2004] 和 RFC 3513 获取更多细节。）
- en: 'IPv6 addresses are typically written as a series of 16-bit hexadecimal numbers
    separated by colons, as in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址通常以一系列由冒号分隔的 16 位十六进制数字形式书写，如下所示：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'IPv6 addresses often include a sequence of zeros and, as a notational convenience,
    two colons (`::`) can be employed to indicate such a sequence. Thus, the above
    address can be rewritten as:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址通常包括一系列零，为了方便表示，可以使用两个冒号 (`::`) 来表示这种零序列。因此，上述地址可以重写为：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Only one instance of the double-colon notation can appear in an IPv6 address;
    more than one instance would be ambiguous.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址中只能出现一次双冒号表示法；出现多个实例会产生歧义。
- en: IPv6 also provides equivalents of the IPv4’s loopback address (127 zeros, followed
    by a one, thus ::1) and wildcard address (all zeros, written as either 0::0 or
    ::).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 还提供了等同于 IPv4 回环地址（127 个零，后跟一个 1，即 ::1）和通配符地址（所有零，写作 0::0 或 ::）的地址。
- en: In order to allow IPv6 applications to communicate with hosts supporting only
    IPv4, IPv6 provides so-called *IPv4-mapped IPv6 addresses*. The format of these
    addresses is shown in [Figure 58-7](ch58.html#format_of_an_ipv4-mapped_ipv6_address
    "Figure 58-7. Format of an IPv4-mapped IPv6 address").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 IPv6 应用程序能够与仅支持 IPv4 的主机通信，IPv6 提供了所谓的*IPv4 映射 IPv6 地址*。这些地址的格式如 [图 58-7](ch58.html#format_of_an_ipv4-mapped_ipv6_address
    "图 58-7. IPv4 映射 IPv6 地址格式") 所示。
- en: '![Format of an IPv4-mapped IPv6 address](figs/web/58-7_SOCKNW-IPv4-mapped-IPv6-scale90.png.jpg)Figure 58-7. Format
    of an IPv4-mapped IPv6 address'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![IPv4 映射 IPv6 地址格式](figs/web/58-7_SOCKNW-IPv4-mapped-IPv6-scale90.png.jpg)图
    58-7. IPv4 映射 IPv6 地址格式'
- en: When writing an IPv4-mapped IPv6 address, the IPv4 part of the address (i.e.,
    the last 4 bytes) is written in IPv4 dotted-decimal notation. Thus, the IPv4-mapped
    IPv6 address equivalent to `204.152.189.116` is `::FFFF:204.152.189.116`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 IPv4 映射 IPv6 地址时，地址的 IPv4 部分（即最后 4 个字节）使用 IPv4 点分十进制表示法。因此，`204.152.189.116`
    对应的 IPv4 映射 IPv6 地址是 `::FFFF:204.152.189.116`。
- en: The Transport Layer
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层
- en: 'There are two widely used transport-layer protocols in the TCP/IP suite:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 协议栈中有两个广泛使用的传输层协议：
- en: '*User Datagram Protocol* (UDP) is the protocol used for datagram sockets.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户数据报协议*（UDP）是用于数据报套接字的协议。'
- en: '*Transmission Control Protocol* (TCP) is the protocol used for stream sockets.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传输控制协议*（TCP）是用于流套接字的协议。'
- en: Before considering these protocols, we first need to describe port numbers,
    a concept used by both protocols.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些协议之前，我们首先需要描述端口号，这是这两种协议都使用的概念。
- en: Port Numbers
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口号
- en: The task of the transport protocol is to provide an end-to-end communication
    service to applications residing on different hosts (or sometimes on the same
    host). In order to do this, the transport layer requires a method of differentiating
    the applications on a host. In TCP and UDP, this differentiation is provided by
    a 16-bit *port number*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议的任务是为位于不同主机（或有时在同一主机上的）应用程序提供端到端的通信服务。为了做到这一点，传输层需要一种区分主机上应用程序的方法。在 TCP
    和 UDP 中，这种区分是通过 16 位的*端口号*来实现的。
- en: Well-known, registered, and privileged ports
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 知名端口、注册端口和特权端口
- en: Some *well-known port numbers* are permanently assigned to specific applications
    (also known as *services*). For example, the *ssh* (secure shell) daemon uses
    the well-known port 22, and HTTP (the protocol used for communication between
    web servers and browsers) uses the well-known port 80\. Well-known ports are assigned
    numbers in the range 0 to 1023 by a central authority, the Internet Assigned Numbers
    Authority (IANA, [http://www.iana.org/](http://www.iana.org/)). Assignment of
    a well-known port number is contingent on an approved network specification (typically
    in the form of an RFC).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些*知名端口号*被永久分配给特定应用程序（也称为*服务*）。例如，*ssh*（安全外壳）守护进程使用知名端口22，HTTP（用于Web服务器和浏览器之间通信的协议）使用知名端口80。知名端口的号码由中央管理机构——互联网号码分配局（IANA，[http://www.iana.org/](http://www.iana.org/)）分配，端口号的分配需要经过批准的网络规范（通常以RFC形式）。
- en: IANA also records *registered ports*, which are allocated to application developers
    on a less stringent basis (which also means that an implementation doesn’t need
    to guarantee the availability of these ports for their registered purpose). The
    range of IANA registered ports is 1024 to 41951\. (Not all port numbers in this
    range are registered.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: IANA还记录了*注册端口*，这些端口分配给应用程序开发者的条件较为宽松（这也意味着实现不需要保证这些端口用于注册目的时的可用性）。IANA注册端口的范围是1024到41951。（并非该范围内的所有端口号都已注册。）
- en: The up-to-date list of IANA well-known and registered port assignments can be
    obtained online at [http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: IANA最新的知名和注册端口分配列表可以通过在线访问[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)获得。
- en: In most TCP/IP implementations (including Linux), the port numbers in the range
    0 to 1023 are also *privileged*, meaning that only privileged (`CAP_NET_BIND_SERVICE`)
    processes may bind to these ports. This prevents a normal user from implementing
    a malicious application that, for example, spoofs as *ssh* in order to obtain
    passwords. (Sometimes, privileged ports are referred to as *reserved* ports.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数TCP/IP实现中（包括Linux），范围从0到1023的端口号也是*特权*端口，这意味着只有特权的（`CAP_NET_BIND_SERVICE`）进程才能绑定到这些端口。这防止了普通用户实现恶意应用程序，例如伪装成*ssh*以获取密码。（有时，特权端口也被称为*保留*端口。）
- en: Although TCP and UDP ports with the same number are distinct entities, the same
    well-known port number is usually assigned to a service under both TCP and UDP,
    even if, as is often the case, that service is available under only one of these
    protocols. This convention avoids confusion of port numbers across the two protocols.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具有相同编号的TCP和UDP端口是两个不同的实体，但通常会为同一服务在TCP和UDP下分配相同的知名端口号，即使该服务通常仅在其中一个协议下可用。此约定避免了在两个协议之间端口号的混淆。
- en: Ephemeral ports
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 短暂端口
- en: If an application doesn’t select a particular port (i.e., in sockets terminology,
    it doesn’t *bind()* its socket to a particular port), then TCP and UDP assign
    a unique *ephemeral port* (i.e., short-lived) number to the socket. In this case,
    the application—typically a client—doesn’t care which port number it uses, but
    assigning a port is necessary so that the transport-layer protocols can identify
    the communication endpoints. It also has the result that the peer application
    at the other end of the communication channel knows how to communicate with this
    application. TCP and UDP also assign an ephemeral port number if we bind a socket
    to port 0.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有选择特定的端口（即，在套接字术语中，它没有将套接字*绑定*到特定端口），那么TCP和UDP会为套接字分配一个唯一的*短暂端口*（即，短生命周期）号。在这种情况下，应用程序——通常是客户端——不在乎使用哪个端口号，但分配端口是必要的，以便传输层协议可以识别通信端点。这也意味着通信通道另一端的对等应用程序知道如何与该应用程序进行通信。如果我们将套接字绑定到端口0，TCP和UDP也会分配一个短暂端口号。
- en: IANA specifies the ports in the range 49152 to 65535 as *dynamic* or *private*,
    with the intention that these ports can be used by local applications and assigned
    as ephemeral ports. However, various implementations allocate ephemeral ports
    from different ranges. On Linux, the range is defined by (and can be modified
    via) two numbers contained in the file `/proc/sys/net/ipv4/ip_local_port_range`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: IANA将49152到65535范围的端口指定为*动态*或*私有*端口，旨在使这些端口可以由本地应用程序使用并分配为短暂端口。然而，不同的实现从不同的范围分配短暂端口。在Linux上，这个范围由`/proc/sys/net/ipv4/ip_local_port_range`文件中的两个数字定义（并可以通过该文件进行修改）。
- en: User Datagram Protocol (UDP)
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据报协议（UDP）
- en: 'UDP adds just two features to IP: port numbers and a data checksum to allow
    the detection of errors in the transmitted data.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UDP仅向IP添加了两个特性：端口号和数据校验和，用于检测传输数据中的错误。
- en: Like IP, UDP is connectionless. Since it adds no reliability to IP, UDP is likewise
    unreliable. If an application layered on top of UDP requires reliability, then
    this must be implemented within the application. Despite this unreliability, we
    may sometimes prefer to use UDP instead of TCP, for the reasons detailed in [TCP
    Versus UDP](ch61.html#tcp_versus_udp "TCP Versus UDP").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像IP一样，UDP是无连接的。由于它没有为IP增加可靠性，因此UDP本身也是不可靠的。如果基于UDP的应用需要可靠性，那么必须在应用层实现这一功能。尽管存在这种不可靠性，有时我们仍然更倾向于使用UDP而非TCP，具体原因可以参见[TCP与UDP对比](ch61.html#tcp_versus_udp
    "TCP Versus UDP")。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The checksums used by both UDP and TCP are just 16 bits long, and are simple
    “add-up” checksums that can fail to detect certain classes of errors. Consequently,
    they do not provide extremely strong error detection. Busy Internet servers typically
    see an average of one undetected transmission error every few days ([Stone & Partridge,
    2000]). Applications that need stronger assurances of data integrity can use the
    Secure Sockets Layer (SSL) protocol, which provides not only secure communication,
    but also much more rigorous detection of errors. Alternatively, an application
    could implement its own error-control scheme.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP使用的校验和仅为16位，是简单的“加和”校验和，可能无法检测某些类型的错误。因此，它们并未提供非常强的错误检测功能。繁忙的互联网服务器通常每几天就会遇到一个无法检测到的传输错误（[Stone
    & Partridge, 2000]）。需要更强数据完整性保障的应用可以使用安全套接字层（SSL）协议，该协议不仅提供安全通信，还能更严格地检测错误。或者，应用程序也可以实现自己的错误控制方案。
- en: Selecting a UDP datagram size to avoid IP fragmentation
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择UDP数据报文大小以避免IP分片
- en: 'In [The Network Layer: IP](ch58.html#the_network_layer_colon_ip "The Network
    Layer: IP"), we described the IP fragmentation mechanism, and noted that it is
    usually best to avoid IP fragmentation. While TCP contains mechanisms for avoiding
    IP fragmentation, UDP does not. With UDP, we can easily cause IP fragmentation
    by transmitting a datagram that exceeds the MTU of the local data link.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在[网络层：IP](ch58.html#the_network_layer_colon_ip "The Network Layer: IP")中，我们描述了IP分片机制，并指出通常最好避免IP分片。尽管TCP包含避免IP分片的机制，但UDP并没有。使用UDP时，我们可以通过传输超过本地数据链路MTU的数据报轻松引发IP分片。'
- en: A UDP-based application generally doesn’t know the MTU of the path between the
    source and destination hosts. UDP-based applications that aim to avoid IP fragmentation
    typically adopt a conservative approach, which is to ensure that the transmitted
    IP datagram is less than the IPv4 minimum reassembly buffer size of 576 bytes.
    (This value is likely to be lower than the path MTU.) From these 576 bytes, 8
    bytes are required by UDP’s own header, and an additional minimum of 20 bytes
    are required for the IP header, leaving 548 bytes for the UDP datagram itself.
    In practice, many UDP-based applications opt for a still lower limit of 512 bytes
    for their datagrams ([Stevens, 1994]).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于UDP的应用通常不知道源主机和目标主机之间路径的最大传输单元（MTU）。为了避免IP分片，基于UDP的应用通常采取一种保守的方式，即确保传输的IP数据报小于IPv4最小重组缓冲区大小576字节。（这个值可能低于路径的MTU。）在这576字节中，UDP的头部需要8字节，IP头部额外需要最少20字节，剩下的548字节用于UDP数据报本身。实际上，许多基于UDP的应用选择一个更低的限制值，即512字节用于它们的数据报（[Stevens,
    1994]）。
- en: Transmission Control Protocol (TCP)
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）
- en: TCP provides a reliable, connection-oriented, bidirectional, byte-stream communication
    channel between two endpoints (i.e., applications), as shown in [Figure 58-8](ch58.html#connected_tcp_sockets
    "Figure 58-8. Connected TCP sockets"). In order to provide these features, TCP
    must perform the tasks described in this section. (A detailed description of all
    of these features can be found in [Stevens, 1994].)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: TCP提供了一种可靠的、面向连接的、双向的字节流通信通道，连接两个端点（即应用程序），如[图58-8](ch58.html#connected_tcp_sockets
    "Figure 58-8. Connected TCP sockets")所示。为了提供这些特性，TCP必须执行本节中描述的任务。（所有这些特性的详细描述可以参考[Stevens,
    1994]。）
- en: '![Connected TCP sockets](figs/web/58-8_SOCKNW-TCP-connected.png.jpg)Figure 58-8. Connected
    TCP sockets'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![已连接的TCP套接字](figs/web/58-8_SOCKNW-TCP-connected.png.jpg)图58-8. 已连接的TCP套接字'
- en: We use the term *TCP endpoint* to denote the information maintained by the kernel
    for one end of a TCP connection. (Often, we abbreviate this term further, for
    example, writing just “a TCP,” to mean “a TCP endpoint,” or “the client TCP” to
    mean “the TCP endpoint maintained for the client application.”) This information
    includes the send and receive buffers for this end of the connection, as well
    as state information that is maintained in order to synchronize the operation
    of the two connected endpoints. (We describe this state information in further
    detail when we consider the TCP state transition diagram in [TCP State Machine
    and State Transition Diagram](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP State Machine and State Transition Diagram").) In the remainder of this book,
    we use the terms *receiving TCP* and *sending TCP* to denote the TCP endpoints
    maintained for the receiving and sending applications on either end of a stream
    socket connection that is being used to transmit data in a particular direction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*TCP 端点*这个术语来表示内核为一个 TCP 连接的某一端所维护的信息。（通常，我们进一步简化这个术语，例如，写作“一个 TCP”，表示“一个
    TCP 端点”，或者“客户端 TCP”表示“为客户端应用程序维护的 TCP 端点”。）这些信息包括该连接端点的发送和接收缓冲区，以及为同步两个连接端点的操作而维护的状态信息。（当我们讨论
    TCP 状态转换图时，会详细描述这些状态信息，见 [TCP 状态机与状态转换图](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP State Machine and State Transition Diagram")。）在本书的其余部分，我们使用*接收 TCP*和*发送 TCP*这两个术语来表示分别用于接收和发送应用程序的
    TCP 端点，这些端点位于一个用于在特定方向上传输数据的流套接字连接的两端。
- en: Connection establishment
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接建立
- en: Before communication can commence, TCP establishes a communication channel between
    the two endpoints. During connection establishment, the sender and receiver can
    exchange options to advertise parameters for the connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信开始之前，TCP 会在两个端点之间建立通信通道。在连接建立过程中，发送方和接收方可以交换选项，以通告连接的参数。
- en: Packaging of data in segments
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据在段中的封装
- en: Data is broken into segments, each of which contains a checksum to allow the
    detection of end-to-end transmission errors. Each segment is transmitted in a
    single IP datagram.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数据被分割成段，每个段都包含一个校验和，用于检测端到端的传输错误。每个段都通过一个 IP 数据报进行传输。
- en: Acknowledgements, retransmissions, and timeouts
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确认、重传和超时
- en: When a TCP segment arrives at its destination without errors, the receiving
    TCP sends a positive acknowledgement to the sender, informing it of the successfully
    delivered data. If a segment arrives with errors, then it is discarded, and no
    acknowledgement is sent. To handle the possibility of segments that never arrive
    or are discarded, the sender starts a timer when each segment is transmitted.
    If an acknowledgement is not received before the timer expires, the segment is
    retransmitted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 TCP 段无误地到达目的地时，接收方的 TCP 会向发送方发送正向确认，告知其数据已成功传送。如果某个段到达时存在错误，则该段会被丢弃，并且不会发送任何确认。为了处理可能存在的丢失或被丢弃的段，发送方在每个段发送时会启动一个计时器。如果在计时器到期之前没有收到确认，该段将会被重新传输。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Since the time taken to transmit a segment and receive its acknowledgement varies
    according to the range of the network and the current traffic loading, TCP employs
    an algorithm to dynamically adjust the size of the retransmission timeout (RTO).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传输一个段并接收其确认的时间会根据网络的范围和当前的流量负载有所变化，TCP 采用算法动态调整重传超时（RTO）的大小。
- en: The receiving TCP may not send acknowledgements immediately, but instead wait
    for a fraction of a second to see if the acknowledgement can be piggybacked inside
    any response that the receiver may send straight back to the sender. (Every TCP
    segment includes an acknowledgement field, allowing for such piggybacking.) The
    aim of this technique, called *delayed ACK*, is to save sending a TCP segment,
    thus decreasing the number of packets in the network and decreasing the load on
    the sending and receiving hosts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接收方的 TCP 可能不会立即发送确认，而是会等待片刻，看是否可以将确认信息打包到接收方可能直接发送回发送方的任何响应中。（每个 TCP 段都包括一个确认字段，允许进行这种打包。）这种技术叫做*延迟确认*，其目的是节省发送一个
    TCP 段，从而减少网络中数据包的数量，并降低发送和接收主机的负载。
- en: Sequencing
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 序列化
- en: Each byte that is transmitted over a TCP connection is assigned a logical sequence
    number. This number indicates the position of that byte in the data stream for
    the connection. (Each of the two streams in the connection has its own sequence
    numbering.) When a TCP segment is transmitted, it includes a field containing
    the sequence number of the first byte in the segment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通过TCP连接传输的字节都分配了一个逻辑序列号。这个序列号表示该字节在连接的数据流中的位置。（连接中的两个流各自有自己的序列号编号。）当TCP数据段被传输时，它会包含一个字段，表示该数据段中第一个字节的序列号。
- en: 'Attaching sequence numbers to each segment serves a variety of purposes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个数据段附加序列号有多种目的：
- en: The sequence number allows TCP segments to be assembled in the correct order
    at the destination, and then passed as a byte stream to the application layer.
    (At any moment, multiple TCP segments may be in transit between sender and receiver,
    and these segments may arrive out of order.)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列号使得TCP数据段能够在目的地按正确顺序组装，然后作为字节流传递给应用层。（在任何时刻，可能有多个TCP数据段在发送方和接收方之间传输，这些数据段可能会乱序到达。）
- en: The acknowledgement message passed from the receiver back to the sender can
    use the sequence number to identify which TCP segment was received.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从接收方返回到发送方的确认消息可以使用序列号来标识收到的TCP数据段。
- en: The receiver can use the sequence number to eliminate duplicate segments. Such
    duplicates may occur either because of the duplication of IP datagrams or because
    of TCP’s own retransmission algorithm, which could retransmit a successfully delivered
    segment if the acknowledgement for that segment was lost or was not received in
    a timely fashion.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收方可以利用序列号来消除重复的数据段。重复数据段可能会发生，这可能是由于IP数据报的重复传输，或者由于TCP自身的重传算法——如果某个数据段的确认丢失或未能及时收到，TCP可能会重传该数据段。
- en: The initial sequence number (ISN) for a stream doesn’t start at 0. Instead,
    it is generated via an algorithm that increases the ISN assigned to successive
    TCP connections (to prevent the possibility of old segments from a previous incarnation
    of the connection being confused with segments for this connection). This algorithm
    is also designed to make guessing the ISN difficult. The sequence number is a
    32-bit value that is wrapped around to 0 when the maximum value is reached.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 流的初始序列号（ISN）并不是从0开始的，而是通过一种算法生成的，该算法会使得分配给连续TCP连接的ISN逐渐增加（以防止来自连接之前的旧数据段与当前连接的数据段混淆）。此算法的设计还旨在使猜测ISN变得困难。序列号是一个32位的值，当达到最大值时会回绕到0。
- en: Flow control
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流量控制
- en: Flow control prevents a fast sender from overwhelming a slow receiver. To implement
    flow control, the receiving TCP maintains a buffer for incoming data. (Each TCP
    advertises the size of this buffer during connection establishment.) Data accumulates
    in this buffer as it is received from the sending TCP, and is removed as the application
    reads data. With each acknowledgement, the receiver advises the sender of how
    much space is available in its incoming data buffer (i.e., how many bytes the
    sender can transmit). The TCP flow-control algorithm employs a so-called *sliding
    window* algorithm, which allows unacknowledged segments containing a total of
    up *N* (the offered window size) bytes to be in transit between the sender and
    receiver. If a receiving TCP’s incoming data buffer fills completely, then the
    window is said to be closed, and the sending TCP stops transmitting.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制可以防止发送方过快地将数据传输给接收方，导致接收方超负荷。为了实现流量控制，接收方的TCP会为接收到的数据维护一个缓冲区。（每个TCP在建立连接时都会通告此缓冲区的大小。）数据在接收方的缓冲区中积累，直到应用程序读取数据时才会被移除。每次确认时，接收方都会通知发送方它的接收缓冲区中剩余的可用空间（即，发送方可以传输的字节数）。TCP流量控制算法采用所谓的*滑动窗口*算法，这允许未确认的数据段（总共最多包含*N*字节，即提供的窗口大小）在发送方和接收方之间传输。如果接收方的接收缓冲区已满，那么窗口被视为关闭，发送方停止传输数据。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The receiver can override the default size for the incoming data buffer using
    the `SO_RCVBUF` socket option (see the *socket(7)* manual page).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接收方可以通过`SO_RCVBUF`套接字选项来覆盖接收缓冲区的默认大小（参见*socket(7)*手册页）。
- en: 'Congestion control: slow-start and congestion-avoidance algorithms'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拥塞控制：慢启动和拥塞避免算法
- en: 'TCP’s congestion-control algorithms are designed to prevent a fast sender from
    overwhelming a network. If a sending TCP transmits packets faster than they can
    be relayed by an intervening router, that router will start dropping packets.
    This could lead to high rates of packet loss and, consequently, serious performance
    degradation, if the sending TCP kept retransmitting these dropped segments at
    the same rate. TCP’s congestion-control algorithms are important in two circumstances:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的拥塞控制算法旨在防止快速发送方压垮网络。如果发送方的TCP以比中间路由器能转发的速度更快的速度传输数据包，路由器将开始丢包。如果发送方的TCP继续以相同的速率重传这些丢失的分段，就可能导致大量的丢包率，并因此引发严重的性能下降。TCP的拥塞控制算法在以下两种情况下非常重要：
- en: '*After connection establishment*: At this time (or when transmission resumes
    on a connection that has been idle for some time), the sender could start by immediately
    injecting as many segments into the network as would be permitted by the window
    size advertised by the receiver. (In fact, this is what was done in early TCP
    implementations.) The problem here is that if the network can’t handle this flood
    of segments, the sender risks overwhelming the network immediately.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接建立后*：此时（或当一个连接在闲置一段时间后恢复传输时），发送方可以通过立即将尽可能多的分段注入网络，来利用接收方通告的窗口大小。（实际上，这就是早期TCP实现中的做法。）问题在于，如果网络无法处理这波分段洪流，发送方可能会立即使网络过载。'
- en: '*When congestion is detected*: If the sending TCP detects that congestion is
    occurring, then it must reduce its transmission rate. TCP detects that congestion
    is occurring based on the assumption that segment loss because of transmission
    errors is very low; thus, if a packet is lost, the cause is assumed to be congestion.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当检测到拥塞时*：如果发送方的TCP检测到拥塞发生，那么它必须减少其传输速率。TCP检测拥塞发生的假设是，传输错误导致的分段丢失非常低；因此，如果丢失了数据包，则认为是由于拥塞造成的。'
- en: 'TCP’s congestion-control strategy employs two algorithms in combination: slow
    start and congestion avoidance.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的拥塞控制策略结合了两种算法：慢启动和拥塞避免。
- en: The *slow-start* algorithm causes the sending TCP to initially transmit segments
    at a slow rate, but allows it to exponentially increase the rate as these segments
    are acknowledged by the receiving TCP. Slow start attempts to prevent a fast TCP
    sender from overwhelming a network. However, if unrestrained, slow start’s exponential
    increase in the transmission rate could mean that the sender would soon overwhelm
    the network. TCP’s *congestion-avoidance* algorithm prevents this, by placing
    a governor on the rate increase.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*慢启动*算法使得发送方TCP最初以较慢的速率发送分段，但随着这些分段被接收方TCP确认，它允许传输速率呈指数增长。慢启动试图防止一个快速的TCP发送方压垮网络。然而，如果不加以控制，慢启动中的指数增长可能意味着发送方很快就会使网络过载。TCP的*拥塞避免*算法通过限制速率增长，避免了这一点。'
- en: With congestion avoidance, at the beginning of a connection, the sending TCP
    starts with a small *congestion window*, which limits the amount of unacknowledged
    data that it can transmit. As the sender receives acknowledgements from the peer
    TCP, the congestion window initially grows exponentially. However, once the congestion
    window reaches a certain threshold believed to be close to the transmission capacity
    of the network, its growth becomes linear, rather than exponential. (An estimate
    of the capacity of the network is derived from a calculation based on the transmission
    rate that was in operation when congestion was detected, or is set at a fixed
    value after initial establishment of the connection.) At all times, the quantity
    of data that the sending TCP will transmit remains additionally constrained by
    the receiving TCP’s advertised window and the local TCP’s send buffer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥塞避免阶段，连接开始时，发送方的TCP会从一个较小的*拥塞窗口*开始，这限制了它能够传输的未确认数据量。随着发送方收到来自对端TCP的确认，拥塞窗口最初会呈指数增长。然而，一旦拥塞窗口达到一个预定阈值，该阈值被认为接近网络的传输能力时，窗口的增长就会变为线性增长，而不是指数增长。（网络容量的估算来自于基于拥塞检测时的传输速率的计算，或者在连接建立后设置为一个固定值。）在任何时候，发送方TCP能够传输的数据量都会受到接收方TCP通告的窗口和本地TCP发送缓冲区的额外限制。
- en: In combination, the slow-start and congestion-avoidance algorithms allow the
    sender to rapidly raise its transmission speed up to the available capacity of
    the network, without overshooting that capacity. The effect of these algorithms
    is to allow data transmission to quickly reach a state of equilibrium, where the
    sender transmits packets at the same rate as it receives acknowledgements from
    the receiver.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Requests for Comments (RFCs)
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the Internet protocols that we discuss in this book is defined in an
    RFC document—a formal protocol specification. RFCs are published by the *RFC Editor*
    ([http://www.rfc-editor.org/](http://www.rfc-editor.org/)), which is funded by
    the *Internet Society* ([http://www.isoc.org/](http://www.isoc.org/)). RFCs that
    describe Internet standards are developed under the auspices of the *Internet
    Engineering Task Force* (IETF, [http://www.ietf.org/](http://www.ietf.org/)),
    a community of network designers, operators, vendors, and researchers concerned
    with the evolution and smooth operation of the Internet. Membership of the IETF
    is open to any interested individual.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The following RFCs are of particular relevance to the material covered in this
    book:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: RFC 791, *Internet Protocol*. J. Postel (ed.), 1981.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 950, *Internet Standard Subnetting Procedure*. J. Mogul and J. Postel, 1985.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 793, *Transmission Control Protocol*. J. Postel (ed.), 1981.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 768, *User Datagram Protocol*. J. Postel (ed.), 1980.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1122, *Requirements for Internet Hosts—Communication Layers*. R. Braden
    (ed.), 1989.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RFC 1122 extends (and corrects) various earlier RFCs describing the TCP/IP protocols.
    It is one of a pair of RFCs that are often simply known as the *Host Requirements
    RFCs*. The other member of the pair is RFC 1123, which covers application-layer
    protocols such as *telnet*, FTP, and SMTP.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the RFCs that describe IPv6 are the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: RFC 2460, *Internet Protocol*, *Version 6*. S. Deering and R. Hinden, 1998.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 4291, *IP Version 6 Addressing Architecture*. R. Hinden and S. Deering,
    2006.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 3493, *Basic Socket Interface Extensions for IPv6*. R. Gilligan, S. Thomson,
    J. Bound, J. McCann, and W. Stevens, 2003.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 3542, *Advanced Sockets API for IPv6*. W. Stevens, M. Thomas, E. Nordmark,
    and T. Jinmei, 2003.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A number of RFCs and papers provide improvements and extensions to the original
    TCP specification, including the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*Congestion Avoidance and Control*. V. Jacobsen, 1988. This was the initial
    paper describing the congestion-control and slow-start algorithms for TCP. Originally
    published in *Proceedings of SIGCOMM ’88*, a slightly revised version is available
    at [ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z](ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z).
    This paper is largely superseded by some of the following RFCs.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 1323, *TCP Extensions for High Performance*. V. Jacobson, R. Braden, and
    D. Borman, 1992.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2018, *TCP Selective Acknowledgment Options*. M. Mathis, J. Mahdavi, S.
    Floyd, and A. Romanow, 1996.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2581, *TCP Congestion Control*. M. Allman, V. Paxson, and W. Stevens, 1999.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2861, *TCP Congestion Window Validation*. M. Handley, J. Padhye, and S.
    Floyd, 2000.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2883, *An Extension to the Selective Acknowledgement (SACK) Option for TCP*.
    S. Floyd, J. Mahdavi, M. Mathis, and M. Podolsky, 2000.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 2988, *Computing TCP’s Retransmission Timer*. V. Paxson and M. Allman, 2000.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 3168, *The Addition of Explicit Congestion Notification (ECN) to IP*. K.
    Ramakrishnan, S. Floyd, and D. Black, 2001.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RFC 3390, *Increasing TCP’s Initial Window*. M. Allman, S. Floyd, and C. Partridge,
    2002.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TCP/IP is a layered networking protocol suite. At the bottom layer of the TCP/IP
    protocol stack is the IP network-layer protocol. IP transmits data in the form
    of datagrams. IP is connectionless, meaning that datagrams transmitted between
    source and destination hosts may take different routes across the network. IP
    is unreliable, in that it provides no guarantee that datagrams will arrive in
    order or unduplicated, or even arrive at all. If reliability is required, then
    it must be provided via the use of a reliable higher-layer protocol (e.g., TCP),
    or within an application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The original version of IP is IPv4\. In the early 1990s, a new version of IP,
    IPv6, was devised. The most notable difference between IPv4 and IPv6 is that IPv4
    uses 32 bits to represent a host address, while IPv6 uses 128 bits, thus allowing
    for a much larger number of hosts on the world-wide Internet. Currently, IPv4
    remains the most widely used version of IP, although in coming years, it is likely
    to be supplanted by IPv6.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Various transport-layer protocols are layered on top of IP, of which the most
    widely used are UDP and TCP. UDP is an unreliable datagram protocol. TCP is a
    reliable, connection-oriented, byte-stream protocol. TCP handles all of the details
    of connection establishment and termination. TCP also packages data into segments
    for transmission by IP, and provides sequence numbering for these segments so
    that they can be acknowledged and assembled in the correct order by the receiver.
    In addition, TCP provides flow control, to prevent a fast sender from overwhelming
    a slow receiver, and congestion control, to prevent a fast sender from overwhelming
    the network.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
