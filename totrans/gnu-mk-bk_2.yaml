- en: Chapter 2. Makefile Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers techniques that can be useful when debugging makefiles.
    The lack of built-in debugging tools, and the complexities of following variables
    in `make`, can make it very challenging to understand why a particular target
    was (or more often was not) built.
  prefs: []
  type: TYPE_NORMAL
- en: The first recipe in this chapter shows the single most useful line that you
    can add to a makefile; it’s the equivalent of a print statement inserted into
    code for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the Value of a Makefile Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve ever looked in a makefile, you’ll realize that makefile variables
    (often just called variables) form the backbone of any `make` process. Variables
    often define which files will be compiled, what command line parameters to pass
    to compilers, and even where to find the compiler. And if you’ve ever tried to
    debug a makefile, you know that the number one question you ask yourself is, “What
    is the value of variable `X`?”
  prefs: []
  type: TYPE_NORMAL
- en: GNU `make` doesn’t have a built-in debugger, nor does it provide the sort of
    interactivity you’d get from a scripting language like Perl or Python. So how
    do you figure out the value of a variable?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the simple makefile shown in [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables"), which just sets
    various variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1. A simple makefile that sets various variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is the value of `X`?
  prefs: []
  type: TYPE_NORMAL
- en: 'The small size and simplicity of this makefile make it feasible to trace through
    all the variable assignments, but even then it takes some work to conclude that
    `X` is `dogs hate cats`. In a multi-thousand-line makefile, one that fully utilizes
    the power of GNU `make`’s variables and functions, figuring out the value of a
    variable can be laborious indeed. Fortunately, here’s a little `make` recipe that
    does all the work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can find the value of variable `X` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because an explicit rule for the `print-X` target doesn’t exist, `make` looks
    for a pattern rule, finds `print-%` (the `%` acts as a wildcard), and runs the
    associated command. The command uses `$*`, a special variable that contains the
    value matched by the `%` in the rule, to print the name of the variable, and then
    does `$($*)` to get its value. This is a very useful technique in makefiles because
    it allows the name of a variable to be computed. In this case, the name of the
    variable to be printed comes from another variable, `$*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this rule can be used to print the values of variables defined in
    the makefile in [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it’s useful to know *how* a variable was defined. `make` has the
    `$origin` function, which returns a string containing the *type* of a variable—that
    is, whether it was defined in a makefile, on the command line, or in the environment.
    Modifying `print-%` to print out origin information as well is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see that `YS` is defined in the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we override the value of `YS` on the command line, we’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because `YS` was set on the `make` command line, its `$(origin)` is now `command
    line` and no longer `file`.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping Every Makefile Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section showed you how to print the value of a single makefile
    variable using a special rule. But what if you want to print every variable defined
    in a makefile?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, GNU `make` 3.80 introduced a couple of new features that make it
    feasible to print the value of all the variables defined in a makefile using a
    single rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab "Example 2-1. A
    simple makefile that sets various variables") again. It sets five variables: `X`,
    `Y`, `Z`, `S`, `YS`, and `ZS`. Adding the following lines to the example creates
    a target called `printvars` that will dump all the variables defined in the makefile,
    as shown in [Example 2-2](ch02.html#target_to_print_all_variables "Example 2-2. A
    target to print all variables").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2. A target to print all variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before we look closely at how this works, try it out on your own, as shown in
    [Example 2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe "Example 2-3. All
    the variables from Example 2-1 dumped by printvars").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3. All the variables from [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables") dumped by `printvars`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `make` has thrown in three extra variables that weren’t explicitly
    defined—`MAKEFILE_LIST`, `MAKEFLAGS`, and `SHELL`—but the rest are all defined
    in the makefile. Each line shows the name of the variable, its fully substituted
    value, and the way in which it was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a lot easier to understand the long complex line used to print the variables
    when it’s reformatted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.VARIABLES` variable is a new feature in GNU `make` 3.80: its value is
    a list of the names of all the variables defined in the makefile. First, the code
    sorts it into order: `$(sort $(.VARIABLES))`. Then it goes through the sorted
    list, variable name by variable name, and sets `V` to each name in turn: `$(foreach
    V,$(sort (.VARIABLES)),...)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each variable name, the loop decides whether to print or ignore the variable
    depending on how it was defined. If it’s a built-in variable, like `$@` or `$(CC)`,
    or came from the environment, it shouldn’t get printed. This decision is made
    by the predicate at ➊. It first figures out how the variable referenced by `$V`
    was defined by calling `$(origin $V)`. This call returns a string describing how
    the variable was defined: `environment` for environment variables, `file` for
    variables defined in a makefile, and `default` for things the `make` defines.
    The `$(filter-out)` statement says if the result of `$(origin)` matches any of
    the patterns `environment%`, `default`, or `automatic` (`automatic` is returned
    by `$(origin)` for `make`’s automatic variable like `$@`, `$<`, and so on), then
    return an empty string; otherwise, leave it alone. This means `$(if)`’s predicate
    will be true only if the variable was defined in the makefile or set on the command
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: If `$(if)`’s predicate is true, then `$(info $V=$($V) ($(value $V)))` outputs
    a message containing the name of the variable, its fully expanded value, and its
    defined value. The `$(value)` function is another new feature in GNU `make` 3.80;
    it outputs the value of a variable without expanding it. In [Example 2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe
    "Example 2-3. All the variables from Example 2-1 dumped by printvars"), `$(YS)`
    would return the value `dogs`, but `$(value YS)` would return `$(Y)$(S)`. That
    is, `$(value YS)` shows us how `YS` is defined, not its final value. That’s a
    very useful debugging feature.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Variable Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a makefile grows, it can become difficult to figure out where a variable
    is used. This is especially true because of GNU `make`’s recursive variables:
    the use of a variable could be hidden deep inside some other variable declaration
    in the makefile. This recipe shows how to trace individual variables as they are
    used.'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll use the makefile in [Example 2-4](ch02.html#example_makefile_for_tracing
    "Example 2-4. Example makefile for tracing") (the lines have been numbered for
    later reference purposes).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4. Example makefile for tracing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this makefile prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing"), the makefile contains a number of recursively defined
    variables and uses them in rule definitions and commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Variable Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you trace through [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing"), you’ll see that the variable `$(Y)` is used on lines 8,
    9, and 11, and twice on line 12\. It’s amazing how often variables are used! The
    reason is that `make` gets the value of a recursively expanded variable (such
    as `YS` in [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing")) only when it is needed (that is, when the variable is
    used and hence expanded), and recursively expanded variables are frequently deeply
    nested.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s annoying enough to trace a variable through the simple makefile in [Example 2-4](ch02.html#example_makefile_for_tracing
    "Example 2-4. Example makefile for tracing"), but doing so for a real makefile
    would be practically impossible. Fortunately, it’s possible to get `make` to do
    the work for you with the following code, which you should add to the start of
    the makefile to be traced (it’ll only get used when explicitly called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dive into how it works, here’s an example of using it to trace the
    value of `Y` in our example makefile. To use the tracer, tell `make` to run the
    `trace` target by setting the `TRACE` variable to the name of the variable you
    want to trace. Tracing the variable `Y` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From the `TRACE` output you can see `Y` being used first on line 8 in the definition
    of the `all` target, which references `Y` via the `$(YS)`; then on line 11 the
    definition of the `cats` target, which also uses `$(YS)`; then twice on line 12
    with the two direct references to `$(Y)`; and finally on line 9 via `$(X)`, which
    references `$(YS)`, which references `$(Y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we can use the tracer to find out where `$(S)` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that `S` is first used twice on line 8 (the `all` target used
    `XS` and `YS`, which both use `S`). Then `S` appears again on line 4 (because
    `YS` is used) and line 12 (because `XS` is used). Finally, `S` is used twice on
    line 9, when `X` is echoed as `X` is used by `XS` and `YS`, which both use `S`.
  prefs: []
  type: TYPE_NORMAL
- en: How the Variable Tracer Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` has a special `$(warning)` function that outputs a warning message
    to `STDERR` and returns the empty string. At a high level, our tracer code changes
    the value of the variable to be traced to include a `$(warning)` message. Every
    time the variable is expanded, the warning is printed, and whenever `make` outputs
    a warning message, it prints the name of the makefile in use and the line number.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say the definition of `Y` is changed from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then, whenever `$(Y)` is expanded, a warning would be generated, and `$(Y)`
    would have the value `dog`. And because `$(warning)` doesn’t return any value,
    the value of `Y` is unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: To add this `$(warning)` call, the tracer code first obtains the unexpanded
    value of the variable to be traced, then prepends it with an appropriate `$(warning)`,
    and finally runs the desired `make` with the specially modified value of the variable
    being examined. It uses the `$(value)` function, which as you saw in [Example 2-2](ch02.html#target_to_print_all_variables
    "Example 2-2. A target to print all variables") enables you to get the unexpanded
    value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the tracer works in detail. If `TRACE` is defined, `make` will process
    the block of tracer definitions. In that case, because `_trace` is the first target
    encountered, it will be the rule that runs by default. The `_trace` rule contains
    a single, complex command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the right side of the command is a `$(shell)` invocation that reruns the
    makefile with a different goal. If we are tracing `YS`, for example, this `$(shell)`
    runs the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the `_value` rule, which is defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because `TRACE` has been set to `YS`, this rule simply echoes the definition
    of `YS`, which is the literal string `$(Y)$(S)`. So that’s what `$(shell)` ends
    up evaluating to.
  prefs: []
  type: TYPE_NORMAL
- en: 'That `$(shell)` call is in fact inside a command line variable definition (usually
    called a *command line override*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the `$(warning)` needed to output the `TRACE X` messages. Notice
    how the name of the variable being defined is a computed value: its name is contained
    in `$(TRACE)`. When tracing `YS`, this definition turns into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The single quotes are used to prevent the shell from seeing the `$` sign. The
    double `$` is used to prevent `make` from seeing the `$`. In either case a variable
    expansion would occur (either in `make` or by the shell), and we want to delay
    any variable expansion until `YS` is actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `_trace` rule recursively runs `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `TRACE` is reset to the empty string, because this recursive invocation
    of `make` should run the real rules rather than the tracer rules. Also, it overrides
    the value of `YS`. Recall that variables defined on the command line override
    definitions in the makefile: even though `YS` is defined in the makefile, the
    `warning`-enabled, command line definition is the one that’s used. Now, every
    time `YS` is expanded, a warning is printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this technique doesn’t work for a variable that is target specific.
    `make` allows you to define a variable as specific to a target in the manner shown
    in [Example 2-5](ch02.html#defining_a_target-specific_variable "Example 2-5. Defining
    a target-specific variable"):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5. Defining a target-specific variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The variable `FOO` will have the value `foo` in the rule that builds `all` and
    in any prerequisites of `all`. The makefile in [Example 2-5](ch02.html#defining_a_target-specific_variable
    "Example 2-5. Defining a target-specific variable") will print `foo` twice, because
    `FOO` is defined in both the `all` and `a` rules. The tracer is unable to obtain
    the value of `FOO` and would in fact cause this makefile to behave incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tracer works by redefining the variable being traced as described earlier.
    Because this happens outside a rule definition, the tracer has no way of obtaining
    the value of a variable that is target specific. For example, in [Example 2-5](ch02.html#defining_a_target-specific_variable
    "Example 2-5. Defining a target-specific variable"), `FOO` is defined only when
    running the `all` or `a` rules. The tracer has no way of obtaining its value.
    Using the tracer on that makefile to trace `FOO` results in the wrong behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That should have output `foo` twice (once for the `all` rule and once for `a`),
    but the tracer has redefined `FOO` and messed up its value. Don’t use this tracer
    for target-specific variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$(warning)` function sends its output to `STDERR`, which makes it possible
    to separate normal `make` output from the tracer. Simply redirect `STDERR` to
    a trace log file. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command will write normal `make` output to the command line while redirecting
    the trace output to *trace.log*.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Rule Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until GNU `make` 4.0, there was no built-in way to trace the order of execution
    of makefile targets. GNU `make` 4.0 added the `--trace` option, which I cover
    in [GNU make 4.0 Tracing](ch02.html#gnu_make_4dot0_tracing "GNU make 4.0 Tracing"),
    but if you need to use an earlier version of `make`, it’s handy to have another
    way to trace a makefile. The techniques shown here work with GNU `make` 4.0 and
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you’ve ever stared at a cryptic log output and asked yourself, “What rule
    caused that output?” or “Where’s the output for the `foo` rule?” then this section
    is for you. And to be honest, who hasn’t wondered what GNU `make`’s log file output
    means?*'
  prefs: []
  type: TYPE_NORMAL
- en: An Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section uses the following example makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It builds two files: `foo.o` and `bar`. We’ll assume that `foo.c` exists so
    that `make`’s built-in rules create `foo.o`; whereas `bar` is a simple rule that
    just touches `$@`. If you run `make` for the first time with this makefile, you’d
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This log output is rather cryptic. There’s no sign of the rule for `bar` being
    run (because `touch $@` was hidden using the `@` modifier, which prevents the
    command from being printed). And there’s no indication that it was the rule for
    `foo.o` that generated the `cc` compilation line. Nor is there any indication
    that the `all` rule was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could, of course, use `make -n` (which just prints the commands to be run
    without actually executing them) to look at the work that GNU `make` would perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case it’s practical, but in general `make -n`’s output can be just as
    cryptic as a normal log file, and it doesn’t provide any way of matching lines
    in the log with lines in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: The SHELL Hack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One simple way to enhance the output of GNU `make` is to redefine `SHELL`, which
    is a built-in variable that contains the name of the shell to use when `make`
    executes commands. Most shells have an `-x` option that causes them to print each
    command they are about to execute; therefore, if you modify `SHELL` in a makefile
    by appending `-x`, it will cause every command to be printed as the makefile is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the example makefile modified using GNU `make`’s `+=` operator to append
    `-x` to `SHELL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In some shells this may not work (the shell may expect a single word of options).
    In GNU `make` 4.0 and later, a variable called `.SHELLFLAGS` contains the flags
    for the shell and can be set to avoid this problem instead of altering `SHELL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the makefile output reveals that `touch bar` was generated by the rule
    for `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SHELL` technique has one disadvantage: it slows `make` down. If `SHELL`
    is left untouched, `make` will often avoid using the shell altogether if it knows
    it can execute the command directly—for simple operations like compilation and
    linking, for example. But once `SHELL` is redefined in a makefile, `make` will
    always use the shell, thus slowing it down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that doesn’t make this a bad debugging trick: getting additional
    information for a brief slowdown is a very small price to pay. But redefining
    `SHELL` doesn’t help track the relationship between the lines in a log file and
    the makefile. Fortunately, this is possible to do with an even smarter redefinition
    of `SHELL`.'
  prefs: []
  type: TYPE_NORMAL
- en: An Even Smarter SHELL Hack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `SHELL` has been redefined, `make` will expand its value before it runs each
    line of each rule. This means that if the expansion of `SHELL` were to output
    information, it would be possible to print information before each rule runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in [Tracing Variable Values](ch02.html#tracing_variable_values "Tracing
    Variable Values"), the `$(warning)` function helpfully outputs a string of your
    choosing, along with the name of the makefile and the line number at which the
    `$(warning)` was written. By adding a `$(warning)` call to `SHELL`, it’s possible
    to print detailed information every time `SHELL` gets expanded. The following
    code snippet does just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first line captures the normal value of `SHELL` in a variable called `OLD_SHELL`.
    Notice the use of `:=` to get `SHELL`’s final value, not its definition. The second
    line defines `SHELL` to include the old shell value and a `$(warning)` that will
    print the name of the target being built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running GNU `make` now produces very useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output is produced when the built-in pattern rule to build
    `foo.o` is about to be executed. Because no makefile or line number information
    gets printed, we know that a built-in rule was used here. Then you see the actual
    output of the built-in rule (the `cc` command). This is followed by another piece
    of output from the `$(warning)`, stating that `bar` is about to be built using
    the rule in the makefile at line 7.
  prefs: []
  type: TYPE_NORMAL
- en: We used `$@` in the `$(warning)` statement that we added to `SHELL`, but there’s
    nothing stopping us from using other automatic variables. For example, in [Example 2-6](ch02.html#using_the_shell_hack
    "Example 2-6. Using the SHELL hack"), we use `$<`, which holds the first prerequisite
    from which the target is being built, and `$?`, which holds the list of prerequisites
    that are newer than the target and tells us why the target is being built.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6. Using the `SHELL` hack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `SHELL` has been redefined to output three pieces of information: the
    name of the target being built (`$@`), the name of the first prerequisite (`$<`,
    which is wrapped in a `$(if)` so that nothing is printed if there is no prerequisite),
    and the names of any newer prerequisites (`$?`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting `foo.o` and running `make` on this makefile now shows that `foo.o`
    was built from `foo.c` because `foo.c` was newer than `foo.o` (because it was
    missing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing to stop us from combining this `$(warning)` trick with `-x`
    to get output showing which rules ran and what commands were executed, as shown
    in [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn "Example 2-7. Combining
    the $(warning) trick with -x").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7. Combining the $(`warning`) trick with `-x`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the full output of the makefile in [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "Example 2-7. Combining the $(warning) trick with -x").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that `foo.c` was newer than `foo.o` (or `foo.o` was missing) when
    `make` was run.
  prefs: []
  type: TYPE_NORMAL
- en: GNU make 4.0 Tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make` 4.0 added a `--trace` command line option that you can use to trace
    rule execution. It provides output similar to that of [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "Example 2-7. Combining the $(warning) trick with -x"). Here’s what happens when
    [Example 2-6](ch02.html#using_the_shell_hack "Example 2-6. Using the SHELL hack"),
    minus the `SHELL` modifications, is traced using GNU `make` 4.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When called with the `--trace` option, GNU `make` 4.0 overrides the `@` modifier
    (used in the earlier example to suppress `touch bar`) in the same way that the
    `-n` and `--just-print` flags do.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most programming languages have assertions: statements that do nothing if the
    value they assert is true but cause a fatal error if not. They’re commonly used
    as a runtime debugging aid to catch very odd situations. A typical assert in C
    might look like `assert( foo != bar )` and would result in a fatal error if `foo`
    and `bar` are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, GNU `make` does not have any form of built-in assertions. But
    they are easy to create from existing functions, and there are even convenient
    assertion functions defined in the GNU Make Standard Library (GMSL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The GMSL project (which is covered in [Chapter 6](ch06.html "Chapter 6. The
    GNU Make Standard Library")) provides two assertion functions: `assert` and `assert_exists`.'
  prefs: []
  type: TYPE_NORMAL
- en: assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `assert` function will output a fatal error if its first argument is false.
    As with `make`’s `$(if)` function, GMSL treats any non-empty string as true and
    an empty string as false. Thus, if `assert`’s argument is an empty string, the
    assertion will cause a fatal error; the second argument to `assert` will be printed
    as part of the error. For example, this makefile breaks immediately because `$(FOO)`
    and `$(BAR)` are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Because `assert` is not a built-in function—it’s user defined in the GMSL makefile—we
    must use `$(call)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The assertion uses another GMSL function, `sne`, which compares two strings
    and returns true if they are not equal or false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because true simply means *not an empty string*, it’s easy to assert that a
    variable be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can use this assertion, for example, to check that a user has set all necessary
    command line variables; if `FOO` is required for the makefile to run properly
    but the user forgot to set it on the command line, the assertion will cause an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use assertions to enforce that certain command line flags are
    not used. Here’s an example that prevents the user from setting `-i`, the ignore
    errors flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is more complex than the previous two because `make` can store
    the `-i` flag in `MAKEFLAGS` in two ways: as a flag in the familiar form `-i`
    or as a block of single characters in the first word of `MAKEFLAGS`. That is,
    setting the command line flags `-i -k` results in `MAKEFLAGS` having the value
    `ki`. So the first `assert` in the loop looks for `-i`, and the second `assert`
    searches for `i` in the first word of `MAKEFLAGS`.'
  prefs: []
  type: TYPE_NORMAL
- en: assert_exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the success of a build relies on having all necessary files present,
    the GMSL provides an assertion specifically designed to warn if a file is missing.
    The `assert_exists` function has a single argument: the name of the file that
    must exist. For example, to check that the file *foo.txt* exists before any commands
    are run by the makefile, you can add an assertion at the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file does not exist, the build stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The assertion stopped the build and the line on which the assertion is found
    in the makefile—in this case, 3—is shown.
  prefs: []
  type: TYPE_NORMAL
- en: assert_target_directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common problem in building real-world makefiles is that you must construct
    directory hierarchies during or before the build. You can ensure that every directory
    exists before each rule runs by creating a special `assert_target_directory` variable,
    as shown in [Example 2-8](ch02.html#creating_an_assertunderscoretargetunders "Example 2-8. Creating
    an assert_target_directory variable").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8. Creating an `assert_target_directory` variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By inserting `$(call assert_target_directory)` at the start of each rule or
    pattern rule’s recipe, `make` automatically checks that the directory in which
    the target is to be written exists. For example, if *foo/* does not exist, the
    makefile in [Example 2-8](ch02.html#creating_an_assertunderscoretargetunders "Example 2-8. Creating
    an assert_target_directory variable") results in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The error gives the name of the makefile and the line number at which the problem
    occurred, making it trivial to find the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a final trick, it’s possible to use a two-line modification to cause the
    makefile to check every rule for a missing directory. Instead of adding `$(call
    assert_target_directory)` to every rule, just redefine the `SHELL` variable to
    include `$(call assert_target_directory)`. This does slow performance but can
    be useful in tracking down a missing directory somewhere deep in nested makefiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`make` expands the value of `SHELL` and hence performs a call to `assert_target_directory`
    for every rule that is run. This simple change means that every rule checks that
    the target directory exists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new value of `SHELL` consists of a call to `assert_target_directory`, which
    always returns an empty string, followed by the old value of `SHELL`, which had
    been stored in `OLD_SHELL`. Note how `OLD_SHELL` is defined using `:=` so that
    `SHELL` doesn’t refer to itself—`OLD_SHELL` contains the value of `SHELL` at runtime
    and can be safely used to redefine `SHELL`. If `OLD_SHELL` were defined using
    `=`, `make` would fail to run because of a circular reference: `SHELL` would refer
    to `OLD_SHELL`, which in turn would refer to `SHELL`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The `assert_target_directory` function works by calling the built-in `$(wildcard)`
    function with the name of the directory where the current target being built should
    be written. The `$(wildcard)` function simply checks to see whether the directory
    exists and returns the name of the directory if so or the empty string if the
    directory is missing. The target is defined by the automatic variable `$@`, and
    the directory portion is extracted with `$(dir)`.
  prefs: []
  type: TYPE_NORMAL
- en: An Interactive GNU make Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite GNU `make`’s popularity, debugging facilities are few and far between.
    GNU `make` has a `-d` option that outputs extensive (but not necessarily useful)
    debugging information about a build, and a `-p` option that prints GNU `make`’s
    internal database of rules and variables. This section shows how to build an interactive
    debugger for GNU `make` using only GNU `make`’s internal functions and the shell
    `read` command.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger has breakpoints, dumps information about the rule at which a breakpoint
    is hit, and allows interactive querying of variable values and definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The Debugger in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you see how the debugger works, let’s look at how to use it. The debugger
    and these examples all assume that you are using GNU `make` 3.80 or later. [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") shows an
    example makefile that builds `all` from the prerequisites `foo` and `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9. Setting a breakpoint using the `__BREAKPOINT` variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate the use of the debugger, a breakpoint is set in the `all` rule
    by inserting a line at the start of the rule’s recipe that consists of just the
    variable `__BREAKPOINT`. `$(__BREAKPOINT)` gets expanded when the rule runs, causing
    the debugger to break execution and prompt when the `all` rule is about to run,
    as shown in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor "Example 2-9. Setting
    a breakpoint using the __BREAKPOINT variable").
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what happens when this makefile is executed with no existing files called
    `all`, `foo`, or `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, you see the output from the execution of the rules for `foo` and `bar`
    (the `Building foo` and `Building bar` lines), and then there’s a break into the
    debugger. The debugger break shows the line at which the break occurred and in
    which makefile. In this case, the breakpoint occurred at line 51 of the makefile.
    (It’s line 51 because what’s not shown in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") is all the
    actual GNU `make` variables that make the debugger work.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugger also outputs information about the rule being built. Here you
    can see that `all` is built from `foo` and `bar` and that the first prerequisite
    is `foo`. That’s important because it’s the first prerequisite that is stored
    in GNU `make`’s `$<` automatic variable. (`$<` is typically used as the source
    code filename for compilation.) The debugger also shows why the `all` rule ran:
    `foo` and `bar` are both newer than `all` (because they were both just built by
    their respective rules).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the debugger prompts `1>` for a command. The debugger will accept
    32 commands before automatically continuing execution of the makefile. The number
    `1` indicates that this is the first command; once `32>` is reached, the debugger
    will continue automatically. The first thing to do is ask for help by typing `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger provides two means of stopping debugging: typing `c` continues
    with normal execution of the makefile; typing `q` quits `make`. The three debugger
    commands `v`, `o`, and `d` allow the user to interrogate GNU `make` variables
    by asking for the value of a variable, its origin (where it was defined), or its
    definition. For example, the makefile in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") contains
    two variables—`MYVAR1` and `MYVAR2`—and a variable that is specific to the `all`
    rule: `MYVAR3`. A first step is to ask the debugger for the values of each of
    these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If it wasn’t clear how `MYVAR3` got its value, you could ask the debugger for
    its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that `MYVAR3` is defined as `$(MYVAR2)`. And so the obvious next
    step is to find out how `MYVAR2` is defined (and also `MYVAR1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And if it wasn’t clear where `MYVAR1` got its value, the `o` command will show
    its origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that `MYVAR1` is defined in a makefile. In contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If the user has overridden the value of `MYVAR1` on the command line (by running,
    say, `make MYVAR1=Hello`), the `o` command reflects that.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints in Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as setting breakpoints in normal rules, you can also set them in patterns.
    Every time that pattern rule is used, the breakpoint is hit. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `all` is built from `foo.x` and `bar.x`, which requires building them
    from `foo.y` and `bar.y` using the `%.x: %.y` rule. A breakpoint is inserted in
    the pattern rule, and the debugger breaks twice: once for `foo.x` and once for
    `bar.x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Even pattern-specific variables work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`%.x` has a pattern-specific variable `FOO` with the value `foo`; the debugger
    `v` command can access it during a breakpoint on the pattern rule.'
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints in Makefiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additionally, you can simply insert a breakpoint in a makefile if needed. Parsing
    of makefiles will pause at the breakpoint so you can examine the current state
    of variables in the makefile. For example, with a breakpoint after each definition
    of `FOO` in this makefile, you can see its value change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The two separate breakpoints are activated (one after each time `FOO` is set).
    Using the debugger’s `v` command shows how the value of `FOO` changes at each
    breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger Internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The debugger draws on functions defined in the GMSL (you can read more about
    the GMSL in [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard Library")).
    The first line of the debugger includes the GMSL functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger uses the `__PROMPT` variable to output the `n>` and read in a
    command followed by a single argument. `__PROMPT` uses the `read` shell command
    to get the command and argument into shell variables `$CMD` and `$ARG` and then
    returns a list of two elements: the first element is the command and the second
    is the argument. Expanding `__PROMPT` prompts for and returns a single command
    and argument pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `__BREAK` variable to get and handle a single command. First, it
    stores the result of `__PROMPT` in `__INPUT`, and then it calls the `__DEBUG`
    function (which handles debugger commands) with two arguments: the command and
    its argument returned by `__PROMPT` in `__INPUT`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `__DEBUG` function handles the core of the debugger. `__DEBUG` takes a single
    character command in `$1`, its first argument, and an optional argument to the
    command in `$2`. `$1` is stored in the variable `__c` and `$2` in `__a`. Then
    `__DEBUG` examines `__c` to see whether it is one of the supported debugger commands
    (`c`, `q`, `v`, `d`, `o`, or `h`); if not, a call to `$(warning)` will output
    an error message.
  prefs: []
  type: TYPE_NORMAL
- en: '`__DEBUG` consists of a set of nested `$(if)` statements that use the GMSL
    `seq` function to determine if the `__c` is a valid debugger command. If it is,
    `$(if)`’s first argument is expanded; if not, the next `$(if)` is examined. For
    example, the `v` command (which outputs the value of a variable) is handled like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the `__c` command is `v`, then `$(warning)` is used to output the value of
    the variable named by `__a` (the `$($(__a))` outputs the value of the variable
    whose name is stored in `__a`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When `__DEBUG` is done, it returns either `$(true)` or `$(false)` (the empty
    string). `$(true)` indicates that the debugger should stop prompting for commands
    and continue execution (the `q` command is handled by calling GNU `make`’s `$(error)`
    function to cause a fatal error, which stops `make`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we come to the definition of `__BREAKPOINT` (the breakpoint variable
    we used in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor "Example 2-9. Setting
    a breakpoint using the __BREAKPOINT variable")). It first outputs a banner containing
    information (you’ll see what `__BANNER` does in a moment); then it loops asking
    for commands by calling `__BREAK`. The loop terminates either if it runs out of
    items in `__LOOP` (which is where the 32-command limit is defined) or if a call
    to `__BREAK` returns `$(true)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`__BANNER` shows that the debugger has stopped at a breakpoint, and by examining
    GNU `make` automatic variables, it is able to give information about the current
    rule being built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the complete debugger code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For the most up-to-date version, visit the GNU `make` Debugger open source project
    at *[http://gmd.sf.net/](http://gmd.sf.net/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Breakpoints in the GNU make Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding section showed how to build a debugger for GNU `make` entirely
    in GNU `make`. But it had only static (hardcoded) breakpoints. This section shows
    you how to enhance the debugger by adding dynamic breakpoints. That makes it possible
    to set and remove breakpoints on the name of a file (in GNU `make` language, a
    *target*) that the makefile will build.
  prefs: []
  type: TYPE_NORMAL
- en: It’s no longer necessary to insert the `$(__BREAKPOINT)` string in a makefile.
    Typing a simple set breakpoint command has the same effect. And another keystroke
    lists all breakpoints currently in effect.
  prefs: []
  type: TYPE_NORMAL
- en: This section shows the use of the new breakpoints and how they are coded. The
    new code is written entirely in GNU `make`’s variable language and uses the GMSL
    set functions (detailed in [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard
    Library")) to maintain the list of current breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the breakpoints to activate requires a little GNU `make` magic, but
    first let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Breakpoints in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you see how the debugger works, let’s look at how to use it. The debugger
    and these examples all assume that you are using GNU `make` 3.80 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example makefile that builds `all` from prerequisites `foo` and `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate the use of the debugger, a breakpoint is set in the makefile by
    inserting a line at the end of the makefile that consists of just the variable
    `$(__BREAKPOINT)`. `$(__BREAKPOINT)` will get expanded when the makefile finishes
    being parsed, causing the debugger to break execution before any rules are run
    and prompt for input. (The debugger is included here with the `include gmd` command
    at the start. You can get the GMD files from the GMD website at *[http://gmd.sf.net/](http://gmd.sf.net/)*;
    it’s all open source code.)
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what happens when this makefile is executed with no existing files called
    `all`, `foo`, or `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger immediately breaks and waits for input. The first thing to do
    is type `h` to see the help text and the three new commands: `b` (to set a breakpoint),
    `r` (to remove a breakpoint), and `l` (to list current breakpoints).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then set two breakpoints in the makefile: one when `foo` gets built and one
    for `all`. (If you look back at [The Debugger in Action](ch02.html#debugger_in_action
    "The Debugger in Action"), you’ll see that you can also achieve this by modifying
    the makefile, but these new breakpoints can be set dynamically at runtime.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the breakpoints, use the `l` command to verify that they are
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing execution by entering `c` causes the `foo` breakpoint to be hit
    immediately. `foo` is the first target that the makefile will build (followed
    by `bar` and finally `all`). The breakpoint indicates that the rule for `foo`
    is at line 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Continuing on, first the output (generated when `bar` is created) appears, and
    then the `all` breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `all` breakpoint prints out much more information than `foo` because `all`
    has prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: The Easy Part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the breakpoint functions to the GNU `make` debugger, the debugger code
    that handles the keyboard was first altered to recognize the `b`, `r`, and `l`
    commands and call user-defined GNU `make` functions `__BP_SET`, `__BP_UNSET`,
    and `__BP_LIST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The targets for which breakpoints are defined are simply a GMSL set of target
    names. Initially, there are no breakpoints and so the set, called `__BREAKPOINTS`,
    is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting and removing breakpoints is a matter of calling the GMSL functions
    `set_insert` and `set_remove` to add or remove an element from `__BREAKPOINTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions use the GNU `make $(eval)` function to change the value of `__BREAKPOINTS`.
    `$(eval FOO)` evaluates its argument `FOO` as if it were a piece of text during
    parsing of the makefile: this means that at runtime you can change variable values
    or define new rules.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__BP_UNSET` used the GMSL function `set_is_member` to determine whether the
    breakpoint being removed was actually defined and output a helpful message in
    the case that the user tries to remove a nonexistent breakpoint (which may be
    caused by a typing error on their part).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing the current breakpoints is simply a matter of outputting the contents
    of the set stored in `__BREAKPOINTS`. Because that set is just a list with no
    duplicates, `__BP_LIST` feeds its value into the GNU `make` functions `$(addprefix)`
    and `$(addsuffix)` to put quotation marks around the target names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`__BP_LIST` uses the GNU `make $(if)` function to choose between listing the
    breakpoints if there are any or saying `No target breakpoints set` if the `__BREAKPOINTS`
    set is empty. `$(if)` will evaluate its second argument if `$(__BREAKPOINTS)`
    is a non-empty string and evaluate its third argument if there are no breakpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: The Trick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get GNU `make` to break into the debugger, it has to expand the `__BREAKPOINT`
    variable, which outputs information about the breakpoint and prompts for commands.
    But for that to happen, we need a way to check which breakpoints are defined every
    time a rule is about to run. If we can engineer that, then `make` can expand `$(__BREAKPOINT)`
    if necessary, causing `make` to stop at the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it’s possible to cause `make` to expand `__BREAKPOINT` by modifying
    the built-in `SHELL` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SHELL` variable is also expanded every time a command is about to run
    inside a rule. That makes it ideal for checking breakpoints. Here’s the actual
    code in the GNU `make` debugger that uses `SHELL` for breakpoint handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: First, the real value of `SHELL` is stored in `__BP_OLD_SHELL` (note that the
    GNU `make :=` operator is used to capture the value, not the definition, of `SHELL`).
    Then `SHELL` is redefined to call the `__BP_NEW_SHELL` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`__BP_NEW_SHELL` is where the interesting work is done. The last part of it
    is `$(__BP_OLD_SHELL)`, which is the value of the original `SHELL` variable. After
    all, once it’s done checking breakpoints, GNU `make` needs to use the original
    `shell` to actually run commands. Before that there’s a rather complex `$(if)`.
    Concentrate for a moment on the call to `$(__BP_CHECK)`. That’s the variable that
    will actually check to see whether the breakpoint should be executed. It’s defined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`__BP_CHECK` checks to see whether the current target being built (stored in
    the standard GNU `make` automatic variable `$@`) is present in the list of breakpoints.
    It does this using the GMSL function `set_is_member`. If the target is present,
    it does two things: it sets an internal variable called `__BP_FLAG` to be the
    target for which the breakpoint has activated and then proceeds to `$(call)` a
    variable and throw away the result by storing it in a variable called `__IGNORE`.
    That’s done so that `__BP_CHECK`’s return value will always be empty; it’s used,
    after all, in the definition of `SHELL`, which ultimately needs to be just the
    name of the `shell` to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Experienced GNU `make` users will be scratching their heads wondering about
    the odd syntax `$(call SHELL,__BREAKPOINT)`. That’s where some GNU `make` rocket
    science comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket Science
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of writing `$(call SHELL,__BREAKPOINT)`, it’s tempting to write `$(__BREAKPOINT)`
    to get the breakpoint to activate. But that doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing so would cause a fatal GNU `make` error. Follow the chain of variables
    up from `__BP_CHECK`, and it becomes clear that it’s been expanded because `SHELL`
    was being expanded (because a rule was about to run). Follow into `__BREAKPOINT`,
    and there’s a nasty surprise: a call to `$(shell)` (this can be seen in the GMD
    code in [Addition and Subtraction](ch05.html#page_64) or in the preceding section),
    which will cause `SHELL` to be expanded.'
  prefs: []
  type: TYPE_NORMAL
- en: Danger, Will Robinson! `SHELL` is defined in terms of `SHELL`, which causes
    GNU `make` to spot the recursion and give up. The `$(call SHELL,__BREAKPOINT)`
    syntax lets us play with fire. Any time a variable is `$(call)`ed in GNU `make`,
    the flag used to check for recursion is disabled. So doing `$(call SHELL,__BREAKPOINT)`
    means that the recursion flag on `SHELL` is turned off (avoiding the error) and
    the definition of `SHELL` calls `__BP_NEW_SHELL` with one argument. The argument
    is the word `__BREAKPOINT`. `__BP_NEW_SHELL` checks to see whether `__BP_FLAG`
    is set to the same value as `$@` (which it does using the GMSL `seq` function)
    and then proceeds to `$(call)` its first argument (which is `__BREAKPOINT`); the
    breakpoint fires and the prompt appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might seem that some horrible infinite recursion will occur when the `$(shell)`
    gets executed and `SHELL` is expanded again. Two things prevent that: `__BP_FLAG`
    is still the same as `$@` (so `__BP_CHECK` is not called again), and this time
    `SHELL` has no argument (the value in `$1` is empty), so the `$(call $1,)` does
    nothing and recursion stops.'
  prefs: []
  type: TYPE_NORMAL
- en: An Introduction to remake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `remake` project (*[http://bashdb.sourceforge.net/remake/](http://bashdb.sourceforge.net/remake/)*)
    is a fork of GNU `make` that integrates a complete debugger created by modifying
    the GNU `make` source code. `remake` forked from GNU `make` 3.82 and is currently
    at version 3.82+dbg-0.9.
  prefs: []
  type: TYPE_NORMAL
- en: Just Print and Trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the operation of `remake`, let’s use [Example 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "Example 2-10. A simple makefile to illustrate remake"), a sample makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10. A simple makefile to illustrate remake
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the standard GNU `make -n` (or `--just-print`) option against this
    makefile produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'But `remake` provides a makefile and line number information for each rule.
    The information shows the target (the value of `$@`) and the commands to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you have to run any real makefile to understand its execution. `remake`
    provides a handy tracing option, `-x`, which runs the makefile while outputting
    information about why targets are being built and showing the commands executed
    and their output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The trace option really comes into its own when an error occurs. Here’s the
    output when a nonexistent option `-z` is added to the `touch` in the commands
    for target `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Right at the bottom of that output is the call stack of targets that were dependent
    on `bar` building successfully, plus, of course, the error generated by `touch`,
    the actual command that was executed, and where to find it in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because `remake` contains an interactive debugger, you can use it to debug
    the `touch` problem. Run `remake` with the `-X` option (uppercase `X` for the
    debugger; lowercase `x` for tracing), and the debugger breaks at the first target
    to be built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So the first break is at line 2 of the makefile and shows that the first target
    is `all` (and the complete prerequisite list is shown). Entering `h` gives complete
    help information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `touch` problem occurs later in the `make` execution (in the `bar`
    rule), just continue by single stepping with `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'While in the debugger, you can fix the error in the makefile and then enter
    `R` to restart the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now things work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Targets, Macro Values, and Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When stopped in the debugger, it’s possible to interrogate information about
    targets in the makefile, such as variable values (expanded and unexpanded) and
    commands. For example, in [Example 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "Example 2-10. A simple makefile to illustrate remake"), when stopped at a breakpoint,
    you can find all the information `remake` has about the `all` target by using
    the `target` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`remake` shows that `all` is a phony target and dumps information about the
    automatic variables that will be set for this rule. There’s no restriction on
    asking about the current target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Because target `foo` has commands, they are listed at the bottom (along with
    where to find them in which makefile). To see the expanded form of the commands,
    use the `expand` modifier of the `target` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To get information about a variable, we use the handy `print` and `expand`
    commands: `print` gives the definition of a variable, and `expand` gives its post-expansion
    value. Here’s how to find out the definition of the built-in `COMPILE.c` variable
    (which contains the command used to compile `.c` files):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the expanded value, `expand` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '`remake` can also set variable values using `set` (which expands a string and
    sets the variable to that value) and `setq` (which sets the variable to a string
    without expansion). For example, changing `CC` from `cc` to `gcc` changes the
    C compiler `make` will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`remake` is a very useful tool to add to your `make` toolkit. You don’t need
    to use it every day, but switching from `make` to `remake` when you have a knotty
    problem to solve is hassle-free if you are not using any features added in GNU
    `make` 4.0.'
  prefs: []
  type: TYPE_NORMAL
