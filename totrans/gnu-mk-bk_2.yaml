- en: Chapter 2. Makefile Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. Makefile 调试
- en: This chapter covers techniques that can be useful when debugging makefiles.
    The lack of built-in debugging tools, and the complexities of following variables
    in `make`, can make it very challenging to understand why a particular target
    was (or more often was not) built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些在调试 makefile 时可能有用的技巧。由于缺乏内置的调试工具，再加上追踪 `make` 中变量的复杂性，这使得理解为什么某个目标被（或更常见的是没有）构建变得非常具有挑战性。
- en: The first recipe in this chapter shows the single most useful line that you
    can add to a makefile; it’s the equivalent of a print statement inserted into
    code for debugging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的第一个配方展示了你可以添加到 makefile 中的最有用的一行；它相当于在代码中插入一个用于调试的打印语句。
- en: Printing the Value of a Makefile Variable
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印 Makefile 变量的值
- en: If you’ve ever looked in a makefile, you’ll realize that makefile variables
    (often just called variables) form the backbone of any `make` process. Variables
    often define which files will be compiled, what command line parameters to pass
    to compilers, and even where to find the compiler. And if you’ve ever tried to
    debug a makefile, you know that the number one question you ask yourself is, “What
    is the value of variable `X`?”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经查看过一个 makefile，你会意识到 makefile 变量（通常简称为变量）是任何 `make` 过程的骨干。变量通常定义了哪些文件将被编译、传递给编译器的命令行参数，甚至编译器的位置。如果你曾经试图调试一个
    makefile，你知道自己问的第一个问题是，“变量 `X` 的值是什么？”
- en: GNU `make` doesn’t have a built-in debugger, nor does it provide the sort of
    interactivity you’d get from a scripting language like Perl or Python. So how
    do you figure out the value of a variable?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 没有内置调试器，也不像 Perl 或 Python 这样的脚本语言那样提供交互式的功能。那么，如何找出一个变量的值呢？
- en: 'Take a look at the simple makefile shown in [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables"), which just sets
    various variables:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 [示例 2-1](ch02.html#simple_makefile_that_sets_various_variab "示例 2-1. 一个设置各种变量的简单
    makefile") 中展示的简单 makefile，它仅设置了几个变量：
- en: Example 2-1. A simple makefile that sets various variables
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1. 一个设置各种变量的简单 makefile
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is the value of `X`?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` 的值是什么？'
- en: 'The small size and simplicity of this makefile make it feasible to trace through
    all the variable assignments, but even then it takes some work to conclude that
    `X` is `dogs hate cats`. In a multi-thousand-line makefile, one that fully utilizes
    the power of GNU `make`’s variables and functions, figuring out the value of a
    variable can be laborious indeed. Fortunately, here’s a little `make` recipe that
    does all the work for you:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 makefile 的小巧和简洁使得追踪所有变量的赋值变得可行，但即便如此，要得出 `X` 的值是 `dogs hate cats` 还是需要一些工作。如果是一个拥有成千上万行的
    makefile，充分利用 GNU `make` 的变量和函数，要弄清楚一个变量的值确实可能会非常繁琐。幸运的是，这里有一个小小的 `make` 配方，它可以为你完成所有的工作：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you can find the value of variable `X` with the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令来查找变量 `X` 的值：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because an explicit rule for the `print-X` target doesn’t exist, `make` looks
    for a pattern rule, finds `print-%` (the `%` acts as a wildcard), and runs the
    associated command. The command uses `$*`, a special variable that contains the
    value matched by the `%` in the rule, to print the name of the variable, and then
    does `$($*)` to get its value. This is a very useful technique in makefiles because
    it allows the name of a variable to be computed. In this case, the name of the
    variable to be printed comes from another variable, `$*`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有为 `print-X` 目标定义显式规则，`make` 会查找模式规则，找到 `print-%`（`%` 起到通配符的作用），并运行相关联的命令。这个命令使用
    `$*`，一个特殊的变量，包含与规则中的 `%` 匹配的值，来打印变量的名称，然后使用 `$($*)` 来获取其值。这在 makefile 中是一个非常有用的技巧，因为它允许计算变量的名称。在这种情况下，要打印的变量名称来自另一个变量
    `$*`。
- en: 'Here’s how this rule can be used to print the values of variables defined in
    the makefile in [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables"):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这个规则来打印在 [示例 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "示例 2-1. 一个设置各种变量的简单 makefile") 中定义的变量的值：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sometimes it’s useful to know *how* a variable was defined. `make` has the
    `$origin` function, which returns a string containing the *type* of a variable—that
    is, whether it was defined in a makefile, on the command line, or in the environment.
    Modifying `print-%` to print out origin information as well is easy:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时了解一个变量是*如何*被定义的非常有用。`make`有一个`$origin`函数，它返回一个字符串，包含变量的*类型*——即变量是如何定义的，是否在makefile中、命令行中，或者在环境中定义。修改`print-%`以同时输出来源信息也很简单：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we see that `YS` is defined in the makefile:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到`YS`是在makefile中定义的：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we override the value of `YS` on the command line, we’ll see:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在命令行中覆盖了`YS`的值，我们将看到：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because `YS` was set on the `make` command line, its `$(origin)` is now `command
    line` and no longer `file`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`YS`是在`make`命令行中设置的，因此它的`$(origin)`现在是`command line`，而不再是`file`。
- en: Dumping Every Makefile Variable
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印每个Makefile变量
- en: The previous section showed you how to print the value of a single makefile
    variable using a special rule. But what if you want to print every variable defined
    in a makefile?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上一部分展示了如何通过特殊规则打印单个makefile变量的值。那么，如果你想打印makefile中定义的所有变量呢？
- en: Fortunately, GNU `make` 3.80 introduced a couple of new features that make it
    feasible to print the value of all the variables defined in a makefile using a
    single rule.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，GNU `make` 3.80引入了几个新功能，使得通过单个规则打印makefile中定义的所有变量的值变得可行。
- en: 'Consider [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab "Example 2-1. A
    simple makefile that sets various variables") again. It sets five variables: `X`,
    `Y`, `Z`, `S`, `YS`, and `ZS`. Adding the following lines to the example creates
    a target called `printvars` that will dump all the variables defined in the makefile,
    as shown in [Example 2-2](ch02.html#target_to_print_all_variables "Example 2-2. A
    target to print all variables").'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑[示例 2-1](ch02.html#simple_makefile_that_sets_various_variab "示例 2-1. 设置各种变量的简单makefile")。它设置了五个变量：`X`、`Y`、`Z`、`S`、`YS`和`ZS`。向示例中添加以下行会创建一个名为`printvars`的目标，该目标将打印makefile中定义的所有变量，如[示例
    2-2](ch02.html#target_to_print_all_variables "示例 2-2. 打印所有变量的目标")所示。
- en: Example 2-2. A target to print all variables
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-2. 打印所有变量的目标
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we look closely at how this works, try it out on your own, as shown in
    [Example 2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe "Example 2-3. All
    the variables from Example 2-1 dumped by printvars").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仔细查看它是如何工作的之前，像[示例 2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe
    "示例 2-3. 打印所有[示例 2-1](ch02.html#simple_makefile_that_sets_various_variab)中的变量")所示那样先自己尝试一下。
- en: Example 2-3. All the variables from [Example 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "Example 2-1. A simple makefile that sets various variables") dumped by `printvars`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-3. 使用`printvars`打印的[示例 2-1](ch02.html#simple_makefile_that_sets_various_variab
    "示例 2-1. 设置各种变量的简单makefile")中的所有变量
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how `make` has thrown in three extra variables that weren’t explicitly
    defined—`MAKEFILE_LIST`, `MAKEFLAGS`, and `SHELL`—but the rest are all defined
    in the makefile. Each line shows the name of the variable, its fully substituted
    value, and the way in which it was defined.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`make`引入了三个额外的变量，这些变量并未明确在文件中定义——`MAKEFILE_LIST`、`MAKEFLAGS`和`SHELL`——但其他变量都在makefile中定义。每一行显示了变量的名称、其完全替换的值以及定义的方式。
- en: 'It’s a lot easier to understand the long complex line used to print the variables
    when it’s reformatted like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将打印变量的长且复杂的行重新格式化后，它会变得更容易理解：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `.VARIABLES` variable is a new feature in GNU `make` 3.80: its value is
    a list of the names of all the variables defined in the makefile. First, the code
    sorts it into order: `$(sort $(.VARIABLES))`. Then it goes through the sorted
    list, variable name by variable name, and sets `V` to each name in turn: `$(foreach
    V,$(sort (.VARIABLES)),...)`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`.VARIABLES`变量是GNU `make` 3.80中的一个新特性：它的值是一个包含makefile中定义的所有变量名称的列表。首先，代码将其排序：`$(sort
    $(.VARIABLES))`。然后，它逐个变量名地遍历排序后的列表，并将`V`设置为每个名称：`$(foreach V,$(sort (.VARIABLES)),...)`。'
- en: 'For each variable name, the loop decides whether to print or ignore the variable
    depending on how it was defined. If it’s a built-in variable, like `$@` or `$(CC)`,
    or came from the environment, it shouldn’t get printed. This decision is made
    by the predicate at ➊. It first figures out how the variable referenced by `$V`
    was defined by calling `$(origin $V)`. This call returns a string describing how
    the variable was defined: `environment` for environment variables, `file` for
    variables defined in a makefile, and `default` for things the `make` defines.
    The `$(filter-out)` statement says if the result of `$(origin)` matches any of
    the patterns `environment%`, `default`, or `automatic` (`automatic` is returned
    by `$(origin)` for `make`’s automatic variable like `$@`, `$<`, and so on), then
    return an empty string; otherwise, leave it alone. This means `$(if)`’s predicate
    will be true only if the variable was defined in the makefile or set on the command
    line.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个变量名，循环会决定是否打印该变量，或者忽略它，这取决于该变量是如何定义的。如果它是内建变量，如`$@`或`$(CC)`，或者来自环境变量，它不应该被打印。这个决定由➊处的条件表达式做出。它首先通过调用`$(origin
    $V)`来确定变量`$V`是如何定义的。此调用返回一个字符串，描述了该变量的定义方式：`environment`表示环境变量，`file`表示在makefile中定义的变量，`default`表示`make`定义的内容。`$(filter-out)`语句表示，如果`$(origin)`的结果匹配任何模式`environment%`、`default`或`automatic`（对于`make`的自动变量，如`$@`、`$<`等，`$(origin)`会返回`automatic`），则返回空字符串；否则，保持原样。这意味着，`$(if)`的条件只有在变量是在makefile中定义或在命令行上设置时才为真。
- en: If `$(if)`’s predicate is true, then `$(info $V=$($V) ($(value $V)))` outputs
    a message containing the name of the variable, its fully expanded value, and its
    defined value. The `$(value)` function is another new feature in GNU `make` 3.80;
    it outputs the value of a variable without expanding it. In [Example 2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe
    "Example 2-3. All the variables from Example 2-1 dumped by printvars"), `$(YS)`
    would return the value `dogs`, but `$(value YS)` would return `$(Y)$(S)`. That
    is, `$(value YS)` shows us how `YS` is defined, not its final value. That’s a
    very useful debugging feature.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$(if)`的条件为真，那么`$(info $V=$($V) ($(value $V)))`会输出一条包含变量名、其完全展开的值以及其定义值的消息。`$(value)`函数是GNU
    `make` 3.80中的另一个新特性；它输出变量的值而不进行展开。在[示例2-3](ch02.html#all_the_variables_from_listing_2-1_dumpe
    "示例2-3. 所有从示例2-1中输出的变量")中，`$(YS)`将返回值`dogs`，但是`$(value YS)`将返回`$(Y)$(S)`。也就是说，`$(value
    YS)`展示的是`YS`的定义方式，而不是其最终值。这是一个非常有用的调试特性。
- en: Tracing Variable Values
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪变量值
- en: 'As a makefile grows, it can become difficult to figure out where a variable
    is used. This is especially true because of GNU `make`’s recursive variables:
    the use of a variable could be hidden deep inside some other variable declaration
    in the makefile. This recipe shows how to trace individual variables as they are
    used.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着makefile的增大，可能会很难找出一个变量的使用位置。尤其是因为GNU `make`的递归变量：一个变量的使用可能被隐藏在makefile中某个其他变量定义的深处。本条食谱展示了如何跟踪各个变量在使用时的情况。
- en: For this example, we’ll use the makefile in [Example 2-4](ch02.html#example_makefile_for_tracing
    "Example 2-4. Example makefile for tracing") (the lines have been numbered for
    later reference purposes).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用[示例2-4](ch02.html#example_makefile_for_tracing "示例2-4. 用于跟踪的示例makefile")中的makefile（这些行已被编号，便于后续参考）。
- en: Example 2-4. Example makefile for tracing
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-4. 用于跟踪的示例makefile
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When run, this makefile prints:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这个makefile会打印：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing"), the makefile contains a number of recursively defined
    variables and uses them in rule definitions and commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例2-4](ch02.html#example_makefile_for_tracing "示例2-4. 用于跟踪的示例makefile")所示，makefile包含了许多递归定义的变量，并且在规则定义和命令中使用了它们。
- en: Tracing Variable Use
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪变量的使用
- en: If you trace through [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing"), you’ll see that the variable `$(Y)` is used on lines 8,
    9, and 11, and twice on line 12\. It’s amazing how often variables are used! The
    reason is that `make` gets the value of a recursively expanded variable (such
    as `YS` in [Example 2-4](ch02.html#example_makefile_for_tracing "Example 2-4. Example
    makefile for tracing")) only when it is needed (that is, when the variable is
    used and hence expanded), and recursively expanded variables are frequently deeply
    nested.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟踪[示例 2-4](ch02.html#example_makefile_for_tracing "示例 2-4. 用于跟踪的示例 Makefile")，你会看到变量`$(Y)`在第8、9和11行被使用，并且在第12行出现了两次。变量使用的频率真是惊人！原因是，`make`仅在需要时（即当变量被使用并展开时）获取递归展开变量的值（比如在[示例
    2-4](ch02.html#example_makefile_for_tracing "示例 2-4. 用于跟踪的示例 Makefile")中的`YS`），而递归展开的变量通常是深度嵌套的。
- en: 'It’s annoying enough to trace a variable through the simple makefile in [Example 2-4](ch02.html#example_makefile_for_tracing
    "Example 2-4. Example makefile for tracing"), but doing so for a real makefile
    would be practically impossible. Fortunately, it’s possible to get `make` to do
    the work for you with the following code, which you should add to the start of
    the makefile to be traced (it’ll only get used when explicitly called):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪一个变量通过[示例 2-4](ch02.html#example_makefile_for_tracing "示例 2-4. 用于跟踪的示例 Makefile")中的简单
    Makefile已经够麻烦了，但要跟踪一个真实的 Makefile几乎是不可能的。幸运的是，可以通过以下代码让`make`为你完成这项工作，应该将其添加到要跟踪的
    Makefile 的开始部分（它只会在显式调用时使用）：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before we dive into how it works, here’s an example of using it to trace the
    value of `Y` in our example makefile. To use the tracer, tell `make` to run the
    `trace` target by setting the `TRACE` variable to the name of the variable you
    want to trace. Tracing the variable `Y` looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解它是如何工作的之前，先看一个例子，展示如何在我们的示例 Makefile 中跟踪`Y`的值。要使用跟踪器，只需告诉`make`运行`trace`目标，方法是将`TRACE`变量设置为你要跟踪的变量的名称。跟踪变量`Y`的方式如下：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From the `TRACE` output you can see `Y` being used first on line 8 in the definition
    of the `all` target, which references `Y` via the `$(YS)`; then on line 11 the
    definition of the `cats` target, which also uses `$(YS)`; then twice on line 12
    with the two direct references to `$(Y)`; and finally on line 9 via `$(X)`, which
    references `$(YS)`, which references `$(Y)`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从`TRACE`输出中，你可以看到`Y`首次出现在第8行的`all`目标定义中，该目标通过`$(YS)`引用了`Y`；然后在第11行，`cats`目标的定义中，也使用了`$(YS)`；接着在第12行出现两次，直接引用了`$(Y)`；最后，在第9行通过`$(X)`使用了`$(YS)`，而`$(YS)`又引用了`$(Y)`。
- en: 'Likewise, we can use the tracer to find out where `$(S)` is used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用这个跟踪器来查找`$(S)`被使用的位置：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output shows that `S` is first used twice on line 8 (the `all` target used
    `XS` and `YS`, which both use `S`). Then `S` appears again on line 4 (because
    `YS` is used) and line 12 (because `XS` is used). Finally, `S` is used twice on
    line 9, when `X` is echoed as `X` is used by `XS` and `YS`, which both use `S`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，`S`首先在第8行使用了两次（`all`目标使用了`XS`和`YS`，这两者都使用了`S`）。然后，`S`再次出现在第4行（因为使用了`YS`）和第12行（因为使用了`XS`）。最后，`S`在第9行被使用了两次，当`X`被回显时，因为`X`被`XS`和`YS`使用，这两者都使用了`S`。
- en: How the Variable Tracer Works
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量跟踪器的工作原理
- en: GNU `make` has a special `$(warning)` function that outputs a warning message
    to `STDERR` and returns the empty string. At a high level, our tracer code changes
    the value of the variable to be traced to include a `$(warning)` message. Every
    time the variable is expanded, the warning is printed, and whenever `make` outputs
    a warning message, it prints the name of the makefile in use and the line number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make`有一个特殊的`$(warning)`函数，可以将警告信息输出到`STDERR`并返回空字符串。从高级别来看，我们的跟踪代码将要跟踪的变量的值更改为包含一个`$(warning)`消息。每次变量展开时，警告都会被打印，而每当`make`输出警告信息时，它会打印使用中的
    Makefile 名称和行号。
- en: For example, say the definition of `Y` is changed from
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`Y`的定义从
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: to
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, whenever `$(Y)` is expanded, a warning would be generated, and `$(Y)`
    would have the value `dog`. And because `$(warning)` doesn’t return any value,
    the value of `Y` is unaffected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当`$(Y)`被展开时，就会生成一个警告，并且`$(Y)`的值会是`dog`。由于`$(warning)`不返回任何值，因此`Y`的值不受影响。
- en: To add this `$(warning)` call, the tracer code first obtains the unexpanded
    value of the variable to be traced, then prepends it with an appropriate `$(warning)`,
    and finally runs the desired `make` with the specially modified value of the variable
    being examined. It uses the `$(value)` function, which as you saw in [Example 2-2](ch02.html#target_to_print_all_variables
    "Example 2-2. A target to print all variables") enables you to get the unexpanded
    value of a variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这个`$(warning)`调用，跟踪器代码首先获取要跟踪的变量的未扩展值，然后将其与适当的`$(warning)`一起预先处理，最后使用经过特殊修改的变量值运行所需的`make`。它使用`$(value)`函数，正如你在[示例
    2-2](ch02.html#target_to_print_all_variables "示例 2-2. 打印所有变量的目标")中看到的那样，`$(value)`可以让你获取变量的未扩展值。
- en: 'Here’s how the tracer works in detail. If `TRACE` is defined, `make` will process
    the block of tracer definitions. In that case, because `_trace` is the first target
    encountered, it will be the rule that runs by default. The `_trace` rule contains
    a single, complex command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是跟踪器如何工作的详细说明。如果`TRACE`已定义，`make`将处理跟踪器定义的代码块。在这种情况下，由于`_trace`是第一个遇到的目标，它将是默认运行的规则。`_trace`规则包含一个单一且复杂的命令：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the right side of the command is a `$(shell)` invocation that reruns the
    makefile with a different goal. If we are tracing `YS`, for example, this `$(shell)`
    runs the command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的右侧是一个`$(shell)`调用，它会使用不同的目标重新运行makefile。例如，如果我们在跟踪`YS`，这个`$(shell)`调用会执行以下命令：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will run the `_value` rule, which is defined like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行`_value`规则，定义如下：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because `TRACE` has been set to `YS`, this rule simply echoes the definition
    of `YS`, which is the literal string `$(Y)$(S)`. So that’s what `$(shell)` ends
    up evaluating to.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`TRACE`已被设置为`YS`，所以这个规则只是回显`YS`的定义，即字面量字符串`$(Y)$(S)`。因此，`$(shell)`最终会评估为这个值。
- en: 'That `$(shell)` call is in fact inside a command line variable definition (usually
    called a *command line override*):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`$(shell)`调用实际上是在一个命令行变量定义中（通常称为*命令行覆盖*）：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This adds the `$(warning)` needed to output the `TRACE X` messages. Notice
    how the name of the variable being defined is a computed value: its name is contained
    in `$(TRACE)`. When tracing `YS`, this definition turns into:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了`$(warning)`，用于输出`TRACE X`消息。请注意，定义的变量名是一个计算值：它的名称包含在`$(TRACE)`中。当跟踪`YS`时，这个定义变成了：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The single quotes are used to prevent the shell from seeing the `$` sign. The
    double `$` is used to prevent `make` from seeing the `$`. In either case a variable
    expansion would occur (either in `make` or by the shell), and we want to delay
    any variable expansion until `YS` is actually used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号用于防止shell看到`$`符号。双`$$`用于防止`make`看到`$`。在这两种情况下，都会发生变量扩展（无论是在`make`中还是由shell进行），我们希望延迟任何变量扩展，直到`YS`实际使用时。
- en: 'Finally, the `_trace` rule recursively runs `make`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`_trace`规则会递归地运行`make`：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The value of `TRACE` is reset to the empty string, because this recursive invocation
    of `make` should run the real rules rather than the tracer rules. Also, it overrides
    the value of `YS`. Recall that variables defined on the command line override
    definitions in the makefile: even though `YS` is defined in the makefile, the
    `warning`-enabled, command line definition is the one that’s used. Now, every
    time `YS` is expanded, a warning is printed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TRACE`的值被重置为空字符串，因为这个递归调用的`make`应该运行真实的规则，而不是跟踪规则。此外，它覆盖了`YS`的值。回想一下，命令行上定义的变量会覆盖makefile中的定义：即使`YS`在makefile中有定义，带有`warning`的命令行定义才是被使用的。现在，每次扩展`YS`时，都会打印一个警告。'
- en: 'Note that this technique doesn’t work for a variable that is target specific.
    `make` allows you to define a variable as specific to a target in the manner shown
    in [Example 2-5](ch02.html#defining_a_target-specific_variable "Example 2-5. Defining
    a target-specific variable"):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种技术不适用于目标特定的变量。`make`允许你按[示例 2-5](ch02.html#defining_a_target-specific_variable
    "示例 2-5. 定义目标特定变量")的方式定义一个目标特定的变量：
- en: Example 2-5. Defining a target-specific variable
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5. 定义目标特定变量
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The variable `FOO` will have the value `foo` in the rule that builds `all` and
    in any prerequisites of `all`. The makefile in [Example 2-5](ch02.html#defining_a_target-specific_variable
    "Example 2-5. Defining a target-specific variable") will print `foo` twice, because
    `FOO` is defined in both the `all` and `a` rules. The tracer is unable to obtain
    the value of `FOO` and would in fact cause this makefile to behave incorrectly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`FOO`将在构建`all`规则和`all`的任何前提条件中具有值`foo`。在[示例2-5](ch02.html#defining_a_target-specific_variable
    "示例2-5. 定义目标特定变量")中的makefile会打印`foo`两次，因为`FOO`在`all`和`a`规则中都被定义。跟踪器无法获取`FOO`的值，实际上会导致该makefile行为不正确。
- en: 'The tracer works by redefining the variable being traced as described earlier.
    Because this happens outside a rule definition, the tracer has no way of obtaining
    the value of a variable that is target specific. For example, in [Example 2-5](ch02.html#defining_a_target-specific_variable
    "Example 2-5. Defining a target-specific variable"), `FOO` is defined only when
    running the `all` or `a` rules. The tracer has no way of obtaining its value.
    Using the tracer on that makefile to trace `FOO` results in the wrong behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪器的工作原理是通过重新定义被跟踪的变量，如前所述。由于这发生在规则定义之外，跟踪器无法获取目标特定变量的值。例如，在[示例2-5](ch02.html#defining_a_target-specific_variable
    "示例2-5. 定义目标特定变量")中，`FOO`仅在运行`all`或`a`规则时定义。跟踪器无法获取其值。在该makefile上使用跟踪器跟踪`FOO`会导致错误的行为：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That should have output `foo` twice (once for the `all` rule and once for `a`),
    but the tracer has redefined `FOO` and messed up its value. Don’t use this tracer
    for target-specific variables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出`foo`两次（一次是`all`规则，一次是`a`规则），但跟踪器已经重新定义了`FOO`并搞乱了它的值。不要将这个跟踪器用于目标特定变量。
- en: 'The `$(warning)` function sends its output to `STDERR`, which makes it possible
    to separate normal `make` output from the tracer. Simply redirect `STDERR` to
    a trace log file. Here’s an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(warning)`函数将其输出发送到`STDERR`，这使得可以将正常的`make`输出与跟踪输出分开。只需将`STDERR`重定向到跟踪日志文件。以下是一个示例：'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command will write normal `make` output to the command line while redirecting
    the trace output to *trace.log*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将把正常的`make`输出写到命令行，同时将跟踪输出重定向到*trace.log*。
- en: Tracing Rule Execution
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪规则执行
- en: Until GNU `make` 4.0, there was no built-in way to trace the order of execution
    of makefile targets. GNU `make` 4.0 added the `--trace` option, which I cover
    in [GNU make 4.0 Tracing](ch02.html#gnu_make_4dot0_tracing "GNU make 4.0 Tracing"),
    but if you need to use an earlier version of `make`, it’s handy to have another
    way to trace a makefile. The techniques shown here work with GNU `make` 4.0 and
    earlier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU `make` 4.0之前，没有内建的方式来跟踪makefile目标的执行顺序。GNU `make` 4.0增加了`--trace`选项，我在[GNU
    make 4.0 跟踪](ch02.html#gnu_make_4dot0_tracing "GNU make 4.0 跟踪")中有详细讲解，但如果你需要使用更早版本的`make`，有其他方法来跟踪makefile是很有用的。这里展示的技术适用于GNU
    `make` 4.0及更早版本。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’ve ever stared at a cryptic log output and asked yourself, “What rule
    caused that output?” or “Where’s the output for the `foo` rule?” then this section
    is for you. And to be honest, who hasn’t wondered what GNU `make`’s log file output
    means?*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你曾经盯着一份晦涩的日志输出，心里想：“是什么规则导致了这个输出？”或者“`foo`规则的输出在哪里？”那么这一节正是为你准备的。说实话，谁没有好奇过GNU
    `make`的日志文件输出意味着什么呢？*'
- en: An Example
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'This section uses the following example makefile:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用以下示例makefile：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It builds two files: `foo.o` and `bar`. We’ll assume that `foo.c` exists so
    that `make`’s built-in rules create `foo.o`; whereas `bar` is a simple rule that
    just touches `$@`. If you run `make` for the first time with this makefile, you’d
    see the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它构建了两个文件：`foo.o`和`bar`。我们假设`foo.c`存在，这样`make`的内建规则就会创建`foo.o`；而`bar`是一个简单的规则，只是触碰`$@`。如果你第一次运行这个makefile的`make`，你会看到以下输出：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This log output is rather cryptic. There’s no sign of the rule for `bar` being
    run (because `touch $@` was hidden using the `@` modifier, which prevents the
    command from being printed). And there’s no indication that it was the rule for
    `foo.o` that generated the `cc` compilation line. Nor is there any indication
    that the `all` rule was used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该日志输出相当晦涩。没有看到`bar`的规则被执行的迹象（因为`touch $@`使用了`@`修饰符，这会阻止命令被打印）。也没有迹象表明是`foo.o`的规则生成了`cc`编译行。同样也没有显示`all`规则被使用的迹象。
- en: 'You could, of course, use `make -n` (which just prints the commands to be run
    without actually executing them) to look at the work that GNU `make` would perform:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用`make -n`（它只会打印要执行的命令，而不会实际执行它们）来查看GNU `make`将会执行的工作：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case it’s practical, but in general `make -n`’s output can be just as
    cryptic as a normal log file, and it doesn’t provide any way of matching lines
    in the log with lines in the makefile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下它是实用的，但通常 `make -n` 的输出可能像普通的日志文件一样晦涩，而且它没有提供将日志文件中的行与 makefile 中的行匹配的方法。
- en: The SHELL Hack
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SHELL 黑客
- en: One simple way to enhance the output of GNU `make` is to redefine `SHELL`, which
    is a built-in variable that contains the name of the shell to use when `make`
    executes commands. Most shells have an `-x` option that causes them to print each
    command they are about to execute; therefore, if you modify `SHELL` in a makefile
    by appending `-x`, it will cause every command to be printed as the makefile is
    run.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 增强 GNU `make` 输出的一种简单方法是重新定义 `SHELL`，这是一个内置变量，包含 `make` 执行命令时要使用的 shell 的名称。大多数
    shell 都有一个 `-x` 选项，可以使它们打印出每个即将执行的命令；因此，如果你通过在 makefile 中附加 `-x` 来修改 `SHELL`，它会导致每个命令在
    makefile 执行时都被打印出来。
- en: 'Here’s the example makefile modified using GNU `make`’s `+=` operator to append
    `-x` to `SHELL`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 GNU `make` 的 `+=` 操作符修改过的 makefile 示例，该操作符将 `-x` 附加到 `SHELL`：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In some shells this may not work (the shell may expect a single word of options).
    In GNU `make` 4.0 and later, a variable called `.SHELLFLAGS` contains the flags
    for the shell and can be set to avoid this problem instead of altering `SHELL`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 shell 中，这可能不起作用（shell 可能期望接收单个选项单词）。在 GNU `make` 4.0 及更高版本中，一个名为 `.SHELLFLAGS`
    的变量包含了 shell 的标志，并可以被设置来避免这个问题，而不需要修改 `SHELL`。
- en: 'Now the makefile output reveals that `touch bar` was generated by the rule
    for `bar`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，makefile 输出显示 `touch bar` 是由 `bar` 规则生成的：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `SHELL` technique has one disadvantage: it slows `make` down. If `SHELL`
    is left untouched, `make` will often avoid using the shell altogether if it knows
    it can execute the command directly—for simple operations like compilation and
    linking, for example. But once `SHELL` is redefined in a makefile, `make` will
    always use the shell, thus slowing it down.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHELL` 技术有一个缺点：它会使 `make` 变慢。如果 `SHELL` 保持不变，`make` 通常会避免使用 shell，前提是它知道可以直接执行命令——例如，对于简单的操作如编译和链接。但一旦在
    makefile 中重新定义了 `SHELL`，`make` 就会始终使用 shell，从而导致变慢。'
- en: 'Of course, that doesn’t make this a bad debugging trick: getting additional
    information for a brief slowdown is a very small price to pay. But redefining
    `SHELL` doesn’t help track the relationship between the lines in a log file and
    the makefile. Fortunately, this is possible to do with an even smarter redefinition
    of `SHELL`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着这是一个糟糕的调试技巧：为了短暂的速度下降，获得额外的信息是一个非常小的代价。但是重新定义 `SHELL` 并不能帮助追踪日志文件中的行与
    makefile 中的行之间的关系。幸运的是，通过更聪明地重新定义 `SHELL`，这是可以做到的。
- en: An Even Smarter SHELL Hack
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更聪明的 SHELL 黑客
- en: If `SHELL` has been redefined, `make` will expand its value before it runs each
    line of each rule. This means that if the expansion of `SHELL` were to output
    information, it would be possible to print information before each rule runs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `SHELL` 已被重新定义，`make` 会在执行每条规则的每一行之前扩展它的值。这意味着，如果 `SHELL` 的扩展输出信息，就可以在每条规则执行之前打印出信息。
- en: 'As you saw in [Tracing Variable Values](ch02.html#tracing_variable_values "Tracing
    Variable Values"), the `$(warning)` function helpfully outputs a string of your
    choosing, along with the name of the makefile and the line number at which the
    `$(warning)` was written. By adding a `$(warning)` call to `SHELL`, it’s possible
    to print detailed information every time `SHELL` gets expanded. The following
    code snippet does just this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[追踪变量值](ch02.html#tracing_variable_values "追踪变量值")中看到的，`$(warning)` 函数会帮助输出你选择的字符串，并附上
    makefile 的名称和 `$(warning)` 所在行的行号。通过将 `$(warning)` 调用添加到 `SHELL` 中，每次 `SHELL`
    扩展时都可以打印详细信息。以下代码片段就实现了这一点：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line captures the normal value of `SHELL` in a variable called `OLD_SHELL`.
    Notice the use of `:=` to get `SHELL`’s final value, not its definition. The second
    line defines `SHELL` to include the old shell value and a `$(warning)` that will
    print the name of the target being built.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `SHELL` 的正常值捕获到一个名为 `OLD_SHELL` 的变量中。注意使用 `:=` 来获取 `SHELL` 的最终值，而不是它的定义。第二行定义了
    `SHELL`，使其包括旧的 shell 值和一个会打印正在构建的目标名称的 `$(warning)`。
- en: 'Running GNU `make` now produces very useful information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 GNU `make` 会输出非常有用的信息：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line of output is produced when the built-in pattern rule to build
    `foo.o` is about to be executed. Because no makefile or line number information
    gets printed, we know that a built-in rule was used here. Then you see the actual
    output of the built-in rule (the `cc` command). This is followed by another piece
    of output from the `$(warning)`, stating that `bar` is about to be built using
    the rule in the makefile at line 7.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行是在即将执行内建模式规则以生成`foo.o`时产生的。由于没有打印makefile或行号信息，我们知道这里使用了内建规则。然后，你会看到内建规则的实际输出（即`cc`命令）。接着是另一条来自`$(warning)`的输出，表明`bar`即将使用makefile中第7行的规则进行构建。
- en: We used `$@` in the `$(warning)` statement that we added to `SHELL`, but there’s
    nothing stopping us from using other automatic variables. For example, in [Example 2-6](ch02.html#using_the_shell_hack
    "Example 2-6. Using the SHELL hack"), we use `$<`, which holds the first prerequisite
    from which the target is being built, and `$?`, which holds the list of prerequisites
    that are newer than the target and tells us why the target is being built.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在添加到`SHELL`中的`$(warning)`语句中使用了`$@`，但没有什么能阻止我们使用其他自动变量。例如，在[示例2-6](ch02.html#using_the_shell_hack
    "示例2-6. 使用SHELL技巧")中，我们使用了`$<`，它保存了构建目标的第一个前提条件，和`$?`，它保存了比目标更新的前提条件列表，并告诉我们为什么要构建该目标。
- en: Example 2-6. Using the `SHELL` hack
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-6. 使用`SHELL`技巧
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here `SHELL` has been redefined to output three pieces of information: the
    name of the target being built (`$@`), the name of the first prerequisite (`$<`,
    which is wrapped in a `$(if)` so that nothing is printed if there is no prerequisite),
    and the names of any newer prerequisites (`$?`).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`SHELL`被重新定义为输出三条信息：正在构建的目标的名称（`$@`），第一个前提条件的名称（`$<`，它被包裹在`$(if)`中，以便在没有前提条件时不打印任何内容），以及任何更新的前提条件的名称（`$?`）。
- en: 'Deleting `foo.o` and running `make` on this makefile now shows that `foo.o`
    was built from `foo.c` because `foo.c` was newer than `foo.o` (because it was
    missing):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`foo.o`并在这个makefile上运行`make`，现在显示`foo.o`是从`foo.c`构建的，因为`foo.c`比`foo.o`更新（因为`foo.o`缺失了）：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There’s nothing to stop us from combining this `$(warning)` trick with `-x`
    to get output showing which rules ran and what commands were executed, as shown
    in [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn "Example 2-7. Combining
    the $(warning) trick with -x").
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止我们将这个`$(warning)`技巧与`-x`结合使用，以显示哪些规则被执行了以及执行了哪些命令，如[示例2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "示例2-7. 将$(warning)技巧与-x结合")中所示。
- en: Example 2-7. Combining the $(`warning`) trick with `-x`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-7. 将$(`warning`)技巧与`-x`结合
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here’s the full output of the makefile in [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "Example 2-7. Combining the $(warning) trick with -x").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是[示例2-7](ch02.html#combining_the_dollarleft_parenthesiswarn "示例2-7. 将$(warning)技巧与-x结合")中makefile的完整输出。
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This assumes that `foo.c` was newer than `foo.o` (or `foo.o` was missing) when
    `make` was run.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设在运行`make`时，`foo.c`比`foo.o`更新（或者`foo.o`缺失）。
- en: GNU make 4.0 Tracing
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU `make` 4.0 跟踪
- en: 'GNU `make` 4.0 added a `--trace` command line option that you can use to trace
    rule execution. It provides output similar to that of [Example 2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "Example 2-7. Combining the $(warning) trick with -x"). Here’s what happens when
    [Example 2-6](ch02.html#using_the_shell_hack "Example 2-6. Using the SHELL hack"),
    minus the `SHELL` modifications, is traced using GNU `make` 4.0:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 4.0增加了一个`--trace`命令行选项，可以用来跟踪规则执行。它提供的输出类似于[示例2-7](ch02.html#combining_the_dollarleft_parenthesiswarn
    "示例2-7. 将$(warning)技巧与-x结合")。下面是[示例2-6](ch02.html#using_the_shell_hack "示例2-6.
    使用SHELL技巧")，去掉`SHELL`修改后的跟踪输出，使用GNU `make` 4.0时的结果：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When called with the `--trace` option, GNU `make` 4.0 overrides the `@` modifier
    (used in the earlier example to suppress `touch bar`) in the same way that the
    `-n` and `--just-print` flags do.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`--trace`选项调用时，GNU `make` 4.0会覆盖`@`修饰符（在前面的示例中用于抑制`touch bar`），就像`-n`和`--just-print`标志一样。
- en: Makefile Assertions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile断言
- en: 'Most programming languages have assertions: statements that do nothing if the
    value they assert is true but cause a fatal error if not. They’re commonly used
    as a runtime debugging aid to catch very odd situations. A typical assert in C
    might look like `assert( foo != bar )` and would result in a fatal error if `foo`
    and `bar` are the same.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有断言：当它们断言的值为真时不会执行任何操作，但如果不为真则会导致致命错误。它们通常作为运行时调试辅助工具，用于捕捉非常特殊的情况。C语言中的典型断言可能看起来像`assert(
    foo != bar )`，如果`foo`和`bar`相同，则会导致致命错误。
- en: Unfortunately, GNU `make` does not have any form of built-in assertions. But
    they are easy to create from existing functions, and there are even convenient
    assertion functions defined in the GNU Make Standard Library (GMSL).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GNU `make`没有任何内置的断言功能。但它们很容易通过现有的函数来创建，甚至在GNU Make标准库（GMSL）中定义了方便的断言函数。
- en: 'The GMSL project (which is covered in [Chapter 6](ch06.html "Chapter 6. The
    GNU Make Standard Library")) provides two assertion functions: `assert` and `assert_exists`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL项目（在[第6章](ch06.html "第6章. GNU Make标准库")中有介绍）提供了两个断言函数：`assert`和`assert_exists`。
- en: assert
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assert
- en: 'The `assert` function will output a fatal error if its first argument is false.
    As with `make`’s `$(if)` function, GMSL treats any non-empty string as true and
    an empty string as false. Thus, if `assert`’s argument is an empty string, the
    assertion will cause a fatal error; the second argument to `assert` will be printed
    as part of the error. For example, this makefile breaks immediately because `$(FOO)`
    and `$(BAR)` are the same:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`assert`的第一个参数为false，它将输出一个致命错误。与`make`的`$(if)`函数一样，GMSL将任何非空字符串视为true，空字符串视为false。因此，如果`assert`的参数是空字符串，断言将导致致命错误；`assert`的第二个参数将作为错误的一部分被打印出来。例如，这个makefile会立刻中断，因为`$(FOO)`和`$(BAR)`相同：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because `assert` is not a built-in function—it’s user defined in the GMSL makefile—we
    must use `$(call)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`assert`不是一个内置函数——它是在GMSL的makefile中用户定义的——所以我们必须使用`$(call)`。
- en: 'We get the message:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下信息：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The assertion uses another GMSL function, `sne`, which compares two strings
    and returns true if they are not equal or false otherwise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 断言使用了另一个GMSL函数，`sne`，它比较两个字符串，如果它们不相等则返回true，否则返回false。
- en: 'Because true simply means *not an empty string*, it’s easy to assert that a
    variable be defined:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为true仅意味着*非空字符串*，所以很容易断言一个变量已定义：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can use this assertion, for example, to check that a user has set all necessary
    command line variables; if `FOO` is required for the makefile to run properly
    but the user forgot to set it on the command line, the assertion will cause an
    error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个断言，例如检查用户是否设置了所有必要的命令行变量；如果`FOO`是makefile正确运行所必需的，而用户忘记在命令行中设置它，断言将会导致错误。
- en: 'You can even use assertions to enforce that certain command line flags are
    not used. Here’s an example that prevents the user from setting `-i`, the ignore
    errors flag:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用断言来强制某些命令行标志不被使用。这里有一个例子，防止用户设置`-i`，即忽略错误标志：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This example is more complex than the previous two because `make` can store
    the `-i` flag in `MAKEFLAGS` in two ways: as a flag in the familiar form `-i`
    or as a block of single characters in the first word of `MAKEFLAGS`. That is,
    setting the command line flags `-i -k` results in `MAKEFLAGS` having the value
    `ki`. So the first `assert` in the loop looks for `-i`, and the second `assert`
    searches for `i` in the first word of `MAKEFLAGS`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子比前两个更复杂，因为`make`可以以两种方式将`-i`标志存储在`MAKEFLAGS`中：作为常见形式的`-i`标志，或作为`MAKEFLAGS`中第一个单词的字符块。也就是说，设置命令行标志`-i
    -k`会导致`MAKEFLAGS`的值为`ki`。所以循环中的第一个`assert`查找`-i`，第二个`assert`则在`MAKEFLAGS`的第一个单词中查找`i`。
- en: assert_exists
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assert_exists
- en: 'Because the success of a build relies on having all necessary files present,
    the GMSL provides an assertion specifically designed to warn if a file is missing.
    The `assert_exists` function has a single argument: the name of the file that
    must exist. For example, to check that the file *foo.txt* exists before any commands
    are run by the makefile, you can add an assertion at the start:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构建的成功依赖于所有必要文件的存在，GMSL提供了一个专门设计的断言，用于在文件缺失时发出警告。`assert_exists`函数有一个参数：必须存在的文件名。例如，为了在makefile运行任何命令之前检查文件*foo.txt*是否存在，你可以在开头添加一个断言：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the file does not exist, the build stops:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，构建将停止：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The assertion stopped the build and the line on which the assertion is found
    in the makefile—in this case, 3—is shown.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 断言停止了构建，并且在makefile中显示了断言所在的行号——在本例中是第3行。
- en: assert_target_directory
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assert_target_directory
- en: A common problem in building real-world makefiles is that you must construct
    directory hierarchies during or before the build. You can ensure that every directory
    exists before each rule runs by creating a special `assert_target_directory` variable,
    as shown in [Example 2-8](ch02.html#creating_an_assertunderscoretargetunders "Example 2-8. Creating
    an assert_target_directory variable").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建实际项目中的 makefile 时，一个常见问题是你必须在构建过程中或之前创建目录层次结构。你可以通过创建一个特殊的 `assert_target_directory`
    变量，确保在每个规则执行之前每个目录都已存在，正如 [示例 2-8](ch02.html#creating_an_assertunderscoretargetunders
    "示例 2-8. 创建 assert_target_directory 变量") 所示。
- en: Example 2-8. Creating an `assert_target_directory` variable
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-8. 创建 `assert_target_directory` 变量
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By inserting `$(call assert_target_directory)` at the start of each rule or
    pattern rule’s recipe, `make` automatically checks that the directory in which
    the target is to be written exists. For example, if *foo/* does not exist, the
    makefile in [Example 2-8](ch02.html#creating_an_assertunderscoretargetunders "Example 2-8. Creating
    an assert_target_directory variable") results in the following error:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个规则或模式规则的配方开始处插入 `$(call assert_target_directory)`，`make` 会自动检查目标文件将被写入的目录是否存在。例如，如果
    *foo/* 不存在，那么 [示例 2-8](ch02.html#creating_an_assertunderscoretargetunders "示例
    2-8. 创建 assert_target_directory 变量") 中的 makefile 会出现以下错误：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The error gives the name of the makefile and the line number at which the problem
    occurred, making it trivial to find the problem.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息会给出出错的 makefile 名称和出错的行号，方便迅速找到问题所在。
- en: 'For a final trick, it’s possible to use a two-line modification to cause the
    makefile to check every rule for a missing directory. Instead of adding `$(call
    assert_target_directory)` to every rule, just redefine the `SHELL` variable to
    include `$(call assert_target_directory)`. This does slow performance but can
    be useful in tracking down a missing directory somewhere deep in nested makefiles:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个技巧是，可以通过两行修改使 makefile 在检查每个规则时检查缺失的目录。与其在每个规则中添加 `$(call assert_target_directory)`，不如重新定义
    `SHELL` 变量，使其包含 `$(call assert_target_directory)`。这样做会稍微影响性能，但对于追踪某个深层嵌套 makefile
    中缺失的目录非常有用：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`make` expands the value of `SHELL` and hence performs a call to `assert_target_directory`
    for every rule that is run. This simple change means that every rule checks that
    the target directory exists.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 扩展 `SHELL` 的值，从而对每个执行的规则都调用 `assert_target_directory`。这一简单的修改意味着每个规则都会检查目标目录是否存在。'
- en: 'The new value of `SHELL` consists of a call to `assert_target_directory`, which
    always returns an empty string, followed by the old value of `SHELL`, which had
    been stored in `OLD_SHELL`. Note how `OLD_SHELL` is defined using `:=` so that
    `SHELL` doesn’t refer to itself—`OLD_SHELL` contains the value of `SHELL` at runtime
    and can be safely used to redefine `SHELL`. If `OLD_SHELL` were defined using
    `=`, `make` would fail to run because of a circular reference: `SHELL` would refer
    to `OLD_SHELL`, which in turn would refer to `SHELL`, and so on.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `SHELL` 值包括对 `assert_target_directory` 的调用，该函数始终返回空字符串，后面跟着存储在 `OLD_SHELL`
    中的旧 `SHELL` 值。注意 `OLD_SHELL` 是使用 `:=` 定义的，以确保 `SHELL` 不会引用自身——`OLD_SHELL` 包含 `SHELL`
    在运行时的值，可以安全地用来重新定义 `SHELL`。如果 `OLD_SHELL` 使用 `=` 定义，`make` 会因为循环引用而失败：`SHELL`
    会引用 `OLD_SHELL`，而 `OLD_SHELL` 又会引用 `SHELL`，如此反复。
- en: The `assert_target_directory` function works by calling the built-in `$(wildcard)`
    function with the name of the directory where the current target being built should
    be written. The `$(wildcard)` function simply checks to see whether the directory
    exists and returns the name of the directory if so or the empty string if the
    directory is missing. The target is defined by the automatic variable `$@`, and
    the directory portion is extracted with `$(dir)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_target_directory` 函数通过调用内建的 `$(wildcard)` 函数，并传入当前目标应写入的目录名来工作。`$(wildcard)`
    函数简单地检查目录是否存在，如果存在，则返回目录名；如果目录缺失，则返回空字符串。目标由自动变量 `$@` 定义，目录部分则通过 `$(dir)` 提取。'
- en: An Interactive GNU make Debugger
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个交互式 GNU make 调试器
- en: Despite GNU `make`’s popularity, debugging facilities are few and far between.
    GNU `make` has a `-d` option that outputs extensive (but not necessarily useful)
    debugging information about a build, and a `-p` option that prints GNU `make`’s
    internal database of rules and variables. This section shows how to build an interactive
    debugger for GNU `make` using only GNU `make`’s internal functions and the shell
    `read` command.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 GNU `make` 很受欢迎，但调试功能少之又少。GNU `make` 有一个 `-d` 选项，能够输出关于构建的广泛调试信息（但不一定有用），还有一个
    `-p` 选项，会打印出 GNU `make` 的内部规则和变量数据库。本节展示了如何仅使用 GNU `make` 的内部函数和 shell `read`
    命令来构建一个交互式调试器。
- en: The debugger has breakpoints, dumps information about the rule at which a breakpoint
    is hit, and allows interactive querying of variable values and definitions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器有断点功能，能够在断点被触发时输出有关规则的信息，并允许交互式查询变量值和定义。
- en: The Debugger in Action
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器实战
- en: Before you see how the debugger works, let’s look at how to use it. The debugger
    and these examples all assume that you are using GNU `make` 3.80 or later. [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") shows an
    example makefile that builds `all` from the prerequisites `foo` and `bar`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在你了解调试器如何工作之前，先来看一下如何使用它。调试器和这些示例都假设你正在使用 GNU `make` 3.80 或更高版本。[示例 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") 展示了一个示例 makefile，它从先决条件
    `foo` 和 `bar` 构建 `all`。
- en: Example 2-9. Setting a breakpoint using the `__BREAKPOINT` variable
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-9. 使用 `__BREAKPOINT` 变量设置断点
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To illustrate the use of the debugger, a breakpoint is set in the `all` rule
    by inserting a line at the start of the rule’s recipe that consists of just the
    variable `__BREAKPOINT`. `$(__BREAKPOINT)` gets expanded when the rule runs, causing
    the debugger to break execution and prompt when the `all` rule is about to run,
    as shown in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor "Example 2-9. Setting
    a breakpoint using the __BREAKPOINT variable").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用调试器，断点被设置在 `all` 规则中，通过在规则的配方开始处插入一行仅包含变量 `__BREAKPOINT`。当规则执行时，`$(__BREAKPOINT)`
    会展开，导致调试器中断执行，并在 `all` 规则即将运行时提示，如 [示例 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") 所示。
- en: 'Here’s what happens when this makefile is executed with no existing files called
    `all`, `foo`, or `bar`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个 makefile 且没有名为 `all`、`foo` 或 `bar` 的文件时，会发生以下情况：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, you see the output from the execution of the rules for `foo` and `bar`
    (the `Building foo` and `Building bar` lines), and then there’s a break into the
    debugger. The debugger break shows the line at which the break occurred and in
    which makefile. In this case, the breakpoint occurred at line 51 of the makefile.
    (It’s line 51 because what’s not shown in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") is all the
    actual GNU `make` variables that make the debugger work.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会看到执行 `foo` 和 `bar` 规则时的输出（即 `Building foo` 和 `Building bar` 行），接着进入调试器。调试器的断点会显示触发断点的行和所在的
    makefile。在这个例子中，断点发生在 makefile 的第 51 行。（它是第 51 行，因为在 [示例 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") 中没有显示的是所有实际使调试器工作的
    GNU `make` 变量。）
- en: 'The debugger also outputs information about the rule being built. Here you
    can see that `all` is built from `foo` and `bar` and that the first prerequisite
    is `foo`. That’s important because it’s the first prerequisite that is stored
    in GNU `make`’s `$<` automatic variable. (`$<` is typically used as the source
    code filename for compilation.) The debugger also shows why the `all` rule ran:
    `foo` and `bar` are both newer than `all` (because they were both just built by
    their respective rules).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器还会输出正在构建的规则的信息。在这里，你可以看到 `all` 是从 `foo` 和 `bar` 构建的，第一个先决条件是 `foo`。这一点很重要，因为第一个先决条件会存储在
    GNU `make` 的 `$<` 自动变量中。（`$<` 通常作为编译时的源代码文件名使用。）调试器还会显示为什么 `all` 规则会运行：因为 `foo`
    和 `bar` 都比 `all` 更新（因为它们刚刚由各自的规则构建）。
- en: 'Finally, the debugger prompts `1>` for a command. The debugger will accept
    32 commands before automatically continuing execution of the makefile. The number
    `1` indicates that this is the first command; once `32>` is reached, the debugger
    will continue automatically. The first thing to do is ask for help by typing `h`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调试器会提示 `1>` 输入命令。在自动继续执行 makefile 之前，调试器会接受 32 个命令。数字 `1` 表示这是第一个命令；一旦达到
    `32>`，调试器会自动继续执行。首先，你可以通过输入 `h` 来请求帮助：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The debugger provides two means of stopping debugging: typing `c` continues
    with normal execution of the makefile; typing `q` quits `make`. The three debugger
    commands `v`, `o`, and `d` allow the user to interrogate GNU `make` variables
    by asking for the value of a variable, its origin (where it was defined), or its
    definition. For example, the makefile in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "Example 2-9. Setting a breakpoint using the __BREAKPOINT variable") contains
    two variables—`MYVAR1` and `MYVAR2`—and a variable that is specific to the `all`
    rule: `MYVAR3`. A first step is to ask the debugger for the values of each of
    these variables:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器提供了两种停止调试的方法：输入 `c` 会继续正常执行 makefile；输入 `q` 会退出 `make`。三个调试器命令 `v`、`o` 和
    `d` 允许用户通过询问变量的值、来源（它是在哪里定义的）或定义来查询 GNU `make` 变量。例如，在 [示例 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "示例 2-9. 使用 __BREAKPOINT 变量设置断点") 中，makefile 包含两个变量——`MYVAR1` 和 `MYVAR2`——以及一个特定于
    `all` 规则的变量：`MYVAR3`。第一步是向调试器询问这些变量的值：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If it wasn’t clear how `MYVAR3` got its value, you could ask the debugger for
    its definition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不清楚 `MYVAR3` 是如何获得其值的，你可以向调试器询问它的定义：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This shows that `MYVAR3` is defined as `$(MYVAR2)`. And so the obvious next
    step is to find out how `MYVAR2` is defined (and also `MYVAR1`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 `MYVAR3` 被定义为 `$(MYVAR2)`。接下来的显而易见的步骤是找出 `MYVAR2` 是如何定义的（以及 `MYVAR1`）：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And if it wasn’t clear where `MYVAR1` got its value, the `o` command will show
    its origin:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不清楚 `MYVAR1` 的值是如何获得的，`o` 命令将显示它的来源：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This means that `MYVAR1` is defined in a makefile. In contrast:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `MYVAR1` 在一个 makefile 中被定义。相比之下：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the user has overridden the value of `MYVAR1` on the command line (by running,
    say, `make MYVAR1=Hello`), the `o` command reflects that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在命令行上覆盖了 `MYVAR1` 的值（例如，运行 `make MYVAR1=Hello`），则 `o` 命令会反映这一点。
- en: Breakpoints in Patterns
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式中的断点
- en: 'As well as setting breakpoints in normal rules, you can also set them in patterns.
    Every time that pattern rule is used, the breakpoint is hit. For example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在正常规则中设置断点，你还可以在模式中设置断点。每次使用该模式规则时，断点都会被触发。例如：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, `all` is built from `foo.x` and `bar.x`, which requires building them
    from `foo.y` and `bar.y` using the `%.x: %.y` rule. A breakpoint is inserted in
    the pattern rule, and the debugger breaks twice: once for `foo.x` and once for
    `bar.x`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`all` 是由 `foo.x` 和 `bar.x` 构建的，这需要通过 `%.x: %.y` 规则从 `foo.y` 和 `bar.y` 构建它们。一个断点被插入到模式规则中，调试器会中断两次：一次是
    `foo.x`，一次是 `bar.x`：'
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Even pattern-specific variables work:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是特定于模式的变量也能正常工作：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`%.x` has a pattern-specific variable `FOO` with the value `foo`; the debugger
    `v` command can access it during a breakpoint on the pattern rule.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`%.x` 具有一个特定于模式的变量 `FOO`，其值为 `foo`；调试器的 `v` 命令可以在模式规则的断点处访问它。'
- en: Breakpoints in Makefiles
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile 中的断点
- en: 'Additionally, you can simply insert a breakpoint in a makefile if needed. Parsing
    of makefiles will pause at the breakpoint so you can examine the current state
    of variables in the makefile. For example, with a breakpoint after each definition
    of `FOO` in this makefile, you can see its value change:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要，你也可以直接在 makefile 中插入断点。makefile 的解析将在断点处暂停，以便你检查 makefile 中当前变量的状态。例如，在每次定义
    `FOO` 后插入一个断点，你可以看到它的值如何变化：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here’s a sample run:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例运行：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The two separate breakpoints are activated (one after each time `FOO` is set).
    Using the debugger’s `v` command shows how the value of `FOO` changes at each
    breakpoint.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个单独的断点会被激活（每次设置 `FOO` 后）。使用调试器的 `v` 命令可以显示在每个断点处 `FOO` 的值如何变化。
- en: Debugger Internals
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器内部实现
- en: 'The debugger draws on functions defined in the GMSL (you can read more about
    the GMSL in [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard Library")).
    The first line of the debugger includes the GMSL functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器调用了在 GMSL 中定义的函数（你可以在 [第六章](ch06.html "第六章. GNU Make 标准库") 中了解更多关于 GMSL 的信息）。调试器的第一行包括
    GMSL 函数：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The debugger uses the `__PROMPT` variable to output the `n>` and read in a
    command followed by a single argument. `__PROMPT` uses the `read` shell command
    to get the command and argument into shell variables `$CMD` and `$ARG` and then
    returns a list of two elements: the first element is the command and the second
    is the argument. Expanding `__PROMPT` prompts for and returns a single command
    and argument pair:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器使用`__PROMPT`变量来输出`n>`并读取一个带有单一参数的命令。`__PROMPT`使用`read` shell命令将命令和参数读取到shell变量`$CMD`和`$ARG`中，然后返回一个包含两个元素的列表：第一个元素是命令，第二个元素是参数。展开`__PROMPT`会提示并返回一个单一的命令和参数对：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You use the `__BREAK` variable to get and handle a single command. First, it
    stores the result of `__PROMPT` in `__INPUT`, and then it calls the `__DEBUG`
    function (which handles debugger commands) with two arguments: the command and
    its argument returned by `__PROMPT` in `__INPUT`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`__BREAK`变量来获取并处理单一命令。首先，它将`__PROMPT`的结果存储在`__INPUT`中，然后调用`__DEBUG`函数（处理调试器命令），并传入两个参数：由`__PROMPT`在`__INPUT`中返回的命令及其参数。
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `__DEBUG` function handles the core of the debugger. `__DEBUG` takes a single
    character command in `$1`, its first argument, and an optional argument to the
    command in `$2`. `$1` is stored in the variable `__c` and `$2` in `__a`. Then
    `__DEBUG` examines `__c` to see whether it is one of the supported debugger commands
    (`c`, `q`, `v`, `d`, `o`, or `h`); if not, a call to `$(warning)` will output
    an error message.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`__DEBUG`函数处理调试器的核心部分。`__DEBUG`接受一个单字符命令作为第一个参数`$1`，以及命令的可选参数`$2`。`$1`存储在变量`__c`中，`$2`存储在`__a`中。然后，`__DEBUG`检查`__c`是否为支持的调试器命令之一（`c`、`q`、`v`、`d`、`o`或`h`）；如果不是，`$(warning)`将输出错误消息。'
- en: '`__DEBUG` consists of a set of nested `$(if)` statements that use the GMSL
    `seq` function to determine if the `__c` is a valid debugger command. If it is,
    `$(if)`’s first argument is expanded; if not, the next `$(if)` is examined. For
    example, the `v` command (which outputs the value of a variable) is handled like
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`__DEBUG`由一组嵌套的`$(if)`语句组成，使用GMSL的`seq`函数来判断`__c`是否为有效的调试器命令。如果是，`$(if)`的第一个参数将被展开；如果不是，接下来的`$(if)`将被检查。例如，`v`命令（用于输出变量的值）是这样处理的：'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the `__c` command is `v`, then `$(warning)` is used to output the value of
    the variable named by `__a` (the `$($(__a))` outputs the value of the variable
    whose name is stored in `__a`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`__c`命令是`v`，则使用`$(warning)`输出由`__a`命名的变量的值（`$($(__a))`输出存储在`__a`中的变量名对应的值）。
- en: 'When `__DEBUG` is done, it returns either `$(true)` or `$(false)` (the empty
    string). `$(true)` indicates that the debugger should stop prompting for commands
    and continue execution (the `q` command is handled by calling GNU `make`’s `$(error)`
    function to cause a fatal error, which stops `make`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当`__DEBUG`完成时，它返回`$(true)`或`$(false)`（空字符串）。`$(true)`表示调试器应停止提示命令并继续执行（`q`命令通过调用GNU
    `make`的`$(error)`函数来引发致命错误，从而停止`make`）：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we come to the definition of `__BREAKPOINT` (the breakpoint variable
    we used in [Example 2-9](ch02.html#setting_a_breakpoint_using_the_underscor "Example 2-9. Setting
    a breakpoint using the __BREAKPOINT variable")). It first outputs a banner containing
    information (you’ll see what `__BANNER` does in a moment); then it loops asking
    for commands by calling `__BREAK`. The loop terminates either if it runs out of
    items in `__LOOP` (which is where the 32-command limit is defined) or if a call
    to `__BREAK` returns `$(true)`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看`__BREAKPOINT`的定义（这是我们在[示例 2-9](ch02.html#setting_a_breakpoint_using_the_underscor
    "示例 2-9. 使用 __BREAKPOINT 变量设置断点")中使用的断点变量）。它首先输出一个包含信息的横幅（稍后你将看到`__BANNER`的作用）；然后它通过调用`__BREAK`来循环询问命令。循环会在`__LOOP`中没有更多项时结束（这里定义了32个命令的限制），或者当调用`__BREAK`返回`$(true)`时结束：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`__BANNER` shows that the debugger has stopped at a breakpoint, and by examining
    GNU `make` automatic variables, it is able to give information about the current
    rule being built:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`__BANNER`显示调试器已在断点处停止，并通过检查GNU `make`自动变量，能够提供有关当前正在构建的规则的信息：'
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here’s the complete debugger code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的调试器代码：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For the most up-to-date version, visit the GNU `make` Debugger open source project
    at *[http://gmd.sf.net/](http://gmd.sf.net/)*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最新版本，请访问GNU `make` 调试器开源项目，地址是*[http://gmd.sf.net/](http://gmd.sf.net/)*。
- en: Dynamic Breakpoints in the GNU make Debugger
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU make 调试器中的动态断点
- en: The preceding section showed how to build a debugger for GNU `make` entirely
    in GNU `make`. But it had only static (hardcoded) breakpoints. This section shows
    you how to enhance the debugger by adding dynamic breakpoints. That makes it possible
    to set and remove breakpoints on the name of a file (in GNU `make` language, a
    *target*) that the makefile will build.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了如何完全使用 GNU `make` 编写一个调试器。但它只有静态（硬编码）断点。本节展示了如何通过添加动态断点来增强调试器。这使得可以根据文件的名称（在
    GNU `make` 语言中，称为 *目标*）设置和移除断点，而这个目标是 makefile 将要构建的。
- en: It’s no longer necessary to insert the `$(__BREAKPOINT)` string in a makefile.
    Typing a simple set breakpoint command has the same effect. And another keystroke
    lists all breakpoints currently in effect.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要在 makefile 中插入 `$(__BREAKPOINT)` 字符串。输入一个简单的设置断点命令就能产生相同的效果。另一个按键操作则列出当前生效的所有断点。
- en: This section shows the use of the new breakpoints and how they are coded. The
    new code is written entirely in GNU `make`’s variable language and uses the GMSL
    set functions (detailed in [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard
    Library")) to maintain the list of current breakpoints.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了新断点的使用以及如何编写代码。新代码完全使用 GNU `make` 的变量语言编写，并使用 GMSL 设置函数（详见[第 6 章](ch06.html
    "第 6 章。GNU Make 标准库")）来维护当前断点列表。
- en: Getting the breakpoints to activate requires a little GNU `make` magic, but
    first let’s look at an example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活断点，需要一些 GNU `make` 的魔法，但首先让我们看一个例子。
- en: Dynamic Breakpoints in Action
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态断点的实际应用
- en: Before you see how the debugger works, let’s look at how to use it. The debugger
    and these examples all assume that you are using GNU `make` 3.80 or later.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解调试器如何工作之前，先看看如何使用它。调试器和这些示例都假设你使用的是 GNU `make` 3.80 或更高版本。
- en: Here’s an example makefile that builds `all` from prerequisites `foo` and `bar`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例 makefile，它从前置条件 `foo` 和 `bar` 构建 `all`。
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To illustrate the use of the debugger, a breakpoint is set in the makefile by
    inserting a line at the end of the makefile that consists of just the variable
    `$(__BREAKPOINT)`. `$(__BREAKPOINT)` will get expanded when the makefile finishes
    being parsed, causing the debugger to break execution before any rules are run
    and prompt for input. (The debugger is included here with the `include gmd` command
    at the start. You can get the GMD files from the GMD website at *[http://gmd.sf.net/](http://gmd.sf.net/)*;
    it’s all open source code.)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明调试器的使用，通过在 makefile 末尾插入一行仅包含变量 `$(__BREAKPOINT)` 的代码来设置断点。`$(__BREAKPOINT)`
    会在 makefile 解析完毕时展开，导致调试器在任何规则执行前中断执行并提示输入。（调试器通过在开始处的 `include gmd` 命令引入。你可以从
    GMD 网站获取 GMD 文件，地址是 *[http://gmd.sf.net/](http://gmd.sf.net/)*；所有代码都是开源的。）
- en: Here’s what happens when this makefile is executed with no existing files called
    `all`, `foo`, or `bar`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个 makefile 且没有名为 `all`、`foo` 或 `bar` 的现有文件时，会发生以下情况：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The debugger immediately breaks and waits for input. The first thing to do
    is type `h` to see the help text and the three new commands: `b` (to set a breakpoint),
    `r` (to remove a breakpoint), and `l` (to list current breakpoints).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器会立即中断并等待输入。首先要做的是输入 `h` 查看帮助文本以及三个新命令：`b`（设置断点），`r`（移除断点），和 `l`（列出当前断点）。
- en: 'Then set two breakpoints in the makefile: one when `foo` gets built and one
    for `all`. (If you look back at [The Debugger in Action](ch02.html#debugger_in_action
    "The Debugger in Action"), you’ll see that you can also achieve this by modifying
    the makefile, but these new breakpoints can be set dynamically at runtime.)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 makefile 中设置两个断点：一个是当 `foo` 被构建时，另一个是为 `all` 设置的。（如果你回顾一下[调试器实战](ch02.html#debugger_in_action
    "调试器实战")，你会看到你也可以通过修改 makefile 来实现这一点，但这些新断点可以在运行时动态设置。）
- en: 'After setting the breakpoints, use the `l` command to verify that they are
    set:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，使用 `l` 命令来验证它们是否已设置：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Continuing execution by entering `c` causes the `foo` breakpoint to be hit
    immediately. `foo` is the first target that the makefile will build (followed
    by `bar` and finally `all`). The breakpoint indicates that the rule for `foo`
    is at line 9:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 `c` 继续执行时，`foo` 断点会立即触发。`foo` 是 makefile 将构建的第一个目标（接着是 `bar`，最后是 `all`）。该断点表明
    `foo` 的规则位于第 9 行：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Continuing on, first the output (generated when `bar` is created) appears, and
    then the `all` breakpoint is hit.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行时，首先会显示生成 `bar` 时的输出，然后触发 `all` 断点。
- en: '[PRE72]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `all` breakpoint prints out much more information than `foo` because `all`
    has prerequisites.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`all` 断点打印出的信息比 `foo` 断点多得多，因为 `all` 具有前置条件。'
- en: The Easy Part
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单部分
- en: To add the breakpoint functions to the GNU `make` debugger, the debugger code
    that handles the keyboard was first altered to recognize the `b`, `r`, and `l`
    commands and call user-defined GNU `make` functions `__BP_SET`, `__BP_UNSET`,
    and `__BP_LIST`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将断点函数添加到 GNU `make` 调试器中，首先修改了处理键盘输入的调试器代码，以识别`b`、`r`和`l`命令，并调用用户定义的 GNU `make`
    函数`__BP_SET`、`__BP_UNSET`和`__BP_LIST`。
- en: 'The targets for which breakpoints are defined are simply a GMSL set of target
    names. Initially, there are no breakpoints and so the set, called `__BREAKPOINTS`,
    is empty:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 定义断点的目标只是一个 GMSL 目标名称集合。最初，没有断点，因此该集合（称为`__BREAKPOINTS`）是空的：
- en: '[PRE73]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Setting and removing breakpoints is a matter of calling the GMSL functions
    `set_insert` and `set_remove` to add or remove an element from `__BREAKPOINTS`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和删除断点只需调用 GMSL 函数`set_insert`和`set_remove`来向`__BREAKPOINTS`中添加或移除元素：
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Both functions use the GNU `make $(eval)` function to change the value of `__BREAKPOINTS`.
    `$(eval FOO)` evaluates its argument `FOO` as if it were a piece of text during
    parsing of the makefile: this means that at runtime you can change variable values
    or define new rules.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都使用 GNU `make $(eval)` 函数来更改`__BREAKPOINTS`的值。`$(eval FOO)`将其参数`FOO`当作文本在解析makefile时进行求值：这意味着在运行时你可以更改变量值或定义新的规则。
- en: '`__BP_UNSET` used the GMSL function `set_is_member` to determine whether the
    breakpoint being removed was actually defined and output a helpful message in
    the case that the user tries to remove a nonexistent breakpoint (which may be
    caused by a typing error on their part).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`__BP_UNSET`使用 GMSL 函数`set_is_member`来判断要移除的断点是否已定义，并在用户尝试移除一个不存在的断点时（这可能是由于用户输入错误）输出一个有用的消息。'
- en: 'Listing the current breakpoints is simply a matter of outputting the contents
    of the set stored in `__BREAKPOINTS`. Because that set is just a list with no
    duplicates, `__BP_LIST` feeds its value into the GNU `make` functions `$(addprefix)`
    and `$(addsuffix)` to put quotation marks around the target names:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列出当前断点仅仅是输出存储在`__BREAKPOINTS`中的集合内容。因为该集合只是一个没有重复元素的列表，所以`__BP_LIST`将其值传递给 GNU
    `make` 函数`$(addprefix)`和`$(addsuffix)`，以便在目标名称周围加上引号：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`__BP_LIST` uses the GNU `make $(if)` function to choose between listing the
    breakpoints if there are any or saying `No target breakpoints set` if the `__BREAKPOINTS`
    set is empty. `$(if)` will evaluate its second argument if `$(__BREAKPOINTS)`
    is a non-empty string and evaluate its third argument if there are no breakpoints.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`__BP_LIST`使用 GNU `make $(if)` 函数来选择：如果有断点，则列出断点；如果`__BREAKPOINTS`集合为空，则显示`No
    target breakpoints set`。'
- en: The Trick
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诀窍
- en: To get GNU `make` to break into the debugger, it has to expand the `__BREAKPOINT`
    variable, which outputs information about the breakpoint and prompts for commands.
    But for that to happen, we need a way to check which breakpoints are defined every
    time a rule is about to run. If we can engineer that, then `make` can expand `$(__BREAKPOINT)`
    if necessary, causing `make` to stop at the breakpoint.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 GNU `make` 进入调试器，它必须展开`__BREAKPOINT`变量，该变量输出有关断点的信息并提示输入命令。但为了实现这一点，我们需要一种方法来检查每次规则即将运行时定义了哪些断点。如果我们能做到这一点，那么`make`就可以在必要时展开`$(__BREAKPOINT)`，导致`make`在断点处停止。
- en: Fortunately, it’s possible to cause `make` to expand `__BREAKPOINT` by modifying
    the built-in `SHELL` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过修改内置的`SHELL`变量，可以让`make`展开`__BREAKPOINT`。
- en: 'The `SHELL` variable is also expanded every time a command is about to run
    inside a rule. That makes it ideal for checking breakpoints. Here’s the actual
    code in the GNU `make` debugger that uses `SHELL` for breakpoint handling:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每次命令准备在规则内部运行时，`SHELL`变量也会被展开。这使得它非常适合检查断点。以下是 GNU `make` 调试器中实际使用 `SHELL` 处理断点的代码：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: First, the real value of `SHELL` is stored in `__BP_OLD_SHELL` (note that the
    GNU `make :=` operator is used to capture the value, not the definition, of `SHELL`).
    Then `SHELL` is redefined to call the `__BP_NEW_SHELL` variable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`SHELL`的实际值存储在`__BP_OLD_SHELL`中（请注意，GNU `make :=` 操作符用于捕获`SHELL`的值，而不是定义）。然后，`SHELL`被重新定义为调用`__BP_NEW_SHELL`变量。
- en: '`__BP_NEW_SHELL` is where the interesting work is done. The last part of it
    is `$(__BP_OLD_SHELL)`, which is the value of the original `SHELL` variable. After
    all, once it’s done checking breakpoints, GNU `make` needs to use the original
    `shell` to actually run commands. Before that there’s a rather complex `$(if)`.
    Concentrate for a moment on the call to `$(__BP_CHECK)`. That’s the variable that
    will actually check to see whether the breakpoint should be executed. It’s defined
    like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`__BP_NEW_SHELL`是执行有趣工作的地方。它的最后部分是`$(__BP_OLD_SHELL)`，即原始`SHELL`变量的值。毕竟，一旦检查完断点，GNU
    `make`需要使用原始的`shell`来实际运行命令。在此之前，还有一个相当复杂的`$(if)`。集中精力看一下对`$(__BP_CHECK)`的调用。这个变量实际上会检查是否应该执行断点。它是这样定义的：'
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`__BP_CHECK` checks to see whether the current target being built (stored in
    the standard GNU `make` automatic variable `$@`) is present in the list of breakpoints.
    It does this using the GMSL function `set_is_member`. If the target is present,
    it does two things: it sets an internal variable called `__BP_FLAG` to be the
    target for which the breakpoint has activated and then proceeds to `$(call)` a
    variable and throw away the result by storing it in a variable called `__IGNORE`.
    That’s done so that `__BP_CHECK`’s return value will always be empty; it’s used,
    after all, in the definition of `SHELL`, which ultimately needs to be just the
    name of the `shell` to execute.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`__BP_CHECK`检查当前正在构建的目标（存储在标准GNU `make`自动变量`$@`中）是否存在于断点列表中。它通过使用GMSL函数`set_is_member`来完成这一检查。如果目标存在，它会做两件事：设置一个名为`__BP_FLAG`的内部变量，将其值设为已激活断点的目标，并继续执行`$(call)`某个变量，并通过将结果存储在`__IGNORE`变量中来丢弃它。这么做是为了确保`__BP_CHECK`的返回值始终为空；毕竟它是用于定义`SHELL`的，而`SHELL`最终需要只是要执行的`shell`的名称。'
- en: Experienced GNU `make` users will be scratching their heads wondering about
    the odd syntax `$(call SHELL,__BREAKPOINT)`. That’s where some GNU `make` rocket
    science comes in.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的GNU `make`用户可能会抓耳挠腮，想弄清楚那个奇怪的语法`$(call SHELL,__BREAKPOINT)`。这时就涉及到一些GNU
    `make`的火箭科学。
- en: Rocket Science
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 火箭科学
- en: Instead of writing `$(call SHELL,__BREAKPOINT)`, it’s tempting to write `$(__BREAKPOINT)`
    to get the breakpoint to activate. But that doesn’t work.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与其写`$(call SHELL,__BREAKPOINT)`，人们更容易写`$(__BREAKPOINT)`来激活断点。但这样并不起作用。
- en: 'Doing so would cause a fatal GNU `make` error. Follow the chain of variables
    up from `__BP_CHECK`, and it becomes clear that it’s been expanded because `SHELL`
    was being expanded (because a rule was about to run). Follow into `__BREAKPOINT`,
    and there’s a nasty surprise: a call to `$(shell)` (this can be seen in the GMD
    code in [Addition and Subtraction](ch05.html#page_64) or in the preceding section),
    which will cause `SHELL` to be expanded.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这么做会导致致命的GNU `make`错误。追溯变量链从`__BP_CHECK`开始，就会发现它已经展开，因为`SHELL`正在展开（因为规则即将运行）。跟进到`__BREAKPOINT`，会有一个令人吃惊的结果：调用`$(shell)`（在[GMD代码中的加法与减法](ch05.html#page_64)或者前一节中可以看到），这会导致`SHELL`展开。
- en: Danger, Will Robinson! `SHELL` is defined in terms of `SHELL`, which causes
    GNU `make` to spot the recursion and give up. The `$(call SHELL,__BREAKPOINT)`
    syntax lets us play with fire. Any time a variable is `$(call)`ed in GNU `make`,
    the flag used to check for recursion is disabled. So doing `$(call SHELL,__BREAKPOINT)`
    means that the recursion flag on `SHELL` is turned off (avoiding the error) and
    the definition of `SHELL` calls `__BP_NEW_SHELL` with one argument. The argument
    is the word `__BREAKPOINT`. `__BP_NEW_SHELL` checks to see whether `__BP_FLAG`
    is set to the same value as `$@` (which it does using the GMSL `seq` function)
    and then proceeds to `$(call)` its first argument (which is `__BREAKPOINT`); the
    breakpoint fires and the prompt appears.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 危险，威尔·罗宾逊！`SHELL`是通过`SHELL`定义的，这会导致GNU `make`发现递归并放弃。`$(call SHELL,__BREAKPOINT)`语法让我们可以玩火。每次在GNU
    `make`中使用`$(call)`调用一个变量时，用于检查递归的标志会被禁用。因此，执行`$(call SHELL,__BREAKPOINT)`意味着`SHELL`的递归标志被关闭（避免了错误），并且`SHELL`的定义会调用`__BP_NEW_SHELL`并传入一个参数。该参数是词汇`__BREAKPOINT`。`__BP_NEW_SHELL`会检查`__BP_FLAG`是否与`$@`的值相同（通过GMSL的`seq`函数进行检查），然后继续执行`$(call)`第一个参数（即`__BREAKPOINT`）；断点被触发，提示符出现。
- en: 'It might seem that some horrible infinite recursion will occur when the `$(shell)`
    gets executed and `SHELL` is expanded again. Two things prevent that: `__BP_FLAG`
    is still the same as `$@` (so `__BP_CHECK` is not called again), and this time
    `SHELL` has no argument (the value in `$1` is empty), so the `$(call $1,)` does
    nothing and recursion stops.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `$(shell)` 并且 `SHELL` 被再次展开时，可能看起来会发生可怕的无限递归。两个因素阻止了这种情况：`__BP_FLAG` 与 `$@`
    保持一致（因此 `__BP_CHECK` 不会再次被调用），并且这次 `SHELL` 没有参数（`$1` 的值为空），所以 `$(call $1,)` 什么也不做，递归停止。
- en: An Introduction to remake
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`remake` 简介'
- en: The `remake` project (*[http://bashdb.sourceforge.net/remake/](http://bashdb.sourceforge.net/remake/)*)
    is a fork of GNU `make` that integrates a complete debugger created by modifying
    the GNU `make` source code. `remake` forked from GNU `make` 3.82 and is currently
    at version 3.82+dbg-0.9.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`remake` 项目（*[http://bashdb.sourceforge.net/remake/](http://bashdb.sourceforge.net/remake/)*)
    是一个基于 GNU `make` 的分支，它通过修改 GNU `make` 源代码集成了一个完整的调试器。`remake` 从 GNU `make` 3.82
    分支而来，目前版本为 3.82+dbg-0.9。'
- en: Just Print and Trace
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅打印和跟踪
- en: 'To illustrate the operation of `remake`, let’s use [Example 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "Example 2-10. A simple makefile to illustrate remake"), a sample makefile:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `remake` 的操作，我们使用 [示例 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "示例 2-10. 一个简单的 makefile 用于说明 remake")，这是一个示例 makefile：
- en: Example 2-10. A simple makefile to illustrate remake
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-10. 一个简单的 makefile 用于说明 remake
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Running the standard GNU `make -n` (or `--just-print`) option against this
    makefile produces the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行标准的 GNU `make -n`（或 `--just-print`）选项来执行这个 makefile 会产生以下输出：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But `remake` provides a makefile and line number information for each rule.
    The information shows the target (the value of `$@`) and the commands to be run:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 `remake` 为每个规则提供了 makefile 和行号信息。这些信息显示了目标（`$@` 的值）和要执行的命令：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Of course, you have to run any real makefile to understand its execution. `remake`
    provides a handy tracing option, `-x`, which runs the makefile while outputting
    information about why targets are being built and showing the commands executed
    and their output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你必须运行任何实际的 makefile 来理解其执行过程。`remake` 提供了一个方便的跟踪选项 `-x`，它在运行 makefile 的同时输出有关为何构建目标的信息，并显示执行的命令及其输出：
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The trace option really comes into its own when an error occurs. Here’s the
    output when a nonexistent option `-z` is added to the `touch` in the commands
    for target `bar`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪选项在发生错误时非常有用。这里是当一个不存在的选项 `-z` 被添加到 `touch` 命令中以构建目标 `bar` 时的输出：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Right at the bottom of that output is the call stack of targets that were dependent
    on `bar` building successfully, plus, of course, the error generated by `touch`,
    the actual command that was executed, and where to find it in the makefile.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最底部是调用栈，显示依赖于 `bar` 构建成功的目标列表，以及 `touch` 生成的错误、执行的实际命令和在 makefile 中的位置。
- en: Debugging
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: 'Because `remake` contains an interactive debugger, you can use it to debug
    the `touch` problem. Run `remake` with the `-X` option (uppercase `X` for the
    debugger; lowercase `x` for tracing), and the debugger breaks at the first target
    to be built:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `remake` 包含一个交互式调试器，你可以用它来调试 `touch` 问题。运行 `remake` 时使用 `-X` 选项（大写的 `X` 用于调试器；小写的
    `x` 用于跟踪），调试器会在第一个目标构建时断点：
- en: '[PRE83]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So the first break is at line 2 of the makefile and shows that the first target
    is `all` (and the complete prerequisite list is shown). Entering `h` gives complete
    help information:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，第一个断点是在 makefile 的第 2 行，它显示第一个目标是 `all`（并显示完整的前提条件列表）。输入 `h` 会提供完整的帮助信息：
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Because the `touch` problem occurs later in the `make` execution (in the `bar`
    rule), just continue by single stepping with `s`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `touch` 问题发生在 `make` 执行的后期（在 `bar` 规则中），所以只需继续执行，通过 `s` 单步调试：
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'While in the debugger, you can fix the error in the makefile and then enter
    `R` to restart the build:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中，你可以修复 makefile 中的错误，然后输入`R`来重新启动构建：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now things work correctly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切正常工作。
- en: Targets, Macro Values, and Expansion
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标、宏值和展开
- en: 'When stopped in the debugger, it’s possible to interrogate information about
    targets in the makefile, such as variable values (expanded and unexpanded) and
    commands. For example, in [Example 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "Example 2-10. A simple makefile to illustrate remake"), when stopped at a breakpoint,
    you can find all the information `remake` has about the `all` target by using
    the `target` command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当在调试器中停止时，可以查询 makefile 中目标的信息，例如变量值（扩展和未扩展的）和命令。例如，在[示例 2-10](ch02.html#simple_makefile_to_illustrate_remake
    "示例 2-10：一个简单的 makefile 来说明 remake")中，当停在断点时，可以通过使用 `target` 命令查找 `remake` 关于
    `all` 目标的所有信息：
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`remake` shows that `all` is a phony target and dumps information about the
    automatic variables that will be set for this rule. There’s no restriction on
    asking about the current target:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`remake` 显示 `all` 是一个虚拟目标，并打印出将为此规则设置的自动变量信息。没有任何限制可以查询当前目标：'
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Because target `foo` has commands, they are listed at the bottom (along with
    where to find them in which makefile). To see the expanded form of the commands,
    use the `expand` modifier of the `target` command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 因为目标 `foo` 有命令，它们会列在底部（以及在哪里找到它们的 makefile）。要查看命令的扩展形式，请使用 `target` 命令的 `expand`
    修饰符：
- en: '[PRE89]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To get information about a variable, we use the handy `print` and `expand`
    commands: `print` gives the definition of a variable, and `expand` gives its post-expansion
    value. Here’s how to find out the definition of the built-in `COMPILE.c` variable
    (which contains the command used to compile `.c` files):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于变量的信息，我们使用方便的 `print` 和 `expand` 命令：`print` 给出变量的定义，而 `expand` 给出扩展后的值。以下是如何查找内置的
    `COMPILE.c` 变量的定义（它包含用于编译 `.c` 文件的命令）：
- en: '[PRE90]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To see the expanded value, `expand` it:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看扩展后的值，`expand`它：
- en: '[PRE91]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`remake` can also set variable values using `set` (which expands a string and
    sets the variable to that value) and `setq` (which sets the variable to a string
    without expansion). For example, changing `CC` from `cc` to `gcc` changes the
    C compiler `make` will use:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`remake` 也可以使用 `set`（它扩展一个字符串并将变量设置为该值）和 `setq`（它将变量设置为一个未扩展的字符串）来设置变量的值。例如，将
    `CC` 从 `cc` 改为 `gcc` 会改变 `make` 使用的 C 编译器：'
- en: '[PRE92]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`remake` is a very useful tool to add to your `make` toolkit. You don’t need
    to use it every day, but switching from `make` to `remake` when you have a knotty
    problem to solve is hassle-free if you are not using any features added in GNU
    `make` 4.0.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`remake` 是一个非常有用的工具，可以添加到你的 `make` 工具包中。你不需要每天使用它，但当你遇到棘手问题时，如果你没有使用 GNU `make`
    4.0 中新增的任何特性，将 `make` 切换到 `remake` 会毫不费力。'
