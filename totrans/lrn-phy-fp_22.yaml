- en: '20'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '20'
- en: SPRINGS, BILLIARD BALLS, AND A GUITAR STRING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧、台球和吉他弦
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: This chapter applies the ideas and theory of the previous chapter to three specific
    examples. The first is a system of two masses and two springs hanging from a fixed
    ceiling, the second is a billiard ball collision, and the third is a guitar string
    modeled as a long line of particles connected to their neighbors with springs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将上一章中的思想和理论应用于三个具体示例。第一个是一个由两个质量和两根弹簧组成的系统，这些弹簧挂在一个固定的天花板上；第二个是台球碰撞；第三个是将吉他弦建模为一条由粒子组成的长线，粒子通过弹簧与相邻的粒子连接。
- en: A few things will be different in this chapter. We’ll take a closer look at
    the approximate numerical calculation we have been doing, treating numerical issues
    in more detail than we have in previous chapters. We’ll examine momentum and energy
    conservation in the context of approximate numerical calculation. We’ll also introduce
    a method for asynchronous animation where the calculations are done first and
    then made into a movie that can be watched afterward. Asynchronous animation is
    appropriate when the calculations get too intense to be done on the time scale
    of human impatience to see the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将有一些不同的地方。我们将更详细地研究之前所做的近似数值计算，比之前的章节更深入地处理数值问题。我们还将研究在近似数值计算的背景下，动量和能量守恒。我们还将介绍一种异步动画的方法，首先进行计算，然后制作成可以观看的电影。异步动画适用于当计算变得过于复杂，无法在人类耐心等待结果的时间尺度内完成时。
- en: Introductory Code
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门代码
- en: '[Listing 20-1](ch20.xhtml#ch20list1) shows the introductory code for the `MOExamples`
    module we’ll develop in this chapter (*MO* for *Multiple Objects*). As usual,
    we import the functions and types we want to use in this module.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单20-1](ch20.xhtml#ch20list1)显示了我们将在本章中开发的`MOExamples`模块的入门代码（*MO*代表*多物体*）。像往常一样，我们导入了我们想在这个模块中使用的函数和类型。'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 20-1: Opening lines of code for the MOExamples module*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单20-1：MOExamples模块的开头代码*'
- en: The types `ParticleState` and `MultiParticleState` are the state-description
    types we use for one particle and multiple particles, respectively. The function
    `newtonSecondMPS` creates a differential equation from a list of internal and
    external forces. The functions `euler`, `eulerCromerMPS`, and `rungeKutta4` are
    used to solve differential equations. We import the type class `HasTime` so we
    can use the `timeOf` function that belongs to it, and because we make explicit
    reference to `HasTime` in one of the exercises.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleState`和`MultiParticleState`类型是我们用于描述单个粒子和多个粒子状态的类型。函数`newtonSecondMPS`根据内部和外部力的列表创建一个微分方程。函数`euler`、`eulerCromerMPS`和`rungeKutta4`用于求解微分方程。我们导入了类型类`HasTime`，这样我们就可以使用它所包含的`timeOf`函数，因为我们在一个练习中明确引用了`HasTime`。'
- en: Two Masses and Two Springs
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个质量和两根弹簧
- en: As a first example of a system with multiple objects, let’s analyze the situation
    in [Figure 20-1](ch20.xhtml#ch20fig1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个多物体系统的示例，让我们分析[图20-1](ch20.xhtml#ch20fig1)中的情况。
- en: '![Image](Images/365fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/365fig01.jpg)'
- en: '*Figure 20-1: A system of two masses and two springs*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-1：一个由两个质量和两根弹簧组成的系统*'
- en: In [Figure 20-1](ch20.xhtml#ch20fig1) we have two masses and two springs. The
    upper spring is attached to a fixed ceiling and has spring constant *k*[1] and
    equilibrium length *re*[1]. The lower spring connects the two objects and has
    spring constant *k*[2] and equilibrium length *re*[2]. The upper object has mass
    *m*[0], and the lower object has mass *m*[1]. Earth surface gravity acts on each
    of the objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图20-1](ch20.xhtml#ch20fig1)中，我们有两个质量和两根弹簧。上面的弹簧连接到一个固定的天花板，具有弹簧常数*k*[1]和平衡长度*re*[1]。下面的弹簧连接两个物体，具有弹簧常数*k*[2]和平衡长度*re*[2]。上方物体的质量为*m*[0]，下方物体的质量为*m*[1]。地球表面的重力作用于每个物体。
- en: Forces
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 力
- en: 'There are a total of four forces acting in this situation: three external forces
    and one internal force. The list `twoSpringsForces` contains the four forces,
    which we will describe in the order they are listed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下共涉及四个力：三个外力和一个内力。列表`twoSpringsForces`包含了这四个力，我们将按照它们的列出顺序进行描述。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since one end is fixed, the upper spring acts as an external force on object
    0\. The relevant one-body force is `fixedLinearSpring 100 0.5 zeroV`, the force
    from a linear spring with spring constant 100 N/m and equilibrium length 0.5 m
    attached to the ceiling at the origin. The lower spring acts as an internal force
    between objects 0 and 1\. It also has spring constant 100 N/m and equilibrium
    length 0.5 m. The last two forces describe the gravitational force Earth exerts
    on each of the two objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一端固定，上方的弹簧对物体0施加外力。相关的单体力是`fixedLinearSpring 100 0.5 zeroV`，这是一个线性弹簧产生的力，弹簧常数为100
    N/m，平衡长度为0.5米，附着在原点的天花板上。下方的弹簧作为物体0和物体1之间的内力。它也具有100 N/m的弹簧常数和平衡长度0.5米。最后两个力描述了地球对这两个物体施加的重力。
- en: Animation Functions
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动画函数
- en: 'We’d like to animate the oscillation of the objects using not-gloss. We need
    to specify the five ingredients that serve as inputs to the `simulateVis` function:
    a time-scale factor, an animation rate, an initial state, a display function,
    and a state-update function. We choose a time-scale factor of 1 and an animation
    rate of 20 frames/second.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用非光滑效果对物体的振荡进行动画化。我们需要指定五个作为输入传递给`simulateVis`函数的参数：时间尺度因子、动画速率、初始状态、显示函数和状态更新函数。我们选择时间尺度因子为1，动画速率为20帧/秒。
- en: 'In the initial state, we must give the mass, initial position, and velocity
    of each object. We let ![Image](Images/366equ01.jpg) ![Image](Images/366equ01a.jpg)
    and **v**[1](0) = 0 m/s, where **r**[*j*] and **v**[*j*] are the position and
    velocity functions of particle *j*. The code for the initial state is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始状态下，我们必须给出每个物体的质量、初始位置和速度。我们设定![Image](Images/366equ01.jpg) ![Image](Images/366equ01a.jpg)
    和**v**[1](0 = 0 m/s，其中**r**[*j*]和**v**[*j*]分别是粒子*j*的位置和速度函数。初始状态的代码如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `MPS` constructor, the one constructor for the `MultiParticleState`
    data type, to transform a list of single-particle states into a multi-particle
    state. We set the charge, time, and velocity of each particle to 0 since that
    is the value in `defaultParticleState`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`MPS`构造函数，这是`MultiParticleState`数据类型的唯一构造函数，用于将单粒子状态列表转换为多粒子状态。我们将每个粒子的电荷、时间和速度设置为0，因为这些值在`defaultParticleState`中就是0。
- en: 'The function that involves most of the physics is `twoSpringsUpdate`, the state-update
    function for the system. Here is the code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及大部分物理内容的函数是`twoSpringsUpdate`，它是系统的状态更新函数。以下是代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The time step gets the local name `dt`. Recall that, in animation, we do not
    choose the time step directly. We choose it indirectly through the time-scale
    factor and animation rate, and then the animation packages do their best to adhere
    to that rate, although they make no promises. Since the old state is not named
    on the left of the equal sign of the definition, the return type is `MultiParticleState
    -> MultiParticleState`. We use `updateMPS` to create the state-update function.
    It returns a state-update function when given a numerical method and a list of
    forces. We choose Euler-Cromer with time step `dt` as our numerical method, and
    we give the list of forces we wrote earlier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 时间步长被命名为`dt`。回想一下，在动画中，我们并不直接选择时间步长。我们通过时间尺度因子和动画速率间接选择它，然后动画包尽力遵循该速率，尽管它们并不做出任何保证。由于旧状态没有在定义的等号左侧命名，因此返回类型为`MultiParticleState
    -> MultiParticleState`。我们使用`updateMPS`来创建状态更新函数。给定数值方法和力列表时，它返回一个状态更新函数。我们选择使用时间步长`dt`的欧拉-克罗梅数值方法，并提供我们之前写的力列表。
- en: We have specified the time-scale factor, the animation rate, the initial state,
    and the state-update function we will use for our animation. We will discuss the
    display function next when we look at the stand-alone program for the animation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了时间尺度因子、动画速率、初始状态和我们将用于动画的状态更新函数。接下来我们将在查看独立程序动画时讨论显示函数。
- en: Stand-Alone Animation Program
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 独立动画程序
- en: '[Listing 20-2](ch20.xhtml#ch20list2) shows a stand-alone program for 3D animation
    of the two masses and two springs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-2](ch20.xhtml#ch20list2)展示了一个用于二维物体和弹簧3D动画的独立程序。'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 20-2: Stand-alone program for a 3D animation of two masses and two
    springs*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20-2：二维物体和弹簧的独立程序动画*'
- en: The program begins by turning on warnings ➊ and then imports the needed types
    and functions. The program makes imports from the `SimpleVec` module of [Chapter
    10](ch10.xhtml), the `Mechanics3D` module of [Chapter 16](ch16.xhtml), the `Multiple`
    `Objects` module of [Chapter 19](ch19.xhtml), and the `MOExamples` module of the
    current chapter. It imports `zeroV` from the `SimpleVec` module to be able to
    refer to the origin, where a spring is attached. The program imports `R` because
    it is used in the type `VisObject R`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先启用警告 ➊，然后导入所需的类型和函数。程序从[第10章](ch10.xhtml)的`SimpleVec`模块、[第16章](ch16.xhtml)的`Mechanics3D`模块、[第19章](ch19.xhtml)的`Multiple
    Objects`模块以及当前章节的`MOExamples`模块中导入了所需内容。它从`SimpleVec`模块导入了`zeroV`，以便引用原点，弹簧固定的位置。程序导入了`R`，因为它在类型`VisObject
    R`中有使用。
- en: Let’s discuss the imports from the `Mechanics3D` module. The program imports
    the `posVec` function, the extraction function of the `ParticleState` data type
    that returns the position vector of a particle state. The only state variable
    needed in the display function is position. None of the other state variables
    have anything to contribute to what the picture should look like for a given state.
    The program imports `simulateVis`, the principal function that produces the animation.
    The program also imports `v3FromVec` to convert a vector with type `Vec` into
    a vector with type `V3`, not-gloss’s vector type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下从`Mechanics3D`模块导入的内容。程序导入了`posVec`函数，这是`ParticleState`数据类型的提取函数，用于返回粒子状态的位移向量。显示函数中唯一需要的状态变量是位置。其他状态变量对给定状态下图片的呈现没有任何贡献。程序导入了`simulateVis`，这是生成动画的主要函数。程序还导入了`v3FromVec`，用于将类型为`Vec`的向量转换为`V3`类型的向量，这是非-华丽模式下的向量类型。
- en: From the `MultipleObjects` module, we import the `MultiParticleState` type with
    its constructor so we can refer to the type in the type signature for the display
    function and use the constructor `MPS` to pattern match on the input in the definition
    of the display function. From the `MOExamples` module of the current chapter,
    we import the initial state and the state-update function, two of the five ingredients
    needed for an animation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从`MultipleObjects`模块中，我们导入了`MultiParticleState`类型及其构造函数，以便在显示函数的类型签名中引用该类型，并使用构造函数`MPS`在显示函数的定义中对输入进行模式匹配。从当前章节的`MOExamples`模块中，我们导入了初始状态和状态更新函数，这两个是制作动画所需的五个元素中的一部分。
- en: From the module `Vis`, the program imports the `VisObject` type with its constructors,
    which include `Line`, `Sphere`, `Trans`, `Scale`, and `VisObjects`. We import
    the `Flavour` type with its constructors because a sphere is required to be either
    solid or wire-frame, and the `Solid` data constructor we use is a constructor
    of `Flavour`. The program also imports the colors `red`, `green`, and `blue`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块`Vis`中，程序导入了`VisObject`类型及其构造函数，包括`Line`、`Sphere`、`Trans`、`Scale`和`VisObjects`。我们导入了`Flavour`类型及其构造函数，因为球体需要是实体的或线框的，而我们使用的`Solid`数据构造函数是`Flavour`的构造函数之一。程序还导入了颜色`red`、`green`和`blue`。
- en: The main program is named `main` and has type `IO ()`. It calls `simulateVis`
    with the five ingredients needed to make an animation, which includes the display
    function `twoSpringsVisObject` defined in the stand-alone program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序命名为`main`，类型为`IO ()`。它调用`simulateVis`，并传入制作动画所需的五个元素，其中包括在独立程序中定义的显示函数`twoSpringsVisObject`。
- en: The display function `twoSpringsVisObject` produces a picture from the state
    of the system. The definition of the display function begins by pattern matching
    on the input so that the body of the function has access to the two-element list
    of single-particle states `sts` ➋. We give local names `r0` and `r1` to the positions
    of the two objects ➌ ➍. The local variable `springsObj` is a picture of two lines
    that represent the two springs ➎. To construct a picture of two lines, we use
    the `Line` data constructor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显示函数`twoSpringsVisObject`根据系统的状态生成图像。显示函数的定义开始时通过模式匹配输入数据，以便函数体能够访问由两个单粒子状态组成的二元列表`sts`
    ➋。我们为两个物体的位置分别命名为`r0`和`r1` ➌ ➍。局部变量`springsObj`是代表两个弹簧的两条线的图像 ➎。为了构造两条线的图像，我们使用了`Line`数据构造函数。
- en: Let’s take a look at the type of `Line` in not-gloss.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Line`类型在非-华丽模式下的定义。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Line` has three inputs. The first has to do with line width. To get the
    default line width, in [Listing 20-2](ch20.xhtml#ch20list2) we supply `Nothing`
    for the first input ➎. The second input is a list of vectors, each vector having
    not-gloss’s native `V3 a` type. In our use, the type variable `a` stands for the
    type `R`. We convert from `Vec` to `V3 R` with `v3FromVec` ➎. The third input
    is a color, for which the program supplies `blue` ➏.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Line`有三个输入。第一个输入与线条宽度有关。为了得到默认的线条宽度，在[清单20-2](ch20.xhtml#ch20list2)中，我们为第一个输入提供了`Nothing`➎。第二个输入是一个向量列表，每个向量具有not-gloss的本地`V3
    a`类型。在我们的用法中，类型变量`a`代表`R`类型。我们通过`v3FromVec`将`Vec`转换为`V3 R`➎。第三个输入是颜色，程序为其提供了`blue`➏。
- en: We define `objs` to be a list of pictures of the two masses and the two springs
    ➐. The pictures of the masses are spheres, translated to the positions contained
    in the state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`objs`为两质量块和两弹簧的图片列表➐。质量块的图片是球体，位移到状态中包含的位置。
- en: We then define a spatial-scale factor `vpm` to be 1 Vis-unit/meter ➑. Of course,
    scaling by 1 is unnecessary, but the code makes it easy to change the value to
    something else. Finally, `VisObjects` combines multiple pictures into a single
    picture and `Scale` scales the entire result ➒.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个空间缩放因子`vpm`，它等于1 Vis单位/米➑。当然，缩放为1是没有必要的，但这样写代码可以方便地将值更改为其他数值。最后，`VisObjects`将多个图片合并为一张单独的图片，`Scale`则对整个结果进行缩放➒。
- en: Using Mechanical Energy as a Guide to Numerical Accuracy
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用机械能作为数值准确性的指导
- en: The system of two masses and two springs that we’ve been exploring should conserve
    mechanical energy. In this section, we’ll discuss the types of energy a system
    of particles can have, and we’ll see how to use energy as a tool to assess the
    accuracy of our numerical methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在研究的由两个质量块和两个弹簧组成的系统应当保持机械能守恒。在本节中，我们将讨论粒子系统可以具有的能量类型，并将了解如何使用能量作为工具来评估我们数值方法的准确性。
- en: Kinetic Energy
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动能
- en: Each moving particle has an energy of motion called *kinetic energy*. The kinetic
    energy of a single particle is one half the particle’s mass multiplied by the
    square of its speed. We’ll use small capitals *KE* for the kinetic energy of a
    single particle. Kinetic energy is a scalar whose SI units are Joules (J).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运动中的粒子都有一种被称为*动能*的运动能量。单个粒子的动能是粒子质量的一半乘以其速度的平方。我们将用小写的*KE*表示单个粒子的动能。动能是一个标量，其国际单位制单位是焦耳（J）。
- en: '![Image](Images/369equ01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/369equ01.jpg)'
- en: 'The speed *v* = |**v**| is the magnitude of the velocity **v**. Here is a Haskell
    function that returns the kinetic energy of one particle:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 速度*v* = |**v**|是速度**v**的大小。这里是一个返回单个粒子动能的Haskell函数：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The kinetic energy of a system of particles is the sum of the kinetic energies
    for each particle in the system. We use uppercase *KE* to denote system kinetic
    energy. In a system of particles, the kinetic energy of particle *n*, which has
    mass *m[n]* and velocity **v**[*n*], is given by
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的动能是系统中每个粒子动能的总和。我们用大写的*KE*表示系统的动能。在一个粒子系统中，质量为*m[n]*，速度为**v**[*n*]的第*n*个粒子的动能由以下公式给出：
- en: '![Image](Images/369equ02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/369equ02.jpg)'
- en: and the system kinetic energy is
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的动能为：
- en: '![Image](Images/369equ03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/369equ03.jpg)'
- en: 'Here is a Haskell function that returns the kinetic energy of a system of particles:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回粒子系统动能的Haskell函数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Potential Energy
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 势能
- en: Some forces are distinguished in that they can be associated with a *potential
    energy*. Such forces are called *conservative* and include the elastic force of
    a spring and the force of gravity as examples.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有些力的特点在于它们可以与*势能*相关联。这样的力被称为*守恒力*，例如弹簧的弹性力和重力就是其中的例子。
- en: A spring acquires potential energy by being compressed or extended from its
    equilibrium position. The spring can be used to store energy in this way. A linear
    spring with spring constant *k* that is displaced (compressed or extended) a distance
    *x* from its equilibrium position has a potential energy
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 弹簧通过被压缩或从平衡位置伸展而获得势能。弹簧可以通过这种方式储存能量。一个线性弹簧的弹簧常数为*k*，当它从平衡位置偏移（压缩或伸展）一个距离*x*时，具有的势能为：
- en: '![Image](Images/370equ01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/370equ01.jpg)'
- en: The type of potential energy associated with a spring is called *elastic potential
    energy*. The function `linearSpringPE` computes the elastic potential energy of
    a spring given its spring constant, equilibrium length, and particle states at
    each end.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与弹簧相关的势能类型称为*弹性势能*。函数`linearSpringPE`计算给定弹簧常数、平衡长度和每端粒子状态时的弹性势能。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is similar to the function `linearSpring` we wrote in [Chapter
    19](ch19.xhtml), except that instead of calculating a force, it calculates a potential
    energy. The displacement from equilibrium *x* in Equation 20.1 is the difference
    between the distance `r21mag` from one end of the spring to the other and the
    spring’s equilibrium length `re`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于我们在[第19章](ch19.xhtml)中编写的`linearSpring`函数，不同之处在于它计算的是势能，而不是力。公式20.1中的平衡位移*x*是弹簧两端之间的距离`r21mag`与弹簧平衡长度`re`的差值。
- en: An object near Earth’s surface has a *gravitational potential energy* that depends
    on its height. An object with mass *m* has potential energy
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 物体在地球表面附近具有*重力势能*，其大小依赖于物体的高度。具有质量*m*的物体具有势能
- en: PE[*g*] = *mgh*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: PE[*g*] = *mgh*
- en: where *g* is Earth’s gravitational acceleration constant and *h* is the object’s
    height above some reference level, such as Earth’s surface. The function `earthSurfaceGravityPE`
    computes the gravitational potential energy of an object near Earth’s surface
    given its particle state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*g*是地球的重力加速度常数，*h*是物体距离某一参考水平（如地球表面）的高度。函数`earthSurfaceGravityPE`计算给定粒子状态时，物体在地球表面附近的重力势能。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function is similar to the function `earthSurfaceGravity` we wrote in [Chapter
    16](ch16.xhtml), except that instead of calculating a force, it calculates a potential
    energy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于我们在[第16章](ch16.xhtml)中编写的`earthSurfaceGravity`函数，不同之处在于它计算的是势能，而不是力。
- en: Returning now to the example of two masses and two springs, the total potential
    energy is the elastic potential energy of each spring plus the gravitational potential
    energy of each mass.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到两个质量和两个弹簧的例子，总势能是每个弹簧的弹性势能加上每个质量的重力势能。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the top spring is connected to a fixed ceiling, we use the default particle
    state for one end of the top spring to indicate that one end of the spring is
    fixed at the origin.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶部弹簧连接到固定的天花板，我们使用默认粒子状态来表示顶部弹簧的一端固定在原点。
- en: Mechanical Energy
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 机械能
- en: The *mechanical energy* of a system of particles is the sum of its kinetic energy
    and its potential energy. Systems with no non-conservative forces conserve mechanical
    energy. The mechanical energy of such a system at a later time is the same as
    it was earlier. Since we are doing approximate calculation, we cannot expect that
    our calculation of mechanical energy will stay exactly the same over time. Since
    we know that it would stay the same if we could do exact calculation, we can take
    the deviation that occurs in our calculation as a guide to the level of inaccuracy
    our numerical method is producing. For a system that should conserve mechanical
    energy, how well it is conserved in our calculations is an indication of our numerical
    method’s accuracy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*机械能*是其动能与势能之和。没有非保守力的系统会保持机械能守恒。对于这样的系统，其机械能在后续时刻与之前时刻相同。由于我们在做近似计算，因此不能期望我们的机械能计算在时间上完全一致。由于我们知道如果能进行精确计算，它将保持不变，我们可以将计算中出现的偏差作为我们数值方法产生不准确度的参考。对于一个应该保持机械能守恒的系统，它在我们的计算中保持的程度可以作为数值方法准确度的指标。
- en: The function `twoSpringsME` computes the mechanical energy for the system of
    two masses and two springs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`twoSpringsME`计算由两个质量和两个弹簧组成的系统的机械能。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Mechanical energy is conserved for this system because all of the forces involved
    are conservative. For the system of two masses and two springs, [Figure 20-2](ch20.xhtml#ch20fig2)
    shows mechanical energy as a function of time for different numerical methods.
    The first column shows the Euler method, the second the Euler-Cromer, and the
    third the fourth-order Runge-Kutta. The first row uses a time step of 0.1 s, the
    second row 0.01 s, the third row 10^(–3) s, and the fourth row 10^(–4) s.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该系统，机械能是守恒的，因为所有涉及的力都是保守力。对于由两个质量和两个弹簧组成的系统，[图20-2](ch20.xhtml#ch20fig2)展示了不同数值方法下机械能随时间的变化情况。第一列展示欧拉法，第二列为欧拉-克罗梅尔法，第三列为四阶龙格-库塔法。第一行使用0.1秒的时间步长，第二行使用0.01秒，第三行使用10^（–3）秒，第四行使用10^（–4）秒。
- en: '![Image](Images/372fig01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/372fig01.jpg)'
- en: '*Figure 20-2: Mechanical energy as a function of time for different numerical
    methods. The change in mechanical energy is a measure of numerical inaccuracy.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-2：不同数值方法下，机械能随时间的变化。机械能的变化是数值不准确度的衡量标准。*'
- en: Mechanical energy tends to increase in the Euler method, oscillate in the Euler-Cromer
    method, and perhaps decrease in the fourth-order Runge-Kutta method. The horizontal
    axis shows a period of 10 seconds in each graph. The vertical axes show vastly
    different scales. If we take the difference between maximum mechanical energy
    and minimum mechanical energy over a 10-second time period as our measure of inaccuracy,
    we can make a table comparing the numerical methods. [Table 20-1](ch20.xhtml#ch20tab1)
    shows such a comparison.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 机械能在欧拉法中倾向于增加，在欧拉-克罗梅法中则表现为振荡，而在四阶龙格-库塔法中可能会减少。每个图中的横轴显示10秒钟的时间段。纵轴显示的尺度差异很大。如果我们将最大机械能和最小机械能之间的差异作为衡量不准确度的标准，就可以制作一个表格来比较数值方法。[表20-1](ch20.xhtml#ch20tab1)展示了这种比较。
- en: '**Table 20-1:** Change in Calculated Mechanical Energy for the Two-Mass and
    Two-Spring System over a 10-Second Interval for Different Numerical Methods'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表20-1：** 对于两质量和两弹簧系统，在10秒时间间隔内，不同数值方法计算的机械能变化'
- en: '| **Time step** | **Euler** | **Euler-Cromer** | **4th order RK** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **时间步长** | **欧拉法** | **欧拉-克罗梅法** | **四阶龙格-库塔法** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10^(–1)s | Way off | 40% | 7% |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 10^(–1)s | 偏差很大 | 40% | 7% |'
- en: '| 10^(–2)s | Way off | 4% | 10^(–4)% |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 10^(–2)s | 偏差很大 | 4% | 10^(–4)% |'
- en: '| 10^(–3)s | 20% | 0.4% | 10^(–8)% |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 10^(–3)s | 20% | 0.4% | 10^(–8)% |'
- en: '| 10^(–4)s | 2% | 0.04% | 10^(–11)% |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 10^(–4)s | 2% | 0.04% | 10^(–11)% |'
- en: '[Table 20-1](ch20.xhtml#ch20tab1) shows maximum mechanical energy minus minimum
    mechanical energy over a 10-second period, expressed as a percentage of initial
    mechanical energy. The Euler method is not even close for time steps less than
    a millisecond. You can see this in the animation if you change the numerical method
    to the Euler method. The springs extend and droop in a horrible display of numerical
    inaccuracy. The table also shows how each 10-fold reduction in time step produces
    approximately a 10-fold improvement in accuracy for the two first-order methods,
    Euler and Euler-Cromer. A 10-fold decrease in time step for the fourth-order Runge-Kutta
    method produces a roughly 10⁴-fold improvement in accuracy. In this way, the fourth-order
    method shows why it is considered a fourth-order method.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[表20-1](ch20.xhtml#ch20tab1)显示了在10秒钟期间，最大机械能减去最小机械能，并以初始机械能的百分比表示。对于小于毫秒的时间步长，欧拉方法甚至都无法接近正确的结果。如果你将数值方法改为欧拉方法，你可以在动画中看到这一点。弹簧在数值不准确的展示中伸展和下垂。该表还显示了，每次时间步长减少十倍，欧拉法和欧拉-克罗梅方法的准确性大约提高十倍。而四阶龙格-库塔方法每次减少十倍的时间步长，准确性大约提高10⁴倍。通过这种方式，四阶方法展示了为什么它被认为是四阶方法。'
- en: Having seen a first example of multiple interacting objects, let’s look at a
    second example of interacting objects, that of a collision.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到第一个多个物体相互作用的例子后，让我们看一下第二个相互作用的例子，即碰撞。
- en: A Collision
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞
- en: Our second example of multiple objects interacting is a collision between two
    billiard balls. For this example, we’ll go through the four data representations
    of [Figure 19-2](ch19.xhtml#ch19fig2), discuss the choice of parameters (including
    time step), look at momentum and energy conservation, discuss some numerical issues,
    and finally produce some animated results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个多个物体相互作用的例子是两颗台球之间的碰撞。对于这个例子，我们将通过[图19-2](ch19.xhtml#ch19fig2)中的四种数据表示形式，讨论参数选择（包括时间步长），查看动量和能量守恒，讨论一些数值问题，并最终展示一些动画结果。
- en: Data Representations
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据表示
- en: The four data representations are a list of forces, a differential equation,
    a state-update function, and a list of states. We’ll discuss each of these in
    turn.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 四种数据表示形式包括：力的列表、微分方程、状态更新函数和状态列表。我们将依次讨论这些。
- en: Forces
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 力
- en: 'We suppose that the elastic billiard interaction described in [Chapter 19](ch19.xhtml)
    is the only force that acts on either particle. This elastic billiard interaction
    is an internal force that acts between the two billiard balls. Here is the list
    of one force:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设在[第19章](ch19.xhtml)中描述的弹性台球相互作用是作用于每个粒子的唯一力。这种弹性台球相互作用是作用在两颗台球之间的内部力。以下是力的列表：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The elastic billiard interaction requires that we specify a spring constant
    for the elastic repulsion and a threshold distance at which the repulsive force
    kicks in. We make the spring constant `k` an argument to the function `billiardForces`
    so we can delay committing to a particular value and so it will be easy to try
    out different values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性台球相互作用要求我们指定一个弹簧常数，用于弹性排斥力，并指定一个阈值距离，在此距离下排斥力才会生效。我们将弹簧常数`k`作为`billiardForces`函数的参数，以便我们可以推迟确定一个特定值，这样也便于尝试不同的值。
- en: 'Each ball has a diameter of 6 cm. The threshold distance occurs when the centers
    of the balls are two radii apart. Because it’s always the same, we specify a particular
    value, `2*ballRadius`, for the threshold distance rather than making it an argument
    like we did for the spring constant. We name the ball radius because it’s used
    in two places: the list of forces we just wrote and the display function we write
    later in the chapter.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个球的直径为 6 厘米。阈值距离出现在球心相距两个半径的位置。由于这个距离始终相同，我们指定一个特定值`2*ballRadius`作为阈值距离，而不是像我们对弹簧常数做的那样将其作为一个参数。我们命名球半径是因为它在两个地方使用：我们刚才写的力的列表和稍后在本章中编写的显示函数。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Differential Equation
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 微分方程
- en: Newton’s second law transforms a list of forces into a differential equation.
    For multi-particle systems, `newtonSecondMPS` is the function that does this transformation.
    We give the name `billiardDiffEq k` to the differential equation that expresses
    Newton’s second law for two billiard balls acted on by `billiardForces k`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律将力的列表转化为一个微分方程。对于多粒子系统，`newtonSecondMPS`是执行此转化的函数。我们给表示牛顿第二定律的微分方程命名为`billiardDiffEq
    k`，它描述了两个台球在`billiardForces k`作用下的运动。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We continue to parameterize the differential equation by the spring constant
    `k` that we have not yet specified.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过弹簧常数`k`来参数化微分方程，直到现在我们还没有指定该值。
- en: State-Update Function
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: Next, we need a state-update function. The simplest way to write a state-update
    function uses the `updateMPS` function of [Figure 19-2](ch19.xhtml#ch19fig2).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个状态更新函数。编写状态更新函数的最简单方法是使用[图 19-2](ch19.xhtml#ch19fig2)中的`updateMPS`函数。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This state-update function has the same form as others we have written, except
    that we included a numerical method and a spring constant as parameters so we
    can specify these items later. There are only three things that have type `TimeStep
    -> NumericalMethod MultiParticleState DMultiParticleState` and can serve for the
    input `nMethod`: `euler`, `eulerCromerMPS`, and `rungeKutta4`. We need to specify
    one of these when we use this function, but for now we’ll delay that decision.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态更新函数与我们编写的其他函数形式相同，不同之处在于我们包含了数值方法和弹簧常数作为参数，以便稍后可以指定这些项。只有三种类型为`TimeStep
    -> NumericalMethod MultiParticleState DMultiParticleState`的函数可以作为输入`nMethod`：`euler`、`eulerCromerMPS`和`rungeKutta4`。我们在使用这个函数时需要指定其中之一，但目前我们将推迟做出这个决定。
- en: List of States
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态列表
- en: The fourth data representation of [Figure 19-2](ch19.xhtml#ch19fig2) is an evolver,
    which is a function that will produce a list of states when given an initial state.
    The simplest way to write an evolver uses the `statesMPS` function of [Figure
    19-2](ch19.xhtml#ch19fig2).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-2](ch19.xhtml#ch19fig2)中的第四种数据表示法是一个演化器，它是一个函数，当给定初始状态时，会生成一系列状态。编写演化器的最简单方法是使用[图
    19-2](ch19.xhtml#ch19fig2)中的`statesMPS`函数。'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get a list of states from an evolver requires an initial state. In the initial
    state, we give the masses of each object as well as their initial positions and
    velocities. We’ll let each billiard ball have a mass of 160 grams. The first ball
    starts at the origin with an initial velocity of 0.2 m/s in the x-direction. The
    second ball starts at rest at coordinates (1 m, 0.02 m) in the xy-plane. The small
    y-component is present so that the collision will be slightly oblique rather than
    one dimensional. The code for the initial state is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从演化器获得状态列表需要一个初始状态。在初始状态中，我们给定每个物体的质量以及它们的初始位置和速度。我们让每个台球的质量为160克。第一个球从原点开始，初始速度为0.2米/秒，方向为x轴。第二个球从静止状态开始，位于坐标(1米，0.02米)的xy平面上。小的y分量存在是为了让碰撞稍微倾斜，而不是一维的。初始状态的代码如下：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s now name a list of states based on this initial state. The list
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基于这个初始状态来命名一个状态列表。该列表
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: is an infinite list of states for the billiard collision when the calculation
    is done with numerical method `nMethod` (`euler`, `eulerCromerMPS`, or `rungeKutta4`),
    spring constant `k`, and time step `dt`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个无限状态列表，表示撞球碰撞的状态，当计算采用数值方法`nMethod`（`euler`，`eulerCromerMPS`或`rungeKutta4`），弹簧常数`k`和时间步长`dt`时得到。
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next we will want a finite list of states that we can use to make a graph, or
    to compare the value of some physical quantity, like momentum or kinetic energy,
    before the collision with the corresponding value after. The list `billiardStatesFinite
    nMethod k dt` is a finite list of states for the billiard collision when the calculation
    is done with numerical method `nMethod`, spring constant `k`, and time step `dt`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个有限的状态列表，可以用来绘制图表，或者用来比较碰撞前后某些物理量的值，比如动量或动能。列表`billiardStatesFinite
    nMethod k dt`是一个有限的撞球碰撞状态列表，当计算采用数值方法`nMethod`，弹簧常数`k`和时间步长`dt`时得到。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To form the finite list, we use `takeWhile` to select all of the states before
    10 seconds elapse. As we will see soon, the collision occurs about 5 seconds into
    the simulation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成有限列表，我们使用`takeWhile`来选择在10秒内所有的状态。如我们将很快看到的，碰撞大约发生在模拟的第5秒。
- en: So far, we have delayed making any choices about numerical method, spring constant,
    or time step. Let’s turn to that issue next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有做出关于数值方法、弹簧常数或时间步长的任何选择。接下来我们来讨论这个问题。
- en: Spring Constant and Time Step
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弹簧常数和时间步长
- en: In an introductory physics course, collisions are usually dealt with using conservation
    of momentum rather than by giving an explicit force for the interaction between
    two particles. Using conservation of momentum is elegant because we don’t need
    to know the force that acts between the particles; as long as it is short-lived,
    the system momentum before the collision must equal the system momentum after
    the collision. However, there are downsides to relying solely on conservation
    of momentum to analyze collisions. For example, for collisions in two dimensions,
    one usually needs information that is not present in the initial state of the
    system, such as the velocity of one of the particles *after* the collision, to
    find the velocities of both particles after the collision. If we know the nature
    of the force between the particles, on the other hand, then initial conditions
    suffice to determine the future motion of the particles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在一门入门级的物理课程中，碰撞通常通过动量守恒来处理，而不是通过给出粒子间相互作用的显式力。使用动量守恒是一种优雅的方法，因为我们不需要知道粒子之间的力，只要它是短暂的，碰撞前后的系统动量必须相等。然而，单纯依赖动量守恒来分析碰撞也有缺点。例如，对于二维碰撞，通常需要一些在系统初始状态中没有的信息，比如碰撞后某一粒子的速度，来计算两粒子碰撞后的速度。另一方面，如果我们知道粒子之间的力的性质，那么初始条件就足以决定粒子的未来运动。
- en: On the practical side of things, our method of analyzing a collision by specifying
    an explicit force between the particles means that we need to make some choices.
    The elastic billiard collision requires that we specify a spring constant. Values
    that are too small or too large can introduce trouble for the numerical analysis
    of the collision with a finite time step. If the spring constant is too small,
    the objects will squish together during the collision, making their centers very
    close, and there is a risk that one object will pass through the other object
    instead of bouncing off of it. If the spring constant is too large, the spring
    will apply a very large force the first time the objects are within their separation
    threshold. The force may be so large that the objects may be outside their separation
    threshold by the very next time step. This would be a poor sampling of the force
    and could lead to poor numerical results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们通过指定粒子之间的显式力来分析碰撞，这意味着我们需要做出一些选择。弹性撞球碰撞要求我们指定弹簧常数。弹簧常数过小或过大都会给有限时间步长的数值分析带来问题。如果弹簧常数太小，物体在碰撞时会被挤压到一起，使得它们的中心非常接近，存在一个风险：一个物体可能会穿过另一个物体，而不是从它上面反弹出去。如果弹簧常数太大，当物体首次进入其分离阈值时，弹簧会施加一个非常大的力。这个力可能大到在下一个时间步长时物体已经超出了分离阈值。这将导致对力的采样不准确，从而可能导致数值结果较差。
- en: If the time step is too large, one particle may move too far during one time
    step and entirely miss any state in which the particles are within their threshold
    separation. Even if the collision is not completely missed, a time step that is
    too large may give inaccurate results. Our general advice is to choose a time
    step that is small compared with the characteristic time scales of the situation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间步长过大，粒子在一个时间步内可能会移动得过远，完全错过粒子处于其阈值分离距离内的任何状态。即使碰撞没有完全错过，过大的时间步长也可能导致不准确的结果。我们的通用建议是选择一个与情况的特征时间尺度相比较小的时间步长。
- en: We need to choose a spring constant for the interaction force in addition to
    the usual time step for numerical analysis. How should we choose these two things?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的数值分析时间步长外，我们还需要为相互作用力选择一个弹簧常数。我们应该如何选择这两者呢？
- en: 'One way to choose a spring constant for the elastic interaction is to suppose
    that all of the initial kinetic energy of motion is transformed into potential
    energy in the spring. If this were true, we could write the following equation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择弹簧常数的一个方法是设想所有初始的动能都转化为弹簧中的势能。如果这是真的，我们可以写出以下方程：
- en: '![Image](Images/377equ01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/377equ01.jpg)'
- en: 'The separation threshold for the two billiard balls we are considering is 6
    cm; perhaps we would like the ball centers to get no closer than 5 cm to each
    other. Then the displacement from equilibrium should be no more than 1 cm. Using
    1 cm for *x* in the equation above and solving for *k* gives us the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的两个台球的分离阈值是6厘米；也许我们希望球心之间的距离不要小于5厘米。那么，平衡位置的位移应不超过1厘米。将1厘米代入上面的方程并解出* k
    *，我们得到以下结果：
- en: '![Image](Images/377equ02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/377equ02.jpg)'
- en: This calculation is a rough way of making a reasonable guess for a spring constant.
    The initial kinetic energy in this collision is only partially transformed into
    elastic potential energy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算是通过合理的猜测来确定弹簧常数的一种粗略方法。此碰撞中的初始动能仅部分转化为弹性势能。
- en: What are the relevant time scales for the collision? One time scale is the time
    it takes the moving billiard ball to traverse a distance equal to the threshold
    separation. This time is given by the threshold separation divided by the initial
    velocity of the moving ball.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞的相关时间尺度是什么？一个时间尺度是移动的台球穿越等于阈值分离距离所需的时间。这个时间由阈值分离除以移动球的初速度给出。
- en: '![Image](Images/377equ03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/377equ03.jpg)'
- en: A second time scale comes from the spring constant and mass in the problem.
    If this were a problem in which the mass could oscillate on the spring, the period
    of oscillation would be proportional to ![Image](Images/377equ04.jpg). Oscillation
    will not occur in this situation, but the collision can be viewed as taking place
    over the course of half a period of the oscillation that would occur if this were
    a full-fledged spring. The half period consists of the compression of the spring
    from equilibrium to closest approach, followed by the expansion of the spring
    back to equilibrium. This second spring-based time scale is
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个时间尺度来自于问题中的弹簧常数和质量。如果这是一个质量可以在弹簧上振荡的问题，振荡周期将与![Image](Images/377equ04.jpg)成正比。在这种情况下不会发生振荡，但可以将碰撞看作是发生在一个完整振荡周期的半个周期内。如果这是一个完整的弹簧，半个周期包括从平衡位置到最近接触的弹簧压缩过程，然后是弹簧恢复平衡的膨胀过程。这个基于弹簧的第二个时间尺度是
- en: '![Image](Images/377equ05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/377equ05.jpg)'
- en: The time step we choose for numerical analysis needs to be small compared with
    the smaller of the two time scales, namely 0.05 s. At this point, we have rough
    estimates for a spring constant and a time step. We will sharpen these estimates
    shortly, after we identify several desirable properties we want of our calculation
    and explore how these properties depend on the spring constant and time step.
    Two of the desirable properties are conservation of momentum and conservation
    of energy, which we look at next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为数值分析选择的时间步长需要比两个时间尺度中较小的那个要小，即0.05秒。到此为止，我们已经粗略估算了弹簧常数和时间步长。我们将很快通过识别我们希望计算具有的几个期望属性，并探索这些属性如何依赖于弹簧常数和时间步长，进一步优化这些估算。我们接下来将讨论的两个期望属性是动量守恒和能量守恒。
- en: Momentum and Energy Conservation
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动量和能量守恒
- en: The basic wisdom about collisions that comes from an introductory physics course
    is that momentum is conserved in all collisions; however, energy is conserved
    only in *elastic collisions*. Our collision is elastic, so we expect both momentum
    and energy to be conserved.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 来自基础物理课程的关于碰撞的基本知识是：动量在所有碰撞中都得到守恒；然而，能量只有在*弹性碰撞*中才得到守恒。我们的碰撞是弹性的，因此我们期望动量和能量都能守恒。
- en: Momentum Conservation
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动量守恒
- en: The momentum of a single particle is the particle’s mass multiplied by its velocity.
    The symbol **p** is conventionally used for momentum, which is a vector whose
    SI units are kg m/s.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单个粒子的动量是粒子的质量与其速度的乘积。符号**p**通常用于表示动量，它是一个矢量，其国际单位制单位是kg·m/s。
- en: '**p** = m**v**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** = m**v**'
- en: '(We saw in [Chapter 18](ch18.xhtml) that relativity theory uses a different
    definition of momentum, but in [Chapter 19](ch19.xhtml) and the current chapter,
    we’re focusing again on Newtonian mechanics.) Here is a Haskell function that
    returns the momentum of one particle:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: （我们在[第18章](ch18.xhtml)中看到，相对论理论使用了不同的动量定义，但在[第19章](ch19.xhtml)和本章中，我们再次关注牛顿力学。）这是一个返回单个粒子动量的Haskell函数：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The momentum of a system of particles is the vector sum of the momenta for each
    particle in the system. We use an uppercase **P** to denote system momentum. In
    a system of particles, the momentum of particle *n*, which has mass *m[n]* and
    velocity **v**[*n*], is given by
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个粒子系统的动量是系统中每个粒子的动量的矢量和。我们用大写字母**P**表示系统动量。在一个粒子系统中，粒子*n*的动量，假设其质量为*m[n]*，速度为**v**[*n*]，由下式给出：
- en: '**p**[*n*] = *m[n]***v**[*n*]'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**p**[*n*] = *m[n]***v**[*n*]'
- en: and the system momentum is
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 系统动量为
- en: '![Image](Images/378equ01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/378equ01.jpg)'
- en: Here is a Haskell function that returns the momentum of a system of particles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回粒子系统动量的Haskell函数。
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In any system with only internal forces, the momentum of the system is conserved,
    meaning it stays the same over time. Our numerical calculations involve a finite
    time step, which must be small compared to characteristic time scales of the physical
    situation to give accurate results. Most quantities of physical interest become
    less and less accurate as the time step is increased. An exception is system momentum
    in the case where only internal forces are present. Our practice of categorizing
    forces as external or internal, along with our automatic application of Newton’s
    third law, guarantees that system momentum will be conserved in any situation
    without external forces, regardless of numerical method and regardless of time
    step. This is because each internal force, acting over the course of one time
    step, will change the momentum vector of one particle by some amount and the momentum
    vector of another particle by the opposite amount. System momentum does not change
    from time step to time step, even if the time step is so large that the results
    of the calculation are poor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何只有内部力的系统中，系统的动量是守恒的，这意味着它在时间上保持不变。我们的数值计算涉及一个有限的时间步长，该时间步长必须相对于物理情境的特征时间尺度较小，以便获得准确的结果。随着时间步长的增加，大多数物理量的准确性会变得越来越差。一个例外是系统动量，在只有内部力存在的情况下。我们将力分类为外力或内力，并自动应用牛顿第三定律，保证了在没有外力的任何情况下，系统动量都将得到守恒，无论数值方法如何，时间步长如何。这是因为每个内部力在一个时间步长内作用，会改变一个粒子的动量向量一定的量，同时会改变另一个粒子的动量向量相反的量。即使时间步长如此之大，以至于计算结果不佳，系统动量也不会在时间步长之间发生变化。
- en: Even in collisions where external forces are present, system momentum is usually
    approximately conserved because the internal forces of collision are usually strong
    compared with any external forces. Since collisions are typically short-lived,
    the effect of external forces over the short duration of the collision is usually
    quite small.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在外力存在的碰撞中，系统动量通常也会大致守恒，因为碰撞的内部力通常与任何外力相比较强。由于碰撞通常是短暂的，外力在碰撞的短暂时间内的作用通常非常小。
- en: 'To confirm this conservation of system momentum, let’s write a function that
    computes percent change in system momentum. Since a list of states is a common
    information representation, we’ll use a finite list of multi-particle states for
    the input to this function, but we’ll only be comparing the first and last states
    in the list. Here is the function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认系统动量的守恒，让我们编写一个函数来计算系统动量的百分比变化。由于状态列表是常见的信息表示方式，我们将使用有限数量的多粒子状态作为该函数的输入，但我们只会比较列表中的第一个和最后一个状态。以下是该函数：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We name the incoming list of multi-particle states `mpsts`, and we use the Prelude
    functions `head` and `last` to pick out the first and last states in the list,
    giving their system momenta the local names `p0` and `p1`, respectively. We proceed
    to take the difference between the final system momentum `p1` and the initial
    system momentum `p0`, form the magnitude of that momentum change vector, divide
    by the magnitude of the initial system momentum, and multiply by 100 to make a
    percentage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传入的多粒子状态列表命名为`mpsts`，并使用Prelude函数`head`和`last`分别提取列表中的第一个和最后一个状态，将它们的系统动量命名为`p0`和`p1`。然后我们计算最终系统动量`p1`和初始系统动量`p0`之间的差值，形成该动量变化向量的大小，再除以初始系统动量的大小，最后乘以100得到百分比。
- en: Creating Tables
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建表格
- en: 'To see how well system momentum is conserved in our calculations, let’s make
    a small table showing the percent change in system momentum for a few different
    time steps and a few different spring constants. The table will appear unwieldy
    if I allow the computer to display all 15 digits that it keeps around for double
    precision floating-point numbers (numbers of type `R` that we have been calling
    real numbers). The following `sigFigs` function rounds a number to a specified
    number of significant figures:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看系统动量在我们计算中的保守情况，让我们做一个小表格，显示不同时间步长和不同弹簧常数下的系统动量的百分比变化。如果我让计算机显示它保存的所有15位数字（双精度浮点数，即我们称之为实数的`R`类型），表格会显得很难看。下面的`sigFigs`函数将一个数字四舍五入到指定的有效数字位数：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function works by dividing the input number `x` by 10^(*m*) for some integer
    *m*, rounding the number, and then re-multiplying the number by 10^(*m*). The
    integer *m* is called `expon` in the code; its value depends on the number `n`
    of significant figures requested. The Prelude function `round` has a quite general
    type; I specialize it to my needs by defining a local function `toInt` with a
    simple, concrete type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过将输入数字`x`除以10^(*m*)，其中*m*是某个整数，四舍五入该数字，然后再将数字乘以10^(*m*)来工作。整数*m*在代码中被称为`expon`；其值取决于请求的有效数字位数`n`。Prelude中的`round`函数有一个相当通用的类型；我通过定义一个局部函数`toInt`，使用一个简单的具体类型来专门化它以满足我的需求。
- en: The final tool we need to make cute little tables, which we will use for momentum,
    energy, and a few other things, is a data type for tables with a `Show` instance
    that makes them appear in a nicely formatted way. First, we define a new data
    type `Table a`, which is a table of items of type `a`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最终工具是用于制作可爱的表格的工具，我们将使用它来表示动量、能量以及其他一些内容，它是一个带有`Show`实例的数据类型，可以使表格以格式化的方式显示。首先，我们定义一个新的数据类型`Table
    a`，它是类型`a`的项目的表格。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The data type `Justification` is to specify whether we want a left-justified
    or right-justified table. A `Table a` contains a `Justification` along with a
    list of lists of items with type `a`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型`Justification`用于指定我们希望表格左对齐还是右对齐。一个`Table a`包含一个`Justification`和一个包含类型`a`的项目列表列表。
- en: We write an explicit show instance for the new data type that formats the output
    in a nice way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为新的数据类型编写了一个显式的`show`实例，以便以漂亮的方式格式化输出。
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the first line, we see a type class constraint; type `a` must be an instance
    of type class `Show` for `Table a` to be an instance of type class `Show`. An
    instance declaration for `Show` requires only that we define a function `show`
    that takes a `Table a` as input and produces a string as output. We define a local
    function `pairWithLength` that pairs the string representation of a value with
    the length of that string. We care about the length because we want to make columns
    that line up nicely. The local variable `pairss` is a list of lists of pairs of
    strings and lengths. The double *s* at the end of the name suggests a list of
    lists. We form `pairss` by mapping `map pairWithLength` onto the input list of
    lists, `xss`. Since each element of `xss` is a list, we apply `map pairWithLength`
    to each list in `xss`, so `pairWithLength` gets applied to each item in the list
    of lists.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们看到一个类型类约束；类型`a`必须是类型类`Show`的实例，才能使`Table a`成为类型类`Show`的实例。`Show`的实例声明只要求我们定义一个函数`show`，该函数以`Table
    a`作为输入，并产生一个字符串作为输出。我们定义了一个局部函数`pairWithLength`，它将值的字符串表示和该字符串的长度配对。我们关心长度是因为我们希望列能够整齐对齐。局部变量`pairss`是一个由字符串和长度对组成的列表的列表。名字末尾的双*s*表示这是一个列表的列表。我们通过将`map
    pairWithLength`映射到输入的列表列表`xss`来形成`pairss`。由于`xss`的每个元素都是一个列表，所以我们对`xss`中的每个列表应用`map
    pairWithLength`，因此`pairWithLength`会作用于列表中的每个项。
- en: The local variable `maxLength` finds the length of the longest item in the table.
    We then use this longest length to set the width of all the columns that will
    be displayed. We write local functions to show an individual item and a line of
    the table. Finally, we form the table by mapping `showLine` onto `pairss` and
    concatenating the results. If you find this trick for displaying tables interesting,
    by all means study it; otherwise, let’s move on and use it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量`maxLength`用于查找表格中最长项目的长度。然后，我们使用这个最长的长度来设置将要显示的所有列的宽度。我们编写局部函数来显示单个项目和表格中的一行。最后，我们通过将`showLine`应用于`pairss`并连接结果来形成表格。如果你觉得这个显示表格的小技巧有趣，可以尽情研究；否则，我们就继续使用它。
- en: 'Here are tables that show the percent change in momentum for the Euler, Euler-Cromer,
    and fourth-order Runge-Kutta methods for several values of spring constant and
    time step:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是展示欧拉法、欧拉-克罗梅法和四阶龙格-库塔法在不同弹簧常数和时间步长下动量百分比变化的表格：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can view these tables in GHCi.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GHCi中查看这些表格。
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Regardless of numerical method, spring constant, or time step, the percentage
    change in momentum is either 0 or something times 10^(–14). Since this is a percentage,
    we are really talking about a few parts in 10^(16), which is the accuracy of double-precision
    floating-point numbers. This deviation from 0 is not from the finite-step-size
    calculation we are doing; it’s because any calculation at all with floating-point
    numbers is approximate. The computer can’t divide by 10 exactly because it represents
    the fraction 1/10 with the repeating binary expansion 0.0001100110011 . . . (recall
    [Table 1-4](ch01.xhtml#ch1tab4)). A few parts in 10^(16) is the deviation from
    exactness we expect to see for any calculation that involves double-precision
    floating-point numbers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是数值方法、弹簧常数还是时间步长，动量的百分比变化要么为0，要么为某个数乘以10^(–14)。由于这是百分比变化，实际上我们谈论的是10^(16)分之一的几个部分，这就是双精度浮点数的精度。这个偏离0的误差并不是我们所做的有限步长计算导致的；而是因为任何使用浮点数的计算都是近似的。计算机无法精确地除以10，因为它用重复的二进制展开0.0001100110011
    . . . 来表示分数1/10（回想一下[表1-4](ch01.xhtml#ch1tab4)）。10^(16)分之一的几个部分是我们期望在任何涉及双精度浮点数的计算中看到的偏差。
- en: With this understanding, these tables are showing us that system momentum is
    conserved for the billiard collision for any numerical method, any spring constant,
    and any step size. This is an example of the claim made earlier that for any situation
    with only internal forces, system momentum is conserved regardless of numerical
    method, step size, or other parameters that describe the problem. Let’s now turn
    to look at the energy of a multi-particle system, which does not share this desirable
    property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，这些表格展示了无论使用哪种数值方法、弹簧常数或步长，台球碰撞系统的动量都是守恒的。这是之前提到的一个例子，说明在只有内力的情况下，系统动量会保持守恒，无论数值方法、步长或描述问题的其他参数如何。接下来，我们将研究多粒子系统的能量，这个系统不具备这种理想的属性。
- en: Energy Conservation
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 能量守恒
- en: With the exception of the short time in which the colliding objects are in contact
    with each other, the only form of energy present is the kinetic energy of the
    objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在碰撞物体接触的短时间内，系统中唯一的能量形式就是物体的动能。
- en: Let’s look at how system kinetic energy evolves in time for the billiard ball
    collision. During all of the time in which the collision is not occurring, kinetic
    energy will be conserved just fine because the velocities of the balls are not
    changing at all. During the short time in which the collision is occurring, some
    kinetic energy is transformed into elastic potential energy, held by our spring,
    before it is transformed back into kinetic energy. [Figure 20-3](ch20.xhtml#ch20fig3)
    shows a graph of system kinetic energy versus time for the collision of two billiard
    balls.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看台球碰撞中系统动能随时间的变化。只要碰撞没有发生，系统动能将完全守恒，因为球的速度没有变化。在碰撞发生的短时间内，一部分动能转化为弹性势能，由我们的弹簧储存，然后再转化回动能。[图20-3](ch20.xhtml#ch20fig3)展示了两颗台球碰撞时，系统动能与时间的关系图。
- en: '![Image](Images/382fig01.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/382fig01.jpg)'
- en: '*Figure 20-3: System kinetic energy for two billiard balls colliding*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-3：两颗台球碰撞时的系统动能*'
- en: We see that before the collision, which begins at a time of about 4.8 s, the
    system kinetic energy is conserved, as the incoming particle moves with a constant
    velocity. We see the expected dip in system kinetic energy as it is converted
    into elastic potential energy. The graph suggests that only about 40 percent of
    the system kinetic energy is so converted since it drops to about 1.9 mJ from
    its initial value of 3.2 mJ. As the spring expands from its state of maximal compression,
    elastic potential energy is converted back into kinetic energy, which remains
    constant after the collision.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在碰撞之前，大约在4.8秒时刻，系统动能是守恒的，因为进入的粒子以恒定速度运动。我们看到系统动能出现预期的下降，转化为弹性势能。图表显示，系统动能大约有40%的部分被转化为弹性势能，因为它从最初的3.2
    mJ降至约1.9 mJ。随着弹簧从最大压缩状态恢复，弹性势能转化回动能，碰撞后动能保持不变。
- en: In an elastic collision, the system kinetic energy after the collision should
    be the same as before the collision. We can see from the graph that system kinetic
    energy after the collision is close to, but not precisely, the same as before.
    This difference is a result of the finite step size of our method, and it depends
    on numerical method, step size, and other parameters of the situation. We see
    from the graph that the Euler-Cromer and fourth-order Runge-Kutta methods produce
    slightly different results, including slightly different results for the final
    system kinetic energy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹性碰撞中，碰撞后的系统动能应该与碰撞前相同。我们从图表中可以看到，碰撞后的系统动能接近，但不完全等于碰撞前的值。这一差异是由于我们方法的有限步长引起的，且它取决于数值方法、步长和其他情况参数。从图中我们可以看到，欧拉-克罗梅方法和四阶龙格-库塔方法产生了略微不同的结果，包括最终系统动能的略微不同的结果。
- en: The following code produced the graph in [Figure 20-3](ch20.xhtml#ch20fig3).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了[图20-3](ch20.xhtml#ch20fig3)中的图表。
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Local variables `timeKEPairsEC` and `timeKEPairsRK4` hold lists of pairs of
    time and system kinetic energy for the Euler-Cromer and fourth-order Runge-Kutta
    methods. We then plot these lists of pairs using gnuplot’s `plotPaths` function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量`timeKEPairsEC`和`timeKEPairsRK4`保存了欧拉-克罗梅和四阶龙格-库塔方法下时间和系统动能的对列表。我们然后使用gnuplot的`plotPaths`函数绘制这些对列表。
- en: The Effect of the Step Size and Spring Constant on Kinetic Energy
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步长和弹簧常数对动能的影响
- en: System kinetic energy does not share the nice property of system momentum that
    guarantees its conservation regardless of step size. An accurate calculation of
    energy, like most physical quantities, requires a reasonably small step size.
    In fact, looking at how well system kinetic energy is conserved is a good way
    to determine whether we are using a step size that is small enough.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 系统动能并不像系统动量那样具有保证其守恒的良好性质，无论步长大小。像大多数物理量一样，能量的精确计算需要一个合理小的步长。事实上，观察系统动能的守恒情况是判断我们是否使用了足够小步长的好方法。
- en: 'To study conservation of system kinetic energy for different step sizes and
    spring constants, let’s write a function that computes percent change in system
    kinetic energy. Since a list of states is a common information representation,
    we’ll use a finite list of multi-particle states for the input to this function,
    but we’ll only be comparing the first and last states in the list. Here is the
    function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究不同步长和弹簧常数下系统动能的守恒，我们编写了一个函数来计算系统动能的百分比变化。由于状态列表是一种常见的信息表示方法，我们将使用一个有限的多粒子状态列表作为此函数的输入，但我们只比较列表中的第一个和最后一个状态。下面是这个函数：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We name the incoming list of multi-particle states `mpsts` and use the Prelude
    functions `head` and `last` to pick out the first and last states in the list,
    giving their system kinetic energies the local names `ke0` and `ke1`, respectively.
    We proceed to take the difference between the final system kinetic energy `ke1`
    and the initial system kinetic energy `ke0`, divide by the initial system kinetic
    energy, and multiply by 100 to make a percentage.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传入的多粒子状态列表命名为`mpsts`，并使用Prelude函数`head`和`last`分别提取列表中的第一个和最后一个状态，将它们的系统动能分别命名为`ke0`和`ke1`。接着，我们计算最终系统动能`ke1`与初始系统动能`ke0`之差，除以初始系统动能，再乘以100以得到百分比。
- en: To explore conservation of kinetic energy, we’ll make some small tables showing
    the percent change in system kinetic energy for a few different time steps and
    a few different spring constants. The following `tenths` function rounds a number
    to one digit after the decimal point and helps to make a handsome table.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索动能守恒，我们将制作一些小表格，展示在几个不同的时间步长和弹簧常数下，系统动能的百分比变化。以下`tenths`函数将一个数字四舍五入到小数点后一个位，并有助于制作一个整齐的表格。
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function works by multiplying the input number `x` by 10, rounding the
    number, and then dividing the result by 10\. The Prelude function `round` has
    a quite general type; I specialize it to my needs by defining a local function
    `toInt` with a simple, concrete type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的工作原理是将输入数字`x`乘以10，四舍五入后，再将结果除以10。Prelude函数`round`具有非常通用的类型；我通过定义一个局部函数`toInt`并为其指定一个简单的具体类型来满足我的需求。
- en: The function `keTable` produces a table of percent change in system kinetic
    energy when given a numerical method, a list of spring constants, and a list of
    time steps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`keTable`在给定数值方法、弹簧常数列表和时间步长列表时，生成一个系统动能百分比变化的表格。
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can view these tables in GHCi.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在GHCi中查看这些表格。
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Conservation is best in the upper-left corner of each table, where time step
    and spring constant are both small. It is not surprising that a smaller time step
    produces better results. A smaller spring constant causes the collision to last
    longer, taking place over a larger number of time steps. A calculation in which
    a collision takes place over only a handful of time steps is unlikely to be very
    accurate. On the other hand, a spring constant that is too small runs the risk
    of allowing the objects to get too close to each other. We take up this concern
    in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个表格的左上角，动能守恒表现最好，此时时间步长和弹簧常数都较小。小时间步长带来的更好结果并不令人惊讶。较小的弹簧常数使碰撞持续时间更长，发生在更多的时间步长中。只有在少数几个时间步长内发生的碰撞，其计算结果不太可能非常精确。另一方面，弹簧常数过小则有可能使物体彼此靠得太近。我们将在下一节讨论这个问题。
- en: Numerical Issues
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数值问题
- en: We have suggested that an accurate calculation for a collision requires that
    multiple time steps take place during the collision. We have also noted that we
    don’t want the colliding objects to get too close to each other. These two desired
    properties for our calculation are in tension with each other because the first
    benefits from a small spring constant while the second benefits from a large spring
    constant. Let’s analyze these two desired properties in more detail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建议，对于碰撞的准确计算，碰撞过程中需要多个时间步长。我们还指出，我们不希望碰撞物体之间的距离过近。这两个对计算的期望性质是相互矛盾的，因为第一个性质更有利于较小的弹簧常数，而第二个性质则更有利于较大的弹簧常数。让我们更详细地分析这两种期望性质。
- en: Time Steps During Collision
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 碰撞过程中的时间步长
- en: As mentioned earlier, if only a handful of time steps, or worse yet, only one
    or zero, elapse over the course of the collision, we are unlikely to get accurate
    results. This observation motivates us to ask how many time steps take place during
    the collision, or equivalently how many time steps occur with the balls within
    the threshold separation. The answer to this question depends on numerical method,
    spring constant, and time step. We’d like a large number of time steps (for example,
    at least 10).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果在碰撞过程中仅经过少数几个时间步长，或者更糟，只有一个或零个时间步长，那么我们不太可能得到准确的结果。这一观察促使我们提出一个问题：碰撞过程中经过了多少个时间步长，或者等效地，多少个时间步长内小球的间隔在阈值范围内。这个问题的答案取决于数值方法、弹簧常数和时间步长。我们希望有一个较大的时间步长数量（例如，至少10个）。
- en: The function `contactSteps` returns the number of time steps during which the
    balls are within their threshold separation of 6 cm. It takes a finite list of
    multi-particle states as input.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`contactSteps`返回小球在其阈值间隔为6厘米时的时间步数。它接受一个有限的多粒子状态列表作为输入。
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function works by using `dropWhile` to discard the multi-particle states
    before there is contact between the balls; in other words, to discard the states
    before the balls come within 6 cm of each other. We use the `inContact` predicate,
    defined next, to decide whether, in a given multi-particle state, the balls are
    in contact, meaning that their centers are within 6 cm of each other. We then
    use `takeWhile` to keep the states in which the balls are in contact. Finally,
    we calculate the length of this list, which is the number of states, or time steps,
    in which the balls are in contact.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过使用`dropWhile`来丢弃球体之间尚未接触的多粒子状态；换句话说，丢弃在球体接近6厘米之前的状态。我们使用接下来定义的`inContact`谓词来判断在给定的多粒子状态中，球体是否接触，即它们的中心是否相距6厘米以内。然后我们使用`takeWhile`来保留球体接触的状态。最后，我们计算该列表的长度，即球体在接触中的状态数或时间步数。
- en: The predicate `inContact` works by calculating the distance between the particle
    centers and comparing it to the threshold separation of twice the ball radius
    (6 cm).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词`inContact`通过计算粒子中心之间的距离并将其与两倍球半径（6厘米）的阈值分离进行比较来工作。
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The function `contactTable` returns this number of time steps in contact for
    a numerical method, a list of spring constants, and a list of time steps.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`contactTable`返回数值方法中该时间步数的接触次数、弹簧常数列表和时间步长列表。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We use a list comprehension to form the list of lists that will get displayed
    as a table. Here are the results from GHCi:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导来形成将作为表格显示的列表列表。以下是来自GHCi的结果：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is not much difference among numerical methods. Regardless of numerical
    method, the best results appear in the upper-left corner of each table, where
    the spring constant and time step are both smallest. A small spring constant gives
    a loose (not stiff) spring, which compresses over a greater distance, allowing
    more time steps to take place during the collision.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法之间差别不大。不管采用哪种数值方法，最佳结果通常出现在每个表格的左上角，那里弹簧常数和时间步长都最小。较小的弹簧常数意味着弹簧比较松弛（而不是僵硬），可以在更长的距离内压缩，从而使碰撞过程中的时间步数更多。
- en: Something may strike you as strange in the lower-right corner of the Runge-Kutta
    table, corresponding to *k* = 100 N/m and *dt* = 0.1 s. How is it possible that
    no times take place within the threshold distance? It is not because the time
    step is so large that the moving ball completely skips over the stationary ball
    without colliding. Rather, it is because a fourth-order Runge-Kutta step is made
    up of four substeps, using derivatives at four different places to compute a final
    change in values for the time step. When the two balls are close but just outside
    the threshold separation, the Runge-Kutta step senses the repulsive force from
    one or more of the substeps. The spring constant is so large that a large repulsive
    force acts to repel the balls, and by the next actual time step, the balls have
    already repelled. So, the 0 listed in the table for number of time steps within
    the threshold separation is not so different from having one time step within
    the threshold; it’s not enough for an accurate calculation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Runge-Kutta表的右下角，可能会有一些奇怪的现象，尤其是当*k* = 100 N/m和*dt* = 0.1 s时。为什么在阈值距离内没有发生任何时间步？并不是因为时间步长太大，以至于运动的小球完全跳过了静止的小球而没有发生碰撞。实际上，这是因为四阶Runge-Kutta步由四个子步骤组成，使用在四个不同位置的导数来计算时间步的最终值变化。当两颗球接近但刚好在阈值分离之外时，Runge-Kutta步会感知到来自一个或多个子步骤的排斥力。弹簧常数非常大，导致一个很大的排斥力作用于球体，将球体推开，因此在下一个实际的时间步之前，球体已经被排斥开了。因此，表中列出的在阈值分离内的时间步数为0，并不比在阈值内有一个时间步数差别；这对于准确的计算来说并不够。
- en: Closest Separation
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最近分离
- en: We don’t want the centers of the balls to get too close to each other. If we
    use a very small spring constant, the balls may compress until their centers coincide,
    or even move past each other. This is certainly not how billiard balls work. Billiard
    balls hardly compress at all, so to model them accurately requires a fairly large
    spring constant.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望球心之间距离过近。如果我们使用一个非常小的弹簧常数，球体可能会压缩直到它们的球心重合，甚至穿越彼此。这显然不是台球的工作方式。台球几乎不会压缩，因此为了准确模拟它们，需要一个相当大的弹簧常数。
- en: It is interesting and important to know how close the ball centers get to each
    other, so we can avoid choosing a spring constant that is too small. We wish to
    know the minimum separation of the balls, center to center, that occurs during
    the collision. The answer to this question depends on numerical method, spring
    constant, and time step.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 了解球心之间的最小距离非常有趣也很重要，这样我们可以避免选择过小的弹簧常数。我们希望知道在碰撞过程中，球体中心到中心的最小分离距离。这个问题的答案取决于数值方法、弹簧常数和时间步长。
- en: The function `closest` returns the closest separation that the balls achieve
    during the collision. It takes a finite list of multi-particle states as input.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`closest`返回在碰撞过程中，球体达到的最小分离距离。它接受一个有限的多粒子状态列表作为输入。
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All this function does is apply the `separation` function below to each multi-particle
    state in the finite list and calculate the minimum.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用是对有限列表中的每个多粒子状态应用下面的`separation`函数，并计算最小值。
- en: The `separation` function works by finding the displacement between ball centers
    and computing its magnitude.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`separation`函数通过计算球心之间的位移并求其大小来工作。'
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function `closestTable` returns a table of closest separations when given
    a numerical method, a list of spring constants, and a list of time steps.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`closestTable`在给定数值方法、一系列弹簧常数和时间步长的情况下，返回一个最小分离距离的表格。
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We multiply by 100 to convert meters into centimeters, which are shown in the
    table.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将米转换为厘米，乘以100，结果显示在表格中。
- en: 'Here are the results from GHCi:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GHCi的结果：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If our goal is to have minimal compression, resulting in a large closest separation,
    the lower-left corner of each table is where we want to be. This suggests a large
    spring constant.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目标是最小化压缩，从而获得较大的最小分离距离，那么每个表格的左下角就是我们想要的位置。这意味着我们需要一个较大的弹簧常数。
- en: We see, in the lower-right corner of the Runge-Kutta table, a closest distance
    of 6.3 cm, which seems impossible. How can the balls repel if they never get within
    the threshold separation? Again, the answer is that a time step of fourth-order
    Runge-Kutta is based on four substeps, some of which sample the repulsive force
    inside the threshold distance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在Runge-Kutta表格的右下角，最小分离距离为6.3厘米，这看起来不可能。如果球体从未接近阈值分离距离，怎么会有反作用力呢？答案是，四阶Runge-Kutta时间步长是基于四个子步骤的，其中一些子步骤会在阈值距离内采样排斥力。
- en: Suppose we desire parameters (spring constant and time step) that produce at
    least 10 time steps during the collision, allow a closest separation of no less
    than 5 cm, and conserve kinetic energy within one percent.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一些参数（弹簧常数和时间步长），使得碰撞过程中至少有10个时间步，最小分离距离不小于5厘米，并且动能保持在1%的误差范围内。
- en: The Euler method is out. It doesn’t conserve kinetic energy to within one percent
    for any of the spring constants and time steps we sampled. Euler-Cromer could
    be used with *k* = 30 N/m and *dt* = 0.003 s or *dt* = 0.01 s, or with *k* = 100
    N/m and *dt* = 0.003 s. Fourth-order Runge-Kutta could be used with the same parameters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法不可用。对于我们采样的任何弹簧常数和时间步长，它无法保持动能在1%的误差范围内。Euler-Cromer方法可以在*k* = 30 N/m和*dt*
    = 0.003 s或*dt* = 0.01 s，或者*k* = 100 N/m和*dt* = 0.003 s的情况下使用。四阶Runge-Kutta也可以使用相同的参数。
- en: Animated Results
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动画结果
- en: We’d like to animate the collision of the billiard balls using gloss. We have
    already written a state-update function and an initial state. What remains is
    to write a display function, which we’ll do now.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用gloss为台球碰撞做动画。我们已经编写了一个状态更新函数和初始状态。接下来要做的是编写一个显示函数，我们现在就来实现。
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We use pattern matching on the input to give the name `sts` to the incoming
    list of single-particle states. This is a list with length 2 because there are
    two particles. Our display function uses the “scale the whole picture at the end”
    paradigm, using the `G.scale` function with the constant `ppm` as the number of
    pixels per meter for our one universal spatial scale factor. The pre-scaled picture
    is made with the `G.pictures` function, which combines a list of pictures, one
    for each ball. The list of pictures is formed using a list comprehension and the
    `place` function, to be defined in a few lines. This code could be used for a
    multi-particle system with any number of particles, as long as we are happy having
    each particle represented by a blue disk. (See Exercise 20.2 if you are offended
    by every particle being blue.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对输入进行模式匹配，将传入的单粒子状态列表命名为`sts`。这是一个长度为2的列表，因为有两个粒子。我们的显示函数采用“最后缩放整张图片”这一范式，使用`G.scale`函数，并将常数`ppm`作为每米像素数，作为我们统一空间尺度因子的值。预缩放的图片由`G.pictures`函数生成，该函数将每个球的图片列表组合起来。图片列表是通过列表推导和`place`函数生成的，`place`函数将在稍后的几行中定义。这段代码可以用于多粒子系统，粒子数量不限，只要我们接受每个粒子都由蓝色圆盘表示。（如果你不喜欢每个粒子都是蓝色的，可以参考第20.2题。）
- en: The remainder of the `billiardPicture` display function consists of local constants
    and functions defined after the `where` keyword. Recall that `where`, like the
    `let`-`in` construction, allows us to define local variables; the local variables
    are used before the `where` keyword and defined after. The local variables in
    a `let`-`in` construction are defined before the `in` keyword and used after.
    The difference between the `let`-`in` construction and the `where` construction
    is similar to the difference between bottom-up thinking, where we define the smallest
    pieces first and build upward to the whole function, and top-down thinking, where
    we define the whole function first in terms of pieces we have not yet defined.
    Haskell supports and encourages both kinds of thinking by supplying these two
    constructions and allowing us to make definitions in terms of as-yet-undefined
    constants and functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`billiardPicture`显示函数的其余部分由在`where`关键字之后定义的局部常量和函数组成。回想一下，`where`就像`let`-`in`结构一样，允许我们定义局部变量；局部变量在`where`关键字之前使用，在之后定义。`let`-`in`结构中的局部变量在`in`关键字之前定义，在之后使用。`let`-`in`结构与`where`结构的区别，就像是自下而上的思维方式——先定义最小的部分，再构建整个函数；和自上而下的思维方式——先定义整个函数，再通过尚未定义的部分来阐述。Haskell支持并鼓励这两种思维方式，通过提供这两种结构，允许我们以尚未定义的常量和函数来做定义。'
- en: The first local variable we define is the spatial scale factor `ppm`, which
    we set to 300 pixels per meter. Next, we define the local function `place`, which
    we have already used to translate a picture to the xy-coordinates specified in
    the position of the state. The function `place` uses the as-yet-undefined functions
    `xSt` and `ySt` to pull the coordinates out of a state, and the as-yet-undefined
    picture `blueBall` for a blue disk. The function `place` uses the `G.translate`
    function to translate the picture by the coordinates.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的第一个局部变量是空间尺度因子`ppm`，我们将其设置为每米300像素。接下来，我们定义了局部函数`place`，我们已经用它将图片移动到状态中指定的xy坐标位置。函数`place`使用尚未定义的函数`xSt`和`ySt`从状态中提取坐标，并使用尚未定义的图片`blueBall`表示一个蓝色圆盘。函数`place`通过`G.translate`函数根据坐标来平移图片。
- en: 'The local function `xSt` picks out the x-coordinate of position from the state
    and uses `realToFrac` to return a `Float`, which is the type that `G.translate`
    expects. The definition of `xSt` is written in point-free style, as a composition
    of three functions: `posVec`, which extracts the position from the state; `xComp`,
    which extracts the x-coordinate from the position; and `realToFrac`, which converts
    an `R` into a `Float`. The function `ySt` is just like `xSt` but for the y-coordinate.
    Finally, we define the local constant `blueBall` as a blue `disk` with radius
    `ballRadius`, which must get converted to a `Float` to match the expected input
    type of the `disk` function from [Chapter 17](ch17.xhtml).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数`xSt`从状态中提取x坐标位置，并使用`realToFrac`返回一个`Float`类型的值，这是`G.translate`所期望的类型。`xSt`的定义采用点自由风格，是由三个函数的组合：`posVec`，从状态中提取位置；`xComp`，从位置中提取x坐标；以及`realToFrac`，将`R`类型转换为`Float`类型。函数`ySt`与`xSt`类似，不过它用于提取y坐标。最后，我们定义了局部常量`blueBall`，它是一个半径为`ballRadius`的蓝色`disk`，必须将其转换为`Float`类型，以匹配[第17章](ch17.xhtml)中`disk`函数所期望的输入类型。
- en: '[Listing 20-3](ch20.xhtml#ch20list3) shows a stand-alone program that uses
    the `simulateGloss` function we wrote in [Chapter 16](ch16.xhtml). The stand-alone
    program consists of one definition: a main function called `main`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 20-3: Stand-alone program for a 2D animation of two billiard balls
    colliding*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function uses the imported `simulateGloss` function to perform the
    animation. We choose a time-scale factor of 1 and an animate rate of 100 frames/second,
    giving a time step of 0.01 s. We choose a spring constant of 30 N/m. We import
    the initial state `billiardInitial`, the state-update function `billiardUpdate`,
    and the display function `billiardPicture` from the `MOExamples` module we have
    been writing in this chapter. When you run the animation, you’ll see one blue
    billiard ball moving to the right collide with a stationary blue billiard ball.
    The originally moving ball moves downward after the collision, while the originally
    stationary ball moves up and to the right.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Wave on a Guitar String
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll model a wave on a guitar string. In particular, we’ll
    focus on the G string of a guitar. A typical G string has a mass of 0.8293 grams
    per meter. The distance from the neck of the guitar to the bottom, the two places
    where the string will stay fixed, is 65 cm. The fundamental vibration of the string,
    when played in an open position to make the note G, has a wavelength of 130 cm
    since the displacement of the string from equilibrium is a sine function that
    starts at 0 at the neck and returns to 0 at the bottom, completing only half a
    wavelength. Any open string on the guitar has 130 cm as the wavelength for its
    fundamental vibration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: We want a frequency of 196 Hz to make the note G. This is because convention
    dictates that frequencies of 55 Hz, 110 Hz, 220 Hz, 440 Hz, and 880 Hz each give
    some version of the note A. Doubling the frequency takes you to the same note,
    up one octave. The chromatic scale that people use has 12 “half steps” in one
    octave, or one doubling of the frequency. The note G is two half steps below A,
    so we must multiply the frequency of an A by 2^(–2/12) to get the frequency of
    a G. For the guitar, we multiply 2^(–2/12) by 220 Hz to get 196 Hz.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: For any wave, wavelength *λ* and period *t* are related to wave speed *v* by
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/390equ01.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: This equation is easiest to understand for a traveling wave (that is, one in
    which a wave crest simply travels along at speed *v*). For a traveling wave, the
    crest passes through one wavelength of distance during each period of time, so
    its speed is its wavelength divided by its period, which is what the equation
    claims. Frequency *f* and period *t* are related by
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/390equ02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: leading to the equation
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = *λf*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: relating wave speed, wavelength, and frequency.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '*Some people like to use the Greek letter *ν* (nu) for frequency, which allows
    them to respond to a common greeting with the following physics joke:*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '***Friend:*** *What’s new? (nu?)*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '***Jokester:*** *v over λ*!'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*Most people are unable to laugh outwardly at this joke, but surely they are
    laughing on the inside.*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Since the two ends of a guitar string are fixed, the guitar string exhibits
    standing waves rather than traveling waves, but the equations just shown are still
    useful because the wave speed is related to the tension *F* in the string and
    the mass per unit length *μ* by
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/391equ01.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: When we tune the guitar, we change the tension, which changes the wave speed,
    which changes the frequency. Let’s calculate the tension we need to achieve a
    frequency of 196 Hz.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: To achieve 196 Hz, we need a wave speed,
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = *λf* = (130 cm)(196 Hz) = 254.8 m/s'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'which requires a tension:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '*F* = *μv*² = (0.8293 g/m)(254.8 m/s)² = 53.84 N'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we need a tension of 53.84 N in the G string of our guitar.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Forces
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will model the guitar string as 64 little point masses, spaced 1 cm from
    each other along the 65-cm length. Each mass is linked by springs to its two nearest
    neighbors. If we give each spring an equilibrium length of zero and a spring constant
    of 5384 N/m, each spring will produce a force of 53.84 N when it is extended by
    1 cm, which is the distance between masses when the string is at rest. So, there
    will be 64 masses, 63 internal springs, and 2 external springs to connect to the
    two fixed ends at 0 cm and 65 cm. Here is the list of forces:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: State-Update Function
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make an animation, we need a state-update function, and for that we must
    choose a numerical method. Either Euler-Cromer or fourth-order Runge-Kutta would
    do just fine. Here we choose Runge-Kutta because it’s slightly more accurate.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Initial State
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll need an initial state. In fact, it is interesting to explore several different
    initial states of the string. The function `stringInitialOvertone` produces an
    initial state in which the string lies in the xy-plane, not initially moving,
    with a sinusoidal pattern.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using this function with an input of 1 produces the fundamental vibration we
    discussed earlier. [Figure 20-4](ch20.xhtml#ch20fig4) demonstrates what `stringInitialOvertone
    1` looks like.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/392fig01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-4: Initial state for the fundamental mode of vibration for a guitar
    string, given by stringInitialOvertone 1*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Higher numbers produce overtones that vibrate at higher frequencies. Using 2
    will produce an overtone that vibrates at 392 Hz, while 3 will produce one that
    vibrates at 588 Hz. [Figure 20-5](ch20.xhtml#ch20fig5) shows what `stringInitialOvertone
    3` looks like.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/393fig01.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-5: Initial state for the second overtone of a guitar string, given
    by stringInitialOvertone 3*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The sound you hear from a guitar string is a mixture of the fundamental frequency
    along with overtones. The initial state `stringInitialPluck` is intended to approximate
    a pluck of the guitar string.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Suppose the pick touches the string 51 cm from the neck, in front of the hole
    in the guitar body. If the pick moves the string 5 mm at that point, the resulting
    string shape is given by `stringInitialPluck`, as shown in [Figure 20-6](ch20.xhtml#ch20fig6).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/394fig01.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-6: Initial state for a pluck of the guitar string, given by string
    InitialPluck*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.10 asks you to write a function that produces an *xy* picture like
    this from a `MultiParticleState`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Stand-Alone Program
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 20-4](ch20.xhtml#ch20list4) shows a stand-alone program to make a
    2D animation of the wave on a guitar string.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 20-4: Stand-alone program for a 2D animation of a guitar string*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We use a time-scale factor of 0.001, meaning that 1 ms of physical time corresponds
    to 1 s of animation time. The code in [Listing 20-4](ch20.xhtml#ch20list4) uses
    the initial state `stringInitialOvertone 3`, but we could replace that initial
    state with `stringInitialOvertone 1` to animate the fundamental vibration or with
    `string` `InitialPluck` to animate the vibration resulting from a pluck. The fundamental
    frequency of 196 Hz represents a period of roughly 5 ms, so the fundamental vibration
    will take about 5 seconds of animation time to complete a period, while the overtone
    number 3 will take only 1.7 seconds of animation time to complete a period.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We use an animation rate of 40 frames/second, giving a time step of 25*μ*s.
    This choice is based on the important time scales of the problem. First, there
    is the period of the fundamental vibration, which is about 5 ms. The overtones
    have progressively shorter periods, namely
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ01.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Evidently, any finite time step we employ is going to lose some information
    about some of the higher overtones because their periods get arbitrarily small.
    (Our method of modeling the string with 64 masses also places limits on the number
    of overtones that can accurately be accounted for. Overtone number 200, for example,
    has about 100 crests and 100 troughs; we can’t possibly account for that if we’re
    only keeping track of the position of 64 masses.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the period of the fundamental vibration, one other time scale is very
    important to the vibrating string: the time it takes the wave to travel from one
    little mass to a neighboring mass. This time is given by the distance between
    masses divided by the wave speed.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ02.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: This time is about 40*μ*s, which is substantially shorter than the fundamental
    period.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: There is a stability criterion for wave situations or any situation that has
    a spatial step size Δ*x* in which information travels at a finite velocity. That
    criterion says that the time step must be smaller than the time it takes information
    to travel one spatial step.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ03.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: More about this stability criterion can be found in [**[18](bib.xhtml#bib18)**].
    Using a time step above this threshold runs the risk of a numerical instability
    that produces nonsensical results. [Figure 20-7](ch20.xhtml#ch20fig7) shows an
    example of numerical instability.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/396fig01.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-7: Example of numerical instability when the time step exceeds the
    time it takes information to travel between masses in the string. From top to
    bottom are three successive time steps.*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-7](ch20.xhtml#ch20fig7) shows the string for three successive time
    steps, numbers 10, 11, and 12, for a simulation with a time step of 100*μ*s, which
    is above the stability threshold. In just two time steps, the calculation goes
    from reasonable to ridiculous. The calculation with a 100-*μ*s time step is unstable.
    If we used this time step in an animation, the picture would rapidly become chaotic.
    I created the panels in [Figure 20-7](ch20.xhtml#ch20fig7) with the commands'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: where `mpsPos` is the function you are asked to write in Exercise 20.10.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The time step must be smaller than 40*μ*s, which is why we chose 25*μ*s earlier.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Animation
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The animations for the guitar string produced by gloss and not-gloss are on
    the edge of my computer’s ability to carry out gracefully. After the animation
    runs for a little while, the frames seem to update less quickly, indicating that
    the computer is having trouble doing all of the calculations we are asking of
    it while at the same time displaying the results. As we ask more and more of the
    computer, there will come a time when it cannot do all of the calculations we
    want at a rate that would it allow it to display the results at the same time.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: One solution for this situation is to use *asynchronous animation*, in which
    we do all of the calculations first and then sew the results together into a movie
    that we can watch later. [Listing 20-5](ch20.xhtml#ch20list5) shows a stand-alone
    program that creates 1,000 PNG files, each showing a picture of the guitar string,
    spaced at 25-*μ*s intervals. These can be combined into an MP4 movie with an external
    program such as ffmpeg.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 20-5: Stand-alone program for a 2D asynchronous animation of a flexible
    string*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The function `makePNG` takes as input an integer and a multi-particle state
    and produces a PNG file showing the position of the string. The purpose of the
    integer is to label the output file; 0 produces the file *GnuplotWave000.png*,
    8 produces the file *GnuplotWave008.png*, and 167 produces the file *Gnuplot Wave167.png*.
    Only integers between 0 and 999, inclusive, should be used with this function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by naming the incoming integer `n` and, using pattern matching
    on the input, the incoming list of single-particle states `sts`. The function
    then defines several local variables in the `let` construction. The local variable
    `rs` is a list of 66 position vectors describing the position of the string. The
    list consists of the positions of the 64 little masses, augmented with the fixed
    positions of the string at each end. The local function `xy` produces an (x, y)
    pair from a position. The list `xys`, formed by mapping `xy` onto the list `rs`
    of positions, is the list of pairs we will ask gnuplot to plot.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The local string `threeDigitString` is a three-digit string based on the integer
    `n` given as input. The function works by using `show` to convert `n` to a string,
    prepending that string with zeros, and then taking the last three digits. We take
    the last three digits by reversing the string, taking the first three digits with
    `take 3`, and then reversing back. The `threeDigitString` is then used as part
    of the filename `pngFilePath`. In the body of the `let` construction, we use gnuplot’s
    `plotPath` function to plot the pairs `xys` that we defined earlier. Since we
    intend to animate the frames that gnuplot produces, it’s important that we specify
    the `XRange` and `YRange` attributes so that each frame has the same range.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn our attention to the function `main`. We want to apply the function
    `makePNG` to each of 1,000 pairs of an integer with a multi-particle state. In
    an imperative language like Python, this would be an opportunity to use a loop.
    In a functional language like Haskell, this is an opportunity to use a list. The
    `main` function consists of several phrases separated by the function application
    operator `$`. Since this operator is right associative (recall [Table 1-2](ch01.xhtml#ch1tab2)),
    it’s easiest to read the definition of `main` from right to left. The rightmost
    phrase,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: is an infinite list of multi-particle states, starting with overtone number
    3, spaced 25*μ*s apart. Applying `zip [0..999]` to this infinite list produces
    a finite list, with each element being a pair of an integer and a multi-particle
    state. Applying `map makePNG` to this list of pairs produces a length-1,000 list
    with type `[IO ()]`. This is not the type we want the function `main` to have.
    We want `main` to have type `IO ()`, which simply means that it does something.
    Haskell provides a function `sequence_` to convert a list of actions into a single
    action.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the type of `sequence_`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are using `sequence_` in a context where the `Foldable` thing is a list,
    the `Monad` is `IO`, and the type variable `a` is unit, so the concrete type for
    `sequence_` in our use is
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: which is just what we need to produce the correct type for `main`. The function
    `sequence_` assembles a list of actions into a single action by sequencing them.
    The following command asks the external program ffmpeg to combine all PNG files
    named *GnuplotWaveDDD.png*, where the capital Ds are digits. We ask for a frame
    rate of 40 frames/second. The final movie is called *GnuplotWave.mp4*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要的来为`main`生成正确的类型。函数`sequence_`通过将一系列动作按顺序组合成一个单一的动作。以下命令要求外部程序ffmpeg将所有名为*GnuplotWaveDDD.png*的PNG文件合并，其中大写的D代表数字。我们要求帧率为每秒40帧。最终的视频文件名为*GnuplotWave.mp4*。
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the character after the percent sign is a zero and not the letter
    O. If you are using a Unix-like system, you can find documentation about ffmpeg,
    after you have installed it, with the command `man ffmpeg`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，百分号后面的字符是零，而不是字母O。如果你使用的是类Unix系统，可以在安装ffmpeg后通过命令`man ffmpeg`查阅相关文档。
- en: When we are doing asynchronous animation, we specify the time step and the animation
    rate rather than the time-scale factor and the animation rate.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行异步动画时，我们指定时间步长和动画速率，而不是时间尺度因子和动画速率。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we examined three physical situations involving multiple interacting
    particles, applying the theory and ideas of [Chapter 19](ch19.xhtml). The first
    situation, with two masses and two springs, contains two particles and both internal
    and external forces.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了涉及多个相互作用粒子的三种物理情况，并应用了[第19章](ch19.xhtml)的理论和概念。第一种情况，包含两个质量和两个弹簧，涉及两个粒子以及内部和外部力。
- en: Our second situation, a collision, has only internal forces and consequently
    conserves system momentum. We looked at conservation of momentum and energy in
    the context of the approximate numerical calculations we have been doing, and
    we found that momentum is conserved for all time steps, no matter how large. The
    collision also gave us an opportunity to look more deeply into numerical issues
    that affect the choice of technical parameters, such as the spring constant and
    time step.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二种情况，碰撞，仅涉及内部力，因此系统的动量得以守恒。我们在进行近似数值计算时，探讨了动量和能量的守恒，发现无论时间步长多大，动量始终是守恒的。碰撞也为我们提供了一个更深入探讨影响技术参数选择的数值问题的机会，例如弹簧常数和时间步长。
- en: Our third situation, the guitar string, involves many particles and suggests
    a transition into fields and waves. All along we have been discretizing time as
    a method to achieve practical results in mechanics problems; here, in using many
    particles to model a string, we are coming close to discretizing space as one
    would do to numerically solve field equations such as the Maxwell equations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三种情况，吉他弦，涉及多个粒子，并且暗示了向场和波动的过渡。一直以来，我们通过离散化时间来实现力学问题的实际结果；在这里，通过使用多个粒子来模拟弦，我们已接近于离散化空间，这与数值求解场方程（如麦克斯韦方程）的方法类似。
- en: '[Part II](part02.xhtml) of this book has dealt with Newtonian mechanics. Starting
    with a single particle moving in one dimension, we have slowly and steadily introduced
    ideas and code to deal with more and more sophisticated situations in mechanics.
    We talked about which mechanics problems can be solved with algebra, which require
    integration from calculus, and which require differential equations. We developed
    some general-purpose ways of solving systems of differential equations, and we
    put them to use in the service of mechanics. We took advantage of Haskell’s type
    system to make simple data structures, like 3D vectors, to construct a sequence
    of information representations that lead from problem specification to problem
    solution, and to create a modular system in which it is easy to switch out one
    numerical method for another. We viewed Newton’s second law as the rule for constructing
    a differential equation from a list of forces. We built Newton’s third law into
    the infrastructure for interacting particles so it gets automatically applied
    to all of the internal forces acting in a multi-particle situation. I hope that
    I have convinced you that a functional language is a fruitful way to express the
    ideas of mechanics alongside the ideas required for solving problems in mechanics.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the book explores electromagnetic theory. It begins with a
    chapter about Coulomb’s law, which fits nicely into the framework of interacting
    particles we have developed. Coulomb’s law, like Newton’s law of universal gravity,
    is expressed as an internal force between two particles.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 20.1.** What is the type of local variable `v` in the function `kineticEnergy`?
    What is the type of local variable `v` in the function `momentum`?'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.2.** The `billiardPicture` display function we wrote will display
    any number of balls, but they are all blue. If you want an animation with billiard
    balls of different colors, you can modify the `billiardPicture` function to cycle
    through a list of colors.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Make a new function `billiardPictureColors` by starting with a copy of `billiardPicture`
    and making the following changes. First, replace the local name `blueBall` with
    a local function `coloredBall` that takes a color as input. Next, modify the local
    function `place` to take a color as a second argument and use the new `coloredBall`
    function instead of `blueBall`. Finally, replace the list comprehension `[place
    st | st <- sts]` with
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The latter will cycle through the colors blue and red. You can change this list
    to cycle through as many colors as you want.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Modify the main billiard collision program to use your new display function,
    `billiardPictureColors`, and check that it works.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.3.** Using [Listing 20-3](ch20.xhtml#ch20list3) as a starting
    point, animate a two-body gravitational system such as the sun and Earth. In place
    of `billiardForces`, write a list of forces called `sunEarthForces` that contains
    the only force present: the universal gravity between the sun and Earth. In place
    of `billiardUpdate`, write an update function called `sunEarthUpdate`. In place
    of `billiardInitial`, write an initial state called `sunEarthInitial`, choosing
    appropriate values for the initial positions and velocities of the sun and Earth.
    In place of `billiard` `Picture`, write a display function called `sunEarthPicture`,
    making the sun yellow and Earth blue. You will not be able to display the size
    of the sun or Earth to scale with the orbital motion. Choose any convenient values
    for the object sizes. Choose a time-scale factor of `365*24*60` so that one year
    of physical time is one minute of animation time. Choose an animation rate of
    60 frames/second. Confirm that the orbital period is approximately one year by
    observing that it takes one minute for the animated Earth to complete a revolution
    around the sun.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.4.** In this problem, we investigate how Jupiter makes the sun
    wobble. We say that Jupiter orbits the sun because the sun is much more massive,
    but in a system consisting only of the sun and Jupiter, both objects orbit a point
    at the system’s center of mass. The center of mass is a weighted average of positions.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/401equ01.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: The distance between the sun and Jupiter is about 8 × 10^(11) m. The radius
    of the sun is 6.96 × 10⁸ m. The mass of the sun is 1.99 × 10^(30) kg. The mass
    of Jupiter is 1.90 × 10^(27) kg.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Placing the sun at the origin in the equation above, and looking only at the
    radial component of the vectors, we find that the center of mass
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/401equ02.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: lies slightly outside the radius of the sun. We should be able to see the sun
    orbit about this center of mass in an animation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Make an animation for the sun-Jupiter system using gloss or not-gloss. The only
    force is the universal gravity between the sun and Jupiter. Display the size of
    the sun to scale with the orbital motion, but zoom in on the sun, ignoring the
    display of Jupiter. If things go well, you should see the sun orbit a point slightly
    outside of its radius.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to include any of the center-of-mass calculations above to make
    this animation. However, for the center of mass to stay fixed, you will need to
    supply initial conditions that give zero momentum to the sun-Jupiter system. If
    you take the initial velocity of Jupiter to be in the y-direction, the sun will
    need to have a small initial velocity in the negative y-direction so that the
    total momentum is 0.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: To obtain an initial velocity estimate for Jupiter, you may assume that Jupiter’s
    orbit is circular and that the radius of its orbit is the same as the sun-Jupiter
    distance. (This is only off by 0.1 percent.)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.5.** Using realistic initial conditions, program an animation
    for the sun, Earth, and moon mutually interacting though gravity. The actual Earth-sun
    separation is about 500 times the Earth-moon separation, so you won’t be able
    to resolve the Earth and moon as separate objects on the screen. To be able to
    see where the moon is relative to Earth, I suggest the following: instead of displaying
    the moon at the position you calculate, display the moon at a fake position that
    has the correct orientation but is 50 times as far from Earth as you calculate.
    An equation to use to calculate a fake moon position is'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[FM] = **r**[E] + *A*(**r**[M] − **r**[E])'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: where **r**[FM] is the position of the fake moon, **r**[M] is the position of
    the (real) moon, **r**[E] is the position of Earth, and *A* is a magnification
    factor that artificially magnifies the vector from Earth to moon for display purposes.
    Try *A* = 50 and see what happens. Note that the fake moon need only appear in
    the display function. This situation should involve three internal forces and
    no external forces.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.6.** Using the `fixedLinearSpring` function, investigate a springy
    pendulum. Choose values for the spring constant *k*, the equilibrium length of
    the spring *r[e]*, and the mass *m*.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: (a) Confirm, with an animation or a graph, that placing the mass a distance
    *r[e]* + *mg*/*k* directly below the spot where the spring attaches to the ceiling,
    giving it no initial velocity, results in an equilibrium situation that allows
    the mass to hang motionless on the spring.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: (b) Choose an initial state in which the mass has no initial velocity and sits
    a distance *r[e]* directly below the spot where the spring attaches to the ceiling.
    In this situation, the spring initially exerts no force on the mass, but gravity
    does exert a force. Confirm, with an animation or a graph, that the mass oscillates
    with an angular frequency ![Image](Images/402equ01.jpg). This is equivalent to
    a period of ![Image](Images/402equ02.jpg).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: (c) Investigate the horizontal oscillation of a pendulum by placing the mass,
    with no initial velocity, a distance *r[e]* + *mg*/*k* from the ceiling attachment
    point, but not directly below that point. Allow the mass to evolve in time. Confirm,
    with an animation or a graph, that the angular frequency of oscillation is close
    to ![Image](Images/402equ03.jpg), with *l* = *r[e]* + *mg*/*k*, or, equivalently,
    that the period is ![Image](Images/402equ04.jpg).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: (d) Find an initial position and velocity for the mass so that it undergoes
    horizontal circular motion.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: (e) If you now change the parameters so that
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/402equ05.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: you may be able to find initial conditions in which the mass undergoes circular
    or elliptical motion in a vertical plane. See if this is possible.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.7.** Consider two equal-mass billiard balls traveling toward
    each other with equal and opposite velocities. If they travel directly toward
    each other, say along the x-axis, the collision will be one dimensional. If, on
    the other hand, their initial velocities are in the positive and negative x-direction,
    but there is a small y-component of displacement between them, the collision will
    be two dimensional. The angle at which the balls travel after the collision (which
    is the same for both balls because of the symmetry) depends on this initial y-component
    of displacement. There is some initial y-displacement that will produce a right
    angle. Find, by trial and error, this y-displacement for some spring constant
    and time step. It may not be what you expect. Try a different spring constant
    and/or time step. Can you explain why the y-displacement required to produce a
    right angle depends on the spring constant?'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.8.** Write an animation for the guitar string in which the string
    is modeled with 9 masses rather than 64\. The distance between masses will be
    6.5 cm rather than 1 cm. This increases the time-step stability threshold to 255*μ*s,
    so we can use a larger time step. We’re asking less of the computer, so the animation
    should run smoothly, even on older hardware. You’ll need to write new definitions
    for `forcesString`, `stringUpdate`, and `stringInitialOvertone`. The function
    `stringPicture` can remain the same. The spring constant for the springs will
    need to be different.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.9.** To see what an animation looks like when a numerical instability
    occurs, modify the gloss animation of the guitar string so that the time step
    is 100*μ*s. You can do this by increasing the time-scale factor or by decreasing
    the animation rate.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.10.** Write the functions'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: that use gnuplot to graph the x- and y-components of position (for the first
    function) and velocity (for the second) for a multi-particle state as if it was
    a guitar string. Functions like these can help with debugging. You can use them
    to visualize what happens in the first several time steps, giving you clues to
    what might be wrong when things aren’t working.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.11.** Write a 3D animation for the guitar string using `simulateVis`.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.12.** Make a 3D animation of the guitar string in which the motion
    looks like that of a jump rope. You should be able to do this by changing the
    initial state so that the masses that make up the string have some initial velocity.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.13.** Modify the function `makePNG` so that it uses four digits
    rather than three to label the output file. This allows for a longer animation
    of up to 10,000 frames. Test your function by making an animation of 2,000 frames.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.14.** Write code to produce graphs like those in [Figure 20-2](ch20.xhtml#ch20fig2).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.15.** Explore energy conservation for the guitar string. Mechanical
    energy should be conserved, but how well it is conserved depends on the time step.
    You will need to write an expression for the mechanical energy of this system.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.16.** Most of our animated results up to now have been based
    on a state-update function and have used the `simulateGloss` or `simulateVis`
    functions. There is a way to animate a list of states, and we’ll explore that
    now. The functions `animateGloss` and `animateVis` that follow take as input a
    time-scale factor, a display function, and a list of states, and they produce
    an animation. The time step for the animation is obtained from the list of states.
    We do not specify an animation rate; that is calculated from the time-scale factor
    and time step.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[Listing 20-6](ch20.xhtml#ch20list6) is a stand-alone program using `animateGloss`
    to make the animation.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 20-6: Stand-alone program for a 2D animation of two billiard balls
    colliding*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Write a stand-alone program using `animateVis` to make the animation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.17.** The billiard collision we studied in this chapter is an
    elastic collision. Any collision in which the only force is `billiardForce` must
    be an elastic collision. How can we produce an inelastic collision? We need some
    sort of two-body force that can dissipate energy. The following two-body force
    can provide dissipation in a collision:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When the distance between the particles is greater than or equal to the threshold
    separation, the particles feel no dissipation force. When the distance between
    the particles is less than the threshold separation, the particles feel a force
    proportional to the relative velocity in a direction that helps the relative velocity
    decrease in magnitude. Including this dissipation force along with `billiardForce`
    in the list of forces acting in a system results in an inelastic collision.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Revise the stand-alone program in [Listing 20-3](ch20.xhtml#ch20list3) to produce
    an inelastic collision. A damping constant of 4 kg/s should produce a totally
    inelastic collision.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that this collision is inelastic, make a graph of mechanical energy
    as a function of time. Since a non-conservative force is present, mechanical energy
    will not be conserved. Mechanical energy should be conserved before the collision,
    drop rapidly during the collision, and then maintain at a lower value after the
    collision.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
