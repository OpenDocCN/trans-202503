- en: '20'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPRINGS, BILLIARD BALLS, AND A GUITAR STRING
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter applies the ideas and theory of the previous chapter to three specific
    examples. The first is a system of two masses and two springs hanging from a fixed
    ceiling, the second is a billiard ball collision, and the third is a guitar string
    modeled as a long line of particles connected to their neighbors with springs.
  prefs: []
  type: TYPE_NORMAL
- en: A few things will be different in this chapter. We’ll take a closer look at
    the approximate numerical calculation we have been doing, treating numerical issues
    in more detail than we have in previous chapters. We’ll examine momentum and energy
    conservation in the context of approximate numerical calculation. We’ll also introduce
    a method for asynchronous animation where the calculations are done first and
    then made into a movie that can be watched afterward. Asynchronous animation is
    appropriate when the calculations get too intense to be done on the time scale
    of human impatience to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 20-1](ch20.xhtml#ch20list1) shows the introductory code for the `MOExamples`
    module we’ll develop in this chapter (*MO* for *Multiple Objects*). As usual,
    we import the functions and types we want to use in this module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-1: Opening lines of code for the MOExamples module*'
  prefs: []
  type: TYPE_NORMAL
- en: The types `ParticleState` and `MultiParticleState` are the state-description
    types we use for one particle and multiple particles, respectively. The function
    `newtonSecondMPS` creates a differential equation from a list of internal and
    external forces. The functions `euler`, `eulerCromerMPS`, and `rungeKutta4` are
    used to solve differential equations. We import the type class `HasTime` so we
    can use the `timeOf` function that belongs to it, and because we make explicit
    reference to `HasTime` in one of the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Two Masses and Two Springs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a first example of a system with multiple objects, let’s analyze the situation
    in [Figure 20-1](ch20.xhtml#ch20fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/365fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-1: A system of two masses and two springs*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 20-1](ch20.xhtml#ch20fig1) we have two masses and two springs. The
    upper spring is attached to a fixed ceiling and has spring constant *k*[1] and
    equilibrium length *re*[1]. The lower spring connects the two objects and has
    spring constant *k*[2] and equilibrium length *re*[2]. The upper object has mass
    *m*[0], and the lower object has mass *m*[1]. Earth surface gravity acts on each
    of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Forces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a total of four forces acting in this situation: three external forces
    and one internal force. The list `twoSpringsForces` contains the four forces,
    which we will describe in the order they are listed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since one end is fixed, the upper spring acts as an external force on object
    0\. The relevant one-body force is `fixedLinearSpring 100 0.5 zeroV`, the force
    from a linear spring with spring constant 100 N/m and equilibrium length 0.5 m
    attached to the ceiling at the origin. The lower spring acts as an internal force
    between objects 0 and 1\. It also has spring constant 100 N/m and equilibrium
    length 0.5 m. The last two forces describe the gravitational force Earth exerts
    on each of the two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’d like to animate the oscillation of the objects using not-gloss. We need
    to specify the five ingredients that serve as inputs to the `simulateVis` function:
    a time-scale factor, an animation rate, an initial state, a display function,
    and a state-update function. We choose a time-scale factor of 1 and an animation
    rate of 20 frames/second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial state, we must give the mass, initial position, and velocity
    of each object. We let ![Image](Images/366equ01.jpg) ![Image](Images/366equ01a.jpg)
    and **v**[1](0) = 0 m/s, where **r**[*j*] and **v**[*j*] are the position and
    velocity functions of particle *j*. The code for the initial state is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the `MPS` constructor, the one constructor for the `MultiParticleState`
    data type, to transform a list of single-particle states into a multi-particle
    state. We set the charge, time, and velocity of each particle to 0 since that
    is the value in `defaultParticleState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that involves most of the physics is `twoSpringsUpdate`, the state-update
    function for the system. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The time step gets the local name `dt`. Recall that, in animation, we do not
    choose the time step directly. We choose it indirectly through the time-scale
    factor and animation rate, and then the animation packages do their best to adhere
    to that rate, although they make no promises. Since the old state is not named
    on the left of the equal sign of the definition, the return type is `MultiParticleState
    -> MultiParticleState`. We use `updateMPS` to create the state-update function.
    It returns a state-update function when given a numerical method and a list of
    forces. We choose Euler-Cromer with time step `dt` as our numerical method, and
    we give the list of forces we wrote earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We have specified the time-scale factor, the animation rate, the initial state,
    and the state-update function we will use for our animation. We will discuss the
    display function next when we look at the stand-alone program for the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Stand-Alone Animation Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 20-2](ch20.xhtml#ch20list2) shows a stand-alone program for 3D animation
    of the two masses and two springs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-2: Stand-alone program for a 3D animation of two masses and two
    springs*'
  prefs: []
  type: TYPE_NORMAL
- en: The program begins by turning on warnings ➊ and then imports the needed types
    and functions. The program makes imports from the `SimpleVec` module of [Chapter
    10](ch10.xhtml), the `Mechanics3D` module of [Chapter 16](ch16.xhtml), the `Multiple`
    `Objects` module of [Chapter 19](ch19.xhtml), and the `MOExamples` module of the
    current chapter. It imports `zeroV` from the `SimpleVec` module to be able to
    refer to the origin, where a spring is attached. The program imports `R` because
    it is used in the type `VisObject R`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the imports from the `Mechanics3D` module. The program imports
    the `posVec` function, the extraction function of the `ParticleState` data type
    that returns the position vector of a particle state. The only state variable
    needed in the display function is position. None of the other state variables
    have anything to contribute to what the picture should look like for a given state.
    The program imports `simulateVis`, the principal function that produces the animation.
    The program also imports `v3FromVec` to convert a vector with type `Vec` into
    a vector with type `V3`, not-gloss’s vector type.
  prefs: []
  type: TYPE_NORMAL
- en: From the `MultipleObjects` module, we import the `MultiParticleState` type with
    its constructor so we can refer to the type in the type signature for the display
    function and use the constructor `MPS` to pattern match on the input in the definition
    of the display function. From the `MOExamples` module of the current chapter,
    we import the initial state and the state-update function, two of the five ingredients
    needed for an animation.
  prefs: []
  type: TYPE_NORMAL
- en: From the module `Vis`, the program imports the `VisObject` type with its constructors,
    which include `Line`, `Sphere`, `Trans`, `Scale`, and `VisObjects`. We import
    the `Flavour` type with its constructors because a sphere is required to be either
    solid or wire-frame, and the `Solid` data constructor we use is a constructor
    of `Flavour`. The program also imports the colors `red`, `green`, and `blue`.
  prefs: []
  type: TYPE_NORMAL
- en: The main program is named `main` and has type `IO ()`. It calls `simulateVis`
    with the five ingredients needed to make an animation, which includes the display
    function `twoSpringsVisObject` defined in the stand-alone program.
  prefs: []
  type: TYPE_NORMAL
- en: The display function `twoSpringsVisObject` produces a picture from the state
    of the system. The definition of the display function begins by pattern matching
    on the input so that the body of the function has access to the two-element list
    of single-particle states `sts` ➋. We give local names `r0` and `r1` to the positions
    of the two objects ➌ ➍. The local variable `springsObj` is a picture of two lines
    that represent the two springs ➎. To construct a picture of two lines, we use
    the `Line` data constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the type of `Line` in not-gloss.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `Line` has three inputs. The first has to do with line width. To get the
    default line width, in [Listing 20-2](ch20.xhtml#ch20list2) we supply `Nothing`
    for the first input ➎. The second input is a list of vectors, each vector having
    not-gloss’s native `V3 a` type. In our use, the type variable `a` stands for the
    type `R`. We convert from `Vec` to `V3 R` with `v3FromVec` ➎. The third input
    is a color, for which the program supplies `blue` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: We define `objs` to be a list of pictures of the two masses and the two springs
    ➐. The pictures of the masses are spheres, translated to the positions contained
    in the state.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a spatial-scale factor `vpm` to be 1 Vis-unit/meter ➑. Of course,
    scaling by 1 is unnecessary, but the code makes it easy to change the value to
    something else. Finally, `VisObjects` combines multiple pictures into a single
    picture and `Scale` scales the entire result ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mechanical Energy as a Guide to Numerical Accuracy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The system of two masses and two springs that we’ve been exploring should conserve
    mechanical energy. In this section, we’ll discuss the types of energy a system
    of particles can have, and we’ll see how to use energy as a tool to assess the
    accuracy of our numerical methods.
  prefs: []
  type: TYPE_NORMAL
- en: Kinetic Energy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each moving particle has an energy of motion called *kinetic energy*. The kinetic
    energy of a single particle is one half the particle’s mass multiplied by the
    square of its speed. We’ll use small capitals *KE* for the kinetic energy of a
    single particle. Kinetic energy is a scalar whose SI units are Joules (J).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/369equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The speed *v* = |**v**| is the magnitude of the velocity **v**. Here is a Haskell
    function that returns the kinetic energy of one particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The kinetic energy of a system of particles is the sum of the kinetic energies
    for each particle in the system. We use uppercase *KE* to denote system kinetic
    energy. In a system of particles, the kinetic energy of particle *n*, which has
    mass *m[n]* and velocity **v**[*n*], is given by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/369equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the system kinetic energy is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/369equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a Haskell function that returns the kinetic energy of a system of particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Potential Energy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some forces are distinguished in that they can be associated with a *potential
    energy*. Such forces are called *conservative* and include the elastic force of
    a spring and the force of gravity as examples.
  prefs: []
  type: TYPE_NORMAL
- en: A spring acquires potential energy by being compressed or extended from its
    equilibrium position. The spring can be used to store energy in this way. A linear
    spring with spring constant *k* that is displaced (compressed or extended) a distance
    *x* from its equilibrium position has a potential energy
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/370equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The type of potential energy associated with a spring is called *elastic potential
    energy*. The function `linearSpringPE` computes the elastic potential energy of
    a spring given its spring constant, equilibrium length, and particle states at
    each end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to the function `linearSpring` we wrote in [Chapter
    19](ch19.xhtml), except that instead of calculating a force, it calculates a potential
    energy. The displacement from equilibrium *x* in Equation 20.1 is the difference
    between the distance `r21mag` from one end of the spring to the other and the
    spring’s equilibrium length `re`.
  prefs: []
  type: TYPE_NORMAL
- en: An object near Earth’s surface has a *gravitational potential energy* that depends
    on its height. An object with mass *m* has potential energy
  prefs: []
  type: TYPE_NORMAL
- en: PE[*g*] = *mgh*
  prefs: []
  type: TYPE_NORMAL
- en: where *g* is Earth’s gravitational acceleration constant and *h* is the object’s
    height above some reference level, such as Earth’s surface. The function `earthSurfaceGravityPE`
    computes the gravitational potential energy of an object near Earth’s surface
    given its particle state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function is similar to the function `earthSurfaceGravity` we wrote in [Chapter
    16](ch16.xhtml), except that instead of calculating a force, it calculates a potential
    energy.
  prefs: []
  type: TYPE_NORMAL
- en: Returning now to the example of two masses and two springs, the total potential
    energy is the elastic potential energy of each spring plus the gravitational potential
    energy of each mass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the top spring is connected to a fixed ceiling, we use the default particle
    state for one end of the top spring to indicate that one end of the spring is
    fixed at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanical Energy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *mechanical energy* of a system of particles is the sum of its kinetic energy
    and its potential energy. Systems with no non-conservative forces conserve mechanical
    energy. The mechanical energy of such a system at a later time is the same as
    it was earlier. Since we are doing approximate calculation, we cannot expect that
    our calculation of mechanical energy will stay exactly the same over time. Since
    we know that it would stay the same if we could do exact calculation, we can take
    the deviation that occurs in our calculation as a guide to the level of inaccuracy
    our numerical method is producing. For a system that should conserve mechanical
    energy, how well it is conserved in our calculations is an indication of our numerical
    method’s accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The function `twoSpringsME` computes the mechanical energy for the system of
    two masses and two springs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Mechanical energy is conserved for this system because all of the forces involved
    are conservative. For the system of two masses and two springs, [Figure 20-2](ch20.xhtml#ch20fig2)
    shows mechanical energy as a function of time for different numerical methods.
    The first column shows the Euler method, the second the Euler-Cromer, and the
    third the fourth-order Runge-Kutta. The first row uses a time step of 0.1 s, the
    second row 0.01 s, the third row 10^(–3) s, and the fourth row 10^(–4) s.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/372fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-2: Mechanical energy as a function of time for different numerical
    methods. The change in mechanical energy is a measure of numerical inaccuracy.*'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanical energy tends to increase in the Euler method, oscillate in the Euler-Cromer
    method, and perhaps decrease in the fourth-order Runge-Kutta method. The horizontal
    axis shows a period of 10 seconds in each graph. The vertical axes show vastly
    different scales. If we take the difference between maximum mechanical energy
    and minimum mechanical energy over a 10-second time period as our measure of inaccuracy,
    we can make a table comparing the numerical methods. [Table 20-1](ch20.xhtml#ch20tab1)
    shows such a comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 20-1:** Change in Calculated Mechanical Energy for the Two-Mass and
    Two-Spring System over a 10-Second Interval for Different Numerical Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Time step** | **Euler** | **Euler-Cromer** | **4th order RK** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10^(–1)s | Way off | 40% | 7% |'
  prefs: []
  type: TYPE_TB
- en: '| 10^(–2)s | Way off | 4% | 10^(–4)% |'
  prefs: []
  type: TYPE_TB
- en: '| 10^(–3)s | 20% | 0.4% | 10^(–8)% |'
  prefs: []
  type: TYPE_TB
- en: '| 10^(–4)s | 2% | 0.04% | 10^(–11)% |'
  prefs: []
  type: TYPE_TB
- en: '[Table 20-1](ch20.xhtml#ch20tab1) shows maximum mechanical energy minus minimum
    mechanical energy over a 10-second period, expressed as a percentage of initial
    mechanical energy. The Euler method is not even close for time steps less than
    a millisecond. You can see this in the animation if you change the numerical method
    to the Euler method. The springs extend and droop in a horrible display of numerical
    inaccuracy. The table also shows how each 10-fold reduction in time step produces
    approximately a 10-fold improvement in accuracy for the two first-order methods,
    Euler and Euler-Cromer. A 10-fold decrease in time step for the fourth-order Runge-Kutta
    method produces a roughly 10⁴-fold improvement in accuracy. In this way, the fourth-order
    method shows why it is considered a fourth-order method.'
  prefs: []
  type: TYPE_NORMAL
- en: Having seen a first example of multiple interacting objects, let’s look at a
    second example of interacting objects, that of a collision.
  prefs: []
  type: TYPE_NORMAL
- en: A Collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our second example of multiple objects interacting is a collision between two
    billiard balls. For this example, we’ll go through the four data representations
    of [Figure 19-2](ch19.xhtml#ch19fig2), discuss the choice of parameters (including
    time step), look at momentum and energy conservation, discuss some numerical issues,
    and finally produce some animated results.
  prefs: []
  type: TYPE_NORMAL
- en: Data Representations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The four data representations are a list of forces, a differential equation,
    a state-update function, and a list of states. We’ll discuss each of these in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: Forces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We suppose that the elastic billiard interaction described in [Chapter 19](ch19.xhtml)
    is the only force that acts on either particle. This elastic billiard interaction
    is an internal force that acts between the two billiard balls. Here is the list
    of one force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The elastic billiard interaction requires that we specify a spring constant
    for the elastic repulsion and a threshold distance at which the repulsive force
    kicks in. We make the spring constant `k` an argument to the function `billiardForces`
    so we can delay committing to a particular value and so it will be easy to try
    out different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each ball has a diameter of 6 cm. The threshold distance occurs when the centers
    of the balls are two radii apart. Because it’s always the same, we specify a particular
    value, `2*ballRadius`, for the threshold distance rather than making it an argument
    like we did for the spring constant. We name the ball radius because it’s used
    in two places: the list of forces we just wrote and the display function we write
    later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Differential Equation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Newton’s second law transforms a list of forces into a differential equation.
    For multi-particle systems, `newtonSecondMPS` is the function that does this transformation.
    We give the name `billiardDiffEq k` to the differential equation that expresses
    Newton’s second law for two billiard balls acted on by `billiardForces k`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We continue to parameterize the differential equation by the spring constant
    `k` that we have not yet specified.
  prefs: []
  type: TYPE_NORMAL
- en: State-Update Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we need a state-update function. The simplest way to write a state-update
    function uses the `updateMPS` function of [Figure 19-2](ch19.xhtml#ch19fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This state-update function has the same form as others we have written, except
    that we included a numerical method and a spring constant as parameters so we
    can specify these items later. There are only three things that have type `TimeStep
    -> NumericalMethod MultiParticleState DMultiParticleState` and can serve for the
    input `nMethod`: `euler`, `eulerCromerMPS`, and `rungeKutta4`. We need to specify
    one of these when we use this function, but for now we’ll delay that decision.'
  prefs: []
  type: TYPE_NORMAL
- en: List of States
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The fourth data representation of [Figure 19-2](ch19.xhtml#ch19fig2) is an evolver,
    which is a function that will produce a list of states when given an initial state.
    The simplest way to write an evolver uses the `statesMPS` function of [Figure
    19-2](ch19.xhtml#ch19fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a list of states from an evolver requires an initial state. In the initial
    state, we give the masses of each object as well as their initial positions and
    velocities. We’ll let each billiard ball have a mass of 160 grams. The first ball
    starts at the origin with an initial velocity of 0.2 m/s in the x-direction. The
    second ball starts at rest at coordinates (1 m, 0.02 m) in the xy-plane. The small
    y-component is present so that the collision will be slightly oblique rather than
    one dimensional. The code for the initial state is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now name a list of states based on this initial state. The list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: is an infinite list of states for the billiard collision when the calculation
    is done with numerical method `nMethod` (`euler`, `eulerCromerMPS`, or `rungeKutta4`),
    spring constant `k`, and time step `dt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next we will want a finite list of states that we can use to make a graph, or
    to compare the value of some physical quantity, like momentum or kinetic energy,
    before the collision with the corresponding value after. The list `billiardStatesFinite
    nMethod k dt` is a finite list of states for the billiard collision when the calculation
    is done with numerical method `nMethod`, spring constant `k`, and time step `dt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To form the finite list, we use `takeWhile` to select all of the states before
    10 seconds elapse. As we will see soon, the collision occurs about 5 seconds into
    the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have delayed making any choices about numerical method, spring constant,
    or time step. Let’s turn to that issue next.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Constant and Time Step
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an introductory physics course, collisions are usually dealt with using conservation
    of momentum rather than by giving an explicit force for the interaction between
    two particles. Using conservation of momentum is elegant because we don’t need
    to know the force that acts between the particles; as long as it is short-lived,
    the system momentum before the collision must equal the system momentum after
    the collision. However, there are downsides to relying solely on conservation
    of momentum to analyze collisions. For example, for collisions in two dimensions,
    one usually needs information that is not present in the initial state of the
    system, such as the velocity of one of the particles *after* the collision, to
    find the velocities of both particles after the collision. If we know the nature
    of the force between the particles, on the other hand, then initial conditions
    suffice to determine the future motion of the particles.
  prefs: []
  type: TYPE_NORMAL
- en: On the practical side of things, our method of analyzing a collision by specifying
    an explicit force between the particles means that we need to make some choices.
    The elastic billiard collision requires that we specify a spring constant. Values
    that are too small or too large can introduce trouble for the numerical analysis
    of the collision with a finite time step. If the spring constant is too small,
    the objects will squish together during the collision, making their centers very
    close, and there is a risk that one object will pass through the other object
    instead of bouncing off of it. If the spring constant is too large, the spring
    will apply a very large force the first time the objects are within their separation
    threshold. The force may be so large that the objects may be outside their separation
    threshold by the very next time step. This would be a poor sampling of the force
    and could lead to poor numerical results.
  prefs: []
  type: TYPE_NORMAL
- en: If the time step is too large, one particle may move too far during one time
    step and entirely miss any state in which the particles are within their threshold
    separation. Even if the collision is not completely missed, a time step that is
    too large may give inaccurate results. Our general advice is to choose a time
    step that is small compared with the characteristic time scales of the situation.
  prefs: []
  type: TYPE_NORMAL
- en: We need to choose a spring constant for the interaction force in addition to
    the usual time step for numerical analysis. How should we choose these two things?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to choose a spring constant for the elastic interaction is to suppose
    that all of the initial kinetic energy of motion is transformed into potential
    energy in the spring. If this were true, we could write the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/377equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The separation threshold for the two billiard balls we are considering is 6
    cm; perhaps we would like the ball centers to get no closer than 5 cm to each
    other. Then the displacement from equilibrium should be no more than 1 cm. Using
    1 cm for *x* in the equation above and solving for *k* gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/377equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This calculation is a rough way of making a reasonable guess for a spring constant.
    The initial kinetic energy in this collision is only partially transformed into
    elastic potential energy.
  prefs: []
  type: TYPE_NORMAL
- en: What are the relevant time scales for the collision? One time scale is the time
    it takes the moving billiard ball to traverse a distance equal to the threshold
    separation. This time is given by the threshold separation divided by the initial
    velocity of the moving ball.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/377equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A second time scale comes from the spring constant and mass in the problem.
    If this were a problem in which the mass could oscillate on the spring, the period
    of oscillation would be proportional to ![Image](Images/377equ04.jpg). Oscillation
    will not occur in this situation, but the collision can be viewed as taking place
    over the course of half a period of the oscillation that would occur if this were
    a full-fledged spring. The half period consists of the compression of the spring
    from equilibrium to closest approach, followed by the expansion of the spring
    back to equilibrium. This second spring-based time scale is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/377equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The time step we choose for numerical analysis needs to be small compared with
    the smaller of the two time scales, namely 0.05 s. At this point, we have rough
    estimates for a spring constant and a time step. We will sharpen these estimates
    shortly, after we identify several desirable properties we want of our calculation
    and explore how these properties depend on the spring constant and time step.
    Two of the desirable properties are conservation of momentum and conservation
    of energy, which we look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Momentum and Energy Conservation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The basic wisdom about collisions that comes from an introductory physics course
    is that momentum is conserved in all collisions; however, energy is conserved
    only in *elastic collisions*. Our collision is elastic, so we expect both momentum
    and energy to be conserved.
  prefs: []
  type: TYPE_NORMAL
- en: Momentum Conservation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The momentum of a single particle is the particle’s mass multiplied by its velocity.
    The symbol **p** is conventionally used for momentum, which is a vector whose
    SI units are kg m/s.
  prefs: []
  type: TYPE_NORMAL
- en: '**p** = m**v**'
  prefs: []
  type: TYPE_NORMAL
- en: '(We saw in [Chapter 18](ch18.xhtml) that relativity theory uses a different
    definition of momentum, but in [Chapter 19](ch19.xhtml) and the current chapter,
    we’re focusing again on Newtonian mechanics.) Here is a Haskell function that
    returns the momentum of one particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The momentum of a system of particles is the vector sum of the momenta for each
    particle in the system. We use an uppercase **P** to denote system momentum. In
    a system of particles, the momentum of particle *n*, which has mass *m[n]* and
    velocity **v**[*n*], is given by
  prefs: []
  type: TYPE_NORMAL
- en: '**p**[*n*] = *m[n]***v**[*n*]'
  prefs: []
  type: TYPE_NORMAL
- en: and the system momentum is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/378equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here is a Haskell function that returns the momentum of a system of particles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In any system with only internal forces, the momentum of the system is conserved,
    meaning it stays the same over time. Our numerical calculations involve a finite
    time step, which must be small compared to characteristic time scales of the physical
    situation to give accurate results. Most quantities of physical interest become
    less and less accurate as the time step is increased. An exception is system momentum
    in the case where only internal forces are present. Our practice of categorizing
    forces as external or internal, along with our automatic application of Newton’s
    third law, guarantees that system momentum will be conserved in any situation
    without external forces, regardless of numerical method and regardless of time
    step. This is because each internal force, acting over the course of one time
    step, will change the momentum vector of one particle by some amount and the momentum
    vector of another particle by the opposite amount. System momentum does not change
    from time step to time step, even if the time step is so large that the results
    of the calculation are poor.
  prefs: []
  type: TYPE_NORMAL
- en: Even in collisions where external forces are present, system momentum is usually
    approximately conserved because the internal forces of collision are usually strong
    compared with any external forces. Since collisions are typically short-lived,
    the effect of external forces over the short duration of the collision is usually
    quite small.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm this conservation of system momentum, let’s write a function that
    computes percent change in system momentum. Since a list of states is a common
    information representation, we’ll use a finite list of multi-particle states for
    the input to this function, but we’ll only be comparing the first and last states
    in the list. Here is the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We name the incoming list of multi-particle states `mpsts`, and we use the Prelude
    functions `head` and `last` to pick out the first and last states in the list,
    giving their system momenta the local names `p0` and `p1`, respectively. We proceed
    to take the difference between the final system momentum `p1` and the initial
    system momentum `p0`, form the magnitude of that momentum change vector, divide
    by the magnitude of the initial system momentum, and multiply by 100 to make a
    percentage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To see how well system momentum is conserved in our calculations, let’s make
    a small table showing the percent change in system momentum for a few different
    time steps and a few different spring constants. The table will appear unwieldy
    if I allow the computer to display all 15 digits that it keeps around for double
    precision floating-point numbers (numbers of type `R` that we have been calling
    real numbers). The following `sigFigs` function rounds a number to a specified
    number of significant figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function works by dividing the input number `x` by 10^(*m*) for some integer
    *m*, rounding the number, and then re-multiplying the number by 10^(*m*). The
    integer *m* is called `expon` in the code; its value depends on the number `n`
    of significant figures requested. The Prelude function `round` has a quite general
    type; I specialize it to my needs by defining a local function `toInt` with a
    simple, concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: The final tool we need to make cute little tables, which we will use for momentum,
    energy, and a few other things, is a data type for tables with a `Show` instance
    that makes them appear in a nicely formatted way. First, we define a new data
    type `Table a`, which is a table of items of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The data type `Justification` is to specify whether we want a left-justified
    or right-justified table. A `Table a` contains a `Justification` along with a
    list of lists of items with type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: We write an explicit show instance for the new data type that formats the output
    in a nice way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we see a type class constraint; type `a` must be an instance
    of type class `Show` for `Table a` to be an instance of type class `Show`. An
    instance declaration for `Show` requires only that we define a function `show`
    that takes a `Table a` as input and produces a string as output. We define a local
    function `pairWithLength` that pairs the string representation of a value with
    the length of that string. We care about the length because we want to make columns
    that line up nicely. The local variable `pairss` is a list of lists of pairs of
    strings and lengths. The double *s* at the end of the name suggests a list of
    lists. We form `pairss` by mapping `map pairWithLength` onto the input list of
    lists, `xss`. Since each element of `xss` is a list, we apply `map pairWithLength`
    to each list in `xss`, so `pairWithLength` gets applied to each item in the list
    of lists.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable `maxLength` finds the length of the longest item in the table.
    We then use this longest length to set the width of all the columns that will
    be displayed. We write local functions to show an individual item and a line of
    the table. Finally, we form the table by mapping `showLine` onto `pairss` and
    concatenating the results. If you find this trick for displaying tables interesting,
    by all means study it; otherwise, let’s move on and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are tables that show the percent change in momentum for the Euler, Euler-Cromer,
    and fourth-order Runge-Kutta methods for several values of spring constant and
    time step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can view these tables in GHCi.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of numerical method, spring constant, or time step, the percentage
    change in momentum is either 0 or something times 10^(–14). Since this is a percentage,
    we are really talking about a few parts in 10^(16), which is the accuracy of double-precision
    floating-point numbers. This deviation from 0 is not from the finite-step-size
    calculation we are doing; it’s because any calculation at all with floating-point
    numbers is approximate. The computer can’t divide by 10 exactly because it represents
    the fraction 1/10 with the repeating binary expansion 0.0001100110011 . . . (recall
    [Table 1-4](ch01.xhtml#ch1tab4)). A few parts in 10^(16) is the deviation from
    exactness we expect to see for any calculation that involves double-precision
    floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, these tables are showing us that system momentum is
    conserved for the billiard collision for any numerical method, any spring constant,
    and any step size. This is an example of the claim made earlier that for any situation
    with only internal forces, system momentum is conserved regardless of numerical
    method, step size, or other parameters that describe the problem. Let’s now turn
    to look at the energy of a multi-particle system, which does not share this desirable
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Energy Conservation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the exception of the short time in which the colliding objects are in contact
    with each other, the only form of energy present is the kinetic energy of the
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how system kinetic energy evolves in time for the billiard ball
    collision. During all of the time in which the collision is not occurring, kinetic
    energy will be conserved just fine because the velocities of the balls are not
    changing at all. During the short time in which the collision is occurring, some
    kinetic energy is transformed into elastic potential energy, held by our spring,
    before it is transformed back into kinetic energy. [Figure 20-3](ch20.xhtml#ch20fig3)
    shows a graph of system kinetic energy versus time for the collision of two billiard
    balls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/382fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-3: System kinetic energy for two billiard balls colliding*'
  prefs: []
  type: TYPE_NORMAL
- en: We see that before the collision, which begins at a time of about 4.8 s, the
    system kinetic energy is conserved, as the incoming particle moves with a constant
    velocity. We see the expected dip in system kinetic energy as it is converted
    into elastic potential energy. The graph suggests that only about 40 percent of
    the system kinetic energy is so converted since it drops to about 1.9 mJ from
    its initial value of 3.2 mJ. As the spring expands from its state of maximal compression,
    elastic potential energy is converted back into kinetic energy, which remains
    constant after the collision.
  prefs: []
  type: TYPE_NORMAL
- en: In an elastic collision, the system kinetic energy after the collision should
    be the same as before the collision. We can see from the graph that system kinetic
    energy after the collision is close to, but not precisely, the same as before.
    This difference is a result of the finite step size of our method, and it depends
    on numerical method, step size, and other parameters of the situation. We see
    from the graph that the Euler-Cromer and fourth-order Runge-Kutta methods produce
    slightly different results, including slightly different results for the final
    system kinetic energy.
  prefs: []
  type: TYPE_NORMAL
- en: The following code produced the graph in [Figure 20-3](ch20.xhtml#ch20fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Local variables `timeKEPairsEC` and `timeKEPairsRK4` hold lists of pairs of
    time and system kinetic energy for the Euler-Cromer and fourth-order Runge-Kutta
    methods. We then plot these lists of pairs using gnuplot’s `plotPaths` function.
  prefs: []
  type: TYPE_NORMAL
- en: The Effect of the Step Size and Spring Constant on Kinetic Energy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: System kinetic energy does not share the nice property of system momentum that
    guarantees its conservation regardless of step size. An accurate calculation of
    energy, like most physical quantities, requires a reasonably small step size.
    In fact, looking at how well system kinetic energy is conserved is a good way
    to determine whether we are using a step size that is small enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'To study conservation of system kinetic energy for different step sizes and
    spring constants, let’s write a function that computes percent change in system
    kinetic energy. Since a list of states is a common information representation,
    we’ll use a finite list of multi-particle states for the input to this function,
    but we’ll only be comparing the first and last states in the list. Here is the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We name the incoming list of multi-particle states `mpsts` and use the Prelude
    functions `head` and `last` to pick out the first and last states in the list,
    giving their system kinetic energies the local names `ke0` and `ke1`, respectively.
    We proceed to take the difference between the final system kinetic energy `ke1`
    and the initial system kinetic energy `ke0`, divide by the initial system kinetic
    energy, and multiply by 100 to make a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: To explore conservation of kinetic energy, we’ll make some small tables showing
    the percent change in system kinetic energy for a few different time steps and
    a few different spring constants. The following `tenths` function rounds a number
    to one digit after the decimal point and helps to make a handsome table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function works by multiplying the input number `x` by 10, rounding the
    number, and then dividing the result by 10\. The Prelude function `round` has
    a quite general type; I specialize it to my needs by defining a local function
    `toInt` with a simple, concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: The function `keTable` produces a table of percent change in system kinetic
    energy when given a numerical method, a list of spring constants, and a list of
    time steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can view these tables in GHCi.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Conservation is best in the upper-left corner of each table, where time step
    and spring constant are both small. It is not surprising that a smaller time step
    produces better results. A smaller spring constant causes the collision to last
    longer, taking place over a larger number of time steps. A calculation in which
    a collision takes place over only a handful of time steps is unlikely to be very
    accurate. On the other hand, a spring constant that is too small runs the risk
    of allowing the objects to get too close to each other. We take up this concern
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Issues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have suggested that an accurate calculation for a collision requires that
    multiple time steps take place during the collision. We have also noted that we
    don’t want the colliding objects to get too close to each other. These two desired
    properties for our calculation are in tension with each other because the first
    benefits from a small spring constant while the second benefits from a large spring
    constant. Let’s analyze these two desired properties in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Time Steps During Collision
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned earlier, if only a handful of time steps, or worse yet, only one
    or zero, elapse over the course of the collision, we are unlikely to get accurate
    results. This observation motivates us to ask how many time steps take place during
    the collision, or equivalently how many time steps occur with the balls within
    the threshold separation. The answer to this question depends on numerical method,
    spring constant, and time step. We’d like a large number of time steps (for example,
    at least 10).
  prefs: []
  type: TYPE_NORMAL
- en: The function `contactSteps` returns the number of time steps during which the
    balls are within their threshold separation of 6 cm. It takes a finite list of
    multi-particle states as input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The function works by using `dropWhile` to discard the multi-particle states
    before there is contact between the balls; in other words, to discard the states
    before the balls come within 6 cm of each other. We use the `inContact` predicate,
    defined next, to decide whether, in a given multi-particle state, the balls are
    in contact, meaning that their centers are within 6 cm of each other. We then
    use `takeWhile` to keep the states in which the balls are in contact. Finally,
    we calculate the length of this list, which is the number of states, or time steps,
    in which the balls are in contact.
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `inContact` works by calculating the distance between the particle
    centers and comparing it to the threshold separation of twice the ball radius
    (6 cm).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The function `contactTable` returns this number of time steps in contact for
    a numerical method, a list of spring constants, and a list of time steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a list comprehension to form the list of lists that will get displayed
    as a table. Here are the results from GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There is not much difference among numerical methods. Regardless of numerical
    method, the best results appear in the upper-left corner of each table, where
    the spring constant and time step are both smallest. A small spring constant gives
    a loose (not stiff) spring, which compresses over a greater distance, allowing
    more time steps to take place during the collision.
  prefs: []
  type: TYPE_NORMAL
- en: Something may strike you as strange in the lower-right corner of the Runge-Kutta
    table, corresponding to *k* = 100 N/m and *dt* = 0.1 s. How is it possible that
    no times take place within the threshold distance? It is not because the time
    step is so large that the moving ball completely skips over the stationary ball
    without colliding. Rather, it is because a fourth-order Runge-Kutta step is made
    up of four substeps, using derivatives at four different places to compute a final
    change in values for the time step. When the two balls are close but just outside
    the threshold separation, the Runge-Kutta step senses the repulsive force from
    one or more of the substeps. The spring constant is so large that a large repulsive
    force acts to repel the balls, and by the next actual time step, the balls have
    already repelled. So, the 0 listed in the table for number of time steps within
    the threshold separation is not so different from having one time step within
    the threshold; it’s not enough for an accurate calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Closest Separation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We don’t want the centers of the balls to get too close to each other. If we
    use a very small spring constant, the balls may compress until their centers coincide,
    or even move past each other. This is certainly not how billiard balls work. Billiard
    balls hardly compress at all, so to model them accurately requires a fairly large
    spring constant.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting and important to know how close the ball centers get to each
    other, so we can avoid choosing a spring constant that is too small. We wish to
    know the minimum separation of the balls, center to center, that occurs during
    the collision. The answer to this question depends on numerical method, spring
    constant, and time step.
  prefs: []
  type: TYPE_NORMAL
- en: The function `closest` returns the closest separation that the balls achieve
    during the collision. It takes a finite list of multi-particle states as input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: All this function does is apply the `separation` function below to each multi-particle
    state in the finite list and calculate the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The `separation` function works by finding the displacement between ball centers
    and computing its magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The function `closestTable` returns a table of closest separations when given
    a numerical method, a list of spring constants, and a list of time steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We multiply by 100 to convert meters into centimeters, which are shown in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results from GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If our goal is to have minimal compression, resulting in a large closest separation,
    the lower-left corner of each table is where we want to be. This suggests a large
    spring constant.
  prefs: []
  type: TYPE_NORMAL
- en: We see, in the lower-right corner of the Runge-Kutta table, a closest distance
    of 6.3 cm, which seems impossible. How can the balls repel if they never get within
    the threshold separation? Again, the answer is that a time step of fourth-order
    Runge-Kutta is based on four substeps, some of which sample the repulsive force
    inside the threshold distance.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we desire parameters (spring constant and time step) that produce at
    least 10 time steps during the collision, allow a closest separation of no less
    than 5 cm, and conserve kinetic energy within one percent.
  prefs: []
  type: TYPE_NORMAL
- en: The Euler method is out. It doesn’t conserve kinetic energy to within one percent
    for any of the spring constants and time steps we sampled. Euler-Cromer could
    be used with *k* = 30 N/m and *dt* = 0.003 s or *dt* = 0.01 s, or with *k* = 100
    N/m and *dt* = 0.003 s. Fourth-order Runge-Kutta could be used with the same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Animated Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’d like to animate the collision of the billiard balls using gloss. We have
    already written a state-update function and an initial state. What remains is
    to write a display function, which we’ll do now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We use pattern matching on the input to give the name `sts` to the incoming
    list of single-particle states. This is a list with length 2 because there are
    two particles. Our display function uses the “scale the whole picture at the end”
    paradigm, using the `G.scale` function with the constant `ppm` as the number of
    pixels per meter for our one universal spatial scale factor. The pre-scaled picture
    is made with the `G.pictures` function, which combines a list of pictures, one
    for each ball. The list of pictures is formed using a list comprehension and the
    `place` function, to be defined in a few lines. This code could be used for a
    multi-particle system with any number of particles, as long as we are happy having
    each particle represented by a blue disk. (See Exercise 20.2 if you are offended
    by every particle being blue.)
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the `billiardPicture` display function consists of local constants
    and functions defined after the `where` keyword. Recall that `where`, like the
    `let`-`in` construction, allows us to define local variables; the local variables
    are used before the `where` keyword and defined after. The local variables in
    a `let`-`in` construction are defined before the `in` keyword and used after.
    The difference between the `let`-`in` construction and the `where` construction
    is similar to the difference between bottom-up thinking, where we define the smallest
    pieces first and build upward to the whole function, and top-down thinking, where
    we define the whole function first in terms of pieces we have not yet defined.
    Haskell supports and encourages both kinds of thinking by supplying these two
    constructions and allowing us to make definitions in terms of as-yet-undefined
    constants and functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first local variable we define is the spatial scale factor `ppm`, which
    we set to 300 pixels per meter. Next, we define the local function `place`, which
    we have already used to translate a picture to the xy-coordinates specified in
    the position of the state. The function `place` uses the as-yet-undefined functions
    `xSt` and `ySt` to pull the coordinates out of a state, and the as-yet-undefined
    picture `blueBall` for a blue disk. The function `place` uses the `G.translate`
    function to translate the picture by the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local function `xSt` picks out the x-coordinate of position from the state
    and uses `realToFrac` to return a `Float`, which is the type that `G.translate`
    expects. The definition of `xSt` is written in point-free style, as a composition
    of three functions: `posVec`, which extracts the position from the state; `xComp`,
    which extracts the x-coordinate from the position; and `realToFrac`, which converts
    an `R` into a `Float`. The function `ySt` is just like `xSt` but for the y-coordinate.
    Finally, we define the local constant `blueBall` as a blue `disk` with radius
    `ballRadius`, which must get converted to a `Float` to match the expected input
    type of the `disk` function from [Chapter 17](ch17.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 20-3](ch20.xhtml#ch20list3) shows a stand-alone program that uses
    the `simulateGloss` function we wrote in [Chapter 16](ch16.xhtml). The stand-alone
    program consists of one definition: a main function called `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-3: Stand-alone program for a 2D animation of two billiard balls
    colliding*'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function uses the imported `simulateGloss` function to perform the
    animation. We choose a time-scale factor of 1 and an animate rate of 100 frames/second,
    giving a time step of 0.01 s. We choose a spring constant of 30 N/m. We import
    the initial state `billiardInitial`, the state-update function `billiardUpdate`,
    and the display function `billiardPicture` from the `MOExamples` module we have
    been writing in this chapter. When you run the animation, you’ll see one blue
    billiard ball moving to the right collide with a stationary blue billiard ball.
    The originally moving ball moves downward after the collision, while the originally
    stationary ball moves up and to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Wave on a Guitar String
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll model a wave on a guitar string. In particular, we’ll
    focus on the G string of a guitar. A typical G string has a mass of 0.8293 grams
    per meter. The distance from the neck of the guitar to the bottom, the two places
    where the string will stay fixed, is 65 cm. The fundamental vibration of the string,
    when played in an open position to make the note G, has a wavelength of 130 cm
    since the displacement of the string from equilibrium is a sine function that
    starts at 0 at the neck and returns to 0 at the bottom, completing only half a
    wavelength. Any open string on the guitar has 130 cm as the wavelength for its
    fundamental vibration.
  prefs: []
  type: TYPE_NORMAL
- en: We want a frequency of 196 Hz to make the note G. This is because convention
    dictates that frequencies of 55 Hz, 110 Hz, 220 Hz, 440 Hz, and 880 Hz each give
    some version of the note A. Doubling the frequency takes you to the same note,
    up one octave. The chromatic scale that people use has 12 “half steps” in one
    octave, or one doubling of the frequency. The note G is two half steps below A,
    so we must multiply the frequency of an A by 2^(–2/12) to get the frequency of
    a G. For the guitar, we multiply 2^(–2/12) by 220 Hz to get 196 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: For any wave, wavelength *λ* and period *t* are related to wave speed *v* by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/390equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This equation is easiest to understand for a traveling wave (that is, one in
    which a wave crest simply travels along at speed *v*). For a traveling wave, the
    crest passes through one wavelength of distance during each period of time, so
    its speed is its wavelength divided by its period, which is what the equation
    claims. Frequency *f* and period *t* are related by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/390equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: leading to the equation
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = *λf*'
  prefs: []
  type: TYPE_NORMAL
- en: relating wave speed, wavelength, and frequency.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs: []
  type: TYPE_NORMAL
- en: '*Some people like to use the Greek letter *ν* (nu) for frequency, which allows
    them to respond to a common greeting with the following physics joke:*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Friend:*** *What’s new? (nu?)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Jokester:*** *v over λ*!'
  prefs: []
  type: TYPE_NORMAL
- en: '*Most people are unable to laugh outwardly at this joke, but surely they are
    laughing on the inside.*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the two ends of a guitar string are fixed, the guitar string exhibits
    standing waves rather than traveling waves, but the equations just shown are still
    useful because the wave speed is related to the tension *F* in the string and
    the mass per unit length *μ* by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/391equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we tune the guitar, we change the tension, which changes the wave speed,
    which changes the frequency. Let’s calculate the tension we need to achieve a
    frequency of 196 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve 196 Hz, we need a wave speed,
  prefs: []
  type: TYPE_NORMAL
- en: '*v* = *λf* = (130 cm)(196 Hz) = 254.8 m/s'
  prefs: []
  type: TYPE_NORMAL
- en: 'which requires a tension:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F* = *μv*² = (0.8293 g/m)(254.8 m/s)² = 53.84 N'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we need a tension of 53.84 N in the G string of our guitar.
  prefs: []
  type: TYPE_NORMAL
- en: Forces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will model the guitar string as 64 little point masses, spaced 1 cm from
    each other along the 65-cm length. Each mass is linked by springs to its two nearest
    neighbors. If we give each spring an equilibrium length of zero and a spring constant
    of 5384 N/m, each spring will produce a force of 53.84 N when it is extended by
    1 cm, which is the distance between masses when the string is at rest. So, there
    will be 64 masses, 63 internal springs, and 2 external springs to connect to the
    two fixed ends at 0 cm and 65 cm. Here is the list of forces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: State-Update Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make an animation, we need a state-update function, and for that we must
    choose a numerical method. Either Euler-Cromer or fourth-order Runge-Kutta would
    do just fine. Here we choose Runge-Kutta because it’s slightly more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Initial State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll need an initial state. In fact, it is interesting to explore several different
    initial states of the string. The function `stringInitialOvertone` produces an
    initial state in which the string lies in the xy-plane, not initially moving,
    with a sinusoidal pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using this function with an input of 1 produces the fundamental vibration we
    discussed earlier. [Figure 20-4](ch20.xhtml#ch20fig4) demonstrates what `stringInitialOvertone
    1` looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/392fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-4: Initial state for the fundamental mode of vibration for a guitar
    string, given by stringInitialOvertone 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Higher numbers produce overtones that vibrate at higher frequencies. Using 2
    will produce an overtone that vibrates at 392 Hz, while 3 will produce one that
    vibrates at 588 Hz. [Figure 20-5](ch20.xhtml#ch20fig5) shows what `stringInitialOvertone
    3` looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/393fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-5: Initial state for the second overtone of a guitar string, given
    by stringInitialOvertone 3*'
  prefs: []
  type: TYPE_NORMAL
- en: The sound you hear from a guitar string is a mixture of the fundamental frequency
    along with overtones. The initial state `stringInitialPluck` is intended to approximate
    a pluck of the guitar string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the pick touches the string 51 cm from the neck, in front of the hole
    in the guitar body. If the pick moves the string 5 mm at that point, the resulting
    string shape is given by `stringInitialPluck`, as shown in [Figure 20-6](ch20.xhtml#ch20fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/394fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-6: Initial state for a pluck of the guitar string, given by string
    InitialPluck*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.10 asks you to write a function that produces an *xy* picture like
    this from a `MultiParticleState`.
  prefs: []
  type: TYPE_NORMAL
- en: Stand-Alone Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 20-4](ch20.xhtml#ch20list4) shows a stand-alone program to make a
    2D animation of the wave on a guitar string.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-4: Stand-alone program for a 2D animation of a guitar string*'
  prefs: []
  type: TYPE_NORMAL
- en: We use a time-scale factor of 0.001, meaning that 1 ms of physical time corresponds
    to 1 s of animation time. The code in [Listing 20-4](ch20.xhtml#ch20list4) uses
    the initial state `stringInitialOvertone 3`, but we could replace that initial
    state with `stringInitialOvertone 1` to animate the fundamental vibration or with
    `string` `InitialPluck` to animate the vibration resulting from a pluck. The fundamental
    frequency of 196 Hz represents a period of roughly 5 ms, so the fundamental vibration
    will take about 5 seconds of animation time to complete a period, while the overtone
    number 3 will take only 1.7 seconds of animation time to complete a period.
  prefs: []
  type: TYPE_NORMAL
- en: We use an animation rate of 40 frames/second, giving a time step of 25*μ*s.
    This choice is based on the important time scales of the problem. First, there
    is the period of the fundamental vibration, which is about 5 ms. The overtones
    have progressively shorter periods, namely
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Evidently, any finite time step we employ is going to lose some information
    about some of the higher overtones because their periods get arbitrarily small.
    (Our method of modeling the string with 64 masses also places limits on the number
    of overtones that can accurately be accounted for. Overtone number 200, for example,
    has about 100 crests and 100 troughs; we can’t possibly account for that if we’re
    only keeping track of the position of 64 masses.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the period of the fundamental vibration, one other time scale is very
    important to the vibrating string: the time it takes the wave to travel from one
    little mass to a neighboring mass. This time is given by the distance between
    masses divided by the wave speed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This time is about 40*μ*s, which is substantially shorter than the fundamental
    period.
  prefs: []
  type: TYPE_NORMAL
- en: There is a stability criterion for wave situations or any situation that has
    a spatial step size Δ*x* in which information travels at a finite velocity. That
    criterion says that the time step must be smaller than the time it takes information
    to travel one spatial step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/395equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More about this stability criterion can be found in [**[18](bib.xhtml#bib18)**].
    Using a time step above this threshold runs the risk of a numerical instability
    that produces nonsensical results. [Figure 20-7](ch20.xhtml#ch20fig7) shows an
    example of numerical instability.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/396fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 20-7: Example of numerical instability when the time step exceeds the
    time it takes information to travel between masses in the string. From top to
    bottom are three successive time steps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-7](ch20.xhtml#ch20fig7) shows the string for three successive time
    steps, numbers 10, 11, and 12, for a simulation with a time step of 100*μ*s, which
    is above the stability threshold. In just two time steps, the calculation goes
    from reasonable to ridiculous. The calculation with a 100-*μ*s time step is unstable.
    If we used this time step in an animation, the picture would rapidly become chaotic.
    I created the panels in [Figure 20-7](ch20.xhtml#ch20fig7) with the commands'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: where `mpsPos` is the function you are asked to write in Exercise 20.10.
  prefs: []
  type: TYPE_NORMAL
- en: The time step must be smaller than 40*μ*s, which is why we chose 25*μ*s earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The animations for the guitar string produced by gloss and not-gloss are on
    the edge of my computer’s ability to carry out gracefully. After the animation
    runs for a little while, the frames seem to update less quickly, indicating that
    the computer is having trouble doing all of the calculations we are asking of
    it while at the same time displaying the results. As we ask more and more of the
    computer, there will come a time when it cannot do all of the calculations we
    want at a rate that would it allow it to display the results at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: One solution for this situation is to use *asynchronous animation*, in which
    we do all of the calculations first and then sew the results together into a movie
    that we can watch later. [Listing 20-5](ch20.xhtml#ch20list5) shows a stand-alone
    program that creates 1,000 PNG files, each showing a picture of the guitar string,
    spaced at 25-*μ*s intervals. These can be combined into an MP4 movie with an external
    program such as ffmpeg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-5: Stand-alone program for a 2D asynchronous animation of a flexible
    string*'
  prefs: []
  type: TYPE_NORMAL
- en: The function `makePNG` takes as input an integer and a multi-particle state
    and produces a PNG file showing the position of the string. The purpose of the
    integer is to label the output file; 0 produces the file *GnuplotWave000.png*,
    8 produces the file *GnuplotWave008.png*, and 167 produces the file *Gnuplot Wave167.png*.
    Only integers between 0 and 999, inclusive, should be used with this function.
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by naming the incoming integer `n` and, using pattern matching
    on the input, the incoming list of single-particle states `sts`. The function
    then defines several local variables in the `let` construction. The local variable
    `rs` is a list of 66 position vectors describing the position of the string. The
    list consists of the positions of the 64 little masses, augmented with the fixed
    positions of the string at each end. The local function `xy` produces an (x, y)
    pair from a position. The list `xys`, formed by mapping `xy` onto the list `rs`
    of positions, is the list of pairs we will ask gnuplot to plot.
  prefs: []
  type: TYPE_NORMAL
- en: The local string `threeDigitString` is a three-digit string based on the integer
    `n` given as input. The function works by using `show` to convert `n` to a string,
    prepending that string with zeros, and then taking the last three digits. We take
    the last three digits by reversing the string, taking the first three digits with
    `take 3`, and then reversing back. The `threeDigitString` is then used as part
    of the filename `pngFilePath`. In the body of the `let` construction, we use gnuplot’s
    `plotPath` function to plot the pairs `xys` that we defined earlier. Since we
    intend to animate the frames that gnuplot produces, it’s important that we specify
    the `XRange` and `YRange` attributes so that each frame has the same range.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn our attention to the function `main`. We want to apply the function
    `makePNG` to each of 1,000 pairs of an integer with a multi-particle state. In
    an imperative language like Python, this would be an opportunity to use a loop.
    In a functional language like Haskell, this is an opportunity to use a list. The
    `main` function consists of several phrases separated by the function application
    operator `$`. Since this operator is right associative (recall [Table 1-2](ch01.xhtml#ch1tab2)),
    it’s easiest to read the definition of `main` from right to left. The rightmost
    phrase,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: is an infinite list of multi-particle states, starting with overtone number
    3, spaced 25*μ*s apart. Applying `zip [0..999]` to this infinite list produces
    a finite list, with each element being a pair of an integer and a multi-particle
    state. Applying `map makePNG` to this list of pairs produces a length-1,000 list
    with type `[IO ()]`. This is not the type we want the function `main` to have.
    We want `main` to have type `IO ()`, which simply means that it does something.
    Haskell provides a function `sequence_` to convert a list of actions into a single
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the type of `sequence_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We are using `sequence_` in a context where the `Foldable` thing is a list,
    the `Monad` is `IO`, and the type variable `a` is unit, so the concrete type for
    `sequence_` in our use is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: which is just what we need to produce the correct type for `main`. The function
    `sequence_` assembles a list of actions into a single action by sequencing them.
    The following command asks the external program ffmpeg to combine all PNG files
    named *GnuplotWaveDDD.png*, where the capital Ds are digits. We ask for a frame
    rate of 40 frames/second. The final movie is called *GnuplotWave.mp4*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the character after the percent sign is a zero and not the letter
    O. If you are using a Unix-like system, you can find documentation about ffmpeg,
    after you have installed it, with the command `man ffmpeg`.
  prefs: []
  type: TYPE_NORMAL
- en: When we are doing asynchronous animation, we specify the time step and the animation
    rate rather than the time-scale factor and the animation rate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we examined three physical situations involving multiple interacting
    particles, applying the theory and ideas of [Chapter 19](ch19.xhtml). The first
    situation, with two masses and two springs, contains two particles and both internal
    and external forces.
  prefs: []
  type: TYPE_NORMAL
- en: Our second situation, a collision, has only internal forces and consequently
    conserves system momentum. We looked at conservation of momentum and energy in
    the context of the approximate numerical calculations we have been doing, and
    we found that momentum is conserved for all time steps, no matter how large. The
    collision also gave us an opportunity to look more deeply into numerical issues
    that affect the choice of technical parameters, such as the spring constant and
    time step.
  prefs: []
  type: TYPE_NORMAL
- en: Our third situation, the guitar string, involves many particles and suggests
    a transition into fields and waves. All along we have been discretizing time as
    a method to achieve practical results in mechanics problems; here, in using many
    particles to model a string, we are coming close to discretizing space as one
    would do to numerically solve field equations such as the Maxwell equations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](part02.xhtml) of this book has dealt with Newtonian mechanics. Starting
    with a single particle moving in one dimension, we have slowly and steadily introduced
    ideas and code to deal with more and more sophisticated situations in mechanics.
    We talked about which mechanics problems can be solved with algebra, which require
    integration from calculus, and which require differential equations. We developed
    some general-purpose ways of solving systems of differential equations, and we
    put them to use in the service of mechanics. We took advantage of Haskell’s type
    system to make simple data structures, like 3D vectors, to construct a sequence
    of information representations that lead from problem specification to problem
    solution, and to create a modular system in which it is easy to switch out one
    numerical method for another. We viewed Newton’s second law as the rule for constructing
    a differential equation from a list of forces. We built Newton’s third law into
    the infrastructure for interacting particles so it gets automatically applied
    to all of the internal forces acting in a multi-particle situation. I hope that
    I have convinced you that a functional language is a fruitful way to express the
    ideas of mechanics alongside the ideas required for solving problems in mechanics.'
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the book explores electromagnetic theory. It begins with a
    chapter about Coulomb’s law, which fits nicely into the framework of interacting
    particles we have developed. Coulomb’s law, like Newton’s law of universal gravity,
    is expressed as an internal force between two particles.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 20.1.** What is the type of local variable `v` in the function `kineticEnergy`?
    What is the type of local variable `v` in the function `momentum`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.2.** The `billiardPicture` display function we wrote will display
    any number of balls, but they are all blue. If you want an animation with billiard
    balls of different colors, you can modify the `billiardPicture` function to cycle
    through a list of colors.'
  prefs: []
  type: TYPE_NORMAL
- en: Make a new function `billiardPictureColors` by starting with a copy of `billiardPicture`
    and making the following changes. First, replace the local name `blueBall` with
    a local function `coloredBall` that takes a color as input. Next, modify the local
    function `place` to take a color as a second argument and use the new `coloredBall`
    function instead of `blueBall`. Finally, replace the list comprehension `[place
    st | st <- sts]` with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The latter will cycle through the colors blue and red. You can change this list
    to cycle through as many colors as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the main billiard collision program to use your new display function,
    `billiardPictureColors`, and check that it works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.3.** Using [Listing 20-3](ch20.xhtml#ch20list3) as a starting
    point, animate a two-body gravitational system such as the sun and Earth. In place
    of `billiardForces`, write a list of forces called `sunEarthForces` that contains
    the only force present: the universal gravity between the sun and Earth. In place
    of `billiardUpdate`, write an update function called `sunEarthUpdate`. In place
    of `billiardInitial`, write an initial state called `sunEarthInitial`, choosing
    appropriate values for the initial positions and velocities of the sun and Earth.
    In place of `billiard` `Picture`, write a display function called `sunEarthPicture`,
    making the sun yellow and Earth blue. You will not be able to display the size
    of the sun or Earth to scale with the orbital motion. Choose any convenient values
    for the object sizes. Choose a time-scale factor of `365*24*60` so that one year
    of physical time is one minute of animation time. Choose an animation rate of
    60 frames/second. Confirm that the orbital period is approximately one year by
    observing that it takes one minute for the animated Earth to complete a revolution
    around the sun.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.4.** In this problem, we investigate how Jupiter makes the sun
    wobble. We say that Jupiter orbits the sun because the sun is much more massive,
    but in a system consisting only of the sun and Jupiter, both objects orbit a point
    at the system’s center of mass. The center of mass is a weighted average of positions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/401equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The distance between the sun and Jupiter is about 8 × 10^(11) m. The radius
    of the sun is 6.96 × 10⁸ m. The mass of the sun is 1.99 × 10^(30) kg. The mass
    of Jupiter is 1.90 × 10^(27) kg.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the sun at the origin in the equation above, and looking only at the
    radial component of the vectors, we find that the center of mass
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/401equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: lies slightly outside the radius of the sun. We should be able to see the sun
    orbit about this center of mass in an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Make an animation for the sun-Jupiter system using gloss or not-gloss. The only
    force is the universal gravity between the sun and Jupiter. Display the size of
    the sun to scale with the orbital motion, but zoom in on the sun, ignoring the
    display of Jupiter. If things go well, you should see the sun orbit a point slightly
    outside of its radius.
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to include any of the center-of-mass calculations above to make
    this animation. However, for the center of mass to stay fixed, you will need to
    supply initial conditions that give zero momentum to the sun-Jupiter system. If
    you take the initial velocity of Jupiter to be in the y-direction, the sun will
    need to have a small initial velocity in the negative y-direction so that the
    total momentum is 0.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain an initial velocity estimate for Jupiter, you may assume that Jupiter’s
    orbit is circular and that the radius of its orbit is the same as the sun-Jupiter
    distance. (This is only off by 0.1 percent.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.5.** Using realistic initial conditions, program an animation
    for the sun, Earth, and moon mutually interacting though gravity. The actual Earth-sun
    separation is about 500 times the Earth-moon separation, so you won’t be able
    to resolve the Earth and moon as separate objects on the screen. To be able to
    see where the moon is relative to Earth, I suggest the following: instead of displaying
    the moon at the position you calculate, display the moon at a fake position that
    has the correct orientation but is 50 times as far from Earth as you calculate.
    An equation to use to calculate a fake moon position is'
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[FM] = **r**[E] + *A*(**r**[M] − **r**[E])'
  prefs: []
  type: TYPE_NORMAL
- en: where **r**[FM] is the position of the fake moon, **r**[M] is the position of
    the (real) moon, **r**[E] is the position of Earth, and *A* is a magnification
    factor that artificially magnifies the vector from Earth to moon for display purposes.
    Try *A* = 50 and see what happens. Note that the fake moon need only appear in
    the display function. This situation should involve three internal forces and
    no external forces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.6.** Using the `fixedLinearSpring` function, investigate a springy
    pendulum. Choose values for the spring constant *k*, the equilibrium length of
    the spring *r[e]*, and the mass *m*.'
  prefs: []
  type: TYPE_NORMAL
- en: (a) Confirm, with an animation or a graph, that placing the mass a distance
    *r[e]* + *mg*/*k* directly below the spot where the spring attaches to the ceiling,
    giving it no initial velocity, results in an equilibrium situation that allows
    the mass to hang motionless on the spring.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Choose an initial state in which the mass has no initial velocity and sits
    a distance *r[e]* directly below the spot where the spring attaches to the ceiling.
    In this situation, the spring initially exerts no force on the mass, but gravity
    does exert a force. Confirm, with an animation or a graph, that the mass oscillates
    with an angular frequency ![Image](Images/402equ01.jpg). This is equivalent to
    a period of ![Image](Images/402equ02.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: (c) Investigate the horizontal oscillation of a pendulum by placing the mass,
    with no initial velocity, a distance *r[e]* + *mg*/*k* from the ceiling attachment
    point, but not directly below that point. Allow the mass to evolve in time. Confirm,
    with an animation or a graph, that the angular frequency of oscillation is close
    to ![Image](Images/402equ03.jpg), with *l* = *r[e]* + *mg*/*k*, or, equivalently,
    that the period is ![Image](Images/402equ04.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: (d) Find an initial position and velocity for the mass so that it undergoes
    horizontal circular motion.
  prefs: []
  type: TYPE_NORMAL
- en: (e) If you now change the parameters so that
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/402equ05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: you may be able to find initial conditions in which the mass undergoes circular
    or elliptical motion in a vertical plane. See if this is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.7.** Consider two equal-mass billiard balls traveling toward
    each other with equal and opposite velocities. If they travel directly toward
    each other, say along the x-axis, the collision will be one dimensional. If, on
    the other hand, their initial velocities are in the positive and negative x-direction,
    but there is a small y-component of displacement between them, the collision will
    be two dimensional. The angle at which the balls travel after the collision (which
    is the same for both balls because of the symmetry) depends on this initial y-component
    of displacement. There is some initial y-displacement that will produce a right
    angle. Find, by trial and error, this y-displacement for some spring constant
    and time step. It may not be what you expect. Try a different spring constant
    and/or time step. Can you explain why the y-displacement required to produce a
    right angle depends on the spring constant?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.8.** Write an animation for the guitar string in which the string
    is modeled with 9 masses rather than 64\. The distance between masses will be
    6.5 cm rather than 1 cm. This increases the time-step stability threshold to 255*μ*s,
    so we can use a larger time step. We’re asking less of the computer, so the animation
    should run smoothly, even on older hardware. You’ll need to write new definitions
    for `forcesString`, `stringUpdate`, and `stringInitialOvertone`. The function
    `stringPicture` can remain the same. The spring constant for the springs will
    need to be different.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.9.** To see what an animation looks like when a numerical instability
    occurs, modify the gloss animation of the guitar string so that the time step
    is 100*μ*s. You can do this by increasing the time-scale factor or by decreasing
    the animation rate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.10.** Write the functions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: that use gnuplot to graph the x- and y-components of position (for the first
    function) and velocity (for the second) for a multi-particle state as if it was
    a guitar string. Functions like these can help with debugging. You can use them
    to visualize what happens in the first several time steps, giving you clues to
    what might be wrong when things aren’t working.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.11.** Write a 3D animation for the guitar string using `simulateVis`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.12.** Make a 3D animation of the guitar string in which the motion
    looks like that of a jump rope. You should be able to do this by changing the
    initial state so that the masses that make up the string have some initial velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.13.** Modify the function `makePNG` so that it uses four digits
    rather than three to label the output file. This allows for a longer animation
    of up to 10,000 frames. Test your function by making an animation of 2,000 frames.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.14.** Write code to produce graphs like those in [Figure 20-2](ch20.xhtml#ch20fig2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.15.** Explore energy conservation for the guitar string. Mechanical
    energy should be conserved, but how well it is conserved depends on the time step.
    You will need to write an expression for the mechanical energy of this system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.16.** Most of our animated results up to now have been based
    on a state-update function and have used the `simulateGloss` or `simulateVis`
    functions. There is a way to animate a list of states, and we’ll explore that
    now. The functions `animateGloss` and `animateVis` that follow take as input a
    time-scale factor, a display function, and a list of states, and they produce
    an animation. The time step for the animation is obtained from the list of states.
    We do not specify an animation rate; that is calculated from the time-scale factor
    and time step.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 20-6](ch20.xhtml#ch20list6) is a stand-alone program using `animateGloss`
    to make the animation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-6: Stand-alone program for a 2D animation of two billiard balls
    colliding*'
  prefs: []
  type: TYPE_NORMAL
- en: Write a stand-alone program using `animateVis` to make the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 20.17.** The billiard collision we studied in this chapter is an
    elastic collision. Any collision in which the only force is `billiardForce` must
    be an elastic collision. How can we produce an inelastic collision? We need some
    sort of two-body force that can dissipate energy. The following two-body force
    can provide dissipation in a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When the distance between the particles is greater than or equal to the threshold
    separation, the particles feel no dissipation force. When the distance between
    the particles is less than the threshold separation, the particles feel a force
    proportional to the relative velocity in a direction that helps the relative velocity
    decrease in magnitude. Including this dissipation force along with `billiardForce`
    in the list of forces acting in a system results in an inelastic collision.
  prefs: []
  type: TYPE_NORMAL
- en: Revise the stand-alone program in [Listing 20-3](ch20.xhtml#ch20list3) to produce
    an inelastic collision. A damping constant of 4 kg/s should produce a totally
    inelastic collision.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that this collision is inelastic, make a graph of mechanical energy
    as a function of time. Since a non-conservative force is present, mechanical energy
    will not be conserved. Mechanical energy should be conserved before the collision,
    drop rapidly during the collision, and then maintain at a lower value after the
    collision.
  prefs: []
  type: TYPE_NORMAL
