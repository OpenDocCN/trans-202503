["```\nspringForce5500 :: R -> R\nspringForce5500 x = -5500 * x\n```", "```\ntype R = Double\n```", "```\nspringForce :: R -> R -> R\nspringForce k x = -k * x\n```", "```\nPrelude> :l HigherOrder.lhs\n[1 of 1] Compiling Main            ( HigherOrder.lhs, interpreted )\nOk, one module loaded.\n*Main> :t springForce\nspringForce :: R -> R -> R\n```", "```\n*Main> :t springForce 2200\nspringForce 2200 :: R -> R\n```", "```\n*Main> :t springForce 2200 0.4\nspringForce 2200 0.4 :: R\n```", "```\n*Main> :t take\ntake :: Int -> [a] -> [a]\n```", "```\n*Main> map sqrt [1,4,9]\n[1.0,2.0,3.0]\n*Main> [sqrt x | x <- [1,4,9]]\n[1.0,2.0,3.0]\n```", "```\n[x, f x, f (f x), f (f (f x)), ...]\n```", "```\nphysicists :: [String]\nphysicists = [\"Einstein\",\"Newton\",\"Maxwell\"]\n```", "```\n*Main> :t (++)\n(++) :: [a] -> [a] -> [a]\n*Main> :t physicists\n\nphysicists :: [String]\n*Main> :t (++) physicists\n(++) physicists :: [String] -> [String]\n```", "```\nvelocities :: [R]\nvelocities = [0,-9.8,-19.6,-29.4]\n```", "```\n*Main> :t (++) physicists velocities\n\n<interactive>:1:17: error:\n    • Couldn't match type Double with [Char]\n      Expected type: [String]\n        Actual type: [R]\n    • In the second argument of (++), namely velocities\n      In the expression: (++) physicists velocities\n```", "```\ngreaterThanOrEq7 :: Int -> Bool\ngreaterThanOrEq7 n = if n >= 7 then True else False\n```", "```\nlt10 :: Int -> Bool\nlt10 n = n < 10\n```", "```\n*Main> filter lt10 [6,4,8,13,7]\n[6,4,8,7]\n*Main>  [x | x <- [6,4,8,13,7], x < 10]\n[6,4,8,7]\n```", "```\ntype Integration = (R -> R)  -- function\n                 -> R        -- lower limit\n                 -> R        -- upper limit\n                 -> R        -- result\n```", "```\nintegral :: R -> Integration\nintegral dt f a b\n    = sum [f t * dt | t <- [a+dt/2, a+3*dt/2 .. b - dt/2]]\n```", "```\n*Main> integral 0.01 (\\x -> x**2) 0 1\n0.33332499999999987\n```", "```\ntype AntiDerivative =   R        -- initial value\n                    -> (R -> R)  -- function\n                    -> (R -> R)  -- antiderivative of function\n```", "```\nantiDerivative :: R -> AntiDerivative\nantiDerivative dt v0 a t = v0 + integral dt a 0 t\n```", "```\nvelFromAcc :: R                       -- dt\n           -> Velocity                -- initial velocity\n           -> (Time -> Acceleration)  -- acceleration function\n           -> (Time -> Velocity)      -- velocity function\nvelFromAcc dt v0 a t = antiDerivative dt v0 a t\n```", "```\nposFromVel :: R                   -- dt\n           -> Position            -- initial position\n           -> (Time -> Velocity)  -- velocity function\n           -> (Time -> Position)  -- position function\nposFromVel = antiDerivative\n```", "```\ntype Time         = R\ntype Position     = R\ntype Velocity     = R\ntype Acceleration = R\n```", "```\nintegralN :: Int -> Integration\nintegralN n f a b\n    = let dt = (b - a) / fromIntegral n\n      in integral dt f a b\n```", "```\nintegralN' :: Int -> Integration\nintegralN' n f a b\n    = integral ((b - a) / fromIntegral n) f a b\n```", "```\nyRock :: R -> R -> R\n```", "```\nvRock :: R -> R -> R\n```", "```\ngreaterThanOrEq7' :: Int -> Bool\ngreaterThanOrEq7' n = undefined\n```", "```\n  map' :: (a -> b) -> [a] -> [b]\n```", "```\n  filter' :: (a -> Bool) -> [a] -> [a]\n```", "```\naverage :: [R] -> R\naverage xs = undefined\n```", "```\ntrapIntegrate :: Int       -- # of trapezoids n\n              -> (R -> R)  -- function f\n              -> R         -- lower limit a\n              -> R         -- upper limit b\n              -> R         -- result\ntrapIntegrate n f a b = undefined\n```"]