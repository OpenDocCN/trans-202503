["```\nint f(int x, int y) {\n    return 10 - (3 * y + x);\n}\n```", "```\nf(x, y):\n    tmp0 = 3 * y\n    tmp1 = tmp0 + x\n    tmp2 = 10 - tmp1\n    Return(tmp2)\n```", "```\nf:\n  ❶ movl    %edi, %x\n    movl    %esi, %y\n  ❷ movl    $3, %tmp0\n    imull   %y, %tmp0\n    movl    %tmp0, %tmp1\n addl    %x, %tmp1\n    movl    $10, %tmp2\n    subl    %tmp1, %tmp2\n  ❸ movl    %tmp2, %eax\n    ret\n```", "```\nf:\n    movl    %edi, -4(%rbp)\n    movl    %esi, -8(%rbp)\n    movl    $3, -12(%rbp)\n  ❶ imull   -8(%rbp), -12(%rbp)\n  ❷ movl    -12(%rbp), -16(%rbp)\n  ❸ addl    -4(%rbp), -16(%rbp)\n    movl    $10, -20(%rbp)\n  ❹ subl    -16(%rbp), -20(%rbp)\n    movl    -20(%rbp), %eax\n    ret\n```", "```\nf:\n `--snip--`\n    movl    %edi, -4(%rbp)\n    movl    %esi, -8(%rbp)\n    movl    $3, -12(%rbp)\n **movl    -12(%rbp), %r11d**\n    imull   -8(%rbp), %r11d\n **movl    %r11d, -12(%rbp)**\n **movl    -12(%rbp), %r10d**\n    movl    %r10d, -16(%rbp)\n **movl    -4(%rbp), %r10d**\n    addl    %r10d, -16(%rbp)\n    movl    $10, -20(%rbp)\n **movl    -16(%rbp), %r10d**\n    subl    %r10d, -20(%rbp)\n    movl    -20(%rbp), %eax\n `--snip--`\n    ret\n```", "```\nf:\n `--snip--`\n    movl    %edi, %edx\n    movl    %esi, %ecx\n    movl    $3, %r8d\n    imull   %ecx, %r8d\n    movl    %r8d, %r9d\n    addl    %edx, %r9d\n    movl    $10, %edi\n    subl    %r9d, %edi\n    movl    %edi, %eax\n `--snip--`\n    ret\n```", "```\nf:\n **movl    %edi, %x**\n **movl    %esi, %y**\n    movl    $3, %tmp0\n    imull   %y, %tmp0\n **movl    %tmp0, %tmp1**\n    addl    %x, %tmp1\n    movl    $10, %tmp2\n    subl    %tmp1, %tmp2\n **movl    %tmp2, %eax**\n    ret\n```", "```\nf:\n    movl    $3, %tmp0\n    imull   **%esi**, %tmp0\n    addl    **%edi**, **%tmp0**\n    movl    $10, **%eax**\n subl    **%tmp0**, **%eax**\n    ret\n```", "```\nf:\n `--snip--`\n    movl    $3, %ecx\n    imull   %esi, %ecx\n    addl    %edi, %ecx\n    movl    $10, %eax\n    subl    %ecx, %eax\n `--snip--`\n    ret\n```", "```\nprogram = Program(top_level*)\nassembly_type = Byte | Longword | Quadword | Double | ByteArray(int size, int alignment)\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)\n          | StaticConstant(identifier name, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(assembly_type src_type, assembly_type dst_type, operand src, operand dst)\n            | MovZeroExtend(assembly_type src_type, assembly_type dst_type,\n                            operand src, operand dst)\n            | Lea(operand src, operand dst)\n | Cvttsd2si(assembly_type dst_type, operand src, operand dst)\n            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            | Div(assembly_type, operand)\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            **| Pop(reg)**\n            | Call(identifier)\n            | Ret\nunary_operator = Neg | Not | Shr\nbinary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor | Shl | ShrTwoOp\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier, int)\n        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)\ncond_code = E | NE | G | GE | L | LE | A | AE | B | BE\nreg = AX **| BX** | CX | DX | DI | SI | R8 | R9 | R10 | R11 **| R12 | R13 | R14 | R15** | SP | BP\n    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7\n    **| XMM8 | XMM9 | XMM10 | XMM11 | XMM12 | XMM13** | XMM14 | XMM15\n```", "```\nint foo(int i, int j);\n```", "```\ndouble foo(int i, double d);\n```", "```\ndivide_and_subtract:\n  ❶ movl    %edi, %a\n  ❷ movl    %esi, %b\n    movl    %a, %eax\n  ❸ cdq\n    idivl   %b\n  ❹ movl    %eax, %tmp\n    subl    %b, %tmp\n    movl    %tmp, %eax\n    ret\n```", "```\ndivide_and_subtract:\n    movl    %edi, %edx\n    movl    %esi, %edi\n    movl    %edx, %eax\n    cdq\n    idivl   %edi\n    movl    %eax, %eax\n    subl    %edi, %eax\n    movl    %eax, %eax\n    ret\n```", "```\nmovl    4(%rdi), %x\nmovl    %x, %eax\nret\n```", "```\nmovl    $1, %y\nmovl    %y, %x\naddl    %x, %ecx\naddl    %y, %eax\n```", "```\nmovl    $1, %y\nmovl    %y, %x\naddl    $1, %y\naddl    %x, %y\n```", "```\nuncolorable:\n    movl    %edi, %arg1\n    movl    %esi, %arg2\n    movl    $10, %eax\n    cdq\n    idivl   %arg1\n    movl    %eax, %tmp\n    movl    %arg1, %eax\n    cdq\n    idivl   %arg2\n    addl    %tmp, %eax\n    ret\n```", "```\nuncolorable:\n    movl    %edi, **%edi**\n    movl    %esi, **%esi**\n    movl    $10, %eax\n    cdq\n    idivl   **%edi**\n    movl    %eax, %tmp\n    movl    **%edi**, %eax\n    cdq\n    idivl   **%esi**\n    addl    %tmp, %eax\n    ret\n```", "```\nuncolorable:\n `--snip--`\n    movl    %edi, %edi\n movl    %esi, %esi\n    movl    $10, %eax\n    cdq\n    idivl   %edi\n    movl    %eax, **-4(%rbp)**\n    movl    %edi, %eax\n    cdq\n    idivl   %esi\n    addl    **-4(%rbp)**, %eax\n `--snip--`\n    ret\n```", "```\nallocate_registers(instructions):\n    interference_graph = build_graph(instructions)\n    add_spill_costs(interference_graph, instructions)\n    color_graph(interference_graph)\n    register_map = create_register_map(interference_graph)\n    transformed_instructions = replace_pseudoregs(instructions, register_map)\n    return transformed_instructions\n```", "```\nnode = Node(operand id, operand* neighbors, double spill_cost, int? color, bool pruned)\ngraph = Graph(node* nodes)\n```", "```\nbuild_graph(instructions):\n  ❶ interference_graph = base_graph\n  ❷ add_pseudoregisters(interference_graph, instructions)\n    cfg = make_control_flow_graph(instructions)\n  ❸ analyze_liveness(cfg)\n  ❹ add_edges(cfg, interference_graph)\n    return interference_graph\n```", "```\nmeet(block):\n    live_registers = {}\n    for succ_id in block.successors:\n        match succ_id with\n        | EXIT -> **live_registers.add(Reg(AX))**\n        | ENTRY -> fail(\"Malformed control-flow graph\")\n        | BlockId(id) ->\n            succ_live_registers = get_block_annotation(succ_id)\n            live_registers.add_all(succ_live_registers)\n\n    return live_registers\n```", "```\nfind_used_and_updated(instruction):\n    match instruction with\n    | Mov(src, dst) -> ❶\n        used = [src]\n        updated = [dst]\n    | Binary(op, src, dst) -> ❷\n        used = [src, dst]\n        updated = [dst]\n    | Unary(op, dst) ->\n        used = [dst]\n        updated = [dst]\n    | Cmp(v1, v2) ->\n        used = [v1, v2]\n        updated = []\n    | SetCC(cond, dst) ->\n        used = []\n        updated = [dst]\n    | Push(v) ->\n        used = [v]\n updated = []\n    | Idiv(divisor) ->\n        used = [divisor, Reg(AX), Reg(DX)]\n        updated = [Reg(AX), Reg(DX)]\n    | Cdq ->\n        used = [Reg(AX)]\n        updated = [Reg(DX)]\n    | Call(f) ->\n        used = `<look up parameter passing registers in the backend symbol table>` ❸\n        updated = [Reg(DI), Reg(SI), Reg(DX), Reg(CX), Reg(R8), Reg(R9), Reg(AX)]\n    | _ ->\n        used = []\n        updated = []\n    return (used, updated)\n```", "```\ntransfer(block, end_live_registers):\n    current_live_registers = end_live_registers\n\n    for instruction in reverse(block.instructions):\n      ❶ annotate_instruction(instruction, current_live_registers)\n      ❷ used, updated = find_used_and_updated(instruction)\n for v in updated:\n            if v is a register:\n                current_live_registers.remove(v)\n\n        for v in used:\n            if v is a register:\n                current_live_registers.add(v)\n\n  ❸ annotate_block(block.id, current_live_registers)\n```", "```\nadd_edges(liveness_cfg, interference_graph):\n    for node in liveness_cfg.nodes:\n        if node is EntryNode or ExitNode:\n            continue\n\n        for instr in node.instructions:\n            used, updated = find_used_and_updated(instr)\n\n          ❶ live_registers = get_instruction_annotation(instr)\n\n            for l in live_registers:\n              ❷ if (instr is Mov) and (l == instr.src):\n                    continue\n\n                for u in updated:\n                  ❸ if (l and u are in interference_graph) and (l != u):\n                        add_edge(interference_graph, l, u)\n```", "```\ncolor_graph(g):\n    remaining = `<unpruned nodes in g>`\n  ❶ if remaining is empty:\n        return\n\n    // choose next node to prune\n    chosen_node = null\n\n    for node in remaining:\n        degree = length(`<unpruned neighbors of node>`)\n        if degree < k:\n          ❷ chosen_node = node\n            break\n\n    if chosen_node is null:\n        // choose a spill candidate\n        best_spill_metric = infinity\n        for node in remaining:\n            degree = length(`<unpruned neighbors of node>`)\n            spill_metric = node.spill_cost / degree\n if spill_metric < best_spill_metric:\n              ❸ chosen_node = node\n                best_spill_metric = spill_metric\n\n    chosen_node.pruned = True\n\n    // color the rest of the graph\n  ❹ color_graph(g)\n\n    // color this node\n    colors = [1, 2, . . ., k]\n    for neighbor_id in chosen_node.neighbors:\n        neighbor = get_node_by_id(g, neighbor_id)\n        if neighbor.color is not null:\n            colors.remove(neighbor.color)\n\n  ❺ if colors is not empty:\n        if chosen_node is a callee-saved hard register:\n            chosen_node.color = max(colors)\n        else:\n            chosen_node.color = min(colors)\n        chosen_node.pruned = False\n\n    return\n```", "```\ncreate_register_map(colored_graph):\n\n    // build map from colors to hard registers\n    color_map = `<empty map>`\n    for node in colored_graph.nodes:\n        match node.id with\n        | Reg(r) ->\n            color_map.add(node.color, r)\n        | Pseudo(p) -> continue\n\n    // build map from pseudoregisters to hard registers\n    register_map = `<empty map>`\n    callee_saved_regs = {}\n    for node in colored_graph.nodes:\n        match node.id with\n        | Pseudo(p) ->\n            if node.color is not null:\n              ❶ hardreg = color_map.get(node.color)\n                register_map.add(p, hardreg)\n                if hardreg is callee saved:\n                  ❷ callee_saved_regs.add(hardreg)\n        | Reg(r) -> continue\n\n ❸ record_callee_saved_regs(`<current function name>`, callee_saved_regs)\n\n    return register_map\n```", "```\nmy_fun:\n    movl    %edi, %tmp1\n    addl    $5, %tmp1\n  ❶ movl    %tmp1, %tmp2\n  ❷ movl    %tmp2, %eax\n    ret\n```", "```\nmy_fun:\n    movl    %edi, %eax\n    addl    $5, %eax\n    ret\n```", "```\nBinary(Sub, Quadword, Imm(16), Reg(SP))\nPush(Reg(R12))\nPush(Reg(R13))\n```", "```\nPop(R13)\nPop(R12)\nRet\n```", "```\npopq    %r13\npopq    %r12\nmovq    %rbp, %rsp\npopq    %rbp\nret\n```", "```\nBinary(Sub, Quadword, Imm(24), Reg(SP))\nPush(Reg(BX))\n```", "```\ncalculate_stack_adjustment(bytes_for_locals, callee_saved_count):\n    callee_saved_bytes = 8 * callee_saved_count\n    total_stack_bytes = callee_saved_bytes + bytes_for_locals\n  ❶ adjusted_stack_bytes = round_up(total_stack_bytes, 16)\n  ❷ stack_adjustment = adjusted_stack_bytes - callee_saved_bytes\n    return stack_adjustment\n```", "```\nmovl    $1, %y\nmovl    %y, %x\naddl    $1, %y\naddl    %x, %y\n```", "```\nf:\n    movl    %edi, %arg\n    movl    %arg, %tmp\n    addl    $1, %tmp\n    imull   %arg, %tmp\n    movl    $10, %eax\n    subl    %tmp, %eax\n    ret\n```", "```\nf:\n    movl    %edi, %tmp\n    addl    $1, %tmp\n    imull   %edi, %tmp\n    movl    $10, %eax\n    subl    %tmp, %eax\n    ret\n```", "```\nf:\n    movl    %edi, %tmp1\n    movl    %edi, %tmp2\n    addl    %tmp1, %tmp2\n    movl    %tmp2, %eax\n    ret\n```", "```\nf:\n    movl    %edi, %tmp2\n    addl    %edi, %tmp2\n    movl    %tmp2, %eax\n    ret\n```", "```\nallocate_registers(instructions):\n **while True:**\n **interference_graph = build_graph(instructions)**\n **coalesced_regs = coalesce(interference_graph, instructions)**\n **if nothing_was_coalesced(coalesced_regs):**\n **break**\n **instructions = rewrite_coalesced(instructions, coalesced_regs)**\n    add_spill_costs(interference_graph, instructions)\n    color_graph(interference_graph)\n    register_map = create_register_map(interference_graph)\n    transformed_instructions = replace_pseudoregs(instructions, register_map)\n    return transformed_instructions\n```", "```\ninit_disjoint_sets():\n  ❶ return `<empty map>`\n\nunion(x, y, reg_map):\n  ❷ reg_map.add(x, y)\n\nfind(r, reg_map):\n  ❸ if r is in reg_map:\n        result = reg_map.get(r)\n      ❹ return find(result, reg_map)\n    return r\n\nnothing_was_coalesced(reg_map):\n  ❺ if reg_map is empty:\n        return True\n    return False\n```", "```\ncoalesce(graph, instructions):\n    coalesced_regs = init_disjoint_sets()\n\n    for i in instructions:\n        match i with\n        | Mov(src, dst) ->\n          ❶ src = find(src, coalesced_regs)\n            dst = find(dst, coalesced_regs)\n\n          ❷ if (src is in graph\n                and dst is in graph\n                and src != dst\n              ❸ and (not are_neighbors(graph, src, dst))\n              ❹ and conservative_coalesceable(graph, src, dst)):\n\n                if src is a hard register:\n                    to_keep = src\n                    to_merge = dst\n                else:\n                    to_keep = dst\n                    to_merge = src\n\n              ❺ union(to_merge, to_keep, coalesced_regs)\n                update_graph(graph, to_merge, to_keep)\n\n        | _ -> continue\n\n    return coalesced_regs\n```", "```\nupdate_graph(graph, x, y):\n\n    node_to_remove = get_node_by_id(graph, x)\n    for neighbor in node_to_remove.neighbors:\n        add_edge(graph, y, neighbor)\n        remove_edge(graph, x, neighbor)\n\n    remove_node_by_id(graph, x)\n```", "```\nconservative_coalesceable(graph, src, dst):\n  ❶ if briggs_test(graph, src, dst):\n        return True\n  ❷ if src is a hard register:\n        return george_test(graph, src, dst)\n    if dst is a hard register:\n        return george_test(graph, dst, src)\n    return False\n\nbriggs_test(graph, x, y):\n    significant_neighbors = 0\n\n    x_node = get_node_by_id(graph, x)\n    y_node = get_node_by_id(graph, y)\n\n    combined_neighbors = set(x_node.neighbors)\n    combined_neighbors.add_all(y_node.neighbors)\n    for n in combined_neighbors:\n        neighbor_node = get_node_by_id(graph, n)\n ❸ degree = length(neighbor_node.neighbors)\n        if are_neighbors(graph, n, x) and are_neighbors(graph, n, y):\n          ❹ degree -= 1\n        if degree >= k:\n            significant_neighbors += 1\n\n  ❺ return (significant_neighbors < k)\n\ngeorge_test(graph, hardreg, pseudoreg):\n    pseudo_node = get_node_by_id(graph, pseudoreg)\n    for n in pseudo_node.neighbors:\n      ❻ if are_neighbors(graph, n, hardreg):\n            continue\n\n        neighbor_node = get_node_by_id(graph, n)\n      ❼ if length(neighbor_node.neighbors) < k:\n            continue\n\n        return False\n    return True\n```", "```\nrewrite_coalesced(instructions, coalesced_regs):\n    new_instructions = []\n    for i in instructions:\n        match i with\n        | Mov(src, dst) ->\n            src = find(src, coalesced_regs)\n            dst = find(dst, coalesced_regs)\n ❶ if src != dst:\n                new_instructions.append(Mov(src, dst))\n        | Binary(op, src, dst) ->\n            src = find(src, coalesced_regs)\n            dst = find(dst, coalesced_regs)\n            new_instructions.append(Binary(op, src, dst))\n        | `--snip--`\n\n    return new_instructions\n```"]