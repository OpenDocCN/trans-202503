["```\n% **codesign –-verify LuLu_2.6.0.dmg**\n\n% **codesign --verify -dvv LuLu_2.6.0.dmg**\nExecutable=/Users/Patrick/Downloads/LuLu_2.6.0.dmg\nIdentifier=LuLu\nFormat=disk image\n...\nAuthority=Developer ID Application: Objective-See, LLC (VBG97UB4TA)\nAuthority=Developer ID Certification Authority\nAuthority=Apple Root CA \n```", "```\n% **codesign --verify \"EvilQuest/Mixed In Key 8.dmg\"**\nEvilQuest/Mixed In Key 8.dmg: code object is not signed at all \n```", "```\n% **codesign --verify \"CreativeUpdate/Firefox 58.0.2.dmg\"**\nCreativeUpdate/Firefox 58.0.2.dmg: CSSMERR_TP_CERT_REVOKED \n```", "```\nNSMutableDictionary* checkImage(NSString* item) {\n    SecStaticCodeRef codeRef = NULL;\n    NSMutableDictionary* signingInfo = [NSMutableDictionary dictionary];\n\n  ❶ CFURLRef itemURL = (__bridge CFURLRef)([NSURL fileURLWithPath:item]);\n\n  ❷ OSStatus status = SecStaticCodeCreateWithPath(itemURL, kSecCSDefaultFlags, &codeRef);\n  ❸ if(errSecSuccess != status) {\n        goto bail;\n    }\n    ...\n\nbail:\n    if(nil != codeRef) {\n        CFRelease(codeRef);\n    }\n    return signingInfo;\n} \n```", "```\n...\n#define KEY_SIGNATURE_STATUS @\"signatureStatus\"\n\nstatus = SecStaticCodeCheckValidity(codeRef, kSecCSEnforceRevocationChecks, NULL);\nsigningInfo[KEY_SIGNATURE_STATUS] = [NSNumber numberWithInt:status];\nif(errSecSuccess != status) {\n    goto bail;\n} \n```", "```\nCFDictionaryRef signingDetails = NULL;\n\nstatus = SecCodeCopySigningInformation(codeRef,\nkSecCSSigningInformation, &signingDetails);\nif(errSecSuccess != status) {\n    goto bail;\n} \n```", "```\n#define KEY_SIGNING_AUTHORITIES @\"signatureAuthorities\"\n\nsigningInfo[KEY_SIGNING_AUTHORITIES] = ((__bridge NSDictionary*)signingDetails)\n[(__bridge NSString*)kSecCodeInfoCertificates]; \n```", "```\n#define KEY_SIGNING_FLAGS @\"flags\"\n\nsigningInfo[KEY_SIGNING_FLAGS] = [(__bridge NSDictionary*)signingDetails\nobjectForKey:(__bridge NSString*)kSecCodeInfoFlags]; \n```", "```\nif([results[KEY_SIGNING_FLAGS] intValue] & CS_ADHOC) {\n    // Code here will run only if item is signed in an ad hoc manner.\n} \n```", "```\nstatic SecRequirementRef requirement = NULL;\nSecRequirementCreateWithString(CFSTR(\"notarized\"), kSecCSDefaultFlags, &requirement); \n```", "```\nif(errSecSuccess == SecStaticCodeCheckValidity(codeRef, kSecCSDefaultFlags, requirement)) {\n    // Code placed here will run only if the item is notarized.\n} \n```", "```\n❶ SecAssessmentRef secAssessment = SecAssessmentCreate(itemURL,\nkSecAssessmentDefaultFlags, (__bridge CFDictionaryRef)(@{}), &error);\n❷ if(NULL == secAssessment) {\n    if((CSSMERR_TP_CERT_REVOKED == CFErrorGetCode(error)) ||\n        (errSecCSRevokedNotarization == CFErrorGetCode(error))) {\n        signingInfo[KEY_SIGNING_NOTARIZED] =\n        [NSNumber numberWithInteger:errSecCSRevokedNotarization];\n    }\n}\n❸ if(NULL != secAssessment) {\n    CFRelease(secAssessment);\n} \n```", "```\n% **./checkSignature LuLu_2.6.0.dmg**\nChecking: LuLu_2.6.0.dmg\nStatus: signed\nIs notarized: no\n\nSigning auths: (\n    \"<cert(0x11100a800) s: Developer ID Application: Objective-See, LLC (VBG97UB4TA)\n    i: Developer ID Certification Authority>\",\n    \"<cert(0x111808200) s: Developer ID Certification Authority i: Apple Root CA>\",\n    \"<cert(0x111808a00) s: Apple Root CA i: Apple Root CA>\"\n) \n```", "```\n% **./checkSignature \"EvilQuest/Mixed In Key 8.dmg\"**\nChecking: Mixed In Key 8.dmg\nStatus: unsigned \n```", "```\n% **./checkSignature \"CreativeUpdate/Firefox 58.0.2.dmg\"**\nChecking: Firefox 58.0.2.dmg\nStatus: revoked \n```", "```\n% **pkgutil --check-signature GoogleChrome.pkg**\nPackage \"GoogleChrome.pkg\":\n   Status: signed by a developer certificate issued by Apple for distribution\n   Notarization: trusted by the Apple notary service\n   Signed with a trusted timestamp on: 05-15 20:46:50 +0000\n   Certificate Chain:\n    1\\. Developer ID Installer: Google LLC (EQHXZ8M8AV)\n       Expires: 2027-02-01 22:12:15 +0000\n       SHA256 Fingerprint:\n           40 02 6A 12 12 38 F4 E0 3F 7B CE 86 FA 5A 22 2B DA 7A 3A 20 70 FF\n           28 0D 86 AA 4E 02 56 C5 B2 B4\n       -----------------------------------------------------------------------\n    2\\. Developer ID Certification Authority\n       Expires: 2027-02-01 22:12:15 +0000\n       SHA256 Fingerprint:\n           7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68 09 0D 2D E1 8D 03\n           F2 9C 88 CF B0 B1 BA 63 58 7F\n       -----------------------------------------------------------------------\n    3\\. Apple Root CA\n       Expires: 2035-02-09 21:40:36 +0000\n       SHA256 Fingerprint:\n           B0 B1 73 0E CB C7 FF 45 05 14 2C 49 F1 29 5E 6E DA 6B CA ED 7E 2C\n           68 C5 BE 91 B5 A1 10 01 F0 24 \n```", "```\n% **codesign –-verify -dvv GoogleChrome.pkg**\nGoogleChrome.pkg: code object is not signed at all \n```", "```\n% **pkgutil --check-signature \"EvilQuest/Mixed In Key 8.pkg\"**\nPackage \"Mixed In Key 8.pkg\":\n   Status: no signature \n```", "```\n% **pkgutil --check-signature KeySteal/archive.pkg**\nPackage \"archive.pkg\":\n   Status: revoked signature\n   Signed with a trusted timestamp on: 10-18 12:58:45 +0000\n   Certificate Chain:\n    1\\. Developer ID Installer: fenghua he (32W7BZNTSV)\n       Expires: 2027-02-01 22:12:15 +0000\n       SHA256 Fingerprint:\n           EC 7C 85 1D B0 A0 8C ED 45 31 6B 8E 9D 7D 34 0F 45 B8 4E CE 9D 9C\n           97 DB 2F 63 57 C2 D9 71 0C 4E\n       -----------------------------------------------------------------------\n    2\\. Developer ID Certification Authority\n       Expires: 2027-02-01 22:12:15 +0000\n       SHA256 Fingerprint:\n           7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68 09 0D 2D E1 8D 03\n           F2 9C 88 CF B0 B1 BA 63 58 7F\n       -----------------------------------------------------------------------\n    3\\. Apple Root CA\n       Expires: 2035-02-09 21:40:36 +0000\n       SHA256 Fingerprint:\n           B0 B1 73 0E CB C7 FF 45 05 14 2C 49 F1 29 5E 6E DA 6B CA ED 7E 2C\n           68 C5 BE 91 B5 A1 10 01 F0 24 \n```", "```\n% **otool -L /usr/sbin/pkgutil**\n/usr/sbin/pkgutil:\n...\n/System/Library/PrivateFrameworks/PackageKit.framework/Versions/A/PackageKit\n... \n```", "```\n% **dyld-shared-cache-extractor /System/Volumes/Preboot/Cryptexes/OS/System/**\n**Library/dyld/dyld_shared_cache_arm64e /tmp/libraries** \n```", "```\n@interface PKArchive : NSObject\n    +(id)archiveWithPath:(id)arg1;\n    +(id)_allArchiveClasses;\n    -(BOOL)closeArchive;\n    -(BOOL)fileExistsAtPath:(id)arg1;\n    -(BOOL)verifyReturningError:(id*)arg1;\n    ...\n@end \n```", "```\n@interface PKArchive : NSObject\n    +(id)archiveWithPath:(id)arg1;\n    +(id)_allArchiveClasses;\n    -(BOOL)closeArchive;\n    -(BOOL)fileExistsAtPath:(id)arg1;\n    -(BOOL)verifyReturningError:(id*)arg1;\n    ...\n\n    @property(readonly) NSString* archiveDigest;\n    @property(readonly) NSString* archivePath;\n    @property(readonly) NSDate* archiveSignatureDate;\n    @property(readonly) NSArray* archiveSignatures;\n@end\n\n@interface PKArchiveSignature : NSObject\n{\n    struct __SecTrust* _verifyTrustRef;\n}\n\n    -(struct __SecTrust*)verificationTrustRef;\n    -(BOOL)verifySignedDataReturningError:(id *)arg1;\n    -(BOOL)verifySignedData;\n    ...\n\n    @property(readonly) NSString* algorithmType;\n    @property(readonly) NSArray* certificateRefs;\n@end\n... \n```", "```\n#define PACKAGE_KIT @\"/System/Library/PrivateFrameworks/PackageKit.framework\" ❶\n\nNSMutableDictionary* checkPackage(NSString* package) {\n    NSBundle* packageKit = [NSBundle bundleWithPath:PACKAGE_KIT]; ❷\n    [packageKit load];\n\n    ...\n} \n```", "```\nClass PKArchiveCls = NSClassFromString(@\"PKArchive\");\n```", "```\nPKXARArchive* archive = [PKArchiveCls archiveWithPath:package];\n```", "```\nif(YES != [PKArchiveCls respondsToSelector:@selector(archiveWithPath:)]) {\n    goto bail;\n} \n```", "```\nNSError* error = nil;\nif(YES != [archive verifyReturningError:&error]) {\n    goto bail;\n} \n```", "```\n❶ NSArray* signatures = archive.archiveSignatures;\nif(0 == signatures.count) {\n    goto bail;\n}\n\nPKArchiveSignature* signature = signatures.firstObject;\n❷ if(YES != [signature verifySignedDataReturningError:&error]) {\n    goto bail;\n} \n```", "```\nClass PKTrustCls = NSClassFromString(@\"PKTrust\");\n\nstruct __SecTrust* trustRef = [signature verificationTrustRef];\n\n❶ PKTrust* pkTrust = [[PKTrustCls alloc] initWithSecTrust:trustRef\nusingAppleRoot:YES signatureDate:archive.archiveSignatureDate];\n\n❷ if(YES != [pkTrust evaluateTrustReturningError:&error]) {\n    goto bail;\n} \n```", "```\n#import <CommonCrypto/CommonDigest.h>\n\ntypedef uint64_t SecAssessmentTicketFlags;\nenum {\n    kSecAssessmentTicketFlagDefault = 0,\n    kSecAssessmentTicketFlagForceOnlineCheck = 1 << 0,\n    kSecAssessmentTicketFlagLegacyListCheck = 1 << 1,\n};\n\nBoolean SecAssessmentTicketLookup(CFDataRef hash, SecCSDigestAlgorithm\nhashType, SecAssessmentTicketFlags flags, double* date, CFErrorRef* errors);\n\nBOOL isPackageNotarized(PKArchiveSignature* signature) {\n    CFErrorRef error = NULL;\n    BOOL isItemNotarized = NO;\n    double notarizationDate = 0;\n\n    SecCSDigestAlgorithm hashType = kSecCodeSignatureHashSHA1;\n\n  ❶ NSData* hash = [signature signedDataReturningAlgorithm:0x0];\n    if(CC_SHA1_DIGEST_LENGTH == hash.length) {\n        hashType = kSecCodeSignatureHashSHA1;\n    } else if(CC_SHA256_DIGEST_LENGTH == hash.length) {\n        hashType = kSecCodeSignatureHashSHA256;\n    }\n\n  ❷ if(YES == SecAssessmentTicketLookup((__bridge CFDataRef)(hash), hashType,\n    kSecAssessmentTicketFlagDefault, &notarizationDate, &error)) {\n        isItemNotarized = YES;\n  ❸} else if(YES == SecAssessmentTicketLookup((__bridge CFDataRef)(hash),\n    hashType, kSecAssessmentTicketFlagForceOnlineCheck, &notarizationDate,\n    &error)) {\n        isItemNotarized = YES;\n }\n\n    return isItemNotarized;\n} \n```", "```\nCFErrorRef error = NULL;\n\nif(YES != SecAssessmentTicketLookup(hash, hashType,\nkSecAssessmentTicketFlagForceOnlineCheck, NULL, &error)) {\n    if(EACCES == CFErrorGetCode(error)) {\n        // Code placed here will run if the item's notarization ticket has been revoked.\n    }\n} \n```", "```\n% **./checkSignature GoogleChrome.pkg**\nChecking: GoogleChrome.pkg\n\nStatus: signed\nNotarized: yes\nSigning authorities (\n    \"<cert(0x11ee0ac30) s: Developer ID Installer: Google LLC (EQHXZ8M8AV)\n    i: Developer ID Certification Authority>\",\n    \"<cert(0x11ee08360) s: Developer ID Certification Authority i: Apple Root CA>\",\n    \"<cert(0x11ee07820) s: Apple Root CA i: Apple Root CA>\"\n)\n\n% **./checkSignature \"EvilQuest/Mixed In Key 8.pkg\"**\nChecking: Mixed In Key 8.pkg\n\nStatus: unsigned\n\n% **./checkSignature KeySteal/archive.pkg**\nChecking: archive.pkg\n\nStatus: certificate revoked\n\nSigning authorities: (\n    \"<cert(0x151406100) s: Developer ID Installer: fenghua he (32W7BZNTSV)\n    i: Developer ID Certification Authority>\",\n    \"<cert(0x151406380) s: Developer ID Certification Authority i: Apple Root CA>\",\n    \"<cert(0x1514082b0) s: Apple Root CA i: Apple Root CA>\"\n) \n```", "```\nSecCSFlags flags = kSecCSEnforceRevocationChecks;\nif(NSOrderedSame != [item.pathExtension caseInsensitiveCompare:@\"dmg\"]) {\n    flags |= kSecCSCheckAllArchitectures;\n}\nstatus = SecStaticCodeCheckValidity(staticCode, flags, NULL);\n... \n```", "```\n% **./checkSignature /Applications/LuLu.app**\nChecking: LuLu.app\n\nStatus: signed\nNotarized: yes\nSigning authorities: : (\n    \"<cert(0x13b814800) s: Developer ID Application: Objective-See, LLC (VBG97UB4TA)\n    i: Developer ID Certification Authority>\",\n    \"<cert(0x13b81c800) s: Developer ID Certification Authority i: Apple Root CA>\",\n    \"<cert(0x13b81d000) s: Apple Root CA i: Apple Root CA>\"\n)\n\n% **./checkSignature WindTail/Final_Presentation.app**\nChecking: Final_Presentation.app\n\nStatus: certificate revoked\n\n% **./checkSignature \"SmoothOperator/3CX Desktop App.app\"**\nChecking: 3CX Desktop App.app\n\nStatus: signed\nNotarized: revoked\n\n% ./**checkSignature MacMa/client**\nChecking: client\n\nStatus: unsigned \n```", "```\nSecCodeRef dynamicCode = NULL;\n\nNSData* data = [NSData dataWithBytes:token length:sizeof(audit_token_t)]; ❶\nNSDictionary* attributes = @{(__bridge NSString*)kSecGuestAttributeAudit:data}; ❷\n\nstatus = SecCodeCopyGuestWithAttributes(NULL,\n(__bridge CFDictionaryRef _Nullable)(attributes), kSecCSDefaultFlags, &dynamicCode); ❸\nif(errSecSuccess != status) {\n    goto bail;\n} \n```", "```\nCFURLRef path = NULL;\nSecCodeCopyPath(dynamicCode, kSecCSDefaultFlags, &path); \n```", "```\nstatic SecRequirementRef requirement = NULL;\nSecRequirementCreateWithString(CFSTR(\"anchor apple\"), kSecCSDefaultFlags, &requirement);\n\nif(errSecSuccess ==\nSecStaticCodeCheckValidity(staticCodeRef, kSecCSCheckAllArchitectures, requirement)) {\n    // Code placed here will run only if the item is signed by Apple alone.\n} \n```"]