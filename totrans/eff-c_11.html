<html><head></head><body>
<section aria-labelledby="ch11" epub:type="chapter" role="doc-chapter">
<span aria-label="229" epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch11">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">DEBUGGING, TESTING, AND ANALYSIS</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">This final chapter describes tools and techniques for producing correct, effective, safe, secure, and robust programs, including static (compile-time) and runtime assertions, debugging, testing, static analysis, and dynamic analysis. The chapter also discusses which compiler flags are recommended for use in different phases of the software development process.</p>
<p class="TX">This chapter marks a transition point from learning to program in C to professional C programming. Programming in C is relatively easy, but mastering C programming is a lifetime endeavor. Modern C programming requires a disciplined approach to develop and deploy safe, secure, and performant systems.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="230" epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/>
<h2 class="H1" id="sec1"><span id="h1-90"/><samp class="SANS_Futura_Std_Bold_B_11">Assertions</samp></h2>
<p class="TNI">An <i>assertion</i> is a function with a Boolean value, known as a <i>predicate</i>, which expresses a logical proposition about a program. You use an assertion to verify that a specific assumption you made during the implementation of your program remains valid. C supports static assertions that can be checked at compile time using <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> and runtime assertions that are checked during program execution using <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp> header. In C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> is a keyword. In C11, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> was provided as a macro in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp>. Prior to that, C did not have static assertions.</p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2" id="sec2"><span id="h2-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Assertions</samp></h3>
<p class="TNI"><i>Static assertions</i> can be expressed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> keyword as follows:</p>

<pre><code>static_assert(<var>integer-constant-expression</var>, <var>string-literal</var>);</code></pre>
<p class="TX">Since C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> also accepts a single-argument form:</p>

<pre><code>static_assert(<var>integer-constant-expression</var>);</code></pre>
<p class="TX">If the value of the integer constant expression is not equal to 0, the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> declaration has no effect. If the integer constant expression is equal to 0, the compiler will produce a diagnostic message with the text of the string literal, if present.</p>
<p class="TX">You can use static assertions to validate assumptions at compile time, such as specific implementation-defined behaviors. Any change in implementation-defined behavior will then be diagnosed at compilation.</p>
<p class="TX">Let’s look at three examples of using static assertions. First, in <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> to verify that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct packed</samp> has no padding bytes.</p>
<span id="Lis11-1"/>
<pre><code>struct packed {
  int i;
  char *p;
};

static_assert(
  sizeof(struct packed) == sizeof(int) + sizeof(char *),
  "struct packed must not have any padding"
);</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Asserting the absence of padding bytes</samp></p>
<p class="TX">The predicate for the static assertion in this example tests that the size of the packed structure is the same as the combined size of its <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> members. For example, on x86-32, both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> are 4 bytes, and the structure is not padded, but on x86-64, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> is 8 bytes, and the compiler adds 4 padding bytes between the two fields.</p>
<p class="TX"><span aria-label="231" epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/>A good use of static assertions is to document all your assumptions concerning implementation-defined behavior. This will prevent the code from compiling when porting to another implementation where those assumptions are invalid.</p>
<p class="TX">Because a static assertion is a declaration, it can appear at file scope, immediately following the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> whose property it asserts.</p>
<p class="TX">For the second example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">clear_stdin</samp> function, shown in <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a>, calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> function to read characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> until the end of the file is reached.</p>
<span id="Lis11-2"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

void clear_stdin() {
  int c;

  do {
    c = getchar();
    static_assert(
      sizeof(unsigned char) &lt; sizeof(int),
      "FIO34-C violation"
    );
  } while (c != EOF);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Using</samp> <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to verify integer sizes</samp></p>
<p class="TX">Each character is obtained as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. It’s common practice to compare the character returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> function with <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, often in a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop, to determine when all the available characters have been read. For this function loop to work correctly, the terminating condition must be able to differentiate between a character and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. However, the C standard allows for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to have the same range, meaning that on some implementations, this test for <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> could return false positives, in which case the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop may terminate early. Because this is an unusual condition, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> to validate that the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop can properly distinguish between valid characters and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.</p>
<p class="TX">In this example, the static assertion verifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(unsigned char) &lt; sizeof(int)</samp>. The static assertion is placed near the code that depends on this assumption being true so that you can easily locate the code that will need to be repaired if the assumption is violated. Because static assertions are evaluated at compile time, placing them within executable code has no impact on the runtime efficiency of the program. See the CERT C rule FIO34-C, “Distinguish between characters read from a file and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">WEOF</samp>,” for more information on this topic.</p>
<p class="TX">Finally, in <a href="chapter11.xhtml#Lis11-3">Listing 11-3</a>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> to perform compile-time bounds checking.</p>
<span id="Lis11-3"/>
<pre><code><span aria-label="232" epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>static const char prefix[] = "Error No: ";
constexpr int size = 14;
char str[size];

// ensure that str has sufficient space to store at
// least one additional character for an error code
static_assert(
  sizeof(str) &gt; sizeof(prefix),
  "str must be larger than prefix"
);
strcpy(str, prefix);</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: Using</samp> <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to perform bounds checking</samp></p>
<p class="TX">This code snippet uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> to copy a constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp> to a statically allocated array <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>. The static assertion ensures that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> has sufficient space to store at least one additional character for an error code following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>.</p>
<p class="TX">This assumption may become invalid if a developer, for example, reduced <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> or changed the prefix string to <samp class="SANS_TheSansMonoCd_W5Regular_11">"Error Number: "</samp> during maintenance. Having added the static assertion, the maintainer would now be warned about the problem.</p>
<p class="TX">Remember that the string literal is a message for the developer or maintainer and not an end user of the system. It’s intended to provide information useful for debugging.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Runtime Assertions</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro injects runtime diagnostic tests into programs. It’s defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp> header file and takes a scalar expression as a single argument:</p>

<pre><code>#define assert(scalar-expression) /* implementation-defined */</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is implementation defined. If the scalar expression is equal to 0, the macro expansion typically writes information about the failing call (including the argument text, the name of the source file <samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp>, the source line number <samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp>, and the name of the enclosing function <samp class="SANS_TheSansMonoCd_W5Regular_11">__func__</samp>) to the standard error stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>. After writing this information to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> function shown in <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a> uses runtime assertions to check that the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument is less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">LIMIT</samp> and that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is not a null pointer.</p>
<span id="Lis11-4"/>
<pre><code>void *dup_string(size_t size, char *str) {
  assert(size &lt;= LIMIT);
  assert(str != nullptr);
  // <var>--snip--</var>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: Using</samp> <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to verify program conditions</samp></p>
<p class="TX"><span aria-label="233" epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/>The messages from these assertions might take the following form:</p>

<pre><code>Assertion failed: size &lt;= LIMIT, function dup_string, file foo.c, line 122.
Assertion failed: str != nullptr, function dup_string, file foo.c, line 123.</code></pre>
<p class="TX">The implicit assumption is that the caller validates arguments before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> so that the function is never called with invalid arguments. The runtime assertions are then used to validate this assumption during the development and test phases.</p>
<p class="TX">The assertion’s predicate expression is often reported in a failed assertion message, which allows you to use <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> on a string literal with the assertion predicate to generate additional debugging information when an assertion fails. Doing so is always safe because string literals in C can never have a null pointer value. For example, we can rewrite the assertions in <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a> to have the same functionality but provide additional context when the assertion fails, as shown in <a href="chapter11.xhtml#Lis11-5">Listing 11-5</a>.</p>
<span id="Lis11-5"/>
<pre><code>void *dup_string(size_t size, char *str) {
  assert(size &lt;= LIMIT &amp;&amp; "size is larger than the expected limit");
  assert(str != nullptr &amp;&amp; "the caller must ensure str is not null");
  // <var>--snip--</var>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Using</samp> <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with additional contextual information</samp></p>
<p class="TX">You should disable assertions before code is deployed by defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> macro (typically as a flag passed to the compiler). If <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> is defined as a macro name at the point in the source file where <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp> is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is defined as follows:</p>

<pre><code>#define assert(ignore) ((void)0)</code></pre>
<p class="TX">The reason the macro does not expand empty is because if it did, then code such as</p>

<pre><code>assert(thing1) // missing semicolon
assert(thing2);</code></pre>
<p class="Continued">would compile in release mode but not in debug mode. The reason it expands to <samp class="SANS_TheSansMonoCd_W5Regular_11">((void) 0)</samp> rather than just <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is to prevent warnings about statements with no effect. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is redefined according to the current state of <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> each time that <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;assert.h&gt;</samp> is included.</p>
<p class="TX">Use static assertions to check assumptions that can be checked at compile time, and use runtime assertions to detect invalid assumptions during testing. Because runtime assertions are typically disabled before deployment, avoid using them to check for conditions that can come up during normal operations, such as the following:</p>
<ul class="ul">
<li class="ListBullet">Invalid input</li>
<li class="ListBullet">Errors opening, reading, or writing streams</li>
<li class="ListBullet"><span aria-label="234" epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>Out-of-memory conditions from dynamic allocation functions</li>
<li class="ListBullet">System call errors</li>
<li class="ListBullet">Invalid permissions</li>
</ul>
<p class="TX">You should instead implement these checks as normal error-checking code that’s always included in the executable. Assertions should be used only to validate preconditions, postconditions, and invariants designed into the code (programming errors).</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h2 class="H1" id="sec4"><span id="h1-91"/><samp class="SANS_Futura_Std_Bold_B_11">Compiler Settings and Flags</samp></h2>
<p class="TNI">Compilers typically don’t enable optimization or security hardening by default. Instead, you can enable optimization, error detection, and security hardening using build flags (Weimer 2018). I recommend specific flags for GCC, Clang, and Visual C++ in the next section, after first describing how and why you might want to use them.</p>
<p class="TX">Select your build flags based on what you’re trying to accomplish. Distinct phases of software development call for different compiler and linker configurations. Some flags, such as the warnings, will be common to all phases. Other flags, such as the debug or the optimization level, are specific to each phase.</p>
<p class="RunInPara1"><b>Build</b> The goal of the build phase is to take full advantage of compiler analysis to eliminate defects before debugging. Dealing with numerous diagnostics at this stage can seem bothersome but is much better than having to find these problems through debugging and testing, or not finding them until after the code has shipped. During the build phase, you should use compiler options that maximize diagnostics to help you eliminate as many defects as possible.</p>
<p class="RunInPara"><b>Debug</b> During debugging, you’re typically trying to determine why your code isn’t working. To best accomplish this, use a set of compiler flags that includes debug information, allows assertions to be useful, and enables a quick turnaround time for the inevitable edit-compile-debug cycle.</p>
<p class="RunInPara"><b>Test</b> You may want to retain debug information and leave assertions enabled during testing to assist in identifying the root cause of any problems that are discovered. Runtime instrumentation can be injected to help detect errors.</p>
<p class="RunInPara"><b>Profile-Guided Optimization</b> This configuration defines compiler and linker flags that control how the compiler adds runtime instrumentation to the code it normally generates. One purpose of instrumentation is to collect profiling statistics, which can be used to find program hot spots for profile-guided optimizations.</p>
<p class="RunInPara2"><b>Release</b> The final phase is to build the code for deployment to its operational environment. Before deploying the system, make sure you thoroughly test your release configuration, because using a different set <span aria-label="235" epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/>of compilation flags can trigger new defects, for example, from latent undefined behaviors or timing effects caused by optimization.</p>
<p class="TX">I’ll now cover some specific compiler and linker flags you might want to use for your compiler and software development phase.</p>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-116"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCC and Clang Flags</samp></h3>
<p class="TNI"><a href="chapter11.xhtml#tab11-1">Table 11-1</a> lists recommended compiler and linker options (aka <i>flags</i>) for both GCC and Clang. You can find documentation for compiler and linker options in the GCC manual (<i><a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/onlinedocs<wbr/>/gcc<wbr/>/Invoking<wbr/>-GCC<wbr/>.html</a></i>) and the Clang Compiler User’s Manual (<i><a href="https://clang.llvm.org/docs/UsersManual.html#command-line-options">https://<wbr/>clang<wbr/>.llvm<wbr/>.org<wbr/>/docs<wbr/>/UsersManual<wbr/>.html#command<wbr/>-line<wbr/>-options</a></i>).</p>
<p class="TT" id="tab11-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended Compiler and Linker Flags for GCC and Clang</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Detect buffer overflows</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,-pie</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Required for address space layout randomization</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic -shared</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Disable text relocations for shared libraries</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Generate abundant debugging information</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Optimize your code for speed/space efficiency</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Turn on recommended compiler warnings</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Turn on even more recommended compiler warnings</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Turn warnings into errors</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Specify the language standard</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Issue warnings demanded by strict conformance to the standard</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Warn for implicit conversions that may alter a value</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Mark the stack segments as nonexecutable</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Add stack protection to functions</samp></p></td>
</tr>
</tbody>
</table>
<section aria-labelledby="sec6" epub:type="division">

<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-O</samp></h4>
<p class="TNI">The uppercase letter <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> flag controls <i>compiler optimization</i>. Most optimizations are completely disabled at optimization level 0 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-O0</samp>). This is the default when no optimization level has been set by a command line option. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp> flag suppresses optimization passes that may hinder the debugging experience.</p>
<p class="TX">Many diagnostics are issued by GCC only at higher optimization levels, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">-02</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>. To ensure that issues are identified during development, use the same (higher) optimization level you plan to adopt in production during the compilation and analysis phase. Clang, on the other hand, does not require the optimizer to issue diagnostics. As a result, Clang can be run <span aria-label="236" epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/>with optimizations disabled during the compilation/analysis and debug phases.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp> compiler option optimizes for size, enabling all <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp> optimizations except those that often increase code size. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> compiler option optimizes aggressively for size rather than speed, which may increase the number of instructions executed if those instructions require fewer bytes to encode. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> option behaves similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>, and it may be used in Clang but only in conjunction with <samp class="SANS_TheSansMonoCd_W5Regular_11">-mno-outline</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> compiler option may be used in GCC versions 12.1 or greater.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h4 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-glevel</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp> flag produces debugging information in the operating system’s native format. You can specify how much information to produce by setting the debug <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>. The default level is <samp class="SANS_TheSansMonoCd_W5Regular_11">-g2</samp>. Level 3 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp>) includes extra information, such as all the macro definitions present in the program. Level 3 also allows you to expand macros in debuggers that support the capability.</p>
<p class="TX">Different settings are appropriate for debugging. Optimization levels should be low or disabled so that the machine instructions correspond closely to the source code. Symbols should also be included to assist in debugging. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> compiler flags are a good default, although other options are acceptable.</p>
<p class="TX">Consider the following program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define HELLO "hello world!"

int main()
{
  puts(HELLO);

  return EXIT_SUCCESS;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp> compiler option affects only the optimization level without enabling debug symbols:</p>

<pre><code>$ <b>gcc -Og hello.c -o hello</b>
$ <b>gdb hello</b>
(...)
(No debugging symbols found in hello)
(gdb)</code></pre>
<p class="TX">Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g</samp> provides some symbols:</p>

<pre><code>$ <b>gcc -Og -g hello.c -o hello</b>
$ <b>gdb hello</b>
(...)
Reading symbols from hello...
<span aria-label="237" epub:type="pagebreak" id="pg_237" role="doc-pagebreak"/>(gdb) break main
Breakpoint 1 at 0x1149: file hello.c, line 6.
(gdb) start
Temporary breakpoint 2 at 0x1149: file hello.c, line 6.
Starting program: /home/test/Documents/test/hello

Breakpoint 1, main () at hello.c:6
6      int main()
(gdb) print HELLO
No symbol "HELLO" in current context.
(gdb)</code></pre>
<p class="TX">Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g3</samp> adds more symbols:</p>

<pre><code>$ <b>gcc -Og -g3 hello.c -o hello</b>
$ <b>gdb hello</b>
(...)
Reading symbols from hello...
(gdb) break main
Breakpoint 1 at 0x1149: file hello.c, line 6.
(gdb) start
Temporary breakpoint 2 at 0x1149: file hello.c, line 6.
Starting program: /home/test/Documents/test/hello

Breakpoint 1, main () at hello.c:6
6      int main()
(gdb) print HELLO
$1 = "hello world!"
(gdb)</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> option causes debugging information to be generated in the operating system’s native format, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">-ggdb3</samp> option tells GCC to use the most expressive format available for use by the GNU Project debugger (GDB). As a result, if you are only debugging with GDB, <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -ggdb3</samp> is also a good choice of options.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> options are recommended for the standard edit-compile-debug cycle.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wall and -Wextra</samp></h4>
<p class="TNI">Compilers typically enable by default only the most conservatively correct diagnostic messages. Additional diagnostics can be enabled to check source code more aggressively for issues. Use the following flags to enable additional diagnostic messages when compiling code with GCC and Clang: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> compiler flags enable predefined sets of compile-time warnings. The warnings in the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> set are generally easy to avoid or eliminate by modifying the diagnosed code. The warnings in the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> set either are situational or indicate problematic constructs that are harder to avoid and, in some cases, may be necessary.</p>
<p class="TX"><span aria-label="238" epub:type="pagebreak" id="pg_238" role="doc-pagebreak"/>Despite their names, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> options do not enable all possible warning diagnostics; they enable only a predefined subset. For a complete list of specific warnings enabled by the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> compiler flags, on GCC run:</p>

<pre><code>$ <b>gcc -Wall -Wextra -Q --help=warning</b></code></pre>
<p class="TX">Alternatively, you can consult the documentation for GCC warning options and Clang diagnostic flags.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wconversion</samp></h4>
<p class="TNI">Data type conversions can alter data values in unexpected ways. Memory safety violations may result from adding or subtracting these values from a pointer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> compiler option warns about:</p>
<ul class="ul">
<li class="ListBullet">Implicit conversions that may alter a value, including conversions between floating-point and integer values</li>
<li class="ListBullet">Conversions between signed and unsigned integers, for example:</li>
</ul>

<pre><code>unsigned ui = -1;</code></pre>
<ul class="ul">
<li class="ListBullet">Conversions to smaller types</li>
</ul>
<p class="TX">Warnings about conversions between signed and unsigned integers can be disabled by using <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wno-sign-conversion</samp>, but they’re often useful in finding certain classes of defects and security vulnerabilities. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> command line option should remain enabled.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Werror</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> flag turns all warnings into errors, requiring you to address them before you can begin debugging. This flag simply encourages good programming discipline.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-std=</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> flag can be used to specify the language standard as <samp class="SANS_TheSansMonoCd_W5Regular_11">c89</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c90</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c99</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c11</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c17</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">c23</samp> (you may need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp> when using an older compiler). If no C language dialect options are given, the default for GCC 13 is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=gnu17</samp>, which provides extensions to the C language that, on rare occasions, conflict with the C standard. For portability, specify the standard you’re using. For access to new language features, specify a recent standard. A good choice if you are reading this second edition of <i>Effective C</i> is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h4 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-pedantic</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag issues warnings when code deviates from strict conformance to the standard. This flag is typically used in conjunction with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> flag to improve the code’s portability.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<span aria-label="239" epub:type="pagebreak" id="pg_239" role="doc-pagebreak"/>
<h4 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-D_FORTIFY_SOURCE=2</samp></h4>
<p class="TNI">The _<samp class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro provides lightweight support for detecting buffer overflows in functions that perform operations on memory and strings. This macro can’t detect all types of buffer overflows, but compiling your source with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp> provides an extra level of validation for functions that copy memory and are a potential source of buffer overflows such as <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp>. Some of the checks can be performed at compile time and result in diagnostics; others occur at runtime and can result in a runtime error.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> macro requires optimizations to be enabled. Consequently, it must be disabled for unoptimized debug builds.</p>
<p class="TX">To overwrite a predefined <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> value, turn it off with <samp class="SANS_TheSansMonoCd_W5Regular_11">-U_FORTIFY _SOURCE</samp> and on again with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>. This will eliminate the warning that macros are being redefined.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp> macro has improved compiler checks for buffer overflows since version 12 of GCC and version 2.34 of the GNU C Library (glibc). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE={1,2,3}</samp> macro for glibc relies heavily on GCC-specific implementation details. Clang implements its own style of fortified function calls.</p>
<p class="TX">Specify either <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp> (recommended) or <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=1</samp> for analysis, testing, and production builds using Clang and GCC versions prior to 12.0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp> for GCC version 12.0 and later.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h4 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fpie -Wl, -pie, and -fpic -shared</samp></h4>
<p class="TNI"><i>Address space layout randomization (ASLR)</i> is a security mechanism that randomizes the process’s memory space to prevent attackers from predicting the location of the code they’re trying to execute. You can learn more about ASLR and other security mitigations in <i>Secure Coding in C and C++</i> (Seacord 2013).</p>
<p class="TX">You must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-pie</samp> flags to create position-independent executable programs and make it possible to enable ASLR for your main program (executable). However, while code emitted for your main program with these options is position independent, it does use some relocations that cannot be used in shared libraries (dynamic shared objects). For those, use <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic</samp> and link with <samp class="SANS_TheSansMonoCd_W5Regular_11">-shared</samp> to avoid text relocations on architectures that support position-dependent shared libraries. Dynamic shared objects are always position independent and therefore support ASLR.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wl,-z,noexecstack</samp></h4>
<p class="TNI">Several operating systems, including OpenBSD, Windows, Linux, and macOS, enforce reduced privileges in the kernel to prevent any part of the process address space from being both writable and executable. This policy is called W^X.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp> linker option tells the linker to mark the stack segments as nonexecutable, which enables the operating system (OS) to <span aria-label="240" epub:type="pagebreak" id="pg_240" role="doc-pagebreak"/>configure memory access rights when the program executable is loaded into memory.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h4 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fstack-protector-strong</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp> option protects applications from the most common forms of stack buffer overflow exploits by adding a stack canary. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector</samp> option is often viewed as insufficient and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-all</samp> option as excessive. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp> option was introduced as a compromise between these two extremes.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">

<h3 class="H2" id="sec17"><span id="h2-117"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Visual C++ Options</samp></h3>
<p class="TNI">Visual C++ provides a wide assortment of compiler options, many of which are similar to the options available for GCC and Clang. One obvious difference is that Visual C++ generally uses the forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>) character instead of a hyphen (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>) to indicate a flag. <a href="chapter11.xhtml#tab11-2">Table 11-2</a> lists recommended compiler and linker flags for Visual C++. (For more information on Visual C++ options, see <i><a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category">https://<wbr/>docs<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/cpp<wbr/>/build<wbr/>/reference<wbr/>/compiler<wbr/>-options<wbr/>-listed<wbr/>-by<wbr/>-category</a></i>.)</p>
<p class="TT" id="tab11-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended Compiler Flags for Visual C++</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Add control flow guard security checks</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Enable static analysis</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Enable security features</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Specify standards conformance mode to the compiler</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set optimization to level 2</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set compiler warnings to level 4</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Turn warnings into errors</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Select the latest/greatest language version</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Several of these options are similar to options provided by the GCC and Clang compilers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> optimization level is appropriate for deployed code, while <samp class="SANS_TheSansMonoCd_W5Regular_11">/Od</samp> disables optimization to speed compilation and simplify debugging. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> warning level is appropriate for new code, as it’s roughly equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> in GCC and Clang. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/Wall</samp> option in Visual C++ isn’t recommended because it produces a high number of false positives. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp> option turns warnings into errors and is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> flag in GCC and Clang. I cover the remaining flags in further detail in the following sections.</p>
<section aria-labelledby="sec18" epub:type="division">

<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">/guard:cf</samp></h4>
<p class="TNI">When you specify the <i>control flow guard (CFG)</i> option, the compiler and linker insert extra runtime security checks to detect attempts to compromise your <span aria-label="241" epub:type="pagebreak" id="pg_241" role="doc-pagebreak"/>code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> option must be passed to both the compiler and the linker.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h4 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">/analyze</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> flag enables static analysis, which provides information about possible defects in your code. I discuss static analysis in more detail in “<span class="Xref">Static Analysis</span>” on <span class="Xref"><a href="#pg_251">page 251</a></span>.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h4 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">/sdl</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag enables additional security features, including treating extra security-relevant warnings as errors and additional secure code-generation features. It also enables other security features from the Microsoft <i>Security Development Lifecycle (SDL)</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag should be used in all production builds where security is a concern.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h4 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">/permissive-</samp></h4>
<p class="TNI">You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp> to help identify and fix conformance issues in your code, thereby improving your code’s correctness and portability. This option disables permissive behaviors and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">/Zc</samp> compiler options for strict conformance. In the integrated development environment (IDE), this option also underlines nonconforming code.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">

<h4 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">/std:clatest</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> option enables all currently implemented compiler and standard library features proposed for C23. There is no <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:c23</samp> at the time of writing, but once one becomes available, you can use it to build C23 code.</p>
</section>
</section>
</section>
<section aria-labelledby="sec23" epub:type="division">

<h2 class="H1" id="sec23"><span id="h1-92"/><samp class="SANS_Futura_Std_Bold_B_11">Debugging</samp></h2>
<p class="TNI">I’ve been programming professionally for 42 years. Once or maybe twice during that time, I’ve written a program that compiled and ran correctly on the first try. For all the other times, there is debugging.</p>
<p class="TX">Let’s debug a faulty program. The program shown in <a href="chapter11.xhtml#Lis11-6">Listing 11-6</a> is an early version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp> function. We reviewed a finished version of this program in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, but this version is not yet ready to deploy.</p>
<span id="Lis11-6"/>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

#define name_size 20U

char *vstrcat(char *buff, size_t buff_length, ...) {
  char *ret = buff;
<span aria-label="242" epub:type="pagebreak" id="pg_242" role="doc-pagebreak"/>  va_list list;
  va_start(list, buff_length);

  const char *part = nullptr;
  size_t offset = 0;
  while ((part = va_arg(list, const char *))) {
   buff = (char *)memccpy(buff, part, '\0', buff_length - offset) - 1;
   if (buff == nullptr) {
     ret[0] = '\0';
     break;
   }
   offset = buff - ret;
  }

  va_end(list);
  return ret;
}

int main() {
  char name[name_size] = "";
  char first[] = "Robert";
  char middle[] = "C.";
  char last[] = "Seacord";

  puts(
    vstrcat(
      name, sizeof(name), first, " ",
      middle, " ", last, nullptr
    )
  );
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: Printing an error</samp></p>
<p class="TX">When we run this program as shown, it outputs my name as expected:</p>

<pre><code>Robert C. Seacord</code></pre>
<p class="TX">However, we also want to ensure that this program, which uses a fixed-size array for <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, properly handles the case where the full name is larger than the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> array. To test this, we can change the size of the array to a too-small value:</p>

<pre><code>#define name_size 10U</code></pre>
<p class="Continued">Now, when we run the program, we learn we have a problem but not much more than that:</p>

<pre><code>$ <b>./bug</b>
Segmentation fault</code></pre>
<p class="TX">Instead of adding print statements, we’ll take the plunge and debug this program using Visual Studio Code on Linux. Just running this <span aria-label="243" epub:type="pagebreak" id="pg_243" role="doc-pagebreak"/>program in the debugger, as shown in <a href="chapter11.xhtml#fig11-1">Figure 11-1</a>, provides us with some information that we didn’t previously have.</p>
<figure class="IMG"><img alt="" class="img1" id="fig11-1" src="../images/f11001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Debugging a program in Visual Studio Code</samp></p></figcaption>
</figure>
<p class="TX">We can see from the CALL STACK pane that we are crashing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__memmove_avx_unaligned_erms</samp> function in libc.</p>

<pre><code>libc.so.6!__memmove_avx_unaligned_erms()
(\x86_64\multiarch\memmove-vec-unaligned-erms.S:314)
vstrcat(char * buff, size_t buff_length) (\home\rcs\bug.c:17)
main() (\home\rcs\bug.c:32)</code></pre>
<p class="TX">We can also see that the segmentation fault is occurring on the line with the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>. There isn’t much else going on in this line, so it’s reasonable to surmise that this function is a <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> helper function. It’s seldom the case that the bug is in the implementation of the library function, so we’ll assume for now that we’re passing an invalid set of arguments.</p>
<p class="TX">Before looking at the arguments, let’s review the description of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function from the C23 standard:</p>
<p class="BlockquoteFirst"><samp class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;string.h&gt;</samp></p>
<p class="Blockquote"><samp class="SANS_TheSansMonoCd_W5Regular_11">void *memccpy(void * restrict s1, const void * restrict s2, int c, size_t n);</samp></p>
<p class="BlockquoteLast">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function copies characters from the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp> into the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, stopping after the first occurrence of character <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> (converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) is copied or after <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters are copied, whichever comes first. If copying takes place between objects that overlap, the behavior is undefined.</p>
<p class="TX"><span aria-label="244" epub:type="pagebreak" id="pg_244" role="doc-pagebreak"/>From the Variables pane in the debugger, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp> we are adding looks correct:</p>

<pre><code><b>part:</b> 0x7fffffffdcd6 "Seacord"</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> alias to the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> also has an expected value:</p>

<pre><code><b>ret:</b> 0x7fffffffdcde "Robert C. "</code></pre>
<p class="TX">The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>, however, seems odd, as it has the same value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> (–1):</p>

<pre><code>buff: 0xffffffffffffffff &lt;error: Cannot access memory at address 0xffffffffffffffff&gt;</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> parameter is a character pointer that is assigned the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>. So once again, let’s check the standard to see what this function returns:</p>
<p class="BlockquoteSingle">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function returns a pointer to the character after the copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, or a null pointer if <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> was not found in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>.</p>
<p class="TX">According to the C standard, this function can return only a null pointer or a pointer to a character in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>, in this program). The storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> begins at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7fffffffdcde</samp> and extends for only 10 bytes, so neither of these explain the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp> value, so the mystery deepens.</p>
<p class="TX">It’s time to examine the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp> function more closely. We’ll set a breakpoint on line 12 near the beginning of the function and start debugging. The buttons along the left of the title bar allow you to continue, step over, step into, step out, restart, and stop debugging. Starting from line 12, we can single-step through the program by clicking the Step Over button. The <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp> function loops several times, so you’ll have to step through a few iterations of the loop, watching the values in the VARIABLES pane. If you do this carefully, you’ll eventually see that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp> on line 18 following the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function, as shown in <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>. This isn’t detected by the null pointer test, and the segmentation fault occurs on the next iteration.</p>
<p class="TX">It was here that I had my eureka moment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function returns a null pointer to indicate that <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp> was not found in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length - offset</samp> characters of <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>. However, we are subtracting 1 from the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> so that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> points to the first occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp> rather than just after it. This works when the character is found, but when it isn’t found, we subtract 1 from a null pointer, which is technically undefined behavior in C. On this implementation, the null pointer is represented by a 0 value. Subtracting 1 from 0 wraps around and produces the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp> value for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> before we can test it. Consequently, the error condition is not detected, and the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> results in the segmentation fault.<span aria-label="245" epub:type="pagebreak" id="pg_245" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img1" id="fig11-2" src="../images/f11002.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: An interesting program state</samp></p></figcaption>
</figure>
<p class="TX">Now that we have discovered the root cause, the bug can be repaired by moving the minus-one subtraction after the null pointer check, which results in the final version of the program shown in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">

<h2 class="H1" id="sec24"><span id="h1-93"/><samp class="SANS_Futura_Std_Bold_B_11">Unit Testing</samp></h2>
<p class="TNI">Testing increases your confidence that your code is defect free. <i>Unit tests</i> are small programs that exercise your code. <i>Unit testing</i> is a process that validates that each unit of the software performs as designed. A <i>unit</i> is the smallest testable part of any software; in C, this is typically an individual function or data abstraction.</p>
<p class="TX">You can write simple tests that resemble normal application code (see <a href="chapter11.xhtml#Lis11-7">Listing 11-7</a>, for example), but it can be beneficial to use a <i>unit-testing framework</i>. Several unit-testing frameworks are available, including Google Test, CUnit, CppUnit, Unity, and others. We’ll examine the most popular of these, based on a recent survey of the C development ecosystem by JetBrains (<i><a href="https://www.jetbrains.com/lp/devecosystem-2023/c/">https://<wbr/>www<wbr/>.jetbrains<wbr/>.com<wbr/>/lp<wbr/>/devecosystem<wbr/>-2023<wbr/>/c<wbr/>/</a></i>): Google Test.</p>
<p class="TX">Google Test works for Linux, Windows, and macOS. Tests are written in C++, so you get to learn another (related) programming language for testing purposes. CUnit and Unity are good alternatives if you want to restrict your testing to pure C.</p>
<p class="TX">In Google Test, you write assertions to verify the tested code’s behavior. Google Test assertions, which are function-like macros, are the real language of the tests. If a test crashes or has a failed assertion, it fails; otherwise, it succeeds. An assertion’s result can be success, nonfatal failure, or fatal failure. If a fatal failure occurs, the current function is aborted; otherwise, the program continues normally.</p>
<p class="TX"><span aria-label="246" epub:type="pagebreak" id="pg_246" role="doc-pagebreak"/>We’ll use Google Test on Ubuntu Linux. To install it, follow the directions from the Google Test GitHub page at <i><a href="https://github.com/google/googletest/tree/main/googletest">https://<wbr/>github<wbr/>.com<wbr/>/google<wbr/>/googletest<wbr/>/tree<wbr/>/main<wbr/>/googletest</a></i>.</p>
<p class="TX">Once Google Test is installed, we’ll set up a unit test for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function shown in <a href="chapter11.xhtml#Lis11-7">Listing 11-7</a>. This function returns an error message string corresponding to the error number passed in as an argument. You’ll need to include the headers that declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp> type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions. Save it in a file named <i>error.c</i> so that the build instructions described later in this section will work properly.</p>
<span id="Lis11-7"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp></p>
<pre class="pre"><code>char *get_error(errno_t errnum) {
  rsize_t size = strerrorlen_s(errnum) + 1;
  char* msg = malloc(size);
  if (msg != nullptr) {
    errno_t status = strerror_s(msg, size, errnum);
    if (status != 0) {
      strncpy_s(msg, size, "unknown error", size - 1);
    }
  }
  return msg;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: The</samp> <samp class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">This function calls both the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions defined in the normative but optional Annex K, “Bounds-checking interfaces” (described in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>).</p>
<p class="TX">Unfortunately, neither GCC nor Clang implements Annex K, so instead we’ll use the Safeclib implementation developed by Reini Urban and available from GitHub (<i><a href="https://github.com/rurban/safeclib">https://<wbr/>github<wbr/>.com<wbr/>/rurban<wbr/>/safeclib</a></i>).</p>
<p class="TX">You can install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp> on Ubuntu with the following command:</p>

<pre><code>% <b>sudo apt install libsafec-dev</b></code></pre>
<p class="TX"><a href="chapter11.xhtml#Lis11-8">Listing 11-8</a> contains a unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function named <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>. A <i>test suite</i> is a set of test cases to be executed in a specific test cycle. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp> suite consists of two test cases: <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>. A <i>test case</i> is a set of preconditions, inputs, actions (where applicable), expected results, and postconditions, developed based on test conditions (<i><a href="https://glossary.istqb.org">https://<wbr/>glossary<wbr/>.istqb<wbr/>.org</a></i>). Save this code in a file named <i>tests.cc</i>.</p>
<span id="Lis11-8"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp></p>
<pre class="pre"><code>#include &lt;gtest/gtest.h&gt;
#include &lt;errno.h&gt;
#define errno_t int

// implemented in a C source file
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> extern "C" char* get_error(errno_t errnum);

namespace {
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> TEST(GetErrorTest, KnownError) {
    EXPECT_STREQ(get_error(ENOMEM), "Cannot allocate memory");
<span aria-label="247" epub:type="pagebreak" id="pg_247" role="doc-pagebreak"/>    EXPECT_STREQ(get_error(ENOTSOCK), "Socket operation on non-socket");
    EXPECT_STREQ(get_error(EPIPE), "Broken pipe");
  }

  TEST(GetErrorTest, UnknownError) {
    EXPECT_STREQ(get_error(-1), "Unknown error -1");
  }
} // namespace

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Unit tests for the</samp> <samp class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">Most of the C++ code is boilerplate and can be copied without modification, including, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function, which invokes the function-like macro <samp class="SANS_TheSansMonoCd_W5Regular_11">RUN_ALL_TESTS</samp> to execute your tests. The two parts that aren’t boilerplate are the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> declaration <span aria-label="annotation1" class="CodeAnnotation">❶</span> and the tests <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> declaration changes the linkage requirements so that the C++ compiler linker doesn’t mangle the function name, as it is wont to do. You need to add a similar declaration for each function being tested, or you can simply include the C header file within an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> block as follows:</p>

<pre><code>extern "C" {
  #include "api_to_test.h"
}</code></pre>
<p class="TX">An <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> declaration is necessary only when compiling with C but linking with C++.</p>
<p class="TX">Both test cases are specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp> macro, which takes two arguments. The first argument is the name of the test suite, and the second argument is the name of the test case.</p>
<p class="TX">Insert Google Test assertions, along with any additional C++ statements you wish to include, in the function body. In <a href="chapter11.xhtml#Lis11-8">Listing 11-8</a>, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT _STREQ</samp> assertion, which verifies that two strings have the same content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function returns a locale-specific message string, which can vary between implementations.</p>
<p class="TX">We used the assertion on several error numbers to verify that the function is returning the correct string for each error number. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_STREQ</samp> assertion is a nonfatal assertion because testing can continue even when this specific assertion fails. This is typically preferable to fatal assertions, as it lets you detect and fix multiple bugs in a single run-edit-compile cycle. If it’s not possible to continue testing after an initial failure (because a subsequent operation relies on a previous result, for example), you can use the fatal <samp class="SANS_TheSansMonoCd_W5Regular_11">ASSERT_STREQ</samp> assertion.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-9">Listing 11-9</a> shows a simple <i>CMakeLists.txt</i> file that can be used to build the tests. This file assumes that the C functions we’re testing can be found in the <i>error.c</i> file and that the implementations of the Annex K functions are provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">safec</samp> library.</p>
<span id="Lis11-9"/>
<pre><code><span aria-label="248" epub:type="pagebreak" id="pg_248" role="doc-pagebreak"/>cmake_minimum_required(VERSION 3.21)
cmake_policy(SET CMP0135 NEW)
project(chapter-11)

# GoogleTest requires at least C++14
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_C_STANDARD 23)

include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip
)

FetchContent_MakeAvailable(googletest)

include(ExternalProject)
ExternalProject_Add(
  libsafec
  BUILD_IN_SOURCE 1
  URL https://github.com/rurban/safeclib/releases/download/v3.7.1/safeclib-3.7.1.tar.gz
  CONFIGURE_COMMAND autoreconf --install
  COMMAND ./configure --prefix=${CMAKE_BINARY_DIR}/libsafec
)
ExternalProject_Get_Property(libsafec install_dir)
include_directories(${install_dir}/src/libsafec/include)
link_directories(${install_dir}/src/libsafec/src/.libs/)

enable_testing()

add_library(error error.c)
add_dependencies(error libsafec)
add_executable(tests tests.cc)

target_link_libraries(
  tests
  error
  safec
  GTest::gtest_main
)

include(GoogleTest)
gtest_discover_tests(tests)</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: The</samp> <samp class="SANS_Futura_Std_Book_11">CMakeLists.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp></p>
<p class="TX">If you prefer to install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">apt install</samp> command, remove the lines specific to installing <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec</samp>.</p>
<p class="TX">Build and run the tests using the following sequence of commands:</p>

<pre><code>$ <b>cmake -S . -B build</b>
$ <b>cmake --build build</b>
$ <b>./build/tests</b></code></pre>
<p class="TX"><span aria-label="249" epub:type="pagebreak" id="pg_249" role="doc-pagebreak"/>The test case tests for several error numbers from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;errno.h&gt;</samp>. How many of these should be tested depends on what you’re trying to accomplish. Ideally, the tests should be comprehensive, which would mean adding an assertion for every error number in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;errno.h&gt;</samp>. This can become tiresome, however; once you have established that your code is working, you’re mostly just testing that the underlying C standard library functions you’re using are implemented correctly. Instead, we could test the error numbers we’re likely going to retrieve, but doing so can again become tiresome because we’d have to identify all the functions called in the program and which error codes they may return. We opted to implement a few spot checks for several randomly selected error numbers from different locations in the list.</p>
<p class="TX"><a href="chapter11.xhtml#Lis11-10">Listing 11-10</a> shows the result of running this test.</p>
<span id="Lis11-10"/>
<pre><code>$ <b>./build/tests</b>
[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from GetErrorTest
[RUN       ] GetErrorTest.KnownError
[        OK] GetErrorTest.KnownError (0 ms)
[RUN       ] GetErrorTest.UnknownError
/home/rcs/tests.cc:19: Failure
Expected equality of these values:
  get_error(-1)
    Which is: "Unknown error -1"
  "unknown error"
<b>[  FAILED  ] GetErrorTest.UnknownError (0 ms)</b>
[----------] 2 tests from GetErrorTest (0 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 1 test.
<b>[  FAILED  ] 1 test, listed below:</b>
<b>[  FAILED  ] GetErrorTest.UnknownError</b>

1 FAILED TEST</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: An unsuccessful test run</samp></p>
<p class="TX">From the test output, you can see that two tests were executed from one test suite. The <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp> test case passed, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp> test case failed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp> test failed because the following assertion returned false:</p>

<pre><code>EXPECT_STREQ(get_error(-1), "unknown error");</code></pre>
<p class="TX">The test assumed that the error path in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function would execute and return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"unknown error"</samp>). Instead, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function returned the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Unknown error -1"</samp>. Examining the source code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function (at <i><a href="https://github.com/rurban/safeclib/blob/master/src/str/strerror_s.c">https://<wbr/>github<wbr/>.com<wbr/>/rurban<wbr/>/safeclib<wbr/>/blob<wbr/>/master<wbr/>/src<wbr/>/str<wbr/>/strerror<wbr/>_s<wbr/>.c</a></i>), we can see that the function does return error codes. Consequently, it’s clear that the function doesn’t treat an unknown error number as an error. Checking the C standard, we see that “<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> shall <span aria-label="250" epub:type="pagebreak" id="pg_250" role="doc-pagebreak"/>map any value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to a message,” so the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function is implemented correctly, but our assumptions about how it behaved were incorrect.</p>
<p class="TX">There is a defect in the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function in that it indicates “unknown error” when the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function fails, but according to the standard:</p>
<p class="BlockquoteSingle">The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function returns zero if the length of the desired string was less than <samp class="SANS_TheSansMonoCd_W5Regular_11">maxsize</samp> and there was no runtime-constraint violation. Otherwise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function returns a nonzero value.</p>
<p class="TX">Consequently, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function returns a nonzero value, a serious error has occurred that’s bad enough to reconsider the design of this function. Instead of returning a string on an error condition, it should probably return a null pointer or otherwise handle the error in a manner consistent with the overall error handling strategy for your system. <a href="chapter11.xhtml#Lis11-11">Listing 11-11</a> updates the function to return a null pointer value.</p>
<span id="Lis11-11"/>
<pre><code>char *get_error(errno_t errnum) {
  rsize_t size = strerrorlen_s(errnum) + 1;
  char* msg = malloc(size);
  if (msg != nullptr) {
    errno_t status = strerror_s(msg, size, errnum);
    if (status != 0) return nullptr;
  }
  return msg;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: The</samp> <samp class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">We need to repair the test to check for the correct string returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error(-1)</samp>:</p>

<pre><code>EXPECT_STREQ(get_error(-1), “Unknown error -1”);</code></pre>
<p class="TX">After making this change, rebuilding, and rerunning the tests, we can see that both test cases succeeded as shown in <a href="chapter11.xhtml#Lis11-12">Listing 11-12</a>.</p>
<span id="Lis11-12"/>
<pre><code>$ <b>./build/tests</b>
[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from GetErrorTest
[RUN       ] GetErrorTest.KnownError
[        OK] GetErrorTest.KnownError (0 ms)
[RUN       ] GetErrorTest.UnknownError
[        OK] GetErrorTest.UnknownError (0 ms)
[----------] 2 tests from GetErrorTest (0 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 2 tests.</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: A successful test run</samp></p>
<p class="TX"><span aria-label="251" epub:type="pagebreak" id="pg_251" role="doc-pagebreak"/>In addition to discovering a design error, we also discovered that our tests are incomplete, as we failed to test the error case. We should add further tests to ensure that error cases are handled correctly. Adding these tests is left as an exercise for the reader.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">

<h2 class="H1" id="sec25"><span id="h1-94"/><samp class="SANS_Futura_Std_Bold_B_11">Static Analysis</samp></h2>
<p class="TNI"><i>Static analysis</i> includes any process for assessing code without executing it (ISO/IEC TS 17961:2013) to provide information about possible software defects.</p>
<p class="TX">Static analysis has practical limitations, as the correctness of software is computationally undecidable. For example, the halting theorem of computer science states that there are programs whose exact control flow cannot be determined statically. As a result, any property dependent on control flow—such as halting—may not be decidable for some programs. Consequently, static analysis may fail to report flaws or may report flaws where they don’t exist.</p>
<p class="TX">A failure to report a real flaw in the code is known as a <i>false negative</i>. False negatives are serious analysis errors, as they may leave you with a false sense of security. Most tools err on the side of caution and, as a result, generate false positives. A <i>false positive</i> is a test result that incorrectly indicates that a flaw is present. Tools might report some high-risk flaws and miss other flaws as an unintended consequence of trying not to overwhelm the user with false positives. False positives can also occur when the code is too complex to completely analyze. The use of function pointers and libraries can make false positives more likely.</p>
<p class="TX">Ideally, tools are both complete and sound in their analysis. An analyzer is considered <i>sound</i> if it cannot give a false-negative result. An analyzer is considered <i>complete</i> if it cannot issue false positives. The possibilities for a given rule are outlined in <a href="chapter11.xhtml#fig11-3">Figure 11-3</a>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig11-3" src="../images/f11003.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Completeness and soundness</samp></p></figcaption>
</figure>
<p class="TX">Compilers perform limited analysis, providing diagnostics about highly localized issues in code that don’t require much reasoning. For example, when comparing a signed value to an unsigned value, the compiler may issue a diagnostic about a type mismatch because it doesn’t require additional information to identify the error. As mentioned earlier in this chapter, there are numerous compiler flags, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> for Visual C++ and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> for GCC and Clang, that control compiler diagnostics.</p>
<p class="TX"><span aria-label="252" epub:type="pagebreak" id="pg_252" role="doc-pagebreak"/>Compilers generally provide high-quality diagnostics, and you shouldn’t ignore them. Always try to understand the reason for the warning and rewrite the code to eliminate the error, rather than simply quieting warnings by adding type casts or making arbitrary changes until the warning goes away. See the CERT C rule MSC00-C, “Compile cleanly at high warning levels,” for more information on this topic.</p>
<p class="TX">Once you’ve addressed compiler warnings in your code, you can use a separate static analyzer to identify additional flaws. Static analyzers will diagnose more complex defects by evaluating the expressions in your program, performing in-depth control and data flow analysis, and reasoning about the possible ranges of values and control flow paths taken.</p>
<p class="TX">Having a tool locate and identify specific errors in your program is much, much easier than hours of testing and debugging, and it’s much less costly than deploying defective code. A wide variety of free and commercial static analysis tools are available. For example, Visual C++ has incorporated a static analyzer that you can invoke with the <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> flag. Visual C++ analysis allows you to specify which rule sets (such as recommended, security, or internationalization) you would like to run or whether to run them all. For more information on Visual C++’s static code analysis, see Microsoft’s website at <i><a href="https://learn.microsoft.com/en-us/visualstudio/code-quality">https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/visualstudio<wbr/>/code<wbr/>-quality</a></i>. Similarly, Clang has incorporated a static analyzer that can be run as a stand-alone tool or within Xcode (<i><a href="https://clang-analyzer.llvm.org">https://<wbr/>clang<wbr/>-analyzer<wbr/>.llvm<wbr/>.org</a></i>). Beginning with version 10, GCC has introduced static analysis that’s enabled through the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fanalyzer</samp> option. Commercial tools also exist, such as CodeQL from GitHub, TrustInSoft Analyzer, SonarQube from SonarSource, Coverity from Synopsys, LDRA Testbed, Helix QAC from Perforce, and others.</p>
<p class="TX">Many static analysis tools have nonoverlapping capabilities, so it may make sense to use more than one.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h2 class="H1" id="sec26"><span id="h1-95"/><samp class="SANS_Futura_Std_Bold_B_11">Dynamic Analysis</samp></h2>
<p class="TNI"><i>Dynamic analysis</i> is the process of evaluating a system or component during execution. It’s also referred to as <i>runtime analysis</i>, among other similar names.</p>
<p class="TX">A common approach to dynamic analysis is to <i>instrument</i> the code—for example, by enabling compile-time flags that inject extra instructions into the executable—and then run the instrumented executable. The debug memory allocation library <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> described in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> takes a similar approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> library provides replacement memory management routines with runtime-configurable debugging facilities. You can control the behavior of these routines by using a command line utility (also called <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>) to detect memory leaks and to discover and report defects such as writing outside the bounds of an object and using a pointer after it’s been freed.</p>
<p class="TX">The advantage of dynamic analysis is that it has a low false-positive rate, so if one of these tools flags a problem, fix it!</p>
<p class="TX">A drawback of dynamic analysis is that it requires sufficient code coverage. If a defective code path is not exercised during the testing process, the <span aria-label="253" epub:type="pagebreak" id="pg_253" role="doc-pagebreak"/>defect won’t be found. Another drawback is that the instrumentation may change other aspects of the program in undesirable ways, such as adding performance overhead or increasing the binary size. Unlike other dynamic analysis tools, the <samp class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro mentioned earlier in this chapter provides lightweight support for detecting buffer overflows so that it can be enabled in a production build with no noticeable impacts on performance.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">

<h2 class="H1" id="sec27"><span id="h1-96"/><samp class="SANS_Futura_Std_Bold_B_11">AddressSanitizer</samp></h2>
<p class="TNI">AddressSanitizer (ASan, <i><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">https://<wbr/>github<wbr/>.com<wbr/>/google<wbr/>/sanitizers<wbr/>/wiki<wbr/>/AddressSanitizer</a></i>) is an example of an effective dynamic analysis tool that is available (for free) for several compilers. Several related sanitizers exist, including ThreadSanitizer, MemorySanitizer, Hardware-Assisted AddressSanitizer, and UndefinedBehaviorSanitizer. Many other dynamic analysis tools are available, both commercial and free. For more information on sanitizers, see <i><a href="https://github.com/google/sanitizers">https://<wbr/>github<wbr/>.com<wbr/>/google<wbr/>/sanitizers</a></i>. I’ll demonstrate the value of these tools by discussing AddressSanitizer in some detail.</p>
<p class="TX">ASan is a dynamic memory error detector for C and C++ programs. It’s incorporated into LLVM version 3.1 and GCC version 4.8, as well as later versions of these compilers. ASan is also available starting with Visual Studio 2019.</p>
<p class="TX">This dynamic analysis tool can find a variety of memory errors, including the following:</p>
<ul class="ul">
<li class="ListBullet">Use after free (dangling pointer dereference)</li>
<li class="ListBullet">Heap, stack, and global buffer overflow</li>
<li class="ListBullet">Use after return</li>
<li class="ListBullet">Use after scope</li>
<li class="ListBullet">Initialization order bugs</li>
<li class="ListBullet">Memory leaks</li>
</ul>
<p class="TX">To demonstrate ASan’s usefulness, we’ll start by replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">get _error</samp> function from <a href="chapter11.xhtml#Lis11-7">Listing 11-7</a> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function shown in <a href="chapter11.xhtml#Lis11-13">Listing 11-13</a>.</p>
<span id="Lis11-13"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp></p>
<pre class="pre"><code>errno_t print_error(errno_t errnum) {
  rsize_t size = strerrorlen_s(errnum) + 1;
  char* msg = malloc(size);
  if (msg == nullptr) return ENOMEM;
  errno_t status = strerror_s(msg, size, errnum);
  if (status != 0) return EINVAL;
  fputs(msg, stderr);
  return EOK;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: The</samp> <samp class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX"><span aria-label="254" epub:type="pagebreak" id="pg_254" role="doc-pagebreak"/>We’ll also replace the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function with the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function shown in <a href="chapter11.xhtml#Lis11-14">Listing 11-14</a>.</p>
<span id="Lis11-14"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp></p>
<pre class="pre"><code>TEST(PrintTests, ZeroReturn) {
  EXPECT_EQ(print_error(ENOMEM), 0);
  EXPECT_EQ(print_error(ENOTSOCK), 0);
  EXPECT_EQ(print_error(EPIPE), 0);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: The</samp> <samp class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test suite</samp></p>
<p class="TX">This Google Test code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">PrintTests</samp> test suite that contains a single test case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroReturn</samp>. This test case uses the nonfatal <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_EQ</samp> assertion to test for a return value of 0 from several calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function to print some randomly selected error numbers. Next, we need to build and run this code on Ubuntu Linux.</p>
<section aria-labelledby="sec28" epub:type="division">

<h3 class="H2" id="sec28"><span id="h2-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tests</samp></h3>
<p class="TNI">Running the revised tests from <a href="chapter11.xhtml#Lis11-14">Listing 11-14</a> produces the positive results shown in <a href="chapter11.xhtml#Lis11-15">Listing 11-15</a>.</p>
<span id="Lis11-15"/>
<pre><code>$ <b>./build/tests</b>
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from PrintTests
[RUN       ] PrintTests.ZeroReturn
[        OK] PrintTests.ZeroReturn (0 ms)
[----------] 1 test from PrintTests (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (0 ms total)
<b>[  PASSED  ]</b> 1 test.</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: A test run of the</samp> <samp class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test suite</samp></p>
<p class="TX">An inexperienced tester may look at these results and mistakenly think, “Hey, this code is working!” However, you should take additional steps to improve your confidence that your code is free from defects. Now that we have a working test harness in place, it’s time to instrument the code.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">

<h3 class="H2" id="sec29"><span id="h2-119"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instrumenting the Code</samp></h3>
<p class="TNI">You can instrument your code by using ASan to compile and link your program with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp> flag. <a href="chapter11.xhtml#tab11-3">Table 11-3</a> shows some compiler flags that are commonly used with ASan.</p>
<p class="TT" id="tab11-3"><span aria-label="255" epub:type="pagebreak" id="pg_255" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-3:</samp> <samp class="SANS_Futura_Std_Book_11">Compiler and Linker Flags Commonly Used with AddressSanitizer</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Enable AddressSanitizer (must be passed to both the compiler and the linker)</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Get symbolic debugging information</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-omit-frame-pointer</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Leave frame pointers to get more informative stack traces in error messages</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize-blacklist=path</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Pass a blacklist file</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-common</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Do not treat global variables as common variables (allows ASan to instrument them)</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Select the compiler and linker flags you want to use from <a href="chapter11.xhtml#tab11-3">Table 11-3</a> and add them to your <i>CMakeLists.txt</i> file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_compile_options</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add_link_options</samp> commands:</p>

<pre><code>add_compile_options(-g3 -fno-omit-frame-pointer -fno-common -fsanitize=address)
add_link_options(-fsanitize=address)</code></pre>
<p class="TX">Do not enable sanitization in the build phase because the inserted runtime instrumentation can cause false positives.</p>
<p class="TX">As previously mentioned, AddressSanitizer works with Clang, GCC, and Visual C++. (See <i><a href="https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc">https://<wbr/>devblogs<wbr/>.microsoft<wbr/>.com<wbr/>/cppblog<wbr/>/addresssanitizer<wbr/>-asan<wbr/>-for<wbr/>-windows<wbr/>-with<wbr/>-msvc</a></i> for more information on ASan support.)</p>
<p class="TX">Depending on which version of which compiler you’re using, you may also need to define the following environment variables:</p>

<pre><code>ASAN_OPTIONS=symbolize=1
ASAN_SYMBOLIZER_PATH=/path/to/llvm_build/bin/llvm-symbolizer</code></pre>
<p class="TX">Try rebuilding and rerunning your tests with these environmental variables set.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">

<h3 class="H2" id="sec30"><span id="h2-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Instrumented Tests</samp></h3>
<p class="TNI">The unit test suite you wrote using Google Test should continue to pass but will also exercise your code, allowing AddressSanitizer to detect additional problems. You should now see the additional output in <a href="chapter11.xhtml#Lis11-16">Listing 11-16</a> from running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">./build/tests</samp>.</p>
<span id="Lis11-16"/>
<pre><code>==22489==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 31 byte(s) in 1 object(s) allocated from:
    #0 0x7f2bcf9f58ff in __interceptor_malloc
  ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:69
    #1 0x557d3105f6da in print_error /home/rcs/test/error.c:21
    #2 0x557d3105d314 in TestBody /home/rcs/test/tests.cc:28

// <var>--snip--</var></code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: An instrumented test run of</samp> <samp class="I">PrintTests</samp></p>
<p class="TX"><span aria-label="256" epub:type="pagebreak" id="pg_256" role="doc-pagebreak"/><a href="chapter11.xhtml#Lis11-16">Listing 11-16</a> shows only the first finding of several that are produced. Most of this stack trace is redacted because it is from the test infrastructure itself and is uninteresting because it doesn’t help locate the defects.</p>
<p class="TX">AddressSanitizer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LeakSanitizer</samp> component has “detected memory leaks” and informs us that this is a direct leak of 31 bytes from one object. The stack trace identifies the filename and line number related to the diagnostic:</p>

<pre><code>#1 0x557d3105f6da in print_error /home/rcs/test/<b>error.c:21</b></code></pre>
<p class="TX">This line of code contains the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function:</p>

<pre><code>errno_t print_error(errno_t errnum) {
  rsize_t size = strerrorlen_s(errnum) + 1;
<b>  char* msg = malloc(size);</b>
  // <var>--snip--</var>
}</code></pre>
<p class="TX">This is an obvious error; the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> is assigned to an automatic variable defined within the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function and never freed. We lose the opportunity to free this allocated memory after the function returns, and the lifetime of the object holding the pointer to the allocated memory ends. To fix this problem, add a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free(msg)</samp> after the allocated storage is no longer required but before the function returns. Rerun the tests and repair any additional defects until you’re satisfied with the quality of your program.</p>
<aside aria-label="box-10" class="box1">
<p class="BoxTitle" id="box-10"><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISES</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">1.  Use static analysis to evaluate the defective code from <a href="chapter11.xhtml#Lis11-6">Listing 11-6</a>. Did the static analysis provide any additional findings?</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">2.  Add further tests to exercise the error handling paths in both the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> <samp class="SANS_Futura_Std_Book_11">(<a href="chapter11.xhtml#Lis11-8">Listing 11-8</a>) and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> <samp class="SANS_Futura_Std_Book_11">(<a href="chapter11.xhtml#Lis11-14">Listing 11-14</a>) functions.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">3.  Evaluate the remaining results from the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">./tests</samp> <samp class="SANS_Futura_Std_Book_11">test instrumented with AddressSanitizer (<a href="chapter11.xhtml#Lis11-15">Listing 11-15</a>). Eliminate the remaining true-positive errors detected.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">4.  Instrument the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">./tests</samp> <samp class="SANS_Futura_Std_Book_11">program using other sanitizers available at</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://github.com/google/sanitizers">https://<wbr/>github<wbr/>.com<wbr/>/google<wbr/>/sanitizers</a></samp> <samp class="SANS_Futura_Std_Book_11">and address any issues you find.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">5.  Use these and similar testing, debugging, and analysis techniques on your real-world code.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">6.  Use profile-guided optimization to optimize the prime factorization program from <a href="chapter10.xhtml">Chapter 10</a></samp><samp class="SANS_Futura_Std_Book_11">. Refer to your compiler’s documentation for details.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<span aria-label="257" epub:type="pagebreak" id="pg_257" role="doc-pagebreak"/>
<h2 class="H1" id="sec31"><span id="h1-97"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about static and runtime assertions and were introduced to some of the more important and recommended compiler flags for GCC, Clang, and Visual C++. You also learned how to debug, test, and analyze your code by using both static and dynamic analysis.</p>
<p class="TX">These are the important last lessons in this book, because you’ll find you spend a considerable amount of time as a professional C programmer debugging and analyzing your code. I posted the following on social media a while back, and it summarizes my (and other C programmers) relationship with the C programming language:</p>
<ul class="ul">
<li class="ListBullet">Language I dislike: C</li>
<li class="ListBullet">Language I begrudgingly respect: C</li>
<li class="ListBullet">Language I think is overrated: C</li>
<li class="ListBullet">Language I think is underrated: C</li>
<li class="ListBullet">Language I like: C</li>
</ul>
</section>
<section aria-labelledby="sec32" epub:type="division">

<h2 class="H1" id="sec32"><span id="h1-98"/><samp class="SANS_Futura_Std_Bold_B_11">Future Directions</samp></h2>
<p class="TNI">With C23 complete, the committee can turn its attention to the next revision of the C programming language, C2Y. This will likely be published in 2029. While that may seem like a long time, it’s roughly half the time previous C standard editions required.</p>
<p class="TX">The C committee has already approved a new charter to document our principles (Seacord et al. 2024). While the committee is dedicated to maintaining the traditional spirit of C, there will be a renewed focus on security and safety. For C2Y, we’ll likely improve automatic type inference, expand <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> support, and potentially adopt lambdas and other features from C++. We’re also working on a novel <samp class="SANS_TheSansMonoCd_W5Regular_11">defer</samp> feature for error handling and resource management. The C floating-point group will continue its work to update to IEEE 754:2019. A technical specification for a provenance-aware memory object model for C (ISO/IEC CD TS 6010:2024) should be published soon and hopefully incorporated into C2Y.</p>
</section>
</section>
</body></html>