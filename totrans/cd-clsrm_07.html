<html><head></head><body>
<div>&#13;
<header>&#13;
<h1 class="ChapterStart"><a id="_idTextAnchor085"/>7</h1>&#13;
<h1 class="ChapterTitle"><a id="_idTextAnchor086"/>Scaffolded Code Exercises</h1>&#13;
</header>&#13;
<p class="ChapterIntroFirst">Once you select a development environment, you can start setting up more involved code exercises for your students. In this chapter, we’ll learn three coding activities of increasing complexity that address multiple computer science standards, such as evaluating and enhancing algorithms, learning to talk about code, using encryption, and debugging. Each exercise will require you to provide students with prewritten code in your chosen development environment as a scaffolding for student understanding. This way, students will continue to learn from existing code but be given specific direction for engaging with that code to better understand it.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor087"/>Evaluating Algorithms</h2>&#13;
<p class="BodyFirst">The computer science standards have students practice evaluating and comparing algorithms. In this evaluation exercise, which is from the organization freeCodeCamp, you’ll present your students with many different algorithms to test for <em class="EmphasisItalic">palindromes,</em> text strings that read the same forward as backward. One technique for finding palindromes would be to choose a string input, reverse it, and see whether the reversed string equals the original string. When this possible solution is abstracted, one component of this function would likely take a string of characters and return that string with the character order reversed. Edd Mann, a blogger and developer, documented 10 ways to do this in JavaScript (<em class="EmphasisItalic"><a href="https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/">https://eddmann.com/posts/ten-ways-to-reverse-a-string-in-javascript/</a></em>). We’ll review three of the solutions he developed, but the full exercise should include many more examples.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor088"/>for Loop</h3>&#13;
<p class="BodyFirst">The first example in Listing 7-1 is a simple <span class="Literal _idGenCharOverride-1">for</span> loop. It takes the string input, loops backward through each character in the string via the <span class="Literal _idGenCharOverride-1">i = stringToReverse.length - 1; i &gt;= 0; i-- </span>arguments, and appends the last character in the string to the new string.</p>&#13;
<pre>function reverseString(stringToReverse) {&#13;
  var reversedString = "";&#13;
  for (var i = stringToReverse.length - 1; i &gt;= 0; i--) {&#13;
    reversedString += stringToReverse[i];&#13;
  }&#13;
  return reversedString;&#13;
}</pre>&#13;
<p class="Listing">Listing 7-1: Using a <span class="LiteralCaption">for</span> loop to reverse a string</p>&#13;
<p class="Body">Students can see the output of the <span class="Literal _idGenCharOverride-1">reverseString</span> function in Listing 7-2 where the word “aibohphobia,” the fear of palindromes, is the input.</p>&#13;
<pre>document.write(reverseString("aibohphobia"));</pre>&#13;
<p class="Listing">Listing 7-2: Code to execute the <span class="LiteralCaption">reverseString</span> function</p>&#13;
<p class="Body">When evaluating this algorithm, you have an excellent opportunity to introduce your students to the debugging tools built into the web browser. Have your students open this code in the browser, launch the web development tools, and then click <strong class="EmphasisBold">Sources</strong> or <strong class="EmphasisBold">Debugger</strong> from the top menu depending on the browser they’re using. Figure 7-1 shows a screen similar to what they’ll see.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-1" src="image/CitC07_01_debugger_labeled_new.png"/></p>&#13;
<figcaption class="Caption">Figure 7-1: Debugging options in the browser’s web development tools</figcaption>&#13;
</figure>&#13;
<p class="Body">Three main panels are in this screenshot. The <em class="EmphasisItalic">File Navigator </em><span class="Wingdings">❶</span> is where every file used in the web page is listed. Clicking these files displays their contents in the <em class="EmphasisItalic">Code Editor </em><span class="Wingdings">❷</span>. Clicking the line numbers in this panel will set <em class="EmphasisItalic">breakpoints</em>, places where we want the browser to pause code execution so we can review variable values or begin stepping through the code. The <em class="EmphasisItalic">JavaScript Debugging</em> panel <span class="Wingdings">❸</span> is where the current program state and other tools for troubleshooting code reside. </p>&#13;
<p class="Body">When evaluating an algorithm, students click the line number at the function’s start and trigger the code execution by manually refreshing the page in the browser. The browser pauses processing the code at the breakpoint. Students should then begin stepping through the code using the navigation controls at the top of the Debugging panel. As they step through the code, they’ll see how the browser highlights each executed step in the algorithm and how the variables change values.</p>&#13;
<p class="Body">Figure 7-1 shows a set breakpoint at line five of the code. From there, the figure shows that the developer has stepped to line six. The mouse is hovering over the <span class="Literal _idGenCharOverride-1">i</span> variable, so we can see its value of <span class="Literal _idGenCharOverride-1">5</span> hovering above it. Alongside the <span class="Literal _idGenCharOverride-1">reversedString</span> variable is the value <span class="Literal _idGenCharOverride-1">aibhop</span>: six letters are now appended in reverse to the string at this iteration. The Debugging panel shows the variable values listed under Scope, a list of the breakpoints, and the <em class="EmphasisItalic">call stack</em>, which is the list of functions currently being called. In this case, the code is only calling one function. But as we dive into more complex code, following the stack and seeing what functions are calling other functions becomes more important.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor089"/>Recursion</h3>&#13;
<p class="BodyFirst">Once your students have had the chance to play with the Debugger and understand the loop strategy for reversing the string, you can introduce a more complex algorithm. The example in Listing 7-3 uses <em class="EmphasisItalic">recursion</em>, a technique where a function calls itself, which creates a loop similar to a <span class="Literal _idGenCharOverride-1">while</span> loop. Here the function first checks whether the ­<span class="Literal _idGenCharOverride-1">stringToReverse</span> input variable is empty; if not, the function returns every character after the first using the <span class="Literal _idGenCharOverride-1">.substr(1)</span> command and appends the first character in the string to the end via the <span class="Literal _idGenCharOverride-1">.charAt(0)</span> command.</p>&#13;
<pre>function reverseString(stringToReverse) {&#13;
  if (stringToReverse === "") {&#13;
    return "";&#13;
  } else {&#13;
    return reverseString(stringToReverse.substr(1)) &#13;
      + stringToReverse.charAt(0);&#13;
  }&#13;
}</pre>&#13;
<p class="Listing">Listing 7-3: Reversing a string using recursion</p>&#13;
<p class="Body">Although the concept of recursion is easy to define, your students might find it difficult to follow and understand this example, and they’re not alone. Many developers express difficulty following along with some recursive algorithms. To help them, direct your students to the call stack as they step through the function’s execution. Have them watch the list of function calls grow and eventually shrink with each iteration. Additionally, have them compare this function to a <span class="Literal _idGenCharOverride-1">while</span> loop because both controls iterate until a condition is met. It’s worth noting that a recursive function is not the same as a <span class="Literal _idGenCharOverride-1">while</span> loop, although there are some similarities.</p>&#13;
<p class="Body">Despite being a bit difficult to follow, recursion can be an ideal solution for certain tasks. For example, the <em class="EmphasisItalic">minimax algorithm</em> is a popular function used in making AI opponents for games like chess and tic-tac-toe. Minimax iterates and evaluates all possible moves to determine the best reply to each possible player move. Figure 7-2 shows how each point in a tic-tac-toe game can branch out into several possibilities.</p>&#13;
<p class="Body">Each branch potentially has more branches. Although navigating a one-dimensional array of characters only needs a single loop, navigating this data tree would require loops within loops. With 255,168 different possible games in tic-tac-toe alone, writing enough loops to explore them all would be unfeasible, which is why Figure 7-2 only illustrates a few branches. Recursion allows us to more easily explore complex data structures without needing to know all their dimensions.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-2" src="image/CitC07_02_tictactoe_new.png"/></p>&#13;
<figcaption class="Caption">Figure 7-2: Sample tic-tac-toe game possibility branches</figcaption>&#13;
</figure>&#13;
<h3 class="HeadB"><a id="_idTextAnchor090"/>Array Manipulation</h3>&#13;
<p class="BodyFirst">A third way to reverse the string, as shown in Listing 7-4, uses array manipulation and array functions built into JavaScript. The .<span class="Literal _idGenCharOverride-1">split("")</span> function splits all the characters in the string into an array, which is then flipped using the <span class="Literal _idGenCharOverride-1">.reverse()</span> command, and then appended back together into a string again via <span class="Literal _idGenCharOverride-1">.join("")</span>. Although it’s one line of code, the array manipulation approach executes three steps we can see and many steps we can’t see because they’re abstracted behind the function calls.</p>&#13;
<pre>function reverseString(stringToReverse) {&#13;
  return stringToReverse.split("").reverse().join("");&#13;
}</pre>&#13;
<p class="Listing">Listing 7-4: Reversing a string using array manipulation</p>&#13;
<p class="Body">After reviewing many ways to accomplish the same task, ask your students for their opinions on the different methods. What do they like and dislike about them? Ask them to justify their answers in terms of implementation, code readability, and performance to practice appraising code. </p>&#13;
<p class="Body">An important point to make is that there aren’t explicitly right and wrong answers. But in some cases, for instance when iterating over data in a tree structure, recursion will feel more natural, and a loop will feel bulkier. At times, the coder might break a chain of functions out of one line of code and into multiple lines to improve readability or will add extensive comments to a single code line to explain what’s going on to their peers and future selves. The point of this exercise isn’t to tell students what the best practices are, but to practice thinking about the different solutions and articulating why they might prefer one technique over another.</p>&#13;
<p class="Body">There are many other ways to extend the exercise to cover computer science standards beyond evaluating and comparing algorithms. For example, when covering the recursion example, you could challenge your students to rewrite it as a <span class="Literal _idGenCharOverride-1">while</span> loop as an exercise in modifying an existing algorithm. We’ve also covered computer science standards such as recursion as a control structure, tree structures for data and the minimax algorithm, and debugging tools as a means of reading algorithms step-by-step for deeper understanding.</p>&#13;
<p class="Body">In the function execution example provided, we used a palindrome for the input. Ask your students, using this input, whether we’re verifying that the functions are working correctly. How do we know the output string is really reversed? What argument should we use to properly test these functions? By doing so, we’re also introducing quality assurance and testing aspects to the exercise.</p>&#13;
<p class="Body">Once students are familiar with systematically stepping through and evaluating code, comparing algorithms, and learning about the different ways to accomplish the same task, we can introduce them to extending those algorithms. Next, we’ll introduce them to an engaging exercise that involves extending existing code iteratively and making it increasingly complex by design.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor091"/>Enhancing Algorithms</h2>&#13;
<p class="BodyFirst">In addition to evaluating and comparing algorithms, computer science standards also require students to refine or enhance them. We’ll use this exercise as an opportunity to bring some basic cybersecurity concepts into the mix. Here students will learn about a simple algorithm for encrypting messages, explore a code sample to execute this process, figure out how to crack the encryption, and determine how to make their original encryption harder to crack.</p>&#13;
<p class="Body">Huge advances in computing originated from wartime necessities. One computational arms race centered on <em class="EmphasisItalic">cryptography</em>, keeping communications secure against third parties reading them. The <em class="EmphasisItalic">Caesar cipher</em>, named for the fact that Julius Caesar used it in correspondence, is a very basic encryption algorithm. In it, each letter in a string is shifted a specific number of characters along the alphabet. For example, input “A” with a shift of one to output “B,” or input “A” with a shift of two to output “C.” Figure 7-3 shows a Federal Bureau of Investigations, Cryptanalysis and Racketeering Records Unit challenge coin featuring a cipher wheel in its design. In this example, the computational device is shifted three places so the input “TOP SECRET” would output “WRS VHFUHW.” The Confederate Army used ciphers like this during the Civil War.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-3" src="image/CitC07_03_cipherwheel.png"/></p>&#13;
<figcaption class="Caption">Figure 7-3: Federal Bureau of Investigations, Cryptanalysis and Racketeering Records Unit challenge coin showing a Caesar cipher. Photo by David Oranchak.</figcaption>&#13;
</figure>&#13;
<p class="Body">The function in Listing 7-5 contains an algorithm that takes a string input, makes a shift, and outputs the string with each character transposed according to the defined shift. Provide this function to your students in your chosen development environment.</p>&#13;
<pre>var caesarCipher = function(str, shift) {&#13;
  if (shift &lt; 0) return caesarCipher(str, shift+26);&#13;
  var output = '';&#13;
  str = str.toUpperCase();&#13;
  for (var i = 0; i &lt; str.length; i++) {&#13;
    var c = str[i];&#13;
    if (c.match(/[a-z]/i)) {&#13;
      var code = str.charCodeAt(i);&#13;
      var asciiA = 'A'.charCodeAt();&#13;
      c = String.fromCharCode(((code- asciiA+shift)%26)+asciiA);&#13;
    }&#13;
    output += c;&#13;
  }&#13;
  return output;&#13;
}</pre>&#13;
<p class="Listing">Listing 7-5: Caesar cipher function by Evan Hahn, released to the public domain</p>&#13;
<p class="Body">Students can test this function using the line of code in Listing 7-6 to see the output.</p>&#13;
<pre>document.write(caesarCipher('Hello, Classmate', 11));</pre>&#13;
<p class="Listing">Listing 7-6: Executing the Caesar cipher</p>&#13;
<p class="Body">Have your students take some time to decompose this code. They should try out some of the bits and pieces in the browser console to understand the parts and search the web for some of the functions. Have them add comments to the code for practice in communicating with other developers and documenting code.</p>&#13;
<p class="Body">To keep the code compact and concise, the author has used a few somewhat advanced techniques. For example, the <span class="Literal _idGenCharOverride-1">/[a-z]/i</span> portion in the <span class="Literal _idGenCharOverride-1">str.match()</span> function is a <em class="EmphasisItalic">regular expression</em>, a powerful search pattern syntax. In this case, it checks for letters a through z. The .<span class="Literal _idGenCharOverride-1">charCodeAt()</span> function returns the Unicode value for the first letter in a string, so executing <span class="Literal _idGenCharOverride-1">'A'.charCodeAt()</span> in the console will return “65.” Conversely, the <span class="Literal _idGenCharOverride-1">String .fromCharCode()</span> function converts a Unicode number identifier for a character into the character, so <span class="Literal _idGenCharOverride-1">String.fromCharCode(65)</span> will output “A.” Using these two functions, the author cleverly uses Unicode to shift the inputs.</p>&#13;
<p class="Body">With comments, this procedure might look something like Listing 7-7.</p>&#13;
<pre>var caesarCipher = function(str, shift) {&#13;
  //Check for negative number shifts&#13;
  if (shift &lt; 0) return caesarCipher(str, shift+26);&#13;
  var output = '';&#13;
  //Convert to uppercase to avoid checking lowercase unicodes&#13;
  str = str.toUpperCase();&#13;
  for (var i = 0; i &lt; str.length; i++) {&#13;
    var c = str[i];&#13;
    //Check if its alphabetic&#13;
    if (c.match(/[a-z]/i)) {&#13;
      //Get the unicode value for it&#13;
      var code = str.charCodeAt(i);&#13;
      //Get the unicode value for A&#13;
      var asciiA = 'A'.charCodeAt();&#13;
      //Shift the unicode value and return the character&#13;
      c = String.fromCharCode(((code-asciiA+shift)%26)+asciiA);&#13;
    }&#13;
    output += c;&#13;
  }&#13;
  return output;&#13;
}</pre>&#13;
<p class="Listing">Listing 7-7: Caesar cipher function with explanatory comments</p>&#13;
<p class="Body">Now that students hopefully have a firm understanding of this procedure, ask them how they would, assuming the sender and receiver share the shift value, use this function to decode a message. How do we shift the encrypted message backward? </p>&#13;
<p class="Body">The answer is to make the shift negative, so 11 becomes −11, but your students shouldn’t expect their user decoders to know this. So let’s abstract away this finding into a function like the one in Listing 7-8. Then users can invoke the more intuitive <span class="Literal _idGenCharOverride-1">caesarCipherDecode('SPWWZ NWLDDXLEP',11)</span> to decode the message.</p>&#13;
<pre>var caesarCipherDecode = function(str, shift) {&#13;
  return caesarCipher(str, (shift * -1));&#13;
}</pre>&#13;
<p class="Listing">Listing 7-8: Caesar cipher decode function</p>&#13;
<p class="Body">Cryptography in wartime and peacetime is a computational arms race. So next, have your students take the perspective of someone who wants to crack the cipher. Let’s say the code cracker has the encoded string but doesn’t know the shift to unlock it. What steps could they execute to find the shift value? </p>&#13;
<p class="Body">Because the alphabet has 26 letters, there are only 26 possible shifts if we include the zero shift. Cracking the code means taking an encoded string and methodically testing each of the possibilities. Once students have explained the algorithm for cracking the cipher, you can provide them with the code in Listing 7-9, which will execute it.</p>&#13;
<pre>var caesarCipherCracker = function(str) {&#13;
  var output = "";&#13;
  for (var i = -25; i &lt; 1; i++) {&#13;
    output += i + " " + caesarCipher(str, i) + "&lt;br/&gt;";&#13;
  }&#13;
  return output;&#13;
}</pre>&#13;
<p class="Listing">Listing 7-9: The <span class="LiteralCaption">caesarCipherCracker</span> function </p>&#13;
<p class="Body">This code snippet is a <em class="EmphasisItalic">brute force search</em>, an algorithm that systematically tests every possibility. When your students execute the command in Listing 7-10, the function will output 26 rows of text showing the result of each shift value on the string input. When students find a row with a legible message, they’ve found the shift value.</p>&#13;
<pre>document.write(caesarCipherCracker('MJQQT HQFXXRFYJ'));</pre>&#13;
<p class="Listing">Listing 7-10: Executing the <span class="LiteralCaption">caesarCipherCracker</span> function</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Securing Passwords</h2>&#13;
<p class="BoxBodyFirst">Criminals and cybersecurity testers use two main strategies to crack passwords. Just as with our cipher, they can use a brute force search to test every possible combination of characters until they find the right one. They can also use social engineering, which means they learn your personal details to see whether any of that information is used in your password. The reason they use it is that many people use their birthdate, pet’s name, or other personal information to make a password easy to remember.</p>&#13;
<p class="BoxBody">The US National Cybersecurity and Communications Integration Center (NCCIC) defines some password characteristics that defend against these strategies. To defend against brute force attacks, a more secure password is <em class="EmphasisItalicBox">long</em> and <em class="EmphasisItalicBox">complex</em>. Using uppercase, lowercase, and number characters in your password means there are 62 options to test for each character. Each additional character in the password string increases its complexity 62-fold, so a 12-character string has more than <em class="EmphasisItalicBox">three sextillion possible combinations</em>. Also, a secure password is <em class="EmphasisItalicBox">unpredictable</em>. It doesn’t contain personal information, and the same password isn’t used on multiple systems.</p>&#13;
<p class="BoxBody">As software developers, your students have a responsibility to protect their users’ data, especially by keeping their passwords safe. So the best practice is to not store user passwords. Instead of storing passwords, safe applications will <em class="EmphasisItalicBox">hash</em> a password the user enters. It will apply an algorithm to the password to transform it into a seemingly random sequence of characters. The process is non-reversible, so the original password is lost in the transformation and can’t be retrieved from the output.</p>&#13;
<p class="BoxBody">The hashed output is saved in the application. Later, when the user enters their password again, the application takes the input, applies the same hashing algorithm, and compares it to the hash in the database. For example, if a user enters “123456” as a password, the site might use the SHA-256 (Secure Hash Algorithm) to convert this input to “e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,” save this to the database, and hash future password inputs from the user to SHA-256. Then the site will compare the output to the value saved in the database. This way, should the user’s data be compromised, the attacker won’t be able to retrieve the passwords from it. Additional best practices such as <em class="EmphasisItalicBox">password salting</em>, where random characters are added to the password before hashing to make the output more unpredictable, further protect user data against breaches.</p>&#13;
<p class="BoxBodyLast">Students should be mindful that online applications are black boxes. We have no idea whether the developers used best practices to keep user data safe. If we use the same password for all applications, it only takes one data breach to give an attacker access to all those applications.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">The cryptographic arms race continues. With our Caesar cipher cracked, we need to make our algorithm more complex. There are lots of ways to do this, and you’ll have fun seeing what algorithms your students come up with. Listing 7-11 shows an example that adds a <span class="Literal _idGenCharOverride-1">rotate</span> variable to the mix, so the <span class="Literal _idGenCharOverride-1">shift</span> variable changes for each character in the string.</p>&#13;
<pre>var rotatingCaesarCipher = function(str, shift, rotate) {&#13;
  var output = "";&#13;
  for (var i = 0; i &lt; str.length; i++) {&#13;
    shift += rotate;&#13;
    output += caesarCipher(str[i], shift);&#13;
  }&#13;
  return output;&#13;
}</pre>&#13;
<p class="Listing">Listing 7-11: Adding a rotating shift to the Caesar cipher</p>&#13;
<p class="Body">With a <span class="Literal _idGenCharOverride-1">shift</span> of 11 and a <span class="Literal _idGenCharOverride-1">rotate</span> of 3, the first character will shift 14, the second 17, the third 20, and so forth. With 26 possible shift values and 26 possible rotate values, a brute force cracker function would need to iterate over 625 possible combinations to find the two keys. In just one iteration, we’ve squared the number of steps in our algorithm as well as the processing power to execute our code. Thinking about code breaking efforts in World War II, we can see how so many innovations in computational techniques and advances in computing power emerged from this conflict. If we can exponentially increase the complexity of our encryption over a few coding lessons, think of how complex the art of cryptography has become over decades of iterations between those keeping data secure and those trying to access it.</p>&#13;
<p class="Body">Computer science standards involving documentation, algorithm analysis and enhancement, iterative development, and cryptography were all covered in this one extensive exercise. The small code snippets used in this section are just a launching point. Students can continue to extend this code, adding layers of complexity to make their messages more secure. We can also use game-based incentives as students figure out how to crack those messages. Now that your students have iteratively developed a relatively simple code example into a more complex version, we can introduce them to an even more complicated and engaging example.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor092"/>Adding an Interface</h2>&#13;
<p class="BodyFirst">The exercise in this section builds on the concepts covered in the previous two exercises and adds a user interface to the mix. The interface offers ideal opportunities to visualize code outputs. The interface also adds event-driven triggers behind graphical elements, such as buttons, where users click these abstractions to execute functions.</p>&#13;
<p class="Body">In this exercise, students work with a function that generates random mazes. There are many kinds of maze-generation algorithms to explore. Each produces distinct maze styles. In this example, we’ll use a <em class="EmphasisItalic">randomized depth-first search</em> algorithm. Listing 7-12 shows the steps for this algorithm.</p>&#13;
<pre>1. Create a grid.&#13;
2. Start with the top-left cell.&#13;
3. Mark the current cell as visited.&#13;
4. Get a list of its orthogonal neighbors. &#13;
5. Start with a random neighbor, for each neighbor:&#13;
  a. If that neighbor hasn't been visited:&#13;
    I. Remove the wall between this cell and the unvisited neighbor.&#13;
    II. Return to step 3.</pre>&#13;
<p class="Listing">Listing 7-12: Steps in a randomized depth-first search algorithm</p>&#13;
<p class="Body">The steps for this algorithm are simple to follow, but translating them into code can get very elaborate. The JavaScript code in Listing 7-13 is from the Rosetta Code website (<em class="EmphasisItalic"><a href="https://rosettacode.org/wiki/Maze_generation">https://rosettacode.org/wiki/Maze_generation</a></em>), which offers GNU Free Documentation Licensed examples of various algorithms in as many different programming languages as possible. This is just one of many code snippets you can use in your lesson.</p>&#13;
<pre>function maze(width,height) {&#13;
  var cells=height*width-1;&#13;
  if (cells&lt;0) {alert("illegal maze dimensions");return;}&#13;
  //Horizontal walls.&#13;
  var horiz =[]; for (var j= 0; j&lt;height+1; j++) horiz[j]= [],&#13;
  //Vertical walls.&#13;
    verti =[]; for (var j= 0; j&lt;height+1; j++) verti[j]= [],&#13;
  //Start at the top-left cell.&#13;
    here = [0, 0],&#13;
    path = [here],&#13;
    unvisited = [];&#13;
  //Build an array of unvisited cells.&#13;
  for (var j = 0; j&lt;height+2; j++) {&#13;
    unvisited[j] = [];&#13;
    for (var k= 0; k&lt;width+1; k++)&#13;
      unvisited[j].push(&#13;
        j&gt;0 &amp;&amp; j&lt;height+1 &amp;&amp; k&gt;0 &amp;&amp; (j != here[0]+1 || k != here[1]+1)&#13;
      );&#13;
  }&#13;
  while (0&lt;cells) {&#13;
    //Build an array of potential neighbors.&#13;
    var potential = [[here[0]+1, here[1]], [here[0],here[1]+1],&#13;
        [here[0]-1, here[1]], [here[0],here[1]-1]];&#13;
    //Build an array of unvisited neighbors.&#13;
    var neighbors = [];&#13;
    for (var j = 0; j &lt; 4; j++) {&#13;
      if (unvisited[potential[j][0]+1][potential[j][1]+1])&#13;
        neighbors.push(potential[j]);&#13;
    }&#13;
    if (neighbors.length) {&#13;
      cells = cells-1;&#13;
      //Get the next random neighbors.&#13;
      next= neighbors[Math.floor(Math.random()*neighbors.length)];&#13;
      unvisited[next[0]+1][next[1]+1] = false;&#13;
      //If neighboring horizontally&#13;
      if (next[0] == here[0])&#13;
        horiz[next[0]][(next[1]+here[1]-1)/2] = true;&#13;
      else //Vertically&#13;
        verti[(next[0]+here[0]-1)/2][next[1]] = true;&#13;
      path.push(here = next);&#13;
    } else {&#13;
      //Pull the last element in the path.&#13;
      here = path.pop();&#13;
    }&#13;
  }&#13;
  return {height: height, width: width, horiz: horiz, verti: verti};&#13;
}</pre>&#13;
<p class="Listing">Listing 7-13: The depth-first search algorithm JavaScript example from Rosetta Code</p>&#13;
<p class="Body">Depending on your students’ knowledge, you could have them read and document this code snippet to explain how it executes the depth-first search algorithm. Your students should take a moment to realize that this algorithm doesn’t draw the maze. It only returns the x, y dimensions of the maze and two arrays of horizontal and vertical Boolean values, so every <span class="Literal _idGenCharOverride-1">true</span> value in the array is where a wall is removed. The <span class="Literal _idGenCharOverride-1">maze(x,y)</span> function is UI independent. It will take another function to loop through the horizontal and vertical arrays, and to draw the lines as needed. As a result, you can reuse the code from the <span class="Literal _idGenCharOverride-1">maze(x,y)</span> function if you decide to switch out your UI. By separating the functions’ responsibilities so changes to one don’t impact the other, the code is modular and decoupled. Listing 7-14 provides an example of taking the output of the <span class="Literal _idGenCharOverride-1">maze(x,y)</span> function and drawing it using characters.</p>&#13;
<pre>function display(m) {&#13;
  var text= [];&#13;
  for (var j= 0; j&lt;m.height*2+1; j++) {&#13;
    var line= [];&#13;
    if (0 == j%2)&#13;
      for (var k=0; k&lt;m.width*4+1; k++)&#13;
        if (0 == k%4) &#13;
          line[k]= '+';&#13;
        else&#13;
          if (j&gt;0 &amp;&amp; m.verti[j/2-1][Math.floor(k/4)])&#13;
            line[k]= ' ';&#13;
          else&#13;
            line[k]= '-';&#13;
    else&#13;
      for (var k=0; k&lt;m.width*4+1; k++)&#13;
        if (0 == k%4)&#13;
          if (k&gt;0 &amp;&amp; m.horiz[(j-1)/2][k/4-1])&#13;
            line[k]= ' ';&#13;
          else&#13;
            line[k]= '|';&#13;
        else&#13;
          line[k]= ' ';&#13;
    if (0 == j) line[1]= line[2]= line[3]= ' ';&#13;
    if (m.height*2-1 == j) line[4*m.width]= ' ';&#13;
    text.push(line.join('')+'\r\n');&#13;
  }&#13;
  return text.join('');	&#13;
}</pre>&#13;
<p class="Listing">Listing 7-14: Function that converts the output of the <span class="LiteralCaption">maze()</span> function into text</p>&#13;
<p class="Body">Students can then execute this code using the HTML <span class="Literal _idGenCharOverride-1">&lt;pre&gt;</span> tag in Listing 7-15 and the JavaScript following it. The <span class="Literal _idGenCharOverride-1">&lt;pre&gt;</span> tag is for “preformatted text” and tells the browser to render everything between the opening and closing tags exactly as it’s typed with all spaces included. </p>&#13;
<pre>&lt;pre id="out"&gt;&lt;/pre&gt;&#13;
&lt;script&gt;&#13;
document.getElementById('out').innerHTML= display(maze(10,10)); &#13;
&lt;/script&gt;</pre>&#13;
<p class="Listing">Listing 7-15: Executing the <span class="LiteralCaption">display()</span> function to output in the web page body</p>&#13;
<p class="Body">Figure 7-4 shows sample output for this code. For the first line, the horizontal array values are <span class="Literal _idGenCharOverride-1">[true, true, true, true, true, true, true, empty, true]</span> and the vertical array values are <span class="Literal _idGenCharOverride-1">[empty, empty, empty, empty, true, empty, true, true, true, true,]</span>.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-4" src="image/CitC07_04_textmaze.png"/></p>&#13;
<figcaption class="Caption">Figure 7-4: Maze displayed with characters from the <span class="LiteralCaption">maze()</span> function output</figcaption>&#13;
</figure>&#13;
<p class="Body">This example uses pipes, plus signs, and minus signs to draw the maze in text. But it could just as well be drawn in the HTML <span class="Literal _idGenCharOverride-1">&lt;canvas&gt;</span> element, which allows for drawing images into an area of the browser window. Figure 7-5 shows a maze generated on an HTML canvas. The modularity of the maze-generating and maze-rendering functions allows for easily swapping out how we render the maze visually.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-5" src="image/CitC07_05_canvasmaze.png"/></p>&#13;
<figcaption class="Caption">Figure 7-5: Maze rendered on an HTML canvas</figcaption>&#13;
</figure>&#13;
<p class="Body">The example maze generator in Listing 7-13 has the entire algorithm wrapped in one function, but other examples you find might break it up further. Perhaps using functions named <span class="Literal _idGenCharOverride-1">getNeighbors()</span>, <span class="Literal _idGenCharOverride-1">removeWall()</span>, and <span class="Literal _idGenCharOverride-1">getRandomCell()</span> to further decompose rendering the maze into many smaller problems. A powerful advantage to breaking up the algorithm this way is that it provides students with the ability to call each step in the maze-generating process individually and render the creation of the maze at each step in the process. Doing so animates the creation of the maze, and they can see the algorithm in action.</p>&#13;
<p class="Body">As the educator, you should provide the code for students to play with and learn from. That includes the maze-generation algorithm, the maze-rendering algorithm in text, an algorithm rendering the maze on an HTML canvas, and the many functions to animate rendering the maze. Your students won’t need to write any code from scratch, just as you won’t; you’ll build code from the endless code samples other developers around the world provide online for everyone to learn from.</p>&#13;
<p class="Body">You will provide this scaffolding code for the next iteration in the exercise, adding an avatar to the maze so students can navigate it in real time. Providing students with a set of functions like <span class="Literal _idGenCharOverride-1">right()</span>, <span class="Literal _idGenCharOverride-1">left()</span>, <span class="Literal _idGenCharOverride-1">up()</span>, and <span class="Literal _idGenCharOverride-1">down()</span> will challenge them to find the right combination of function calls to reach the exit. Once students write the functions to navigate the maze, they could add buttons to the interface, like those in Figure 7-6. Then they would attach the navigation functions to these buttons using the JavaScript <span class="Literal _idGenCharOverride-1">onclick()</span> event handler, which triggers an assigned function when the user clicks the object with their mouse or touchpad. </p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-6" src="image/CitC07_06_navbuttons.png"/></p>&#13;
<figcaption class="Caption">Figure 7-6: Navigation buttons</figcaption>&#13;
</figure>&#13;
<p class="Body">Just as the <span class="Literal _idGenCharOverride-1">maze(x,y)</span> function abstracts away the algorithm for generating a random maze, these buttons abstract away having to know the names of the <span class="Literal _idGenCharOverride-1">left()</span>, <span class="Literal _idGenCharOverride-1">right()</span>, <span class="Literal _idGenCharOverride-1">up()</span>, and <span class="Literal _idGenCharOverride-1">down()</span> functions to simple mouse clicks. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Abstractions All Around You</h2>&#13;
<p class="BoxBodyFirst">In Chapter 3, we explored the abstractions layered over abstractions from the zeros and ones of binary up to the modern user interface. In our maze navigation application, we see how arrow buttons can abstract away function calls so a user doesn’t even need to read anything to execute code. With computing devices embedded into so many devices we use in our daily lives, ask your students to consider the abstractions different devices present them.</p>&#13;
<p class="BoxBody">For example, consider a digital car stereo. The volume knob is a mechanical interface that triggers code to update the volume display. The preset buttons save and retrieve station data, executing code at the push of a button.</p>&#13;
<p class="BoxBody">Similarly, programmable digital thermostats offer users the ability to set climate settings for different times of the day. A digital camera captures images, converts them to digital form, and saves them to local storage. Computers embedded in cars allow for automatic toll payments, maintenance monitoring, keyless entry, cruise control, and more.</p>&#13;
<p class="BoxBodyLast">Have your students choose an embedded computational device similar to those in these examples. Have them explain the procedures the device provides and how the implementation details of those procedures are abstracted from the user.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">As students iteratively add functionality and interactivity to their mazes, they begin to make this microworld their own. They could add animation and sound effects to the interface for when the user bumps into a wall or reaches the goal. They could add an animated GIF image representing the player’s avatar. On a more advanced level, students could write the process mentioned in “Algorithms” on <a href="CitC_c04.xhtml#_idTextAnchor061">page 64</a> to solve the maze automatically. Once they know how to automate solving the maze, they can use that knowledge to add an AI enemy to chase the player through the maze. </p>&#13;
<p class="Body">The options for extending this example are endless for you as the educator as well. Having students show off and share the code they use to enhance their projects allows them to document, communicate, and collaborate on extending the base application. Asking students for features to make their mazes more accessible to the visually impaired can further challenge them. </p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor093"/>Summary</h2>&#13;
<p class="BodyFirst">The three exercises we covered in this chapter involve you, the educator, providing code for students to understand, experiment with, and extend. In the first exercise, you provide students with as many examples as possible to show different ways to solve the same problem. Students compare, contrast, and form opinions on each of these methods and learn to articulate which they prefer and justify their preferences. </p>&#13;
<p class="Body">In our second exercise, you give students a simple encryption function. From this starting point, they alternate between figuring out how to crack the encryption and iteratively enhance the function to make it harder to crack. Cryptography and computational complexity are additional concepts tangential to this lesson.</p>&#13;
<p class="Body">Our third exercise includes understanding an existing function and adds a user interface where students can see the output of this function. From this starter code, students experiment with animating their algorithm’s maze output, adding a player to navigate the maze, and abstracting away the navigation function names behind clickable arrows. From here, students can follow their passions, adding functionality, collaborating with peers on their innovations, and making the code their own.</p>&#13;
<p class="Body">Much of software development involves asking the right questions and finding the right existing solutions rather than writing new code from scratch. When students feel comfortable working with other people’s code, they have the power to assemble applications from prewritten functions. Having students practice working with existing code gives them a foundation for launching their own projects. </p>&#13;
<p class="Body">In the next chapter, we’ll learn about projects that can benefit your school while students learn to work independently.</p>&#13;
</div>&#13;
</body></html>