<html><head></head><body>
<h2 class="h2" id="ch08"><a id="page_131"/><strong><span class="big">8</span></strong><br/><strong>INTERPROCESS COMMUNICATION</strong></h2>
<p class="noindent">Interprocess communication (IPC) on iOS is, depending on your perspective, refreshingly simple or horribly limiting. I mostly consider it to be the former. While Android has flexible IPC mechanisms such as Intents, Content Providers, and Binder, iOS has a simple system based on two components: message passing via URLs and application extensions. The message passing helps other applications and web pages invoke your application with externally supplied parameters. Application extensions are intended to extend the functionality of the base system, providing services such as sharing, storage, and the ability to alter the functionality of the Today screen or keyboard.</p>
<p class="indent">In this chapter, you’ll learn about the various ways you can implement IPC on iOS, how people commonly get IPC wrong, and how to work around some of the limitations imposed by this system without compromising user security.</p>
<h3 class="h3" id="ch08lev1sec01"><a id="page_132"/><strong>URL Schemes and the openURL Method</strong></h3>
<p class="noindent">The official IPC mechanism available to iOS application developers is via URL schemes, which are similar to protocol handlers such as <span class="literal">mailto:</span> on a desktop system.</p>
<p class="indent">On iOS, developers can define a URL scheme that they want their application to respond to, and other applications (or web pages, importantly) can invoke the application by passing in arguments as URL parameters.</p>
<h4 class="h4" id="ch08lev2sec01"><em><strong>Defining URL Schemes</strong></em></h4>
<p class="noindent">Custom URL schemes are described in a project’s <em>Info.plist</em> file. To add a new scheme, you can use Xcode’s plist editor, shown in <a href="ch08.html#ch8fig1">Figure 8-1</a>.</p>
<div class="image"><img alt="image" src="graphics/f08-01.jpg"/></div>
<p class="figcap"><a id="ch8fig1"/><em>Figure 8-1: Defining a URL scheme within the Xcode plist editor</em></p>
<p class="indent">First, you add the URL types key, which will create a subkey, called Item 0. A subkey will automatically be created for the URL identifier, which should be populated with a reverse DNS notated string such as <span class="literal">com.mycompany.myapp</span>. Then, you create a new subkey of Item 0, which is the URL Schemes key. Under Item 0, which was created under URL Schemes, enter the scheme you want other applications to call your application by. For example, entering <span class="literal">mynewapp</span> here makes it so that your application will respond to <em>mynewapp://</em> URLs.</p>
<p class="indent">You can also define these URL schemes manually within the plist file using an external editor, as shown in <a href="ch08.html#ch8ex1">Listing 8-1</a>.</p>
<p class="programs"><a id="page_133"/>&lt;?<span class="rose">xml version</span>=<span class="red">"1.0"</span> encoding=<span class="red">"UTF-8"</span>?&gt;<br/>&lt;!<span class="rose">DOCTYPE</span> plist <span class="rose">PUBLIC</span> <span class="red">"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/</span><br/>     <span class="red">PropertyList-1.0.dtd"</span>&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;<br/>  &lt;string&gt;en&lt;/string&gt;<br/>  <span class="codestrong">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;</span><br/>  <span class="codestrong">&lt;array&gt;</span><br/>    <span class="codestrong">&lt;dict&gt;</span><br/>      <span class="codestrong">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br/>      <span class="codestrong">&lt;array&gt;</span><br/>        <span class="codestrong">&lt;string&gt;com.funco.myapp&lt;/string&gt;</span><br/>      <span class="codestrong">&lt;/dict&gt;</span><br/>    <span class="codestrong">&lt;/array&gt;</span><br/>    &lt;key&gt;CFBundleDisplayName&lt;/key&gt;<br/>    &lt;string&gt;${PRODUCT_NAME}&lt;/string&gt;<br/>    &lt;key&gt;CFBundleExecutable&lt;/key&gt;<br/>    &lt;string&gt;${EXECUTABLE_NAME}&lt;/string&gt;</p>
<p class="listcap"><a id="ch8ex1"/><em>Listing 8-1: URL schemes as shown in the plist</em></p>
<p class="indent">The bold lines indicate the additions to the original plist after the creation of the URL scheme in <a href="ch08.html#ch8fig1">Figure 8-1</a>. Learn what’s in this file so that you can quickly grep for the information you need when examining a new and foreign codebase. When you’re hunting for a custom URL scheme, you should look for the <span class="literal">CFBundleURLSchemes</span> key.</p>
<p class="indent">Once you’ve defined a URL scheme or discovered a URL scheme you want to interact with, you’ll need to implement code to make or receive IPC calls. Thankfully, this is fairly simple, but there are a few pitfalls to watch out for. You’ll take a look at them now.</p>
<h4 class="h4" id="ch08lev2sec02"><em><strong>Sending and Receiving URL/IPC Requests</strong></em></h4>
<p class="noindent">To send a message via a URL scheme, you simply create an <span class="literal">NSURL</span> object containing an <span class="literal">NSString</span> representing the URL you want to call and then invoke the <span class="literal">openURL:</span> method <span class="literal">[UIApplication sharedApplication]</span>. Here’s an example:</p>
<p class="programs"><span class="violet1">NSURL</span> *myURL = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"someotherapp://somestuff?someparameter=avalue</span><br/>     <span class="red">&amp;otherparameter=anothervalue"</span>];<br/><br/>[[<span class="violet1">UIApplication</span> <span class="violet">sharedApplication</span><span class="violet1">]</span> <span class="violet">openURL</span><span class="violet1">:myURL];</span></p>
<p class="indent">Keys and values for the receiving application are passed in as they would be in an HTTP URL, using <span class="literal">?</span> to indicate parameters and <span class="literal">&amp;</span> to separate <a id="page_134"/>key-value pairs. The only exception is that there doesn’t need to be any text before the <span class="literal">?</span> because you’re not talking to a remote site.</p>
<p class="indent">The receiving application can then extract any component of the URL with the standard <span class="literal">NSURL</span> object properties,<sup><a href="footnote.html#fn74" id="fn_74">1</a></sup> such as <span class="literal">host</span> (<span class="literal">somestuff</span> in my example), or the <span class="literal">query</span> (your key-value pairs).</p>
<h4 class="h4" id="ch08lev2sec03"><em><strong>Validating URLs and Authenticating the Sender</strong></em></h4>
<p class="noindent">When the receiving application is invoked with its custom URL scheme, it has the option to verify that it wants to open the URL to begin with, using the <span class="literal">application:didFinishLaunchingWithOptions:</span> method or <span class="literal">application:will-FinishLaunchingWithOptions:</span> method. Applications typically use the former, as in <a href="ch08.html#ch8ex2">Listing 8-2</a>.</p>
<p class="programs">- (<span class="rose">BOOL</span>)application:(<span class="violet1">UIApplication *</span>)application didFinishLaunchingWithOptions:(<span class="violet1">NS</span><br/>     <span class="violet1">Dictionary</span> *)launchOptions {<br/><br/>    <span class="rose">if</span> ([launchOptions <span class="violet">objectForKey:</span><span class="violet1">UIApplicationLaunchOptionsURLKey] != nil) {</span><br/>        <span class="violet1">NSURL *</span>url = (<span class="violet1">NSURL</span> *)[launchOptions valueForKey<span class="violet1">:UI</span><br/>     <span class="violet1">ApplicationLaunchOptionsURLKey];</span><br/>        <span class="rose">if</span> <span class="violet1">([url query] != nil) {</span><br/>            <span class="violet1">NSString *</span>theQuery = [[url query]<br/>     <span class="violet">stringByReplacingPercentEscapesUsingEncoding</span>:<span class="violet1">NSUTF8StringEncoding];</span><br/>            <span class="rose">if</span> (![<span class="rose">self</span> <span class="violet">isValidQuery</span>:theQuery]) {<br/>                <span class="rose">return</span> NO;<br/>            }<br/>            <span class="rose">return</span> YES;<br/>        }<br/>    }<br/>}</p>
<p class="listcap"><a id="ch8ex2"/><em>Listing 8-2: Validating URLs within</em> <span class="literal">didFinishLaunchingWithOptions</span></p>
<p class="indent">If YES is returned, the <span class="literal">openURL</span> method will be called with the supplied URL. In the <span class="literal">openURL</span> method, the data passed (if any) is parsed and <span class="literal">openURL</span> makes decisions as to how the app will behave in response. The method is also where you can make decisions based on the application that called your app. <a href="ch08.html#ch8ex3">Listing 8-3</a> shows what an <span class="literal">openURL</span> method might look like.</p>
<p class="programs">   - (<span class="rose">BOOL</span>)application:(<span class="violet1">UIApplication *</span>)application <span class="violet">openURL</span>:(<span class="violet1">NSURL</span> *)url<br/>        sourceApplication:(<span class="violet1">NSString</span> *)sourceApplication annotation:<br/>        (<span class="rose">id</span>)annotation {<br/><br/><span class="ent">➊</span>     <span class="rose">if</span> ([sourceApplication <span class="violet">isEqualToString</span>:<span class="red">@"com.apple.mobilesafari"</span>]) {<br/>           <span class="violet1">NSLog(</span><span class="red">@"Loading app from Safari"</span><span class="violet1">);</span><br/>           <span class="rose">return</span> NO; <span class="green1"><span class="codeitalic">// We don't want to be called by web pages</span></span><br/>       }<br/>       <span class="rose">else</span> {<br/><span class="ent">➋</span>         <span class="violet1">NSString</span> *theQuery = [[url query]<br/>        <span class="violet">stringByReplacingPercentEscapesUsingEncoding</span>:<span class="violet1">NSUTF8StringEncoding];</span><br/><span class="ent">➌</span>         <span class="violet1">NSArray</span> *chunks = [theQuery componentsSeparatedByString:<span class="red">@"&amp;"</span>];<br/>           <span class="rose">for</span> (<span class="violet1">NSString*</span> chunk <span class="rose">in</span> chunks) {<br/><span class="ent">➍</span>              <span class="violet1">NSArray</span> *keyval = [chunk componentsSeparatedByString:<span class="red">@"="</span>];<br/><span class="ent">➎</span>              <span class="violet1">NSString</span> *key = [keyval <span class="violet">objectAtIndex</span>:0];<br/>               <span class="violet1">NSString</span> *value = [keyval <span class="violet">objectAtIndex</span>:1];<br/><span class="ent">➏</span>              <span class="green1"><span class="codeitalic">// Do something with your key and value</span></span><br/>               --<span class="codeitalic">snip</span>--<br/>               <span class="rose">return</span> YES;<br/>           }<br/>       }<br/>   }</p>
<p class="listcap"><a id="ch8ex3"/><em>Listing 8-3: Parsing the data received by</em> <span class="literal">openURL</span></p>
<p class="indent"><a id="page_135"/>At <span class="ent">➊</span>, the method examines the source application to see whether it comes from the bundle ID that identifies Mobile Safari; since this application is meant to take input only from other applications, it returns <span class="literal">NO</span>. If your app is meant to be opened only by a specific application, you could restrict it to one valid bundle ID.</p>
<p class="indent">At <span class="ent">➋</span>, the input is unescaped, in case there are URL-encoded characters in it (such as <span class="literal">%20</span> for a space). At <span class="ent">➌</span> and <span class="ent">➍</span>, individual key-value pairs are separated out and broken down further into key-value pairs. The first key-value pair is grabbed at <span class="ent">➎</span>, and it is parsed to inform whatever logic might be written at <span class="ent">➏</span>.</p>
<p class="indent">The parsing and validation of the actual query string will depend on what type of data you’re receiving. If you’re expecting a numeric value, you can also use a regular expression to ensure that the string contains only numbers. Here’s an example of a check you might add to your <span class="literal">openURL</span> method:</p>
<p class="programs"><span class="violet1">NSCharacterSet*</span> notNumeric = [[<span class="violet1">NSCharacterSet</span> decimalDigitCharacterSet] invertedSet<br/>     ];<br/><span class="rose">if</span> ([value rangeOfCharacterFromSet:notDigits].location != <span class="violet1">NSNotFound</span>) {<br/>    <span class="rose">return</span> NO; <span class="green1"><span class="codeitalic">// We didn't get a numeric value</span></span><br/>}</p>
<p class="indent">Just validate any parameters received via URL-based IPC to ensure that they contain only the type of data you expect. If you use these parameters to form database queries or change the content of the HTML, make extra sure you’re sanitizing the data and integrating the content properly. I’ll talk more about this in <a href="ch12.html#ch12">Chapter 12</a>.</p>
<h5 class="h5" id="ch08lev3sec01"><a id="page_136"/><strong>Watch for Deprecated Validation Code</strong></h5>
<p class="noindent">Note that you may sometimes see the deprecated (yet more sensibly named) <span class="literal">handleOpenURL</span> method used in some codebases; see <a href="ch08.html#ch8ex4">Listing 8-4</a> for an example.</p>
<p class="programs">- (<span class="rose">BOOL</span>)application:(<span class="violet1">UIApplication *</span>)application handleOpenURL:(<span class="violet1">NSURL</span> *)url</p>
<p class="listcap"><a id="ch8ex4"/><em>Listing 8-4: Deprecated method for handling received URLs</em></p>
<p class="indent">Using <span class="literal">handleOpenURL</span> is undesirable in many cases because the method blindly opens any URL given to it, and it gives you no way to identify where the URL came from. Of course, verifying the source application provides only limited guarantees.</p>
<h5 class="h5" id="ch08lev3sec02"><strong>How Safe Is Sender Validation?</strong></h5>
<p class="noindent">Given what I’ve discussed in this section, you may well wonder whether you can trust the value of the <span class="literal">sourceApplication</span> parameter at all. Good question! While the sender check is merely a string comparison and is not directly cryptographic, Apple does ensure that all app IDs submitted to the App Store are unique: first come, first served. On a jailbroken device, however, you can’t guarantee this uniqueness, so be wary of blindly trusting a URL just because it claims to come from a particular application.</p>
<h4 class="h4" id="ch08lev2sec04"><em><strong>URL Scheme Hijacking</strong></em></h4>
<p class="noindent">The relatively simple system of URL scheme definition that I described has a potential problem. What if another application tries to register your URL scheme? In the case of Apple’s built-in applications, other applications won’t be able to successfully register a duplicate scheme. For everyone else, though, the resultant behavior is ... undefined. Just ask Apple:</p>
<div class="blockquote">
<p class="noindent">If more than one third-party app registers to handle the same URL scheme, there is currently no process for determining which app will be given that scheme.<sup><a href="footnote.html#fn75" id="fn_75">2</a></sup></p>
</div>
<p class="indent">In other words, you face two unpleasant possibilities. First, a malicious application installed before your application could register your URL scheme and retain it after your application is installed. Or, a malicious application installed after your application could successfully register your URL scheme, effectively hijacking it from your application. Either situation can result in data intended for your application going to a malicious third-party app. What can you do? I’ll let you know once I figure that out.</p>
<p class="indent">In recent versions of iOS, however, alternative mechanisms for passing data between applications have been made available, each appropriate for <a id="page_137"/>different circumstances. These may be a better fit for your app than <span class="literal">openURL</span>. Let’s look at a few of these newer methods now.</p>
<h3 class="h3" id="ch08lev1sec02"><strong>Universal Links</strong></h3>
<p class="noindent">URL scheme hijacking is one of the reasons that Apple introduced <em>Universal Links</em> in iOS 9. Universal Links are a way to effectively provide deep linking in an iOS application and integration between websites and mobile applications. For example, imagine you’ve published an instant messaging application called HoopChat. If a user visits a website that has a “Message me in HoopChat!” button, this could link to a URL like <em><a href="https://www.hoopchat.com/im/send/?id=356372">https://www.hoopchat.com/im/send/?id=356372</a></em>. If the user clicks this link and has your application installed, the link would open directly in your application, where the app could create a new message to the person with the user ID of 356372. If the user doesn’t have the application installed, the same URL would be viewed in Mobile Safari, which would take you to a web-based UI to send a message.</p>
<p class="indent">Behind the scenes, the way this works is that the application has an entitlement that specifies how it handles links to particular domains, as shown in <a href="ch08.html#ch8fig2">Figure 8-2</a>.</p>
<div class="image"><img alt="image" src="graphics/f08-02.jpg"/></div>
<p class="figcap"><a id="ch8fig2"/><em>Figure 8-2: Enabling Universal Links under Associated Domains in Xcode</em></p>
<p class="indent">When one of these domains is visited in Mobile Safari, a file called <em>apple -app-site-association</em> is downloaded from the web server. This takes the form of a signed blob of JSON, as in <a href="ch08.html#ch8ex5">Listing 8-5</a>.</p>
<p class="programs">   {<br/>      "applinks": {<br/>         "apps": [],<br/>         "details": {<br/><span class="ent">➊</span>          "FAFBQM3A4N.com.hoopchat.messenger": {<br/><span class="ent">➋</span>            "paths": [ "*" ]<br/>            }<br/>         }<br/>      }<br/>   }</p>
<p class="listcap"><a id="ch8ex5"/><em>Listing 8-5: Format of the</em> apple-app-site-association <em>file</em></p>
<p class="indent"><a id="page_138"/>This file specifies the developer team ID, the bundle identifier (shown at <span class="ent">➊</span>), and the URL paths that should be handled by the app (as opposed to the main website). In this case, all URLs should be handled by the app if it’s installed, so the file gives a value of <span class="literal">*</span> at <span class="ent">➋</span>.</p>
<p class="indent">As mentioned, this blob needs to be signed; the signing key is actually the private key to your production SSL certificate. If you have the private and public keys to your website, your JSON file can be signed from the command line, as shown in <a href="ch08.html#ch8ex6">Listing 8-6</a>.</p>
<p class="programs">   openssl smime \<br/>       -sign \<br/>       -nodetach \<br/><span class="ent">➊</span>     -in "unsigned.json" \<br/><span class="ent">➋</span>         -out "apple-app-site-association" \<br/>       -outform DER \<br/><span class="ent">➌</span>         -inkey "private-key.pem" \<br/><span class="ent">➍</span>         -signer "certificate.pem"</p>
<p class="listcap"><a id="ch8ex6"/><em>Listing 8-6: Signing the</em> apple-app-site-association <em>file</em></p>
<p class="indent">This example uses the <span class="literal">openssl</span> utility, providing it with the unsigned JSON file at <span class="ent">➊</span> and the output filename at <span class="ent">➋</span>. At <span class="ent">➌</span> and <span class="ent">➍</span>, a key pair is provided. If your key is protected by a passphrase, you’d enter that when prompted, and you’d receive a valid <em>apple-app-site-association</em> file as the output. This file would then be uploaded to the web root of your website, where iOS would fetch it over HTTPS to determine whether to pass the URL to your app. Within the application, logic as to what action your app will take upon receiving a universal link will depend on what you implement in the <span class="literal">application:continueUserActivity:restorationHandler:</span> method of your application delegate.</p>
<p class="indent">This universal linking approach is preferable to custom URL handling schemes for a few reasons. First, Universal Links isn’t subject to URL scheme hijacking; only your website, authenticated over HTTPS, can specify what URLs will be opened in your application, and those calls can’t be sent to a separate bundle ID. Second, the links should work regardless of whether an app is installed. In earlier versions of iOS, you’d just get an error saying that the scheme isn’t recognized. With Universal Links, if the app isn’t installed, you’ll be sent to the equivalent on the website. Finally, Universal Links provide some privacy protections by preventing applications from enumerating what applications are present on a device. (Apps could previously use the <span class="literal">canOpenURL</span> method to enumerate installed applications; with Universal Links, no such mechanism exists.)</p>
<p class="indent">Now that you’ve seen how you can control interactions with your own application, let’s take a look at some ways to more deeply integrate your application with popular apps and services using <span class="literal">UIActivity</span>.</p>
<h3 class="h3" id="ch08lev1sec03"><a id="page_139"/><strong>Sharing Data with UIActivity</strong></h3>
<p class="noindentb">In iOS 6, Apple started allowing third-party applications to share information through a set of predefined methods, such as sending data via an email or posting to Facebook. This limited form of IPC allows developers to implement the most basic sharing functionality. You can get an idea of the types of data this is useful for by examining the following <span class="literal">UIActivity</span> types:</p>
<p class="bull">• <span class="literal">UIActivityTypePostToFacebook</span></p>
<p class="bull">• <span class="literal">UIActivityTypePostToTwitter</span></p>
<p class="bull">• <span class="literal">UIActivityTypePostToWeibo</span></p>
<p class="bull">• <span class="literal">UIActivityTypePostToTencentWeibo</span></p>
<p class="bull">• <span class="literal">UIActivityTypePostToFlickr</span></p>
<p class="bull">• <span class="literal">UIActivityTypePostToVimeo</span></p>
<p class="bull">• <span class="literal">UIActivityTypeMessage</span></p>
<p class="bull">• <span class="literal">UIActivityTypeMail</span></p>
<p class="bull">• <span class="literal">UIActivityTypePrint</span></p>
<p class="bull">• <span class="literal">UIActivityTypeCopyToPasteboard</span></p>
<p class="bull">• <span class="literal">UIActivityTypeAssignToContact</span></p>
<p class="bull">• <span class="literal">UIActivityTypeSaveToCameraRoll</span></p>
<p class="bull">• <span class="literal">UIActivityTypeAddToReadingList</span></p>
<p class="bull">• <span class="literal">UIActivityTypeAirDrop</span></p>
<p class="indentt">To share via <span class="literal">UIActivity</span>, just create a <span class="literal">UIActivityViewController</span> and pass it data such as text, a URL, an image, and so forth, as shown in <a href="ch08.html#ch8ex7">Listing 8-7</a>.</p>
<p class="programs"><span class="violet1">NSString</span> *text = <span class="red">@"Check out this highly adequate iOS security resource"</span>;<br/><span class="violet1">NSURL</span> *url = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"http://nostarch.com/iossecurity/"</span>];<br/><br/><span class="violet1">UIActivityViewController *</span>controller = [[<span class="violet1">UIActivityViewController</span> <span class="violet">alloc</span><span class="violet1">]</span><br/>                            <span class="violet1">initWithActivityItems:@[text, url]</span><br/>                            <span class="violet1">applicationActivities:nil];</span><br/><br/><span class="violet1">[navigationController presentViewController:controller animated:YES completion:nil</span><br/>     <span class="violet1">];</span></p>
<p class="listcap"><a id="ch8ex7"/><em>Listing 8-7: Instantiating a</em> <span class="literal">UIActivityViewController</span></p>
<p class="indent">Here, a <span class="literal">UIActivityViewController</span> called <span class="literal">controller</span> is passed some text and a URL. If certain modes of sharing aren’t appropriate for the data, you can exclude them. For example, if you want to ensure that users can only mail or print your content but not post to social networking sites, you can tell <span class="literal">UIActivityViewController</span> to exclude all other known types of sharing, as in <a href="ch08.html#ch8ex8">Listing 8-8</a>.</p>
<p class="programs"><a id="page_140"/>[controller <span class="violet">setExcludedActivityTypes</span>:@[<span class="violet1">UIActivityTypePostToFacebook,</span><br/>                                       <span class="violet1">UIActivityTypePostToTwitter</span><br/>                                       <span class="violet1">UIActivityTypePostToWeibo</span><br/>                                       <span class="violet1">UIActivityTypePostToTencentWeibo</span><br/>                                       <span class="violet1">UIActivityTypePostToFlickr</span><br/>                                       <span class="violet1">UIActivityTypePostToVimeo</span><br/>                                       <span class="violet1">UIActivityTypeMessage</span><br/>                                       <span class="violet1">UIActivityTypeCopyToPasteboard</span><br/>                                       <span class="violet1">UIActivityTypeAssignToContact</span><br/>                                       <span class="violet1">UIActivityTypeSaveToCameraRoll</span><br/>                                       <span class="violet1">UIActivityTypeAddToReadingList</span><br/>                                       <span class="violet1">UIActivityTypeAirDrop];</span></p>
<p class="listcap"><a id="ch8ex8"/><em>Listing 8-8: Excluding certain types of sharing activities</em></p>
<p class="indent">This exclusion approach is, unfortunately, not convenient or thorough, and any sharing types added in future versions of iOS will be included by default. If it’s important to disable parts of the sharing UI, be sure that you test with the most recent versions of iOS before they reach the general public.</p>
<p class="indent">In addition to URL schemes and <span class="literal">UIActivity</span> methods, there’s one more way to handle IPC in iOS: through extensions.</p>
<h3 class="h3" id="ch08lev1sec04"><strong>Application Extensions</strong></h3>
<p class="noindent">In iOS 8 and later, developers can write various <em>extensions</em>, which behave like specialized forms of IPC. The extensions allow you to present data to other applications, have applications share data through your app, or alter system behavior. <a href="ch08.html#ch8tab1">Table 8-1</a> shows the various kinds of <em>extension points</em> you can code for. An extension point defines what component of the OS the extension will have access to and how it will need to be coded.</p>
<p class="tablecap"><a id="ch8tab1"/><strong>Table 8-1:</strong> Extension Points</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Type</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Function</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">Today</p></td>
<td class="table" valign="top"><p class="table">Manipulates widgets in the Today view of the Notification Center</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Share</p></td>
<td class="table" valign="top"><p class="table">Allows data to be sent to your app via Share buttons</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Action</p></td>
<td class="table" valign="top"><p class="table">Reads or manipulates data to be returned to the host app</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Photo</p></td>
<td class="table" valign="top"><p class="table">Provides methods to manipulate photos within the Photos app</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Document Provider</p></td>
<td class="table" valign="top"><p class="table">Allows access to a library of files</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Keyboard</p></td>
<td class="table" valign="top"><p class="table">Provides a custom keyboard</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_141"/>While app extensions aren’t applications, they are required to come bundled with an application, referred to as the <em>containing app</em>. Third-party applications that use an extension (called <em>host apps</em>) can communicate with the extension bundled in the containing app, but the containing app itself does not directly talk to the extension. Apple also specifically excludes some functions from being accessible via extensions, such as using the HealthKit API, receiving AirDrop data, or accessing the camera or microphone.</p>
<p class="indent">Extensions can be implemented in many ways, and they can be treated as applications in and of themselves. As shown in <a href="ch08.html#ch8fig3">Figure 8-3</a>, extensions are created as their own applications within Xcode.</p>
<div class="image"><img alt="image" src="graphics/f08-03.jpg"/></div>
<p class="figcap"><a id="ch8fig3"/><em>Figure 8-3: Adding a new extension target to a project</em></p>
<p class="indent">For this book, however, let’s home in on the most important aspects to check from a security perspective.</p>
<h4 class="h4" id="ch08lev2sec05"><em><strong>Checking Whether an App Implements Extensions</strong></em></h4>
<p class="noindent">First, you can easily determine whether the app you’re examining implements an extension by searching for the <span class="literal">NSExtensionPointIdentifier</span> inside property lists. To search for that property, you can execute the following command in the project’s <em>root</em> directory:</p>
<p class="programs">$ find . -name "*.plist" |xargs grep NSExtensionPointIdentifier</p>
<p class="indent">This greps all <em>.plist</em> files in the directory for <span class="literal">NSExtensionPointIdentifier</span>. You can also search for the property by checking the <em>.plist</em> file within Xcode, as in <a href="ch08.html#ch8fig4">Figure 8-4</a>.</p>
<div class="image"><a id="page_142"/><img alt="image" src="graphics/f08-04.jpg"/></div>
<p class="figcap"><a id="ch8fig4"/><em>Figure 8-4: The</em> Info.plist <em>of a newly created extension, viewed in Xcode</em></p>
<p class="indent">An extension’s <em>Info.plist</em> file will contain the type of extension being used, as well as optional definitions of the types of data that the extension is designed to handle. If you find the <span class="literal">NSExtensionPointIdentifier</span> property defined, you should dig in to the project and find the view controller for the defined extension.</p>
<h4 class="h4" id="ch08lev2sec06"><em><strong>Restricting and Validating Shareable Data</strong></em></h4>
<p class="noindent">For share and action extensions, you can define an <span class="literal">NSExtensionActivationRule</span>, which contains a dictionary of data types that your application is restricted to handling (see <a href="ch08.html#ch8fig5">Figure 8-5</a>).</p>
<div class="image"><img alt="image" src="graphics/f08-05.jpg"/></div>
<p class="figcap"><a id="ch8fig5"/><em>Figure 8-5: Activation rules in an extension’s</em> .plist <em>file, viewed in Xcode</em></p>
<p class="indent">This dictionary will be evaluated to determine what data types your extension allows and the maximum number of these items you’ll accept. But apps aren’t limited to accepting predefined types of data; they can also implement custom <span class="literal">NSPredicate</span>s to define their own rules for what they’ll accept. If this is the case, you’ll see the <span class="literal">NSExtensionActivationRule</span> represented as a string rather than a numeric value.</p>
<p class="indentb">If you know you’re dealing with predefined data types, however, keep the following predefined activation rules in mind:</p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsAttachmentsWithMaxCount</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsAttachmentsWithMinCount</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsFileWithMaxCount</span></p>
<p class="bull"><a id="page_143"/>• <span class="literal">NSExtensionActivationSupportsImageWithMaxCount</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsMovieWithMaxCount</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsText</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsWebURLWithMaxCount</span></p>
<p class="bull">• <span class="literal">NSExtensionActivationSupportsWebPageWithMaxCount</span></p>
<p class="indentt">Because extensions can often receive unknown and arbitrary kinds of data, it’s important to ensure that your extension performs correct validation in the <span class="literal">isContentValid</span> method of its view controller, particularly in share or action extensions. Examine the logic in your app’s implementation of this method and determine whether the app is performing the necessary validation required.</p>
<p class="indent">Typically, an extension will examine the <span class="literal">NSExtensionContext</span> (which is passed in by the host app when it calls <span class="literal">beginRequestWithExtensionContext</span>), as in <a href="ch08.html#ch8ex9">Listing 8-9</a>.</p>
<p class="programs"><span class="violet1">NSExtensionContext</span> *context = [<span class="rose">self</span> extensionContext];<br/><span class="violet1">NSArray</span> *items = [context inputItems];</p>
<p class="listcap"><a id="ch8ex9"/><em>Listing 8-9: Creating an array of</em> <span class="literal">NSExtensionItem</span><em>s from the</em> <span class="literal">NSExtensionContext</span></p>
<p class="indent">This will give an array of <span class="literal">NSExtensionItem</span> objects, and each object will contain a different type of data passed in by the host app, such as images, URLs, text, and so on. Each of these items should be examined and validated before you use them to perform actions or allow the user to post the data.</p>
<h4 class="h4" id="ch08lev2sec07"><em><strong>Preventing Apps from Interacting with Extensions</strong></em></h4>
<p class="noindent">Keyboard extensions have the unique characteristic that they read every keystroke that a user enters into them. Different third-party keyboards may have various degrees of keystroke logging to help with things such as auto-completion or sending data to a remote web service for processing. It’s also possible that an actively malicious keyboard could be distributed, working as a pure keylogger. If your application accepts security-sensitive data via the keyboard, you may want to prevent the use of third-party keyboards with your application. You can do this with the <span class="literal">shouldAllowExtensionPointIdentifier</span> delegate method, as shown in <a href="ch08.html#ch8ex10">Listing 8-10</a>.</p>
<p class="programs">- (<span class="rose">BOOL</span>)application:(<span class="violet1">UIApplication *</span>)application<br/>     <span class="violet">shouldAllowExtensionPointIdentifier</span>:(<span class="violet1">NSString</span> *)extensionPointIdentifier {<br/>    <span class="rose">if</span> ([extensionPointIdentifier <span class="violet">isEqualToString</span>:<span class="violet1">UI</span><br/>     <span class="violet1">ApplicationKeyboardExtensionPointIdentifier]) {</span><br/>        <span class="rose">return</span> <span class="violet1">NO;</span><br/>    <span class="violet1">}</span><br/>    <span class="rose">return</span> <span class="violet1">YES;</span><br/><span class="violet1">}</span></p>
<p class="listcap"><a id="ch8ex10"/><em>Listing 8-10: The</em> <span class="literal">shouldAllowExtensionPointIdentifier</span> <em>delegate method</em></p>
<p class="indent"><a id="page_144"/>This code simply examines the value of <span class="literal">extensionPointIdentifier</span> and returns <span class="literal">NO</span> if it matches the constant <span class="literal">UIApplicationKeyboardExtensionPointIdentifier</span>. Note that currently third-party keyboards are the only extensions that can be disabled in this fashion.</p>
<p class="indent">You’ve seen the best ways to implement IPC, so to close the chapter, I’ll walk you through one approach to IPC that you may see in the wild that doesn’t work out so well.</p>
<h3 class="h3" id="ch08lev1sec05"><strong>A Failed IPC Hack: The Pasteboard</strong></h3>
<p class="noindent">There have been occasional reports of people abusing the <span class="literal">UIPasteboard</span> mechanism as a kind of IPC channel. For example, some try using it to transfer a user’s data from a free version of an application to a “pro” version, since there’s no way the newly installed application can read the old application’s data. Don’t do that!</p>
<p class="indent">An OAuth library designed to work with Twitter<sup><a href="footnote.html#fn76" id="fn_76">3</a></sup> uses the general paste-board as a mechanism to shuffle authentication information from a web view to the main part of the app, as in this example:</p>
<p class="programs">   - (<span class="rose">void</span>) pasteboardChanged: (<span class="violet1">NSNotification</span> *) note {<br/><span class="ent">➊</span>     <span class="violet1">UIPasteboard *</span>pb = [<span class="violet1">UIPasteboard</span> <span class="violet">generalPasteboar</span><span class="violet1">d];</span><br/><br/>       <span class="rose">if</span> <span class="violet1">([note.userInfo</span> <span class="violet">objectForKey</span><span class="violet1">:UIPasteboardChangedTypesAddedKey] == nil)</span><br/>        <span class="rose">return</span><span class="violet1">;</span><br/>       <span class="violet1">NSString *copied = pb.string;</span><br/><br/>       <span class="rose">if</span> (<span class="violet1">copied.length != 7 || !copied.oauthtwitter_isNumeric)</span> <span class="rose">return</span><span class="violet1">;</span><br/><span class="ent">➋</span>     <span class="violet1">[</span><span class="rose">self</span> <span class="violet1">gotPin:copied];</span><br/>   <span class="violet1">}</span></p>
<p class="indent">After reading data from the general pasteboard at <span class="ent">➊</span>, this library validates the data and sends it to the <span class="literal">gotPin</span> method at <span class="ent">➋</span>.</p>
<p class="indent">But the general pasteboard is shared among all applications and can be read by any process on the device. This makes the pasteboard a particularly bad place to store anything even resembling private data. I’ll go into more detail on the pasteboard in <a href="ch10.html#ch10">Chapter 10</a>, but for now, ensure that the app you’re examining isn’t putting anything on the pasteboard that you wouldn’t want every other app to know about.</p>
<h3 class="h3" id="ch08lev1sec06"><a id="page_145"/><strong>Closing Thoughts</strong></h3>
<p class="noindent">While IPC in iOS appears limited at first, there are ample opportunities for developers to fail to parse externally supplied input, create new data leaks, and even potentially send data to the wrong app. Ensure that sharing is appropriately limited, received data is validated, sending applications are verified, and unencrypted data isn’t passed by simply trusting that the receiving URL handler is the one you would expect.<a id="page_146"/></p>
</body></html>