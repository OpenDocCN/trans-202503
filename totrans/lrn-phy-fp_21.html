<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_339"/><span class="big">19</span><br/>INTERACTING PARTICLES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In Newtonian mechanics, forces that act on particles are produced by other particles. The goal of this chapter is to develop the key ideas that will allow us to predict the motion of multiple interacting particles: Newton’s third law, the two-body force, and the distinction between internal and external forces. As usual, we’ll express these ideas in code.</p>&#13;
<p class="indent">We’ll begin the chapter by discussing Newton’s third law. We’ll then develop the idea of a two-body force to express the notion that an interaction between two particles leads to one force produced by one particle on a second particle and simultaneously leads to another force produced by the second particle on the first particle. Two-body force is a significant enough idea in multi-particle situations that we’ll define a data type for two-body force. We’ll decide which particles are going to be in our system and then distinguish between an internal force and an external force. We’ll finish the chapter by considering the state of a multi-particle system and writing a state-update rule that automatically applies Newton’s third law, so we need <span epub:type="pagebreak" id="page_340"/>not apply it manually. In the next chapter, we’ll apply the ideas discussed here to specific example situations.</p>&#13;
<h3 class="h3" id="ch19lev1">Newton’s Third Law</h3>&#13;
<p class="noindent">If we stand on slippery ice and push our friend, we might find ourselves accelerating in the direction opposite from the way we pushed. We produced a force on our friend, but our friend also produced a force on us, whether or not that was their intention. Newton’s third law claims that these two forces are equal and opposite.</p>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s third law, Newton’s words [<strong><a href="bib.xhtml#bib15"><span class="green">15</span></a></strong>]</strong></p>&#13;
<p class="noindent"><em>To any action there is always an opposite and equal reaction; in other words, the actions of two bodies upon each other are always equal and always opposite in direction.</em></p>&#13;
</div>&#13;
<div class="quote">&#13;
<p class="noindent"><strong>Newton’s third law, modern version</strong></p>&#13;
<p class="noindent"><em>If object A exerts a force on object B, then object B exerts a force on object A. This second force is equal in magnitude to the first force, but opposite in direction.</em></p>&#13;
</div>&#13;
<p class="indent">When we say the <em>second</em> force, we’re not implying an order in time. The forces arise together, from the same process, whatever the interaction between the objects is.</p>&#13;
<p class="indent">When dealing with Newton’s second law, as we did in the previous five chapters, we’re only concerned with the forces that act <em>on</em> the object we’re applying Newton’s second law to. If an object also produces forces on other objects, that’s fine, but those forces only get counted when we apply Newton’s second law to one of those other objects. Newton’s second law cares about the forces <em>on</em> an object, not the forces produced <em>by</em> an object.</p>&#13;
<p class="indent">Newton’s third law, on the other hand, cares about both and asserts a relationship between them for each interaction. Newton’s second law applies to an object; Newton’s third law applies to an interaction between two objects.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19list1">Listing 19-1</a> shows the first lines of code for the <span class="literal">MultipleObjects</span> module we’ll develop in this chapter.</p>&#13;
<pre id="ch19list1">{-# OPTIONS -Wall #-}&#13;
{-# LANGUAGE MultiParamTypeClasses #-}&#13;
&#13;
module MultipleObjects where&#13;
&#13;
import SimpleVec&#13;
    ( Vec, R, (^+^), (^-^), (*^), (^*), (^/), zeroV, magnitude )&#13;
import Mechanics1D&#13;
    ( RealVectorSpace(..), Diff(..), NumericalMethod, Mass, TimeStep, euler )&#13;
import Mechanics3D&#13;
    ( OneBodyForce, ParticleState(..), DParticleState(..), HasTime(..)&#13;
    , defaultParticleState, newtonSecondPS )&#13;
</pre>&#13;
<p class="listing"><em>Listing 19-1: Opening lines of code for the <span class="literal">MultipleObjects</span> module</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_341"/>You should be familiar with the first line by now: it turns on warnings. The second line turns on a language option that allows us to use multiparameter type classes; we’ll explain this later in the chapter. We name the module <span class="literal">MultipleObjects</span>. We import the data types <span class="literal">Vec</span> and <span class="literal">R</span> from <span class="literal">SimpleVec</span> so we can refer to them in our type signatures. We also import the zero vector, the <span class="literal">magnitude</span> function, and the basic vector operators from <span class="literal">SimpleVec</span>. We use the type classes <span class="literal">RealVectorSpace</span> and <span class="literal">HasTime</span> to extend the general-purpose numerical methods <span class="literal">euler</span> and <span class="literal">rungeKutta4</span> to the multi-particle setting of this chapter. By making the new data type for multi-particle state an instance of these two type classes, we’ll be able to use the two general-purpose numerical methods. We import <span class="literal">newtonSecondPS</span>, the function that applies Newton’s second law to a single particle, to use in the function we write that applies Newton’s second law to a collection of particles. We import <span class="literal">euler</span> to use as a basis for writing an Euler-Cromer method for multiple particles. We’ll fill out the rest of the module as we move through the chapter.</p>&#13;
<div class="note">&#13;
<p class="note-title"><span class="bg1">NOTE</span></p>&#13;
<p class="note-para"><em>We’ll be using the terms</em> body, object, <em>and</em> particle <em>interchangeably. A particle connotes a small thing; the words</em> body <em>and</em> object <em>sometimes connote things that are larger and have an orientation in space. Change in orientation is called</em> rotation, <em>and the study of objects with orientations that can rotate as well as move through space is called</em> rigid-body mechanics. <em>We won’t be getting into rigid-body mechanics here, although this chapter contains important prerequisite material for the subject. What we mean when using the word</em> body, object, <em>or</em> particle <em>is something that can experience forces, move, and accelerate through space but that either has no orientation or allows us to ignore its orientation. Sometimes the term point particle is used to emphasize that orientation is irrelevant.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch19lev2">Two-Body Forces</h3>&#13;
<p class="noindent">In <a href="ch16.xhtml">Chapter 16</a>, we defined a <span class="literal">OneBodyForce</span> to be a function taking the state of a particle as input and producing a (vector) force on the particle as output. The one-body force is appropriate when the force acting on the one body depends only on that body’s state of affairs: namely, its position, velocity, mass, charge, or current time.</p>&#13;
<p class="indent">Many forces in mechanics are fundamentally <em>two-body</em> in nature, meaning the force vector depends on the states of both the particle producing the force and the particle experiencing the force. A <em>two-body force</em> is a force that depends on the states of two particles.</p>&#13;
<pre>type TwoBodyForce&#13;
    =  ParticleState  -- force is produced BY particle with this state&#13;
    -&gt; ParticleState  -- force acts ON particle with this state&#13;
    -&gt; ForceVector</pre>&#13;
<p class="indent">The type <span class="literal">ForceVector</span> is a type synonym for <span class="literal">Vec</span>, the name suggesting that the particular vector we have in mind represents a force.</p>&#13;
<pre>type ForceVector = Vec</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_342"/>The force vector returned by a two-body force is produced <em>by</em> the particle whose state is given first in <span class="literal">TwoBodyForce</span>, and it acts <em>on</em> the particle whose state is given second. Let’s call this the <em>by-on convention</em>. The comments in the code just shown remind us of this convention.</p>&#13;
<p class="indent">Every two-body force we write should obey Newton’s third law. If the two particle states are exchanged, the force vector produced should be negated from what it was. That is, if <span class="literal">f</span> is a two-body force, the vector <span class="literal">f st2 st1</span> should be the negative of <span class="literal">f st1 st2</span>. Since the force acting on one particle is the negative of the force acting on the other, a convention like the by-on convention is important so that, for example, gravity acts as an attractive force and not as a repulsive force.</p>&#13;
<p class="indent">There is a relationship between a two-body force and a one-body force. Given the state of a particle that is producing a force, we can turn a two-body force into a one-body force by providing the two-body force with its first input and nothing else. This creates a function. The function takes the state of a particle on which the force acts and returns a force vector, making the function a one-body force. Here is the Haskell code to express this idea:</p>&#13;
<pre>oneFromTwo :: ParticleState  -- state of particle PRODUCING the force&#13;
           -&gt; TwoBodyForce&#13;
           -&gt; OneBodyForce&#13;
oneFromTwo stBy f = f stBy</pre>&#13;
<p class="indent">This code is deceptively simple. By applying the two-body force <span class="literal">f</span> to the state of the particle that is producing the force, we obtain a one-body force. The local variable <span class="literal">stBy</span> holds the state of the particle producing the force; equivalently, the force is produced <em>by</em> the particle with the state <span class="literal">stBy</span>.</p>&#13;
<p class="indent">If our brains worked more like the Haskell compiler, we might not bother to make this definition of <span class="literal">oneFromTwo</span> because in any place we use this function, we could achieve equivalent behavior with fewer keystrokes by omitting the name <span class="literal">oneFromTwo</span> and reversing the order of its arguments. However, my brain does not work enough like the Haskell compiler for this to be an easy or natural thing to do. I believe that this function, silly as it is for the Haskell compiler, offers value to the human reader and writer of code because it engages the ideas and terminology of mechanics, namely one- and two-body forces. With experience in programming, you will come across more ways of writing code that the compiler sees as equivalent but that sit differently on your brain. Use the flexibility of the language to write in a way that is easy for you, and perhaps others, to read and understand. Your code is not just for the computer; it’s for you and other people too.</p>&#13;
<p class="indent">We’ll use the function <span class="literal">oneFromTwo</span> when we talk about springs later in the chapter. We’ll also use it when we want to collect all the forces that act on one particle.</p>&#13;
<p class="indent">Let’s look at some examples of two-body forces. We need to be careful of two issues as we write a two-body force. First, a two-body force needs to respect Newton’s third law. To achieve this, as we will see in the examples that follow, the states of the two bodies need to be used in a symmetric way. (More precisely, the two states need to be used in an <em>anti-symmetric</em> way so <span epub:type="pagebreak" id="page_343"/>that interchanging them produces a minus sign.) Second, we need to respect the by-on convention so we have a clear understanding of which body the force acts on. Haskell’s type system will not prevent us from mistakenly writing a <span class="literal">TwoBodyForce</span> that violates Newton’s third law, or one that returns the wrong force, so we need to be careful.</p>&#13;
<h4 class="h4" id="ch19lev3">Universal Gravity</h4>&#13;
<p class="noindent">Newton was the first to give a quantitative relationship describing the gravitational force between two massive spherical objects. He showed that the force exerted by one object on another is directly proportional to the mass of each object and inversely proportional to the square of the distance between their centers. As an equation, Newton’s law of universal gravity can be written as</p>&#13;
<div class="imagec"><img src="Images/343fig01.jpg" alt="Image" width="399" height="39"/></div>&#13;
<p class="noindent">where <em>m</em><sub>1</sub> is the mass of object 1, <em>m</em><sub>2</sub> is the mass of object 2, and <em>r</em> is the distance between the centers of the objects. This equation gives the magnitude of the force produced by object 1 on object 2 (which, by Newton’s third law, is the same as the magnitude of the force produced by object 2 on object 1). In SI units, the constant <em>G</em> = 6.67408 × 10<sup>–11</sup> N m<sup>2</sup>/kg<sup>2</sup>. Equation 19.1 can be translated into Haskell as follows:</p>&#13;
<pre>gravityMagnitude :: Mass -&gt; Mass -&gt; R -&gt; R&#13;
gravityMagnitude m1 m2 r = let gg = 6.67408e-11  -- N m^2 / kg^2&#13;
                           in gg * m1 * m2 / r**2</pre>&#13;
<p class="indent">We can use vector notation to give a more comprehensive version of Newton’s law of universal gravity, which includes the direction of the force in the equation. Define the displacement vector <strong>r</strong><sub>21</sub> to be the vector that points from particle 1 to particle 2, as in <a href="ch19.xhtml#ch19fig1">Figure 19-1</a>.</p>&#13;
<div class="imagel" id="ch19fig1"><img src="Images/343fig02.jpg" alt="Image" width="249" height="166"/></div>&#13;
<p class="figcap"><em>Figure 19-1: The displacement vector r<sub>21</sub> points from particle 1 to particle 2.</em></p>&#13;
<p class="indent">We’ll also define a unit vector <img class="inline" src="Images/e0343-02.jpg" alt="Image" width="25" height="21"/> to point in the direction from particle 1 to particle 2.</p>&#13;
<div class="imagec"><img src="Images/343equ02.jpg" alt="Image" width="394" height="47"/></div>&#13;
<p class="indent">The force <strong>F</strong><sub>21</sub> exerted on particle 2 produced by particle 1 is given in vector notation by replacing <em>r</em> in Equation 19.1 with |<strong>r</strong><sub>21</sub>| and indicating the <span epub:type="pagebreak" id="page_344"/>direction of the force with <img class="inline" src="Images/e0344-01.jpg" alt="Image" width="36" height="21"/> because the force on particle 2 points toward particle 1.</p>&#13;
<div class="imagec"><img src="Images/344equ01.jpg" alt="Image" width="515" height="52"/></div>&#13;
<p class="indent">Notice that the force <strong>F</strong><sub>21</sub> on object 2 points opposite to the displacement vector <strong>r</strong><sub>21</sub>; that is, it points toward object 1. This makes sense because gravity is an attractive force.</p>&#13;
<p class="indent">Comparing Equations 19.1 and 19.3, we see that Equation 19.1 is simpler, while Equation 19.3 is more powerful since the direction of the force is encoded in the equation.</p>&#13;
<p class="indent">If <strong>r</strong><sub>1</sub> is the position vector for particle 1 and <strong>r</strong><sub>2</sub> is the position vector for particle 2, then <strong>r</strong><sub>21</sub> = <strong>r</strong><sub>2</sub> – <strong>r</strong><sub>1</sub>, and we can write the force on particle 2 as:</p>&#13;
<div class="imagec"><img src="Images/344equ02.jpg" alt="Image" width="453" height="52"/></div>&#13;
<p class="indent">Here is the Haskell definition for the two-body force of universal gravity:</p>&#13;
<pre>universalGravity :: TwoBodyForce&#13;
universalGravity st1 st2&#13;
    = let gg = 6.67408e-11  -- N m^2 / kg^2&#13;
          m1 = mass st1&#13;
          m2 = mass st2&#13;
          r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          r21 = r2 ^-^ r1&#13;
      in (-gg) *^ m1 *^ m2 *^ r21 ^/ magnitude r21 ** 3</pre>&#13;
<p class="indent">We use the extraction (also called eliminator or selector) functions <span class="literal">mass</span> and <span class="literal">posVec</span> from the <span class="literal">ParticleState</span> data type to extract the masses and position vectors of the two particles and we give local names to these values. The final expression we return comes from Equation 19.4.</p>&#13;
<p class="indent">Notice that universal gravity obeys Newton’s third law. We calculate the force <strong>F</strong><sub>12</sub> produced by particle 2 on particle 1 by exchanging the roles of <em>m</em><sub>1</sub> with <em>m</em><sub>2</sub> and of <strong>r</strong><sub>1</sub> with <strong>r</strong><sub>2</sub>.</p>&#13;
<div class="imagec"><img src="Images/344equ03.jpg" alt="Image" width="448" height="52"/></div>&#13;
<h4 class="h4" id="ch19lev4">Constant Repulsive Force</h4>&#13;
<p class="noindent">Let’s try to write a constant repulsive force between two objects; in other words, a force that doesn’t depend on the distance between the objects.</p>&#13;
<p class="indent">Here’s a wrong way to do it:</p>&#13;
<pre>constantRepulsiveForceWrong :: ForceVector -&gt; TwoBodyForce&#13;
constantRepulsiveForceWrong force = \_ _ -&gt; force</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_345"/>The intent of the code is clear: we intend to ignore the states of the particles and return whatever force was given. This code satisfies the Haskell type checker and compiles, but it does not satisfy Newton’s third law. Since the particle states are completely ignored, there is no chance that exchanging the particle states will reverse the direction of the force, as required by Newton’s third law.</p>&#13;
<p class="indent">Here is a constant repulsive force that does obey Newton’s third law:</p>&#13;
<pre>constantRepulsiveForce :: R -&gt; TwoBodyForce&#13;
constantRepulsiveForce force st1 st2&#13;
    = let r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          r21 = r2 ^-^ r1&#13;
      in force *^ r21 ^/ magnitude r21</pre>&#13;
<p class="indent">Instead of passing a force vector to our function, we now pass only a force magnitude. We use the positions of the two bodies to determine what direction “repulsive” is. When we exchange the two particle states in this two-body force, the direction of the force is properly reversed.</p>&#13;
<h4 class="h4" id="ch19lev5">Linear Spring</h4>&#13;
<p class="noindent">A spring, typically made of coiled metal or plastic, can be extended by pulling its ends apart and compressed by pushing them toward each other. The spring has some equilibrium length, which is the distance between the two ends when the spring is detached and allowed to assume its natural shape.</p>&#13;
<p class="indent">If objects are connected to the ends of the spring, the spring can exert forces on these objects. If the distance between the two objects becomes less than the equilibrium length of the spring, the spring compresses and exerts repulsive forces on the objects in an effort to restore its equilibrium length. Similarly, an extended spring seeks restoration by exerting attractive forces on the objects at its ends. If the mass of the spring is negligible compared with the masses of the objects at its ends, then the force exerted by one end of the spring on one object will be equal and opposite to the force exerted by the other end of the spring on the other object. The spring acts as a Newton’s third law–respecting two-body force between the two objects. Since the magnitudes of the forces at each end are equal, we sometimes speak of the force of the spring as if it were one single value.</p>&#13;
<p class="indent">We’ll assume a spring that does not bend but only compresses or extends along a line connecting the ends. If <em>r</em><sub>21</sub> is the distance between the ends of the spring and <em>r<sub>e</sub></em> is the equilibrium length of the spring, the spring is in extension when <em>r</em><sub>21</sub> &gt; <em>r<sub>e</sub></em>, in compression when <em>r</em><sub>21</sub> &lt; <em>r<sub>e</sub></em>, and in equilibrium when <em>r</em><sub>21</sub> = <em>r<sub>e</sub></em>.</p>&#13;
<p class="indent">The size of the force exerted by a spring depends on how much the spring has been extended or compressed from its equilibrium length. A larger extension or compression produces a larger force. The force exerted by the spring depends on the difference <em>r</em><sub>21</sub> – <em>r<sub>e</sub></em>. A <em>linear spring</em> is one in <span epub:type="pagebreak" id="page_346"/>which the force is proportional to this difference. The constant of proportionality <em>k</em> is called the <em>spring constant</em>.</p>&#13;
<p class="indent">Let’s call <strong>r</strong><sub>21</sub> the displacement vector from object 1 at one end of the spring to object 2 at the other, as in <a href="ch19.xhtml#ch19fig1">Figure 19-1</a>. Then <em>r</em><sub>21</sub> = |<strong>r</strong><sub>21</sub>| is the distance from one end to the other, and <img class="inline" src="Images/e0346-01.jpg" alt="Image" width="125" height="21"/> is a unit vector from end 1 toward end 2. <a href="ch19.xhtml#ch19tab1">Table 19-1</a> shows the force on each end of the spring.</p>&#13;
<p class="tabcap" id="ch19tab1"><strong>Table 19-1:</strong> Forces on Each End of a Linear Spring</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"/></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Spring state</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Force at end 1</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Force at end 2</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>r</em><sub>21</sub> &gt; <em>r<sub>e</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Extension</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><img class="inline" src="Images/e0346-02.jpg" alt="Image" width="95" height="19"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><img class="inline" src="Images/e0346-03.jpg" alt="Image" width="104" height="22"/></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><em>r</em><sub>21</sub> = <em>r<sub>e</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Equilibrium</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac">0</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="tabac">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>r</em><sub>21</sub> &lt; <em>r<sub>e</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Compression</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><img class="inline" src="Images/e0346-04.jpg" alt="Image" width="95" height="18"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><img class="inline" src="Images/e0346-05.jpg" alt="Image" width="104" height="18"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The force <strong>F</strong><sub>21</sub> exerted on object 2 produced by the spring connected to object 1 is as follows:</p>&#13;
<div class="imagec"><img src="Images/346equ01.jpg" alt="Image" width="442" height="43"/></div>&#13;
<p class="indent">This equation holds whether the spring is in extension, compression, or equilibrium. If <strong>r</strong><sub>1</sub> is the position vector for object 1 and <strong>r</strong><sub>2</sub> is the position vector for object 2, then <strong>r</strong><sub>21</sub> = <strong>r</strong><sub>2</sub> – <strong>r</strong><sub>1</sub>, and we can write the force on object 2 as follows:</p>&#13;
<div class="imagec"><img src="Images/346equ02.jpg" alt="Image" width="486" height="47"/></div>&#13;
<p class="indent">Here is Haskell code for the two-body force of a linear spring with spring constant <span class="literal">k</span> and equilibrium length <span class="literal">re</span>:</p>&#13;
<pre>linearSpring :: R  -- spring constant&#13;
             -&gt; R  -- equilibrium length&#13;
             -&gt; TwoBodyForce&#13;
linearSpring k re st1 st2&#13;
    = let r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          r21 = r2 ^-^ r1&#13;
          r21mag = magnitude r21&#13;
      in (-k) *^ (r21mag - re) *^ r21 ^/ r21mag</pre>&#13;
<p class="indent">There may be times when we want to attach one end of a spring to a fixed wall or ceiling. In that case, the spring is better represented by a one-body force. This is a good opportunity to use the function <span class="literal">oneFromTwo</span> that we wrote earlier in this chapter to produce a one-body force from a two-body force. Given a spring constant, an equilibrium length, and a fixed position for one end of the spring, the function <span class="literal">fixedLinearSpring</span> produces a one-body force for the object attached to the other end of the spring.</p>&#13;
<pre>fixedLinearSpring :: R -&gt; R -&gt; Vec -&gt; OneBodyForce&#13;
fixedLinearSpring k re r1&#13;
    = oneFromTwo (defaultParticleState { posVec = r1 }) (linearSpring k re)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_347"/>The function <span class="literal">fixedLinearSpring</span> works by creating a fake particle state at the fixed end of the spring. The particle state is fake in that its only use is to supply a position; we do not intend to allow this particle state to evolve as we would for a real particle. When this fake particle state is given to the function <span class="literal">oneFromTwo</span> along with the two-body force <span class="literal">linearSpring k re</span>, we obtain a one-body force that describes the force the spring exerts on the movable mass.</p>&#13;
<h4 class="h4" id="ch19lev6">Central Force</h4>&#13;
<p class="noindent">The three two-body forces we have considered so far—universal gravity, a constant repulsive force, and a linear spring—are all examples of a <em>central force</em>, which is a force between two particles that depends only on the distance between them and acts along the line that joins them. A central force can be either attractive or repulsive. A general expression for the force on object 2 produced by a central force from object 1 is</p>&#13;
<div class="imagec"><img src="Images/347equ01.jpg" alt="Image" width="412" height="43"/></div>&#13;
<p class="noindent">or</p>&#13;
<div class="imagec"><img src="Images/347equ02.jpg" alt="Image" width="461" height="47"/></div>&#13;
<p class="noindent">if <strong>r</strong><sub>1</sub> is the position vector for object 1 and <strong>r</strong><sub>2</sub> is the position vector for object 2. Here is the central force in Haskell:</p>&#13;
<pre>centralForce :: (R -&gt; R) -&gt; TwoBodyForce&#13;
centralForce f st1 st2&#13;
    = let r1 = posVec st1&#13;
          r2 = posVec st2&#13;
          r21 = r2 ^-^ r1&#13;
          r21mag = magnitude r21&#13;
      in f r21mag *^ r21 ^/ r21mag</pre>&#13;
<p class="indent">We provide <span class="literal">centralForce</span> with a scalar function <span class="literal">f</span> that describes how the force depends on the distance between the two objects.</p>&#13;
<p class="indent">The linear spring force of the previous section can be alternatively defined using this <span class="literal">centralForce</span> function as follows:</p>&#13;
<pre>linearSpringCentral :: R  -- spring constant&#13;
                    -&gt; R  -- equilibrium length&#13;
                    -&gt; TwoBodyForce&#13;
linearSpringCentral k re = centralForce (\r -&gt; -k * (r - re))</pre>&#13;
<p class="indent">Here we send the scalar function</p>&#13;
<div class="equationc"><em>f</em>(<em>r</em>) = –<em>k</em>(<em>r</em> – <em>r<sub>e</sub></em>)</div>&#13;
<p class="noindent">to <span class="literal">centralForce</span>, where the negative sign indicates that the force is attractive when <em>r</em> &gt; <em>r<sub>e</sub></em>. Exercise 19.3 asks you to write universal gravity as a central force.</p>&#13;
<h4 class="h4" id="ch19lev7"><span epub:type="pagebreak" id="page_348"/>Elastic Billiard Interaction</h4>&#13;
<p class="noindent">In an elastic collision between two objects, the objects compress a bit and store energy, much like a spring, before bouncing apart. In an introductory physics course, collisions are typically treated as “black box” events, where we don’t get involved in the particular forces that act between the colliding objects but rather use conservation of momentum to figure out how the objects will move after the collision instead. Here, we’ll view the force between objects as a two-body force that is 0 when the objects are apart from one another and that acts as a spring when the objects come into contact.</p>&#13;
<p class="indent">The crucial thing to know is whether the objects are touching or not touching. We only keep track of the position of the center of each object in the state, so the question becomes whether the centers of the two objects are closer than some threshold distance between the centers that we’ll call <em>r<sub>e</sub></em>. If the distance between the objects is greater than <em>r<sub>e</sub></em>, there is no force. If the distance is less than <em>r<sub>e</sub></em>, we’ll model the force as a compressed linear spring with spring constant <em>k</em>. The following equation gives the force on object 2 produced by object 1:</p>&#13;
<div class="imagec"><img src="Images/348equ01.jpg" alt="Image" width="510" height="52"/></div>&#13;
<p class="indent">This force is like half of a linear spring. It behaves like a linear spring under compression, when the centers are closer than the threshold distance <em>r<sub>e</sub></em>, but there is no force when the spring would exhibit extension. Here is the Haskell code:</p>&#13;
<pre>billiardForce :: R  -- spring constant&#13;
              -&gt; R  -- threshold center separation&#13;
              -&gt; TwoBodyForce&#13;
billiardForce k re&#13;
    = centralForce $ \r -&gt; if r &gt;= re&#13;
                           then 0&#13;
                           else (-k * (r - re))</pre>&#13;
<p class="indent">When the distance between the particles is greater than or equal to the threshold separation, the particles feel no force. When the distance between the particles is less than the threshold separation, the objects are touching and compressing a bit, feeling a force of repulsion. We’ll use this two-body force to animate a collision in the next chapter.</p>&#13;
<h3 class="h3" id="ch19lev8">Internal and External Forces</h3>&#13;
<p class="noindent">When we have multiple interacting particles, the forces that act on any one particle can be classified into two sorts. On the one hand, there are the forces produced by other particles in the collection of particles we are paying attention to. These are the forces to which Newton’s third law applies. If we care about particles A and B, and A feels a force from B, then Newton’s <span epub:type="pagebreak" id="page_349"/>third law reminds us that somewhere in our calculation we need to account for the fact that B feels a force from A.</p>&#13;
<p class="indent">On the other hand, there are the forces produced by things outside of the collection of particles we are paying attention to. We may want Earth’s surface gravity as a force without having to include Earth as one of the particles we care about. We may want to include forces produced by electric or magnetic fields without including the sources of these fields in our calculation. For this second sort of force, Newton’s third law is irrelevant; it tells us about a force that acts on something we don’t care about and don’t need to account for in our calculation. The distinction between these two sorts of forces motivates the following definitions.</p>&#13;
<p class="indent">A <em>system of particles</em> is simply a choice of which particles to pay attention to. We decide which particles to include in our system, and these are the particles whose motion we calculate by applying Newton’s second law.</p>&#13;
<p class="indent">For a system of particles, it’s useful to distinguish between an <em>internal force</em> (a force produced by a particle in our system) and an <em>external force</em> (a force produced by something outside of our system). By making this distinction between forces, we will be able to write a state-update rule that automatically applies Newton’s third law for us. An external force does not require Newton’s third law; it’s treated the same as last chapter because we’re not concerned with the motion of the object creating the force. For an internal force, both particles are in our system, and we can treat them symmetrically, making sure that each particle experiences the appropriate force.</p>&#13;
<p class="indent">Let’s make a new data type for force that demands every force be either an external force or an internal force.</p>&#13;
<pre>data Force = ExternalForce Int OneBodyForce&#13;
           | InternalForce Int Int TwoBodyForce</pre>&#13;
<p class="indent">The <span class="literal">Int</span>s in this data type definition are particle numbers. We are going to number the particles in our system, starting with 0. A particular external force is specified by giving the particle number that experiences the force along with the one-body force that describes it. For example, the <span class="literal">Force</span></p>&#13;
<pre>ExternalForce 98 (fixedLinearSpring 1 0.5 (vec 100 0 0))</pre>&#13;
<p class="noindent">indicates that particle 98 experiences the force of a linear spring with spring constant 1 and equilibrium length 0.5, and whose other end is fixed at position 100<img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>.</p>&#13;
<p class="indent">A particular internal force is specified by giving numbers for the two particles that participate in the interaction, followed by the two-body force that describes the interaction. For example, the <span class="literal">Force</span></p>&#13;
<pre>InternalForce 0 1 universalGravity</pre>&#13;
<p class="noindent">indicates that particles 0 and 1 interact via universal gravity. The <span class="literal">Force</span></p>&#13;
<pre>InternalForce 1 0 universalGravity</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_350"/>means the same thing. To indicate that particles 0 and 1 interact by universal gravity, we include one, but not both, of these forces in the list of forces that describes the setting for our system of particles.</p>&#13;
<h3 class="h3" id="ch19lev9">The State of a Multi-Particle System</h3>&#13;
<p class="noindent">The state of a system of particles consists of the information contained in the states of each particle. A list of particle states is an appropriate type for the state of a system of multiple particles.</p>&#13;
<p class="indent">There are a few ways we could approach this. We could use the data type <span class="literal">[ParticleState]</span> to describe the state of a system of particles. We could also write a type synonym to give an alternate name to a list of single-particle states. However, we won’t follow either of these two paths because we already use a list of single-particle states to represent a solution to a one-particle mechanics problem. In this solution, each single-particle state describes the same particle at a different time. The state of a multi-particle system wants a list of particles for a different purpose; each single-particle state describes a different particle at the same time.</p>&#13;
<p class="indent">Since we do not want to confuse a list of single-particle states used as a solution to a one-particle mechanics problem with a list used to describe a multi-particle system, we create a new data type using the <span class="literal">data</span> keyword so that the compiler regards the two types as different. Different purposes suggest different types.</p>&#13;
<pre>data MultiParticleState&#13;
    = MPS { particleStates :: [ParticleState] } deriving Show</pre>&#13;
<p class="indent">We build a value with type <span class="literal">MultiParticleState</span> with the data constructor <span class="literal">MPS</span>, which is short for multi-particle state. We could have used <span class="literal">MultiParticleState</span> as the name of the data constructor; however, I chose <span class="literal">MPS</span> because it’s shorter and appears less awkward to use in code to me. Underneath the data constructor is a plain old list of single-particle states. The <span class="literal">data</span> constructor makes the type <span class="literal">MultiParticleState</span> distinct from the type <span class="literal">[ParticleState]</span>. We use record syntax to obtain the extraction function <span class="literal">particleStates</span> without having to explicitly define it.</p>&#13;
<p class="indent">Underneath the data constructor, the single-particle states reside in a list, meaning we can refer to the particles by number, starting with <span class="literal">0</span>. Each particle is labeled by a number with type <span class="literal">Int</span>.</p>&#13;
<p class="indent">We note in passing that using a list for the states of each particle is not the most efficient way to handle data. In this book, we are primarily concerned with the clarity, beauty, and simplicity of the code we write, and we are less concerned with its efficiency. A good rule in Haskell programming <span epub:type="pagebreak" id="page_351"/>is not to worry about efficiency until your code runs slower than you would like. At that point, it makes sense to ask what can be done to make it faster. In the old days, functional programming was saddled with a reputation for slowness. However, that is no longer true. Haskell, in particular, provides data structures such as arrays that can be more efficient than the list structure we are using. The list-based method we use works well for tens of particles, but it may be too slow for hundreds of particles. If you get to the point where you want to run simulations with hundreds or thousands of particles, I recommend looking into array types. For simplicity, we stick to the list data type in this book.</p>&#13;
<p class="indent">To do animation with the <span class="literal">Vis</span> module using the function <span class="literal">simulateVis</span> we wrote in <a href="ch16.xhtml">Chapter 16</a>, a data type that represents the state of something needs to be an instance of type class <span class="literal">HasTime</span>, which means that a state needs to have a time associated with it. Each single-particle state has a time; in fact, every single-particle state that makes up a multi-particle state has the same time. So, we’ll just take the time from particle number 0. Here is the instance declaration:</p>&#13;
<pre>instance HasTime MultiParticleState where&#13;
    timeOf (MPS sts) = time (sts !! 0)</pre>&#13;
<p class="indent">We use pattern matching on the input to define the function <span class="literal">timeOf</span>. By giving the data constructor <span class="literal">MPS</span> followed by a list, we have access to that list in the body of the function and can use the list element operator (<span class="literal">!!</span>).</p>&#13;
<p class="indent">In the next chapter, we’ll animate a system of two masses and two springs. The animation uses <span class="literal">simulateVis</span>, which uses <span class="literal">timeOf</span>. Since the state space for that animation is <span class="literal">MultiParticleState</span>, <span class="literal">simulateVis</span> needs the <span class="literal">timeOf</span> that goes with <span class="literal">MultiParticleState</span>, which is exactly what the instance declaration provides.</p>&#13;
<p class="indent">Recall that in <a href="ch16.xhtml">Chapter 16</a> we introduced the data type <span class="literal">DParticleState</span> to hold the time derivatives of the state variables in <span class="literal">ParticleState</span>. Here, in the many-particle setting, we do something similar and define a new data type <span class="literal">DMultiParticleState</span> to hold the time derivatives of the state variables in <span class="literal">MultiParticleState</span>. Here is the data type definition:</p>&#13;
<pre>data DMultiParticleState = DMPS [DParticleState] deriving Show</pre>&#13;
<p class="indent">You can see from this definition that we are just packaging a list of <span class="literal">DParticleState</span>s, analogous to the way we packaged a list of <span class="literal">ParticleState</span>s in the data type definition above for <span class="literal">MultiParticleState</span>.</p>&#13;
<p class="indent">With a new data type in hand to represent the state of a multi-particle system, let us turn to the question of how that state evolves in time—in other words, how the state gets updated.</p>&#13;
<h3 class="h3" id="ch19lev10"><span epub:type="pagebreak" id="page_352"/>State Update for Multiple Particles</h3>&#13;
<p class="noindent">For a system of multiple particles, <a href="ch19.xhtml#ch19fig2">Figure 19-2</a> gives an overview of the data representations and functions that transform among them, much as <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> did for a single particle.</p>&#13;
<div class="imagel" id="ch19fig2"><img src="Images/352fig01.jpg" alt="Image" width="552" height="581"/></div>&#13;
<p class="figcap"><em>Figure 19-2: Data representations and functions that transform among them</em></p>&#13;
<p class="indent">The four representations are forces, differential equation, state-update function, and evolver. In the next section, we’ll discuss Newton’s second law and the function <span class="literal">newtonSecondMPS</span> that implements it in the multi-particle setting. We’ll see how to use our numerical methods in this setting, and we’ll define the composite functions <span class="literal">updateMPS</span> and <span class="literal">statesMPS</span> that are shown in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>.</p>&#13;
<h4 class="h4" id="ch19lev11">Implementing Newton’s Second Law</h4>&#13;
<p class="noindent">For a system of interacting particles, both Newton’s second law and Newton’s third law are involved in producing a differential equation. <a href="ch19.xhtml#ch19fig3">Figure 19-3</a> shows a schematic diagram for a two-body mechanics problem.</p>&#13;
<div class="imagel" id="ch19fig3"><img src="Images/353fig01.jpg" alt="Image" width="652" height="758"/></div>&#13;
<p class="figcap"><em>Figure 19-3: Schematic representation of Newton’s second law and Newton’s third law working together in a two-body situation. The two bodies interact with each other, and each body has external forces acting on it as well.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_353"/>The function <strong>F</strong><sub>1e</sub>, shown in the upper left of <a href="ch19.xhtml#ch19fig3">Figure 19-3</a>, produces the net external force on particle 1. The external forces on particle 1 can depend on time, the position of particle 1, and the velocity of particle 1. These three quantities are shown as inputs to <strong>F</strong><sub>1e</sub>. We find the net external force on particle 1 by supplying the inputs to the function to form <strong>F</strong><sub>1e</sub>(<em>t</em>, <strong>r</strong><sub>1</sub> (<em>t</em>), <strong>v</strong><sub>1</sub> (<em>t</em>)). If there are multiple external forces acting on particle 1, they need to be added together (as vectors). The function <strong>F</strong><sub>1e</sub> needs to return this sum.</p>&#13;
<p class="indent">Moving down the diagram from <strong>F</strong><sub>1e</sub>, we find a summation that adds together the net external force and the net internal force to produce the net force on particle 1 that appears in Newton’s second law. We’ll talk about the net internal force shortly; for now let’s keep moving down the left column <span epub:type="pagebreak" id="page_354"/>of the diagram. Newton’s second law says that dividing the net force on particle 1 by the mass of particle 1 will give the acceleration of particle 1. Integrating the acceleration produces the velocity, and integrating the velocity produces the position. The position and velocity of particle 1 feed back as inputs to the net external force function <strong>F</strong><sub>1e</sub>.</p>&#13;
<p class="indent">The position and velocity of particle 1 also get combined with those of particle 2, governed by the right column of <a href="ch19.xhtml#ch19fig3">Figure 19-3</a>, to produce a relative position and a relative velocity that serve as inputs to <strong>F</strong><sub>21</sub>, the internal force of particle 1 on particle 2. If particle 1 exerts multiple forces on particle 2, perhaps a spring force and an electrical force, these must be added as vectors to form <strong>F</strong><sub>21</sub>(<strong>r</strong><sub>2</sub>(<em>t</em>) – <strong>r</strong><sub>1</sub>(<em>t</em>),<strong>v</strong><sub>2</sub>(<em>t</em>) – <strong>v</strong><sub>1</sub>(<em>t</em>)), the net internal force of particle 1 on particle 2. An internal force between two particles shouldn’t depend explicitly on time, and it should depend on the positions and velocities of the two particles only through their relative values. All of the two-body forces we introduced earlier in the chapter have this property.</p>&#13;
<p class="indent">Since <strong>F</strong><sub>21</sub>(<strong>r</strong><sub>2</sub>(<em>t</em>) – <strong>r</strong><sub>1</sub>(<em>t</em>),<strong>v</strong><sub>2</sub>(<em>t</em>) – <strong>v</strong><sub>1</sub>(<em>t</em>)) is the force on particle 2, it goes straight into the summation on the right to be added to the net external force on particle 2. By Newton’s third law, the force on particle 1 produced by particle 2 is equal and opposite to this, hence the multiplication by –1 to produce the net internal force on particle 1 before it gets added to the net external force on particle 1.</p>&#13;
<p class="indent">Time is produced by integrating the constant 1, as in our previous schematic diagrams. Time is an input to each of the net external force functions, but not to the net internal force function.</p>&#13;
<p class="indent">To summarize <a href="ch19.xhtml#ch19fig3">Figure 19-3</a>, the internal and external forces on each particle must be added together to form the net force on the particle, which, per Newton’s second law, gets divided by its mass to calculate the acceleration of the particle. Newton’s third law is carried out in the center column, where the force of interaction is calculated, sent unchanged to particle 2, and sent negated to particle 1. The internal forces express the interaction between the two particles, while the external forces represent interactions with things outside of the system. All of the feedback means that a set of coupled differential equations will be the mathematical expression of a multi-particle mechanics problem.</p>&#13;
<p class="indent">We can write Newton’s second law as a set of coupled differential equations.</p>&#13;
<div class="imagec"><img src="Images/354equ01.jpg" alt="Image" width="663" height="43"/></div>&#13;
<div class="imagec"><img src="Images/354equ02.jpg" alt="Image" width="696" height="43"/></div>&#13;
<div class="imagec"><img src="Images/354equ03.jpg" alt="Image" width="697" height="63"/></div>&#13;
<div class="imagec"><img src="Images/354equ04.jpg" alt="Image" width="696" height="43"/></div>&#13;
<div class="imagec"><img src="Images/354equ05.jpg" alt="Image" width="697" height="57"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_355"/>The time derivative of time is 1, as in single-particle mechanics. The time derivative of position is velocity, and this holds for each particle. The time derivative of velocity is acceleration, which is found by dividing net force by mass for each particle. The net force on a particle is the sum of the net external force and the net internal force. The function <strong>F</strong><sub>2<em>e</em></sub> produces the net external force on particle 2 when given the time, the position of particle 2, and the velocity of particle 2. The function <strong>F</strong><sub><em>mn</em></sub> produces the internal force of particle <em>n</em> on particle <em>m</em> when given the relative position and relative velocity of particles <em>m</em> and <em>n</em>. The net internal force on particle 2, for example, is</p>&#13;
<div class="imagec"><img src="Images/355fig01.jpg" alt="Image" width="284" height="44"/></div>&#13;
<p class="noindent">where we add the internal forces produced by all of the other particles in the system. We have only given equations for the first two particles in a system, but there is a similar pair of equations for every particle in the system. Hopefully the pattern is clear.</p>&#13;
<p class="indent">In <a href="ch16.xhtml">Chapter 16</a>, which was concerned with the motion of a single particle, we used the function <span class="literal">newtonSecondPS</span> to transform a list of forces into a differential equation. We would now like an analogous function for multiple particles. We would like a function with the following type signature:</p>&#13;
<pre>newtonSecondMPS :: [Force]&#13;
                -&gt; MultiParticleState -&gt; DMultiParticleState  -- a diff eqn</pre>&#13;
<p class="indent">The name of this function has <em>MPS</em> on the end to remind us that it works with the <span class="literal">MultiParticleState</span> state space.</p>&#13;
<p class="indent">Our plan is to apply Newton’s second law to each particle in the system. For each particle, we identify all of the external and internal forces that act on it, and we transform each of these into a one-body force. Once we have the list of one-body forces that act on a particle, we can use the function <span class="literal">newtonSecondPS</span> to calculate the time derivatives of all the state variables for that particle. When we have the time derivatives of each state variable for each particle, we’ll bundle it all up and ask <span class="literal">newtonSecondMPS</span> to return that bundle. Here’s the code:</p>&#13;
<pre>newtonSecondMPS fs mpst@(MPS sts)&#13;
    = let deriv (n,st) = newtonSecondPS (forcesOn n mpst fs) st&#13;
      in DMPS $ map deriv (zip [0..] sts)</pre>&#13;
<p class="indent">The first line in the code names the incoming list of forces <span class="literal">fs</span> and gives <em>two</em> names to the incoming multi-particle state. When placed between two names on the left side of a definition, the <span class="literal">@</span> (“at symbol”) allows the code writer to give a simple identifier to the incoming value <em>and</em> simultaneously do pattern matching on the input. The simple identifier <span class="literal">mpst</span> stands for the incoming multi-particle state with type <span class="literal">MultiParticleState</span>. Since it appears underneath the data constructor <span class="literal">MPS</span>, the name <span class="literal">sts</span> stands for the list of single-particle states (type <span class="literal">[ParticleState]</span>). We want to use both <span class="literal">mpst</span> and <span class="literal">sts</span> in our definition.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_356"/>In the second line of code, we define a local function <span class="literal">deriv</span> to calculate the time derivatives of single-particle state variables. Its argument <span class="literal">(n,st)</span> is a pair of particle number and single-particle state. Its return value is a collection of derivatives (type <span class="literal">DParticleState</span>). This local function uses <span class="literal">newtonSecondPS</span> to calculate the derivatives. The expression <span class="literal">forcesOn n mpst fs</span> is the list of one-body forces that act on particle number <span class="literal">n</span> when the multi-particle state is <span class="literal">mpst</span> and the list of all system forces (external and internal) is <span class="literal">fs</span>. We will write the function <span class="literal">forcesOn</span> next.</p>&#13;
<p class="indent">In the final line, we zip together particle numbers with associated particle states to make a list of number-state pairs. We then map the local function <span class="literal">deriv</span> onto that list, producing a list of time derivatives of single-particle states (type <span class="literal">[DParticleState]</span>). Finally, we apply the <span class="literal">DMPS</span> data constructor to form the time multi-particle state derivative (type <span class="literal">DMultiParticleState</span>).</p>&#13;
<p class="indent">From a physics standpoint, all we are doing is applying Newton’s second law to each particle in the system. The apparent complexity comes partly from our need to number the particles and partly from our desire to use clear types to represent the things we care about (such as internal and external forces). The clear types benefit us in two ways. First, types represent the important ideas in physics and help us think about them. Second, types help the compiler find our mistakes. By doing some of the heavy lifting in functions like this, we will end up with a collection of powerful functions that let us solve multi-particle problems with relative ease.</p>&#13;
<p class="indent">How do we find the net force on each particle? In other words, how do we write the function <span class="literal">forcesOn</span> we used earlier? What type should <span class="literal">forcesOn</span> have? The function <span class="literal">forcesOn</span> needs to take a particle number, a multi-particle state, and a list of forces as inputs, and it needs to produce a list of one-body forces as output. Here is the type signature and the definition for <span class="literal">forcesOn</span>:</p>&#13;
<pre>forcesOn :: Int -&gt; MultiParticleState -&gt; [Force] -&gt; [OneBodyForce]&#13;
forcesOn n mpst = map (forceOn n mpst)</pre>&#13;
<p class="indent">The incoming particle number is named <span class="literal">n</span>, and the incoming multi-particle state is named <span class="literal">mpst</span>. We don’t bother to name the list of forces, which means that <span class="literal">forcesOn n mpst</span> has type <span class="literal">[Force] -&gt; [OneBodyForce]</span>. You can see from the definition that <span class="literal">forcesOn</span> passes most of the work on to another as-yet-undefined function called <span class="literal">forceOn</span> (note the dropped <em>s</em>). The idea is that the function <span class="literal">forceOn n mpst</span> has type <span class="literal">Force -&gt; OneBodyForce</span> and transforms an external or internal force in the list of system forces into a one-body force acting on particle <span class="literal">n</span>. If we can transform a single force, we can use <span class="literal">map</span> to transform a list of forces.</p>&#13;
<p class="indent">The function <span class="literal">forceOn</span> needs to deal with both external and internal forces. External forces are easier. We just have to check whether the external force acts on particle <span class="literal">n</span>. If so, we return the one-body force held inside the external force. If not, we make up a one-body force that is zero.</p>&#13;
<p class="indent">For an internal force, we need to check whether either of the particle numbers specified in the internal force are particle number <span class="literal">n</span> that we care about. If so, we use the <span class="literal">oneFromTwo</span> function written earlier in the chapter that <span epub:type="pagebreak" id="page_357"/>constructs a one-body force from a two-body force. If not, we again make up a zero force. Here is the code for <span class="literal">forceOn</span>:</p>&#13;
<pre>forceOn :: Int -&gt; MultiParticleState -&gt; Force -&gt; OneBodyForce&#13;
forceOn n _         (ExternalForce n0 fOneBody)&#13;
    | n == n0    = fOneBody&#13;
    | otherwise  = const zeroV&#13;
forceOn n (MPS sts) (InternalForce n0 n1 fTwoBody)&#13;
    | n == n0    = oneFromTwo (sts !! n1) fTwoBody  -- n1 acts on n0&#13;
    | n == n1    = oneFromTwo (sts !! n0) fTwoBody  -- n0 acts on n1&#13;
    | otherwise  = const zeroV</pre>&#13;
<p class="indent">The function uses pattern matching on the <span class="literal">Force</span> input, so there is one part of the definition for each of the two data constructors of <span class="literal">Force</span> (that is, one part for an external force and a second part for an internal force). This definition uses a Haskell feature called <em>guards</em>. A guard is the vertical bar on the left of several of the lines of code. The guard is a convenient alternative to an <span class="literal">if-then-else</span> construction, especially when there are more than two possibilities, as in the part of the definition that works with internal forces.</p>&#13;
<p class="indent">Each line in the guard construction consists of four items: a vertical bar, a Boolean condition, an equal sign, and a result. At each vertical bar, the condition is checked. If the condition is true, the corresponding result is returned; if the condition is false, we go to the next vertical bar and repeat the process. It is good practice for the condition in the last guard line to be <span class="literal">otherwise</span>, which is just another name for <span class="literal">True</span>. By using <span class="literal">otherwise</span>, we are guaranteed that one of the guard conditions will hold and consequently that one of the results will be returned.</p>&#13;
<p class="indent">The first part of the definition for <span class="literal">forceOn</span> is for an external force. We check whether particle number <span class="literal">n</span>, the particle we are currently interested in, matches particle number <span class="literal">n0</span>, the particle on which the current external force acts. If they match, we return the one-body force <span class="literal">fOneBody</span> contained in the external force. If they don’t match, we return the one-body force <span class="literal">const zeroV</span>, a one-body force that ignores the state of the particle and simply returns the zero vector.</p>&#13;
<p class="indent">The second part of the definition for <span class="literal">forceOn</span> is for an internal force. An internal force involves two particles; if the particle we care about is either of these, the function needs to return the appropriate one-body force. We first check whether particle number <span class="literal">n</span>, the particle we are currently interested in, matches particle number <span class="literal">n0</span>, the first of the two particles involved in the internal force. If <span class="literal">n</span> equals <span class="literal">n0</span>, we are interested in the force that particle <span class="literal">n1</span> exerts on particle <span class="literal">n0</span>. We provide <span class="literal">oneFromTwo</span>, the function we wrote earlier in the chapter to convert a two-body force to a one-body force, with <span epub:type="pagebreak" id="page_358"/>the single-particle state for <span class="literal">n1</span>, called <span class="literal">sts !! n1</span>, and the two-body force contained in the internal force, called <span class="literal">fTwoBody</span>. The function <span class="literal">oneFromTwo</span> returns the one-body force that acts on particle <span class="literal">n</span>.</p>&#13;
<p class="indent">If <span class="literal">n</span> does not equal <span class="literal">n0</span>, we check whether <span class="literal">n</span> equals <span class="literal">n1</span>, the other particle involved in the internal force under consideration. If so, we are interested in the force that particle <span class="literal">n0</span> exerts on particle <span class="literal">n1</span>. We provide <span class="literal">oneFromTwo</span> with the single-particle state for <span class="literal">n0</span>, called <span class="literal">sts !! n0</span>, and with the two-body force contained in the internal force. The function <span class="literal">oneFromTwo</span> again returns the one-body force that acts on particle <span class="literal">n</span>. Finally, if particle <span class="literal">n</span> matches neither <span class="literal">n0</span> nor <span class="literal">n1</span>, we return a zero force.</p>&#13;
<p class="indent">The part of the definition of <span class="literal">forceOn</span> that deals with an internal force is how we apply Newton’s third law. This is the part that guarantees the forces will be equal and opposite because they come from the same internal force. For each of the two particles involved, we use the same two-body force to produce the one-body force that acts on each particle; only the single-particle states are interchanged. Since a two-body force has the property that particle interchange negates the force, Newton’s third law is automatically applied. We can’t make the mistake of remembering that <span class="literal">n1</span> exerts a force on <span class="literal">n0</span> but forgetting that <span class="literal">n0</span> exerts a force on <span class="literal">n1</span>. Our language of internal forces and our code to deal with them ensure that Newton’s third law holds without further attention from the code writer. In particular, each time we investigate a new multi-particle system, all we give is a list of external and internal forces. We don’t have to ensure that the force <span class="literal">n1</span> exerts on <span class="literal">n0</span> is equal and opposite to the force <span class="literal">n0</span> exerts on <span class="literal">n1</span>. Haskell deals with this automatically.</p>&#13;
<h4 class="h4" id="ch19lev12">Numerical Methods for Multiple Particles</h4>&#13;
<p class="noindent">Recall that the Euler and fourth-order Runge-Kutta methods are general methods for solving any differential equation. At the end of <a href="ch15.xhtml">Chapter 15</a>, we wrote functions <span class="literal">euler</span> and <span class="literal">rungeKutta4</span> that work with any state space <span class="literal">s</span> that is an instance of type class <span class="literal">RealVectorSpace</span>. To make these two functions usable with the <span class="literal">MultiParticleState</span> state space, we need to write two instance declarations. Here they are:</p>&#13;
<pre>instance RealVectorSpace DMultiParticleState where&#13;
    DMPS dsts1 +++ DMPS dsts2 = DMPS $ zipWith (+++) dsts1 dsts2&#13;
    scale w (DMPS dsts) = DMPS $ map (scale w) dsts</pre>&#13;
<p class="indent">The content of this instance declaration is that the sum of two multi-particle states is just the particle-wise sum.</p>&#13;
<pre>instance Diff MultiParticleState DMultiParticleState where&#13;
    shift dt (DMPS dsts) (MPS sts) = MPS $ zipWith (shift dt) dsts sts</pre>&#13;
<p class="indent">This instance declaration says that “shifting” a multi-particle state by a state derivative is just shifting each single-particle state by the associated single-particle state derivative.</p>&#13;
<p class="indent">The Euler-Cromer method is not a general method for any differential equation, so we need to write an explicit numerical method for Euler-Cromer as it applies to the <span class="literal">MultiParticleState</span> data type. Here it is:</p>&#13;
<pre>eulerCromerMPS :: TimeStep        -- dt for stepping&#13;
               -&gt; NumericalMethod MultiParticleState DMultiParticleState&#13;
eulerCromerMPS dt deriv mpst0&#13;
    = let mpst1 = euler dt deriv mpst0<span epub:type="pagebreak" id="page_359"/>&#13;
          sts0 = particleStates mpst0&#13;
          sts1 = particleStates mpst1&#13;
          -- now update positions&#13;
          in MPS $ [ st1 { posVec = posVec st0 ^+^ velocity st1 ^* dt }&#13;
                         | (st0,st1) &lt;- zip sts0 sts1 ]</pre>&#13;
<p class="indent">We choose to calculate the Euler-Cromer derivatives by first taking an Euler step, which is easy to do and correctly updates the mass, charge, time, and velocity for each particle. However, the position needs to be fixed because it needs to be based on the updated velocity. The local variable <span class="literal">mpst0</span> stands for the incoming multi-particle state, while <span class="literal">mpst1</span> stands for the Euler-updated multi-particle state. The variables <span class="literal">sts0</span> and <span class="literal">sts1</span> are the lists of single-particle states underneath the <span class="literal">MPS</span> data constructor for the incoming and Euler-updated multi-particle states.</p>&#13;
<p class="indent">To form the Euler-Cromer-updated multi-particle state, we use a list comprehension to go through all the particles and apply the Euler-Cromer update Equation 15.10, which updates the incoming position with the Euler-updated velocity.</p>&#13;
<h4 class="h4" id="ch19lev13">Composite Functions</h4>&#13;
<p class="noindent">As in the single-particle situation, it’s convenient to have composite functions that take two or three steps in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>. The function <span class="literal">updateMPS</span> is the composition of Newton’s second law with a numerical method and is useful for animation. You can see from its definition that it’s just this composition:</p>&#13;
<pre>updateMPS :: NumericalMethod MultiParticleState DMultiParticleState&#13;
          -&gt; [Force]&#13;
          -&gt; MultiParticleState -&gt; MultiParticleState&#13;
updateMPS method = method . newtonSecondMPS</pre>&#13;
<p class="indent">The function <span class="literal">solver</span> in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a> also takes two steps in data representations, solving a differential equation by producing an evolver that can then generate a list of states from an initial state. We wrote <span class="literal">solver</span> in <a href="ch15.xhtml">Chapter 15</a>, and that code works just fine in the multi-particle setting.</p>&#13;
<p class="indent">The function <span class="literal">statesMPS</span> takes all three steps in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>, transforming a list of forces into an evolver. Its definition is what you would expect: a composition of Newton’s second law, a numerical method, and iteration.</p>&#13;
<pre>statesMPS :: NumericalMethod MultiParticleState DMultiParticleState&#13;
          -&gt; [Force]&#13;
          -&gt; MultiParticleState -&gt; [MultiParticleState]&#13;
statesMPS method = iterate . method . newtonSecondMPS</pre>&#13;
<h3 class="h3" id="ch19lev14">Summary</h3>&#13;
<p class="noindent">In this chapter, we applied Newtonian mechanics to multiple interacting objects moving in three dimensions. Newton’s third law governs the interaction <span epub:type="pagebreak" id="page_360"/>between particles. A two-body force is a force that depends on the states of two particles. We classify the forces that act on particles in our system into internal forces, which are produced by other particles in our system, and external forces, which are produced by something outside of our system. The state of a system of particles is described by giving the single-particle states for each of the particles in the system. Our <span class="literal">MultiParticleState</span> data type does exactly that. Our state-update procedure is still based on Newton’s second law, but now it automatically applies Newton’s third law to all internal forces.</p>&#13;
<p class="indent">As in the single-particle situation, solving a mechanics problem is still a process of transforming information through a sequence of four representations. For the multi-particle case, we start with a list of internal and external forces, produce a differential equation, produce a state-update function, and finally produce a list of multi-particle states.</p>&#13;
<p class="indent">The process of producing the differential equation from the forces has evolved over the course of <a href="part02.xhtml">Part II</a> of this book. Newton’s second law is always present, but the state has contained more information as we moved from one dimension to three dimensions to multiple particles. <a href="ch19.xhtml#ch19tab2">Table 19-2</a> shows the functions we have used to carry out Newton’s second law by producing a differential equation. The function <span class="literal">newtonSecondV</span> is for one particle in one dimension when the forces depend only on velocity. The function <span class="literal">newtonSecondTV</span> is for one particle in one dimension when the forces depend only on time and velocity. The function <span class="literal">newtonSecond1D</span> is for one particle in one dimension when the forces could depend on any combination of time, position, or velocity. The function <span class="literal">newtonSecondPS</span> is for one particle in three dimensions when the forces could depend on time, position, or velocity. Finally, the function <span class="literal">newtonSecondMPS</span> is for multiple particles in three dimensions where the forces could depend on time, position, or velocity.</p>&#13;
<p class="tabcap" id="ch19tab2"><strong>Table 19-2:</strong> Functions for Newton’s Second Law</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:75%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">newtonSecondV</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Mass -&gt;</span></p>&#13;
<p class="taba"><span class="literal">[Velocity -&gt; Force] -&gt; Velocity -&gt; R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">newtonSecondTV</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Mass -&gt;</span></p>&#13;
<p class="taba"><span class="literal">[(Time, Velocity) -&gt; Force] -&gt; (Time, Velocity) -&gt; (R, R)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">newtonSecond1D</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Mass -&gt;</span></p>&#13;
<p class="taba"><span class="literal">[State1D -&gt; Force] -&gt; State1D -&gt; (R, R, R)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">newtonSecondPS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">[OneBodyForce] -&gt; ParticleState -&gt; DParticleState</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">newtonSecondMPS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">[Force] -&gt; MultiParticleState -&gt; DMultiParticleState</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We have used the type <span class="literal">Force</span> in two different ways over the course of <a href="part02.xhtml">Part II</a>. In a one-dimensional setting, <span class="literal">Force</span> is simply a type synonym for a real number. In the three-dimensional, multi-particle setting of this chapter, the definition of <span class="literal">Force</span> is much more complex, describing a data type that could be an internal force or an external force and including the dependence of force on state. We have come a long way. In the next chapter, we’ll apply these ideas to specific examples of interacting particles and animate our results.</p>&#13;
<h3 class="h3" id="ch19lev15"><span epub:type="pagebreak" id="page_361"/>Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 19.1.</strong> Write a function <span class="literal">speed</span></p>&#13;
<pre>speed :: ParticleState -&gt; R&#13;
speed st = undefined st</pre>&#13;
<p class="noindentts">that returns the speed of a particle from its state.</p>&#13;
<p class="noindentts"><strong>Exercise 19.2.</strong> We could use pattern matching on the input rather than extraction functions to write the two-body force for universal gravity. The resulting definition has the benefit of being a bit shorter. Complete the following definition:</p>&#13;
<pre>universalGravity' :: TwoBodyForce&#13;
universalGravity' (ParticleState m1 _ _ r1 _) (ParticleState m2 _ _ r2 _)&#13;
    = undefined m1 r1 m2 r2</pre>&#13;
<p class="noindentts"><strong>Exercise 19.3.</strong> Universal gravity is a central force. Use the function <span class="literal">centralForce</span> to write the function</p>&#13;
<pre>universalGravityCentral :: TwoBodyForce&#13;
universalGravityCentral = undefined</pre>&#13;
<p class="noindentts">that expresses the same two-body force as <span class="literal">universalGravity</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 19.4.</strong> Our constant repulsive force is a central force. Rewrite the constant repulsive force using <span class="literal">centralForce</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 19.5.</strong> No real spring is completely linear across its entire range. In Exercise 15.10, we introduced the Lennard-Jones spring as an example of a nonlinear spring.</p>&#13;
<p class="indent">The force on end 2 of the spring is given by the following expression, in which <em>r<sub>e</sub></em> is the equilibrium length and <em>D<sub>e</sub></em> is the dissociation energy (that is, the energy required to extend the spring so that the ends are very far apart):</p>&#13;
<div class="imagec"><img src="Images/361equ01.jpg" alt="Image" width="352" height="63"/></div>&#13;
<p class="indent">If <em>r</em><sub>21</sub> &lt; <em>r<sub>e</sub></em>, the force on particle 2 will be in the direction of <strong>r</strong><sub>21</sub>, which is repulsive. If <em>r</em><sub>21</sub> &gt; <em>r<sub>e</sub></em>, the force on particle 2 will be in the direction of –<strong>r</strong><sub>21</sub>, which is attractive.</p>&#13;
<p class="indent">Write the function <span class="literal">lennardJones</span>, which takes a dissociation energy and an equilibrium length and returns a two-body force for the Lennard-Jones spring.</p>&#13;
<pre>lennardJones :: R  -- dissociation energy&#13;
             -&gt; R  -- equilibrium length&#13;
             -&gt; TwoBodyForce&#13;
lennardJones de re = centralForce $ \r -&gt; undefined de re r</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_362"/><strong>Exercise 19.6.</strong> Write a function <span class="literal">systemKE</span></p>&#13;
<pre>systemKE :: MultiParticleState -&gt; R&#13;
systemKE mpst = undefined mpst</pre>&#13;
<p class="noindentts">that returns the kinetic energy of a system of particles by adding up the kinetic energy of each particle.</p>&#13;
<p class="noindentts"><strong>Exercise 19.7.</strong> Each wire in a schematic diagram can be labeled with a type. Label each wire in <a href="ch19.xhtml#ch19fig3">Figure 19-3</a> with a type.</p>&#13;
<p class="noindentts"><strong>Exercise 19.8.</strong> An alternative way to write the function <span class="literal">forcesOn</span> is to form the list of one-body forces by appending a list of one-body forces that come from external forces to a list of one-body forces that come from internal forces. This method has the advantage of not requiring us to make up any fake zero forces and not needing the function <span class="literal">forceOn</span>.</p>&#13;
<pre>forcesOn' :: Int -&gt; MultiParticleState -&gt; [Force] -&gt; [OneBodyForce]&#13;
forcesOn' n mpst fs = externalForcesOn n fs ++ internalForcesOn n mpst fs&#13;
&#13;
externalForcesOn :: Int -&gt; [Force] -&gt; [OneBodyForce]&#13;
externalForcesOn n fs = undefined n fs&#13;
&#13;
internalForcesOn :: Int -&gt; MultiParticleState -&gt; [Force] -&gt; [OneBodyForce]&#13;
internalForcesOn n (MPS sts) fs&#13;
    = [oneFromTwo (sts !! n1) f | InternalForce n0 n1 f &lt;- fs, n == n0] ++&#13;
      [oneFromTwo (sts !! n0) f | InternalForce n0 n1 f &lt;- fs, n == n1]</pre>&#13;
<p class="indent">In defining the function <span class="literal">internalForcesOn</span>, we use pattern matching inside a list comprehension. We exclude any force that does not match the pattern. Following the model of <span class="literal">internalForcesOn</span>, write the function <span class="literal">externalForcesOn</span>.</p>&#13;
</div></body></html>