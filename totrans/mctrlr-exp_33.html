<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app08"><span epub:type="pagebreak" id="page_393"/><strong>H  Unsorted Attacks</strong></h2>&#13;
<h3 class="h3" id="app08_1"><strong>H.1 PIC16C84 PicBuster</strong></h3>&#13;
<p class="noindent">The third chapter of McCormac (1996) describes a few firmware extraction exploits from the early days of TV piracy. Of particular interest is a trick against the PIC16C84, the very first PIC to include electrically erasable EEPROM memory rather than OTP ROM or UV erasable EPROM. Like the PICs we saw in <a href="ch19.xhtml#ch19">Chapter 19</a>, a protection fuse is implemented with the same floating gate transistor as the EEPROM bits.</p>&#13;
<p class="indent">The trick involves the difference between the supply voltage VDD and the programming voltage on the !MCLR pin. In normal operation, VDD should be less than 7.5V and !MCLR should be less than 14V, relative to ground on VSS. This technique does not work against earlier chips, which lacked an electrical erase feature.</p>&#13;
<p class="indent">To exploit the PIC16C84, the chip is electrically mass erased at the wrong voltage. The VDD pin is held at 13.5V, just 0.5V less than VPP. VDD is then dropped to the standard 5V and switched off for ten to twenty seconds before being powered back on, allowing data to be read.</p>&#13;
<h3 class="h3" id="app08_2"><span epub:type="pagebreak" id="page_394"/><strong>H.2 PIC Checksums</strong></h3>&#13;
<p class="noindent">PIC microcontrollers implement a checksum that leaks information from locked chips, and in some cases you can clear—but not set—bits by performing a second programming. Kaljević (1997) documents the checksum algorithm and a technique for zeroing coefficients of that checksum to reveal specific bits of the source program.</p>&#13;
<p class="indent">On 14-bit models like the PIC16, Kaljević begins by the checksum algorithm, <img class="inline" src="../images/f0394-01.jpg" alt="image" width="80" height="20"/> where <em>a</em> is the higher seven bits and <em>b</em> the lower seven bits of a 14-bit instruction word. <img class="inline" src="../images/f0394-02.jpg" alt="image" width="15" height="20"/> is the XNOR operator, ∽ is inversion, and ⊕ is the XOR operator. <em>s</em> is freely readable from the chip over the normal ICSP protocol, and the game is to reveal the unknown bits in <em>a</em> and <em>b</em>.</p>&#13;
<p class="indent">Knowing <em>s</em>, he points out that overwriting the word with <span class="literal">0b11-111110000000</span> to zero <em>b</em> will give us <img class="inline" src="../images/f0394-03.jpg" alt="image" width="150" height="24"/>, or just the inverse of <em>a</em>. It follows that <em>s</em> = <em>ã</em> ⊕ b = <em>s</em><sub>1</sub> ⊕ <em>b</em>.</p>&#13;
<p class="indent">Then we can declare that <em>b</em> = (<em>s</em> ⊕ <em>s</em><sub>1</sub>) &amp; <span class="literal">0x7f</span> and also that <img class="inline" src="../images/f0394-03a.jpg" alt="image" width="70" height="21"/> &amp; <span class="literal">0x7f</span>. The fully reconstructed word from <em>s</em> and <em>s</em><sub>1</sub> is easily computed for 14-bit PICs such as the PIC16C61, 62, 64, 65, 71, 73, 74, and 84.</p>&#13;
<p class="center"><img class="inline" src="../images/f0394-03b.jpg" alt="image" width="440" height="28"/></p>&#13;
<p class="indent">For 12-bit parallel programmed chips in the PIC12 series, the checksum algorithm is different. Here, <em>s</em> = <em>a</em> ⊕ <em>b</em> ⊕ <em>c</em> where <em>a</em> is the upper nybble, <em>b</em> the middle nybble, and <em>c</em> the lower nybble of the instruction word.</p>&#13;
<p class="indent">Instead of one write, as in the 14-bit chips, two writes are performed. After the first write of <span class="literal">0x0ff0</span> zeroes <em>c</em>, we see <em>s</em><sub>1</sub> = <em>a</em> ⊕ <em>b</em>. We can then make a second write of <span class="literal">0x0f00</span> to zero <em>b</em>, leaving <em>s</em><sub>2</sub> = <em>a</em>. Tying it all together, for twelve bit chips with observations of <em>s</em>, <em>s</em><sub>1</sub> and <em>s</em><sub>2</sub>, our original instruction word is revealed <span epub:type="pagebreak" id="page_395"/>with <em>a</em> = <em>s</em><sub>2</sub>, <em>b</em> = <em>s</em><sub>2</sub> ⊕ <em>s</em><sub>1</sub>, and <em>c</em> = <em>s</em><sub>1</sub> ⊕ <em>s</em>.</p>&#13;
<p class="indentt"><em>w</em> = (<em>s</em><sub>2</sub> &amp; <span class="literal">0xf00</span>) + ((<em>s</em><sub>2</sub> ⊕ <em>s</em><sub>1</sub>) &amp; <span class="literal">0xf0</span>) + ((<em>s</em><sub>1</sub> ⊕ <em>s</em>) &amp; <span class="literal">0xf</span>)</p>&#13;
<p class="indentt">As for performing the writes, the paper becomes a little hard to follow. On the PIC16C71 and 61 models, the first 64 words of memory can simply be overwritten. <em>b</em> is zeroed and the algorithm for recovery gives those words with no ambiguity, but the rest of memory cannot be written so easily.</p>&#13;
<p class="indent">To program an already-locked chip in order to clear bits, he recommends over-volting the chip, then if that fails, overheating it, and if even that is not enough, also giving it a limited exposure to ultraviolet light. The voltage trick—perhaps related to the one in <a href="app08.xhtml#app08_1">Chapter H.1</a>—is to power the chip at between six and nine volts while strictly limiting current to 100mA. Failing that, he suggests holding the temperature at 110 <sup>°</sup>C, being careful never to go above 140 <sup>°</sup>C.</p>&#13;
<p class="indent">If that is insufficient, he proposes exposing the die and calibrating the UV light power such that it takes ten minutes to erase a PIC. Then, at 110 <sup>°</sup>C, running thirty second exposures until the protection bit becomes set, allowing writes. <span class="literal">0x3f80</span> is then written to every word of memory, and the chip slowly cooled down to −20 <sup>°</sup>C. At this point, the protection bit will fall back to zero. Writes will no longer be allowed, but the cleared bits from the writes will also be zero. <em>s</em><sub>1</sub> can then be read out of the locked chip.</p>&#13;
<p class="indent">One further trick is described only in x86 assembly code to write <span class="literal">0b11111111000000</span>, which sets <em>b</em> to either <span class="literal">0x40</span> or <span class="literal">0x00</span>. This leaves a puzzle in decoding, and some helpful notes are given as to which of two possible instruction words would be the right guess.</p>&#13;
<h3 class="h3" id="app08_3"><span epub:type="pagebreak" id="page_396"/><strong>H.3 ESP32 TOCTOU for XIP</strong></h3>&#13;
<p class="noindent">The ESP32 series from Espressif supports an execute-in-place (XiP) mode, in which instructions are fetched directly from SPI flash without first being copied into internal SRAM. This allows more RAM to be used by the application, at the cost of a slower execution speed.</p>&#13;
<p class="indent">Code is validated and a signature checked before execution, but Magesh (2023) describes a time-of-check to time-of-use (TOCTOU) attack against the signature validation by swapping between two SPI flash chips at runtime. This allows the signed code to be successfully measured before the unsigned code is executed.</p>&#13;
<p class="indent">Magesh notes that this trick does not work when flash encryption (AES XTS) is enabled, but he expects that an attacker might still exploit an encrypted image by randomizing a single page until a needed behavior is found, keeping all other pages intact.</p>&#13;
<h3 class="h3" id="app08_4"><strong>H.4 DS5002 Chosen Ciphertext</strong></h3>&#13;
<p class="noindent">The DS5002 from Dallas Semiconductor is an early and creative attempt at code readout protection. Code is held encrypted in external memory, with the key held internally in battery backed SRAM. This creates an awkward situation for arcade game repairs, as the batteries in existing devices will eventually die. Without an exploit, the code needed to run the game will die with it.</p>&#13;
<p class="indent">This chip’s instruction set is 8051. Encryption occurs one byte at a time, independent of all other bytes but unique to that address. The transformation is the same for both opcodes and parameters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_397"/>In addition to encryption, the DS5002 also performs dummy reads during cycles when the memory bus might otherwise be idle. The values fetched from these addresses are not used for anything; they only exist to confuse us.</p>&#13;
<p class="indent">The DS5002 is also available as a module in sealed epoxy with a battery back-up. <a href="app08.xhtml#chHfig1">Figures H.1</a> and <a href="app08.xhtml#chHfig2">H.2</a> show this module in surface microscopy and X-ray.</p>&#13;
<p class="indent">Kuhn (1996) and Kuhn (1998) presented a cryptographic attack against the chip, by first backing up a copy of the external SRAM and then feeding guesses into the CPU, watching the address change in response.</p>&#13;
<p class="indent">For example, you might make a guess that a particular instruction is a branch. Because the addresses are scrambled, you can’t know that your guess is right just from the next address fetched. But if you change a parameter byte, almost every value will branch the addresses into a different direction.</p>&#13;
<p class="indent">The point of the attack is to take that little piece of information, then use it to wedge apart many bytes of chosen ciphertext with known content, allowing us to execute arbitrary code.</p>&#13;
<p class="indent">You should also understand that bytes are encrypted individually and that they don’t impact later bytes. We don’t quite know how a byte will be scrambled, but for any specific address we can build up a table of bytes. The table is a unique mapping of a cipher byte to a clear byte, and the table does not change when the preceding byte in memory changes. As you’ll soon see, we don’t much care about the address that holds each byte. Instead, we care about forcing those bytes to known values and building lookup tables that let us choose the right ciphertext for specific plaintext.</p>&#13;
<p class="indent">Wilhelmsen and Kirkegaard (2017) presents a more modern implementation of the same attack, and being written in a less academic style, it’s easier to follow. They describe a number of complications, with far less math.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_398"/><img id="chHfig1" src="../images/f0398-01.jpg" alt="Image" width="778" height="803"/></div>&#13;
<p class="figcap">Figure H.1: Dallas DS5002</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_399"/><img id="chHfig2" src="../images/f0399-01.jpg" alt="Image" width="1125" height="677"/></div>&#13;
<p class="figcap">Figure H.2: Dallas DS5002 Module in X-ray</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_400"/>Many 8051 instructions take a few clock cycles to execute after being fetched. The DS5002 fetches unrelated instructions during this time to confuse an outside observer, making my earlier description a bit oversimplified.</p>&#13;
<p class="indent">Also, the interrupt table is held in internal SRAM so the attacker can’t know when interrupts have been fired. This matters a lot at reset time.</p>&#13;
<p class="indent">It’s necessary to know when the first real instruction is fetched, because the first observed access might be a dummy read. They do this by attempting all 256 values at that address, and if none of those values change the subsequent memory accesses, they then know that the byte is a dummy and might freely be ignored. This is repeated until they’ve identified the first real instruction.</p>&#13;
<p class="indent">Having identified the location of the first instruction byte, they next need to produce some bytes of their own to fit there. Because the DS5002 sets Port 3 to <span class="literal">FF</span> at reset, they can brute-force 05 b0 (<span class="literal">inc p3</span>) as the first two instruction bytes to flip Port 3 back to <span class="literal">00</span>. And I mean that they brute-force it; there are only 65,536 combinations.</p>&#13;
<p class="indent">At this point, they have one ciphertext/plaintext mapping of the first two bytes but don’t yet have other mappings, so they can’t arbitrarily change them. To get a mapping for the third byte, they brute-force the first byte until they get <span class="literal">75</span>, the opcode for <span class="literal">mov iram addr, #data</span>, at which point they can run <span class="literal">75 b0 xx</span> to write all 256 values of cleartext into Port 3. Now the third byte is completely cracked, even though only two values are mapped for the first byte and just one value for the second byte.</p>&#13;
<p class="indent">They then adjust the first byte until it becomes anything like a <span class="literal">nop</span> and adjust the second byte until it becomes <span class="literal">75</span>. Then they can scan every value of the fourth byte just as they did the third! <span epub:type="pagebreak" id="page_401"/>Repeating this gives them a few bytes of shellcode that they can force into the chip, preceded by two <span class="literal">nop</span> bytes that don’t much matter.</p>&#13;
<p class="indent">Finally, they insert little bits of shellcode. This one gives them the boundary between code and data memories:</p>&#13;
<div class="imagel"><img src="../images/f0401-01.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent">This one dumps the code:</p>&#13;
<div class="imagel"><img src="../images/f0401-02.jpg" alt="Image" width="811" height="113"/></div>&#13;
<p class="indent">And this one dumps the data:</p>&#13;
<div class="imagel"><img src="../images/f0401-03.jpg" alt="Image" width="811" height="90"/></div>&#13;
<p class="indent">There are a lot of resets involved in this attack, but they report just two minutes to brute-force the first range of instructions and just four minutes to dump 32 kilobytes of firmware.</p>&#13;
<h3 class="h3" id="app08_5"><strong>H.5 SAMA5 CMAC, SPA, Keys</strong></h3>&#13;
<p class="noindent">Janushkevich (2020) describes three vulnerabilities in the Microchip (née Atmel) SAMA5 series of secure microcontrollers.</p>&#13;
<p class="indent">This series contains a boot monitor called SAM Boot Assistance (SAM-BA) that allows authenticated and encrypted applets to be uploaded and then executed. These applets are often used as drivers, implementing support for new memory devices in RAM-loadable modules to keep the bootloader small, while relying upon cipher-based message authentication code (CMAC) authentication to keep things secure.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_402"/>Note well: CMAC authentication is often thought of as a fast alternative to public-key signatures. When things go well, CMAC offers authentication in far less time than public-key signatures. Unlike signatures, things can go quite poorly because CMAC depends upon a shared secret key that either party can leak. Think of it like a letter: if we were writing to one another with public-key cryptography, my signature would guarantee that the letter came from someone with a key that only I should have access to and that only I might leak to a third-party. But if we use CMAC to authenticate our letters, you <em>and</em> I have access to the authentication key. <em>Either</em> of us might leak that key to a third-party.</p>&#13;
<p class="indent">Some chips include SAM-BA in ROM. Others have no ROM and instead link the boot assistance monitor to flash memory. A GPIO pin configures the bootloader entry, and SAM-BA supports both UART and USB communications to the host computer. The standard procedure is that when the configuration pin is low at reset or the application’s reset vector is <span class="literal">0xffffffff</span>, the boot-loader will first attempt enumeration over USB and then fall back to a UART console.</p>&#13;
<p class="indent">SAM-BA has a fancy GUI client and TCL scripting library, but for the first bug, we’ll stick to the text protocol of the UART variant. Microchip documents loading a secure applet with the following transactions, where <span class="literal">applet.cip</span> is an encrypted and signed applet binary that is 9,870 bytes in size.</p>&#13;
<div class="imagel"><img src="../images/f0402-01.jpg" alt="Image" width="812" height="112"/></div>&#13;
<p class="indent">During this procedure, the <span class="literal">SAPT</span> command handler loads the applet to <span class="literal">0x220000</span> in SRAM, checks the CMAC authentication, and decrypts the applet in place. The result of the authentication <span epub:type="pagebreak" id="page_403"/>check is placed in a global variable. If the CMAC were wrong, the latter <span class="literal">CACK</span> message would include an error code and the global variable would indicate a bad authentication.</p>&#13;
<p class="indent">After the applet is loaded, the <span class="literal">SMBX</span> command is used to load the mailbox. <span class="literal">mailbox.bin</span> is neither encrypted nor signed, and it loads to the mailbox area within the application image at <span class="literal">0x22-0004</span>. A matching command, <span class="literal">RMBX</span>, will retrieve the mailbox after execution, to allow for bidirectional communication.</p>&#13;
<div class="imagel"><img src="../images/f0403-01.jpg" alt="Image" width="811" height="113"/></div>&#13;
<p class="indent">Now that the applet is loaded, the <span class="literal">EAPP</span> command can be used to execute the applet against the mailbox message. In addition to the mailbox, <span class="literal">SFIL</span> and <span class="literal">RFIL</span> commands exit to send or receive a file from the device.</p>&#13;
<div class="imagel"><img src="../images/f0403-02.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent">Now that we’ve covered the basics of the tutorial, let’s peek at the first exploitable bug. Janushkevich first notes that the <span class="literal">RMBX</span> command allows the mailbox to be retrieved even when it has not been loaded. Because the mailbox and the applet overlap, this allows him to read back part of the applet from memory.</p>&#13;
<p class="indent">He then tried first a signed, encrypted applet and an unsigned, unencrypted applet. <span class="literal">RMBX</span> returned pieces of the first applet in cleartext, showing that it was decrypted to memory before being executed. The unsigned applet also had pieces returned from the mailbox without corruption, implying that when CMAC validation fails, the unvalidated message remains in memory without being scrambled by decryption.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_404"/>Finally, he tried executing the applet with <span class="literal">EAPP</span>, <span class="literal">SFIL</span>, and <span class="literal">RFIL</span>. All three—I shit you not—executed the unencrypted, unsigned applet without complaint. It seems that the <span class="literal">SAPT</span> command records that the authentication failed, but the commands that execute the applet do not bother to check that variable. This is tracked as CVE-2020-12787.</p>&#13;
<p class="indent">As a second attack, he attached a ChipWhisperer to a modified SAMA5D2-XULT dev kit to take a look at the power consumption when that chip performs CMAC authentication. By identifying a point in time when power traces wildly diverge based upon a carry-in subtraction of a provided CMAC word from the computed word, he is able to leak bits of the correct CMAC of the message, starting from the most significant bit and working his way down to the least. In 1,300 power measurements or twenty minutes, this lets him forge a CMAC authentication for bootstrapping an image, loading a SAM-BA applet, or installing a key. This is tracked as CVE-2020-12788.</p>&#13;
<p class="indent">His third attack against this series is simple but brutal: the CMAC keys used by this bootloader are hardcoded and can be dumped by an applet using the vulnerabilities we’ve already discussed. These keys were verified by decrypting published applets, allowing for their reverse engineering and, perhaps someday, their exploitation. CVE-2020-12789.</p>&#13;
</div>
</div>
</body></html>