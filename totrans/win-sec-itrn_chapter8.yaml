- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OTHER
    ACCESS CHECKING USE CASES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Access checks determine what access a caller should have when opening a kernel
    resource. However, we sometimes perform them for other reasons, as they can serve
    as additional security checks. This chapter details some examples of using access
    checks as a secondary security mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at traversal checking, which determines whether a caller
    has access to a hierarchy of resources. Next, we’ll discuss how access checks
    are used when a handle is duplicated. We’ll also consider how an access check
    can limit access to kernel information, such as process listings, from sandboxed
    applications. Finally, I’ll describe some additional PowerShell commands that
    automate the access checking of resources.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Traversal Checking</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When accessing a hierarchical set of resources, such as an object directory
    tree, the user must traverse the hierarchy until they reach the target resource.
    For every directory or container in the hierarchy, the system performs an access
    check to determine whether the caller can proceed to the next container. This
    check is called a *traversal check*, and it’s performed whenever code looks up
    a path inside the I/O manager or object manager. For example, [Figure 8-1](chapter8.xhtml#fig8-1)
    shows the traversal checks needed to access an OMNS object using the path *ABC\QRS\XYZ\OBJ*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Traversal checks
    required to access</samp> <samp class="SANS_Futura_Std_Book_11">OBJ</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, three access checks must be performed before we can access *OBJ*.
    Each access check extracts the security descriptor from the container and then
    checks the type-specific access to see if traversal is allowed. Both the OMNS
    and file directories can grant or deny <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. If, for example, *QRS* denied <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access to the caller, the traversal check would fail, as shown in [Figure 8-2](chapter8.xhtml#fig8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Traversal checks
    blocked at</samp> <samp class="SANS_Futura_Std_Book_11">QRS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Even if the caller would pass the access checks for *XYZ* and *OBJ*, because
    *QRS* now denies access via the traversal check, it’s no longer possible for them
    to access *OBJ* using the *ABC\QRS\XYZ\OBJ* path.
  prefs: []
  type: TYPE_NORMAL
- en: The traversal check prevents a user from accessing their resources if any parent
    container denies <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. This is unexpected behavior—why shouldn’t a user be able to access their
    own resources? It also introduces a performance concern. If a user must have access
    to every parent container to access their files, then the kernel must expend time
    and effort performing an access check for each container, when all that matters
    security-wise is whether the user has access to the resource they want to open.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SeChangeNotifyPrivilege
    Privilege</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the traversal check behavior closer to how you might expect it to work
    and reduce the performance impact, the SRM defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege, which almost every <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object has enabled by default. When this privilege is enabled, the system bypasses
    the entire traversal check and lets users access resources that an inaccessible
    parent would otherwise block. In [Listing 8-1](chapter8.xhtml#Lis8-1), we verify
    the privilege’s behavior using OMNS directory objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Testing SeChangeNotifyPrivilege to bypass traversal checks'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object and all its parent directories, automating the directory creation by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDirectories</samp> property
    ❶. We ensure the privilege is enabled ❷ and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtObject</samp>
    command to check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object can be opened. In the output, we can see we’re able to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We then set a security descriptor with an empty DACL on the *QRS* directory
    ❸. This should block all access to the directory object, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access. But when we check our access again, we see that we can still access the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> object because we
    have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege enabled ❹.
  prefs: []
  type: TYPE_NORMAL
- en: We now disable the privilege and try again to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object ❺. This time, the directory traversal fails. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege or access to the *QRS* directory, we can no longer open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. However, our final check demonstrates that if we have access to a parent
    after *QRS*, such as *XYZ*, we can access the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object via a relative open by using the directory as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Root</samp>
    parameter ❻.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Limited Checks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel contains an additional performance improvement for traversal checks.
    If the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    privilege is disabled, the kernel will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>
    function, which performs a more limited check instead of a full access check.
    For completeness, I have reimplemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeFastTraverseCheck</samp>
    function in PowerShell so that we can explore its behavior in more detail. [Listing
    8-2](chapter8.xhtml#Lis8-2) shows the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: A PowerShell implementation of SeFastTraverseCheck'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the three parameters the function takes: the token’s flags,
    a directory object’s security descriptor, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp>
    access rights to check ❶. We specify the access rights because the object manager
    and the I/O manager use this function for <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> objects, and the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access
    right differs between the two object types; specifying the access as a parameter
    allows the check function to handle both cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the security descriptor’s DACL is NULL, granting access
    if it is ❷. We follow this with a check on two token flags ❸. If the flags indicate
    that the token is filtered or restricted, then the fast check fails. The kernel
    copies these flags from the caller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. We can get the flags from user mode using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    property on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object,
    as shown in [Listing 8-3](chapter8.xhtml#Lis8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: Querying token flags'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the flags include <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>.
    If you’re not running in a restricted token sandbox, why would this flag be set?
    Querying the token elevation type shows that it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>,
    which means it’s the default token for a UAC administrator. To convert the full
    administrator token to the default token, LSASS uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system, which will set the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>
    flag but not <samp class="SANS_TheSansMonoCd_W5Regular_11">IsRestricted</samp>,
    as it’s only removing groups, not adding restricted SIDs. This means that while
    a UAC admin running code as the default user can never pass the fast traversal
    check, a normal user could. This behavior doesn’t have any security implication,
    but it does mean that if <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is disabled, resource lookup performance will suffer.
  prefs: []
  type: TYPE_NORMAL
- en: The final check in [Listing 8-3](chapter8.xhtml#Lis8-3) consists of enumerating
    the DACL’s ACEs. If the ACE is inherit-only or doesn’t contain the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Traverse</samp> access mask, it’s skipped
    ❹. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp> ACE,
    the fast traverse check fails ❺, and the ACE’s SID is not checked at all. Finally,
    if the ACE is an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE and the SID equals the *Everyone* group’s SID, the fast check succeeds ❻.
    If there are no more ACEs, the check fails ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this fast check doesn’t consider whether the caller’s token has the
    *Everyone* group enabled. This is because typically the only way to remove the
    *Everyone* group would be to filter the token. The big exception to this is the
    anonymous token, which doesn’t have any groups but is also not filtered in any
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s turn to another use for the access check: considering the granted
    access when assigning a duplicated handle.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Handle Duplication Access Checks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system always performs an access check when creating or opening a kernel
    resource that returns a handle. But what about when that handle is duplicated?
    In the simplest case, when the new handle has the same granted access mask as
    the original one, the system won’t perform any checks. It’s also possible to drop
    some parts of the granted access mask, and doing so won’t trigger an additional
    access check either. However, if you want to add additional access rights to the
    duplicated handle, the kernel will query the security descriptor from the object
    and perform a new access check to determine whether to allow the access.
  prefs: []
  type: TYPE_NORMAL
- en: When you duplicate a handle, you must specify both the source and destination
    process handles, and the access check occurs in the context of the destination
    process. This means the access check considers the destination process’s primary
    token, not the source process’s, which could be an issue if a privileged process
    tried to duplicate a handle to a less privileged process with additional access.
    Such an operation would fail with <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    Denied</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-4](chapter8.xhtml#Lis8-4) demonstrates this handle duplication access
    check behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Testing the handle duplication access check behavior'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object with an empty DACL and request only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp> access on
    the handle ❶. This will block all users from accessing the object, except for
    the owner, who can be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> access thanks
    to the owner check described in the previous chapter. We test the duplication
    by requesting the same access, which the new handle returns ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we request <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    access only ❸. As the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>’s
    DACL is empty, this access right wouldn’t be granted during an access check, and
    because we get <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>
    on the new handle, we know that no access check took place. Finally, we try to
    increase our access by requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access ❹. An access check must now take place, as we’re requesting greater access
    rights than the handle currently has. This check results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    Denied</samp> error.
  prefs: []
  type: TYPE_NORMAL
- en: If we hadn’t set a security descriptor when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>,
    there would be no security associated with the object, and this last check would
    have succeeded, granting <samp class="SANS_TheSansMonoCd_W5Regular_11">Full Access</samp>.
    As mentioned in [Chapter 2](chapter2.xhtml), you need to be careful when duplicating
    unnamed handles to less privileged processes if you’re dropping access; the destination
    process might be able to reduplicate the handle to one with more access. In [Listing
    8-5](chapter8.xhtml#Lis8-5), we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject
    NoRightsUpgrade</samp> flag to see how it affects handle duplication access checking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Testing the NtDuplicateObject NoRightsUpgrade flag'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating an unnamed <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, which will have no associated security descriptor. We request the initial
    handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access
    only. However, our attempt to duplicate a new handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access succeeds, granting us complete access.
  prefs: []
  type: TYPE_NORMAL
- en: Now we test the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>
    flag. Because we don’t specify any access mask, the handle will be duplicated
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp> access.
    With the new handle, we then perform another duplication, this time requesting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> access. We can
    observe that the handle duplication fails. This isn’t due to an access check;
    instead, it’s because of a flag set on the handle entry in the kernel indicating
    that any request for more access should fail immediately. This prevents the handle
    from being used to gain additional access rights.
  prefs: []
  type: TYPE_NORMAL
- en: The incorrect handling of duplicate handles can lead to vulnerabilities; for
    example, CVE-2019-0943, an issue I discovered in a privileged service responsible
    for caching the details of font files on Windows. The service duplicated a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object handle to a sandbox
    process with read-only access. However, the sandbox process could convert the
    handle back to a writable section handle, and the section could be mapped into
    memory as writable. This allowed the sandbox process to modify the state of the
    privileged service and escape the sandbox. Windows fixed the vulnerability by
    duplicating the handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoRightsUpgrade</samp>
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: The access checks that occur during traversal checking and handle duplication
    are typically hidden from view, but both relate to the security of an individual
    resource. Next, we’ll discuss how access checks limit the information we can extract
    and the operations we can perform for a group of resources. These restrictions
    occur based on the caller’s token, regardless of the individual access set for
    those resources.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Sandbox Token Checks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beginning in Windows 8, Microsoft has tried to make it harder to compromise
    the system by escaping sandbox token restrictions. This is especially important
    for software such as web browsers and document readers, which process untrusted
    content from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel implements two APIs that use an access check to determine whether
    the caller is in a sandbox: <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>,
    introduced in Windows 8, and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>,
    introduced in Windows 10\. These APIs produce equivalent results; the difference
    between them is that <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>
    checks the token of the caller, while <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>
    checks a specified <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that doesn’t have to be the caller’s.'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, these APIs perform an access check for the token and grant access
    only if the token is not in a sandbox. [Listing 8-6](chapter8.xhtml#Lis8-6) shows
    a reimplementation of this access check in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: An access check for a sandbox token'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to define a dummy kernel object type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtType</samp>
    command. This allows us to specify the generic mapping for the access check. We
    specify only the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp> values, as
    write and execute access are not important in this context. Note that the new
    type is local to PowerShell; the kernel doesn’t know anything about it.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a security descriptor with a NULL DACL and the owner and group
    SIDs set to the *SYSTEM* user. The use of a NULL DACL will deny access to lowbox
    tokens, as described in the previous chapter, but not to any other sandbox token
    type, such as restricted tokens.
  prefs: []
  type: TYPE_NORMAL
- en: To handle other token types, we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    mandatory label ACE with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NoReadUp</samp>
    policy. As a result, any token with an integrity level lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    will be denied access to the mask specified in the generic mapping’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    field. Lowbox tokens ignore the <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    mandatory label, but we’ve covered these tokens using the NULL DACL. Note that
    this security descriptor doesn’t consider restricted tokens with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    integrity level to be sandbox tokens. It’s not clear if this is an intentional
    oversight or a bug in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We can now perform an access check with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command, using the current, non-sandboxed token. The access check succeeds, granting
    us <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp> access. If
    we repeat the check with a token that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level, the system denies us access, indicating that the token is sandboxed.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the kernel APIs call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    API, which will return an error if the caller has an Identification-level impersonation
    token. Therefore, the kernel will consider some impersonation tokens to be sandboxed
    even if the implementation in [Listing 8-6](chapter8.xhtml#Lis8-6) would indicate
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'When either API indicates that the caller is sandboxed, the kernel changes
    its behavior to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List only processes and threads that can be directly accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block access to loaded kernel modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerate open handles and their kernel object addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create arbitrary file and object manager symbolic links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new restricted token with more access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in [Listing 8-7](chapter8.xhtml#Lis8-7), we query for handles while
    impersonating a <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity
    level token and are denied access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Querying for handle information while impersonating a Low integrity
    level token'
  prefs: []
  type: TYPE_NORMAL
- en: While only kernel-mode code can access <samp class="SANS_TheSansMonoCd_W5Regular_11">ExIsRestrictedCaller</samp>,
    you can access <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp>
    in user mode, as it’s also exported in *NTDLL*. This allows you to query the kernel
    using a token handle to find out whether the kernel thinks it is a sandbox token.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlIsSandboxToken</samp> API
    exposes its result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp> property,
    as shown in [Listing 8-8](chapter8.xhtml#Lis8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: Checking the sandbox status of tokens'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> has an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IsSandboxToken</samp> property. Internally,
    this property opens the process’s token and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSandbox</samp>.
    We can use this property to easily discover which processes are sandboxed, by
    using the script in [Listing 8-9](chapter8.xhtml#Lis8-9), for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: Enumerating all sandboxed processes for the current user'
  prefs: []
  type: TYPE_NORMAL
- en: These sandbox checks are an important feature for limiting information disclosure
    and restricting dangerous functionality such as symbolic links, which improve
    an attacker’s chances of escaping the sandbox and gaining additional privileges.
    For example, blocking access to the handle table prevents the disclosure of kernel
    object addresses that could be used to exploit kernel memory corruption vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered three uses of the access check for purposes not related to
    opening a resource. We’ll finish this chapter by describing some commands that
    simplify access checking over a range of individual resources.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Automating Access Checks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous chapter provided a worked example that used <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    to determine the granted access for a collection of kernel objects. If you want
    to check a different type of resource, such as files, you’ll need to modify that
    script to use file commands.
  prefs: []
  type: TYPE_NORMAL
- en: Because checking for the granted access across a range of resources is such
    a useful operation, the PowerShell module comes with several commands to automate
    the process. The commands are designed to allow you to quickly assess the security
    attack surface of available resources on a Windows system. They all start with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>, and you can
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Command</samp> to list them,
    as shown in [Listing 8-10](chapter8.xhtml#Lis8-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-10: Listing the Get-Accessible* commands'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to some of these commands in later chapters. Here, we’ll focus
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command, which we can use to automate access checking over the entire OMNS. The
    command lets you specify an OMNS path to check, then enumerates the OMNS and reports
    either the maximum granted access or whether a specific access mask can be granted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify what tokens to use for the access check. The command can
    source tokens from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process command lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify no options when running the command, it will use the current
    primary token. It will then enumerate all objects based on an OMNS path and perform
    an access check for every token specified. If the access check succeeds, then
    the command generates a structured object containing the details of the result.
    [Listing 8-11](chapter8.xhtml#Lis8-11) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-11: Getting accessible objects from the OMNS root'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we run the command against the root of the OMNS, and we receive three
    columns in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TokenId  </samp>The unique identifier
    of the token used for the access check
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>The granted access,
    mapped to generic access rights
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Name  </samp>The name of the checked
    resource
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenId</samp>
    to distinguish the results for the different tokens specified to the command.
  prefs: []
  type: TYPE_NORMAL
- en: This output is only a subset of the result produced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command. You can extract the rest of the information using commands like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>. You can also display
    the copy of the security descriptor used to perform the access check with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    PowerShell command, as shown in [Listing 8-12](chapter8.xhtml#Lis8-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-12: Displaying the security descriptor used for the access check'
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve run the command against a directory here, you might wonder if it will
    also list the objects contained within the directory. By default, no; the command
    opens the path as an object and does an access check. If you want to recursively
    check all objects in the directory, you need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp>
    parameter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command also accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    parameter you can use to specify the maximum recursive depth. If you run a recursive
    check as a non-administrator user, you might see a lot of warnings, as in [Listing
    8-13](chapter8.xhtml#Lis8-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-13: Warnings when recursively enumerating objects'
  prefs: []
  type: TYPE_NORMAL
- en: You can turn off the warnings by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">WarningAction</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Ignore</samp>, but
    keep in mind that they’re trying to tell you something. For the command to work,
    it needs to open each object and query its security descriptor. From user mode,
    this requires passing the access check during the opening; if you don’t have permission
    to open an object for <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access, the command can’t perform an access check. For better results, you can
    run the command as an administrator, and for the best results, run it as the *SYSTEM*
    user by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp>
    command to start a *SYSTEM* PowerShell shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the command will perform the access check using the caller’s token.
    But if you’re running the command as an administrator, you probably won’t want
    this behavior, as almost all resources will allow administrators full access.
    Instead, consider specifying arbitrary tokens to check against the resource. For
    example, when run as a UAC administrator, the following command recursively opens
    the resources using the administrator token but performs the access check with
    the non-administrator token from the Explorer process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s common to want to filter the list of objects to check. You could run the
    access check against all the objects and then filter the list afterward, but this
    would require a lot of work that you’ll then just throw away. To save you some
    time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command supports multiple filter parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TypeFilter  </samp>A list of NT
    type names to check
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Filter  </samp>A name filter used
    to restrict which objects are opened; can contain wildcards
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Include  </samp>A name filter used
    to determine which results to include in the output
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Exclude  </samp>A name filter used
    to determine which results to exclude from the output
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Access  </samp>An access mask used
    to limit the output to only objects with specific granted access
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command will find all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    objects that can be opened with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter requires that all access be granted before outputting a result. You
    can modify this by specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowPartialAccess</samp>,
    which will output any result that partially matches the specified access. If you
    want to see all results regardless of the granted access, specify <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowEmptyAccess</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s wrap up with some worked examples that use the commands you’ve learned
    about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying an Access
    Check for an Object</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous chapter, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command to automate an access check against kernel objects and determine their
    maximum granted access. To accomplish this, we first needed to query for an object’s
    security descriptor. We then passed this value to the command along with the type
    of kernel object to check.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a handle to an object, you can simplify the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command by specifying the object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp>
    parameter, as shown in [Listing 8-14](chapter8.xhtml#Lis8-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-14: Running an access check on an object'
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> parameter
    eliminates the need to manually extract the security descriptor from the object
    and will automatically select the correct generic mapping structure for the kernel
    object type. This reduces the risk that you’ll make mistakes when performing an
    object access check.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable
    Section Objects</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The system uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects to share memory between processes. If a privileged process sets a weak
    security descriptor, it might be possible for a less privileged process to open
    and modify the contents of the section. This can lead to security issues if that
    section contains trusted parameters that can trick the privileged process into
    performing privileged operations.
  prefs: []
  type: TYPE_NORMAL
- en: I identified a vulnerability of this class, CVE-2014-6349, in Internet Explorer’s
    sandbox configuration. The configuration incorrectly secured a shared <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object, allowing sandboxed Internet Explorer processes to open it and disable
    the sandbox entirely. I discovered this issue by performing an access check for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access on all named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects. Once I had
    identified all sections with this access right, I manually determined whether
    any of them were exploitable from the sandbox. In [Listing 8-15](chapter8.xhtml#Lis8-15),
    we automate the discovery of writable sections using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-15: Enumerating writable Section objects for a Low integrity level
    token'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calculating the access mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access and converting it into a generic access enumeration ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>
    command takes only generic access, as it doesn’t know ahead of time what objects
    you’re likely to want to check for. We then duplicate the current user’s token
    and set its integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>,
    producing a simple sandbox ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the token and access mask to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleObject</samp>,
    performing a recursive check in the user’s *BaseNamedObjects* directory by specifying
    a single path separator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Win32Path</samp>
    parameter ❸. The results returned from the command should contain only sections
    that can be opened for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we enumerate the list of discovered sections, displaying their names
    and the initial contents of any discovered writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object ❹. We open each named section, map up to the first 4,096 bytes into memory,
    and then output the contents as a hex dump. We map the section as writable, as
    it’s possible the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object’s security descriptor grants <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access but that the section was created read-only. In this case, mapping <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp> will fail with an error.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this script as is to find noteworthy writable sections. You don’t
    have to use a sandbox token; it can be interesting to see the sections available
    for a normal user that are owned by privileged processes. You can also use this
    as a template for performing the same check for any other kernel object type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked at some examples of the uses of access checking outside
    of opening a resource. We first considered traversal checks, which are used to
    determine if a user can traverse a hierarchical list of containers, such as object
    directories. Then we discussed how access checks are used when handles are duplicated
    between processes, including how this can create security issues if the object
    has no name or security descriptor configured.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored how an access check can be used to determine if a caller’s
    token is sandboxed. The kernel does this to limit access to information or certain
    operations, to make it more difficult to exploit specific classes of security
    vulnerabilities. Finally, we saw how to automate access checks for various resource
    types with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Accessible</samp>
    commands. We looked at the basic parameters common to all commands and how to
    use them to enumerate accessible named kernel objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the end of our examination of the access check process. In the next
    chapter, we’ll cover the last remaining responsibility of the SRM: security auditing.'
  prefs: []
  type: TYPE_NORMAL
