- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BRIDGES
    AND ARTICULATION POINTS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">桥和关节点</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter we consider another aspect of connectivity: nodes and edges
    that are essential to maintaining the integrity of a connected component in an
    undirected graph. These are known as *articulation points* and *bridges*, respectively.
    Understanding which nodes or edges are essential to maintaining connectivity is
    important in a range of real-world problems. Any time we must ensure that there
    is no single point of failure in a network, we need to find its bridges and articulation
    points.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑连通性的另一个方面：在无向图中，维持连通分量完整性所必需的节点和边。这些分别被称为*关节点*和*桥*。理解哪些节点或边对维持连通性至关重要，对于一系列现实世界的问题非常重要。每当我们必须确保网络中没有单点故障时，我们就需要找出其桥和关节点。
- en: After formally defining bridges and articulation points, this chapter provides
    a few demonstrative real-world use cases where these concepts apply, such as developing
    a robust transportation network for a set of islands and building the best secret
    labyrinth for an evil wizard. We then present two algorithms to efficiently search
    for these elements in undirected graphs, building on the depth-first search algorithm
    introduced in [Chapter 4](chapter4.xhtml).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式定义桥和关节点之后，本章提供了一些实际的示范性应用案例，这些概念可以应用于其中，比如为一组岛屿开发强健的交通网络，以及为邪恶的巫师构建最佳的秘密迷宫。接着，我们介绍了两种高效搜索这些元素的算法，基于[第4章](chapter4.xhtml)中介绍的深度优先搜索算法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining Bridges and Articulation Points</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">桥和关节点的定义</samp>
- en: For every pair of nodes in an undirected graph to be mutually reachable, they
    must be part of the same connected component. In [Chapter 3](chapter3.xhtml),
    we learned that a connected component in an undirected graph is a subset of nodes
    *V*′ ⊆ *V* such that *u* is reachable from *v* for all pairs *u* ∈ *V*′ and *v*
    ∈ *V*′. As a concrete example, consider a series of islands joined by ferries.
    Nodes represent islands and edges represent the ferry routes between them. To
    provide full travel options, the transportation planners need the resulting graph
    to consist of a single connected component. That is, a person must be able to
    travel between any two islands on the ferry network, whether by a direct connection
    or by a series of trips.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图中的每一对节点，要使它们能够相互到达，它们必须属于同一个连通分量。在[第3章](chapter3.xhtml)中，我们学到了无向图中的连通分量是节点的一个子集
    *V*′ ⊆ *V*，使得对于所有 *u* ∈ *V*′ 和 *v* ∈ *V*′，*u* 可以从 *v* 到达。以一系列由渡轮连接的岛屿为例。节点代表岛屿，边代表它们之间的渡轮路线。为了提供全面的旅行选项，交通规划者需要使得结果图包含一个单一的连通分量。也就是说，一个人必须能够在渡轮网络中通过直接连接或一系列旅行，在任何两个岛屿之间往返。
- en: '[Figure 11-1](#fig11-1) shows an example graph with two separate connected
    components {0, 1, 2, 4, 5} and {3, 6, 7}.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-1](#fig11-1)显示了一个包含两个独立连通分量{0, 1, 2, 4, 5}和{3, 6, 7}的示例图。'
- en: '![There are no edges between a node in the set containing nodes 0, 1, 2, 4,
    and 5 and a node in the set containing nodes 3, 6, and 7.](../images/f11001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![在包含节点0、1、2、4和5的集合中的节点与包含节点3、6和7的集合中的节点之间没有边。](../images/f11001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A graph with two
    separate connected components</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-1：一个包含两个独立连通分量的图</samp>
- en: A *bridge* is an edge whose removal splits a single connected component into
    two disjoint components. [Figure 11-2(a)](#fig11-2) shows an example graph with
    two bridges (1, 2) and (4, 5). Removing either edge would split the single connected
    component into two. Removing both would split the graph into three separate connected
    components, as shown in [Figure 11-2(b)](#fig11-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*桥*是一个边，它的去除会将一个连通分量分割成两个不相交的分量。[图11-2(a)](#fig11-2)显示了一个包含两条桥（1, 2）和（4, 5）的示例图。移除其中任意一条边都会将单一的连通分量分割成两个。移除两条边都会将图分割成三个独立的连通分量，如[图11-2(b)](#fig11-2)所示。'
- en: '![(A) shows a graph with eight nodes. The edges (1, 2) and (4, 5) are bolded.
    (B) shows the same graph with those edges removed.](../images/f11002.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个包含八个节点的图。边（1, 2）和（4, 5）加粗显示。 (B) 显示了去除这些边后的相同图。](../images/f11002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A graph with two
    bridges (a) and the three separate components that arise from removing the bridges
    (b)</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：一个有两个桥接点的图（a），以及移除桥接点后的三个独立组件（b）</samp>
- en: 'Similarly, an *articulation point* (or *cut vertex*) is a node whose removal
    splits a connected component into two or more disjoint components. For example,
    the graph in [Figure 11-3](#fig11-3) has three articulation points: the shaded
    nodes 1, 2, and 4.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*关节点*（或*割顶*）是一个节点，移除它会将一个连通组件拆分为两个或多个不相交的组件。例如，图[图 11-3](#fig11-3)中有三个关节点：阴影节点
    1、2 和 4。
- en: '![a graph with eight nodes. Nodes 1, 2, and 4 are shaded.](../images/f11003.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![一个有八个节点的图。节点 1、2 和 4 被阴影标出。](../images/f11003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A graph with three
    articulation points</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3：一个有三个关节点的图</samp>
- en: '[Figure 11-4](#fig11-4) shows the impact of individually removing each of the
    articulation points in [Figure 11-3](#fig11-3).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-4](#fig11-4)展示了分别移除[图 11-3](#fig11-3)中的每个关节点所产生的影响。'
- en: '![(A) shows the graph with node 1 removed. (B) shows the graph with node 2
    removed. (C) shows the graph with node 4 removed.](../images/f11004.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 展示了移除节点 1 后的图。 (B) 展示了移除节点 2 后的图。 (C) 展示了移除节点 4 后的图。](../images/f11004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The results of
    removing different articulation points</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-4：移除不同关节点的结果</samp>
- en: In [Figure 11-4(a)](#fig11-4), removing node 1 creates the components {0, 4,
    5} and {2, 3, 6, 7}. [Figure 11-4(b)](#fig11-4) shows that removing node 2 creates
    the components {0, 1, 4, 5} and {3, 6, 7}, while removing node 4 would create
    components {0, 1, 2, 3, 6, 7} and {5}, as shown in [Figure 11-4(c)](#fig11-4).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-4(a)](#fig11-4)中，移除节点 1 会产生两个组件 {0, 4, 5} 和 {2, 3, 6, 7}。在[图 11-4(b)](#fig11-4)中，移除节点
    2 会产生组件 {0, 1, 4, 5} 和 {3, 6, 7}，而移除节点 4 会产生组件 {0, 1, 2, 3, 6, 7} 和 {5}，如[图 11-4(c)](#fig11-4)所示。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用例</samp>
- en: Identifying the bridges and articulation points in a graph is essential for
    understanding single points of failure in a network. This section provides some
    real-world applications for finding bridges and articulation points. We first
    show how to apply these concepts to create a resilient ferry network, then examine
    how to extend the same techniques to prevent the spread of disease or construct
    optimal magical labyrinths.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中识别桥接点和关节点对于理解网络中的单点故障至关重要。本节提供了一些现实世界中寻找桥接点和关节点的应用实例。我们首先展示如何将这些概念应用于创建一个具有韧性的渡轮网络，然后探讨如何将相同的技术扩展到防止疾病传播或构建最佳魔法迷宫。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Resilient
    Networks</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设计韧性网络</samp>
- en: A *resilient network* needs to be able to gracefully handle the loss of an individual
    edge or node without losing connectivity. To expand the island example from the
    previous section, let’s consider two hypothetical ferry networks among eight of
    the Hawaiian islands, as shown in [Figures 11-5](#fig11-5) and [11-6](#fig11-6).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*韧性网络*需要能够优雅地处理单个边或节点的丢失，而不会失去连通性。为了扩展上一节中的岛屿示例，假设有两个假想的渡轮网络，连接八个夏威夷岛屿，如[图
    11-5](#fig11-5)和[图 11-6](#fig11-6)所示。
- en: '![A map of eight Hawaiian islands and seven edges forming a single connected
    component.](../images/f11005.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含八个夏威夷岛屿和七条边，形成一个单一连通组件的地图。](../images/f11005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: A map of hypothetical
    ferry routes among the Hawaiian islands</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-5：假设的夏威夷岛屿之间渡轮航线的地图</samp>
- en: '[Figure 11-5](#fig11-5) shows a minimal ferry network needed to connect the
    eight islands. If all ferries are running without problems, it is possible to
    travel between any two islands. It might take multiple hops for someone to reach
    their destination, but there will be a path.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-5](#fig11-5)展示了连接八个岛屿所需的最小渡轮网络。如果所有渡轮都正常运行，任何两个岛屿之间都可以互通。虽然可能需要经过多个跳跃才能到达目的地，但总会有一条路径。'
- en: However, the network is fragile. If the ferry between O‘ahu (node 2) and Moloka‘i
    (node 3) breaks down, it splits the network in two. People can no longer travel
    from Maui (node 5) and Ni‘ihau (node 0). Each ferry route in the graph is a bridge.
    The loss of any single route would disconnect at least one island. Similarly,
    many of the nodes in [Figure 11-5](#fig11-5) are articulation points. If the ferry
    terminal in O‘ahu (node 2) is closed due to weather, it will disconnect Kaua‘i
    (node 1) from Maui (node 5).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个网络很脆弱。如果在欧胡岛（节点2）和莫洛凯岛（节点3）之间的渡轮出现故障，网络就会被分割成两部分。人们将无法从毛伊岛（节点5）和尼伊豪岛（节点0）之间旅行。图中的每条渡轮路线都是一个桥梁，任何一条线路的丧失都会使至少一个岛屿断开连接。同样，图[11-5](#fig11-5)中的许多节点也是关节点。如果欧胡岛的渡轮码头（节点2）因天气原因关闭，它将把考艾岛（节点1）和毛伊岛（节点5）隔断。
- en: By understanding their network’s bridges and articulation points, planners could
    design a more robust network with no bridges, as shown in [Figure 11-6](#fig11-6).
    A single broken ferry (removal of an edge) won’t cut off travel between any two
    islands. If the ferry between O‘ahu (node 2) and Moloka‘i (node 3) breaks down,
    for example, a traveler could still make their way from Maui (node 5) to Ni‘ihau
    (node 0) via other routes. The network also lacks articulation points. If the
    ferry terminal in Maui closes, for instance, it cuts off only that island.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解网络的桥梁和关节点，规划者可以设计出一个更强大的网络，没有桥梁，如[图11-6](#fig11-6)所示。例如，即使渡轮出现故障（移除一条边），也不会切断任何两个岛屿之间的旅行。如果欧胡岛（节点2）和莫洛凯岛（节点3）之间的渡轮出现故障，旅行者仍然可以通过其他路线从毛伊岛（节点5）前往尼伊豪岛（节点0）。该网络也没有关节点。例如，如果毛伊岛的渡轮码头关闭，它只会断开该岛屿的连接。
- en: '![A map of eight Hawaiian islands with 14 edges connecting the islands.](../images/f11006.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一张显示八个夏威夷岛屿及其间有14条边连接的地图。](../images/f11006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: A second map of
    hypothetical ferry routes among the Hawaiian islands</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-6：夏威夷岛屿之间假设渡轮路线的第二张地图</samp>
- en: We can extend these concepts beyond transportation systems to computer networks,
    power grids, communication networks, or wastewater systems. While it’s often preferable
    to construct graphs without bridges or articulation points, it’s not always feasible.
    However, understanding a network’s weaknesses may still be helpful for planning
    purposes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些概念扩展到交通系统之外，应用到计算机网络、电网、通信网络或废水系统中。虽然通常最好设计没有桥梁或关节点的图，但这并不总是可行的。然而，了解一个网络的弱点仍然对规划有所帮助。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing the Spread
    of Diseases</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">防止疾病传播</samp>
- en: Consider how a common cold migrates through a social network. For simplicity’s
    sake, let’s assume you need to be in proximity to a sick person to catch the cold.
    You cannot catch the cold from someone you never see. If the edges represent real-world
    interactions between people, the virus can pass only between neighboring nodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想常见感冒是如何通过社交网络传播的。为了简化，我们假设你需要靠近一个生病的人才能得感冒。你不能从一个你永远不会见到的人那里感染感冒。如果这些边代表现实世界中人们之间的互动，那么病毒只能在邻近的节点之间传播。
- en: 'We can use the concept of bridges and articulation points to model or stop
    the spread of disease. That coffee meeting with a former workmate acts as a bridge
    that allows the cold to jump between two otherwise disjoint sets of people: your
    previous and your current coworkers. A person who self-isolates and cuts off the
    spread of the virus between groups is an articulation point. By not going to any
    events for a few weeks, you can help prevent a cold from passing between your
    different social circles. Your running friends, the members of your data structures
    reading group, and your coworkers will each be limited to their own colds without
    sharing any through you.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用桥梁和关节点的概念来模拟或阻止疾病的传播。与以前的同事进行的咖啡聚会就像一个桥梁，它允许感冒在两组原本不相交的人群之间传播：你以前的同事和你现在的同事。一个自我隔离并切断病毒在不同人群之间传播的人是一个关节点。通过几周不参加任何活动，你可以帮助防止感冒在不同的社交圈之间传播。你的跑步朋友、数据结构阅读小组的成员以及你的同事们，将只能各自限于他们自己的人群内传播感冒，而不会通过你互相传播。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Magical
    Labyrinths</samp>
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设计魔幻迷宫</samp>
- en: In contrast to the previous two cases, where we want to minimize the bridges
    and articulation points, imagine an evil wizard deciding where to place the most
    effective traps in their labyrinth. A tunnel that serves as the only connection
    between two sections of the labyrinth is a bridge. If one section contains the
    labyrinth entrance and the other contains the goal, the wizard knows that thorough
    adventurers must pass through the tunnel, making it a great place for the best
    trap. Similarly, a room that must be traversed to move between two parts of the
    labyrinth is an articulation point—an ideal place to deploy high-level monsters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两种情况不同，我们希望最小化桥梁和关节点，试想一个邪恶的巫师决定在他的迷宫中布置最有效的陷阱。一个作为迷宫两个部分唯一连接通道的隧道就是桥梁。如果一个部分包含迷宫入口，另一个部分包含目标，巫师知道所有的冒险者都必须经过这条隧道，这使得它成为布置最强大陷阱的理想地点。同样，必须穿过的房间以便在迷宫的两个部分之间移动就是关节点——部署高级怪物的理想场所。
- en: In more common settings, we can use these same techniques to place tollbooths
    on critical highways (bridges) or information booths at the intersection of airport
    terminals (articulation points). In these cases, we use the fact that people traveling
    from one part of the graph to another must pass through this single node or edge.
    Understanding the connectivity of the graph thus lets us optimize potentially
    scarce or expensive resources.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在更常见的场景中，我们可以使用这些相同的技术，在关键的高速公路（桥梁）上设置收费站，或者在机场航站楼交汇处设置信息亭（关节点）。在这些情况下，我们利用这样一个事实：从图的一个部分到另一个部分的旅行者必须经过这个单一的节点或边。理解图的连通性可以帮助我们优化潜在稀缺或昂贵的资源。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Bridge-Finding Algorithm</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">桥梁查找算法</samp>
- en: The computer scientist Robert Tarjan proposed a range of useful algorithms for
    understanding graphs using the properties of their depth-first search trees. This
    section introduces a *bridge-finding algorithm* on undirected graphs that uses
    this approach. The algorithm starts a depth-first search from an arbitrary node
    and tracks both the edges used and the order in which the nodes are first visited
    (the *order index* or *preorder index*, denoted *order*(*u*)). We can use this
    information to look for bridges by asking whether an edge in the depth-first search
    tree provides the only path to reach the nodes in its subtree. Edges that do not
    appear in the depth-first search tree *T* can be immediately ruled out as bridges
    because we were already able to reach the nodes without using them. This means
    we need to consider only the edges in *T*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家罗伯特·塔尔扬（Robert Tarjan）提出了一系列有用的算法，用于通过图的深度优先搜索树的性质来理解图的结构。本节介绍了一种*桥梁查找算法*，它在无向图上使用了这一方法。该算法从一个任意节点开始深度优先搜索，并跟踪所用的边以及节点首次访问的顺序（*顺序索引*或*前序索引*，记作*order*(*u*)）。我们可以利用这些信息通过询问一个边是否是到达其子树中节点的唯一路径来寻找桥梁。那些不出现在深度优先搜索树*T*中的边可以立即排除为桥梁，因为我们已经能在不使用它们的情况下到达节点。这意味着我们只需考虑*T*中的边。
- en: '[Figure 11-7](#fig11-7) shows an example of a graph and two representations
    of its corresponding depth-first search tree rooted at node 0\. [Figure 11-7(a)](#fig11-7)
    shows the initial graph. [Figure 11-7(b)](#fig11-7) shows the corresponding depth-first
    search tree when starting from node 0; the number outside each node indicates
    the order index. [Figure 11-7(c)](#fig11-7) shows the same tree with the *untraversed
    edges* as dashed lines. These untraversed edges are called *back edges* and lead
    back to a node that has already been visited during the depth-first search.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-7](#fig11-7)显示了一个图的示例以及其对应的深度优先搜索树的两种表示，树的根节点为0。[图11-7(a)](#fig11-7)显示了初始图。[图11-7(b)](#fig11-7)显示了从节点0开始的深度优先搜索树；每个节点外的数字表示顺序索引。[图11-7(c)](#fig11-7)显示了相同的树，并将*未遍历的边*标为虚线。这些未遍历的边称为*回边*，它们回到在深度优先搜索过程中已经访问过的节点。'
- en: '![(A) shows an undirected graph with seven nodes and nine edges. (B) shows
    a tree built from this graph with root node 0\. Node 0 is labeled with order =
    0 and has two children: node 1 with order = 1, and node 3 with order = 5\. (C)
    shows the same tree as subfigure B with three additional dashed edges.](../images/f11007.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个包含七个节点和九条边的无向图。(B) 显示了从该图构建的树，根节点为0。节点0标记为order = 0，并且有两个子节点：节点1，order
    = 1，和节点3，order = 5。(C) 显示了与B子图相同的树，并附加了三条虚线边。](../images/f11007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: An undirected
    graph (a), a depth-first search tree (b), and the depth-first search tree with
    untraversed edges (c)</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-7：无向图（a），深度优先搜索树（b），以及包含未遍历边的深度优先搜索树（c）</samp>
- en: We can identify bridges by looking for edges leading into a subtree of *T*,
    where that subtree’s nodes only have neighbors in the same subtree. In other words,
    if the edge (*v*, *u*) is a bridge, there is no way to get into or out of the
    subtree of node *u* except through the edge into (*v*, *u*). Edge (1, 6) in [Figure
    11-7(a)](#fig11-7) presents one such example, providing the only path into or
    out of the subtree rooted at node 6\. In contrast, the edge (0, 3) is not a bridge,
    because node 5 has an edge back to node 0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查找指向 *T* 子树的边来识别桥，其中该子树的节点只与同一子树中的邻居相连。换句话说，如果边（*v*，*u*）是桥，则没有其他方式能够进出节点
    *u* 的子树，除了通过边（*v*，*u*）进入或离开。在[图 11-7(a)](#fig11-7)中，边（1，6）就是一个这样的例子，提供了进入或离开以节点
    6 为根的子树的唯一路径。相反，边（0，3）不是桥，因为节点 5 有一条通往节点 0 的边。
- en: The key to this algorithm is that we can look at the minimum and maximum order
    index in the neighborhoods of *u* and its descendants. By the properties of depth-first
    search, all the nodes in *u*’s subtree must have an order index in the range [*order*(*u*),
    *order*(*u*) + *K* − 1], where *K* is the number of nodes in the subtree (including
    *u*). This is because the search travels to those nodes after visiting *u* and
    before visiting nodes in other subtrees. If the nodes in *u*’s subtree have any
    neighbor with an order index outside that range, the edge to that neighbor would
    provide an alternate path into *u*’s subtree.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的关键是我们可以查看 *u* 及其后代节点的邻域中的最小和最大顺序索引。根据深度优先搜索的性质，*u* 的子树中的所有节点的顺序索引都必须位于
    [*order*（*u*），*order*（*u*） + *K* − 1] 范围内，其中 *K* 是子树中节点的数量（包括 *u*）。这是因为搜索在访问 *u*
    后，先访问这些节点，然后才访问其他子树中的节点。如果 *u* 的子树中的节点有任何邻居，其顺序索引超出了这个范围，则通向该邻居的边将提供进入 *u* 子树的替代路径。
- en: We can use a common simplification by observing that any unvisited nodes reachable
    from the subtree would be explored by the depth-first search and thus would appear
    in the subtree. Therefore, we need to check only for back edges to neighbors with
    a lower order index. We can test whether edge (*v*, *u*), where *v* is the parent
    of *u*, is a bridge by checking if any node in *u*’s subtree has a neighbor *w*
    such that *order*(*w*) < *order*(*u*), excluding the connection (*v*, *u*) itself.
    If there is such a neighbor, we have found a back edge that bypasses (*v*, *u*)
    and know that (*v*, *u*) is not a bridge. Conversely, if *order*(*w*) ≥ *order*(*u*)
    for all the subtree’s neighbors *w* when excluding the connection (*v*, *u*),
    then (*v*, *u*) is a bridge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过观察到任何未访问的节点，只要它可以从子树到达，就会被深度优先搜索所探索，从而出现在子树中，来简化问题。因此，我们只需要检查指向邻居且具有较低顺序索引的回边即可。我们可以通过检查边（*v*，*u*），其中
    *v* 是 *u* 的父节点，是否为桥来进行测试，即检查 *u* 的子树中的任何节点是否有一个邻居 *w*，使得 *order*（*w*） < *order*（*u*），并排除连接（*v*，*u*）本身。如果存在这样的邻居，我们就找到了一个绕过（*v*，*u*）的回边，并且可以确定（*v*，*u*）不是桥。相反，如果在排除连接（*v*，*u*）的情况下，所有子树邻居
    *w* 的 *order*（*w*） ≥ *order*（*u*），则（*v*，*u*）是一个桥。
- en: Node 2 in [Figure 11-7](#fig11-7) provides an example of this case. The search
    reached node 2 via the edge (1, 2) and assigned it an order index of 2, as shown
    in [Figure 11-7(b)](#fig11-7). For edge (1, 2) to be a bridge, there must be no
    alternate path out of that subtree. However, node 2 itself has an edge to node
    0 (with order = 0), providing such an alternate route.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#fig11-7)中的节点 2 提供了一个此类情况的例子。搜索通过边（1，2）到达节点 2，并将其分配了顺序索引 2，如[图 11-7(b)](#fig11-7)所示。为了使边（1，2）成为一座桥，必须没有从该子树出去的替代路径。然而，节点
    2 本身有一条通向节点 0（顺序 = 0）的边，从而提供了这样的替代路径。'
- en: The opposite case is shown in [Figure 11-8](#fig11-8) with edge (0, 1). The
    graph in [Figure 11-8(a)](#fig11-8) has a slight modification from the one in
    [Figure 11-7(a)](#fig11-7), the exclusion of edge (0, 2), which results in edge
    (0, 1) now being a bridge. [Figure 11-8(b)](#fig11-8) shows the corresponding
    depth-first search subtree rooted at node 0, with the untraversed edges in gray.
    The dotted ovals in both figures indicate the subtree of node 1\. As shown in
    [Figure 11-8(b)](#fig11-8), the only connection from the subtree of node 1 to
    a node with order less than 1 is the edge (0, 1) itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的情况显示在[图 11-8](#fig11-8)中，边 (0, 1)。[图 11-8(a)](#fig11-8)中的图与[图 11-7(a)](#fig11-7)中的图稍有不同，排除了边
    (0, 2)，因此边 (0, 1) 现在是一个桥接边。[图 11-8(b)](#fig11-8) 显示了以节点 0 为根的对应深度优先搜索子树，其中未遍历的边以灰色显示。两幅图中的虚线椭圆表示节点
    1 的子树。如[图 11-8(b)](#fig11-8)所示，从节点 1 的子树到顺序小于 1 的节点的唯一连接是边 (0, 1) 本身。
- en: '![(A) shows an undirected graph with seven nodes and eight edges. (B) shows
    a tree built from this graph with root node 0 and additional gray edges.](../images/f11008.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示一个有七个节点和八条边的无向图。 (B) 显示一个从该图构建的树，根节点是 0，且有额外的灰色边。](../images/f11008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: An undirected
    graph (a) and a depth-first search tree (b)</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-8：一个无向图 (a) 和一个深度优先搜索树
    (b)</samp>
- en: The bridge-finding algorithm checks each subtree in the depth-first search tree
    by recording the lowest-order indices that neighbor any node in the subtree. The
    only adjacent edge we exclude is the link between the subtree root *u* and its
    parent, as this is the edge we are testing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接查找算法通过记录邻接任何子树节点的最低序号，检查深度优先搜索树中的每个子树。唯一排除的邻接边是子树根节点 *u* 与其父节点之间的链接，因为这就是我们正在测试的边。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'We can implement the bridge-finding algorithm using a single pass of depth-first
    search. To simplify the code, we’ll use the helper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    to track information about the order in which the depth-first search reaches various
    nodes, including:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一次深度优先搜索来实现桥接查找算法。为了简化代码，我们将使用辅助数据结构 <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    来跟踪深度优先搜索到达各个节点的顺序信息，包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">parent</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node’s index to that of its parent in the depth-first search tree
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">parent</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **将每个节点的索引映射到其在深度优先搜索树中的父节点索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">next_order_index</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores the next order index
    to assign
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">next_order_index</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储下一个要分配的顺序索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">order</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node’s index to its order index
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">order</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **将每个节点的索引映射到其顺序索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">lowest</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node to the *lowest* order index of any nodes in its depth-first search subtree
    or their immediate neighbors (excluding the node’s parent)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">lowest</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **将每个节点映射到其深度优先搜索子树或其直接邻居（不包括节点的父节点）中的
    *最低* 顺序索引
- en: 'The data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    provides a wrapper for this information and saves us from having to pass many
    parameters to the search function. We can also use the object to perform basic
    assignments and updates. We define <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构 <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp> 提供了这个信息的封装，避免了我们需要将许多参数传递给搜索函数。我们还可以使用该对象执行基本的赋值和更新操作。我们在以下代码中定义了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constructor sets all the information to its initial values ❶. The code initializes
    all entries of the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">parent</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> in order to indicate
    that these values are unset for each node. It sets <samp class="SANS_TheSansMonoCd_W5Regular_11">next_order_index</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> in preparation for the
    first node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将所有信息设置为初始值❶。代码将<samp class="SANS_TheSansMonoCd_W5Regular_11">parent</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">order</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>列表的所有条目初始化为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，以表示这些值尚未为每个节点设置。它将<samp class="SANS_TheSansMonoCd_W5Regular_11">next_order_index</samp>设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，以准备处理第一个节点。
- en: The helper method <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>
    records the current node’s order index and increments the next one to assign.
    It also initializes the lowest order index seen for this node, which is initially
    the order index of the node itself ❷.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法<samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>记录当前节点的顺序索引，并增加下一个要分配的顺序索引。它还初始化该节点的最低顺序索引，初始值为该节点自身的顺序索引❷。
- en: 'We use a depth-first search adapted from those in [Chapter 4](chapter4.xhtml)
    to fill in the entries of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    and find the bridges:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自[第4章](chapter4.xhtml)的深度优先搜索，来填写<samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>的条目并查找桥。
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The recursive helper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bridge_finding_dfs()</samp>
    starts by setting the current node’s order index and initial value for the lowest
    order index reachable in the subtree using the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>
    helper method ❶.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 递归辅助函数<samp class="SANS_TheSansMonoCd_W5Regular_11">bridge_finding_dfs()</samp>通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>辅助方法❶，首先设置当前节点的顺序索引和子树中可达的最低顺序索引的初始值。
- en: The code then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to check each of the node’s neighbors. For consistency of ordering with other
    examples, we use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>
    to traverse the neighbors in order of their index, though traversing them in sorted
    order is not necessary for the correctness of the algorithm. If a neighbor has
    not been visited (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    value is unset) ❷, the code sets its parent and recursively explores it. After
    returning from the recursive call, the code checks whether it has found a smaller
    order index neighboring the subtree by comparing the child’s <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    entry with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    entry ❸.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接着使用<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环检查每个节点的邻居。为了与其他示例中的顺序保持一致，我们使用函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>按顺序遍历邻居，尽管按排序顺序遍历对于算法的正确性并非必要。如果某个邻居尚未访问（其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">order</samp>值未设置）❷，代码将其父节点设置并递归地探索它。递归调用返回后，代码通过比较子节点的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>条目与它自身的<samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>条目❸，检查是否找到了邻近子树的较小顺序索引。
- en: At this point, the search has finished exploring the depth-first search subtree
    rooted at <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>. It can
    check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">edge</samp> is a bridge
    by comparing the lowest-order index of any node in the subtree or its immediate
    neighbor with the order index of the subtree’s root ❹. The code appends new bridges
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，搜索已完成对以<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>为根的深度优先搜索子树的探索。它可以通过比较子树中任何节点或其直接邻居的最低顺序索引与子树根节点的顺序索引，来检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">edge</samp>是否为桥❹。代码将新发现的桥添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>中。
- en: If the neighbor has been seen (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    value is set), then the code first checks whether the neighbor is the parent node
    itself. If it is, then the edge under consideration was just traversed and the
    search ignores it. Otherwise, the code checks whether this neighbor represents
    a node outside the subtree by checking that neighbor’s order index ❺.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居已被访问（其 <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> 值已设置），代码首先检查邻居是否是父节点。如果是，那么正在考虑的边刚刚被遍历过，搜索将忽略它。否则，代码会检查该邻居是否代表子树外的节点，通过检查该邻居的顺序索引
    ❺。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_bridges()</samp> function
    provides a wrapper that sets up the statistics and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp>
    data structures, then starts the search(es). The code finds all bridges in each
    connected component by performing a single depth-first search from that component,
    using the approach adapted from [Listing 4-2](chapter4.xhtml#list4-2). Since each
    node is visited only once and each edge is examined at most twice (once in each
    direction), the cost of the full algorithm scales as |*V* | + |*E*|.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">find_bridges()</samp> 函数提供了一个封装器，用于设置统计信息和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> 数据结构，然后开始搜索。代码通过执行一次深度优先搜索来找到每个连通分量中的所有桥，使用的方式是从[Listing
    4-2](chapter4.xhtml#list4-2)中改编而来。由于每个节点仅访问一次，每条边最多检查两次（每个方向一次），因此整个算法的成本是 |*V*
    | + |*E*|。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">示例</samp>
- en: '[Figure 11-9](#fig11-9) shows an example run of the bridge-finding algorithm
    on a graph with eight nodes. Each subfigure shows the state of the search after
    *completing* the visit to the circled node. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>’s
    lists <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    are shown. The arrows indicate edges traversed so far and the dashed edges indicate
    ones that were seen by search but not traversed, while the bolded gray arrows
    are the bridges.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9](#fig11-9) 显示了在一个具有八个节点的图上运行桥查找算法的示例。每个子图显示了搜索完成访问圈中节点后的状态。<samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    的列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    被展示。箭头表示到目前为止遍历的边，而虚线边表示已经被搜索到但未遍历的边，粗体灰色箭头表示桥。'
- en: '[Figure 11-9(a)](#fig11-9) shows the state of the algorithm after the search
    completes node 6\. At this point, it has initially visited and set a preorder
    index for nodes 0, 1, 2, 3, 7, and 6\. Nodes 4 and 5 are unvisited and thus do
    not have a preorder index. Similarly, the lower bounds correspond to the algorithm’s
    state after visiting only some of the visited node’s children. Node 6 has the
    final state of <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> since
    the search has finished processing it. In contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    value of node 3 is not finalized because the algorithm has not finished searching
    its subtree.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-9(a)](#fig11-9) 显示了搜索完成节点6后算法的状态。此时，算法已初步访问并为节点0、1、2、3、7和6设置了先序索引。节点4和5未被访问，因此没有先序索引。同样，低值与算法在访问已访问节点的子节点后获得的状态相对应。节点6的最终状态是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">最低</samp>，因为搜索已经完成了对它的处理。相比之下，节点3的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">最低</samp> 值尚未最终确定，因为算法尚未完成对其子树的搜索。'
- en: In [Figure 11-9(b)](#fig11-9), the search backtracks to node 7 and completes
    that node. During this process, the algorithm checks whether the edge (7, 6) could
    be a bridge. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[6]</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">order[6]</samp>, we
    know there is an alternate path out of the subtree (through node 2) and the edge
    is not a bridge.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-9(b)](#fig11-9) 中，搜索回溯到节点7并完成了该节点。在此过程中，算法检查边(7, 6)是否可能是桥。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[6]</samp>
    小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">order[6]</samp>，我们知道从子树中存在一条备用路径（通过节点2），因此该边不是桥。
- en: '![Each subfigure shows a graph with eight nodes and the values in two arrays.
    In (A) node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4],
    and the low array contains [0,1, 2, 3, –1, –1, 2, 4].](../images/f11009.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示一个具有八个节点的图以及两个数组中的值。在(A)中，节点6被圈出，order数组包含[0, 1, 2, 3, –1, –1, 5, 4]，low数组包含[0,1,
    2, 3, –1, –1, 2, 4]。](../images/f11009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-9: The stages of
    the bridge-finding algorithm</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-9：桥接算法的各个阶段</samp>
- en: By [Figure 11-9(e)](#fig11-9), the search has found the first bridge. While
    it has not finished processing node 1, it has fully searched the subtree rooted
    at node 2\. After returning from node 2, the algorithm finds that <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[2]</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">order[2]</samp>, indicating
    that the edge (1, 2) is the only path into or out of the subtree rooted at node
    2\. It adds (1, 2) to the list of bridges before moving on to the other children
    of node 1\. In [Figure 11-9(f)](#fig11-9), after finishing the subtree rooted
    at node 5, the search finds that the edge (4, 5) must be another bridge, as the
    removal of that edge disconnects node 5.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[图 11-9(e)](#fig11-9)，搜索已经找到了第一个桥接边。虽然它还没有完成处理节点 1，但已经完全搜索了以节点 2 为根的子树。在从节点
    2 返回后，算法发现<samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[2]</samp>等于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">order[2]</samp>，表明边（1, 2）是通向或离开以节点 2 为根的子树的唯一路径。它将（1,
    2）添加到桥接边列表中，然后继续处理节点 1 的其他子节点。在[图 11-9(f)](#fig11-9)中，完成了以节点 5 为根的子树后，搜索发现边（4,
    5）必定是另一个桥接边，因为删除该边会使节点 5 与其他节点断开连接。
- en: To visualize this, imagine our evil wizard inspecting their newly created magical
    labyrinth. They start by walking the labyrinth, building a depth-first tree, and
    recording the preorder index of each room with a chalk marking on the wall. Each
    time they enter a new room, they recursively explore any unvisited neighboring
    rooms and poke their head into previously visited neighboring rooms to check the
    marks on the wall. When visiting the Room of Loose Ceiling Tiles they might see
    a new neighbor, the Room with the Ugly Carpet, and also find a connection back
    to the previously visited Room That Is Always Uncomfortably Warm. Throughout the
    process, they track the lowest number they have seen since entering each room.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象化这一过程，想象我们的邪恶巫师正在检查他们新创建的魔法迷宫。他们首先开始走迷宫，建立一个深度优先树，并在每个房间的墙上用粉笔标记该房间的前序索引。每当他们进入一个新房间时，他们会递归地探索任何未访问的邻居房间，并探头查看以前访问过的邻居房间，检查墙上的标记。当他们访问到“松动天花板砖房间”时，他们可能会发现一个新邻居，“丑陋地毯房间”，并且还会找到一条通向先前访问过的“总是令人不舒服的温暖房间”的连接。在整个过程中，他们记录下进入每个房间以来看到的最小编号。
- en: After backtracking through each hallway, the wizard checks their notes to determine
    whether any of the rooms they just visited have a neighboring room with a preorder
    index less than the room at the far end of the hallway (the room that they just
    left when backtracking). After backtracking through their personal favorite, the
    Hallway of Excessive Chandeliers, the wizard effectively asks, “Is there another
    passage through which the adventurers could reach one of the rooms up ahead? Or
    do they have to go through the Hallway of Excessive Chandeliers?” If there is
    no alternate path, they can mark the Hallway of Excessive Chandeliers as a bridge,
    be happy in the knowledge that the adventurers will always get to see this opulently
    decorated passage, and also plan to deploy a good trap.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在回溯通过每个走廊后，巫师检查他们的笔记，以确定他们刚刚访问过的任何房间是否有邻近房间，其前序索引小于走廊尽头的房间（即他们回溯时刚离开的房间）。在回溯通过他们个人最喜欢的“吊灯过多走廊”后，巫师实际上是在问：“是否还有其他通道可以让冒险者到达前面的某个房间？还是他们必须穿过‘吊灯过多走廊’？”如果没有其他通道，他们可以将“吊灯过多走廊”标记为一个桥接边，并且高兴地知道冒险者总会看到这个华丽装饰的通道，同时还计划设置一个很好的陷阱。
- en: <samp class="SANS_Futura_Std_Bold_B_11">An Algorithm for Finding Articulation
    Points</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">一种寻找关节点的算法</samp>
- en: We can adapt the bridge-finding algorithm to identify articulation points by
    considering the roots of each subtree instead of the edges directly connected
    to them, using very similar logic. We identify articulation points by looking
    for a node *u* whose descendants in the depth-first search tree do not have a
    neighbor above *u* in that tree. An edge from a node outside the subtree of *u*
    to one of the descendants of *u* would provide the critical alternate path around
    *u*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过考虑每个子树的根节点，而不是直接与它们相连的边，使用非常相似的逻辑，来将桥接查找算法适应为识别关节点。我们通过寻找一个节点*u*来识别关节点，该节点的深度优先搜索树中的后代没有任何邻居位于该树中的*u*之上。一个来自树外节点的边，连接到*u*的后代之一，将为*u*提供一个关键的替代路径。
- en: To understand how to use the node’s subtrees to identify articulation points,
    consider the two cases shown in [Figure 11-10](#fig11-10). We map the depth-first
    search subtrees onto the original undirected graph with arrows and label each
    node with its order index. The current node under consideration is shaded and
    a dashed boundary marks the node’s descendants.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A), nodes {2, 3, 6, 7} are circled. In (B), nodes {6, 7} are circled.](../images/f11010.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-10: Two nodes and
    their subtrees in a graph’s depth-first search tree</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-10(a)](#fig11-10), the algorithm is considering node 1 and descendants
    {2, 3, 6, 7}. Removing node 1 would cut its descendants off from the rest of the
    graph. In contrast, node 3 is not an articulation point, as shown in [Figure 11-10(b)](#fig11-10).
    That node’s descendants include node 6, which has a link back to node 2 (outside
    the subtree of node 3). The edge (2, 6), although not included in the depth-first
    search tree, provides an alternate path to nodes 6 and 7 in the event node 3 is
    removed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This logic works for every node except the root node. Since the root node has
    no ancestors, we cannot use the same approach of checking the subtrees for back
    edges. Instead, we must look for cases where the root node has more than one subtree.
    As shown in the example graph in [Figure 11-11](#fig11-11), the root node will
    have multiple subtrees only if the graph has components that would be disconnected
    by the removal of the root node. If there were an edge joining the subtrees, the
    depth-first search would traverse that edge before returning to the root.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with seven nodes. Six of the edges are arrows, including (0, 1),
    (1, 2), and (1, 6). Three edges are dashed lines including (0, 2), (0, 5) and
    (1, 4).](../images/f11011.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-11: A depth-first
    subtree where the root node is an articulation point</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the specialized root test with the lower bound tracking from
    the bridge-detection algorithm to identify the articulation points in a graph,
    as shown in the following code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: As with the bridge-finding algorithm, we implement the *articulation-point-finding
    algorithm* with a single pass of depth-first search that completes both the search
    and the identification. We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    data structure track and update information about each node’s parent, order index,
    and lowest reachable order index.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the code, we break the search into two functions. The first function
    handles the non-root nodes and performs the recursive exploration:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    performs the majority of the work for this algorithm. It starts by setting the
    current node’s order index and tentative lower bound ❶, then performs the depth-first
    search by iterating over each neighbor, checking whether it has been visited,
    and, if not, recursively exploring it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    执行了此算法的大部分工作。它首先设置当前节点的顺序索引和暂定下界 ❶，然后通过遍历每个邻居来执行深度优先搜索，检查是否已访问，如果没有，则递归地进行探索。
- en: The code tracks the lower bounds for the neighbors of any node in the subtree.
    For subtrees in the depth-first search tree (previously unexplored nodes), the
    code updates the lower bound based on the lowest neighbor of that entire subtree
    ❷. The logic for identifying articulation points takes place after this recursive
    exploration of each child. The code determines whether the subtree it just visited
    would be cut off by the removal of the *current* node by checking whether any
    node in that subtree contains a neighbor above the current node in the depth-first
    search tree ❸.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码跟踪任何节点在子树中邻居的下界。对于深度优先搜索树中的子树（先前未探索的节点），代码会根据该子树的最低邻居来更新下界 ❷。标识关节点的逻辑发生在每个子节点的递归探索之后。代码通过检查该子树中的任何节点是否包含一个在深度优先搜索树中高于当前节点的邻居
    ❸ 来确定当前节点的移除是否会切断它刚刚访问过的子树。
- en: For neighbors that are not part of the depth-first search subtree (previously
    explored nodes) and are not the current node’s parent, the code compares the node’s
    lower bound to the neighbor’s order index ❹.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不属于深度优先搜索子树（先前已探索的节点）且不是当前节点的父节点的邻居，代码会将节点的下界与邻居的顺序索引进行比较 ❹。
- en: 'For the root node, we add some additional logic to track the number of subtrees:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根节点，我们添加了一些额外的逻辑来跟踪子树的数量：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp>
    function starts by setting the order index of the root and initializing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_subtrees</samp> counter. It then starts
    the depth-first search by iterating over each neighbor, checking if it has been
    visited ❶, and, if not, recursively exploring it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    function. Instead of using the lower bound logic in deciding whether the root
    is an articulation point, the code simply checks whether the root has two or more
    subtrees ❷. If so, it appends the root to the results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp>
    函数首先设置根节点的顺序索引，并初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_subtrees</samp>
    计数器。然后，它通过遍历每个邻居，检查是否已访问过 ❶，如果没有，则使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    函数递归地进行探索。代码不是通过使用下界逻辑来判断根节点是否为关节点，而是直接检查根节点是否有两个或更多的子树 ❷。如果是，它将根节点添加到结果中。
- en: 'The function for finding all articulation points consists of using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp> function
    to run this search on each connected component in the graph:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有关节点的函数是通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp>
    函数在图中的每个连通分量上运行此搜索：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_articulation_points()</samp>
    function starts by creating and initializing the data structures needed for the
    algorithm. Since the data structures are indexed by node and the different connected
    components are disjoint, the code can use a single <samp class="SANS_TheSansMonoCd_W5Regular_11">stats</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> object for all
    connected components. The code then iterates over each node, checks whether it
    has been visited by a search ❶, and, if not, starts a new depth-first search from
    that node. It finishes by returning the list of all articulation points.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">find_articulation_points()</samp>
    函数首先创建并初始化算法所需的数据结构。由于数据结构是通过节点进行索引的，并且不同的连通分量是离散的，因此代码可以使用单一的 <samp class="SANS_TheSansMonoCd_W5Regular_11">stats</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> 对象来处理所有连通分量。然后，代码遍历每个节点，检查是否已经通过搜索访问过
    ❶，如果没有，则从该节点开始新的深度优先搜索。最后，它返回所有关节点的列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 11-12](#fig11-12) shows an illustration of the algorithm for finding
    articulation points. Each subfigure shows the state of the algorithm after *completing*
    the visit to the circled node. The edges tested are represented by an arrow if
    they are part of the depth-first search tree or a dashed line if they are not.
    Unexplored edges are solid gray lines, and the discovered articulation points
    are shaded.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a graph with eight nodes and the values in two arrays.
    In (A), node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4],
    and the low array contains [0,1, 2, 3, –1, –1, 2, 4].](../images/f11012.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-12: The stages of
    the articulation-point-finding algorithm</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the algorithm behavior represented in [Figure 11-12](#fig11-12)
    is the same as that in [Figure 11-9](#fig11-9). The order in which the nodes are
    explored and the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    at each step are identical. The difference in behavior arises where articulation
    points are detected in [Figure 11-12(d)](#fig11-12). The lowest-order index for
    any neighbor of the subtree rooted at node 3 is 2, the order index of the current
    node. We know that node 2 has at least one subtree without connections back to
    any of its ancestors, meaning that removing node 2 would disconnect that subtree.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12(e)](#fig11-12) is interesting because, although it shows the
    state after finishing node 5, the algorithm has already marked (the unfinished)
    node 1 as an articulation point due to performing the articulation point test
    after checking each subtree. Regardless of what happens while exploring the other
    descendants of node 1, we know that removing that node would disconnect the subtree
    rooted at node 2.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12(h)](#fig11-12) shows the final step of the algorithm. At this
    point, the search has returned from the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    function and is testing the root. Instead of using the low boundary, it checks
    how many subtrees the root has, revealing that node 0 has a single depth-first
    search subtree. All nodes in the graph are reached through node 1 before the search
    returns to node 0\. Therefore, node 0 is not an articulation point.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bridges and articulation points are critical for understanding the structure
    of graphs, including their points of failure and bottlenecks. As we saw in the
    example use cases, these features apply to a variety of real-world problems, from
    incorporating redundant routes into airline networks to designing the ultimate
    magical labyrinth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms introduced in this chapter provide practical methods for identifying
    these structural elements and using depth-first search trees and order indexes
    to determine which nodes are reachable via alternate paths. This again highlights
    the power and versatility of a simple depth-first search and shows how augmenting
    information like order indexes can provide deep insights into the overall structure
    of the graph.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的算法提供了实用的方法，用于识别这些结构元素，并利用深度优先搜索树和顺序索引来确定哪些节点可以通过替代路径到达。这再次突显了简单的深度优先搜索的强大和多功能性，并展示了如何通过增加顺序索引等信息，深入理解图的整体结构。
- en: The next chapter further extends our discussion of connectivity, this time considering
    directed graphs and the related concept of strongly connected components. We introduce
    an algorithm that builds off the ideas presented in this chapter of collecting
    statistics with depth-first search to understand the graph’s structure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将进一步扩展我们关于连通性的讨论，这次将考虑有向图以及相关的强连通分量概念。我们介绍了一种算法，该算法基于本章中介绍的利用深度优先搜索收集统计信息来理解图结构的思想。
