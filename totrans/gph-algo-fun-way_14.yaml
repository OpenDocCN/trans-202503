- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BRIDGES
    AND ARTICULATION POINTS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter we consider another aspect of connectivity: nodes and edges
    that are essential to maintaining the integrity of a connected component in an
    undirected graph. These are known as *articulation points* and *bridges*, respectively.
    Understanding which nodes or edges are essential to maintaining connectivity is
    important in a range of real-world problems. Any time we must ensure that there
    is no single point of failure in a network, we need to find its bridges and articulation
    points.'
  prefs: []
  type: TYPE_NORMAL
- en: After formally defining bridges and articulation points, this chapter provides
    a few demonstrative real-world use cases where these concepts apply, such as developing
    a robust transportation network for a set of islands and building the best secret
    labyrinth for an evil wizard. We then present two algorithms to efficiently search
    for these elements in undirected graphs, building on the depth-first search algorithm
    introduced in [Chapter 4](chapter4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining Bridges and Articulation Points</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For every pair of nodes in an undirected graph to be mutually reachable, they
    must be part of the same connected component. In [Chapter 3](chapter3.xhtml),
    we learned that a connected component in an undirected graph is a subset of nodes
    *V*′ ⊆ *V* such that *u* is reachable from *v* for all pairs *u* ∈ *V*′ and *v*
    ∈ *V*′. As a concrete example, consider a series of islands joined by ferries.
    Nodes represent islands and edges represent the ferry routes between them. To
    provide full travel options, the transportation planners need the resulting graph
    to consist of a single connected component. That is, a person must be able to
    travel between any two islands on the ferry network, whether by a direct connection
    or by a series of trips.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-1](#fig11-1) shows an example graph with two separate connected
    components {0, 1, 2, 4, 5} and {3, 6, 7}.'
  prefs: []
  type: TYPE_NORMAL
- en: '![There are no edges between a node in the set containing nodes 0, 1, 2, 4,
    and 5 and a node in the set containing nodes 3, 6, and 7.](../images/f11001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A graph with two
    separate connected components</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A *bridge* is an edge whose removal splits a single connected component into
    two disjoint components. [Figure 11-2(a)](#fig11-2) shows an example graph with
    two bridges (1, 2) and (4, 5). Removing either edge would split the single connected
    component into two. Removing both would split the graph into three separate connected
    components, as shown in [Figure 11-2(b)](#fig11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with eight nodes. The edges (1, 2) and (4, 5) are bolded.
    (B) shows the same graph with those edges removed.](../images/f11002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: A graph with two
    bridges (a) and the three separate components that arise from removing the bridges
    (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an *articulation point* (or *cut vertex*) is a node whose removal
    splits a connected component into two or more disjoint components. For example,
    the graph in [Figure 11-3](#fig11-3) has three articulation points: the shaded
    nodes 1, 2, and 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '![a graph with eight nodes. Nodes 1, 2, and 4 are shaded.](../images/f11003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A graph with three
    articulation points</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-4](#fig11-4) shows the impact of individually removing each of the
    articulation points in [Figure 11-3](#fig11-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the graph with node 1 removed. (B) shows the graph with node 2
    removed. (C) shows the graph with node 4 removed.](../images/f11004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The results of
    removing different articulation points</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-4(a)](#fig11-4), removing node 1 creates the components {0, 4,
    5} and {2, 3, 6, 7}. [Figure 11-4(b)](#fig11-4) shows that removing node 2 creates
    the components {0, 1, 4, 5} and {3, 6, 7}, while removing node 4 would create
    components {0, 1, 2, 3, 6, 7} and {5}, as shown in [Figure 11-4(c)](#fig11-4).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying the bridges and articulation points in a graph is essential for
    understanding single points of failure in a network. This section provides some
    real-world applications for finding bridges and articulation points. We first
    show how to apply these concepts to create a resilient ferry network, then examine
    how to extend the same techniques to prevent the spread of disease or construct
    optimal magical labyrinths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Resilient
    Networks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *resilient network* needs to be able to gracefully handle the loss of an individual
    edge or node without losing connectivity. To expand the island example from the
    previous section, let’s consider two hypothetical ferry networks among eight of
    the Hawaiian islands, as shown in [Figures 11-5](#fig11-5) and [11-6](#fig11-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A map of eight Hawaiian islands and seven edges forming a single connected
    component.](../images/f11005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: A map of hypothetical
    ferry routes among the Hawaiian islands</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-5](#fig11-5) shows a minimal ferry network needed to connect the
    eight islands. If all ferries are running without problems, it is possible to
    travel between any two islands. It might take multiple hops for someone to reach
    their destination, but there will be a path.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the network is fragile. If the ferry between O‘ahu (node 2) and Moloka‘i
    (node 3) breaks down, it splits the network in two. People can no longer travel
    from Maui (node 5) and Ni‘ihau (node 0). Each ferry route in the graph is a bridge.
    The loss of any single route would disconnect at least one island. Similarly,
    many of the nodes in [Figure 11-5](#fig11-5) are articulation points. If the ferry
    terminal in O‘ahu (node 2) is closed due to weather, it will disconnect Kaua‘i
    (node 1) from Maui (node 5).
  prefs: []
  type: TYPE_NORMAL
- en: By understanding their network’s bridges and articulation points, planners could
    design a more robust network with no bridges, as shown in [Figure 11-6](#fig11-6).
    A single broken ferry (removal of an edge) won’t cut off travel between any two
    islands. If the ferry between O‘ahu (node 2) and Moloka‘i (node 3) breaks down,
    for example, a traveler could still make their way from Maui (node 5) to Ni‘ihau
    (node 0) via other routes. The network also lacks articulation points. If the
    ferry terminal in Maui closes, for instance, it cuts off only that island.
  prefs: []
  type: TYPE_NORMAL
- en: '![A map of eight Hawaiian islands with 14 edges connecting the islands.](../images/f11006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: A second map of
    hypothetical ferry routes among the Hawaiian islands</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can extend these concepts beyond transportation systems to computer networks,
    power grids, communication networks, or wastewater systems. While it’s often preferable
    to construct graphs without bridges or articulation points, it’s not always feasible.
    However, understanding a network’s weaknesses may still be helpful for planning
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing the Spread
    of Diseases</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider how a common cold migrates through a social network. For simplicity’s
    sake, let’s assume you need to be in proximity to a sick person to catch the cold.
    You cannot catch the cold from someone you never see. If the edges represent real-world
    interactions between people, the virus can pass only between neighboring nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the concept of bridges and articulation points to model or stop
    the spread of disease. That coffee meeting with a former workmate acts as a bridge
    that allows the cold to jump between two otherwise disjoint sets of people: your
    previous and your current coworkers. A person who self-isolates and cuts off the
    spread of the virus between groups is an articulation point. By not going to any
    events for a few weeks, you can help prevent a cold from passing between your
    different social circles. Your running friends, the members of your data structures
    reading group, and your coworkers will each be limited to their own colds without
    sharing any through you.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing Magical
    Labyrinths</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to the previous two cases, where we want to minimize the bridges
    and articulation points, imagine an evil wizard deciding where to place the most
    effective traps in their labyrinth. A tunnel that serves as the only connection
    between two sections of the labyrinth is a bridge. If one section contains the
    labyrinth entrance and the other contains the goal, the wizard knows that thorough
    adventurers must pass through the tunnel, making it a great place for the best
    trap. Similarly, a room that must be traversed to move between two parts of the
    labyrinth is an articulation point—an ideal place to deploy high-level monsters.
  prefs: []
  type: TYPE_NORMAL
- en: In more common settings, we can use these same techniques to place tollbooths
    on critical highways (bridges) or information booths at the intersection of airport
    terminals (articulation points). In these cases, we use the fact that people traveling
    from one part of the graph to another must pass through this single node or edge.
    Understanding the connectivity of the graph thus lets us optimize potentially
    scarce or expensive resources.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Bridge-Finding Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The computer scientist Robert Tarjan proposed a range of useful algorithms for
    understanding graphs using the properties of their depth-first search trees. This
    section introduces a *bridge-finding algorithm* on undirected graphs that uses
    this approach. The algorithm starts a depth-first search from an arbitrary node
    and tracks both the edges used and the order in which the nodes are first visited
    (the *order index* or *preorder index*, denoted *order*(*u*)). We can use this
    information to look for bridges by asking whether an edge in the depth-first search
    tree provides the only path to reach the nodes in its subtree. Edges that do not
    appear in the depth-first search tree *T* can be immediately ruled out as bridges
    because we were already able to reach the nodes without using them. This means
    we need to consider only the edges in *T*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-7](#fig11-7) shows an example of a graph and two representations
    of its corresponding depth-first search tree rooted at node 0\. [Figure 11-7(a)](#fig11-7)
    shows the initial graph. [Figure 11-7(b)](#fig11-7) shows the corresponding depth-first
    search tree when starting from node 0; the number outside each node indicates
    the order index. [Figure 11-7(c)](#fig11-7) shows the same tree with the *untraversed
    edges* as dashed lines. These untraversed edges are called *back edges* and lead
    back to a node that has already been visited during the depth-first search.'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows an undirected graph with seven nodes and nine edges. (B) shows
    a tree built from this graph with root node 0\. Node 0 is labeled with order =
    0 and has two children: node 1 with order = 1, and node 3 with order = 5\. (C)
    shows the same tree as subfigure B with three additional dashed edges.](../images/f11007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: An undirected
    graph (a), a depth-first search tree (b), and the depth-first search tree with
    untraversed edges (c)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can identify bridges by looking for edges leading into a subtree of *T*,
    where that subtree’s nodes only have neighbors in the same subtree. In other words,
    if the edge (*v*, *u*) is a bridge, there is no way to get into or out of the
    subtree of node *u* except through the edge into (*v*, *u*). Edge (1, 6) in [Figure
    11-7(a)](#fig11-7) presents one such example, providing the only path into or
    out of the subtree rooted at node 6\. In contrast, the edge (0, 3) is not a bridge,
    because node 5 has an edge back to node 0.
  prefs: []
  type: TYPE_NORMAL
- en: The key to this algorithm is that we can look at the minimum and maximum order
    index in the neighborhoods of *u* and its descendants. By the properties of depth-first
    search, all the nodes in *u*’s subtree must have an order index in the range [*order*(*u*),
    *order*(*u*) + *K* − 1], where *K* is the number of nodes in the subtree (including
    *u*). This is because the search travels to those nodes after visiting *u* and
    before visiting nodes in other subtrees. If the nodes in *u*’s subtree have any
    neighbor with an order index outside that range, the edge to that neighbor would
    provide an alternate path into *u*’s subtree.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a common simplification by observing that any unvisited nodes reachable
    from the subtree would be explored by the depth-first search and thus would appear
    in the subtree. Therefore, we need to check only for back edges to neighbors with
    a lower order index. We can test whether edge (*v*, *u*), where *v* is the parent
    of *u*, is a bridge by checking if any node in *u*’s subtree has a neighbor *w*
    such that *order*(*w*) < *order*(*u*), excluding the connection (*v*, *u*) itself.
    If there is such a neighbor, we have found a back edge that bypasses (*v*, *u*)
    and know that (*v*, *u*) is not a bridge. Conversely, if *order*(*w*) ≥ *order*(*u*)
    for all the subtree’s neighbors *w* when excluding the connection (*v*, *u*),
    then (*v*, *u*) is a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Node 2 in [Figure 11-7](#fig11-7) provides an example of this case. The search
    reached node 2 via the edge (1, 2) and assigned it an order index of 2, as shown
    in [Figure 11-7(b)](#fig11-7). For edge (1, 2) to be a bridge, there must be no
    alternate path out of that subtree. However, node 2 itself has an edge to node
    0 (with order = 0), providing such an alternate route.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite case is shown in [Figure 11-8](#fig11-8) with edge (0, 1). The
    graph in [Figure 11-8(a)](#fig11-8) has a slight modification from the one in
    [Figure 11-7(a)](#fig11-7), the exclusion of edge (0, 2), which results in edge
    (0, 1) now being a bridge. [Figure 11-8(b)](#fig11-8) shows the corresponding
    depth-first search subtree rooted at node 0, with the untraversed edges in gray.
    The dotted ovals in both figures indicate the subtree of node 1\. As shown in
    [Figure 11-8(b)](#fig11-8), the only connection from the subtree of node 1 to
    a node with order less than 1 is the edge (0, 1) itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows an undirected graph with seven nodes and eight edges. (B) shows
    a tree built from this graph with root node 0 and additional gray edges.](../images/f11008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: An undirected
    graph (a) and a depth-first search tree (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The bridge-finding algorithm checks each subtree in the depth-first search tree
    by recording the lowest-order indices that neighbor any node in the subtree. The
    only adjacent edge we exclude is the link between the subtree root *u* and its
    parent, as this is the edge we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can implement the bridge-finding algorithm using a single pass of depth-first
    search. To simplify the code, we’ll use the helper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    to track information about the order in which the depth-first search reaches various
    nodes, including:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">parent</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node’s index to that of its parent in the depth-first search tree
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">next_order_index</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores the next order index
    to assign
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">order</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node’s index to its order index
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">lowest</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Maps
    each node to the *lowest* order index of any nodes in its depth-first search subtree
    or their immediate neighbors (excluding the node’s parent)
  prefs: []
  type: TYPE_NORMAL
- en: 'The data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    provides a wrapper for this information and saves us from having to pass many
    parameters to the search function. We can also use the object to perform basic
    assignments and updates. We define <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The constructor sets all the information to its initial values ❶. The code initializes
    all entries of the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">parent</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> in order to indicate
    that these values are unset for each node. It sets <samp class="SANS_TheSansMonoCd_W5Regular_11">next_order_index</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> in preparation for the
    first node.
  prefs: []
  type: TYPE_NORMAL
- en: The helper method <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>
    records the current node’s order index and increments the next one to assign.
    It also initializes the lowest order index seen for this node, which is initially
    the order index of the node itself ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a depth-first search adapted from those in [Chapter 4](chapter4.xhtml)
    to fill in the entries of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    and find the bridges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The recursive helper function <samp class="SANS_TheSansMonoCd_W5Regular_11">bridge_finding_dfs()</samp>
    starts by setting the current node’s order index and initial value for the lowest
    order index reachable in the subtree using the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_order_index()</samp>
    helper method ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The code then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to check each of the node’s neighbors. For consistency of ordering with other
    examples, we use the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp>
    to traverse the neighbors in order of their index, though traversing them in sorted
    order is not necessary for the correctness of the algorithm. If a neighbor has
    not been visited (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    value is unset) ❷, the code sets its parent and recursively explores it. After
    returning from the recursive call, the code checks whether it has found a smaller
    order index neighboring the subtree by comparing the child’s <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    entry with its own <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    entry ❸.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the search has finished exploring the depth-first search subtree
    rooted at <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>. It can
    check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">edge</samp> is a bridge
    by comparing the lowest-order index of any node in the subtree or its immediate
    neighbor with the order index of the subtree’s root ❹. The code appends new bridges
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If the neighbor has been seen (its <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    value is set), then the code first checks whether the neighbor is the parent node
    itself. If it is, then the edge under consideration was just traversed and the
    search ignores it. Otherwise, the code checks whether this neighbor represents
    a node outside the subtree by checking that neighbor’s order index ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_bridges()</samp> function
    provides a wrapper that sets up the statistics and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp>
    data structures, then starts the search(es). The code finds all bridges in each
    connected component by performing a single depth-first search from that component,
    using the approach adapted from [Listing 4-2](chapter4.xhtml#list4-2). Since each
    node is visited only once and each edge is examined at most twice (once in each
    direction), the cost of the full algorithm scales as |*V* | + |*E*|.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 11-9](#fig11-9) shows an example run of the bridge-finding algorithm
    on a graph with eight nodes. Each subfigure shows the state of the search after
    *completing* the visit to the circled node. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>’s
    lists <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp>
    are shown. The arrows indicate edges traversed so far and the dashed edges indicate
    ones that were seen by search but not traversed, while the bolded gray arrows
    are the bridges.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-9(a)](#fig11-9) shows the state of the algorithm after the search
    completes node 6\. At this point, it has initially visited and set a preorder
    index for nodes 0, 1, 2, 3, 7, and 6\. Nodes 4 and 5 are unvisited and thus do
    not have a preorder index. Similarly, the lower bounds correspond to the algorithm’s
    state after visiting only some of the visited node’s children. Node 6 has the
    final state of <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp> since
    the search has finished processing it. In contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest</samp>
    value of node 3 is not finalized because the algorithm has not finished searching
    its subtree.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-9(b)](#fig11-9), the search backtracks to node 7 and completes
    that node. During this process, the algorithm checks whether the edge (7, 6) could
    be a bridge. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[6]</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">order[6]</samp>, we
    know there is an alternate path out of the subtree (through node 2) and the edge
    is not a bridge.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a graph with eight nodes and the values in two arrays.
    In (A) node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4],
    and the low array contains [0,1, 2, 3, –1, –1, 2, 4].](../images/f11009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-9: The stages of
    the bridge-finding algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: By [Figure 11-9(e)](#fig11-9), the search has found the first bridge. While
    it has not finished processing node 1, it has fully searched the subtree rooted
    at node 2\. After returning from node 2, the algorithm finds that <samp class="SANS_TheSansMonoCd_W5Regular_11">lowest[2]</samp>
    is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">order[2]</samp>, indicating
    that the edge (1, 2) is the only path into or out of the subtree rooted at node
    2\. It adds (1, 2) to the list of bridges before moving on to the other children
    of node 1\. In [Figure 11-9(f)](#fig11-9), after finishing the subtree rooted
    at node 5, the search finds that the edge (4, 5) must be another bridge, as the
    removal of that edge disconnects node 5.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize this, imagine our evil wizard inspecting their newly created magical
    labyrinth. They start by walking the labyrinth, building a depth-first tree, and
    recording the preorder index of each room with a chalk marking on the wall. Each
    time they enter a new room, they recursively explore any unvisited neighboring
    rooms and poke their head into previously visited neighboring rooms to check the
    marks on the wall. When visiting the Room of Loose Ceiling Tiles they might see
    a new neighbor, the Room with the Ugly Carpet, and also find a connection back
    to the previously visited Room That Is Always Uncomfortably Warm. Throughout the
    process, they track the lowest number they have seen since entering each room.
  prefs: []
  type: TYPE_NORMAL
- en: After backtracking through each hallway, the wizard checks their notes to determine
    whether any of the rooms they just visited have a neighboring room with a preorder
    index less than the room at the far end of the hallway (the room that they just
    left when backtracking). After backtracking through their personal favorite, the
    Hallway of Excessive Chandeliers, the wizard effectively asks, “Is there another
    passage through which the adventurers could reach one of the rooms up ahead? Or
    do they have to go through the Hallway of Excessive Chandeliers?” If there is
    no alternate path, they can mark the Hallway of Excessive Chandeliers as a bridge,
    be happy in the knowledge that the adventurers will always get to see this opulently
    decorated passage, and also plan to deploy a good trap.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">An Algorithm for Finding Articulation
    Points</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can adapt the bridge-finding algorithm to identify articulation points by
    considering the roots of each subtree instead of the edges directly connected
    to them, using very similar logic. We identify articulation points by looking
    for a node *u* whose descendants in the depth-first search tree do not have a
    neighbor above *u* in that tree. An edge from a node outside the subtree of *u*
    to one of the descendants of *u* would provide the critical alternate path around
    *u*.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how to use the node’s subtrees to identify articulation points,
    consider the two cases shown in [Figure 11-10](#fig11-10). We map the depth-first
    search subtrees onto the original undirected graph with arrows and label each
    node with its order index. The current node under consideration is shaded and
    a dashed boundary marks the node’s descendants.
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A), nodes {2, 3, 6, 7} are circled. In (B), nodes {6, 7} are circled.](../images/f11010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-10: Two nodes and
    their subtrees in a graph’s depth-first search tree</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-10(a)](#fig11-10), the algorithm is considering node 1 and descendants
    {2, 3, 6, 7}. Removing node 1 would cut its descendants off from the rest of the
    graph. In contrast, node 3 is not an articulation point, as shown in [Figure 11-10(b)](#fig11-10).
    That node’s descendants include node 6, which has a link back to node 2 (outside
    the subtree of node 3). The edge (2, 6), although not included in the depth-first
    search tree, provides an alternate path to nodes 6 and 7 in the event node 3 is
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: This logic works for every node except the root node. Since the root node has
    no ancestors, we cannot use the same approach of checking the subtrees for back
    edges. Instead, we must look for cases where the root node has more than one subtree.
    As shown in the example graph in [Figure 11-11](#fig11-11), the root node will
    have multiple subtrees only if the graph has components that would be disconnected
    by the removal of the root node. If there were an edge joining the subtrees, the
    depth-first search would traverse that edge before returning to the root.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with seven nodes. Six of the edges are arrows, including (0, 1),
    (1, 2), and (1, 6). Three edges are dashed lines including (0, 2), (0, 5) and
    (1, 4).](../images/f11011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-11: A depth-first
    subtree where the root node is an articulation point</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the specialized root test with the lower bound tracking from
    the bridge-detection algorithm to identify the articulation points in a graph,
    as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As with the bridge-finding algorithm, we implement the *articulation-point-finding
    algorithm* with a single pass of depth-first search that completes both the search
    and the identification. We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    data structure track and update information about each node’s parent, order index,
    and lowest reachable order index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the code, we break the search into two functions. The first function
    handles the non-root nodes and performs the recursive exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The recursive function <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    performs the majority of the work for this algorithm. It starts by setting the
    current node’s order index and tentative lower bound ❶, then performs the depth-first
    search by iterating over each neighbor, checking whether it has been visited,
    and, if not, recursively exploring it.
  prefs: []
  type: TYPE_NORMAL
- en: The code tracks the lower bounds for the neighbors of any node in the subtree.
    For subtrees in the depth-first search tree (previously unexplored nodes), the
    code updates the lower bound based on the lowest neighbor of that entire subtree
    ❷. The logic for identifying articulation points takes place after this recursive
    exploration of each child. The code determines whether the subtree it just visited
    would be cut off by the removal of the *current* node by checking whether any
    node in that subtree contains a neighbor above the current node in the depth-first
    search tree ❸.
  prefs: []
  type: TYPE_NORMAL
- en: For neighbors that are not part of the depth-first search subtree (previously
    explored nodes) and are not the current node’s parent, the code compares the node’s
    lower bound to the neighbor’s order index ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the root node, we add some additional logic to track the number of subtrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp>
    function starts by setting the order index of the root and initializing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_subtrees</samp> counter. It then starts
    the depth-first search by iterating over each neighbor, checking if it has been
    visited ❶, and, if not, recursively exploring it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    function. Instead of using the lower bound logic in deciding whether the root
    is an articulation point, the code simply checks whether the root has two or more
    subtrees ❷. If so, it appends the root to the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for finding all articulation points consists of using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_root()</samp> function
    to run this search on each connected component in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_articulation_points()</samp>
    function starts by creating and initializing the data structures needed for the
    algorithm. Since the data structures are indexed by node and the different connected
    components are disjoint, the code can use a single <samp class="SANS_TheSansMonoCd_W5Regular_11">stats</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">results</samp> object for all
    connected components. The code then iterates over each node, checks whether it
    has been visited by a search ❶, and, if not, starts a new depth-first search from
    that node. It finishes by returning the list of all articulation points.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 11-12](#fig11-12) shows an illustration of the algorithm for finding
    articulation points. Each subfigure shows the state of the algorithm after *completing*
    the visit to the circled node. The edges tested are represented by an arrow if
    they are part of the depth-first search tree or a dashed line if they are not.
    Unexplored edges are solid gray lines, and the discovered articulation points
    are shaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a graph with eight nodes and the values in two arrays.
    In (A), node 6 is circled, the order array contains [0, 1, 2, 3, –1, –1, 5, 4],
    and the low array contains [0,1, 2, 3, –1, –1, 2, 4].](../images/f11012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-12: The stages of
    the articulation-point-finding algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the algorithm behavior represented in [Figure 11-12](#fig11-12)
    is the same as that in [Figure 11-9](#fig11-9). The order in which the nodes are
    explored and the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">DFSTreeStats</samp>
    at each step are identical. The difference in behavior arises where articulation
    points are detected in [Figure 11-12(d)](#fig11-12). The lowest-order index for
    any neighbor of the subtree rooted at node 3 is 2, the order index of the current
    node. We know that node 2 has at least one subtree without connections back to
    any of its ancestors, meaning that removing node 2 would disconnect that subtree.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12(e)](#fig11-12) is interesting because, although it shows the
    state after finishing node 5, the algorithm has already marked (the unfinished)
    node 1 as an articulation point due to performing the articulation point test
    after checking each subtree. Regardless of what happens while exploring the other
    descendants of node 1, we know that removing that node would disconnect the subtree
    rooted at node 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-12(h)](#fig11-12) shows the final step of the algorithm. At this
    point, the search has returned from the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">articulation_point_dfs()</samp>
    function and is testing the root. Instead of using the low boundary, it checks
    how many subtrees the root has, revealing that node 0 has a single depth-first
    search subtree. All nodes in the graph are reached through node 1 before the search
    returns to node 0\. Therefore, node 0 is not an articulation point.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bridges and articulation points are critical for understanding the structure
    of graphs, including their points of failure and bottlenecks. As we saw in the
    example use cases, these features apply to a variety of real-world problems, from
    incorporating redundant routes into airline networks to designing the ultimate
    magical labyrinth.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms introduced in this chapter provide practical methods for identifying
    these structural elements and using depth-first search trees and order indexes
    to determine which nodes are reachable via alternate paths. This again highlights
    the power and versatility of a simple depth-first search and shows how augmenting
    information like order indexes can provide deep insights into the overall structure
    of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter further extends our discussion of connectivity, this time considering
    directed graphs and the related concept of strongly connected components. We introduce
    an algorithm that builds off the ideas presented in this chapter of collecting
    statistics with depth-first search to understand the graph’s structure.
  prefs: []
  type: TYPE_NORMAL
