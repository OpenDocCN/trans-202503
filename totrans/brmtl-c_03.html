<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="19" id="Page_19"/>2</span><br/>
<span class="ChapterTitle">Introduction to the Integrated Development Environment</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">So far, we’ve used individual tools such as GCC, <code>make</code>, and a text editor to build our program. This has allowed you to see what each tool does and learn about the details of software development. Now you’ll learn about using an integrated development environment (IDE). The IDE is a program designed to take all those tools (and some others) and hide them behind one integrated interface.</p>
<p>The main advantage of this approach is that you can use one GUI-based tool to do everything. The major disadvantage is that it works well only if you behave the way the IDE expects you to behave. Also, it hides a great deal from you. For example, to get a linker map, you have to go through several layers of GUI and enter the map option in an obscure customization box.</p>
<p><span epub:type="pagebreak" title="20" id="Page_20"/>The IDE we’ll use in this book is the System Workbench for STM32 IDE. From its name, you can tell it was created for the STM32 microprocessors. An enhancement to a very popular IDE called Eclipse, it includes an editor, debugger, and compiler. It is especially powerful when it comes to debugging, because remotely debugging on a microcontroller involves a lot of tools, and the IDE makes them work together seamlessly.</p>
<p>To practice using the IDE, you’ll write the same “Hello World” program you wrote in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, only this time you will wrap every step of the process in a unified GUI. In one respect, the IDE makes things simpler by hiding the compiler and other tools from you. In other ways, it makes things more complex, because accessing those tools to tune them is more difficult. For example, if I want to add the flag <code>-Wextra</code> to the compiler command line without an IDE, all I do is edit the makefile. When using an IDE, I have to find the magic box in which I can enter this value (spoiler: it’s Project<span class="MenuArrow">▶</span>Properties and then C/C++ Build<span class="MenuArrow">▶</span>Settings<span class="MenuArrow">▶</span>Tool Settings<span class="MenuArrow">▶</span>GCC Compiler<span class="MenuArrow">▶</span>All Options).</p>
<h2 id="h1-501621c02-0001">Using System Workbench for STM32</h2>
<p class="BodyFirst">So far, we’ve used a text editor, a compiler called GCC,<em> </em>and a program called <code>make</code> to run the compiler. As we get into more complex programs, we’ll need a debugger as well.</p>
<p>The STM32 Workbench bundles all these tools into one integrated development environment that is built on the Eclipse IDE. In fact, it <em>is</em> Eclipse, with lots of special STM32 stuff added, and I’ll refer to it as such in the following discussion. We’ll get deeper into the STM32 side of things in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. For now, let’s explore the IDE by writing a “Hello World” program.</p>
<h3 id="h2-501621c02-0001">Starting the IDE</h3>
<p class="BodyFirst">If you followed the advice at the beginning of <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, you’ve already downloaded System Workbench for STM32. Install it using the instructions from the website. The standard installation creates a desktop icon and a startup menu item, so you should be able to start the IDE in the same way as any other program.</p>
<p>When first started, Eclipse asks for the location of your workspace. Enter the directory that will contain all the projects for this book. Next, Eclipse should display the Welcome screen. Dismiss the screen by clicking the close icon (the little X next to the tab).</p>
<p>A window should pop up indicating that the system is downloading additional tools for the ARM processor. When the system finishes, you should get a C/C++ view of an empty project, as shown <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>.</p>
<span epub:type="pagebreak" title="21" id="Page_21"/><figure>
<img src="image_fi/501621c02/f02001.png" alt="f02001" class=""/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: An empty project screen</p></figcaption>
</figure>
<p>Eclipse is the frontend for a <em>lot</em> of tools. Displaying them in an organized manner is quite a challenge. To cope with this, Eclipse uses the concept of views. A <em>view</em> is a window layout that is designed for a particular task. For example, a Java programmer might have a different view than that of a C programmer. Likewise, debugging requires a different view than coding.</p>
<p>The default view in this version of Eclipse is that of a C/C++ project. (You can change the view at any time by using the Window<span class="MenuArrow">▶</span>View menu.) On the left of the view is the Project Explorer (currently empty), which allows you to view your projects and their details. In the upper middle, you have a text editor. On the right is a window with three tabs: Outline, Build Targets, and Task List. We’ll go into them when we get to more complex projects.</p>
<p>At the bottom is a small, wide window with the tabs Problems, Tasks, Console, Properties, and Call Graph. The Problems window contains a list of the errors and warnings generated by the code in your current project. The Console window contains the output of the build process. The other tabs we’ll worry about when we start generating more complex programs.</p>
<h3 id="h2-501621c02-0002">Creating Hello World</h3>
<p class="BodyFirst">We will now create another “Hello World” project. You must take certain steps whenever you create a native C project (<em>native</em> means the program runs on the machine on which it was compiled; if you compile it on one machine and run it on another, that’s called <em>cross-compilation</em>), and this chapter goes through them in detail. You will be going through these steps a lot; so that you don’t have to remember them all, refer to the checklist in the <span class="xref" itemid="xref_target_appendix">appendix</span>.</p>
<p><span epub:type="pagebreak" title="22" id="Page_22"/>Start a new project by selecting <b>File</b><span class="MenuArrow">▶</span><b>New</b><span class="MenuArrow">▶</span><b>C Project </b>from the menu bar. This brings up the C Project dialog.</p>
<p>I’ve chosen the name <em>02.hello-ide</em> for our project, as it’s unique and descriptive. Project names can contain any character except spaces and special characters such as a forward slash (/), backslash (\), colon (:), and other characters that have special meaning for your filesystem. Letters, digits, dashes, dots, and underscores are okay.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Eclipse will let you create a project with a space in the name and then fail to properly build it, so don’t use spaces.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>For the project type, select <b>Hello World ANSI C Project</b>. For toolchains, select the toolchain for your operating system, as shown in <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a>. Click <b>Next</b>.</p>
<figure>
<img src="image_fi/501621c02/f02002.png" alt="f02002" class=""/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: The project creation dialog</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>We now see the Basic Settings dialog. Leave these settings alone and click <b>Next</b>.</p>
<p>The next dialog is Select Configurations (see <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a>).</p>
<figure>
<img src="image_fi/501621c02/f02003.png" alt="f02003" class=""/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: The Select Configurations dialog</p></figcaption>
</figure>
<p>You have a lot of different options for building your project. Eclipse groups these into project configurations. The two defined by default are Release and Debug. Release produces highly optimized code that is difficult if not impossible to debug. Debug produces unoptimized, easy-to-debug code and generates debug symbols. Since you are learning, we’ll stick with the Debug configuration. Deselect the <b>Release</b> configuration, leaving only <b>Debug</b> selected, and click <b>Finish</b>.</p>
<p><span epub:type="pagebreak" title="24" id="Page_24"/>The IDE creates our project and generates a number of files. One of these is our source code, already filled in with its version of a “Hello World” program (see <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a>).</p>
<figure>
<img src="image_fi/501621c02/f02004.png" alt="f02004" class=""/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: The result of creating our “Hello World” project</p></figcaption>
</figure>
<p>If you enter any code yourself, note that the Eclipse editor uses a tab size of 4 by default, which means that when you use a tab to indent a line in source code, the tab will have a width of four spaces. Practically every other editor and tool uses eight spaces. You can fix this with one of the configuration items in Window<span class="MenuArrow">▶</span>Preferences. (Telling you how to further customize Eclipse would take a whole book, and this is not that book.)</p>
<p>At this point we would be done—if we were writing in Java. Eclipse was designed for Java. C is an add-on that <em>almost</em> completely works. We have to do one more fix-up.</p>
<p>First, compile the project by choosing <b>Project</b><span class="MenuArrow">▶</span><b>Build Project</b>. Then select <b>Run</b><span class="MenuArrow">▶</span><b>Run Configurations</b>, which should bring up the Run Configurations dialog. Next, click <b>C/C++ Application</b> on the left side, and then click the small icon on the left of the icon row to create a new configuration. Finally, under C/C++ Application, click <b>Browse</b>, as shown in <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a>.</p>
<p>Use the file browser to find your executable in the <em>Debug</em> directory. The IDE has created a project directory for you in your workspace (the location of which is system-dependent) that has the same name as your project. All the files for your project are in this directory. Within the project directory, a <em>Debug</em> directory contains all the files built as part of the Debug build (the only type of build we are doing). Within that directory, you’ll find <em>02.hello-ide</em> on <span epub:type="pagebreak" title="25" id="Page_25"/>macOS and Linux or <em>02.hello-ide.exe</em> on Windows. Select this file, as shown <a href="#figure2-6" id="figureanchor2-6">Figure 2-6</a>, and then click <b>OK</b>.</p>
<figure>
<img src="image_fi/501621c02/f02005.png" alt="f02005" class=""/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: The Run Configurations dialog</p></figcaption>
</figure>
<figure>
<img src="image_fi/501621c02/f02006.png" alt="f02006" class=""/>
<figcaption><p><a id="figure2-6">Figure 2-6</a>: The Application Selection dialog</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>Next, click <b>Apply</b> and <b>Close</b> to finish the run configuration. This setup tells the IDE where your program is actually located. (Since it decided where to put it, you’d think it would know where it went, but for some reason it doesn’t.)</p>
<p>Now let’s actually run the program. Select <b>Run</b><span class="MenuArrow">▶</span><b>Run</b>. The results should appear in the Console window, as shown in <a href="#figure2-7" id="figureanchor2-7">Figure 2-7</a>.</p>
<figure>
<img src="image_fi/501621c02/f02007.png" alt="f02007" class=""/>
<figcaption><p><a id="figure2-7">Figure 2-7</a>: The results of our program</p></figcaption>
</figure>
<h3 id="h2-501621c02-0003">Debugging the Program</h3>
<p class="BodyFirst">Now for a quick introduction to the <em>debugger</em>, which watches our program execute and lets us see what’s going on inside it. First, let’s generate a little more code to debug by duplicating line 15 (<code>puts("!!!Hello World!!!");</code>) and then save the project by choosing <b>File</b><span class="MenuArrow">▶</span><b>Save All</b>.</p>
<p>It is important to choose File<span class="MenuArrow">▶</span>Save All after each edit. If you were to run the program now, before saving all files, the compiler would see the old, unsaved file on disk and compile it. The resulting program would print <code>!!!Hello World!!!</code> only once instead of twice, which could get very confusing. The code we have in front of us is correct; the code we are running is not. Until you choose File<span class="MenuArrow">▶</span>Save All, the files are not the same. (End of soapbox mode.)</p>
<p>Now let’s start the debugger with <b>Run</b><span class="MenuArrow">▶</span><b>Debug</b> (see <a href="#figure2-8" id="figureanchor2-8">Figure 2-8</a>).</p>
<span epub:type="pagebreak" title="27" id="Page_27"/><figure>
<img src="image_fi/501621c02/f02008.png" alt="f02008" class=""/>
<figcaption><p><a id="figure2-8">Figure 2-8</a>: Starting the debugger</p></figcaption>
</figure>
<p>The IDE is about to switch into debugging mode, which changes the perspective from development to debugging. This means a whole new window arrangement. The system warns you that this is about to happen, as shown in <a href="#figure2-9" id="figureanchor2-9">Figure 2-9</a>. (Remember that you can always switch perspectives with the command Window<span class="MenuArrow">▶</span>Perspective<span class="MenuArrow">▶</span>C/C++ or Window<span class="MenuArrow">▶</span>Perspective<span class="MenuArrow">▶</span>Debug.)</p>
<figure>
<img src="image_fi/501621c02/f02009.png" alt="f02009" class=""/>
<figcaption><p><a id="figure2-9">Figure 2-9</a>: The debug perspective warning</p></figcaption>
</figure>
<p>Click <b>Yes</b> in the warning. The debug perspective should open, as shown in <a href="#figure2-10" id="figureanchor2-10">Figure 2-10</a>.</p>
<figure>
<span epub:type="pagebreak" title="28" id="Page_28"/>
<img src="image_fi/501621c02/f02010.png" alt="f02010" class=""/>
<figcaption><p><a id="figure2-10">Figure 2-10</a>: The debug perspective</p></figcaption>
</figure>
<p>In the upper left is the Stack Trace<b> </b>window, which shows the program being executed and how far into it you are. This information will become more useful when we discuss stack usage in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>
<p>Next to that is the Variables/Breakpoints/Registers/I/O Registers/Modules window, which contains the following:</p>
<ol class="none">
<li><b>Variables </b>Information about the program’s variables. (More on this starting with <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.)</li>
<li><b>Breakpoints </b>A <em>breakpoint</em> is a location in your program at which the program stops and lets the debugger examine it. You can set a breakpoint by double-clicking the line number of an executable line in your program. We’ll start using them in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</li>
<li><b>Registers </b>Information about the current state of the processor’s registers. (Discussed in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>.)</li>
<li><b>Modules </b>The dynamically linked modules. Since this feature is not available to embedded programmers, we won’t be discussing it.</li>
</ol>
<p>In the middle of the screen, the Source window displays our program. The highlighted line of code indicates that the debugger has run the program up to this line and stopped.</p>
<p><span epub:type="pagebreak" title="29" id="Page_29"/>Next to the Source window is the Outline panel. This is like a table of contents indicating which files go into our program. I’ve included the files <em>stdio.h </em>and <em>stdlib.h</em> so that they show up here.</p>
<p>Across the bottom is the Console/Tasks/Problems/Executables/Memory window. The Console window displays the output from the program. All the other tabs contain information we’re not interested in.</p>
<p>Now we’ll <em>step through</em> the program, meaning we will execute one statement at a time using the debugger. Click the Step Over icon at the top of the screen (see <a href="#figure2-11" id="figureanchor2-11">Figure 2-11</a>) or press F6 to step over the current line.</p>
<figure>
<img src="image_fi/501621c02/f02011.png" alt="f02011" class=""/>
<figcaption><p><a id="figure2-11">Figure 2-11</a>: Step Over (F6)</p></figcaption>
</figure>
<p>The highlighted line in the Source window advances one line, and <code>!!!Hello World!!!</code> appears in the Console window (see <a href="#figure2-12" id="figureanchor2-12">Figure 2-12</a>).</p>
<figure>
<img src="image_fi/501621c02/f02012.png" alt="f02012" class=""/>
<figcaption><p><a id="figure2-12">Figure 2-12</a>: Single-step results</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="30" id="Page_30"/>If you keep stepping, you’ll see the second <code>puts</code> executed, followed by the <code>return</code><b> </b>statement. After that, the program goes into the system library to do cleanup work. Since we don’t have the source code for this library, the debugger can display no information about it.</p>
<p>There are two other significant icons on the toolbar (see <a href="#figure2-13" id="figureanchor2-13">Figure 2-13</a>). The Resume icon (or F8 key) runs the program until it finishes or hits a breakpoint. The Debug icon restarts debugging.</p>

<figure>
<img src="image_fi/501621c02/f02013.png" alt="f02013" class=""/>
<figcaption><p><a id="figure2-13">Figure 2-13</a>: Debugging commands</p></figcaption>
</figure>
<p>We’ll make use of the debugger a lot in coming chapters. It will provide a very useful way of getting information out of our running program and seeing what’s going on. To return to the original C/C++ perspective, select <b>Window</b><span class="MenuArrow">▶</span> <b>Perspective</b><span class="MenuArrow">▶</span><b>Open Perspective</b><span class="MenuArrow">▶</span><b>C++</b>.</p>
<h2 id="h1-501621c02-0002">What the IDE Did for Us</h2>
<p class="BodyFirst">The IDE generated the C source file, including the <code>puts</code> functions, to print “Hello World.” It also generated a file called <em>Debug/makefile</em>, which is used as input to the <code>make</code> program. <a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a> contains an excerpt from this file.</p>
<pre><code>###########################################################################
# Automatically-generated file. Do not edit!
###########################################################################

-include ../makefile.init

RM := rm -rf

# All of the sources participating in the build are defined here
-include <span class="CodeAnnotationCode" aria-label="annotation1">1</span> sources.mk
-include src/subdir.mk
-include subdir.mk
-include <span class="CodeAnnotationCode" aria-label="annotation2">2</span> objects.mk

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(strip $(C_DEPS)),)
-include $(C_DEPS)
endif
endif

-include ../makefile.defs

# Add inputs and outputs from these tool invocations to the build variables

<span epub:type="pagebreak" title="31" id="Page_31"/># All Target
all: 02.hello-ide</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: An excerpt from <em>Debug/makefile</em></p>
<p>This makefile is located in the <em>Debug</em> directory. The IDE supports multiple build configurations and generates a makefile in a different directory for each of them. (For this project, we created only a Debug configuration. Other projects may also use a Release configuration.)</p>
<p>The makefile is more complex than the one we generated ourselves in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> because the IDE uses lots and lots of advanced <code>make</code> syntax. The IDE also generated the files <em>sources.mk</em> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <em>objects.mk</em> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which are included in the makefile. What we can see from these files is that computer-generated stuff is designed to be very flexible at the cost of making the thing nearly impossible to read.</p>
<p>As it stands now, the IDE does not generate or download a lot of data. But when we start to do embedded programming, this will change dramatically.</p>
<h2 id="h1-501621c02-0003">Importing the Book’s Programming Examples</h2>
<p class="BodyFirst">The programming examples used in this book can be downloaded at <a href="https://nostarch.com/bare-metal-c." class="LinkURL">https://nostarch.com/bare-metal-c.</a> To use the downloaded programming examples, you’ll need to import them. (You can’t just stick the files in your workspace; that would be too easy.) To perform an import, use the following steps:</p>
<ol class="decimal">
<li value="1">Select <b>File</b><span class="MenuArrow">▶</span><b>Import</b>.</li>
<li value="2">In the Import dialog, select <b>General</b><span class="MenuArrow">▶</span><b>Existing Projects into Workspace</b>.</li>
<li value="3">Click <b>Next</b>.</li>
<li value="4">Select the radio button <b>Select Archive File</b> and then click <b>Browse</b> after the blank space to select the file containing the project (the one you downloaded from the website).</li>
<li value="5">Click <b>Finish</b>.</li>
</ol>
<h2 id="h1-501621c02-0004">Summary</h2>
<p class="BodyFirst">The IDE is a mixed blessing. On the one hand, you don’t have to worry about all the tools that it takes to create a program. You didn’t have to create the makefile, manually perform the build, or run the debugger.</p>
<p>But this hands-off approach comes with a price. To add a compile-time flag to your program from <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, you just add the flag to the makefile. With the IDE, you can’t do this, because the IDE generates the makefile on its own. You have to find the right configuration item to do it in the IDE, and, as we will discover, the IDE has a lot of options.</p>
<p><span epub:type="pagebreak" title="32" id="Page_32"/>In this book I try to keep things as simple as possible through the use of checklists (like the one in the <span class="xref" itemid="xref_target_appendix">appendix</span>) and standard procedures. Eclipse tries to take care of everything, but you will occasionally need to tweak things under the hood.</p>
<h2 id="h1-501621c02-0005">Programming Problems</h2>
<ol class="decimal">
<li value="1">Find out what happens when you put <code>\t</code> in a string to be printed.</li>
<li value="2">In <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, we used <code>printf</code> to print the message. In this chapter, Eclipse uses <code>puts</code>. Look up the documentation of these functions to see how they are different.</li>
</ol>
<h2 id="h1-501621c02-0006">Questions</h2>
<ol class="decimal">
<li value="1">What is an IDE?</li>
<li value="2">What are the files generated by our IDE, and what do they contain?</li>
<li value="3">Where can you get help with using C and Eclipse?</li>
</ol>
</section>
</body></html>