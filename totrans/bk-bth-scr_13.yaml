- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 12 OUTPUTS, REDIRECTION, AND PIPING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now do quite a bit with Batch, such as setting, resetting, and interrogating
    variables of various data types, calling routines and other bat files, and performing
    arithmetic; however, most of what you’ve learned will have no lasting effect (except
    for file movements and the ability to set variables persistently). At the end
    of a bat file’s ephemeral execution, all of the bits and bytes that’ve been manipulated
    may vanish into the ether, and it’ll be as if the bat file had never existed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll leave the metaphysics of Batch for another time, but whenever code of
    any type is executed, the intent is to effect some sort of change. Some coders
    will use Batch simply as a wrapper, setting a few variables before calling an
    executable that’ll bring about that change, but Batch can do much more. In this
    chapter, I’ll discuss two general types of output: output from the interpreter
    (stdout and stderr) and output from you, the coder. After learning the distinction,
    you’ll be able to write the different types of output to the console, new files,
    and existing files. In this way, you can store the product of all those variables,
    calls, and arithmetic on your computer.'
  prefs: []
  type: TYPE_NORMAL
- en: The discussion about the two types of output will lead to a couple of related
    and interesting topics. One is the redirection of the output of any Batch command
    to a file, and the other is piping, the technique of sending output from one command
    into another command. Maybe most important, you’ll learn what exactly is scrolling
    by so quickly on the console and how to manage it—that is, either save or suppress
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter-Generated vs. Coder-Generated Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you open or execute a bat file, it creates two general types of outputs:
    interpreter-generated and coder-generated. To be perfectly clear, the interpreter
    technically creates all of the output, but some of that output is the result of
    commands entered by you, the coder, to write something to the console or a file.
    That’s *coder-generated output*. As a byproduct of the run, the interpreter is
    also creating output that you didn’t explicitly request. That’s *interpreter-generated
    output*.'
  prefs: []
  type: TYPE_NORMAL
- en: All Batch commands create interpreter-generated output; a few also create coder-generated
    output. By default, Batch writes both types of output to the console, and if the
    bat file is even moderately complex, the text scrolls by in a jumble that’s too
    fast to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The echo command is a great example of one that generates both general types
    of output, and in its simplest manifestation, it writes all of its arguments to
    the console. Consider this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The execution of this command writes the output shown in [Listing 12-1](#Lis12-1)
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Output generated by the interpreter and the coder'
  prefs: []
  type: TYPE_NORMAL
- en: The desired text, Greetings, Earthlings., is output, but it isn’t alone and
    appears twice, with the current directory prepended to the first line for some
    reason. (I’ll assume that the current directory is *C:\Batch\* throughout this
    chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: The two lines in [Listing 12-1](#Lis12-1) represent entirely different types
    of outputs. The second line is from the coder—a message written to the console
    with the echo command. The interpreter generates the first line. It isn’t the
    output of the echo command; it’s a *report of the execution* of the echo command.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction is as subtle as it is important. The interpreter, at a minimum,
    logs the execution of every command by writing it, prepended with the prompt.
    By default, the prompt is the current directory followed by a greater-than sign.
    Many commands produce additional interpreter-generated output, such as the xcopy
    command, which often produces a list of the files copied.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the intermingled output is a mess, and if this example doesn’t look
    like a mess, that’s because I’m showing the output from only a single command.
    Before long, I’ll show you how to clean up the console by sending these distinct
    outputs to different destinations, but first you’ll need to better understand
    the interpreter-generated output, which itself is actually two different outputs.
  prefs: []
  type: TYPE_NORMAL
- en: stdout and stderr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Batch writes every bit of interpreter-generated output to one of two data streams.
    A *data stream* is a transmission of information from a source—in this case, the
    interpreter—to a destination, which by default is the console. A file descriptor
    represents each data stream, and the most voluminous by far is the stream described
    as *stdout*, pronounced *standard out* (or less frequently, *standard output*).
    In fact, the only interpreter-generated output not found in stdout are error messages,
    which are written to the file descriptor *stderr*, pronounced *standard error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stdout data stream can become dense and cryptic, but it’s often invaluable
    to help you determine what exactly transpired during a bat file’s execution. You
    can often see the results of if commands, what files were created, and much more.
    To demonstrate, the following del command deletes a file and is followed by a
    set command that captures errorlevel as the return code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nothing here creates coder-generated output; all output comes from the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the *DeleteMe.txt* file exists, the previous code deletes it and writes
    the following to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Most variables are resolved in stdout, such as errorlevel being resolved to
    0 in this example. (Frustratingly, the interpreter fails to resolve variables
    fully in certain situations, such as when using delayed expansion. See [Chapter
    31](chapter31.xhtml) for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Interspersed with stdout can be the second type of interpreter-generated output,
    the output written to the stderr data stream, but only if there are any errors,
    of course. If, for instance, the file in the del command doesn’t exist, the interpreter
    outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first and last lines are written to stdout, but the middle line stating
    that the file couldn’t be found is written to stderr. It’s important to understand
    that error messages are written to stderr, while all other interpreter-generated
    output goes to stdout. Both are needed to get a full picture of what happened
    during a bat file’s execution, and unless we do something to intervene, both are
    written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: (By the way, let’s not quibble over why the return code is 0 even if an error
    message is generated. But if we must, the file doesn’t exist after the del command
    completes, so in a certain prosaic sense, it was successful, or it’s a bug.)
  prefs: []
  type: TYPE_NORMAL
- en: Writing Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating, writing to, and appending to files are basic functions of most coding
    languages, and Batch allows you to build files with both coder- and interpreter-generated
    output. Up until now, all of the output that you have seen has been written to
    the console, and when the bat file completes, the window closes.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you’ll want to create files that persist beyond the life of the bat file’s
    execution. You can write data to a file to use as input to an executable or even
    another bat file. If I want a record of how often others run one of my bat files,
    I’ll set it up to write one record to a central logfile with information about
    when and on what server it ran. You can even build reports, and capturing the
    interpreter-generated output into a file provides you with a great audit trail
    of exactly what transpired during the bat file’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: From Coder-Generated Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ve shown that we can write text to the console with the > con syntax. With
    a similar syntax, we can write to a file with two commands: the familiar echo
    command writes a record, and the not-so-familiar type command writes an entire
    file to another file.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Record to a File
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s return to the extraterrestrials. Instead of greeting us via the console,
    they might want to enter their greeting into a simple text file, and they can
    accomplish this with a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code has four distinct elements. The first is the echo command,
    and the second is the command’s argument: the Greetings, Earthlings. text. The
    third element is the greater-than sign (>), or redirection character. This character
    redirects the output of the command preceding it to the target, which is the fourth
    element: the *C:\Batch\ET.txt* file. Putting it all together, the previous statement
    writes the one line of greeting to the text file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following alternative syntax performs the identical task, but it’s easier
    to read because the message no longer abuts the greater-than sign as it did in
    the previous example. I’ve moved the redirection character to the fore, again
    followed by the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you replace the path and filename in this example with con, you’ll recognize
    the familiar syntax for writing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the appeal of this syntax. If the aliens
    have more than one line to communicate, they can set the target file path and
    name to a variable and use it in successive echo commands. This syntax allows
    for multiple usages of the redirection, target, and echo command to be lined up
    in an orderly fashion, making it easier to read what’s being written to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on, I snuck a couple of subtle yet important features into the
    previous code. The first echo command has a single greater-than sign for the redirection,
    while the subsequent commands each use two greater-than signs. The single character
    operator creates a new file with its text, deleting the current file of that name
    if it exists. The two-character operator appends to an existing file. A rookie
    mistake is to use a single greater-than sign for multiple commands, leaving the
    novice Batch coder wondering why only the last of several commands worked, when
    they all actually worked, each wiping out the existing file and writing a single
    line of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important feature is the echo command followed immediately by a dot;
    it’ll write a blank line, not a dot. After this code executes, the complete contents
    of *ET.txt* contain these three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you ever need to write a single dot on a line, leave a space between echo
    and the dot.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a File to a File
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another useful command that you can couple with redirection is the type command.
    Used alone, the command writes out, or types, the complete contents of a file
    to stdout and the console. With redirection, it can insert the full contents of
    that file into another file. The following example writes the contents of *DetailRecs.txt*
    to *OutFile.txt*, prepended with a header record and appended with a trailer record
    via a couple echo commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that only the first echo command has the single character redirection
    operator, thus ensuring that it’s truly a header record.
  prefs: []
  type: TYPE_NORMAL
- en: From Interpreter-Generated Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now know that the mess scrolling by on the console is mostly stdout with
    the possibility of some stderr and coder-generated output. You can also control
    the destination (console or file) of the coder-generated output. The missing piece
    is what to do about the interpreter-generated output. By default, it’s sent to
    the console, but with a modicum of effort, you can write everything the interpreter
    generates to a file, commonly called a *trace file*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to redirect the output of the echo
    and type commands to a file, but you can redirect the output of any command, in
    particular the call command. In [Chapter 10](chapter10.xhtml), I introduced the
    concept of calling routines within a bat file, so you can create a routine containing
    the bat file’s main logic and call it at the top of the file. What’s new here
    is the redirection operator and the trace file appended to the first line in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a complete bat file that writes the greeting to the console and captures
    the trace file.
  prefs: []
  type: TYPE_NORMAL
- en: The at symbol (@) prefixing the first command suppresses the call command itself
    from the console, but not the call command’s output. Critically, the output from
    the call command is the stdout coming out of the called routine, and that output
    is redirected via the greater-than sign in the first line away from the console
    and to the trace file. Notice that the greeting itself at the bottom of the file
    is explicitly being sent to the console with > con prefixing each of the three
    echo commands. Without the redirection, the greeting would’ve been written to
    the trace file with the rest of stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each data stream has a reference or numerical handle so that you can refer
    to one or the other with minimal keystrokes. The reference for stdout is 1, and
    placing that reference number before the redirection character explicitly diverts
    stdout to the trace file. But stdout is redirected by default with the greater-than
    sign alone, so the following two commands are functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In both commands, stdout alone is written to the trace file, and any error messages
    from stderr will end up being displayed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stderr data stream is referenced by 2, so you can redirect these error
    messages instead with this one-byte modification prior to the redirection symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even redirect each data stream, stdout and stderr, to entirely different
    files at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In practice, separating the data streams is rarely useful as any error messages
    won’t be tied to the commands that generated them.
  prefs: []
  type: TYPE_NORMAL
- en: A far superior solution, shown in [Listing 12-2](#Lis12-2), is to write both
    outputs to the trace file, and that’s accomplished with this particularly esoteric
    syntax at the end of the command including 2 and 1, for stderr and stdout, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: The ideal technique to redirect stdout and stderr to a trace
    file'
  prefs: []
  type: TYPE_NORMAL
- en: As you are aware, the ampersand (&) is the command separator used to execute
    two commands coded on a single line. But used in the manner shown in [Listing
    12-2](#Lis12-2), the interpreter treats the ampersand simply as part of the redirection
    syntax. Just chalk this up as another batveat and don’t ask why, but it’s the
    best technique for capturing a trace file.
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing stdout and stderr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can watch stdout and stderr scroll by on the console, or you can save both
    data streams to a trace file. In other situations, this data simply isn’t needed
    at all. It might not be worth the disk space to create a log of every execution
    of a stable and frequently run process, and you might not even want stdout and
    stderr written to the console because you want it uncluttered for any coder-generated
    output. In such cases, you’ll want to outright suppress the interpreter-generated
    output. Two techniques work; one is simple but works only on stdout, while the
    slightly more complex technique also works on stderr.
  prefs: []
  type: TYPE_NORMAL
- en: The @echo off Technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simple technique to suppress stdout is with the @echo off command. Based
    on what you’ve learned about the echo command, you might expect this particular
    command to write off to stdout. Afterall, echo Hello writes Hello to stdout. Usually,
    echo writes out its arguments, but there are two exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The off argument instructs the interpreter to suppress (or turn off) stdout,
    and the on argument turns it back on, with one catch. The echo command to suppress
    stdout is itself written to stdout. Fortunately, Batch allows for the suppression
    of any single command’s contribution to stdout simply by prepending it with the
    at symbol (@). Hence, the command to suppress stdout that is itself suppressed
    is @echo off. I quietly introduced this technique in [Chapter 2](chapter2.xhtml)
    to clean up the console but sidestepped a deeper explanation for later (which
    is now).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the extraterrestrials were to communicate with us via the console, this
    simple bat file would do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first echo suppresses stdout so as to keep the console uncluttered and
    readable. Try this bat file without that first line to see the difference. It’s
    ugly; each echo command generates both general types of output to the console.
    With this command in place, the second echo command writes only its arguments
    to the console. The echo command followed immediately by a dot writes a blank
    line. Finally, the pause command keeps the window open so that it doesn’t disappear
    in a flash. The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Press any key, and the pause command allows the bat file to continue, closing
    the window. In [Chapter 3](chapter3.xhtml), I mentioned that I start every high-level
    bat file with a setlocal command that enables command extensions and delayed expansion.
    This echo command is the only command that might come before that setlocal, thus
    keeping the console pristine. However, you also can prepend the setlocal command
    itself with an at symbol to suppress its execution from stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, every novice Batch coder will likely try to write a blank line
    with nothing but spaces following the echo command, even if only by accident.
    But that command simply writes out the state of the echo, which is either on or
    off. For instance, executing the following two lines at the beginning of a bat
    file writes ECHO is off. to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, replacing the first line with echo on activates stdout, resulting
    in ECHO is on. as the output.
  prefs: []
  type: TYPE_NORMAL
- en: The @echo off technique has one more catch. While stdout is suppressed, stderr
    is unaffected, which means that any unredirected error messages will appear on
    the console with little or no context.
  prefs: []
  type: TYPE_NORMAL
- en: The Redirection to nul Technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best technique for suppressing all interpreter-generated output is to redirect
    stdout and stderr to the *nul* file introduced in [Chapter 7](chapter7.xhtml).
    This file is always empty, regardless of what’s written to it, making it something
    of a Batch trash receptacle. For instance, reworking the call command from [Listing
    12-2](#Lis12-2) to send stdout and stderr to *nul* instead of a trace file effectively
    suppresses all interpreter-generated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, the name of the routine is now a misnomer. (Rename the label :SuppressTrace
    if you must.)
  prefs: []
  type: TYPE_NORMAL
- en: This technique does require that you create a routine for the mainline logic,
    but it’s very effective, it’s relatively simple, and you can use it to suppress
    all the interpreter-generated output of called bat files as well as routines.
    The leading at sign even suppresses the call command itself from stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this technique to suppress the output of any command. For instance,
    the following executes the compiled program, while simply discarding its command
    line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Prepending (or even appending) the program execution with a redirection to the
    *nul* file resolves the issue nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Remarks in stdout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve one last remark about stdout. In [Chapter 2](chapter2.xhtml), I introduced
    the rem command as a simple means of entering a remark or comment into the code.
    An alternative syntax exists and has ramifications for stdout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remarks generated with the rem command are written to stdout. However, any
    line in the code preceded with two colons (::) is also treated as a remark, but
    it’s a hidden remark suppressed from stdout. Consider these two valid remarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find only the first remark in stdout. Also notice that the dual colons
    don’t require a space before the remark text. In [Chapter 9](chapter9.xhtml),
    I mentioned that labels must start with a colon, but the second character must
    be a different character. This is because the double colons signify a hidden remark.
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing nefarious about a hidden remark. Remarks that explain the code
    can be useful in stdout, but others might muddy it up. This is a great technique
    for coders to keep notes for themselves in the code, and only in the code. For
    instance, it’s always good to maintain a detailed history of revisions in the
    source code, but those details might just make a mess of the trace file. If so,
    use double colons for such remarks.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection of Any Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve shown that redirection of the echo, type, and call commands can write
    output to a file, but those are just three examples. You can redirect the output
    of any Batch command. To take just one example, you can send output of the following
    xcopy command to a logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The *.dat* files are copied to *D:\Backup\* with or without the redirection,
    but the interpreter now appends the resulting text that lists all of the files
    just copied along with a total count to the *Copy.log* file. It’s appended because
    of the two greater-than signs; the single character operator would have created
    a new file with the output.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can perform redirection for any command, many don’t have output
    or have drab output not worth capturing. In the next chapter, I’ll introduce the
    dir command, which writes details about all the files and subfolders in a directory
    to stdout. That’s the type of information that’s easily and often redirected to
    a file. Command line output from a compiled program is another example of data
    often worth capturing.
  prefs: []
  type: TYPE_NORMAL
- en: Piping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redirection typically sends output to a file, but piping sends output to an
    entirely different destination. *Piping* is the concept of joining two distinct
    commands. The interpreter sends the output of the first command to the second
    command as input via some sort of a tube, hose, duct, conduit, or ... there’s
    a better metaphor for a physical conveyance, oh ... a pipe. The character used
    to make this connection is, appropriately enough, the pipe character, also called
    the vertical bar or upright slash. On most keyboards, it’s above ENTER, and you
    press SHIFT-\ to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this point you’ve seen the results of the echo command redirected to the
    console, stdout, or a particular file, but you also can pipe those results to
    other Batch commands. Recall the xcopy command from [Chapter 7](chapter7.xhtml)
    that, as part of the copy, gave the destination file a different name from the
    source file. At the time, I warned that such a command sometimes fails, and I
    promised a solution in this chapter, and that solution is piping. The following
    command certainly appears to be a straightforward copy with a renamed destination
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *NewName.txt* file exists at the target path, this command simply overlays
    the file and moves on. But due to the vagaries of Batch (or less diplomatically,
    a possible bug), if *NewName.txt* doesn’t exist, the interpreter gets a bit confused.
    The source file is clearly *OldName.txt*, but is *NewName.txt* the name of the
    destination file or the destination folder? The *.txt* extension should make it
    obvious to the interpreter, but directory names can include dots. (But shame on
    anyone who would give a folder name a typical file extension.) When the interpreter
    gets confused, it does what a lost human should do; it asks directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you had typed the xcopy command into a command prompt and seen that message
    written to the console, undoubtedly you would’ve simply entered F and been done
    with it. The same would’ve been true if the stdout of a bat file had gone to the
    console, but when this command is in a bat file with a redirected stdout, the
    interpreter essentially asks the trace file for a response and waits in perpetuity.
    At some point someone will investigate the long-running execution, scroll down
    to the bottom of the trace file, and find the text in the previous example. This
    is what coders call a *hang*; it’s worse than an abort because the execution never
    ends. The cause can be an endless loop, but in this case, the cause is the interpreter
    asking for a response from an entity that cannot respond. The only human response
    is to kill the command window, find and correct the issue, and rerun.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to respond programmatically with an answer in real time is to
    anticipate the question and code for it before the bat file ever executes. To
    this end, I’ll precede the xcopy command with a response from an echo command.
    The following echo F command is simply writing F, the response for file, and that
    response is piped as input to the xcopy command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now stdout shows F being entered as the answer to the question even though
    the response wasn’t from a human:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: (Yes, the interpreter and stdout took some liberties with the spacing before
    the pipe.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the interpreter copies the file to the destination folder using the
    new name. If echo D had preceded the pipe, the target file would’ve been *C:\Target\NewName.txt\OldName.txt*.
    That’s clearly not the intention here, but in a different situation you could
    define the destination as a directory with the piping technique.
  prefs: []
  type: TYPE_NORMAL
- en: To make this more generic, you could set a variable to either F or D, depending
    on the format of the target. If the target ends in a period and extension, you
    can assume it’s a file; if not, it’s a directory. Then you can pipe the resolved
    variable into the xcopy command with an echo command.
  prefs: []
  type: TYPE_NORMAL
- en: But what effect does this technique have when the xcopy command doesn’t ask
    for a response? It’s synonymous with trying to impart wisdom to someone, perhaps
    a teenager, who doesn’t want to listen. Just as a parent’s words are lost into
    the void, the information piped to the xcopy command is completely ignored if
    a question wasn’t asked. It’s as if the echo command never executed. So, if a
    response is requested, the piping will give it, and if a response isn’t requested,
    it’s harmless.
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications of piping. In [Chapter 24](chapter24.xhtml), you’ll
    learn how to perform some fairly complex text searches by piping both echo and
    type commands into a findstr command, allowing you to find specific text in a
    string or to find all the records in a file with that text. You can even sort
    the output of any command by piping it into the yet to be discussed sort command.
  prefs: []
  type: TYPE_NORMAL
- en: stdin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though this is a chapter about outputs, any discussion of stdout and stderr
    wouldn’t be complete without a mention of the input data stream *stdin*, pronounced
    *standard in* (or less frequently, *standard input*) and referenced by 0, which
    is input from the console. But little more than a mention is needed. In most literature
    on the subject, all three are mentioned together as if they were of equal importance,
    but while stdout and stderr are ubiquitous, stdin is used only occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the first command redirects a message to the console
    via echo. The second command is quite new, something of a reversal on the first
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The stdin data stream is the input from the keyboard or the console and is denoted
    in this context with the reserved word, con. Up until now, I’ve used con only
    as output, in particular output to the console. Ultimately, the type command redirects
    stdin into a text file.
  prefs: []
  type: TYPE_NORMAL
- en: This command temporarily halts processing. The user can type a line of text
    and press ENTER to write that line of text to the file. The file can accept multiple
    lines of text until the user terminates the command by pressing CTRL-Z, followed
    by ENTER when the cursor is at the beginning of a line. (I never said it was user-friendly.)
  prefs: []
  type: TYPE_NORMAL
- en: Many times, you may request a basic response of the user at the console— often
    a simple yes or no—and I’ll discuss how such interactive bat files work in [Chapter
    15](chapter15.xhtml). In those rare instances when you request more involved input
    from the user, redirecting stdin saves that data to a file for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, I covered three related topics: outputs, redirection, and
    piping. The stdout and stderr data streams are important and useful interpreter-generated
    outputs, giving you detailed information about a bat file’s execution. These are
    distinct from coder-generated output, the output that you explicitly create. You
    learned how redirection creates new files and appends to existing files. I showed
    how to capture the interpreter-generated output in a trace file or suppress it
    altogether. Individual commands also have output and you learned how to redirect
    it to a file and pipe it to other commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book I’ll discuss many applications of these new tools. In [Chapter
    22](chapter22.xhtml), formatting simple reports with Batch will make great use
    of redirection. I already mentioned the use of piping for text searches and redirection
    with the dir command. In the next chapter, I’ll discuss this extremely useful
    command and everything else you need to know about directories.
  prefs: []
  type: TYPE_NORMAL
