- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 OUTPUTS, REDIRECTION, AND PIPING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 输出、重定向和管道
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: You can now do quite a bit with Batch, such as setting, resetting, and interrogating
    variables of various data types, calling routines and other bat files, and performing
    arithmetic; however, most of what you’ve learned will have no lasting effect (except
    for file movements and the ability to set variables persistently). At the end
    of a bat file’s ephemeral execution, all of the bits and bytes that’ve been manipulated
    may vanish into the ether, and it’ll be as if the bat file had never existed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 Batch 做很多事情，比如设置、重置和查询各种数据类型的变量，调用例程和其他 bat 文件，执行算术运算；然而，你学到的大部分内容不会产生持久的影响（除了文件移动和能够持久设置变量）。在
    bat 文件的短暂执行结束时，所有被操作的位和字节可能会消失在空气中，就好像这个 bat 文件从未存在过一样。
- en: 'I’ll leave the metaphysics of Batch for another time, but whenever code of
    any type is executed, the intent is to effect some sort of change. Some coders
    will use Batch simply as a wrapper, setting a few variables before calling an
    executable that’ll bring about that change, but Batch can do much more. In this
    chapter, I’ll discuss two general types of output: output from the interpreter
    (stdout and stderr) and output from you, the coder. After learning the distinction,
    you’ll be able to write the different types of output to the console, new files,
    and existing files. In this way, you can store the product of all those variables,
    calls, and arithmetic on your computer.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留待以后再讨论 Batch 的形而上学问题，但每当任何类型的代码被执行时，目的就是产生某种变化。一些编码人员仅将 Batch 用作一个包装器，在调用可执行文件之前设置一些变量来实现这种变化，但
    Batch 能做的远不止这些。在本章中，我将讨论两种输出类型：解释器输出（stdout 和 stderr）和你，编码人员的输出。了解了这一区别后，你将能够将不同类型的输出写入控制台、新文件和现有文件。通过这种方式，你可以将所有那些变量、调用和算术运算的结果存储在你的计算机上。
- en: The discussion about the two types of output will lead to a couple of related
    and interesting topics. One is the redirection of the output of any Batch command
    to a file, and the other is piping, the technique of sending output from one command
    into another command. Maybe most important, you’ll learn what exactly is scrolling
    by so quickly on the console and how to manage it—that is, either save or suppress
    it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论这两种输出类型会引出几个相关且有趣的话题。其中一个是将任何 Batch 命令的输出重定向到文件，另一个是管道技术，将一个命令的输出传递到另一个命令。也许最重要的是，你将学会如何管理快速滚动的控制台内容——即要么保存它，要么抑制它。
- en: Interpreter-Generated vs. Coder-Generated Output
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器生成的输出与编码器生成的输出
- en: 'When you open or execute a bat file, it creates two general types of outputs:
    interpreter-generated and coder-generated. To be perfectly clear, the interpreter
    technically creates all of the output, but some of that output is the result of
    commands entered by you, the coder, to write something to the console or a file.
    That’s *coder-generated output*. As a byproduct of the run, the interpreter is
    also creating output that you didn’t explicitly request. That’s *interpreter-generated
    output*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开或执行一个 bat 文件时，它会生成两种类型的输出：解释器生成的输出和编码器生成的输出。为了完全清楚，解释器技术上生成了所有的输出，但其中一部分输出是你，编码员，通过命令写入控制台或文件所产生的。这就是*编码员生成的输出*。作为运行的副产品，解释器还会生成你没有明确要求的输出，这就是*解释器生成的输出*。
- en: All Batch commands create interpreter-generated output; a few also create coder-generated
    output. By default, Batch writes both types of output to the console, and if the
    bat file is even moderately complex, the text scrolls by in a jumble that’s too
    fast to read.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Batch 命令都会生成解释器输出；少数命令还会生成编码器输出。默认情况下，Batch 会将两种类型的输出写入控制台，如果 bat 文件稍微复杂一些，文本滚动得太快，以至于无法阅读。
- en: 'The echo command is a great example of one that generates both general types
    of output, and in its simplest manifestation, it writes all of its arguments to
    the console. Consider this command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: echo 命令就是一个很好的例子，它可以生成两种类型的输出。在最简单的表现形式中，它会将所有的参数写入控制台。考虑以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The execution of this command writes the output shown in [Listing 12-1](#Lis12-1)
    to the console.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令会将 [清单 12-1](#Lis12-1) 中所示的输出写入控制台。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-1: Output generated by the interpreter and the coder'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-1：解释器和编码器生成的输出
- en: The desired text, Greetings, Earthlings., is output, but it isn’t alone and
    appears twice, with the current directory prepended to the first line for some
    reason. (I’ll assume that the current directory is *C:\Batch\* throughout this
    chapter.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的文本“Greetings, Earthlings.”会被输出，但它并不孤单，会出现两次，且由于某种原因，当前目录会被附加到第一行之前。（假设本章中当前目录为*C:\Batch\*。）
- en: The two lines in [Listing 12-1](#Lis12-1) represent entirely different types
    of outputs. The second line is from the coder—a message written to the console
    with the echo command. The interpreter generates the first line. It isn’t the
    output of the echo command; it’s a *report of the execution* of the echo command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-1](#Lis12-1) 中的两行表示完全不同类型的输出。第二行来自编码者——通过 echo 命令写入控制台的消息。第一行由解释器生成。它不是
    echo 命令的输出；它是 echo 命令的*执行报告*。'
- en: The distinction is as subtle as it is important. The interpreter, at a minimum,
    logs the execution of every command by writing it, prepended with the prompt.
    By default, the prompt is the current directory followed by a greater-than sign.
    Many commands produce additional interpreter-generated output, such as the xcopy
    command, which often produces a list of the files copied.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别既微妙又重要。至少，解释器会通过写入每个命令并附加提示符来记录每个命令的执行。默认情况下，提示符是当前目录，后跟一个大于符号。许多命令会产生额外的解释器生成的输出，比如
    xcopy 命令，它通常会列出已复制的文件。
- en: Clearly, the intermingled output is a mess, and if this example doesn’t look
    like a mess, that’s because I’m showing the output from only a single command.
    Before long, I’ll show you how to clean up the console by sending these distinct
    outputs to different destinations, but first you’ll need to better understand
    the interpreter-generated output, which itself is actually two different outputs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，交织的输出很乱，如果这个例子看起来不乱，那是因为我只展示了一个命令的输出。很快，我将向你展示如何通过将这些不同的输出发送到不同的目标来清理控制台，但首先你需要更好地理解由解释器生成的输出，实际上它是两个不同的输出。
- en: stdout and stderr
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stdout 和 stderr
- en: Batch writes every bit of interpreter-generated output to one of two data streams.
    A *data stream* is a transmission of information from a source—in this case, the
    interpreter—to a destination, which by default is the console. A file descriptor
    represents each data stream, and the most voluminous by far is the stream described
    as *stdout*, pronounced *standard out* (or less frequently, *standard output*).
    In fact, the only interpreter-generated output not found in stdout are error messages,
    which are written to the file descriptor *stderr*, pronounced *standard error*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理将每一部分由解释器生成的输出写入两个数据流之一。*数据流*是从源（在本例中是解释器）到目标的传输信息，默认情况下目标是控制台。每个数据流由文件描述符表示，而最大的数据流是被描述为*stdout*的流，发音为*标准输出*（或较少使用的*标准输出*）。事实上，唯一不在
    stdout 中的解释器生成的输出是错误消息，它们被写入文件描述符*stderr*，发音为*标准错误*。
- en: 'The stdout data stream can become dense and cryptic, but it’s often invaluable
    to help you determine what exactly transpired during a bat file’s execution. You
    can often see the results of if commands, what files were created, and much more.
    To demonstrate, the following del command deletes a file and is followed by a
    set command that captures errorlevel as the return code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: stdout 数据流可能会变得复杂且难以理解，但它通常对你帮助极大，能帮助你确定批处理文件执行过程中到底发生了什么。你通常可以看到 if 命令的结果、哪些文件被创建等等。为了演示，以下
    del 命令删除一个文件，接着是一个 set 命令，它捕获 errorlevel 作为返回代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nothing here creates coder-generated output; all output comes from the interpreter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有产生由编码器生成的输出；所有输出都来自解释器。
- en: 'If the *DeleteMe.txt* file exists, the previous code deletes it and writes
    the following to stdout:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在*DeleteMe.txt*文件，前面的代码会删除它并将以下内容写入stdout：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most variables are resolved in stdout, such as errorlevel being resolved to
    0 in this example. (Frustratingly, the interpreter fails to resolve variables
    fully in certain situations, such as when using delayed expansion. See [Chapter
    31](chapter31.xhtml) for more details.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数变量在 stdout 中解析，比如在这个例子中，errorlevel 被解析为 0。（令人沮丧的是，解释器在某些情况下无法完全解析变量，比如在使用延迟扩展时。更多细节见[第31章](chapter31.xhtml)。）
- en: 'Interspersed with stdout can be the second type of interpreter-generated output,
    the output written to the stderr data stream, but only if there are any errors,
    of course. If, for instance, the file in the del command doesn’t exist, the interpreter
    outputs the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出（stdout）中间可以夹杂第二种解释器生成的输出，即写入到stderr数据流的输出，但仅在发生错误时才会有输出。例如，如果del命令中的文件不存在，解释器会输出如下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first and last lines are written to stdout, but the middle line stating
    that the file couldn’t be found is written to stderr. It’s important to understand
    that error messages are written to stderr, while all other interpreter-generated
    output goes to stdout. Both are needed to get a full picture of what happened
    during a bat file’s execution, and unless we do something to intervene, both are
    written to the console.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和最后一行被写入标准输出（stdout），但中间一行表示文件找不到的信息则写入标准错误输出（stderr）。理解这一点非常重要：错误消息被写入stderr，而所有其他解释器生成的输出都会写入stdout。为了全面了解批处理文件执行过程中发生的情况，两个输出都需要，并且除非我们采取措施干预，否则它们都会写入控制台。
- en: (By the way, let’s not quibble over why the return code is 0 even if an error
    message is generated. But if we must, the file doesn’t exist after the del command
    completes, so in a certain prosaic sense, it was successful, or it’s a bug.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一下，别纠结于为什么即使生成了错误消息，返回代码仍然是0。但如果非要解释的话，del命令完成后文件不存在，从某种平凡的意义上来说，它是成功的，或者这算是个bug。）
- en: Writing Files
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入文件
- en: Creating, writing to, and appending to files are basic functions of most coding
    languages, and Batch allows you to build files with both coder- and interpreter-generated
    output. Up until now, all of the output that you have seen has been written to
    the console, and when the bat file completes, the window closes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、写入和追加文件是大多数编程语言的基本功能，而批处理（Batch）允许你构建包含编码器和解释器生成输出的文件。直到现在，你所看到的所有输出都被写入到控制台，并且当批处理文件完成时，窗口会关闭。
- en: Often, you’ll want to create files that persist beyond the life of the bat file’s
    execution. You can write data to a file to use as input to an executable or even
    another bat file. If I want a record of how often others run one of my bat files,
    I’ll set it up to write one record to a central logfile with information about
    when and on what server it ran. You can even build reports, and capturing the
    interpreter-generated output into a file provides you with a great audit trail
    of exactly what transpired during the bat file’s execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能希望创建在批处理文件执行完毕后仍然存在的文件。你可以将数据写入文件，以便作为可执行文件或另一个批处理文件的输入。如果我想记录其他人运行我的批处理文件的频率，我可以设置它将一条记录写入到一个中央日志文件中，记录何时以及在哪个服务器上运行了该文件。你甚至可以生成报告，并将解释器生成的输出捕获到文件中，这样可以为你提供关于批处理文件执行过程中发生的事情的良好审计跟踪。
- en: From Coder-Generated Output
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自编码器生成的输出
- en: 'I’ve shown that we can write text to the console with the > con syntax. With
    a similar syntax, we can write to a file with two commands: the familiar echo
    command writes a record, and the not-so-familiar type command writes an entire
    file to another file.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了如何使用> con语法将文本写入控制台。通过类似的语法，我们可以通过两个命令写入文件：熟悉的echo命令写入一条记录，而不那么熟悉的type命令将整个文件写入另一个文件。
- en: Writing a Record to a File
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 写入记录到文件
- en: 'Let’s return to the extraterrestrials. Instead of greeting us via the console,
    they might want to enter their greeting into a simple text file, and they can
    accomplish this with a single line of code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到外星人。与其通过控制台向我们问好，它们可能想把问候语写入一个简单的文本文件中，它们可以通过一行代码来实现：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line of code has four distinct elements. The first is the echo command,
    and the second is the command’s argument: the Greetings, Earthlings. text. The
    third element is the greater-than sign (>), or redirection character. This character
    redirects the output of the command preceding it to the target, which is the fourth
    element: the *C:\Batch\ET.txt* file. Putting it all together, the previous statement
    writes the one line of greeting to the text file.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码有四个不同的元素。第一个是echo命令，第二个是命令的参数：Greetings, Earthlings. 文本。第三个元素是大于符号（>），即重定向字符。这个字符将前面的命令输出重定向到目标，目标是第四个元素：*C:\Batch\ET.txt*
    文件。将它们结合起来，前面的语句将问候语写入文本文件。
- en: 'The following alternative syntax performs the identical task, but it’s easier
    to read because the message no longer abuts the greater-than sign as it did in
    the previous example. I’ve moved the redirection character to the fore, again
    followed by the target:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的替代语法执行相同的任务，但因为信息不再紧贴着大于符号，所以更容易阅读。我将重定向符号移到了前面，后面跟着目标：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you replace the path and filename in this example with con, you’ll recognize
    the familiar syntax for writing to the console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此示例中的路径和文件名替换为 `con`，你将会认出这种常见的语法来写入控制台。
- en: 'The following example demonstrates the appeal of this syntax. If the aliens
    have more than one line to communicate, they can set the target file path and
    name to a variable and use it in successive echo commands. This syntax allows
    for multiple usages of the redirection, target, and echo command to be lined up
    in an orderly fashion, making it easier to read what’s being written to the file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这种语法的优势。如果外星人有多行信息需要传递，他们可以将目标文件路径和名称设置为变量，并在后续的 `echo` 命令中使用它。这种语法允许将多个重定向、目标和
    `echo` 命令按顺序排列，使得更容易阅读写入文件的内容：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we move on, I snuck a couple of subtle yet important features into the
    previous code. The first echo command has a single greater-than sign for the redirection,
    while the subsequent commands each use two greater-than signs. The single character
    operator creates a new file with its text, deleting the current file of that name
    if it exists. The two-character operator appends to an existing file. A rookie
    mistake is to use a single greater-than sign for multiple commands, leaving the
    novice Batch coder wondering why only the last of several commands worked, when
    they all actually worked, each wiping out the existing file and writing a single
    line of text.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我在之前的代码中悄悄加入了几个微妙但重要的功能。第一个 `echo` 命令使用了单一的大于符号来进行重定向，而后续的命令则每个使用了两个大于符号。单字符操作符会创建一个新的文件并写入内容，如果该文件已存在，则会删除它。两个字符操作符则会将内容追加到现有文件中。一个新手常犯的错误是对多个命令使用单一的大于符号，结果让初学者困惑，为什么只有最后一个命令有效，实际上每个命令都有效，只不过每次都会清空文件并写入一行文本。
- en: 'The other important feature is the echo command followed immediately by a dot;
    it’ll write a blank line, not a dot. After this code executes, the complete contents
    of *ET.txt* contain these three lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是 `echo` 命令后面紧跟一个点；它会写入一个空行，而不是一个点。执行完此代码后，*ET.txt* 的完整内容包括以下三行：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you ever need to write a single dot on a line, leave a space between echo
    and the dot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在一行中写入一个单独的点，记得在 `echo` 和点之间留一个空格。
- en: Writing a File to a File
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 写入文件到文件
- en: 'Another useful command that you can couple with redirection is the type command.
    Used alone, the command writes out, or types, the complete contents of a file
    to stdout and the console. With redirection, it can insert the full contents of
    that file into another file. The following example writes the contents of *DetailRecs.txt*
    to *OutFile.txt*, prepended with a header record and appended with a trailer record
    via a couple echo commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可以与重定向结合使用的有用命令是 `type` 命令。单独使用时，该命令会将文件的完整内容写入标准输出和控制台。结合重定向时，它可以将该文件的完整内容插入到另一个文件中。以下示例将
    *DetailRecs.txt* 的内容写入 *OutFile.txt*，并通过两个 `echo` 命令在前面添加一个头记录，在后面添加一个尾记录：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that only the first echo command has the single character redirection
    operator, thus ensuring that it’s truly a header record.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有第一个 `echo` 命令使用了单一的重定向符号，从而确保它是真正的头记录。
- en: From Interpreter-Generated Output
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自解释器生成的输出
- en: You now know that the mess scrolling by on the console is mostly stdout with
    the possibility of some stderr and coder-generated output. You can also control
    the destination (console or file) of the coder-generated output. The missing piece
    is what to do about the interpreter-generated output. By default, it’s sent to
    the console, but with a modicum of effort, you can write everything the interpreter
    generates to a file, commonly called a *trace file*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道，控制台上滚动的大多数杂乱信息是标准输出（stdout），可能还包含一些标准错误（stderr）和程序生成的输出。你也可以控制程序生成的输出的目标（控制台或文件）。缺失的一部分是如何处理解释器生成的输出。默认情况下，它会被发送到控制台，但通过一些努力，你可以将解释器生成的所有内容写入一个文件，通常称为
    *跟踪文件*。
- en: 'In the previous section, you learned how to redirect the output of the echo
    and type commands to a file, but you can redirect the output of any command, in
    particular the call command. In [Chapter 10](chapter10.xhtml), I introduced the
    concept of calling routines within a bat file, so you can create a routine containing
    the bat file’s main logic and call it at the top of the file. What’s new here
    is the redirection operator and the trace file appended to the first line in the
    following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学会了如何将echo和type命令的输出重定向到文件，但你可以将任何命令的输出重定向，尤其是call命令。在[第10章](chapter10.xhtml)中，我介绍了在bat文件中调用例程的概念，因此你可以创建一个包含bat文件主要逻辑的例程，并在文件的顶部调用它。这里的新内容是重定向操作符和在下面示例中追加到第一行的追踪文件：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a complete bat file that writes the greeting to the console and captures
    the trace file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的bat文件，它将问候语写入控制台并捕获追踪文件。
- en: The at symbol (@) prefixing the first command suppresses the call command itself
    from the console, but not the call command’s output. Critically, the output from
    the call command is the stdout coming out of the called routine, and that output
    is redirected via the greater-than sign in the first line away from the console
    and to the trace file. Notice that the greeting itself at the bottom of the file
    is explicitly being sent to the console with > con prefixing each of the three
    echo commands. Without the redirection, the greeting would’ve been written to
    the trace file with the rest of stdout.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令前加上@符号可以抑制call命令本身在控制台的显示，但不会抑制call命令的输出。关键的是，call命令的输出是从被调用的例程中出来的stdout，而该输出通过第一个命令中的大于符号被重定向，避免显示在控制台并转到追踪文件。注意，文件底部的问候语明确被发送到控制台，每个echo命令前都有>
    con前缀。如果没有重定向，问候语将与其余的stdout一起写入追踪文件。
- en: 'Each data stream has a reference or numerical handle so that you can refer
    to one or the other with minimal keystrokes. The reference for stdout is 1, and
    placing that reference number before the redirection character explicitly diverts
    stdout to the trace file. But stdout is redirected by default with the greater-than
    sign alone, so the following two commands are functionally equivalent:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据流都有一个引用或数字句柄，你可以用最少的按键引用其中之一。stdout的引用是1，将该引用号放在重定向符号之前，可以明确地将stdout重定向到追踪文件。但默认情况下，stdout是通过大于符号（>）单独重定向的，因此以下两个命令在功能上是等效的：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both commands, stdout alone is written to the trace file, and any error messages
    from stderr will end up being displayed on the console.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个命令中，仅将stdout写入追踪文件，stderr中的任何错误消息将显示在控制台上。
- en: 'The stderr data stream is referenced by 2, so you can redirect these error
    messages instead with this one-byte modification prior to the redirection symbol:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: stderr数据流由2引用，因此你可以在重定向符号之前通过修改一个字节来重定向这些错误消息：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can even redirect each data stream, stdout and stderr, to entirely different
    files at once:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将每个数据流，stdout和stderr，同时重定向到完全不同的文件：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In practice, separating the data streams is rarely useful as any error messages
    won’t be tied to the commands that generated them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，分离数据流很少有用，因为任何错误消息都不会与生成它们的命令关联。
- en: A far superior solution, shown in [Listing 12-2](#Lis12-2), is to write both
    outputs to the trace file, and that’s accomplished with this particularly esoteric
    syntax at the end of the command including 2 and 1, for stderr and stdout, respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个远远优于此的解决方案，如[Listing 12-2](#Lis12-2)所示，是将两个输出都写入追踪文件，且通过在命令末尾使用特别晦涩的语法，其中2和1分别代表stderr和stdout，来实现这一点。
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-2: The ideal technique to redirect stdout and stderr to a trace
    file'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-2：将stdout和stderr重定向到追踪文件的理想技巧
- en: As you are aware, the ampersand (&) is the command separator used to execute
    two commands coded on a single line. But used in the manner shown in [Listing
    12-2](#Lis12-2), the interpreter treats the ampersand simply as part of the redirection
    syntax. Just chalk this up as another batveat and don’t ask why, but it’s the
    best technique for capturing a trace file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，&符号是用于在单行中执行两个命令的命令分隔符。但在[Listing 12-2](#Lis12-2)中所示的方式使用时，解释器将&符号视为重定向语法的一部分。记住这一点作为另一个bat的警告，不要问为什么，但这是捕获追踪文件的最佳技巧。
- en: Suppressing stdout and stderr
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抑制stdout和stderr
- en: You can watch stdout and stderr scroll by on the console, or you can save both
    data streams to a trace file. In other situations, this data simply isn’t needed
    at all. It might not be worth the disk space to create a log of every execution
    of a stable and frequently run process, and you might not even want stdout and
    stderr written to the console because you want it uncluttered for any coder-generated
    output. In such cases, you’ll want to outright suppress the interpreter-generated
    output. Two techniques work; one is simple but works only on stdout, while the
    slightly more complex technique also works on stderr.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到 stdout 和 stderr 在控制台上滚动，或者你可以将这两个数据流保存到跟踪文件中。在其他情况下，这些数据根本不需要。有时为每次执行一个稳定且频繁运行的过程创建日志可能不值得占用磁盘空间，而且你可能不希望
    stdout 和 stderr 输出到控制台，因为你希望控制台对任何程序员生成的输出保持整洁。在这种情况下，你将希望彻底抑制解释器生成的输出。有两种技巧可以做到；其中一种简单但只适用于
    stdout，而稍微复杂的技巧也适用于 stderr。
- en: The @echo off Technique
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@echo off 技巧'
- en: The simple technique to suppress stdout is with the @echo off command. Based
    on what you’ve learned about the echo command, you might expect this particular
    command to write off to stdout. Afterall, echo Hello writes Hello to stdout. Usually,
    echo writes out its arguments, but there are two exceptions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 抑制 stdout 的简单技巧是使用 @echo off 命令。根据你对 echo 命令的了解，你可能会预期这个特定的命令会将内容输出到 stdout。毕竟，echo
    Hello 会将 Hello 输出到 stdout。通常，echo 会输出它的参数，但有两个例外。
- en: The off argument instructs the interpreter to suppress (or turn off) stdout,
    and the on argument turns it back on, with one catch. The echo command to suppress
    stdout is itself written to stdout. Fortunately, Batch allows for the suppression
    of any single command’s contribution to stdout simply by prepending it with the
    at symbol (@). Hence, the command to suppress stdout that is itself suppressed
    is @echo off. I quietly introduced this technique in [Chapter 2](chapter2.xhtml)
    to clean up the console but sidestepped a deeper explanation for later (which
    is now).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: off 参数指示解释器抑制（或关闭）stdout，on 参数则将其重新打开，但有一个限制。用于抑制 stdout 的 echo 命令本身是写入 stdout
    的。幸运的是，Batch 允许通过在命令前加上 at 符号 (@) 来抑制单个命令对 stdout 的贡献。因此，抑制 stdout 的命令本身被抑制写入
    stdout 为 @echo off。我在[第 2 章](chapter2.xhtml)中悄悄介绍了这个技巧来清理控制台，但并未做深入解释，今天来讲解（现在是时候了）。
- en: 'If the extraterrestrials were to communicate with us via the console, this
    simple bat file would do the trick:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外星人要通过控制台与我们沟通，这个简单的 bat 文件就能派上用场：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first echo suppresses stdout so as to keep the console uncluttered and
    readable. Try this bat file without that first line to see the difference. It’s
    ugly; each echo command generates both general types of output to the console.
    With this command in place, the second echo command writes only its arguments
    to the console. The echo command followed immediately by a dot writes a blank
    line. Finally, the pause command keeps the window open so that it doesn’t disappear
    in a flash. The result is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 echo 命令抑制了 stdout，以保持控制台的整洁和可读性。尝试去掉这一行，看看差异。效果很差；每个 echo 命令都会将两种类型的输出都发送到控制台。使用这个命令后，第二个
    echo 命令仅将它的参数写入控制台。紧跟着点号的 echo 命令会写出一个空行。最后，pause 命令保持窗口打开，避免它迅速消失。最终的结果是：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Press any key, and the pause command allows the bat file to continue, closing
    the window. In [Chapter 3](chapter3.xhtml), I mentioned that I start every high-level
    bat file with a setlocal command that enables command extensions and delayed expansion.
    This echo command is the only command that might come before that setlocal, thus
    keeping the console pristine. However, you also can prepend the setlocal command
    itself with an at symbol to suppress its execution from stdout.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按下任意键，pause 命令允许 bat 文件继续执行并关闭窗口。在[第 3 章](chapter3.xhtml)中，我提到我在每个高级 bat 文件的开头都会使用
    setlocal 命令，以启用命令扩展和延迟扩展。这个 echo 命令是唯一可能出现在 setlocal 之前的命令，从而保持控制台的整洁。不过，你也可以在
    setlocal 命令前面加上一个 at 符号，以抑制其从 stdout 的执行。
- en: 'As a side note, every novice Batch coder will likely try to write a blank line
    with nothing but spaces following the echo command, even if only by accident.
    But that command simply writes out the state of the echo, which is either on or
    off. For instance, executing the following two lines at the beginning of a bat
    file writes ECHO is off. to the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附带说明，每个初学者 Batch 编程者可能会试图在 echo 命令后仅通过空格写出一行空白，即便这只是个意外。但这个命令只是写出 echo 的状态，而状态只有开或关。例如，在
    bat 文件的开头执行以下两行，会将 ECHO is off. 输出到控制台：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Likewise, replacing the first line with echo on activates stdout, resulting
    in ECHO is on. as the output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，用echo on替换第一行会激活stdout，输出为ECHO is on。
- en: The @echo off technique has one more catch. While stdout is suppressed, stderr
    is unaffected, which means that any unredirected error messages will appear on
    the console with little or no context.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '@echo off技巧还有一个注意点。尽管stdout被抑制，stderr不受影响，这意味着任何未重定向的错误信息会在控制台上显示，且几乎没有上下文。'
- en: The Redirection to nul Technique
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重定向到nul的技巧
- en: 'The best technique for suppressing all interpreter-generated output is to redirect
    stdout and stderr to the *nul* file introduced in [Chapter 7](chapter7.xhtml).
    This file is always empty, regardless of what’s written to it, making it something
    of a Batch trash receptacle. For instance, reworking the call command from [Listing
    12-2](#Lis12-2) to send stdout and stderr to *nul* instead of a trace file effectively
    suppresses all interpreter-generated output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 抑制所有解释器生成的输出的最佳技巧是将stdout和stderr重定向到[第7章](chapter7.xhtml)中介绍的*nul*文件。无论写入其中什么内容，这个文件始终为空，因此它有点像是一个Batch垃圾接收器。例如，将[清单12-2](#Lis12-2)中的call命令重新编写为将stdout和stderr发送到*nul*而不是跟踪文件，有效地抑制了所有解释器生成的输出：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, the name of the routine is now a misnomer. (Rename the label :SuppressTrace
    if you must.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，例程的名称现在已经不准确了。（如果需要，重新命名标签为:SuppressTrace。）
- en: This technique does require that you create a routine for the mainline logic,
    but it’s very effective, it’s relatively simple, and you can use it to suppress
    all the interpreter-generated output of called bat files as well as routines.
    The leading at sign even suppresses the call command itself from stdout.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧确实需要你为主线逻辑创建一个例程，但它非常有效，且相对简单，你可以用它来抑制所有被调用的bat文件和例程生成的输出。前导的@符号甚至可以将call命令本身从stdout中抑制。
- en: 'You can use this technique to suppress the output of any command. For instance,
    the following executes the compiled program, while simply discarding its command
    line output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种技巧来抑制任何命令的输出。例如，以下代码执行编译后的程序，同时简单地丢弃其命令行输出：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Prepending (or even appending) the program execution with a redirection to the
    *nul* file resolves the issue nicely.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行前添加（或甚至附加）重定向到*nul*文件，可以很好地解决这个问题。
- en: Remarks in stdout
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stdout中的备注
- en: I’ve one last remark about stdout. In [Chapter 2](chapter2.xhtml), I introduced
    the rem command as a simple means of entering a remark or comment into the code.
    An alternative syntax exists and has ramifications for stdout.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我对stdout还有最后一点说明。在[第2章](chapter2.xhtml)中，我介绍了rem命令，它是将备注或注释简单地写入代码中的一种方式。还有另一种语法，它对stdout有影响。
- en: 'Remarks generated with the rem command are written to stdout. However, any
    line in the code preceded with two colons (::) is also treated as a remark, but
    it’s a hidden remark suppressed from stdout. Consider these two valid remarks:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用rem命令生成的备注会被写入stdout。然而，代码中任何以两个冒号(::)开头的行也会被视为备注，但它是一个隐藏的备注，且会从stdout中被抑制。请看这两个有效的备注：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’ll find only the first remark in stdout. Also notice that the dual colons
    don’t require a space before the remark text. In [Chapter 9](chapter9.xhtml),
    I mentioned that labels must start with a colon, but the second character must
    be a different character. This is because the double colons signify a hidden remark.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你只会在stdout中看到第一个备注。还要注意，双冒号前不需要空格。 在[第9章](chapter9.xhtml)中，我提到标签必须以冒号开头，但第二个字符必须是不同的字符。这是因为双冒号表示隐藏的备注。
- en: There’s nothing nefarious about a hidden remark. Remarks that explain the code
    can be useful in stdout, but others might muddy it up. This is a great technique
    for coders to keep notes for themselves in the code, and only in the code. For
    instance, it’s always good to maintain a detailed history of revisions in the
    source code, but those details might just make a mess of the trace file. If so,
    use double colons for such remarks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的备注并没有什么不当之处。解释代码的备注在stdout中可能很有用，但其他备注可能会让它变得杂乱。对于程序员来说，这是一个很好的技巧，可以在代码中仅为自己保留注释。例如，始终保持源代码修订的详细历史是件好事，但这些细节可能会把跟踪文件弄得一团糟。如果是这样，可以为此类备注使用双冒号。
- en: Redirection of Any Command
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何命令的重定向
- en: 'I’ve shown that redirection of the echo, type, and call commands can write
    output to a file, but those are just three examples. You can redirect the output
    of any Batch command. To take just one example, you can send output of the following
    xcopy command to a logfile:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示过如何通过重定向 `echo`、`type` 和 `call` 命令将输出写入文件，但这只是三个例子。你可以重定向任何 Batch 命令的输出。举个例子，你可以将以下
    `xcopy` 命令的输出发送到一个日志文件：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *.dat* files are copied to *D:\Backup\* with or without the redirection,
    but the interpreter now appends the resulting text that lists all of the files
    just copied along with a total count to the *Copy.log* file. It’s appended because
    of the two greater-than signs; the single character operator would have created
    a new file with the output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否重定向，*.dat* 文件都会被复制到 *D:\Backup\* 目录，但解释器会将列出所有刚刚复制的文件及其总数的文本附加到 *Copy.log*
    文件中。它之所以是附加的，是因为使用了两个大于号；如果是单个字符运算符，则会创建一个新的文件来存储输出。
- en: Although you can perform redirection for any command, many don’t have output
    or have drab output not worth capturing. In the next chapter, I’ll introduce the
    dir command, which writes details about all the files and subfolders in a directory
    to stdout. That’s the type of information that’s easily and often redirected to
    a file. Command line output from a compiled program is another example of data
    often worth capturing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以对任何命令进行重定向，但许多命令没有输出，或者其输出非常乏味，不值得捕捉。在下一章中，我将介绍 `dir` 命令，它将目录中所有文件和子文件夹的详细信息写入标准输出。这种信息通常很容易且经常被重定向到文件。编译程序的命令行输出是另一种值得捕捉的数据。
- en: Piping
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: Redirection typically sends output to a file, but piping sends output to an
    entirely different destination. *Piping* is the concept of joining two distinct
    commands. The interpreter sends the output of the first command to the second
    command as input via some sort of a tube, hose, duct, conduit, or ... there’s
    a better metaphor for a physical conveyance, oh ... a pipe. The character used
    to make this connection is, appropriately enough, the pipe character, also called
    the vertical bar or upright slash. On most keyboards, it’s above ENTER, and you
    press SHIFT-\ to access it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向通常将输出发送到文件，而管道则将输出发送到完全不同的目标。*管道* 是将两个不同命令连接起来的概念。解释器通过某种方式将第一个命令的输出作为输入传递给第二个命令，像通过管子、软管、管道等
    ... 其实有一个更合适的物理比喻，就是管道。用来建立这种连接的字符恰如其分地被称为管道字符，也叫竖线或直杠。在大多数键盘上，它位于回车键上方，按下 SHIFT-\
    就能输入。
- en: 'To this point you’ve seen the results of the echo command redirected to the
    console, stdout, or a particular file, but you also can pipe those results to
    other Batch commands. Recall the xcopy command from [Chapter 7](chapter7.xhtml)
    that, as part of the copy, gave the destination file a different name from the
    source file. At the time, I warned that such a command sometimes fails, and I
    promised a solution in this chapter, and that solution is piping. The following
    command certainly appears to be a straightforward copy with a renamed destination
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到 `echo` 命令的结果被重定向到控制台、标准输出或某个特定文件，但你同样可以将这些结果通过管道传递给其他 Batch 命令。回想一下
    [第七章](chapter7.xhtml) 中提到的 `xcopy` 命令，它在复制过程中将目标文件命名为与源文件不同的名字。当时我警告过，类似的命令有时会失败，并承诺在这一章提供解决方案，那个解决方案就是管道。以下命令显然是一个直接的复制操作，并将目标文件重新命名：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the *NewName.txt* file exists at the target path, this command simply overlays
    the file and moves on. But due to the vagaries of Batch (or less diplomatically,
    a possible bug), if *NewName.txt* doesn’t exist, the interpreter gets a bit confused.
    The source file is clearly *OldName.txt*, but is *NewName.txt* the name of the
    destination file or the destination folder? The *.txt* extension should make it
    obvious to the interpreter, but directory names can include dots. (But shame on
    anyone who would give a folder name a typical file extension.) When the interpreter
    gets confused, it does what a lost human should do; it asks directions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标路径下已经存在 *NewName.txt* 文件，这个命令会简单地覆盖该文件并继续执行。但由于 Batch 的不确定性（或者更直白地说，可能是一个
    bug），如果 *NewName.txt* 不存在，解释器会有些困惑。源文件显然是 *OldName.txt*，但是 *NewName.txt* 是目标文件的名字，还是目标文件夹的名字呢？*.txt*
    扩展名应该能让解释器明白，但目录名中也可以包含点（.）。（不过，给文件夹命名时加上常见的文件扩展名真是个让人羞愧的做法。）当解释器感到困惑时，它会像迷路的人一样寻求帮助：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you had typed the xcopy command into a command prompt and seen that message
    written to the console, undoubtedly you would’ve simply entered F and been done
    with it. The same would’ve been true if the stdout of a bat file had gone to the
    console, but when this command is in a bat file with a redirected stdout, the
    interpreter essentially asks the trace file for a response and waits in perpetuity.
    At some point someone will investigate the long-running execution, scroll down
    to the bottom of the trace file, and find the text in the previous example. This
    is what coders call a *hang*; it’s worse than an abort because the execution never
    ends. The cause can be an endless loop, but in this case, the cause is the interpreter
    asking for a response from an entity that cannot respond. The only human response
    is to kill the command window, find and correct the issue, and rerun.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令提示符下输入了xcopy命令并看到了该信息被写入控制台，你无疑会直接输入F然后完成操作。如果这个stdout输出来自一个批处理文件，也会是同样的情况，但当这个命令在一个有重定向stdout的批处理文件中时，解释器本质上会向追踪文件请求响应，并会一直等待下去。某个时候，会有人调查这个长时间运行的进程，滚动到追踪文件的底部，找到前面示例中的文本。这就是程序员所说的*挂起*；它比中止更糟糕，因为执行永远不会结束。原因可能是一个无限循环，但在这种情况下，原因是解释器向一个无法响应的实体请求反馈。唯一的人工回应就是终止命令窗口，找到并修正问题，然后重新运行。
- en: 'The only way to respond programmatically with an answer in real time is to
    anticipate the question and code for it before the bat file ever executes. To
    this end, I’ll precede the xcopy command with a response from an echo command.
    The following echo F command is simply writing F, the response for file, and that
    response is piped as input to the xcopy command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中实时响应并给出答案的唯一方式是预测问题并在批处理文件执行之前编写相应代码。为此，我将在xcopy命令前加上echo命令的响应。以下的echo F命令只是写入F，这是针对文件的响应，并且这个响应被作为输入传递给xcopy命令：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now stdout shows F being entered as the answer to the question even though
    the response wasn’t from a human:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标准输出显示F作为对问题的回答，尽管这个回应并不是来自一个人类：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: (Yes, the interpreter and stdout took some liberties with the spacing before
    the pipe.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，解释器和标准输出在管道符号之前的空格上做了一些处理。）
- en: Finally, the interpreter copies the file to the destination folder using the
    new name. If echo D had preceded the pipe, the target file would’ve been *C:\Target\NewName.txt\OldName.txt*.
    That’s clearly not the intention here, but in a different situation you could
    define the destination as a directory with the piping technique.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，解释器使用新名称将文件复制到目标文件夹。如果在管道符之前是echo D，那么目标文件会是*C:\Target\NewName.txt\OldName.txt*。显然，这不是这里的意图，但在不同的情况下，你可以使用管道技术将目标定义为一个目录。
- en: To make this more generic, you could set a variable to either F or D, depending
    on the format of the target. If the target ends in a period and extension, you
    can assume it’s a file; if not, it’s a directory. Then you can pipe the resolved
    variable into the xcopy command with an echo command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一过程更具通用性，你可以设置一个变量，根据目标的格式将其设置为F或D。如果目标以句点和扩展名结尾，你可以假设它是一个文件；如果不是，它就是一个目录。然后你可以将解析后的变量通过回显命令传递给xcopy命令。
- en: But what effect does this technique have when the xcopy command doesn’t ask
    for a response? It’s synonymous with trying to impart wisdom to someone, perhaps
    a teenager, who doesn’t want to listen. Just as a parent’s words are lost into
    the void, the information piped to the xcopy command is completely ignored if
    a question wasn’t asked. It’s as if the echo command never executed. So, if a
    response is requested, the piping will give it, and if a response isn’t requested,
    it’s harmless.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当xcopy命令不要求反馈时，这种技术有什么效果呢？它就像试图向某人传授智慧，也许是一个不想听的青少年。就像父母的话语消失在空洞中一样，如果没有提出问题，管道传递给xcopy命令的信息会被完全忽略。就好像echo命令从未执行过一样。因此，如果需要回应，管道就会给出反馈；如果不需要回应，那它就是无害的。
- en: There are many applications of piping. In [Chapter 24](chapter24.xhtml), you’ll
    learn how to perform some fairly complex text searches by piping both echo and
    type commands into a findstr command, allowing you to find specific text in a
    string or to find all the records in a file with that text. You can even sort
    the output of any command by piping it into the yet to be discussed sort command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 管道有许多应用。在[第24章](chapter24.xhtml)中，你将学习如何通过将echo和type命令通过管道传递给findstr命令来执行一些相当复杂的文本搜索，从而允许你在字符串中找到特定文本，或者在文件中找到包含该文本的所有记录。你甚至可以通过将命令的输出传递给尚未讨论的sort命令来对其进行排序。
- en: stdin
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准输入（stdin）
- en: Even though this is a chapter about outputs, any discussion of stdout and stderr
    wouldn’t be complete without a mention of the input data stream *stdin*, pronounced
    *standard in* (or less frequently, *standard input*) and referenced by 0, which
    is input from the console. But little more than a mention is needed. In most literature
    on the subject, all three are mentioned together as if they were of equal importance,
    but while stdout and stderr are ubiquitous, stdin is used only occasionally.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章讲的是输出，但任何关于 stdout 和 stderr 的讨论，如果不提及输入数据流 *stdin*（发音为 *standard in* 或不太常见的
    *standard input*），以及它通过 0 来引用来自控制台的输入，都会是不完整的。不过，仅需简单提及即可。在大多数相关文献中，通常会将三者一起提及，仿佛它们同等重要，但尽管
    stdout 和 stderr 是无处不在的，stdin 的使用却相对偶尔。
- en: 'In the following example, the first command redirects a message to the console
    via echo. The second command is quite new, something of a reversal on the first
    command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，第一个命令通过 echo 将消息重定向到控制台。第二个命令则相对较新，可以视为对第一个命令的反转：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The stdin data stream is the input from the keyboard or the console and is denoted
    in this context with the reserved word, con. Up until now, I’ve used con only
    as output, in particular output to the console. Ultimately, the type command redirects
    stdin into a text file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: stdin 数据流是来自键盘或控制台的输入，在此上下文中通过保留字 con 来表示。直到现在，我只将 con 用作输出，特别是输出到控制台。最终，type
    命令将 stdin 重定向到文本文件中。
- en: This command temporarily halts processing. The user can type a line of text
    and press ENTER to write that line of text to the file. The file can accept multiple
    lines of text until the user terminates the command by pressing CTRL-Z, followed
    by ENTER when the cursor is at the beginning of a line. (I never said it was user-friendly.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会暂时暂停处理。用户可以输入一行文本并按 ENTER 键将该行文本写入文件。文件可以接受多行文本，直到用户通过按 CTRL-Z 后再按 ENTER
    键（当光标位于行首时）来终止命令。（我可没说过它是用户友好的。）
- en: Many times, you may request a basic response of the user at the console— often
    a simple yes or no—and I’ll discuss how such interactive bat files work in [Chapter
    15](chapter15.xhtml). In those rare instances when you request more involved input
    from the user, redirecting stdin saves that data to a file for later use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你可能会在控制台请求用户的基本响应——通常是简单的“是”或“否”——我将在[第 15 章](chapter15.xhtml)讨论这种交互式 bat
    文件如何工作。在那些你请求用户提供更复杂输入的罕见情况下，重定向 stdin 会将数据保存到文件中，以便稍后使用。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, I covered three related topics: outputs, redirection, and
    piping. The stdout and stderr data streams are important and useful interpreter-generated
    outputs, giving you detailed information about a bat file’s execution. These are
    distinct from coder-generated output, the output that you explicitly create. You
    learned how redirection creates new files and appends to existing files. I showed
    how to capture the interpreter-generated output in a trace file or suppress it
    altogether. Individual commands also have output and you learned how to redirect
    it to a file and pipe it to other commands.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了三个相关的主题：输出、重定向和管道。stdout 和 stderr 数据流是重要且有用的由解释器生成的输出，它们为你提供有关 bat
    文件执行的详细信息。这些输出不同于由编码人员生成的输出——你显式创建的输出。你学会了如何通过重定向创建新文件并附加到现有文件。我展示了如何将解释器生成的输出捕获到跟踪文件中或完全抑制它。各个命令也有输出，你学会了如何将其重定向到文件并将其管道传输到其他命令。
- en: Later in this book I’ll discuss many applications of these new tools. In [Chapter
    22](chapter22.xhtml), formatting simple reports with Batch will make great use
    of redirection. I already mentioned the use of piping for text searches and redirection
    with the dir command. In the next chapter, I’ll discuss this extremely useful
    command and everything else you need to know about directories.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我将讨论这些新工具的许多应用。在[第 22 章](chapter22.xhtml)中，使用批处理格式化简单报告将充分利用重定向。我已经提到过使用管道进行文本搜索以及通过
    dir 命令进行重定向。在下一章中，我将讨论这个极为有用的命令以及你需要了解的有关目录的所有内容。
