- en: '17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '17'
- en: USING THE AUTOTOOLS WITH WINDOWS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上使用 Autotools
- en: '*“Well, Steve, I think there’s more than one way of looking at it. I think
    it’s more like we both had this rich neighbor named Xerox and I broke into his
    house to steal the TV set and found out that you had already stolen it.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“嗯，Steve，我认为有不止一种看待这个问题的方式。我觉得更像是我们都有一个富有的邻居，名叫 Xerox，我闯入了他的家偷了电视机，结果发现你已经偷走了它。”*'
- en: —Bill Gates, quoted in* Steve Jobs *by Walter Isaacson*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —比尔·盖茨，引用自*沃尔特·艾萨克森的《史蒂夫·乔布斯》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Autoconf generates configure scripts containing hundreds of lines of Bourne
    shell code. If that statement doesn’t make you wonder how we could ever use the
    Autotools with Windows, you should probably re-read it until it does. In fact,
    the only way Autoconf *can* be used is with an actual Bourne shell and a subset
    of Unix tools like `grep`, `awk`, and `sed`. So before we can even get started,
    we need to ensure that we have a proper execution environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 生成的配置脚本包含数百行 Bourne shell 代码。如果这句话没有让你怀疑我们如何能在 Windows 上使用 Autotools，你可能需要重新读一遍，直到产生疑问。事实上，Autoconf
    *唯一能*使用的方法是借助真实的 Bourne shell 和一些 Unix 工具的子集，如 `grep`、`awk` 和 `sed`。因此，在我们开始之前，需要确保我们有一个合适的执行环境。
- en: When I started working on the first edition of this book, there were few options
    that provided the required environment for building Windows software with the
    Autotools. During the last 10 years, that story has changed. Today, an entire
    gamut of options is available to developers, depending on whether your goal is
    to build Windows applications on Linux or Windows.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编写本书的第一版时，提供构建 Windows 软件所需环境的选项很少。而在过去的 10 年里，这个情况发生了变化。如今，开发者可以根据目标是要在
    Linux 还是 Windows 上构建 Windows 应用程序，选择多种可用选项。
- en: In the last decade, Windows has been viewed by the GNU community as a more important
    target than it has in the past. Significant efforts have been made recently to
    ensure that GNU source code at least considers Windows as a target environment.
    This attitude shift has provided important source-level support for making Cygwin
    and its sibling environments manage clean ports of GNU packages to Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，GNU 社区已将 Windows 视为比以前更重要的目标。最近，已经做出了大量努力，确保 GNU 源代码至少会考虑将 Windows 作为目标环境。这种态度的转变为
    Cygwin 及其相关环境提供了重要的源代码级支持，从而确保将 GNU 软件包清晰地移植到 Windows 上。
- en: Environment Options
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境选项
- en: Since our goal is to build native Windows software using GNU tools, including
    specifically the Autotools, we’re naturally going to have to consider systems
    that provide various levels of POSIX environment functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的目标是使用 GNU 工具，包括特别是 Autotools 来构建原生的 Windows 软件，我们自然需要考虑提供各种级别 POSIX 环境功能的系统。
- en: At one end of the spectrum, we have actual Linux installations, which may take
    any one of several forms, including bare-metal dedicated machine installations
    and virtual machines running on KVM, Xen, or VMware ESX servers or on a Windows
    machine running Microsoft HyperV, VMware Workstation, or Oracle’s VirtualBox.
    There are also Mac options for running virtual machines, and macOS itself provides
    a reasonably POSIX-compliant environment. We could also use Windows Subsystem
    for Linux (WSL).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个光谱的一端，我们有实际的 Linux 安装，可能以多种形式出现，包括裸机专用机器安装、在 KVM、Xen 或 VMware ESX 服务器上运行的虚拟机，或者在运行
    Microsoft HyperV、VMware Workstation 或 Oracle 的 VirtualBox 的 Windows 机器上。也有在 Mac
    上运行虚拟机的选项，macOS 本身也提供了相对符合 POSIX 标准的环境。我们也可以使用 Windows Subsystem for Linux（WSL）。
- en: A full Linux installation obviously provides the most POSIX-compliant environment
    for building software using GNU tools. To actually generate Windows software on
    a Linux system, we have to configure a cross-compile. That is, we have to build
    software that’s not designed to run on the build system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Linux 安装显然提供了最符合 POSIX 标准的环境来使用 GNU 工具构建软件。要在 Linux 系统上生成 Windows 软件，我们必须配置交叉编译。也就是说，我们必须构建那些不打算在构建系统上运行的软件。
- en: At the other end of that spectrum, we have various POSIX environment emulators
    running within Windows applications. The “application” in these cases is almost
    always a Bash shell running in some sort of shell host process or terminal, but
    these environments are more or less compatible with a true Linux build environment.
    The flavors we have to pick from today include Cygwin, MinGW, and MSys2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个范围的另一端，我们有各种在Windows应用程序中运行的POSIX环境模拟器。这些“应用程序”几乎总是某种类型的Bash shell，运行在某个shell宿主进程或终端中，但这些环境或多或少与真正的Linux构建环境兼容。我们今天可以选择的有Cygwin、MinGW和MSys2。
- en: A final option—and one we won’t spend much time on—is that of cross-compiling
    Windows software on other types of systems, including mainframes and supercomputers.
    If you want to see a Windows program compile fast, you should watch it happen
    on a Cray XC50 with an SSD or RAM disk. Since GNU software can run on pretty much
    any Unix system that has a Bourne shell, we can cross-compile software on it for
    any platform, including Windows. After you’ve cross-compiled on Linux, moving
    the process to a different POSIX-compliant platform is relatively simple.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终的选择——我们不会花太多时间讨论——是跨平台编译Windows软件到其他类型的系统，包括大型主机和超级计算机。如果你想看到Windows程序快速编译，你应该看看它在配备SSD或RAM磁盘的Cray
    XC50上编译的过程。由于GNU软件几乎可以在任何具有Bourne shell的Unix系统上运行，我们可以在其上为任何平台进行交叉编译，包括Windows。在Linux上完成交叉编译后，将这个过程转移到其他POSIX兼容平台相对简单。
- en: Tool Chain Options
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具链选项
- en: Once we’ve chosen an environment, we’ll then need to select a tool chain in
    which to build our native software for Windows. Generally speaking, the environment
    you choose limits your tool chain options. For example, if you select a full Linux
    installation, your only tool chain option is to install a cross-compiler for Windows—probably
    *mingw-w64*. Don’t knock it until you’ve tried it—this is a really good option
    because it does a pretty reasonable job of building Windows software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了环境，我们接下来需要选择一个工具链来为Windows构建本地软件。一般来说，你选择的环境会限制你的工具链选项。例如，如果你选择一个完整的Linux安装，那么你唯一的工具链选项就是安装一个Windows的交叉编译器——可能是*mingw-w64*。在你没有尝试之前不要轻视它——这个选项其实非常不错，因为它能够合理地构建Windows软件。
- en: The biggest problem you’ll find here is the inconvenience of having to copy
    your software over to a Windows system in order to test it. In fact, running tests
    as part of your build is pretty much a nonstarter, as you can’t execute your products
    on your build machine.^([1](footnote.xhtml#ch17fn1)) I’ve seen such cross-compilation
    testing done by having a remote copy and execution stage as part of the build
    system’s test phase, but doing this tends to make your build brittle because it
    requires additional environment configuration that’s not part of a normal package
    build process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的最大问题是必须将软件复制到Windows系统上进行测试的不便。事实上，将测试作为构建的一部分几乎是行不通的，因为你不能在你的构建机器上执行产品。^([1](footnote.xhtml#ch17fn1))
    我曾见过通过在构建系统的测试阶段加入远程复制和执行步骤来进行此类交叉编译测试，但这样做往往会让构建变得脆弱，因为它需要额外的环境配置，而这些配置通常不属于正常的包构建过程的一部分。
- en: Getting Started
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始
- en: I’ll present a full cross-section of options for building Windows software using
    GNU tools. We’ll start by using a Windows cross-compiler tool chain on native
    Linux and then check out Windows Subsystem for Linux, and finally move on to the
    remaining Windows-based options, presented in the order they were created. We’ll
    first check out Cygwin on a Windows 10 system. Next, we’ll try MinGW and finally
    finish up with MSys2\. By the time you reach the end of this chapter, you should
    be very comfortable with these processes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示使用GNU工具构建Windows软件的完整选项列表。我们将首先使用Windows交叉编译器工具链在原生Linux上进行编译，然后查看Windows子系统Linux，最后了解剩余的基于Windows的选项，按它们创建的顺序呈现。我们将首先查看Windows
    10系统上的Cygwin。接下来，我们将尝试MinGW，最后结束于MSys2。到本章结束时，你应该对这些过程非常熟悉。
- en: For Windows-based systems, I’ll presume you’re running a reasonably recent copy
    of Windows 10\. I installed *Windows 10 Build 1803* (released April 30, 2018)
    in a virtual machine under Oracle’s VirtualBox on my Linux Mint system. You can
    take this path, or you can use a “bare metal” (nonvirtual) installation of Windows
    10\. The manner in which you choose to run Windows and, to a lesser extent, the
    exact version you choose to run are really not significant issues here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Windows 的系统，我假设你正在运行一个较新的 Windows 10 版本。我在我的 Linux Mint 系统的 Oracle VirtualBox
    虚拟机中安装了 *Windows 10 Build 1803*（2018年4月30日发布）。你可以选择这条路径，也可以选择使用“裸金属”安装（非虚拟）Windows
    10。你选择运行 Windows 的方式以及选择的具体版本，实际上并不是这里的关键问题。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The majority of this book centers on the use of free and open source software
    (FOSS). Microsoft Windows is, of course, not free software. You should pay for
    any copy of Windows—or any other non-free software—you choose to use.^([2](footnote.xhtml#ch17fn2))*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书的主要内容集中在自由和开源软件（FOSS）的使用上。微软 Windows 当然不是自由软件。你应该为你选择使用的任何 Windows 版本——或任何其他非自由软件——付费。^([2](footnote.xhtml#ch17fn2))*'
- en: I’ve also installed Git for Windows^([3](footnote.xhtml#ch17fn3)) on my Windows
    system and cloned the b64 project from [Chapter 13](ch13.xhtml) and Gnulib from
    the Savannah Git server. We won’t be making any significant changes to the b64
    project source code, except to make it work in a given environment where necessary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我也在我的 Windows 系统上安装了 Git for Windows^([3](footnote.xhtml#ch17fn3))，并从 [第13章](ch13.xhtml)
    克隆了 b64 项目和从 Savannah Git 服务器克隆了 Gnulib 项目。除非必要以确保它在给定环境中正常工作，否则我们不会对 b64 项目的源代码做任何重大修改。
- en: When you install Git for Windows, you’ll have the option of downloading a 32-
    or 64-bit version in one of two varieties—as an installer or as a portable package.
    The installer style installs Git on your Windows system in the usual fashion and
    may be uninstalled from the Windows installed-programs panel. The portable style
    requires no installation and can be executed directly from its expanded archive.
    Select an installer or a portable package option for your Windows system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为 Windows 安装 Git 时，你可以选择下载 32 位或 64 位版本，并且可以选择两种格式之一——安装程序或便携包。安装程序格式将 Git
    以常规方式安装到你的 Windows 系统中，并可以通过 Windows 的已安装程序面板卸载。便携格式无需安装，可以直接从解压后的归档文件中运行。请选择适合你
    Windows 系统的安装程序或便携包选项。
- en: If you chose to use an installer, during the installation process you’ll be
    asked how you want Git to treat your source file line endings. I generally avoid
    the first option, which is to “check out” using Windows-style line endings but
    “commit” using Unix-style line endings. You might want to use this option if you’re
    planning to use Notepad as your editor (not advisable). I generally select the
    option to check out and commit as is. Git has no business modifying your source
    files as they pass through it. Just configure your editor to recognize and manage
    line endings the way you like.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用安装程序，在安装过程中你会被询问如何处理源文件的行结束符。我一般避免选择第一个选项，即“检出”时使用 Windows 风格的行结束符，但“提交”时使用
    Unix 风格的行结束符。如果你计划使用记事本作为编辑器（不推荐），你可能想选择这个选项。我通常选择“检出”和“提交”时保持一致。Git 不应该在源文件通过时修改它们。只需将你的编辑器配置为按你喜欢的方式识别和管理行结束符。
- en: Cross-Compiling for Windows on Linux
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上为 Windows 进行交叉编译
- en: Since we’re already running Linux, let’s start our investigation of the options
    right here at home.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在使用 Linux，让我们从这里开始调查相关选项。
- en: '*Installing a Windows Cross Tool Chain*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装 Windows 交叉工具链*'
- en: The first thing we’ll need to do is install a Windows cross-compiler tool chain
    (often referred to simply as a “cross tool chain” or as “cross tools”) on our
    Linux system. The most widely available one is mingw-w64 for Linux, which can
    build native Windows programs and libraries that look very much like they were
    generated by Microsoft tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是在我们的 Linux 系统上安装 Windows 交叉编译工具链（通常简称为“交叉工具链”或“交叉工具”）。最广泛使用的工具链是适用于
    Linux 的 mingw-w64，它可以构建原生的 Windows 程序和库，这些程序和库看起来非常像是由微软工具生成的。
- en: On my Linux Mint system, I searched the internet for *Linux Mint mingw-w64*;
    the top result was my goal. You can generally use your system’s package manager
    to find and install this package because mingw-w64 is pretty popular. On CentOS
    and other Red Hat–based systems, try `yum search mingw-w64`. For Debian-based
    systems like Ubuntu and Mint, try `apt-cache search mingw-w64`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Linux Mint系统上，我搜索了*Linux Mint mingw-w64*；搜索的第一个结果就是我要找的目标。通常，你可以使用系统的包管理器来查找并安装这个包，因为mingw-w64非常流行。在CentOS和其他基于Red
    Hat的系统上，可以尝试`yum search mingw-w64`。对于像Ubuntu和Mint这样的基于Debian的系统，可以尝试`apt-cache
    search mingw-w64`。
- en: Be aware when you run these package searches that you may get back a long result
    list composed of a few dozen real packages and one or two meta packages. It’s
    better to select one of the meta packages so you get all of the required real
    packages in one shot. I highly recommend you search the internet for your distro
    name and *mingw-w64* in order to get some background on which package you should
    install using your package manager. A little research up front can save you a
    lot of headache later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这些包搜索时，请注意，你可能会返回一个很长的结果列表，其中包含几十个实际的包和一两个元包。最好选择其中一个元包，这样你就能一次性获得所有必需的实际包。我强烈建议你搜索一下你的发行版名称和*mingw-w64*，以了解使用包管理器安装哪个包。稍微做些前期研究可以为你后续省去很多麻烦。
- en: 'For example, on my Debian-based system, I got these results from an `apt-cache`
    search:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的基于Debian的系统上，我通过`apt-cache`搜索得到了这些结果：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The actual results list contained dozens of entries, but according to a quick
    internet search, I found the only package I really needed to install was *mingw-w64*
    (highlighted); a meta-package referencing actual packages that install the GCC
    C and C++ compilers for generating 32- and 64-bit Windows software; and a *binutils*
    package containing the librarian, linker, and other common development tools.
    Some package management systems divide this set of packages differently, allowing
    you the option of installing `gcc` and `g++` separately or of installing 32-bit
    and 64-bit code generators separately. Installing this package on my system displays
    the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际结果列表包含了数十个条目，但根据我快速的互联网搜索，我发现我真正需要安装的唯一包是*mingw-w64*（高亮显示）；它是一个元包，引用了实际的包，这些包安装了用于生成32位和64位Windows软件的GCC
    C和C++编译器；以及一个*binutils*包，包含了库管理器、链接器和其他常见的开发工具。有些包管理系统将这些包的集合分开，允许你选择单独安装`gcc`和`g++`，或者单独安装32位和64位代码生成器。在我的系统上安装这个包时，会显示以下输出：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Testing the Build*'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试构建*'
- en: Once you’ve found and installed the proper cross tool chain, you’re ready to
    start building Windows software. I’ve chosen something simple, but not trivial—the
    b64 project from [Chapter 13](ch13.xhtml). It uses Gnulib, so it has a convenience
    library. Gnulib aims for portability, so we can assess how good it is with Windows
    portability, at least for the few modules b64 uses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了并安装了合适的交叉工具链，你就可以开始构建Windows软件了。我选择了一个简单但不琐碎的例子——来自[第13章](ch13.xhtml)的b64项目。它使用Gnulib，因此它有一个便利库。Gnulib的目标是可移植性，因此我们可以评估它在Windows可移植性方面的表现，至少是对b64使用的几个模块的评估。
- en: 'To build for another platform, you need to configure the project for cross-compilation.
    For a full explanation of cross-compiling using the Autotools, see Item 6 in [Chapter
    18](ch18.xhtml). For now, just be aware that the configuration options you’ll
    need are `--build` and `--host`. The first option describes the system on which
    you’ll be building the software, and the second option describes the system on
    which the generated software will be executed. In order to discover our build
    platform, we can run the `config.guess` script installed into the root of our
    project by `automake` (via `autoreconf`). To do this, we’ll need to bootstrap
    the project for a regular build so that `config.guess` gets installed.^([4](footnote.xhtml#ch17fn4))
    Let’s do that within the *b64* directory itself:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要为另一个平台构建，你需要为交叉编译配置项目。有关使用Autotools进行交叉编译的完整说明，请参见[第18章](ch18.xhtml)中的第6节。现在，只需知道你需要的配置选项是`--build`和`--host`。第一个选项描述了你将构建软件的系统，第二个选项描述了生成的软件将要执行的系统。为了发现我们的构建平台，我们可以运行`config.guess`脚本，这个脚本是通过`automake`（通过`autoreconf`）安装到我们项目根目录中的。为了做到这一点，我们需要为常规构建启动项目，以便`config.guess`能够被安装。^([4](footnote.xhtml#ch17fn4))
    让我们在*b64*目录下执行这个操作：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running `config.guess` is how `configure` determines the default value to use
    for the `--build` option, so it will always be correct. Determining the value
    we should use for the `--host` option is just a bit more difficult. We need to
    find the prefix on our cross tool chain, because the `--host` option value is
    what `configure` uses to find the correct tool chain and to set up our `CC` and
    `LD` variables.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`config.guess`是`configure`确定`--build`选项默认值的方式，因此它总是正确的。确定我们应该为`--host`选项使用的值要稍微困难一点。我们需要找到交叉工具链的前缀，因为`--host`选项的值是`configure`用来找到正确工具链并设置我们的`CC`和`LD`变量的。
- en: 'This can be done in a few different ways. You can use your system’s package
    manager to determine what files were installed when you installed the mingw-w64
    meta package, or you can look in your */usr/bin* directory to see what the compiler
    is named—this usually works, and actually *does* work for this tool chain, but
    sometimes cross tool chains are installed into a completely different directory,
    so I’ll use my package manager. Your package manager has similar options, but
    you can follow along directly with my usage if you happen to be on a Debian-based
    system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种不同的方式来完成。你可以使用系统的包管理器来确定安装mingw-w64元包时安装了哪些文件，或者你可以查看*/usr/bin*目录，看看编译器的名称是什么——这种方法通常有效，并且对于这个工具链来说，确实*有效*，但有时交叉工具链会安装到完全不同的目录中，所以我将使用我的包管理器。你的包管理器有类似的选项，但如果你恰好使用的是基于Debian的系统，你可以直接按照我的方法操作：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first command lists all of the installed packages on my system and filters
    the list through `grep`, searching for anything associated with *mingw*. The equivalent
    `rpm` command on Red Hat–based systems would be `rpm -qa | grep mingw`. The package
    I’m looking for will be related to the GCC C compiler and `x86_64` development.
    It will likely look very similar, if not exactly the same, on your system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令列出了我系统上所有已安装的软件包，并通过`grep`过滤列表，查找与*mingw*相关的任何内容。在基于Red Hat的系统中，等效的`rpm`命令是`rpm
    -qa | grep mingw`。我查找的软件包将与GCC C编译器和`x86_64`开发相关。它在你的系统上看起来可能非常相似，甚至完全一样。
- en: The second command lists the files installed by that package. Here, I’m looking
    for the compiler, standard C library, headers, and other target-specific files.
    The equivalent `rpm` command would be `rpm -ql mingw64-gcc`.^([5](footnote.xhtml#ch17fn5))
    The tag I’m searching for is `x86_64-w64-mingw32`. It should look similar in structure
    (but not content) to the value printed previously by our execution of `./config.guess`.
    This is the value that should be used with the `--host` option on the `configure`
    command line. It’s used by `configure` as a prefix for `gcc`, and a careful examination
    of your package manager output will show that there was indeed a program called
    `x86_64-w64-mingw32-gcc` installed into your */**usr/bin* directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令列出了该软件包安装的文件。在这里，我要查找的是编译器、标准C库、头文件和其他特定于目标的文件。等效的`rpm`命令是`rpm -ql mingw64-gcc`。^([5](footnote.xhtml#ch17fn5))我搜索的标签是`x86_64-w64-mingw32`。它的结构应该与我们执行`./config.guess`时之前打印的值相似（但内容不同）。这是应该在`configure`命令行中与`--host`选项一起使用的值。`configure`用它作为`gcc`的前缀，通过仔细检查软件包管理器的输出，你会发现确实有一个名为`x86_64-w64-mingw32-gcc`的程序被安装到你的*/**usr/bin*目录中。
- en: Now let’s use the information we’ve gathered to build b64 for Windows. From
    within the *b64* directory, create a subdirectory called *w64* (or whatever you
    like) and change into it; this will be the build directory we’ll use to build
    a 64-bit Windows version of b64\. Run `../configure` with options to target Windows,
    as follows (assuming we’re still in the *b64* directory):^([6](footnote.xhtml#ch17fn6))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用我们收集到的信息为Windows构建b64。在*b64*目录中，创建一个名为*w64*的子目录（或者你喜欢的名字），并切换到该目录；这是我们将用来构建64位Windows版本b64的构建目录。运行`../configure`并使用目标Windows的选项，如下所示（假设我们仍然在*b64*目录中）：^([6](footnote.xhtml#ch17fn6))
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I’ve highlighted some of the important output lines from `configure` when cross-compiling.
    If you make a mistake entering the `--host` value on the command line, you’ll
    see output similar to the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将一些在交叉编译时`configure`的输出中的重要行标出。如果你在命令行中输入`--host`值时犯了错误，你将看到类似于以下的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The warning is telling you that it could not find a `strip` program called `x86_64-w64-oops-strip`
    (not surprising). Most cross tool chains come with a properly prefixed version
    of `strip` because this is one of the tools in the *binutils* package, so this
    is a reasonable test. If `configure` can’t find a prefixed version of the tools,
    it falls back to using the base names of the tools, which may be perfectly fine
    if your cross tools are named by their base names but simply stored in a different
    directory (which you’ve presumably added to your `PATH`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 警告信息告诉你，它无法找到一个名为`x86_64-w64-oops-strip`的`strip`程序（这并不令人惊讶）。大多数交叉工具链都附带了一个适当前缀的`strip`版本，因为这是*binutils*包中的工具之一，所以这是一个合理的测试。如果`configure`找不到带前缀的工具版本，它将回退到使用工具的基础名称，如果你的交叉工具正好是按基础名称命名并且只是存储在不同的目录（你应该已经将其添加到`PATH`中），那么这样做也许是完全可以的。
- en: 'Now that we’ve configured the build for cross-compilation, everything else
    works exactly the same as a regular Linux build. Try running `make`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为交叉编译配置了构建，其他的一切都与常规的Linux构建完全相同。试试运行`make`：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’ve highlighted the lines that indicate we’re using the *mingw-w64* cross tool
    chain to build b64\. A listing of the *src* directory shows our Windows executable,
    `b64.exe`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了那些指示我们使用*mingw-w64*交叉工具链来构建b64的行。*src*目录的列表显示了我们的Windows可执行文件`b64.exe`。
- en: 'To be complete, let’s copy this program over to a Windows system and give it
    a try. As mentioned previously, I have Windows 10 installed in a virtual machine
    on my Linux system so I can simply run it in place from a Windows-mapped drive
    (`Z:`, in my case):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，让我们将这个程序复制到Windows系统上并尝试一下。如前所述，我在我的Linux系统上安装了Windows 10的虚拟机，因此我可以直接从Windows映射的驱动器（在我的案例中是`Z:`）运行它：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**NOTE**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t be concerned about the *`set /p`* command—it’s just a tricky way of
    echoing text to the Windows console without a trailing newline, since *`cmd.exe`*’s
    *`echo`* statement has no option to suppress the trailing newline.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要担心*`set /p`*命令——它只是一个巧妙的方式，通过Windows控制台回显文本，而不带有结尾换行符，因为*`cmd.exe`*的*`echo`*语句没有选项来抑制结尾换行符*。'
- en: I’m not going to try to tell you that you’ll never experience problems building
    Windows software this way. You will, but they’ll be porting issues related primarily
    to a few POSIX system calls made directly by your project’s source code. I will,
    however, say that whatever problems you do run into will be a proper subset of
    those you’d experience if you tried to use Microsoft tools to build this package.
    In addition to any source-code-porting issues you might find (they’ll still be
    there, even with Microsoft tools), you’d also have to work the kinks out of hand-configured
    Visual Studio solution and project files or Microsoft `nmake` files. For some
    projects, it’s worth the extra effort to be able to access the additional fine-grained
    tuning available when using Microsoft tools. For others, such tuning is not that
    important; building these projects for Windows on a Linux system works very well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会告诉你通过这种方式构建Windows软件时你永远不会遇到问题。你会遇到，但它们主要是与你的项目源代码直接调用的一些POSIX系统调用相关的移植问题。然而，我会说，遇到的任何问题，都会是你尝试使用Microsoft工具构建该软件包时所遇到问题的一个适当子集。除了你可能会发现的任何源代码移植问题（即使使用Microsoft工具，它们依然存在），你还需要解决手动配置的Visual
    Studio解决方案和项目文件或Microsoft `nmake`文件中的问题。对于某些项目，能够访问Microsoft工具提供的额外精细调优是值得付出的额外努力。对于其他项目来说，这种调优并不那么重要；在Linux系统上为Windows构建这些项目工作得非常好。
- en: Windows Subsystem for Linux
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows Subsystem for Linux
- en: Before we leave the Linux world behind, let’s examine the Windows Subsystem
    for Linux (WSL) as an option for building Windows software using GNU tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开Linux世界之前，让我们将Windows Subsystem for Linux（WSL）作为一个选项来构建使用GNU工具的Windows软件。
- en: You can obtain a flavor of Linux for WSL by downloading the version you want
    to use from the Windows Store. Before doing this, however, you must enable the
    optional Windows Subsystem for Linux feature. You can do this either from the
    **Windows Features** panel (type **windows features** into the Cortana search
    bar and select the top result) or from a PowerShell command prompt opened as *Administrator*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从Windows商店下载你想要使用的Linux版本来为WSL获取一个Linux发行版。然而，在此之前，你必须启用可选的Windows Subsystem
    for Linux功能。你可以通过**Windows功能**面板（在Cortana搜索栏中输入**windows features**并选择顶部的结果）或从以*管理员*身份打开的PowerShell命令提示符来完成此操作。
- en: 'From the **Windows Features** panel, scroll down until you find the entry for
    **Windows Subsystem for Linux**, check the associated checkbox, and click **OK**.
    Alternatively, from a PowerShell prompt (as *Administrator*), enter the following
    command and follow the prompts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Windows 特性** 面板中，向下滚动，直到找到 **Windows Subsystem for Linux** 的条目，勾选关联的复选框并点击
    **确定**。或者，在 PowerShell 提示符下（作为 *管理员*），输入以下命令并按照提示操作：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing the Windows Subsystem for Linux will require a system restart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Windows Subsystem for Linux 需要重新启动系统。
- en: Now open the Windows Store and search for “Windows Subsystem for Linux,” select
    the “Run Linux on Windows” search result, and select the Linux flavor you want
    to install. On my system, installing the Ubuntu 18.04 flavor downloaded about
    215MB and installed an “Ubuntu 18.04” icon in my Start menu.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Windows Store，搜索 “Windows Subsystem for Linux”，选择 “Run Linux on Windows”
    的搜索结果，并选择你想安装的 Linux 版本。在我的系统上，安装 Ubuntu 18.04 版本时，下载了大约 215MB，并在开始菜单中安装了一个“Ubuntu
    18.04”图标。
- en: 'Upon first execution, the terminal window displayed text indicating that the
    system was being installed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次执行时，终端窗口显示了系统正在安装的文本：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `mount` command to see how Microsoft integrates the Windows and Linux
    filesystems:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mount` 命令查看 Microsoft 如何集成 Windows 和 Linux 文件系统：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The key item of interest (highlighted) here is the fact that your Windows *C:*
    drive is mounted under */mnt/c* on this Linux installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要特别注意的关键点（已高亮）是，你的 Windows *C:* 驱动器已在该 Linux 安装中挂载到 */mnt/c* 目录下。
- en: On the other side of the coin, the Linux root filesystem is installed into your
    Windows filesystem in the hidden user-specific *AppData* directory. For example,
    I found my Ubuntu 18.04 installation’s root filesystem at *C:\Users\*your-username*\AppData\Local\Packages\CanonicalGroupLimited
    .UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs*.^([7](footnote.xhtml#ch17fn7))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Linux 根文件系统被安装到你的 Windows 文件系统中的隐藏用户特定 *AppData* 目录下。例如，我在 *C:\Users\*你的用户名*\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs*
    中找到了我的 Ubuntu 18.04 安装的根文件系统。^([7](footnote.xhtml#ch17fn7))
- en: 'If you selected a Debian-based distribution, start by updating your system
    software repository cache with `sudo apt-get update`. Then you can install development
    tools like GCC and the Autotools in the usual manner for the distro you selected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了基于 Debian 的发行版，首先使用 `sudo apt-get update` 更新系统软件源缓存。然后，你可以按照所选发行版的常规方式安装开发工具，如
    GCC 和 Autotools：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you’re at all familiar with Ubuntu and `apt`, you’ll see there’s no significant
    difference between the output of the preceding command on WSL Ubuntu 18.04 and
    a native installation of Ubuntu 18.04\. That’s because you’re really running Ubuntu
    18.04 on Windows here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Ubuntu 和 `apt` 有所了解，你会发现 WSL Ubuntu 18.04 上的前述命令输出与原生安装的 Ubuntu 18.04 输出没有显著区别。因为你实际上是在
    Windows 上运行 Ubuntu 18.04。
- en: 'As with a regular installation of Ubuntu 18.04, if you create a *bin* directory
    in your home directory and then open a new Ubuntu 18.04 terminal window, you’ll
    find your personal *bin* directory at the beginning of your `PATH`. Do this now
    so you can create a symlink, *~/bin/gnulib-tools*, that refers to the `gnulib-tool`
    in your Windows clone of Gnulib, as we did when we built b64 on Linux:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的 Ubuntu 18.04 安装类似，如果你在主目录中创建一个 *bin* 目录，然后打开一个新的 Ubuntu 18.04 终端窗口，你会发现你的个人
    *bin* 目录会出现在 `PATH` 的最前面。现在就这样做，以便你可以创建一个符号链接，*~/bin/gnulib-tools*，指向你在 Windows
    上的 Gnulib 克隆中的 `gnulib-tool`，就像我们在 Linux 上构建 b64 时做的那样：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Change into the */mnt/c/Users/.../b64* directory and run `./bootstrap.sh`,
    followed by ./`configure && make` to build b64:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 */mnt/c/Users/.../b64* 目录并运行 `./bootstrap.sh`，接着运行 `./configure && make`
    来构建 b64：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wonderful! Except that this is a Linux program, not a Windows program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！除了这是一个 Linux 程序，而不是一个 Windows 程序：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Attempting to run this program from a Windows command prompt will result in
    the Windows equivalent of a blank stare. You see, what you really have here with
    WSL is an inexpensive form of virtual machine guest with some built-in filesystem
    integration. That’s not to say it’s not useful. It’s very handy to have Linux
    closely integrated with Windows for many purposes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从 Windows 命令提示符运行该程序将得到 Windows 等效的茫然无措。实际上，WSL 本质上是一个廉价的虚拟机客体，带有一些内置的文件系统集成。虽然如此，这并不意味着它没有用处。对于许多用途，将
    Linux 与 Windows 紧密集成是非常便利的。
- en: So what can we do? Our only option is to do the same thing we did on our native
    Linux installation earlier—install mingw-w64 and cross-compile. The process is
    identical, so I won’t reiterate the details. Refer to that discussion in “Cross-Compiling
    for Windows on Linux” on [page 454](ch17.xhtml#page_454) for instructions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该怎么办呢？我们的唯一选择是做和之前在本地Linux安装时做的相同的事情——安装mingw-w64并进行交叉编译。这个过程是相同的，因此我不会再详细重复。有关详细说明，请参阅“在Linux上为Windows进行交叉编译”部分，见[第454页](ch17.xhtml#page_454)。
- en: Cygwin
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cygwin
- en: The Cygwin project was established in 1995 by Cygnus Solutions as an effort
    to create tool chains using GNU software for the various embedded environments
    for which the company was hired to provide development tools.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin项目由Cygnus Solutions于1995年成立，目的是为该公司为各种嵌入式环境提供开发工具的工作，创建基于GNU软件的工具链。
- en: Cygwin’s general philosophy is that GNU packages should be able to be compiled
    for Windows without any modifications to the source code at all. Time is money
    to a support company, and any time not spent modifying source code is money in
    the bank. They wanted their engineers to *use* GNU tools in these environments,
    not spend their time porting them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin的总体哲学是，GNU软件包应该能够在Windows上编译运行，而无需对源代码进行任何修改。对支持公司来说，时间就是金钱，任何不花时间修改源代码的时间都意味着存入银行的钱。他们希望他们的工程师能*使用*这些环境中的GNU工具，而不是花时间将它们移植过去。
- en: So how do they do this? Well, most GNU packages are written in C and use the
    C standard library for accessing most of the system functionality they require.
    The C standard library—being standardized—is portable by definition. Additionally,
    GNU projects strive for portability—at least among Unix flavors. Nevertheless,
    there is a subset of POSIX system functionality of which many GNU packages avail
    themselves, including POSIX threads (pthreads) and system calls like `fork`, `exec`,
    and `mmap`. While recent C and C++ standards now include a threading API, those
    other system calls are very specific to Unix and Linux. In fact, they have no
    direct counterparts on Windows that align well enough to use without some adapter
    code between the caller and the Windows API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它们是如何做到这一点的呢？实际上，大多数GNU软件包都是用C语言编写的，并使用C标准库来访问它们所需的大多数系统功能。C标准库——作为一种标准化的库——天生具有可移植性。此外，GNU项目也致力于可移植性——至少在Unix的不同版本之间是这样。然而，仍然有一些POSIX系统功能，许多GNU软件包会利用它们，包括POSIX线程（pthreads）和像`fork`、`exec`、`mmap`这样的系统调用。虽然最近的C和C++标准已经包括了线程API，但其他一些系统调用则非常特定于Unix和Linux。事实上，这些系统调用在Windows上没有直接的对应功能，要使用它们通常需要在调用者和Windows
    API之间加上一些适配器代码。
- en: For a simple example, when you get right down to the bare metal, the two kernels
    work fundamentally differently with respect to how processes are created. Windows
    uses the Win32 `CreateProcess` function to create a new process and load a program
    into it in a single step. Unix, on the other hand, uses the `fork` and `exec`
    system calls to respectively clone an existing process and replace the contents
    of the clone with another program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，当你回到最基本的层面时，两个内核在创建进程方面的工作原理是根本不同的。Windows使用Win32的`CreateProcess`函数来创建一个新进程并在单个步骤中加载一个程序。而Unix则使用`fork`和`exec`系统调用，分别用来克隆现有进程并将克隆内容替换为另一个程序。
- en: It’s actually fairly easy to replace the `fork`-`exec` pair with a call to `CreateProcess`.
    The true difficulties arise when `fork` is used independently of `exec`, and this
    does happen occasionally.^([8](footnote.xhtml#ch17fn8)) There is simply no way
    to make `CreateProcess` do only half its job.^([9](footnote.xhtml#ch17fn9)) Many
    GNU programs don’t use `fork` without `exec`, but some important ones do. Mapping
    these calls to the Windows API is difficult at best, and it’s often impossible
    without significant structural changes to the source code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将`fork`-`exec`这对调用替换为调用`CreateProcess`是相对容易的。真正的难题出现在`fork`被独立于`exec`使用时，这种情况偶尔会发生。^([8](footnote.xhtml#ch17fn8))
    事实上，无法让`CreateProcess`仅完成它的部分工作。^([9](footnote.xhtml#ch17fn9)) 许多GNU程序不会在没有`exec`的情况下使用`fork`，但也有一些重要的程序会。将这些调用映射到Windows
    API上，即便是在最佳情况下，也是非常困难的，而在没有对源代码进行重大结构性修改的情况下，这几乎是不可能的。
- en: Cygnus therefore elected to create a shim library of POSIX system call functionality.
    This library is called *cygwin1.dll*, and programs built using Cygwin are linked
    to this library and therefore depend on it at runtime. More to the point, every
    standard library call and most system calls pass though *cygwin1.dll* so that
    porting to a new platform without existing tools is an easy process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Cygnus 决定创建一个 POSIX 系统调用功能的 shim 库。这个库被称为 *cygwin1.dll*，通过 Cygwin 构建的程序会链接到这个库，并在运行时依赖它。更重要的是，每个标准库调用和大多数系统调用都会通过
    *cygwin1.dll*，因此在没有现有工具的情况下移植到新平台是一个简单的过程。
- en: You can detect if a Windows program was built for the Cygwin platform by simply
    looking for *cygwin1.dll* in its dependency list.^([10](footnote.xhtml#ch17fn10))
    But the Cygwin platform is not the only target that Cygwin supports. The mingw-w64
    tool chains have been ported to Cygwin and may be used as cross-compilers in Cygwin
    to build native Windows software, just as we did on Linux.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看程序的依赖列表来检测一个 Windows 程序是否为 Cygwin 平台构建，只需查找 *cygwin1.dll* 即可。^([10](footnote.xhtml#ch17fn10))
    但是，Cygwin 平台并不是 Cygwin 支持的唯一目标。mingw-w64 工具链已被移植到 Cygwin，并可以作为交叉编译器在 Cygwin 中使用，构建本地
    Windows 软件，就像我们在 Linux 上所做的那样。
- en: In 1999, Red Hat purchased Cygnus Solutions, and Cygwin has been maintained
    by various Red Hat employees and outside volunteers since then. Because of this
    maturity, Cygwin’s package repository is very large, and its Windows POSIX environment
    is one of the most complete implementations available. Cygwin is one of the most-used
    systems for porting GNU and other software to Windows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 1999 年，Red Hat 收购了 Cygnus Solutions，从那时起，Cygwin 一直由多位 Red Hat 员工和外部志愿者维护。由于其成熟性，Cygwin
    的软件包库非常庞大，其 Windows POSIX 环境是现有实现中最完整的之一。Cygwin 是将 GNU 和其他软件移植到 Windows 上使用最广泛的系统之一。
- en: '*Installing Cygwin*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装 Cygwin*'
- en: To install Cygwin, download the installer from Cygwin’s website at *[https://www.cygwin.com](https://www.cygwin.com)*.
    The installer is called `setup-x86_64.exe`. Cygwin’s installer does not use the
    Windows installation database; you can remove Cygwin merely by deleting its installation
    directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Cygwin，请从 Cygwin 的官方网站下载安装程序，网址为 *[https://www.cygwin.com](https://www.cygwin.com)*。安装程序名为
    `setup-x86_64.exe`。Cygwin 的安装程序不使用 Windows 安装数据库；你只需删除其安装目录即可卸载 Cygwin。
- en: A unique and useful aspect of the Cygwin installer is that it caches its downloaded
    packages at a location of your choice on your filesystem. This cache can then
    be used as a standalone installation source for later installations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin 安装程序的一个独特且有用的特点是，它将下载的软件包缓存到你选择的文件系统位置。这个缓存可以作为独立的安装源，供以后安装时使用。
- en: Running the installer presents a setup wizard, the opening page of which is
    shown in [Figure 17-1](ch17.xhtml#ch17fig1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装程序时会出现一个安装向导，其首页如 [图 17-1](ch17.xhtml#ch17fig1) 所示。
- en: '![Image](../images/17fig01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig01.jpg)'
- en: '*Figure 17-1: The initial copyright screen of the Cygwin64 setup program*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-1：Cygwin64 安装程序的初始版权屏幕*'
- en: Click **Next** to move to the second page of the setup wizard, shown in [Figure
    17-2](ch17.xhtml#ch17fig2).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **下一步** 进入安装向导的第二页，见 [图 17-2](ch17.xhtml#ch17fig2)。
- en: You’re asked here to select how you want to obtain packages. Your options include
    the internet or a local installation directory. You may also elect to download
    files from the internet but not install them, which is useful for building a local
    installation source for installing multiple systems from the same cache of downloaded
    files. Select **Install from Internet** and click **Next** to continue to the
    next page, shown in [Figure 17-3](ch17.xhtml#ch17fig3).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，你需要选择获取软件包的方式。你可以选择通过互联网或本地安装目录获取。你还可以选择从互联网下载文件，但不进行安装，这对于建立本地安装源、从相同的下载文件缓存中为多个系统安装软件很有用。选择
    **从互联网安装**，然后点击 **下一步** 继续到下一页，见 [图 17-3](ch17.xhtml#ch17fig3)。
- en: '![Image](../images/17fig02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig02.jpg)'
- en: '*Figure 17-2: The installation type screen of the Cygwin64 setup program*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2：Cygwin64 安装程序的安装类型屏幕*'
- en: '![Image](../images/17fig03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig03.jpg)'
- en: '*Figure 17-3: The installation location screen of the Cygwin64 setup program*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：Cygwin64 安装程序的安装位置屏幕*'
- en: Here, you’re asked where you want to install Cygwin. The default location is
    *C:\cygwin64*, and it’s recommended that you just stick with this default location,
    though Cygwin does a better job than some of the other installers of managing
    the required system changes if you do choose to install in a nondefault location.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，系统会询问你希望将Cygwin安装到哪里。默认位置是*C:\cygwin64*，建议你保持这个默认位置，尽管如果选择安装到非默认位置，Cygwin在管理所需的系统更改方面要比其他一些安装程序做得更好。
- en: If you’re a Windows power user, you’re very likely feeling that gut-wrenching
    desire right now to change the default location to something more reasonable on
    Windows. I admonish you not to do this. The problem is that you’re trying to view
    Cygwin as an application and, while it technically is one, it can also be viewed
    as being somewhat akin to a full Linux virtual machine installation. It provides
    a foreign (to Windows) development environment, which puts it squarely in the
    camp of a sibling operating system to Windows. From this perspective, it’s perhaps
    a bit easier to understand why the *Cygwin64* directory deserves a special place
    next to the *Windows* directory on your hard drive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Windows的高级用户，现在很可能会有强烈的想法，想将默认位置更改为Windows中更合理的位置。我劝你不要这样做。问题在于，你正试图将Cygwin视为一个应用程序，尽管它从技术上讲是一个应用程序，但它也可以被看作是类似于完整的Linux虚拟机安装。它提供了一个对Windows来说是外部的（外国的）开发环境，这使得它与Windows的操作系统在某种程度上类似。从这个角度来看，也许更容易理解为什么*Cygwin64*目录值得在硬盘上与*Windows*目录并排存在。
- en: Click **Next** to move to the next page, shown in [Figure 17-4](ch17.xhtml#ch17fig4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**进入下一个页面，如[图17-4](ch17.xhtml#ch17fig4)所示。
- en: '![Image](../images/17fig04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig04.jpg)'
- en: '*Figure 17-4: The local package directory screen of the Cygwin64 setup program*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-4：Cygwin64安装程序的本地软件包目录屏幕*'
- en: You’re now asked to select a local package directory. This is the directory
    where downloaded package files are stored. Choose a reasonable location on your
    Windows system—such as your *Downloads* directory. A *cygwin* directory will be
    created at this location and will contain a subdirectory for each internet source
    from which you download packages. Click **Next** to move to the next screen, shown
    in [Figure 17-5](ch17.xhtml#ch17fig5).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要选择一个本地软件包目录。这是存储下载的软件包文件的目录。请选择您Windows系统上一个合理的位置——例如您的*下载*目录。在该位置将创建一个*Cygwin*目录，并包含一个子目录，用于存储从每个互联网源下载的软件包。点击**下一步**进入下一个页面，如[图17-5](ch17.xhtml#ch17fig5)所示。
- en: '![Image](../images/17fig05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig05.jpg)'
- en: '*Figure 17-5: The proxy settings screen of the Cygwin64 setup program*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-5：Cygwin64安装程序的代理设置屏幕*'
- en: You may now select or modify your proxy settings. Usually, you can just use
    the default system proxy settings. Those who use a proxy in their work or home
    environments will be used to configuring this for internet applications and will
    know what to do with the options here. Click **Next** to move to the next screen,
    shown in [Figure 17-6](ch17.xhtml#ch17fig6).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以选择或修改代理设置。通常，你可以使用默认的系统代理设置。那些在工作或家庭环境中使用代理的人，通常已经习惯了为互联网应用程序配置此类设置，并知道如何处理这里的选项。点击**下一步**进入下一个页面，如[图17-6](ch17.xhtml#ch17fig6)所示。
- en: '![Image](../images/17fig06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig06.jpg)'
- en: '*Figure 17-6: The package download source screen of the Cygwin64 setup program*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-6：Cygwin64安装程序的软件包下载源屏幕*'
- en: Select a package download source. As with a Linux distribution, there are multiple
    sites you can use as a package source for Cygwin. Select one that’s geographically
    close to you for the fastest installation and then click **Next** to begin downloading
    the package catalog, shown in [Figure 17-7](ch17.xhtml#ch17fig7).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个软件包下载源。就像Linux发行版一样，你可以使用多个站点作为Cygwin的软件包源。选择一个地理位置接近你的站点，以确保安装速度最快，然后点击**下一步**开始下载软件包目录，如[图17-7](ch17.xhtml#ch17fig7)所示。
- en: '![Image](../images/17fig07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig07.jpg)'
- en: '*Figure 17-7: The package catalog download screen of the Cygwin64 setup program*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-7：Cygwin64安装程序的软件包目录下载屏幕*'
- en: Downloading and parsing the package catalog from the selected source site takes
    only a few seconds, and then the package manager main screen is displayed, as
    shown in [Figure 17-8](ch17.xhtml#ch17fig8).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从选定的源站点下载并解析软件包目录只需几秒钟，随后将显示软件包管理器主界面，如[图17-8](ch17.xhtml#ch17fig8)所示。
- en: '![Image](../images/17fig08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig08.jpg)'
- en: '*Figure 17-8: The package manager screen of the Cygwin64 setup program*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-8：Cygwin64安装程序的软件包管理器屏幕*'
- en: 'I’ve expanded the All root element and the Devel category to show you the first
    few packages in this category, sorted alphabetically. Select the following additional
    packages in the Devel category by clicking the down arrow on the right end of
    the New column and choosing the highest version number available in the list for
    each package (with a few exceptions):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我已展开“所有根元素”和“开发”类别，以显示该类别中的前几个包，按字母顺序排序。在“开发”类别中，选择以下附加包，方法是点击“新建”列右侧的下拉箭头，并为每个包选择列表中可用的最高版本号（有少数例外情况）：
- en: autoconf2.5 (2.69-3)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: autoconf2.5 (2.69-3)
- en: automake (10-1)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: automake (10-1)
- en: automake1.15 (1.15.1-1)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: automake1.15 (1.15.1-1)
- en: binutils (2.29-1)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: binutils (2.29-1)
- en: gcc-core (7.4.0-1)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcc-core (7.4.0-1)
- en: gcc-g++ (7.4.0-1 - optional)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcc-g++ (7.4.0-1 - 可选)
- en: libtool (2.4.6-6)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libtool (2.4.6-6)
- en: make (4.2.1-2)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: make (4.2.1-2)
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you scroll though the list of packages, you’ll note that some have been
    preselected for you. Do not deselect any of the default packages.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*在浏览包列表时，您会注意到一些包已被预选中。请不要取消选择任何默认包。*'
- en: Each entry in this list has a base package name followed by a package version
    in parentheses. The versioning system is similar to that of a standard Linux distribution.
    The upstream source package version is suffixed with a dash, followed by a packager’s
    version. For example, the *autoconf2.5* package has a source package version of
    2.69 and a packager’s version of 3\. The packager’s version is specific to the
    distribution—in this case, Cygwin.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的每一项都包含一个基础包名称，后跟括号中的包版本。版本管理系统类似于标准的 Linux 发行版。上游源包的版本后缀为连字符，后面跟着打包者的版本。例如，*autoconf2.5*
    包的源包版本是 2.69，而打包者的版本是 3。打包者的版本特定于发行版——在本例中是 Cygwin。
- en: Cygwin uses a rolling release mechanism, meaning that Cygwin packages are updated
    somewhat independently as newer source package versions become available and as
    the Cygwin maintainers consume them. The versions I’ve listed here were current
    at the time of this writing. Your most recent version numbers may be newer. Select
    the most recent rather than the ones I’ve listed. Feel free to use the search
    box at the top of the dialog to quickly find the packages in the list. Once you’ve
    selected these additional packages, click **Next** to continue to the next page,
    shown in [Figure 17-9](ch17.xhtml#ch17fig9).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin 使用滚动发布机制，这意味着 Cygwin 包会在更新的源包版本可用时，或 Cygwin 维护者使用这些包时进行独立更新。我在这里列出的版本是写作时的当前版本。您当前的版本号可能更新。请选择最新的版本，而不是我列出的版本。您可以随时使用对话框顶部的搜索框快速查找列表中的包。选择了这些附加包后，点击
    **下一步** 继续到下一页，如[图 17-9](ch17.xhtml#ch17fig9)所示。
- en: '![Image](../images/17fig09.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig09.jpg)'
- en: '*Figure 17-9: The download confirmation screen of the Cygwin64 setup program*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-9：Cygwin64 安装程序的下载确认界面*'
- en: After reviewing the list here to ensure you’ve selected the desired set, click
    **Next** to start the download process, shown in [Figure 17-10](ch17.xhtml#ch17fig10).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 审核此处的列表以确保您选择了所需的包后，点击 **下一步** 开始下载过程，如[图 17-10](ch17.xhtml#ch17fig10)所示。
- en: '![Image](../images/17fig10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig10.jpg)'
- en: '*Figure 17-10: The package download progress screen of the Cygwin64 setup program*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-10：Cygwin64 安装程序的包下载进度界面*'
- en: Since you elected to install only a few packages, this should not take long.
    Once the process completes, click **Next** to continue to the next screen, shown
    in [Figure 17-11](ch17.xhtml#ch17fig11).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您选择仅安装少数几个包，因此这应该不会花费太长时间。过程完成后，点击 **下一步** 继续到下一个界面，如[图 17-11](ch17.xhtml#ch17fig11)所示。
- en: '![Image](../images/17fig11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig11.jpg)'
- en: '*Figure 17-11: The icon selection screen of the Cygwin64 setup program*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-11：Cygwin64 安装程序的图标选择界面*'
- en: 'Select where you’d like icons to be created on your Windows system. You have
    two checkbox options here: Desktop and Start Menu. If you elect not to add any
    icons, you can still run the Cygwin terminal program by executing *C:\cygwin64\cygwin.bat*
    from an Explorer window or from a command or PowerShell prompt.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您希望在 Windows 系统上创建图标的位置。这里有两个复选框选项：桌面和开始菜单。如果您选择不添加任何图标，仍然可以通过在资源管理器窗口或命令提示符或
    PowerShell 提示符中执行 *C:\cygwin64\cygwin.bat* 来运行 Cygwin 终端程序。
- en: Click **Finish** to close the package manager. When you want to modify your
    Cygwin environment by adding or removing packages, or updating your existing packages
    to newer versions, just run `setup-x86_64.exe` again.^([11](footnote.xhtml#ch17fn11))
    You’ll need to go through all the same initial screens, but the package manager
    will remember your previous options and all the packages you currently have installed,
    allowing you to modify the existing configuration as you desire.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **完成** 以关闭包管理器。当你想通过添加或删除软件包，或者更新现有软件包到更新版本时，只需再次运行 `setup-x86_64.exe`。^([11](footnote.xhtml#ch17fn11))
    你需要重新经历所有相同的初始界面，但包管理器会记住你之前的选项和当前已安装的所有软件包，允许你根据需要修改现有配置。
- en: '*Opening the Cygwin Terminal*'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*打开 Cygwin 终端*'
- en: The first execution of the Cygwin terminal indicates that skeleton *.bashrc*,
    *.bash_profile*, *.inputrc*, and *.profile* files are copied into your */home/*username
    directory within the Cygwin filesystem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行 Cygwin 终端时，表示骨架 *.bashrc*、*.bash_profile*、*.inputrc* 和 *.profile* 文件已复制到
    Cygwin 文件系统中的 */home/*username 目录。
- en: 'The best way to understand the Cygwin filesystem is to execute the `mount`
    command within the terminal to display how Cygwin maps your Windows filesystem
    resources into its own filesystem:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Cygwin 文件系统的最佳方式是通过在终端中执行`mount`命令，查看 Cygwin 如何将你的 Windows 文件系统资源映射到它自己的文件系统中：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Cygwin auto-mounts *C:\cygwin64*, *C:\cygwin64\bin*, and *C:\cygwin64\lib* to
    */*, */usr/bin*, and */usr/lib*, respectively. It also auto-mounts all of your
    Windows drive roots to directories named by the drive letter under the */cygdrive*
    directory. I have my Windows operating system installed on the *C:\* drive, and
    I have the *Z:\* drive mapped to my Linux host though VirtualBox’s shared folder
    system. Therefore, I have full access to both my Windows filesystem and my Linux
    host filesystem from within Cygwin’s POSIX environment.^([12](footnote.xhtml#ch17fn12))
    I also have access to Cygwin’s entire filesystem from Windows, via the *C:\Cygwin64*
    directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin 自动将 *C:\cygwin64*、*C:\cygwin64\bin* 和 *C:\cygwin64\lib* 分别挂载到 */*、*/usr/bin*
    和 */usr/lib*。它还会将你的所有 Windows 驱动器根目录自动挂载到 */cygdrive* 目录下，目录名称对应驱动器字母。我将 Windows
    操作系统安装在 *C:\* 驱动器上，并通过 VirtualBox 的共享文件夹系统将 *Z:\* 驱动器映射到我的 Linux 主机。因此，我可以从 Cygwin
    的 POSIX 环境中完全访问我的 Windows 文件系统和 Linux 主机文件系统。^([12](footnote.xhtml#ch17fn12))
    我也可以通过 *C:\Cygwin64* 目录从 Windows 访问 Cygwin 的整个文件系统。
- en: '*Testing the Build*'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试构建*'
- en: Because Cygwin provides access to your Windows environment within its own POSIX
    environment, you can simply run a previously installed standalone copy of Git
    for Windows directly from the Cygwin shell prompt. An even better option, but
    one that only works inside of the Cygwin terminal, is to install Cygwin’s version
    of git from its package manager. Why is this option better? Because Cygwin’s git
    package understands Cygwin’s filesystem conventions better than the Windows version
    does. For instance, the Windows version will sometimes create files with the wrong
    permissions when viewed from a POSIX environment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Cygwin 提供了在其自己的 POSIX 环境中访问 Windows 环境的功能，所以你可以直接从 Cygwin shell 提示符运行之前安装的
    Git for Windows 独立版本。一个更好的选择，但仅适用于 Cygwin 终端内的是，从其包管理器安装 Cygwin 版本的 git。为什么这个选项更好？因为
    Cygwin 的 git 包比 Windows 版本更了解 Cygwin 的文件系统约定。例如，Windows 版本有时在 POSIX 环境中查看时会创建具有错误权限的文件。
- en: 'Unlike MinGW and Msys2, Cygwin can manage symlinks correctly within the Cygwin
    filesystem. Recall from [Chapter 13](ch13.xhtml), and earlier in this chapter,
    that we need to create a symlink to the `gnulib-tool` utility somewhere in our
    `PATH` so that b64’s `bootstrap.sh` script is able to find Gnulib. Let’s do that
    now in the Cygwin terminal. Fill in the elided section of the following command
    with the proper path to your clone of Gnulib:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MinGW 和 Msys2 不同，Cygwin 可以在 Cygwin 文件系统中正确管理符号链接。回想一下 [第 13 章](ch13.xhtml)，以及本章前面的内容，我们需要在
    `PATH` 中的某个位置创建指向 `gnulib-tool` 工具的符号链接，以便 b64 的 `bootstrap.sh` 脚本能够找到 Gnulib。现在让我们在
    Cygwin 终端中进行此操作。将以下命令中省略的部分填写为你克隆的 Gnulib 的正确路径：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command creates a symbolic link in Cygwin’s */usr/bin* directory, referring
    to the `gnulib-tool` program in the root of the Gnulib work area you cloned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 Cygwin 的 */usr/bin* 目录中创建一个符号链接，指向你克隆的 Gnulib 工作区根目录中的 `gnulib-tool` 程序。
- en: By default, Cygwin creates symlinks as text files flagged with the Windows *System*
    (S) attribute, making them invisible to normal Windows directory listing commands
    and within Windows File Explorer. If you examine the contents of a Cygwin symlink
    file, you’ll find it contains a magic cookie, `!<symlink>`, followed by the path
    to the target filesystem entry in UTF-16 format (beginning with the little-endian
    byte order mark, 0xFFFE).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cygwin 将符号链接创建为文本文件，并标记为 Windows *系统*（S）属性，这使得它们在正常的 Windows 目录列出命令和 Windows
    文件资源管理器中不可见。如果你检查 Cygwin 符号链接文件的内容，你会发现它包含一个魔术标记 `!<symlink>`，后面是以 UTF-16 格式（以小端字节顺序标记
    0xFFFE 开头）表示的目标文件系统条目的路径。
- en: You can configure Cygwin to create true Windows symbolic links by exporting
    a `CYGWIN` environment variable containing the text `winsymlinks:nativestrict`.
    However, if you do this, you must then run your Cygwin terminal as Administrator,
    because creating Windows native symbolic links requires administrative rights
    by default. Recent versions of Windows 10 allow native symlinks to be created
    without elevated privileges if you’re willing to switch your system into so-called
    “developer mode.”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导出包含文本 `winsymlinks:nativestrict` 的 `CYGWIN` 环境变量来配置 Cygwin 创建真正的 Windows
    符号链接。然而，如果你这样做，你必须以管理员身份运行 Cygwin 终端，因为默认情况下，创建 Windows 原生符号链接需要管理员权限。Windows
    10 的最近版本允许在不提升权限的情况下创建原生符号链接，前提是你愿意将系统切换到所谓的“开发者模式”。
- en: All that said, Cygwin’s own system of managing symlinks works really well, as
    long as the tools interpreting the links are built for the Cygwin platform. In
    fact, to see the contents of a Cygwin symlink file, you have to use a non-Cygwin
    tool because Cygwin tools will simply follow the symlink file, rather than open
    the file, even from a Windows command prompt!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Cygwin 自己的符号链接管理系统运行得非常好，只要解释链接的工具是为 Cygwin 平台构建的。事实上，要查看 Cygwin 符号链接文件的内容，你必须使用非
    Cygwin 工具，因为 Cygwin 工具会直接跟随符号链接文件，而不是打开文件，即使在 Windows 命令提示符下也是如此！
- en: 'Now, let’s build b64 for Windows. We’ll start by changing directories within
    the Cygwin terminal to the b64 work area you cloned on your Windows system and
    running the `bootstrap.sh` script to pull in our Gnulib dependencies and to run
    `autoreconf -i`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为 Windows 构建 b64。我们将首先在 Cygwin 终端中切换到你在 Windows 系统上克隆的 b64 工作区，并运行 `bootstrap.sh`
    脚本，以拉取我们的 Gnulib 依赖项并运行 `autoreconf -i`：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And now we can simply run `configure` and `make`. We’ll do this from within
    a subdirectory structure so we can reuse this work area for other build types
    later. Note there’s no need to specify `--build` or `--host` options here to set
    up a cross-compile. We’re running “native” Cygwin tools, which automatically build
    Cygwin programs designed to run on the host platform:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地运行 `configure` 和 `make`。我们将在一个子目录结构中执行此操作，这样我们以后可以重用这个工作区进行其他构建类型。注意，这里不需要指定
    `--build` 或 `--host` 选项来设置交叉编译。我们正在运行“本地”Cygwin 工具，这些工具会自动构建设计用于在主机平台上运行的 Cygwin
    程序：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we’ll test our new `b64.exe` program to see if it works on Windows.
    While the Cygwin terminal may look like Linux, it’s really just a Linux-like way
    of accessing Windows, so you can execute Windows programs from the Cygwin terminal.
    This is nice because it allows us to use the Bash version of `echo` with its `-n`
    option to suppress the default linefeed during our testing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将测试我们的新 `b64.exe` 程序，看它是否能在 Windows 上运行。虽然 Cygwin 终端看起来像 Linux，但它实际上只是一种访问
    Windows 的类 Linux 方式，因此你可以从 Cygwin 终端执行 Windows 程序。这一点很好，因为它允许我们在测试过程中使用 Bash 版本的
    `echo`，并通过 `-n` 选项来抑制默认的换行符：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**NOTE**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I did not use the* .exe *extension on the command to reverse the base64 encoding
    operation in this console listing. I wanted to show that, like Windows, Cygwin
    does not require the use of the extension on executable files.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在此控制台列表中没有在命令上使用 .exe 扩展名来反转 base64 编码操作。我想展示的是，像 Windows 一样，Cygwin 不需要在可执行文件上使用扩展名。*'
- en: If you run a dependency checker like Visual Studio’s `dumpbin.exe` or Cygwin’s
    `cygcheck` utility, you’ll find that this version of `b64.exe` depends heavily
    on *cygwin1.dll*, which must be shipped with your program. By default, Cygwin
    builds “Cygwin” software—software designed to run on the Cygwin platform, and
    an important part of the Cygwin platform is *cygwin1.dll* on Windows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行类似 Visual Studio 的 `dumpbin.exe` 或 Cygwin 的 `cygcheck` 工具，你会发现这个版本的 `b64.exe`
    很依赖于 *cygwin1.dll*，它必须与你的程序一起发布。默认情况下，Cygwin 构建的是“Cygwin”软件——即设计用于在 Cygwin 平台上运行的软件，Cygwin
    平台的重要组成部分是在 Windows 上的 *cygwin1.dll*。
- en: '*Building True Native Windows Software*'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建真正的 Windows 原生软件*'
- en: You may also install the mingw-w64 tool chain and compile using the same techniques
    we used in “Cross-Compiling for Windows on Linux” on [page 454](ch17.xhtml#page_454).
    The mingw-w64 tool chain is available in the Cygwin package manager and is a Cygwin
    port of the same tool chain we installed earlier on Linux.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以安装mingw-w64工具链，并使用我们在“[Linux上交叉编译Windows](ch17.xhtml#page_454)”一节中使用的相同技术进行编译。mingw-w64工具链可以通过Cygwin包管理器获取，并且是我们在Linux上安装的同一工具链的Cygwin移植版本。
- en: Let’s do that now. Run the `setup-x86_64.exe` program again and skip through
    all the leading dialogs until you come to the package manager window. After initial
    installation, the default view shown by the package manager window is a list of
    pending updates of packages you’ve already installed. Depending on how long it
    has been since your initial installation, this list may even be empty. Select
    the **Full** option from the **View** drop-down box to return to the complete
    list of packages. Locate and select (under the **Devel** category) the following
    packages for installation. You may see newer version options than I’ve listed
    here; select the latest available to you. You can enter a prefix (**mingw64-**)
    in the **Search** box to narrow down the result list to a subset of packages containing
    those you want.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做。再次运行`setup-x86_64.exe`程序，并跳过所有前置对话框，直到你到达包管理窗口。初始安装后，包管理器窗口显示的默认视图是你已安装软件包的待更新列表。根据你最初安装以来的时间长度，这个列表可能甚至是空的。从**视图**下拉框中选择**完整**选项，返回到完整的软件包列表。定位并选择（在**开发**类别下）以下要安装的软件包。你可能会看到比我列出的版本更新的选项；请选择最新的可用版本。你可以在**搜索**框中输入前缀（**mingw64-**）以缩小结果列表，找到你想要的软件包。
- en: mingw64-i686-gcc-core (7.4.0-1)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mingw64-i686-gcc-core (7.4.0-1)
- en: mingw64-i686-gcc-g++ (7.4.0-1)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mingw64-i686-gcc-g++ (7.4.0-1)
- en: mingw64-x86_64-gcc-core (7.4.0-1)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mingw64-x86_64-gcc-core (7.4.0-1)
- en: mingw64-x86_64-gcc-g++ (7.4.0-1)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mingw64-x86_64-gcc-g++ (7.4.0-1)
- en: The first two of these packages are for generating 32-bit Windows software,
    and the last two are for generating 64-bit Windows software. Click **Next** to
    continue and install these additional packages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个软件包用于生成32位Windows软件，后两个用于生成64位Windows软件。点击**下一步**继续并安装这些额外的软件包。
- en: '**NOTE**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may notice on the summary screen that other packages you did not explicitly
    select are also getting installed. That’s because these four are meta-packages,
    as described previously. If it has been a while since you initially installed
    Cygwin, you may also see updates for packages you previously installed.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会注意到在总结页面上，其他你没有明确选择的软件包也在安装。这是因为这四个软件包是元包，正如前面所描述的那样。如果你从最初安装Cygwin以来已经有一段时间，你可能还会看到之前安装的软件包的更新。*'
- en: 'Create other subdirectories under *b64/cw-builds* for 32- and 64-bit mingw-w64
    builds:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*b64/cw-builds*目录下为32位和64位的mingw-w64构建创建其他子目录：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s start by building the 32-bit Windows program in the *mingw32* directory
    using the i686 variation of the mingw-w64 cross tool set:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始使用mingw-w64交叉工具集的i686变体，在*mingw32*目录中构建32位Windows程序：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Though it may seem odd, you must use the `--build` and `--host` options on the
    `configure` command line here to cross-compile for Windows. The reason is the
    mingw-w64 tool chain is not the default tool chain on Cygwin. All you’re really
    doing is telling `configure` where to find the nondefault tools you want to use.
    From a certain point of view, it actually is a cross-compile because you’re building
    non-Cygwin software on the Cygwin platform.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能有些奇怪，但你必须在`configure`命令行中使用`--build`和`--host`选项进行Windows的交叉编译。原因是mingw-w64工具链不是Cygwin的默认工具链。你实际上是在告诉`configure`在哪里找到你想使用的非默认工具。从某种角度看，这实际上是一个交叉编译，因为你在Cygwin平台上构建非Cygwin软件。
- en: 'Do the same for the 64-bit build:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对64位构建做相同操作：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**NOTE**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It may seem strange that the 64-bit version of the gcc is called *`x86_64-w64-mingw32-gcc`*.
    What’s with that *`32`* on the end of the cross-tool prefix? The reason is that
    mingw was originally a 32-bit Windows compiler, named specifically mingw32\. The
    mingw32 project was eventually renamed to MinGW, but tools and package names are
    harder to change once they’re in widespread use.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*可能会觉得奇怪，64位版本的gcc被称为`x86_64-w64-mingw32-gcc`。那末尾的*`32`*是怎么回事？原因在于mingw最初是一个32位的Windows编译器，专门叫做mingw32。mingw32项目最终更名为MinGW，但一旦工具和包名称被广泛使用，它们就很难再更改了。*'
- en: '*Analyzing the Software*'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分析软件*'
- en: To really understand the differences between these builds, you’ll need to obtain
    a tool for looking inside the `b64.exe` files we generated using each of these
    three tool sets. You can run the `dumpbin.exe` utility that comes with Visual
    Studio or Cygwin’s `cygcheck` tool, if you like. I found a very nice tool called
    *Dependencies* on GitHub by user lucasg.^([13](footnote.xhtml#ch17fn13))
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解这些构建之间的差异，你需要获得一个工具，用来查看我们用这三套工具集生成的`b64.exe`文件。你可以运行与Visual Studio一起提供的`dumpbin.exe`工具，或者使用Cygwin的`cygcheck`工具，如果你愿意的话。我在GitHub上找到了一款非常不错的工具，名为*Dependencies*，由用户lucasg开发。^([13](footnote.xhtml#ch17fn13))
- en: 'First, let’s look at the `cygcheck` output for all three versions of the program.
    We’ll start in the *cw-builds* directory to give us easy access to all of them:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看`cygcheck`工具对于这三种版本程序的输出。我们从*cw-builds*目录开始，这样我们可以轻松访问所有版本：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The concept being conveyed by the hierarchies here is that a library is a direct
    dependency of the library or program directly above it and an indirect dependency
    of ancestors farther up the chain. The Cygwin version at ➊ shows a dependency
    hierarchy with *cygwin1.dll* near the top, just under `b64.exe`, and with all
    other libraries as direct or indirect dependencies of that library. This implies
    that every system or library call made by `b64.exe` is being made directly to
    *cygwin1.dll*, which then calls the other libraries on its behalf.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所传达的概念是，一个库是直接依赖于它上方直接的库或程序，并且是链条中更高层次的祖先的间接依赖。在➊，Cygwin版本显示了一个依赖层次结构，其中*cygwin1.dll*位于顶端，紧接着是`b64.exe`，其余的所有库都是它的直接或间接依赖。这意味着`b64.exe`所做的每个系统或库调用，实际上都是直接调用*cygwin1.dll*，然后由它代表调用其他库。
- en: The 64-bit mingw64 version at ➌ displays a similar hierarchy, except that the
    `b64.exe` program depends directly on *kernel32.dll* and *msvcrt.dll*. This is
    a native Windows program, by all accounts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 64位的mingw64版本在➌显示了一个类似的层次结构，除了`b64.exe`程序直接依赖于*kernel32.dll*和*msvcrt.dll*。这显然是一个本地Windows程序。
- en: My version of the `cygcheck` utility has some problems with 32-bit native Windows
    software. You can see this at ➋, where the tool shows us only the program, `b64.exe`,
    with no library dependencies. To see the true details of this version, let’s switch
    to the Dependencies program I mentioned earlier. I’ve loaded all three versions
    of the program into one instance of Dependencies in [Figure 17-12](ch17.xhtml#ch17fig12).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我版本的`cygcheck`工具在处理32位本地Windows软件时存在一些问题。你可以在➋看到，工具只显示了程序`b64.exe`，没有显示任何库依赖。为了查看这个版本的真实细节，让我们切换到我之前提到的Dependencies程序。我已经将这三个版本的程序加载到一个Dependencies实例中，如[图
    17-12](ch17.xhtml#ch17fig12)所示。
- en: '![Image](../images/17fig12.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig12.jpg)'
- en: '*Figure 17-12: Modules and exports for `b64.exe` built as a 32-bit mingw-w64
    program*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-12：作为32位mingw-w64程序构建的`b64.exe`的模块和导出*'
- en: Here, you can see that the 32-bit mingw-w64 version really does have library
    dependencies similar to those of the 64-bit mingw-w64 version. The 32-bit version
    uses *C:\Windows\SysWOW64\msvcrt.dll*, and the 64-bit version uses *C:\Windows\system32\msvcrt.dll*.
    The same is true of *kernel32.dll*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到32位的mingw-w64版本确实有类似于64位mingw-w64版本的库依赖。32位版本使用的是*C:\Windows\SysWOW64\msvcrt.dll*，而64位版本使用的是*C:\Windows\system32\msvcrt.dll*。*kernel32.dll*也是一样的。
- en: There are additional subtle differences between the Cygwin version and the mingw-w64
    versions. For a simple example, the Cygwin version imports `getopt` from *cygwin1.dll*.
    You’ll perhaps recall that we used the POSIX `getopt` function to parse command
    line options in b64\. You won’t find `getopt` in *msvcrt.dll*, however, so where
    does it come from? The mingw-w64 tool chain provides a static archive of such
    POSIX functionality that ends up becoming a part of `b64.exe`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin版本与mingw-w64版本之间还有一些细微的差别。举个简单的例子，Cygwin版本从*cygwin1.dll*中导入`getopt`。你或许还记得我们在b64中使用了POSIX
    `getopt`函数来解析命令行选项。但是，你不会在*msvcrt.dll*中找到`getopt`，那么它是从哪里来的呢？mingw-w64工具链提供了这样的POSIX功能的静态库，它最终成为了`b64.exe`的一部分。
- en: 'MinGW: Minimalist GNU for Windows'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'MinGW: 最小化GNU工具集（Minimalist GNU for Windows）'
- en: In 1998, Colin Peters authored the initial release of what was then called *mingw32*.
    Later the numbers were dropped in order to avoid the implication that MinGW could
    only generate 32-bit software.^([14](footnote.xhtml#ch17fn14))
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1998年，Colin Peters发布了最初版本的*mingw32*。后来，为了避免给MinGW只能生成32位软件的印象，版本号被去掉了。^([14](footnote.xhtml#ch17fn14))
- en: MinGW initially offered only a Cygwin port of GCC. Sometime later, Jan-Jaap
    Van der Heijden created a native Windows port of GCC and added a *binutils* package
    and GNU `make`. MinGW has been a very popular alternative to Cygwin ever since,
    mainly because of its primary goal of creating software that closely resembles
    software generated by Microsoft tools. For reasonably portable C code, no libraries
    other than Windows system and Visual Studio runtime libraries (*msvcrt.dll*) are
    required. Remember that mingw-w64 was not available until 2013, so MinGW was the
    only available open source option for generating native Windows code for more
    than 10 years.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 最初只提供了 GCC 的 Cygwin 移植版。不久之后，Jan-Jaap Van der Heijden 创建了 GCC 的原生 Windows
    移植版，并添加了 *binutils* 包和 GNU `make`。自那时以来，MinGW 就成为了 Cygwin 的一个非常流行的替代品，主要因为它的核心目标是创建与
    Microsoft 工具生成的软件非常相似的软件。对于合理可移植的 C 代码，除了 Windows 系统和 Visual Studio 运行时库（*msvcrt.dll*）之外，不需要其他任何库。请记住，mingw-w64
    在 2013 年之前是不可用的，因此在超过 10 年的时间里，MinGW 是生成原生 Windows 代码的唯一可用开源选项。
- en: This concept is central to the philosophy espoused by the MinGW project. The
    goal of MinGW is to use only the standard C library as an abstraction layer and
    to modify source code where necessary to make other key packages available under
    MinGW.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一概念是 MinGW 项目所倡导的理念的核心。MinGW 的目标是仅使用标准 C 库作为抽象层，并在必要时修改源代码，以使其他关键包能够在 MinGW
    下使用。
- en: There is a significant portion of GNU software, however, that makes use of the
    *pthreads* library. To accommodate this major set of GNU packages, MinGW gave
    in to pragmatism by providing a library called *pthreads-win32.dll*. This library
    shows up so often in the dependency list for software today that many people don’t
    associate it with MinGW at all. Indeed, some portable software compiled using
    Microsoft’s tools has even used *pthreads-win32.dll* independently, as a portable
    threading library, relying on POSIX threads in both POSIX and Windows environments.^([15](footnote.xhtml#ch17fn15))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GNU 软件中有一大部分使用了 *pthreads* 库。为了适应这一主要的 GNU 软件包，MinGW 通过提供一个名为 *pthreads-win32.dll*
    的库来采取务实的做法。这个库今天在软件的依赖列表中经常出现，以至于许多人并不将它与 MinGW 联系在一起。实际上，一些使用 Microsoft 工具编译的可移植软件甚至独立使用
    *pthreads-win32.dll* 作为可移植的线程库，在 POSIX 和 Windows 环境中都依赖 POSIX 线程。^([15](footnote.xhtml#ch17fn15))
- en: 'There is one major drawback to using MinGW, which is lately becoming more of
    an issue: MinGW still only generates 32-bit native Windows applications. Microsoft
    and Intel have recently announced jointly that some near-future version of Windows
    would only support 64-bit hardware. While 32-bit software will generally run on
    64-bit systems, this may change with time. MinGW’s package repository does not
    provide a port of its GCC compiler that generates 64-bit Windows object code,
    but there are third parties that make mingw-w64 available on the MinGW platform
    if you’re willing to move away from MinGW’s package manager. However, this sort
    of activity is discouraged because adding third-party packages to the environment
    can cause dependency problems the package manager can’t resolve.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MinGW 有一个主要的缺点，最近这个问题变得更加突出：MinGW 仍然只生成 32 位的原生 Windows 应用程序。微软和英特尔最近联合宣布，未来某个版本的
    Windows 将只支持 64 位硬件。虽然 32 位软件通常可以在 64 位系统上运行，但随着时间推移，这种情况可能会发生变化。MinGW 的包库并未提供生成
    64 位 Windows 目标代码的 GCC 编译器，但如果你愿意放弃 MinGW 的包管理器，第三方可以在 MinGW 平台上提供 mingw-w64。然而，这种做法是不被鼓励的，因为将第三方包添加到环境中可能会导致包管理器无法解决的依赖问题。
- en: The MinGW community has survived on its name for many years, and the project
    has only recently started taking monetary donations to help with maintenance.
    Perhaps the additional financial support will spur the community into moving forward
    with these important upgrades.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 社区多年来一直靠着它的名字存活，直到最近该项目才开始接受资金捐赠以帮助维护。或许额外的财务支持能激励社区推动这些重要的升级。
- en: '*Installing MinGW*'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装 MinGW*'
- en: In spite of MinGW generating only 32-bit Windows programs and libraries, it’s
    worth looking at here because using it is so simple and effective for software
    that’s already portable. Once you’ve begun to understand how MinGW and Msys work,
    moving to the other Windows-based POSIX platforms is a trivial task because all
    of them are based on some form of an Msys-like environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 MinGW 仅生成 32 位 Windows 程序和库，但它仍然值得关注，因为使用它对于已经可移植的软件来说非常简单且高效。一旦你开始理解 MinGW
    和 Msys 的工作原理，转向其他基于 Windows 的 POSIX 平台就变得微不足道，因为它们都基于某种类似 Msys 的环境。
- en: 'We’ll start by installing MinGW, which could not be simpler. Navigate in your
    favorite browser to *[http://www.mingw.org](http://www.mingw.org)*. Click the
    **Downloads** tab in the top menu bar. This link takes you to the *osdn.net*^([16](footnote.xhtml#ch17fn16))
    download page for the MinGW project. Scroll down a bit (being careful to avoid
    the ridiculous large green-button advertisement links intended to look like legitimate
    download buttons). Under the gray bar labeled “Operating System: Windows,” click
    the small blue button with the embedded Windows 10–like logo. Save the `mingw-get-setup.exe`
    program to a location on your hard drive.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从安装 MinGW 开始，这个过程简单得不能再简单了。在你喜欢的浏览器中访问 *[http://www.mingw.org](http://www.mingw.org)*。点击顶部菜单栏中的
    **Downloads** 标签。这条链接会带你进入 MinGW 项目的 *osdn.net*^([16](footnote.xhtml#ch17fn16))
    下载页面。向下滚动一些（小心避免点击那些看起来像是合法下载按钮的巨大绿色广告链接）。在标有“Operating System: Windows”的灰色条下，点击带有
    Windows 10 类似图标的小蓝色按钮。将 `mingw-get-setup.exe` 程序保存到你硬盘上的某个位置。'
- en: Running this program presents you with a very simple dialog-based installer
    for the MinGW Installation Manager Setup Tool, as shown in [Figure 17-13](ch17.xhtml#ch17fig13).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，会显示一个非常简单的基于对话框的安装程序界面，用于 MinGW 安装管理器设置工具，如 [图 17-13](ch17.xhtml#ch17fig13)
    所示。
- en: '![Image](../images/17fig13.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig13.jpg)'
- en: '*Figure 17-13: The initial dialog presented by the MinGW Installation Manager
    Setup Tool*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-13：MinGW 安装管理器设置工具展示的初始对话框*'
- en: This program actually installs the MinGW Installation Manager, a tool that,
    much like the Cygwin package manager, allows fine-grained control over the MinGW
    components that get installed or updated. Before the installation manager, the
    only option for updating MinGW was either to uninstall an existing full installation
    and then reinstall a new version from scratch, or try to upgrade, which was a
    hit-and-miss proposition at best.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序实际上安装了 MinGW 安装管理器，它是一个类似于 Cygwin 包管理器的工具，可以精细地控制安装或更新的 MinGW 组件。在安装管理器出现之前，更新
    MinGW 的唯一选择是卸载现有的完整安装版本，然后重新从头开始安装新的版本，或者尝试升级，这样的操作往往是运气成分多。
- en: In spite of the apparent out-of-date copyright range, the setup program and
    the installation manager itself were last refreshed (as of this writing) in September
    of 2017\. The installation manager keeps a package catalog up-to-date, so you
    always have access to the very latest MinGW packages. For instance, a package
    containing GCC 8.2.0 was uploaded in August of 2018\. By the time you read this,
    it will likely have been updated with an even newer version.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管版权日期似乎过时，但根据最新更新（截至本书撰写时），该设置程序和安装管理器本身在 2017 年 9 月最后一次更新。安装管理器会保持软件包目录的最新状态，因此你始终可以访问到最新的
    MinGW 软件包。例如，包含 GCC 8.2.0 的软件包在 2018 年 8 月上传。等你阅读本文时，它可能已经更新为更高版本。
- en: Go ahead and click **Install**. You’re presented with an options page, shown
    in [Figure 17-14](ch17.xhtml#ch17fig14).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 继续点击 **Install**。你将看到一个选项页面，如 [图 17-14](ch17.xhtml#ch17fig14) 所示。
- en: '![Image](../images/17fig14.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig14.jpg)'
- en: '*Figure 17-14: The options page presented by the MinGW Installation Manager
    Setup Tool*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-14：MinGW 安装管理器设置工具展示的选项页面*'
- en: As with Cygwin, MinGW wants to be installed in a path off the root of the system
    drive, and also as with Cygwin, you need to consider MinGW a virtualized operating
    system. As such, it has need of a special place on your Windows filesystem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Cygwin 类似，MinGW 希望被安装在系统驱动器根目录下的路径中，同样像 Cygwin 一样，你需要把 MinGW 当作一个虚拟化的操作系统。因此，它需要在
    Windows 文件系统中一个特殊的地方。
- en: Additionally, like Cygwin, you’ll find MinGW is not installed using the Windows
    installation database and, hence, does not show up in the Windows installed programs
    panel. You can, in fact, completely remove MinGW from your Windows system by merely
    deleting the *C:\MinGW* directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，与 Cygwin 类似，你会发现 MinGW 不是通过 Windows 安装数据库来安装的，因此它不会出现在 Windows 已安装程序面板中。事实上，你只需删除
    *C:\MinGW* 目录，就可以完全从你的 Windows 系统中移除 MinGW。
- en: '**NOTE**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you do decide to install into a different location, you’ll need to carefully
    read the initial installation instructions on the MinGW website, because you’ll
    need to make additional changes to files in the* C:\MinGW\msys\1.0\etc *directory
    after installation.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你决定安装到其他位置，你需要仔细阅读 MinGW 网站上的初始安装说明，因为在安装后，你需要对* C:\MinGW\msys\1.0\etc *目录中的文件做额外的修改。*'
- en: Leave all options as they are and click **Continue**. The next screen you’ll
    see is the download progress page, showing you that the latest installation manager
    program is being downloaded into the *C:\MinGW\libexec\mingw-get* directory. [Figure
    17-15](ch17.xhtml#ch17fig15) shows the state of this dialog once the catalog has
    been updated from the download source and the latest version of the installation
    manager has been downloaded and installed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 保持所有选项不变，然后点击 **继续**。你将看到下一个屏幕，这是下载进度页面，显示最新的安装管理器程序正在被下载到 *C:\MinGW\libexec\mingw-get*
    目录中。 [图 17-15](ch17.xhtml#ch17fig15) 显示了该对话框的状态，一旦目录已从下载源更新，最新版本的安装管理器就会被下载并安装。
- en: '![Image](../images/17fig15.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig15.jpg)'
- en: '*Figure 17-15: The download progress page for the MinGW Installation Manager
    Setup Tool*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-15：MinGW 安装管理器设置工具的下载进度页面*'
- en: Click **Continue** to open the installation manager, shown in [Figure 17-16](ch17.xhtml#ch17fig16).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **继续** 打开安装管理器，如 [图 17-16](ch17.xhtml#ch17fig16) 所示。
- en: '![Image](../images/17fig16.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig16.jpg)'
- en: '*Figure 17-16: The installation manager main screen with package context menu*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-16：安装管理器主屏幕与软件包上下文菜单*'
- en: The packages you see in the Basic Setup panel (shown by default) are actually
    meta-packages, or packages referring to large groups of actual packages. To see
    real packages, you can select the **All Packages** option on the left and then
    scroll through the list displayed on the right. When you’re ready to continue,
    return to the Basic Setup panel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本设置面板中（默认显示的），你看到的软件包实际上是元包，或者说是指向一大组实际包的包。要查看实际包，你可以选择左侧的 **所有软件包** 选项，然后滚动浏览右侧显示的列表。当你准备好继续时，返回到基本设置面板。
- en: Selecting the *mingw-developer-toolkit-bin* meta-package will also automatically
    select the *msys-base-bin* meta-package. These two, plus the *mingw32-base-bin*
    meta-package, are all you need to compile C programs into 32-bit native Windows
    programs. Select these three packages, as shown in [Figure 17-16](ch17.xhtml#ch17fig16),
    and then click the **Apply Changes** option from the **Installation** menu, as
    shown in [Figure 17-17](ch17.xhtml#ch17fig17).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 *mingw-developer-toolkit-bin* 元包时，将自动选择 *msys-base-bin* 元包。这两个元包，再加上 *mingw32-base-bin*
    元包，就是你将 C 程序编译为 32 位原生 Windows 程序所需的所有内容。选择这三个包，如 [图 17-16](ch17.xhtml#ch17fig16)
    所示，然后点击 **应用更改** 选项，位于 **安装** 菜单中，如 [图 17-17](ch17.xhtml#ch17fig17) 所示。
- en: '![Image](../images/17fig17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig17.jpg)'
- en: '*Figure 17-17: Applying selected changes in the installation manager*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-17：在安装管理器中应用所选更改*'
- en: You’re presented with a confirmation dialog titled “Schedule of Pending Actions,”
    which allows you to apply the scheduled changes, defer these changes in order
    to return to the main window and modify the current list, or simply discard all
    changes. Select **Apply**, as shown in [Figure 17-18](ch17.xhtml#ch17fig18).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个名为“待处理操作调度”的确认对话框，允许你应用已调度的更改，推迟这些更改以返回主窗口并修改当前列表，或者简单地丢弃所有更改。选择 **应用**，如
    [图 17-18](ch17.xhtml#ch17fig18) 所示。
- en: '![Image](../images/17fig18.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig18.jpg)'
- en: '*Figure 17-18: The installation manager’s schedule of pending actions dialog*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-18：安装管理器的待处理操作调度对话框*'
- en: Finally, you’re presented with the Download Package dialog, shown in [Figure
    17-19](ch17.xhtml#ch17fig19), in which each of the 112 packages you selected for
    download is displayed with a progress bar.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会看到下载包对话框，如 [图 17-19](ch17.xhtml#ch17fig19) 所示，其中显示了你选择下载的 112 个包，并且每个包都有一个进度条。
- en: '![Image](../images/17fig19.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig19.jpg)'
- en: '*Figure 17-19: *The installation manager’s Download Package dialog**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-19：安装管理器的下载包对话框*'
- en: '**NOTE**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Since the MinGW download site will have undoubtedly been updated after this
    writing, you may see a different number of packages to be installed in the bottom
    pane of the dialog shown in [Figure 17-18](ch17.xhtml#ch17fig18).*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于 MinGW 下载站点在本写作后无疑会有所更新，因此你可能会看到在 [图 17-18](ch17.xhtml#ch17fig18) 显示的对话框底部出现不同数量的软件包待安装。*'
- en: This may take a while, depending on your internet connection, so go grab a snack.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间，具体取决于你的互联网连接速度，所以下去吃点零食吧。
- en: '**NOTE**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you get any package download errors, just click **OK** to dismiss the error
    dialog, wait for the successful download and installation of the remaining packages
    to complete, and then click **Apply Changes** from the **Installation** menu again
    to retry downloading and installing the failed packages. Only the failed packages
    will be redownloaded.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你遇到任何包下载错误，只需点击 **确定** 以关闭错误对话框，等待剩余包的下载和安装成功完成，然后从 **安装** 菜单再次点击 **应用更改**，重新尝试下载和安装失败的包。只有失败的包会被重新下载。*'
- en: Once all packages have been downloaded, they’ll be installed into a standard
    Unix-like directory structure within the *C:\MinGW\msys\1.0* directory. [Figure
    17-20](ch17.xhtml#ch17fig20) shows the installation manager’s Applying Scheduled
    Changes dialog, after it has installed each of the previously downloaded packages.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有包下载完毕，它们将被安装到 *C:\MinGW\msys\1.0* 目录下的标准类 Unix 目录结构中。[图 17-20](ch17.xhtml#ch17fig20)
    显示了安装管理器的应用已安排更改对话框，表示它已安装每个先前下载的包。
- en: '![Image](../images/17fig20.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig20.jpg)'
- en: '*Figure 17-20: The installation manager’s Applying Scheduled Changes dialog*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-20：安装管理器的应用已安排更改对话框*'
- en: You may now close the installation manager program. There is one final step
    in preparing your installation of MinGW—creating a convenient desktop icon for
    the MinGW terminal, which is a somewhat outdated version of the Bash shell ported
    to Windows and running in a Windows Console Host (`conhost.exe`) process. MinGW
    installs a Windows batch file at *C:\MinGW\msys\1.0\msys.bat*. Execute this batch
    file to start the MinGW terminal that provides your POSIX build environment. I
    like to create a shortcut to this file on my desktop and change the icon for it
    to point to the *msys.ico* file found in the same directory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以关闭安装管理器程序了。准备好 MinGW 安装的最后一步是为 MinGW 终端创建一个方便的桌面快捷方式，它是一个稍显过时的 Bash shell
    版本，已移植到 Windows 并在 Windows Console Host (`conhost.exe`) 进程中运行。MinGW 会在 *C:\MinGW\msys\1.0\msys.bat*
    安装一个 Windows 批处理文件。执行该批处理文件启动提供 POSIX 构建环境的 MinGW 终端。我喜欢在桌面上为这个文件创建一个快捷方式，并将图标更改为指向同一目录下的
    *msys.ico* 文件。
- en: Double-click the `msys.bat` file and start up the MinGW terminal. You’ll find
    `pwd` shows that you’re left in the */home/**`username`* directory, where *`username`*
    is your Windows system user name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `msys.bat` 文件，启动 MinGW 终端。你会发现，`pwd` 显示你仍然处于 */home/**`username`* 目录，其中 *`username`*
    是你的 Windows 系统用户名。
- en: 'As with Cygwin, the best way to understand the filesystem is to use `mount`
    to view the mount points in the MinGW filesystem:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Cygwin 一样，理解文件系统的最佳方式是使用`mount`查看 MinGW 文件系统中的挂载点：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This output looks similar to its Cygwin counterpart, but there are a few differences.
    First, MinGW mounts your Windows user temporary directory as */tmp*. Second, both
    */usr* and */* represent the same Windows directory, *C:\MinGW\msys\1.0*. Finally,
    *C:\MinGW* itself is mounted under */mingw*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来和 Cygwin 中的类似，但有一些区别。首先，MinGW 将你的 Windows 用户临时目录挂载为 */tmp*。其次，*/usr*
    和 */* 都代表相同的 Windows 目录，*C:\MinGW\msys\1.0*。最后，*C:\MinGW* 本身被挂载到 */mingw* 下。
- en: Windows drives are managed a bit differently also. Windows drive letters show
    up in the MinGW filesystem as they do in Cygwin, but they’re listed directly under
    the root, rather than as a separate top-level directory. Another subtle difference
    here is that my *D:* drive is listed. It’s a virtual optical drive, with no media
    mounted. MinGW chooses to show it even without media, while Cygwin only shows
    it with media.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 驱动器的管理方式也略有不同。Windows 驱动器字母会像在 Cygwin 中一样显示在 MinGW 文件系统中，但它们直接列在根目录下，而不是作为单独的顶级目录。这里还有一个细微的区别是，我的
    *D:* 驱动器被列出了。它是一个虚拟光驱，没有挂载介质。MinGW 即使没有介质也会显示它，而 Cygwin 只有在挂载了介质时才显示它。
- en: If you `cat` the contents of the */etc/fstab* file, you can see that most of
    the preceding is hardcoded. The only mount point that’s actually soft-configured
    is the */mingw* path:^([17](footnote.xhtml#ch17fn17))
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你 `cat` 查看 */etc/fstab* 文件的内容，你会看到前面大多数内容是硬编码的。唯一实际软配置的挂载点是 */mingw* 路径：^([17](footnote.xhtml#ch17fn17))
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Testing the Build*'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试构建*'
- en: 'We’re now ready to try building the b64 project. First, we should clean up
    the *b64* directory in order to demonstrate `bootstrap.sh` in this environment,
    so change into the *b64* directory from your MinGW terminal and use `git` to remove
    all artifacts. Then make a build directory structure for testing MinGW:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备尝试构建 b64 项目。首先，我们应该清理 *b64* 目录，以便在此环境中演示 `bootstrap.sh`，所以请从 MinGW 终端进入
    *b64* 目录并使用 `git` 删除所有工件。然后，为测试 MinGW 创建一个构建目录结构：
- en: '[PRE26]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At this point, rather than lead you down a sure path to failure, I’ll state
    up front that you’ll immediately run into problems with symbolic links. While
    Cygwin has no trouble properly creating and using symlinks in its environment,
    the same is not true of MinGW. If you attempt to create a symlink from `/usr/bin/gnulib-tool`
    to the `.../gnulib/gnulib-tool` program, you’ll find the `ln -s` command seems
    to work, but when you try to run `bootstrap.sh`, it fails to find Gnulib. A closer
    examination shows that the symlink you thought you created was actually just a
    copy. Well, a copy won’t work, because `gnulib-tool` uses its real location in
    the filesystem as the base of the Gnulib repository and a copy of `gnulib-tool`
    in another location cannot do this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，为了不让你走向必然的失败，我先声明，你很快会遇到符号链接的问题。虽然 Cygwin 在其环境中没有问题地创建和使用符号链接，但 MinGW
    就不一样了。如果你尝试从 `/usr/bin/gnulib-tool` 创建一个指向 `.../gnulib/gnulib-tool` 程序的符号链接，你会发现
    `ln -s` 命令似乎执行了，但当你尝试运行 `bootstrap.sh` 时，它却找不到 Gnulib。仔细检查后，你会发现你以为创建的符号链接其实只是一个复制品。嗯，复制品是行不通的，因为
    `gnulib-tool` 使用它在文件系统中的实际位置作为 Gnulib 仓库的基准，而在另一个位置的 `gnulib-tool` 复制品无法做到这一点。
- en: To fix this problem, we’ll have to adjust b64’s `bootstrap.sh` program to use
    a relative path to the actual `gnulib-tool`. I cloned gnulib right next to b64,
    so I merely have to change `bootstrap.sh` so that it refers to `../gnulib/gnulib-tool`,
    rather than relying on its being accessible from the system `PATH`. Use any editor
    to make changes similar to those highlighted in [Listing 17-1](ch17.xhtml#ch17ex1)
    on your system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要调整 b64 的 `bootstrap.sh` 程序，使用相对路径来引用实际的 `gnulib-tool`。我将 gnulib
    克隆到 b64 旁边，所以我只需要更改 `bootstrap.sh`，使其引用 `../gnulib/gnulib-tool`，而不再依赖系统 `PATH`
    中的可访问路径。使用任何编辑器，按照[清单 17-1](ch17.xhtml#ch17ex1)中的提示，在你的系统上进行类似的更改。
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 17-1:* b64/bootstrap.sh: *Changes required to allow MinGW to find
    Gnulib*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-1:* b64/bootstrap.sh: *允许 MinGW 找到 Gnulib 所需的更改*'
- en: '**NOTE**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*After making these changes to *`bootstrap.sh`*, you should expect to see different
    output when you run *`b64.exe`* against it.*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*在对 *`bootstrap.sh`* 做出这些更改后，你应该期待在运行 *`b64.exe`* 时看到不同的输出。*'
- en: That will fix our Gnulib issues, but there’s another problem lurking here. While
    MinGW may have the very latest GCC tool chain, it doesn’t stay as current with
    the Autotools. We’ve been working with Autoconf 2.69 and Automake 1.15.1, but
    as of this writing, MinGW only provides Autoconf 2.68 and Automake 1.11.1\. Perhaps
    by the time you read this, these tools will have been updated, and you will not
    have to make the changes to *configure.ac* shown in [Listing 17-2](ch17.xhtml#ch17ex2).
    Check your Autoconf and Automake versions before making these changes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决我们在 Gnulib 上遇到的问题，但这里还有另一个潜在问题。虽然 MinGW 可能拥有最新的 GCC 工具链，但它在 Autotools 上的更新没有那么及时。我们一直在使用
    Autoconf 2.69 和 Automake 1.15.1，但截至本文写作时，MinGW 只提供 Autoconf 2.68 和 Automake 1.11.1。也许等你阅读本文时，这些工具已经更新，你就不必做出文中[清单
    17-2](ch17.xhtml#ch17ex2)中所示的更改。请在做这些更改之前，先检查一下你的 Autoconf 和 Automake 版本。
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 17-2:* b64/configure.ac: *Changes required to work with Autoconf 2.68*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-2:* b64/configure.ac: *与 Autoconf 2.68 配合使用所需的更改*'
- en: The highlighted lines show the changes that need to be made. First, we need
    to reduce the lowest supported version in `AC_PREREQ` to allow Autoconf 2.68 to
    process this *configure.ac* file. Then we need to change the Automake macro, `AC_CONFIG_MACRO_DIRS`
    (plural), to its Autoconf counterpart, `AC_CONFIG_MACRO_DIR`. It works the same,
    except that the one that comes with Automake 1.15.1 makes it possible for us to
    forego the use of `AC_LOCAL_AMFLAGS = -I m4` in our *Makefile.am* file. Luckily,
    I had already added that line into *Makefile.am* and just left it there, so this
    change is easy. Finally, Automake 1.15.1 consolidated the functionality of `AM_PROG_CC_C_O`
    into the `AM_INIT_AUTOMAKE` macro when the `subdir-objects` option is given. Moving
    back to Automake 1.11.1 requires us to change to the old format where we have
    to explicitly mention `AM_PROG_CC_C_O` and it must come after `AC_PROG_CC`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮的行显示了需要进行的更改。首先，我们需要将 `AC_PREREQ` 中支持的最低版本降低，以允许 Autoconf 2.68 处理这个 *configure.ac*
    文件。然后，我们需要将 Automake 宏 `AC_CONFIG_MACRO_DIRS`（复数形式）更改为它的 Autoconf 对应宏 `AC_CONFIG_MACRO_DIR`。这两个宏的功能相同，只不过
    Automake 1.15.1 版本中的宏使我们能够省略在 *Makefile.am* 文件中使用 `AC_LOCAL_AMFLAGS = -I m4`。幸运的是，我已经把这一行加到了
    *Makefile.am* 中，并且一直保留在那里，所以这个更改很容易。最后，Automake 1.15.1 将 `AM_PROG_CC_C_O` 的功能合并到
    `AM_INIT_AUTOMAKE` 宏中，当启用 `subdir-objects` 选项时。如果回退到 Automake 1.11.1，我们需要改回旧的格式，显式地提到
    `AM_PROG_CC_C_O`，并且它必须位于 `AC_PROG_CC` 之后。
- en: 'After these changes, we can finally run `bootstrap.sh` to generate our `configure`
    script:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改后，我们可以最终运行 `bootstrap.sh` 来生成我们的 `configure` 脚本：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now change into the *mgw-builds/mingw* directory created earlier and run `configure`
    with a relative path back to *b64*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入之前创建的 *mgw-builds/mingw* 目录，并使用相对路径运行 `configure` 回到 *b64*：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Opening `b64.exe` in `DependenciesGUI.exe` shows us it’s a 32-bit Windows program
    that depends only on `SysWOW64\kernel32.dll` and `SysWOW64\MSVCRT.dll`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DependenciesGUI.exe` 中打开 `b64.exe` 会显示它是一个仅依赖 `SysWOW64\kernel32.dll` 和 `SysWOW64\MSVCRT.dll`
    的 32 位 Windows 程序。
- en: Msys2
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Msys2
- en: Msys2 was developed by a company called OneVision Software in 2013 using “clean
    room” techniques in order to loosen up the open source licensing requirements
    imposed by Cygwin and to provide a more modern alternative to the old out-of-date
    Msys environments used by Cygwin and MinGW.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2 由 OneVision Software 公司于 2013 年开发，采用“清洁室”技术，以便放宽 Cygwin 强加的开源许可要求，并为 Cygwin
    和 MinGW 使用的过时 Msys 环境提供更现代的替代方案。
- en: MSys2 uses a OneVision 64-bit port of the MinGW tool chain called *mingw-w64*.
    However, like Cygwin, Msys2 provides its own library of POSIX system-level functionality
    called *msys-2.0.dll*. Msys2 provides a C standard library implemented in terms
    of this library. You can detect if a Windows program was built for the Msys2 platform
    in the same manner as previously described for the Cygwin platform.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: MSys2 使用的是 OneVision 64 位版本的 MinGW 工具链，称为 *mingw-w64*。然而，像 Cygwin 一样，Msys2 提供了一个名为
    *msys-2.0.dll* 的 POSIX 系统级功能库。Msys2 提供了一个以这个库为基础实现的 C 标准库。你可以像检测 Cygwin 平台一样，检测一个
    Windows 程序是否为 Msys2 平台构建。
- en: Because Msys2 is more or less a feature-for-feature replacement of Cygwin, and
    since so many people are already used to the way Cygwin works, Msys2 has had a
    difficult time gaining traction, though it is used by some key players, including
    Git for Windows. Msys2 is advertised as an upgrade to Cygwin, but Msys2 merely
    provides different implementations of the same portability mechanisms used by
    Cygwin.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Msys2 在很大程度上是 Cygwin 的功能替代品，而且由于很多人已经习惯了 Cygwin 的工作方式，Msys2 在推广上遇到了一些困难，尽管它已经被一些关键用户使用，包括
    Git for Windows。Msys2 被宣传为 Cygwin 的升级版，但实际上 Msys2 仅提供了与 Cygwin 相同的可移植性机制的不同实现。
- en: The one distinguishing characteristic that sets Msys2 apart from Cygwin is the
    fact that Msys2’s open source license is much more lenient than that of Cygwin.
    While Cygwin uses GPL-based licensing, Msys2 uses only a standard 3-clause BSD
    license, making it a viable option for building proprietary Windows software using
    Linux tools.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 区分 Msys2 和 Cygwin 的一个显著特点是，Msys2 的开源许可证比 Cygwin 更宽松。Cygwin 使用基于 GPL 的许可证，而 Msys2
    仅使用标准的 3 款 BSD 许可证，这使得它成为使用 Linux 工具构建专有 Windows 软件的可行选项。
- en: The most significant offering in OneVision’s system is the 64-bit port of the
    MinGW compiler—not that it runs on 64-bit platforms (which it does), but that
    it generates 64-bit Windows code. It’s safe to say that the world of cross-compiled
    Windows code was expanded dramatically when this compiler was released. It has
    since been ported to many different platforms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: OneVision 系统中最重要的功能是 MinGW 编译器的 64 位移植版——这不仅仅是因为它运行在 64 位平台上（它确实如此），更因为它生成 64
    位的 Windows 代码。可以说，当这个编译器发布时，跨编译 Windows 代码的世界得到了极大的扩展。此后，它已被移植到许多不同的平台上。
- en: Msys2 does tie into the Windows installation database, so you may uninstall
    Msys2 from the Windows installed-programs panel.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2 会与 Windows 安装数据库连接，因此你可以通过 Windows 安装程序面板卸载 Msys2。
- en: '*What’s Msys?*'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*什么是 Msys？*'
- en: The term “Msys” has been misused for many purposes over the years. Some think
    it means “Unix on Windows” or, at the very least, the sense of such. All it really
    provides is potential. Msys, at its most basic, provides a Unix-compatible terminal
    program, a Bourne-like shell (usually Bash), and a base set of utilities. Some
    implementations have more and some have fewer utilities. Whatever implementation
    you’re using, be it Cygwin, MinGW, or Msys2, the Msys component of these packages
    is there for you to build upon by installing additional packages to build up the
    environment the way you like.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: “Msys” 这个术语多年来被错误使用。有人认为它意味着“Windows 上的 Unix”，或者至少是类似的意思。实际上，它所提供的只是潜力。最基本的
    Msys 提供了一个 Unix 兼容的终端程序，一个类似 Bourne 的 shell（通常是 Bash），以及一套基础的实用程序。一些实现提供了更多的工具，而一些则提供了较少的工具。不管你使用的是哪种实现，Cygwin、MinGW
    还是 Msys2，这些包中的 Msys 组件都可以让你通过安装额外的包来构建你喜欢的环境。
- en: When OneVision created Msys2, the company’s vision was to start out small, allowing
    the user to build up the environment exactly the way they wanted. Msys2’s version
    of Msys has very few packages preinstalled, while Cygwin has many. Msys2 and Cygwin
    base their terminal window on `mintty.exe`,^([18](footnote.xhtml#ch17fn18)) while
    MinGW bases its terminal on `conhost.exe` (Windows console host process), and
    you can tell this is so because the look and feel of the Cygwin and Msys2 terminals
    are very similar to each other, but significantly different from that of MinGW.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当OneVision创建Msys2时，公司的愿景是从小做起，让用户能够按照自己的需求构建环境。Msys2版本的Msys预装的包非常少，而Cygwin预装了许多。Msys2和Cygwin的终端窗口都基于`mintty.exe`，^([18](footnote.xhtml#ch17fn18))
    而MinGW则基于`conhost.exe`（Windows控制台宿主进程），你可以从外观和操作感受上判断这一点，因为Cygwin和Msys2的终端看起来非常相似，但与MinGW的终端有显著的不同。
- en: '*Installing Msys2*'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装Msys2*'
- en: The installation procedure for Msys2 is pretty simple. Navigate in your web
    browser to the Msys2 home page at *[http://www.msys2.org](http://www.msys2.org)*
    and click the button at the top of the page for either the 32-bit (`msys2-i686-`*`yyyymmdd`*`.exe`)
    or the 64-bit (`msys2-x86_64-`*`yyyymmdd`*`.exe`) version of the Msys2 installer.^([19](footnote.xhtml#ch17fn19))
    When the download completes, run the installer and you’re presented with a dialog-based
    installation wizard. The welcome page is shown in [Figure 17-21](ch17.xhtml#ch17fig21).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2的安装过程非常简单。在你的网页浏览器中导航到Msys2的主页*[http://www.msys2.org](http://www.msys2.org)*，然后点击页面顶部的按钮，选择32位(`msys2-i686-`*`yyyymmdd`*`.exe`)或64位(`msys2-x86_64-`*`yyyymmdd`*`.exe`)版本的Msys2安装程序。^([19](footnote.xhtml#ch17fn19))
    下载完成后，运行安装程序，你将看到一个对话框式的安装向导。欢迎页面如[图17-21](ch17.xhtml#ch17fig21)所示。
- en: '![Image](../images/17fig21.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig21.jpg)'
- en: '*Figure 17-21: The welcome page of the Msys2 install utility*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-21：Msys2安装工具的欢迎页面*'
- en: Click **Next** to move to the next page, shown in [Figure 17-22](ch17.xhtml#ch17fig22).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**进入下一页面，如[图17-22](ch17.xhtml#ch17fig22)所示。
- en: '![Image](../images/17fig22.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig22.jpg)'
- en: '*Figure 17-22: The installation folder page of the Msys2 install utility*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-22：Msys2安装工具的安装文件夹页面*'
- en: Select an installation location. Like Cygwin and MinGW, Msys2 wants to be installed
    at the root of the system drive. I recommend sticking with the default location
    for the same reasons I gave for the other two systems. Click **Next** to move
    to the next page, shown in [Figure 17-23](ch17.xhtml#ch17fig23).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 选择安装位置。像Cygwin和MinGW一样，Msys2也希望安装在系统驱动器的根目录下。我建议使用默认位置，原因和我对另外两个系统的建议相同。点击**下一步**进入下一页面，如[图17-23](ch17.xhtml#ch17fig23)所示。
- en: '![Image](../images/17fig23.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig23.jpg)'
- en: '*Figure 17-23: The shortcuts page of the Msys2 install utility*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-23：Msys2安装工具的快捷方式页面*'
- en: You can select the Windows Start Menu folder in which you’d like the installer
    to create its shortcuts. The default is sufficient. Click **Next** to move to
    the next page and begin installation, shown in [Figure 17-24](ch17.xhtml#ch17fig24).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择Windows开始菜单文件夹，安装程序将在其中创建快捷方式。默认设置已经足够。点击**下一步**进入下一页面，开始安装，如[图17-24](ch17.xhtml#ch17fig24)所示。
- en: '![Image](../images/17fig24.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig24.jpg)'
- en: '*Figure 17-24: The installation progress page (showing details) of the Msys2
    install utility*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-24：Msys2安装工具的安装进度页面（显示详细信息）*'
- en: When installation has completed, click **Next** to move to the final page, shown
    in [Figure 17-25](ch17.xhtml#ch17fig25).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，点击**下一步**进入最后一页，如[图17-25](ch17.xhtml#ch17fig25)所示。
- en: '![Image](../images/17fig25.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/17fig25.jpg)'
- en: '*Figure 17-25: The final page of the Msys2 install utility*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-25：Msys2安装工具的最后一页*'
- en: You’re given the option here of starting Msys2 upon completion. Click **Finish**
    to exit the installer. Allow the installer to execute Msys2 as it exits or go
    to the Windows 10 Start Menu, locate the **MSYS2 64bit** folder, and click the
    **MSYS2 MSYS** entry. Both options start the Msys2 terminal window in the same
    manner by executing the `C:\msys64\msys2_shell.cmd` script with a command line
    option of `-msys`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，你可以选择在安装完成后启动Msys2。点击**完成**退出安装程序。你可以让安装程序在退出时自动启动Msys2，或者转到Windows 10开始菜单，找到**MSYS2
    64bit**文件夹，然后点击**MSYS2 MSYS**条目。这两种方式都会通过执行`C:\msys64\msys2_shell.cmd`脚本并带有`-msys`命令行选项来启动Msys2终端窗口。
- en: Unlike the other systems’ installers, the Msys2 installer doesn’t download packages
    from the internet. Rather, much like a Linux distribution release, Msys2 installs
    a small base set of packages that get further out-of-date as time goes by until,
    eventually, a new installer is made available by the Msys2 maintainers. Therefore,
    the first thing you need to do is update these installed base packages.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他系统的安装程序不同，Msys2 安装程序不会从互联网上下载包。而是像 Linux 发行版发布一样，Msys2 安装一小部分基础包，这些包会随着时间的推移变得越来越过时，直到最终，Msys2
    维护者发布了一个新的安装程序。因此，首先需要做的就是更新这些已安装的基础包。
- en: Msys2 uses a Windows port of the Arch Linux package manager, Pacman, to provide
    access to repositories of packages ported to Msys2\. The basic installation provides
    relatively few packages, and it needs to be updated with Pacman before additional
    packages can be installed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2 使用 Arch Linux 包管理器 Pacman 的 Windows 移植版，提供对移植到 Msys2 的包仓库的访问。基本安装提供的包比较少，需要先用
    Pacman 更新才能安装更多的包。
- en: With the terminal window open, we’ll update the Msys2 system using the command
    `pacman -Syu`. Pacman commands are uppercase, and options to those commands are
    lowercase. The `-S` command is the remote repository “sync” command. The `-u`
    option of this command updates existing packages from the remote repository. The
    `-y` option updates the catalog from the repository before checking for updates.
    To get help on the commands, run `pacman -h`. To get help on the available options
    for a command, add `-h` to the command line along with the command. For example,
    to get help on available options for the `-S` command, run `pacman -Sh`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，我们将使用命令`pacman -Syu`来更新 Msys2 系统。Pacman 命令是大写的，命令的选项是小写的。`-S`命令是远程仓库的“同步”命令。此命令的`-u`选项会从远程仓库更新现有包。`-y`选项会在检查更新前更新仓库的目录。要获取命令的帮助，请运行`pacman
    -h`。要获取某个命令的可用选项的帮助，请在命令行中加上`-h`和该命令。例如，要获取`-S`命令的可用选项的帮助，请运行`pacman -Sh`。
- en: 'Go ahead and update the system now, downloading the latest catalog first:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续更新系统，首先下载最新的目录：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Press y (or just enter to accept the default) at the prompt to continue updating
    the Msys2 system. You’ll note the small number of packages being updated. The
    base Msys2 system provides almost nothing. The core system comes with Bash, a
    Unix-like filesystem emulator that sits on top of the Windows filesystem, mintty,
    the Msys2 Msys runtime, and the Pacman package manager, so it’s not really a problem
    that the Msys2 installer installs out-of-date packages that need to be updated
    upon first use.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时按 y（或直接按回车接受默认设置）继续更新 Msys2 系统。你会注意到更新的包数量很少。基础 Msys2 系统几乎什么都没有。核心系统包括 Bash，一个类似
    Unix 的文件系统模拟器，位于 Windows 文件系统之上；mintty，Msys2 的 Msys 运行时；以及 Pacman 包管理器，因此 Msys2
    安装程序安装过时的包并在首次使用时需要更新其实并不是问题。
- en: 'Pacman will download and install several packages, including Pacman:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Pacman 将下载并安装多个包，包括 Pacman：
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When you reach this point, Pacman itself needs to be updated, but it cannot
    update itself while it’s running—an artifact of the way Windows manages running
    executable images. It displays a message indicating that you should close the
    terminal window by clicking the X in the upper-right corner and then restart Msys2
    from the Windows Start Menu and continue the installation process.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达此步骤时，Pacman 本身需要更新，但它无法在运行时进行自我更新——这是 Windows 管理运行中可执行文件的方式所带来的一个结果。它会显示一条消息，提示你应该通过点击右上角的
    X 关闭终端窗口，然后从 Windows 开始菜单重新启动 Msys2 并继续安装过程。
- en: '**NOTE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you get a pop-up box warning you of running processes, just click ***OK***
    to close the window anyway.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你看到弹出框警告有正在运行的进程，只需点击***确定***关闭窗口即可。*'
- en: Run `pacman -Su` again (no need to update the catalog again) to continue the
    update process and press enter when prompted again. This time, many more packages
    are updated. Press y (or just enter) to continue and then wait for the update
    process to complete.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`pacman -Su`（无需再次更新目录），继续更新过程，并在提示时按回车。这时，许多更多的包将会被更新。按 y（或直接按回车）继续，然后等待更新过程完成。
- en: 'Before we continue installing additional packages, let’s take a look at the
    filesystem by running the `mount` command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续安装其他包之前，先通过运行`mount`命令来查看文件系统：
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You’ll notice that the Msys2 base installation directory, *C:\msys64*, is mounted
    at */* and that *C:\msys64\usr\bin* is mounted at */bin*. As with the other systems,
    Windows drives are mounted as their drive letter. Msys2 mounts them off the root
    like MinGW. (Cygwin can be configured to do the same.) Like Cygwin, Msys2 doesn’t
    mount optical drives without media, so you don’t see my *D:* drive mounted here
    as */d*, but if I inserted a virtual disc and then executed `mount`, it would
    show up in the list.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Msys2的基础安装目录*C:\msys64*已挂载在*/*下，而*C:\msys64\usr\bin*已挂载在*/bin*下。与其他系统一样，Windows驱动器会以它们的驱动器字母挂载。Msys2像MinGW一样从根目录挂载它们。（Cygwin也可以配置成这样。）与Cygwin类似，Msys2不会挂载没有媒体的光驱，所以你不会看到我的*D:*驱动器挂载在这里作为*/d*，但是如果我插入一个虚拟光盘并执行`mount`命令，它会出现在列表中。
- en: '*Installing Tools*'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安装工具*'
- en: At this point, Msys2 is completely up-to-date and ready for you to add tools.
    But what tools should we add? I’d venture to guess this is the point where most
    uncommitted Msys2 explorers bail out. There is fairly complete documentation on
    the Msys2 wiki site, but you really need to read at least the introductory material
    in order to understand Msys2 the way you should.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，Msys2已经完全更新，并且准备好让你添加工具了。那么我们应该添加什么工具呢？我敢猜测，大多数没有明确目的的Msys2探索者在此时就会放弃。Msys2
    Wiki网站上有相当完整的文档，但你确实需要至少阅读引导材料，才能正确理解Msys2。
- en: While Cygwin and MinGW make it pretty obvious which path you should take at
    each turn, Msys2 simply offers options. You can build POSIX-only software for
    the Msys2 environment, or you can build native 32- or 64-bit Windows applications.
    Msys2 doesn’t attempt to persuade you to go one way or the other by preinstalling
    software for a particular goal.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Cygwin和MinGW在每个步骤上都明确告诉你应该走哪条路，但Msys2只是提供了选择。你可以为Msys2环境构建仅限POSIX的软件，或者为32位或64位Windows应用程序构建原生应用程序。Msys2不会通过预安装某个特定目标的软件来劝说你走某一条路。
- en: 'Msys2 provides three different terminal window shortcuts, each configured (using
    different command line options) to build software for one of the three targets
    Msys2 supports: Msys2 native applications, 32-bit Windows applications, or 64-bit
    Windows applications. This is not really any different from cross-compiling; it
    just targets a specific tool chain with a custom environment instead of using
    options on the `configure` command line.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2提供了三种不同的终端窗口快捷方式，每种快捷方式都配置了不同的命令行选项，以便为Msys2支持的三个目标之一构建软件：Msys2原生应用程序、32位Windows应用程序或64位Windows应用程序。这与交叉编译并没有本质区别；它只是针对特定的工具链，使用定制环境，而不是在`configure`命令行中使用选项。
- en: 'Obviously, our goal here is not to build Msys2 software. Rather, we want to
    build Windows software, and Msys2 fully supports this goal. To find out what needs
    to be installed to meet our goals, read the Msys2 wiki page titled “Creating Packages.”^([20](footnote.xhtml#ch17fn20))
    According to this page, the following are the important Pacman groups:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的目标并不是构建Msys2软件。相反，我们的目标是构建Windows软件，而Msys2完全支持这个目标。要了解实现目标需要安装哪些内容，可以阅读Msys2
    Wiki页面上名为“创建包”的文章。^([20](footnote.xhtml#ch17fn20))根据该页面，以下是重要的Pacman组：
- en: '**base-devel**   Required by all targets'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**base-devel**   所有目标所必需'
- en: '**msys2-devel**   For building Msys2 native POSIX packages'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**msys2-devel**   用于构建Msys2原生POSIX包'
- en: '**mingw-w64-i686-toolchain**   For building native 32-bit Windows software'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**mingw-w64-i686-toolchain**   用于构建原生32位Windows软件'
- en: '**mingw-w64-x86_64-toolchain**   For building native 64-bit Windows software'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**mingw-w64-x86_64-toolchain**   用于构建原生64位Windows软件'
- en: For our purposes, the first and last of these packages will suffice. It’s not
    necessarily obvious, but you don’t get `gcc` and the *binutils* package unless
    you install the *msys2-devel* meta package. Like Cygwin, Msys2 sees its own platform,
    which generates applications that fully depend on *msys2.0.dll*, as owning the
    native Msys2 tool chain.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，这些包中的第一个和最后一个就足够了。虽然这并不完全显而易见，但除非你安装了*msys2-devel*元包，否则你不会获得`gcc`和*binutils*包。像Cygwin一样，Msys2把它自己的平台视为拥有原生的Msys2工具链，生成的应用程序完全依赖于*msys2.0.dll*。
- en: 'There is no GUI package installer in Msys2, so let’s begin by exploring a few
    Pacman commands. Like most package management systems, the packages available
    to Pacman are grouped into logical sets. The `-Sg` option shows you a list of
    package groups:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2没有GUI包安装器，所以让我们从探索一些Pacman命令开始。像大多数包管理系统一样，Pacman提供的包被分组为逻辑集合。`-Sg`选项可以显示包组列表：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To find out what packages are in a group, just add the group name to the end
    of the previous command line:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看某个组包含哪些包，只需将组名添加到上一行命令的末尾：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you use `pacman -S` to install a package and give it a group name, it
    shows you a list of group members and asks which of these members to install.
    If you simply press enter, it installs all of them. The `--needed` option ensures
    that only packages that are not already installed are downloaded. Without it,
    you’ll download and install packages in your target groups that are already installed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`pacman -S`安装一个包并给它一个组名时，它会显示组成员列表并询问你要安装哪些成员。如果你直接按回车，它会安装所有成员。`--needed`选项确保只下载尚未安装的包。如果没有这个选项，你将下载并安装目标组中已经安装的包：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Press y to download and then install the packages you requested. This could
    take a while, so I guess it’s time for another snack.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按y以下载并安装你请求的包。这可能需要一些时间，所以我想现在是时候来点小吃了。
- en: '*Testing the Build*'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试构建*'
- en: Once these packages have been installed, your Msys2 environment is ready to
    use. Let’s change into the *b64* directory again, clean up, and create another
    build directory for Msys2 build testing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些包安装完成，你的Msys2环境就可以使用了。让我们再次切换到*b64*目录，进行清理，然后为Msys2构建测试创建另一个构建目录。
- en: If you’ve been working through this chapter and just came out of testing MinGW,
    your `bootstrap.sh` and *configure.ac* files have probably been modified. These
    changes will work fine in this environment. However, if you do decide to revert,
    only revert the *configure.ac* changes. The `bootstrap.sh` file should remain
    as is with the relative-path reference to `gnulib-tool`. If you skipped the section
    on MinGW, you’ll need to modify `bootstrap.sh` by adding a relative path to the
    Gnulib repository work area to the execution of `gnulib-tool`. Msys2 has the same
    problem as MinGW in that it creates copies of the target, rather than working
    symlinks, so creating a symlink in */usr/bin* for `gnulib-tool` will not work
    here:^([21](footnote.xhtml#ch17fn21))
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本章中进行操作并刚刚完成MinGW测试，你的`bootstrap.sh`和*configure.ac*文件可能已经被修改。这些更改在当前环境下是可以正常工作的。不过，如果你决定还原，只需还原*configure.ac*的更改。`bootstrap.sh`文件应保持不变，继续使用相对路径引用`gnulib-tool`。如果你跳过了MinGW部分，你需要通过为`gnulib-tool`的执行添加Gnulib仓库工作区的相对路径来修改`bootstrap.sh`。Msys2和MinGW一样，存在创建目标的副本而非工作符号链接的问题，因此在*/usr/bin*中创建`gnulib-tool`的符号链接在这里不起作用：^([21](footnote.xhtml#ch17fn21))
- en: '[PRE37]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Before we can build b64, we need to change terminals. You may have noticed that
    Msys2 configured three shortcuts in the **MSYS2 64bit** folder it created in the
    Windows Start Menu. Up to this point, we’ve been using the **MSYS2 MSYS** shortcut
    to start an Msys2 terminal. This was fine as long as we were just installing packages
    or if we were going to target the Msys2 platform.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以构建b64之前，我们需要更换终端。你可能已经注意到，Msys2在它创建的Windows开始菜单中的**MSYS2 64bit**文件夹里配置了三个快捷方式。到目前为止，我们一直使用**MSYS2
    MSYS**快捷方式来启动Msys2终端。只要我们只是安装包或者要面向Msys2平台，这个方法是没问题的。
- en: 'We’re building 64-bit native Windows software, so open a MinGW 64-bit terminal
    now. Then, from within that terminal window, change into the *b64/ms2-builds/mw64*
    directory and build b64:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建64位原生Windows软件，所以现在请打开一个MinGW 64位终端。然后，在该终端窗口中，切换到*b64/ms2-builds/mw64*目录并构建b64：
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The difference between these terminal windows is defined by the values of various
    environment variables starting with `MSYS`. These variables are used to configure
    the site configuration file referenced in the first line of `configure`’s output.
    See the Msys2 wiki for lots of details on how to configure environments this way.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这些终端窗口之间的差异由以`MSYS`开头的各种环境变量的值定义。这些变量用于配置`configure`输出的第一行中引用的站点配置文件。有关如何以这种方式配置环境的详细信息，请参见Msys2维基。
- en: Running the `b64.exe` program through `DependenciesGUI.exe`, we can see that
    it’s a true native 64-bit Windows program, dependent only on Windows system and
    Visual Studio runtime libraries.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`b64.exe`程序与`DependenciesGUI.exe`一起运行，我们可以看到它是一个真正的原生64位Windows程序，仅依赖于Windows系统和Visual
    Studio运行时库。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: After the whirlwind tour we just took, you should now have no trouble building
    Windows software using GNU tools. Personally, I find the Cygwin and Msys2 environments
    to be the most useful for many purposes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 经过刚才的快速巡览，你现在应该能毫不费力地使用GNU工具构建Windows软件了。就个人而言，我发现Cygwin和Msys2环境对于许多用途来说是最有用的。
- en: Msys2 is a bit more modern and fresh, but they both serve as good general-purpose
    platforms for the GNU tools. Msys2 also has the distinct advantage of building
    pure Windows software wherever possible, while Cygwin (unless using the mingw-w64
    cross tools) builds apps that, although they do run on Windows, rely heavily on
    the Cygwin system library. That’s not necessarily a showstopper for me. If there
    are other factors and Cygwin comes out on top, then I don’t mind the extra library,
    but the purist in me leans toward a desire for no unnecessary third-party libraries.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Msys2稍微现代一些，看起来更清新，但它们都可以作为GNU工具的良好通用平台。Msys2还具有一个独特的优势，即在可能的情况下构建纯Windows软件，而Cygwin（除非使用mingw-w64交叉工具）构建的应用程序虽然可以在Windows上运行，但依赖于Cygwin系统库。这对我来说不一定是一个障碍。如果还有其他因素并且Cygwin最终占据上风，那么我不介意额外的库，但内心的纯粹主义者倾向于希望没有不必要的第三方库。
- en: Cygwin has the advantage of maturity. It’s not so far behind Msys2 that it’s
    unusable, but it’s been around long enough that it has some nice features, like
    integrating a working symbolic link mechanism into all of its utilities so it
    can properly emulate POSIX symlinks. It also has many more packages available
    for installation within the environment.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin的优势在于成熟度。它并不落后于Msys2到无法使用的程度，但它已经存在足够长的时间，拥有一些不错的功能，比如将一个有效的符号链接机制集成到其所有工具中，从而能够正确地模拟POSIX符号链接。它还提供了更多可供安装的包。
- en: MinGW is a bit out-of-date, and it really needs to support 64-bit Windows builds,
    but it’s clean and small. With its new package manager, it stacks up pretty well
    against the other two. All it really needs to move into the big leagues is to
    embrace the newer 64-bit code generator in the *mingw-w64* package. It might also
    be nice to upgrade to mintty from the conhost-based console it uses.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW稍微有些过时，确实需要支持64位Windows构建，但它简洁且小巧。凭借其新的包管理器，它与其他两个相比表现得相当不错。它真正需要进入主流的，只是拥抱*mingw-w64*包中的更新的64位代码生成器。将其从基于conhost的控制台升级为mintty也许会是个不错的选择。
