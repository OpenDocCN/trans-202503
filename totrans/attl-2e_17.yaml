- en: '17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING THE AUTOTOOLS WITH WINDOWS
  prefs: []
  type: TYPE_NORMAL
- en: '*“Well, Steve, I think there’s more than one way of looking at it. I think
    it’s more like we both had this rich neighbor named Xerox and I broke into his
    house to steal the TV set and found out that you had already stolen it.”'
  prefs: []
  type: TYPE_NORMAL
- en: —Bill Gates, quoted in* Steve Jobs *by Walter Isaacson*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Autoconf generates configure scripts containing hundreds of lines of Bourne
    shell code. If that statement doesn’t make you wonder how we could ever use the
    Autotools with Windows, you should probably re-read it until it does. In fact,
    the only way Autoconf *can* be used is with an actual Bourne shell and a subset
    of Unix tools like `grep`, `awk`, and `sed`. So before we can even get started,
    we need to ensure that we have a proper execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: When I started working on the first edition of this book, there were few options
    that provided the required environment for building Windows software with the
    Autotools. During the last 10 years, that story has changed. Today, an entire
    gamut of options is available to developers, depending on whether your goal is
    to build Windows applications on Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the last decade, Windows has been viewed by the GNU community as a more important
    target than it has in the past. Significant efforts have been made recently to
    ensure that GNU source code at least considers Windows as a target environment.
    This attitude shift has provided important source-level support for making Cygwin
    and its sibling environments manage clean ports of GNU packages to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Environment Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since our goal is to build native Windows software using GNU tools, including
    specifically the Autotools, we’re naturally going to have to consider systems
    that provide various levels of POSIX environment functionality.
  prefs: []
  type: TYPE_NORMAL
- en: At one end of the spectrum, we have actual Linux installations, which may take
    any one of several forms, including bare-metal dedicated machine installations
    and virtual machines running on KVM, Xen, or VMware ESX servers or on a Windows
    machine running Microsoft HyperV, VMware Workstation, or Oracle’s VirtualBox.
    There are also Mac options for running virtual machines, and macOS itself provides
    a reasonably POSIX-compliant environment. We could also use Windows Subsystem
    for Linux (WSL).
  prefs: []
  type: TYPE_NORMAL
- en: A full Linux installation obviously provides the most POSIX-compliant environment
    for building software using GNU tools. To actually generate Windows software on
    a Linux system, we have to configure a cross-compile. That is, we have to build
    software that’s not designed to run on the build system.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of that spectrum, we have various POSIX environment emulators
    running within Windows applications. The “application” in these cases is almost
    always a Bash shell running in some sort of shell host process or terminal, but
    these environments are more or less compatible with a true Linux build environment.
    The flavors we have to pick from today include Cygwin, MinGW, and MSys2.
  prefs: []
  type: TYPE_NORMAL
- en: A final option—and one we won’t spend much time on—is that of cross-compiling
    Windows software on other types of systems, including mainframes and supercomputers.
    If you want to see a Windows program compile fast, you should watch it happen
    on a Cray XC50 with an SSD or RAM disk. Since GNU software can run on pretty much
    any Unix system that has a Bourne shell, we can cross-compile software on it for
    any platform, including Windows. After you’ve cross-compiled on Linux, moving
    the process to a different POSIX-compliant platform is relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: Tool Chain Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we’ve chosen an environment, we’ll then need to select a tool chain in
    which to build our native software for Windows. Generally speaking, the environment
    you choose limits your tool chain options. For example, if you select a full Linux
    installation, your only tool chain option is to install a cross-compiler for Windows—probably
    *mingw-w64*. Don’t knock it until you’ve tried it—this is a really good option
    because it does a pretty reasonable job of building Windows software.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem you’ll find here is the inconvenience of having to copy
    your software over to a Windows system in order to test it. In fact, running tests
    as part of your build is pretty much a nonstarter, as you can’t execute your products
    on your build machine.^([1](footnote.xhtml#ch17fn1)) I’ve seen such cross-compilation
    testing done by having a remote copy and execution stage as part of the build
    system’s test phase, but doing this tends to make your build brittle because it
    requires additional environment configuration that’s not part of a normal package
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll present a full cross-section of options for building Windows software using
    GNU tools. We’ll start by using a Windows cross-compiler tool chain on native
    Linux and then check out Windows Subsystem for Linux, and finally move on to the
    remaining Windows-based options, presented in the order they were created. We’ll
    first check out Cygwin on a Windows 10 system. Next, we’ll try MinGW and finally
    finish up with MSys2\. By the time you reach the end of this chapter, you should
    be very comfortable with these processes.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows-based systems, I’ll presume you’re running a reasonably recent copy
    of Windows 10\. I installed *Windows 10 Build 1803* (released April 30, 2018)
    in a virtual machine under Oracle’s VirtualBox on my Linux Mint system. You can
    take this path, or you can use a “bare metal” (nonvirtual) installation of Windows
    10\. The manner in which you choose to run Windows and, to a lesser extent, the
    exact version you choose to run are really not significant issues here.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The majority of this book centers on the use of free and open source software
    (FOSS). Microsoft Windows is, of course, not free software. You should pay for
    any copy of Windows—or any other non-free software—you choose to use.^([2](footnote.xhtml#ch17fn2))*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also installed Git for Windows^([3](footnote.xhtml#ch17fn3)) on my Windows
    system and cloned the b64 project from [Chapter 13](ch13.xhtml) and Gnulib from
    the Savannah Git server. We won’t be making any significant changes to the b64
    project source code, except to make it work in a given environment where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: When you install Git for Windows, you’ll have the option of downloading a 32-
    or 64-bit version in one of two varieties—as an installer or as a portable package.
    The installer style installs Git on your Windows system in the usual fashion and
    may be uninstalled from the Windows installed-programs panel. The portable style
    requires no installation and can be executed directly from its expanded archive.
    Select an installer or a portable package option for your Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: If you chose to use an installer, during the installation process you’ll be
    asked how you want Git to treat your source file line endings. I generally avoid
    the first option, which is to “check out” using Windows-style line endings but
    “commit” using Unix-style line endings. You might want to use this option if you’re
    planning to use Notepad as your editor (not advisable). I generally select the
    option to check out and commit as is. Git has no business modifying your source
    files as they pass through it. Just configure your editor to recognize and manage
    line endings the way you like.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Compiling for Windows on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we’re already running Linux, let’s start our investigation of the options
    right here at home.
  prefs: []
  type: TYPE_NORMAL
- en: '*Installing a Windows Cross Tool Chain*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first thing we’ll need to do is install a Windows cross-compiler tool chain
    (often referred to simply as a “cross tool chain” or as “cross tools”) on our
    Linux system. The most widely available one is mingw-w64 for Linux, which can
    build native Windows programs and libraries that look very much like they were
    generated by Microsoft tools.
  prefs: []
  type: TYPE_NORMAL
- en: On my Linux Mint system, I searched the internet for *Linux Mint mingw-w64*;
    the top result was my goal. You can generally use your system’s package manager
    to find and install this package because mingw-w64 is pretty popular. On CentOS
    and other Red Hat–based systems, try `yum search mingw-w64`. For Debian-based
    systems like Ubuntu and Mint, try `apt-cache search mingw-w64`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware when you run these package searches that you may get back a long result
    list composed of a few dozen real packages and one or two meta packages. It’s
    better to select one of the meta packages so you get all of the required real
    packages in one shot. I highly recommend you search the internet for your distro
    name and *mingw-w64* in order to get some background on which package you should
    install using your package manager. A little research up front can save you a
    lot of headache later.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on my Debian-based system, I got these results from an `apt-cache`
    search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual results list contained dozens of entries, but according to a quick
    internet search, I found the only package I really needed to install was *mingw-w64*
    (highlighted); a meta-package referencing actual packages that install the GCC
    C and C++ compilers for generating 32- and 64-bit Windows software; and a *binutils*
    package containing the librarian, linker, and other common development tools.
    Some package management systems divide this set of packages differently, allowing
    you the option of installing `gcc` and `g++` separately or of installing 32-bit
    and 64-bit code generators separately. Installing this package on my system displays
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Testing the Build*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve found and installed the proper cross tool chain, you’re ready to
    start building Windows software. I’ve chosen something simple, but not trivial—the
    b64 project from [Chapter 13](ch13.xhtml). It uses Gnulib, so it has a convenience
    library. Gnulib aims for portability, so we can assess how good it is with Windows
    portability, at least for the few modules b64 uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build for another platform, you need to configure the project for cross-compilation.
    For a full explanation of cross-compiling using the Autotools, see Item 6 in [Chapter
    18](ch18.xhtml). For now, just be aware that the configuration options you’ll
    need are `--build` and `--host`. The first option describes the system on which
    you’ll be building the software, and the second option describes the system on
    which the generated software will be executed. In order to discover our build
    platform, we can run the `config.guess` script installed into the root of our
    project by `automake` (via `autoreconf`). To do this, we’ll need to bootstrap
    the project for a regular build so that `config.guess` gets installed.^([4](footnote.xhtml#ch17fn4))
    Let’s do that within the *b64* directory itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running `config.guess` is how `configure` determines the default value to use
    for the `--build` option, so it will always be correct. Determining the value
    we should use for the `--host` option is just a bit more difficult. We need to
    find the prefix on our cross tool chain, because the `--host` option value is
    what `configure` uses to find the correct tool chain and to set up our `CC` and
    `LD` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done in a few different ways. You can use your system’s package
    manager to determine what files were installed when you installed the mingw-w64
    meta package, or you can look in your */usr/bin* directory to see what the compiler
    is named—this usually works, and actually *does* work for this tool chain, but
    sometimes cross tool chains are installed into a completely different directory,
    so I’ll use my package manager. Your package manager has similar options, but
    you can follow along directly with my usage if you happen to be on a Debian-based
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first command lists all of the installed packages on my system and filters
    the list through `grep`, searching for anything associated with *mingw*. The equivalent
    `rpm` command on Red Hat–based systems would be `rpm -qa | grep mingw`. The package
    I’m looking for will be related to the GCC C compiler and `x86_64` development.
    It will likely look very similar, if not exactly the same, on your system.
  prefs: []
  type: TYPE_NORMAL
- en: The second command lists the files installed by that package. Here, I’m looking
    for the compiler, standard C library, headers, and other target-specific files.
    The equivalent `rpm` command would be `rpm -ql mingw64-gcc`.^([5](footnote.xhtml#ch17fn5))
    The tag I’m searching for is `x86_64-w64-mingw32`. It should look similar in structure
    (but not content) to the value printed previously by our execution of `./config.guess`.
    This is the value that should be used with the `--host` option on the `configure`
    command line. It’s used by `configure` as a prefix for `gcc`, and a careful examination
    of your package manager output will show that there was indeed a program called
    `x86_64-w64-mingw32-gcc` installed into your */**usr/bin* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s use the information we’ve gathered to build b64 for Windows. From
    within the *b64* directory, create a subdirectory called *w64* (or whatever you
    like) and change into it; this will be the build directory we’ll use to build
    a 64-bit Windows version of b64\. Run `../configure` with options to target Windows,
    as follows (assuming we’re still in the *b64* directory):^([6](footnote.xhtml#ch17fn6))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve highlighted some of the important output lines from `configure` when cross-compiling.
    If you make a mistake entering the `--host` value on the command line, you’ll
    see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The warning is telling you that it could not find a `strip` program called `x86_64-w64-oops-strip`
    (not surprising). Most cross tool chains come with a properly prefixed version
    of `strip` because this is one of the tools in the *binutils* package, so this
    is a reasonable test. If `configure` can’t find a prefixed version of the tools,
    it falls back to using the base names of the tools, which may be perfectly fine
    if your cross tools are named by their base names but simply stored in a different
    directory (which you’ve presumably added to your `PATH`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve configured the build for cross-compilation, everything else
    works exactly the same as a regular Linux build. Try running `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I’ve highlighted the lines that indicate we’re using the *mingw-w64* cross tool
    chain to build b64\. A listing of the *src* directory shows our Windows executable,
    `b64.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be complete, let’s copy this program over to a Windows system and give it
    a try. As mentioned previously, I have Windows 10 installed in a virtual machine
    on my Linux system so I can simply run it in place from a Windows-mapped drive
    (`Z:`, in my case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t be concerned about the *`set /p`* command—it’s just a tricky way of
    echoing text to the Windows console without a trailing newline, since *`cmd.exe`*’s
    *`echo`* statement has no option to suppress the trailing newline.*'
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to try to tell you that you’ll never experience problems building
    Windows software this way. You will, but they’ll be porting issues related primarily
    to a few POSIX system calls made directly by your project’s source code. I will,
    however, say that whatever problems you do run into will be a proper subset of
    those you’d experience if you tried to use Microsoft tools to build this package.
    In addition to any source-code-porting issues you might find (they’ll still be
    there, even with Microsoft tools), you’d also have to work the kinks out of hand-configured
    Visual Studio solution and project files or Microsoft `nmake` files. For some
    projects, it’s worth the extra effort to be able to access the additional fine-grained
    tuning available when using Microsoft tools. For others, such tuning is not that
    important; building these projects for Windows on a Linux system works very well.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Subsystem for Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we leave the Linux world behind, let’s examine the Windows Subsystem
    for Linux (WSL) as an option for building Windows software using GNU tools.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain a flavor of Linux for WSL by downloading the version you want
    to use from the Windows Store. Before doing this, however, you must enable the
    optional Windows Subsystem for Linux feature. You can do this either from the
    **Windows Features** panel (type **windows features** into the Cortana search
    bar and select the top result) or from a PowerShell command prompt opened as *Administrator*.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Windows Features** panel, scroll down until you find the entry for
    **Windows Subsystem for Linux**, check the associated checkbox, and click **OK**.
    Alternatively, from a PowerShell prompt (as *Administrator*), enter the following
    command and follow the prompts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Windows Subsystem for Linux will require a system restart.
  prefs: []
  type: TYPE_NORMAL
- en: Now open the Windows Store and search for “Windows Subsystem for Linux,” select
    the “Run Linux on Windows” search result, and select the Linux flavor you want
    to install. On my system, installing the Ubuntu 18.04 flavor downloaded about
    215MB and installed an “Ubuntu 18.04” icon in my Start menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon first execution, the terminal window displayed text indicating that the
    system was being installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `mount` command to see how Microsoft integrates the Windows and Linux
    filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The key item of interest (highlighted) here is the fact that your Windows *C:*
    drive is mounted under */mnt/c* on this Linux installation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of the coin, the Linux root filesystem is installed into your
    Windows filesystem in the hidden user-specific *AppData* directory. For example,
    I found my Ubuntu 18.04 installation’s root filesystem at *C:\Users\*your-username*\AppData\Local\Packages\CanonicalGroupLimited
    .UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs*.^([7](footnote.xhtml#ch17fn7))
  prefs: []
  type: TYPE_NORMAL
- en: 'If you selected a Debian-based distribution, start by updating your system
    software repository cache with `sudo apt-get update`. Then you can install development
    tools like GCC and the Autotools in the usual manner for the distro you selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you’re at all familiar with Ubuntu and `apt`, you’ll see there’s no significant
    difference between the output of the preceding command on WSL Ubuntu 18.04 and
    a native installation of Ubuntu 18.04\. That’s because you’re really running Ubuntu
    18.04 on Windows here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with a regular installation of Ubuntu 18.04, if you create a *bin* directory
    in your home directory and then open a new Ubuntu 18.04 terminal window, you’ll
    find your personal *bin* directory at the beginning of your `PATH`. Do this now
    so you can create a symlink, *~/bin/gnulib-tools*, that refers to the `gnulib-tool`
    in your Windows clone of Gnulib, as we did when we built b64 on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Change into the */mnt/c/Users/.../b64* directory and run `./bootstrap.sh`,
    followed by ./`configure && make` to build b64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! Except that this is a Linux program, not a Windows program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to run this program from a Windows command prompt will result in
    the Windows equivalent of a blank stare. You see, what you really have here with
    WSL is an inexpensive form of virtual machine guest with some built-in filesystem
    integration. That’s not to say it’s not useful. It’s very handy to have Linux
    closely integrated with Windows for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: So what can we do? Our only option is to do the same thing we did on our native
    Linux installation earlier—install mingw-w64 and cross-compile. The process is
    identical, so I won’t reiterate the details. Refer to that discussion in “Cross-Compiling
    for Windows on Linux” on [page 454](ch17.xhtml#page_454) for instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Cygwin project was established in 1995 by Cygnus Solutions as an effort
    to create tool chains using GNU software for the various embedded environments
    for which the company was hired to provide development tools.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin’s general philosophy is that GNU packages should be able to be compiled
    for Windows without any modifications to the source code at all. Time is money
    to a support company, and any time not spent modifying source code is money in
    the bank. They wanted their engineers to *use* GNU tools in these environments,
    not spend their time porting them.
  prefs: []
  type: TYPE_NORMAL
- en: So how do they do this? Well, most GNU packages are written in C and use the
    C standard library for accessing most of the system functionality they require.
    The C standard library—being standardized—is portable by definition. Additionally,
    GNU projects strive for portability—at least among Unix flavors. Nevertheless,
    there is a subset of POSIX system functionality of which many GNU packages avail
    themselves, including POSIX threads (pthreads) and system calls like `fork`, `exec`,
    and `mmap`. While recent C and C++ standards now include a threading API, those
    other system calls are very specific to Unix and Linux. In fact, they have no
    direct counterparts on Windows that align well enough to use without some adapter
    code between the caller and the Windows API.
  prefs: []
  type: TYPE_NORMAL
- en: For a simple example, when you get right down to the bare metal, the two kernels
    work fundamentally differently with respect to how processes are created. Windows
    uses the Win32 `CreateProcess` function to create a new process and load a program
    into it in a single step. Unix, on the other hand, uses the `fork` and `exec`
    system calls to respectively clone an existing process and replace the contents
    of the clone with another program.
  prefs: []
  type: TYPE_NORMAL
- en: It’s actually fairly easy to replace the `fork`-`exec` pair with a call to `CreateProcess`.
    The true difficulties arise when `fork` is used independently of `exec`, and this
    does happen occasionally.^([8](footnote.xhtml#ch17fn8)) There is simply no way
    to make `CreateProcess` do only half its job.^([9](footnote.xhtml#ch17fn9)) Many
    GNU programs don’t use `fork` without `exec`, but some important ones do. Mapping
    these calls to the Windows API is difficult at best, and it’s often impossible
    without significant structural changes to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Cygnus therefore elected to create a shim library of POSIX system call functionality.
    This library is called *cygwin1.dll*, and programs built using Cygwin are linked
    to this library and therefore depend on it at runtime. More to the point, every
    standard library call and most system calls pass though *cygwin1.dll* so that
    porting to a new platform without existing tools is an easy process.
  prefs: []
  type: TYPE_NORMAL
- en: You can detect if a Windows program was built for the Cygwin platform by simply
    looking for *cygwin1.dll* in its dependency list.^([10](footnote.xhtml#ch17fn10))
    But the Cygwin platform is not the only target that Cygwin supports. The mingw-w64
    tool chains have been ported to Cygwin and may be used as cross-compilers in Cygwin
    to build native Windows software, just as we did on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In 1999, Red Hat purchased Cygnus Solutions, and Cygwin has been maintained
    by various Red Hat employees and outside volunteers since then. Because of this
    maturity, Cygwin’s package repository is very large, and its Windows POSIX environment
    is one of the most complete implementations available. Cygwin is one of the most-used
    systems for porting GNU and other software to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '*Installing Cygwin*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To install Cygwin, download the installer from Cygwin’s website at *[https://www.cygwin.com](https://www.cygwin.com)*.
    The installer is called `setup-x86_64.exe`. Cygwin’s installer does not use the
    Windows installation database; you can remove Cygwin merely by deleting its installation
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: A unique and useful aspect of the Cygwin installer is that it caches its downloaded
    packages at a location of your choice on your filesystem. This cache can then
    be used as a standalone installation source for later installations.
  prefs: []
  type: TYPE_NORMAL
- en: Running the installer presents a setup wizard, the opening page of which is
    shown in [Figure 17-1](ch17.xhtml#ch17fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-1: The initial copyright screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to move to the second page of the setup wizard, shown in [Figure
    17-2](ch17.xhtml#ch17fig2).
  prefs: []
  type: TYPE_NORMAL
- en: You’re asked here to select how you want to obtain packages. Your options include
    the internet or a local installation directory. You may also elect to download
    files from the internet but not install them, which is useful for building a local
    installation source for installing multiple systems from the same cache of downloaded
    files. Select **Install from Internet** and click **Next** to continue to the
    next page, shown in [Figure 17-3](ch17.xhtml#ch17fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-2: The installation type screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-3: The installation location screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’re asked where you want to install Cygwin. The default location is
    *C:\cygwin64*, and it’s recommended that you just stick with this default location,
    though Cygwin does a better job than some of the other installers of managing
    the required system changes if you do choose to install in a nondefault location.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a Windows power user, you’re very likely feeling that gut-wrenching
    desire right now to change the default location to something more reasonable on
    Windows. I admonish you not to do this. The problem is that you’re trying to view
    Cygwin as an application and, while it technically is one, it can also be viewed
    as being somewhat akin to a full Linux virtual machine installation. It provides
    a foreign (to Windows) development environment, which puts it squarely in the
    camp of a sibling operating system to Windows. From this perspective, it’s perhaps
    a bit easier to understand why the *Cygwin64* directory deserves a special place
    next to the *Windows* directory on your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to move to the next page, shown in [Figure 17-4](ch17.xhtml#ch17fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-4: The local package directory screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re now asked to select a local package directory. This is the directory
    where downloaded package files are stored. Choose a reasonable location on your
    Windows system—such as your *Downloads* directory. A *cygwin* directory will be
    created at this location and will contain a subdirectory for each internet source
    from which you download packages. Click **Next** to move to the next screen, shown
    in [Figure 17-5](ch17.xhtml#ch17fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-5: The proxy settings screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: You may now select or modify your proxy settings. Usually, you can just use
    the default system proxy settings. Those who use a proxy in their work or home
    environments will be used to configuring this for internet applications and will
    know what to do with the options here. Click **Next** to move to the next screen,
    shown in [Figure 17-6](ch17.xhtml#ch17fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-6: The package download source screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: Select a package download source. As with a Linux distribution, there are multiple
    sites you can use as a package source for Cygwin. Select one that’s geographically
    close to you for the fastest installation and then click **Next** to begin downloading
    the package catalog, shown in [Figure 17-7](ch17.xhtml#ch17fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-7: The package catalog download screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and parsing the package catalog from the selected source site takes
    only a few seconds, and then the package manager main screen is displayed, as
    shown in [Figure 17-8](ch17.xhtml#ch17fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-8: The package manager screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve expanded the All root element and the Devel category to show you the first
    few packages in this category, sorted alphabetically. Select the following additional
    packages in the Devel category by clicking the down arrow on the right end of
    the New column and choosing the highest version number available in the list for
    each package (with a few exceptions):'
  prefs: []
  type: TYPE_NORMAL
- en: autoconf2.5 (2.69-3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: automake (10-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: automake1.15 (1.15.1-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: binutils (2.29-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc-core (7.4.0-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc-g++ (7.4.0-1 - optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: libtool (2.4.6-6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make (4.2.1-2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As you scroll though the list of packages, you’ll note that some have been
    preselected for you. Do not deselect any of the default packages.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in this list has a base package name followed by a package version
    in parentheses. The versioning system is similar to that of a standard Linux distribution.
    The upstream source package version is suffixed with a dash, followed by a packager’s
    version. For example, the *autoconf2.5* package has a source package version of
    2.69 and a packager’s version of 3\. The packager’s version is specific to the
    distribution—in this case, Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin uses a rolling release mechanism, meaning that Cygwin packages are updated
    somewhat independently as newer source package versions become available and as
    the Cygwin maintainers consume them. The versions I’ve listed here were current
    at the time of this writing. Your most recent version numbers may be newer. Select
    the most recent rather than the ones I’ve listed. Feel free to use the search
    box at the top of the dialog to quickly find the packages in the list. Once you’ve
    selected these additional packages, click **Next** to continue to the next page,
    shown in [Figure 17-9](ch17.xhtml#ch17fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-9: The download confirmation screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing the list here to ensure you’ve selected the desired set, click
    **Next** to start the download process, shown in [Figure 17-10](ch17.xhtml#ch17fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-10: The package download progress screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: Since you elected to install only a few packages, this should not take long.
    Once the process completes, click **Next** to continue to the next screen, shown
    in [Figure 17-11](ch17.xhtml#ch17fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-11: The icon selection screen of the Cygwin64 setup program*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select where you’d like icons to be created on your Windows system. You have
    two checkbox options here: Desktop and Start Menu. If you elect not to add any
    icons, you can still run the Cygwin terminal program by executing *C:\cygwin64\cygwin.bat*
    from an Explorer window or from a command or PowerShell prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish** to close the package manager. When you want to modify your
    Cygwin environment by adding or removing packages, or updating your existing packages
    to newer versions, just run `setup-x86_64.exe` again.^([11](footnote.xhtml#ch17fn11))
    You’ll need to go through all the same initial screens, but the package manager
    will remember your previous options and all the packages you currently have installed,
    allowing you to modify the existing configuration as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: '*Opening the Cygwin Terminal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first execution of the Cygwin terminal indicates that skeleton *.bashrc*,
    *.bash_profile*, *.inputrc*, and *.profile* files are copied into your */home/*username
    directory within the Cygwin filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand the Cygwin filesystem is to execute the `mount`
    command within the terminal to display how Cygwin maps your Windows filesystem
    resources into its own filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Cygwin auto-mounts *C:\cygwin64*, *C:\cygwin64\bin*, and *C:\cygwin64\lib* to
    */*, */usr/bin*, and */usr/lib*, respectively. It also auto-mounts all of your
    Windows drive roots to directories named by the drive letter under the */cygdrive*
    directory. I have my Windows operating system installed on the *C:\* drive, and
    I have the *Z:\* drive mapped to my Linux host though VirtualBox’s shared folder
    system. Therefore, I have full access to both my Windows filesystem and my Linux
    host filesystem from within Cygwin’s POSIX environment.^([12](footnote.xhtml#ch17fn12))
    I also have access to Cygwin’s entire filesystem from Windows, via the *C:\Cygwin64*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing the Build*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Cygwin provides access to your Windows environment within its own POSIX
    environment, you can simply run a previously installed standalone copy of Git
    for Windows directly from the Cygwin shell prompt. An even better option, but
    one that only works inside of the Cygwin terminal, is to install Cygwin’s version
    of git from its package manager. Why is this option better? Because Cygwin’s git
    package understands Cygwin’s filesystem conventions better than the Windows version
    does. For instance, the Windows version will sometimes create files with the wrong
    permissions when viewed from a POSIX environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike MinGW and Msys2, Cygwin can manage symlinks correctly within the Cygwin
    filesystem. Recall from [Chapter 13](ch13.xhtml), and earlier in this chapter,
    that we need to create a symlink to the `gnulib-tool` utility somewhere in our
    `PATH` so that b64’s `bootstrap.sh` script is able to find Gnulib. Let’s do that
    now in the Cygwin terminal. Fill in the elided section of the following command
    with the proper path to your clone of Gnulib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a symbolic link in Cygwin’s */usr/bin* directory, referring
    to the `gnulib-tool` program in the root of the Gnulib work area you cloned.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Cygwin creates symlinks as text files flagged with the Windows *System*
    (S) attribute, making them invisible to normal Windows directory listing commands
    and within Windows File Explorer. If you examine the contents of a Cygwin symlink
    file, you’ll find it contains a magic cookie, `!<symlink>`, followed by the path
    to the target filesystem entry in UTF-16 format (beginning with the little-endian
    byte order mark, 0xFFFE).
  prefs: []
  type: TYPE_NORMAL
- en: You can configure Cygwin to create true Windows symbolic links by exporting
    a `CYGWIN` environment variable containing the text `winsymlinks:nativestrict`.
    However, if you do this, you must then run your Cygwin terminal as Administrator,
    because creating Windows native symbolic links requires administrative rights
    by default. Recent versions of Windows 10 allow native symlinks to be created
    without elevated privileges if you’re willing to switch your system into so-called
    “developer mode.”
  prefs: []
  type: TYPE_NORMAL
- en: All that said, Cygwin’s own system of managing symlinks works really well, as
    long as the tools interpreting the links are built for the Cygwin platform. In
    fact, to see the contents of a Cygwin symlink file, you have to use a non-Cygwin
    tool because Cygwin tools will simply follow the symlink file, rather than open
    the file, even from a Windows command prompt!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build b64 for Windows. We’ll start by changing directories within
    the Cygwin terminal to the b64 work area you cloned on your Windows system and
    running the `bootstrap.sh` script to pull in our Gnulib dependencies and to run
    `autoreconf -i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can simply run `configure` and `make`. We’ll do this from within
    a subdirectory structure so we can reuse this work area for other build types
    later. Note there’s no need to specify `--build` or `--host` options here to set
    up a cross-compile. We’re running “native” Cygwin tools, which automatically build
    Cygwin programs designed to run on the host platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll test our new `b64.exe` program to see if it works on Windows.
    While the Cygwin terminal may look like Linux, it’s really just a Linux-like way
    of accessing Windows, so you can execute Windows programs from the Cygwin terminal.
    This is nice because it allows us to use the Bash version of `echo` with its `-n`
    option to suppress the default linefeed during our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I did not use the* .exe *extension on the command to reverse the base64 encoding
    operation in this console listing. I wanted to show that, like Windows, Cygwin
    does not require the use of the extension on executable files.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you run a dependency checker like Visual Studio’s `dumpbin.exe` or Cygwin’s
    `cygcheck` utility, you’ll find that this version of `b64.exe` depends heavily
    on *cygwin1.dll*, which must be shipped with your program. By default, Cygwin
    builds “Cygwin” software—software designed to run on the Cygwin platform, and
    an important part of the Cygwin platform is *cygwin1.dll* on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '*Building True Native Windows Software*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may also install the mingw-w64 tool chain and compile using the same techniques
    we used in “Cross-Compiling for Windows on Linux” on [page 454](ch17.xhtml#page_454).
    The mingw-w64 tool chain is available in the Cygwin package manager and is a Cygwin
    port of the same tool chain we installed earlier on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that now. Run the `setup-x86_64.exe` program again and skip through
    all the leading dialogs until you come to the package manager window. After initial
    installation, the default view shown by the package manager window is a list of
    pending updates of packages you’ve already installed. Depending on how long it
    has been since your initial installation, this list may even be empty. Select
    the **Full** option from the **View** drop-down box to return to the complete
    list of packages. Locate and select (under the **Devel** category) the following
    packages for installation. You may see newer version options than I’ve listed
    here; select the latest available to you. You can enter a prefix (**mingw64-**)
    in the **Search** box to narrow down the result list to a subset of packages containing
    those you want.
  prefs: []
  type: TYPE_NORMAL
- en: mingw64-i686-gcc-core (7.4.0-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mingw64-i686-gcc-g++ (7.4.0-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mingw64-x86_64-gcc-core (7.4.0-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mingw64-x86_64-gcc-g++ (7.4.0-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two of these packages are for generating 32-bit Windows software,
    and the last two are for generating 64-bit Windows software. Click **Next** to
    continue and install these additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may notice on the summary screen that other packages you did not explicitly
    select are also getting installed. That’s because these four are meta-packages,
    as described previously. If it has been a while since you initially installed
    Cygwin, you may also see updates for packages you previously installed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create other subdirectories under *b64/cw-builds* for 32- and 64-bit mingw-w64
    builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by building the 32-bit Windows program in the *mingw32* directory
    using the i686 variation of the mingw-w64 cross tool set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Though it may seem odd, you must use the `--build` and `--host` options on the
    `configure` command line here to cross-compile for Windows. The reason is the
    mingw-w64 tool chain is not the default tool chain on Cygwin. All you’re really
    doing is telling `configure` where to find the nondefault tools you want to use.
    From a certain point of view, it actually is a cross-compile because you’re building
    non-Cygwin software on the Cygwin platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same for the 64-bit build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It may seem strange that the 64-bit version of the gcc is called *`x86_64-w64-mingw32-gcc`*.
    What’s with that *`32`* on the end of the cross-tool prefix? The reason is that
    mingw was originally a 32-bit Windows compiler, named specifically mingw32\. The
    mingw32 project was eventually renamed to MinGW, but tools and package names are
    harder to change once they’re in widespread use.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Analyzing the Software*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To really understand the differences between these builds, you’ll need to obtain
    a tool for looking inside the `b64.exe` files we generated using each of these
    three tool sets. You can run the `dumpbin.exe` utility that comes with Visual
    Studio or Cygwin’s `cygcheck` tool, if you like. I found a very nice tool called
    *Dependencies* on GitHub by user lucasg.^([13](footnote.xhtml#ch17fn13))
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the `cygcheck` output for all three versions of the program.
    We’ll start in the *cw-builds* directory to give us easy access to all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The concept being conveyed by the hierarchies here is that a library is a direct
    dependency of the library or program directly above it and an indirect dependency
    of ancestors farther up the chain. The Cygwin version at ➊ shows a dependency
    hierarchy with *cygwin1.dll* near the top, just under `b64.exe`, and with all
    other libraries as direct or indirect dependencies of that library. This implies
    that every system or library call made by `b64.exe` is being made directly to
    *cygwin1.dll*, which then calls the other libraries on its behalf.
  prefs: []
  type: TYPE_NORMAL
- en: The 64-bit mingw64 version at ➌ displays a similar hierarchy, except that the
    `b64.exe` program depends directly on *kernel32.dll* and *msvcrt.dll*. This is
    a native Windows program, by all accounts.
  prefs: []
  type: TYPE_NORMAL
- en: My version of the `cygcheck` utility has some problems with 32-bit native Windows
    software. You can see this at ➋, where the tool shows us only the program, `b64.exe`,
    with no library dependencies. To see the true details of this version, let’s switch
    to the Dependencies program I mentioned earlier. I’ve loaded all three versions
    of the program into one instance of Dependencies in [Figure 17-12](ch17.xhtml#ch17fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-12: Modules and exports for `b64.exe` built as a 32-bit mingw-w64
    program*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the 32-bit mingw-w64 version really does have library
    dependencies similar to those of the 64-bit mingw-w64 version. The 32-bit version
    uses *C:\Windows\SysWOW64\msvcrt.dll*, and the 64-bit version uses *C:\Windows\system32\msvcrt.dll*.
    The same is true of *kernel32.dll*.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional subtle differences between the Cygwin version and the mingw-w64
    versions. For a simple example, the Cygwin version imports `getopt` from *cygwin1.dll*.
    You’ll perhaps recall that we used the POSIX `getopt` function to parse command
    line options in b64\. You won’t find `getopt` in *msvcrt.dll*, however, so where
    does it come from? The mingw-w64 tool chain provides a static archive of such
    POSIX functionality that ends up becoming a part of `b64.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MinGW: Minimalist GNU for Windows'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1998, Colin Peters authored the initial release of what was then called *mingw32*.
    Later the numbers were dropped in order to avoid the implication that MinGW could
    only generate 32-bit software.^([14](footnote.xhtml#ch17fn14))
  prefs: []
  type: TYPE_NORMAL
- en: MinGW initially offered only a Cygwin port of GCC. Sometime later, Jan-Jaap
    Van der Heijden created a native Windows port of GCC and added a *binutils* package
    and GNU `make`. MinGW has been a very popular alternative to Cygwin ever since,
    mainly because of its primary goal of creating software that closely resembles
    software generated by Microsoft tools. For reasonably portable C code, no libraries
    other than Windows system and Visual Studio runtime libraries (*msvcrt.dll*) are
    required. Remember that mingw-w64 was not available until 2013, so MinGW was the
    only available open source option for generating native Windows code for more
    than 10 years.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is central to the philosophy espoused by the MinGW project. The
    goal of MinGW is to use only the standard C library as an abstraction layer and
    to modify source code where necessary to make other key packages available under
    MinGW.
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant portion of GNU software, however, that makes use of the
    *pthreads* library. To accommodate this major set of GNU packages, MinGW gave
    in to pragmatism by providing a library called *pthreads-win32.dll*. This library
    shows up so often in the dependency list for software today that many people don’t
    associate it with MinGW at all. Indeed, some portable software compiled using
    Microsoft’s tools has even used *pthreads-win32.dll* independently, as a portable
    threading library, relying on POSIX threads in both POSIX and Windows environments.^([15](footnote.xhtml#ch17fn15))
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major drawback to using MinGW, which is lately becoming more of
    an issue: MinGW still only generates 32-bit native Windows applications. Microsoft
    and Intel have recently announced jointly that some near-future version of Windows
    would only support 64-bit hardware. While 32-bit software will generally run on
    64-bit systems, this may change with time. MinGW’s package repository does not
    provide a port of its GCC compiler that generates 64-bit Windows object code,
    but there are third parties that make mingw-w64 available on the MinGW platform
    if you’re willing to move away from MinGW’s package manager. However, this sort
    of activity is discouraged because adding third-party packages to the environment
    can cause dependency problems the package manager can’t resolve.'
  prefs: []
  type: TYPE_NORMAL
- en: The MinGW community has survived on its name for many years, and the project
    has only recently started taking monetary donations to help with maintenance.
    Perhaps the additional financial support will spur the community into moving forward
    with these important upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: '*Installing MinGW*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In spite of MinGW generating only 32-bit Windows programs and libraries, it’s
    worth looking at here because using it is so simple and effective for software
    that’s already portable. Once you’ve begun to understand how MinGW and Msys work,
    moving to the other Windows-based POSIX platforms is a trivial task because all
    of them are based on some form of an Msys-like environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by installing MinGW, which could not be simpler. Navigate in your
    favorite browser to *[http://www.mingw.org](http://www.mingw.org)*. Click the
    **Downloads** tab in the top menu bar. This link takes you to the *osdn.net*^([16](footnote.xhtml#ch17fn16))
    download page for the MinGW project. Scroll down a bit (being careful to avoid
    the ridiculous large green-button advertisement links intended to look like legitimate
    download buttons). Under the gray bar labeled “Operating System: Windows,” click
    the small blue button with the embedded Windows 10–like logo. Save the `mingw-get-setup.exe`
    program to a location on your hard drive.'
  prefs: []
  type: TYPE_NORMAL
- en: Running this program presents you with a very simple dialog-based installer
    for the MinGW Installation Manager Setup Tool, as shown in [Figure 17-13](ch17.xhtml#ch17fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-13: The initial dialog presented by the MinGW Installation Manager
    Setup Tool*'
  prefs: []
  type: TYPE_NORMAL
- en: This program actually installs the MinGW Installation Manager, a tool that,
    much like the Cygwin package manager, allows fine-grained control over the MinGW
    components that get installed or updated. Before the installation manager, the
    only option for updating MinGW was either to uninstall an existing full installation
    and then reinstall a new version from scratch, or try to upgrade, which was a
    hit-and-miss proposition at best.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of the apparent out-of-date copyright range, the setup program and
    the installation manager itself were last refreshed (as of this writing) in September
    of 2017\. The installation manager keeps a package catalog up-to-date, so you
    always have access to the very latest MinGW packages. For instance, a package
    containing GCC 8.2.0 was uploaded in August of 2018\. By the time you read this,
    it will likely have been updated with an even newer version.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and click **Install**. You’re presented with an options page, shown
    in [Figure 17-14](ch17.xhtml#ch17fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-14: The options page presented by the MinGW Installation Manager
    Setup Tool*'
  prefs: []
  type: TYPE_NORMAL
- en: As with Cygwin, MinGW wants to be installed in a path off the root of the system
    drive, and also as with Cygwin, you need to consider MinGW a virtualized operating
    system. As such, it has need of a special place on your Windows filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, like Cygwin, you’ll find MinGW is not installed using the Windows
    installation database and, hence, does not show up in the Windows installed programs
    panel. You can, in fact, completely remove MinGW from your Windows system by merely
    deleting the *C:\MinGW* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you do decide to install into a different location, you’ll need to carefully
    read the initial installation instructions on the MinGW website, because you’ll
    need to make additional changes to files in the* C:\MinGW\msys\1.0\etc *directory
    after installation.*'
  prefs: []
  type: TYPE_NORMAL
- en: Leave all options as they are and click **Continue**. The next screen you’ll
    see is the download progress page, showing you that the latest installation manager
    program is being downloaded into the *C:\MinGW\libexec\mingw-get* directory. [Figure
    17-15](ch17.xhtml#ch17fig15) shows the state of this dialog once the catalog has
    been updated from the download source and the latest version of the installation
    manager has been downloaded and installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-15: The download progress page for the MinGW Installation Manager
    Setup Tool*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Continue** to open the installation manager, shown in [Figure 17-16](ch17.xhtml#ch17fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-16: The installation manager main screen with package context menu*'
  prefs: []
  type: TYPE_NORMAL
- en: The packages you see in the Basic Setup panel (shown by default) are actually
    meta-packages, or packages referring to large groups of actual packages. To see
    real packages, you can select the **All Packages** option on the left and then
    scroll through the list displayed on the right. When you’re ready to continue,
    return to the Basic Setup panel.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the *mingw-developer-toolkit-bin* meta-package will also automatically
    select the *msys-base-bin* meta-package. These two, plus the *mingw32-base-bin*
    meta-package, are all you need to compile C programs into 32-bit native Windows
    programs. Select these three packages, as shown in [Figure 17-16](ch17.xhtml#ch17fig16),
    and then click the **Apply Changes** option from the **Installation** menu, as
    shown in [Figure 17-17](ch17.xhtml#ch17fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-17: Applying selected changes in the installation manager*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re presented with a confirmation dialog titled “Schedule of Pending Actions,”
    which allows you to apply the scheduled changes, defer these changes in order
    to return to the main window and modify the current list, or simply discard all
    changes. Select **Apply**, as shown in [Figure 17-18](ch17.xhtml#ch17fig18).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-18: The installation manager’s schedule of pending actions dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’re presented with the Download Package dialog, shown in [Figure
    17-19](ch17.xhtml#ch17fig19), in which each of the 112 packages you selected for
    download is displayed with a progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-19: *The installation manager’s Download Package dialog**'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Since the MinGW download site will have undoubtedly been updated after this
    writing, you may see a different number of packages to be installed in the bottom
    pane of the dialog shown in [Figure 17-18](ch17.xhtml#ch17fig18).*'
  prefs: []
  type: TYPE_NORMAL
- en: This may take a while, depending on your internet connection, so go grab a snack.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you get any package download errors, just click **OK** to dismiss the error
    dialog, wait for the successful download and installation of the remaining packages
    to complete, and then click **Apply Changes** from the **Installation** menu again
    to retry downloading and installing the failed packages. Only the failed packages
    will be redownloaded.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once all packages have been downloaded, they’ll be installed into a standard
    Unix-like directory structure within the *C:\MinGW\msys\1.0* directory. [Figure
    17-20](ch17.xhtml#ch17fig20) shows the installation manager’s Applying Scheduled
    Changes dialog, after it has installed each of the previously downloaded packages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-20: The installation manager’s Applying Scheduled Changes dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: You may now close the installation manager program. There is one final step
    in preparing your installation of MinGW—creating a convenient desktop icon for
    the MinGW terminal, which is a somewhat outdated version of the Bash shell ported
    to Windows and running in a Windows Console Host (`conhost.exe`) process. MinGW
    installs a Windows batch file at *C:\MinGW\msys\1.0\msys.bat*. Execute this batch
    file to start the MinGW terminal that provides your POSIX build environment. I
    like to create a shortcut to this file on my desktop and change the icon for it
    to point to the *msys.ico* file found in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the `msys.bat` file and start up the MinGW terminal. You’ll find
    `pwd` shows that you’re left in the */home/**`username`* directory, where *`username`*
    is your Windows system user name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Cygwin, the best way to understand the filesystem is to use `mount`
    to view the mount points in the MinGW filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This output looks similar to its Cygwin counterpart, but there are a few differences.
    First, MinGW mounts your Windows user temporary directory as */tmp*. Second, both
    */usr* and */* represent the same Windows directory, *C:\MinGW\msys\1.0*. Finally,
    *C:\MinGW* itself is mounted under */mingw*.
  prefs: []
  type: TYPE_NORMAL
- en: Windows drives are managed a bit differently also. Windows drive letters show
    up in the MinGW filesystem as they do in Cygwin, but they’re listed directly under
    the root, rather than as a separate top-level directory. Another subtle difference
    here is that my *D:* drive is listed. It’s a virtual optical drive, with no media
    mounted. MinGW chooses to show it even without media, while Cygwin only shows
    it with media.
  prefs: []
  type: TYPE_NORMAL
- en: If you `cat` the contents of the */etc/fstab* file, you can see that most of
    the preceding is hardcoded. The only mount point that’s actually soft-configured
    is the */mingw* path:^([17](footnote.xhtml#ch17fn17))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Testing the Build*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re now ready to try building the b64 project. First, we should clean up
    the *b64* directory in order to demonstrate `bootstrap.sh` in this environment,
    so change into the *b64* directory from your MinGW terminal and use `git` to remove
    all artifacts. Then make a build directory structure for testing MinGW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At this point, rather than lead you down a sure path to failure, I’ll state
    up front that you’ll immediately run into problems with symbolic links. While
    Cygwin has no trouble properly creating and using symlinks in its environment,
    the same is not true of MinGW. If you attempt to create a symlink from `/usr/bin/gnulib-tool`
    to the `.../gnulib/gnulib-tool` program, you’ll find the `ln -s` command seems
    to work, but when you try to run `bootstrap.sh`, it fails to find Gnulib. A closer
    examination shows that the symlink you thought you created was actually just a
    copy. Well, a copy won’t work, because `gnulib-tool` uses its real location in
    the filesystem as the base of the Gnulib repository and a copy of `gnulib-tool`
    in another location cannot do this.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, we’ll have to adjust b64’s `bootstrap.sh` program to use
    a relative path to the actual `gnulib-tool`. I cloned gnulib right next to b64,
    so I merely have to change `bootstrap.sh` so that it refers to `../gnulib/gnulib-tool`,
    rather than relying on its being accessible from the system `PATH`. Use any editor
    to make changes similar to those highlighted in [Listing 17-1](ch17.xhtml#ch17ex1)
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-1:* b64/bootstrap.sh: *Changes required to allow MinGW to find
    Gnulib*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*After making these changes to *`bootstrap.sh`*, you should expect to see different
    output when you run *`b64.exe`* against it.*'
  prefs: []
  type: TYPE_NORMAL
- en: That will fix our Gnulib issues, but there’s another problem lurking here. While
    MinGW may have the very latest GCC tool chain, it doesn’t stay as current with
    the Autotools. We’ve been working with Autoconf 2.69 and Automake 1.15.1, but
    as of this writing, MinGW only provides Autoconf 2.68 and Automake 1.11.1\. Perhaps
    by the time you read this, these tools will have been updated, and you will not
    have to make the changes to *configure.ac* shown in [Listing 17-2](ch17.xhtml#ch17ex2).
    Check your Autoconf and Automake versions before making these changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-2:* b64/configure.ac: *Changes required to work with Autoconf 2.68*'
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted lines show the changes that need to be made. First, we need
    to reduce the lowest supported version in `AC_PREREQ` to allow Autoconf 2.68 to
    process this *configure.ac* file. Then we need to change the Automake macro, `AC_CONFIG_MACRO_DIRS`
    (plural), to its Autoconf counterpart, `AC_CONFIG_MACRO_DIR`. It works the same,
    except that the one that comes with Automake 1.15.1 makes it possible for us to
    forego the use of `AC_LOCAL_AMFLAGS = -I m4` in our *Makefile.am* file. Luckily,
    I had already added that line into *Makefile.am* and just left it there, so this
    change is easy. Finally, Automake 1.15.1 consolidated the functionality of `AM_PROG_CC_C_O`
    into the `AM_INIT_AUTOMAKE` macro when the `subdir-objects` option is given. Moving
    back to Automake 1.11.1 requires us to change to the old format where we have
    to explicitly mention `AM_PROG_CC_C_O` and it must come after `AC_PROG_CC`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, we can finally run `bootstrap.sh` to generate our `configure`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change into the *mgw-builds/mingw* directory created earlier and run `configure`
    with a relative path back to *b64*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Opening `b64.exe` in `DependenciesGUI.exe` shows us it’s a 32-bit Windows program
    that depends only on `SysWOW64\kernel32.dll` and `SysWOW64\MSVCRT.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: Msys2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Msys2 was developed by a company called OneVision Software in 2013 using “clean
    room” techniques in order to loosen up the open source licensing requirements
    imposed by Cygwin and to provide a more modern alternative to the old out-of-date
    Msys environments used by Cygwin and MinGW.
  prefs: []
  type: TYPE_NORMAL
- en: MSys2 uses a OneVision 64-bit port of the MinGW tool chain called *mingw-w64*.
    However, like Cygwin, Msys2 provides its own library of POSIX system-level functionality
    called *msys-2.0.dll*. Msys2 provides a C standard library implemented in terms
    of this library. You can detect if a Windows program was built for the Msys2 platform
    in the same manner as previously described for the Cygwin platform.
  prefs: []
  type: TYPE_NORMAL
- en: Because Msys2 is more or less a feature-for-feature replacement of Cygwin, and
    since so many people are already used to the way Cygwin works, Msys2 has had a
    difficult time gaining traction, though it is used by some key players, including
    Git for Windows. Msys2 is advertised as an upgrade to Cygwin, but Msys2 merely
    provides different implementations of the same portability mechanisms used by
    Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: The one distinguishing characteristic that sets Msys2 apart from Cygwin is the
    fact that Msys2’s open source license is much more lenient than that of Cygwin.
    While Cygwin uses GPL-based licensing, Msys2 uses only a standard 3-clause BSD
    license, making it a viable option for building proprietary Windows software using
    Linux tools.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant offering in OneVision’s system is the 64-bit port of the
    MinGW compiler—not that it runs on 64-bit platforms (which it does), but that
    it generates 64-bit Windows code. It’s safe to say that the world of cross-compiled
    Windows code was expanded dramatically when this compiler was released. It has
    since been ported to many different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Msys2 does tie into the Windows installation database, so you may uninstall
    Msys2 from the Windows installed-programs panel.
  prefs: []
  type: TYPE_NORMAL
- en: '*What’s Msys?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The term “Msys” has been misused for many purposes over the years. Some think
    it means “Unix on Windows” or, at the very least, the sense of such. All it really
    provides is potential. Msys, at its most basic, provides a Unix-compatible terminal
    program, a Bourne-like shell (usually Bash), and a base set of utilities. Some
    implementations have more and some have fewer utilities. Whatever implementation
    you’re using, be it Cygwin, MinGW, or Msys2, the Msys component of these packages
    is there for you to build upon by installing additional packages to build up the
    environment the way you like.
  prefs: []
  type: TYPE_NORMAL
- en: When OneVision created Msys2, the company’s vision was to start out small, allowing
    the user to build up the environment exactly the way they wanted. Msys2’s version
    of Msys has very few packages preinstalled, while Cygwin has many. Msys2 and Cygwin
    base their terminal window on `mintty.exe`,^([18](footnote.xhtml#ch17fn18)) while
    MinGW bases its terminal on `conhost.exe` (Windows console host process), and
    you can tell this is so because the look and feel of the Cygwin and Msys2 terminals
    are very similar to each other, but significantly different from that of MinGW.
  prefs: []
  type: TYPE_NORMAL
- en: '*Installing Msys2*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The installation procedure for Msys2 is pretty simple. Navigate in your web
    browser to the Msys2 home page at *[http://www.msys2.org](http://www.msys2.org)*
    and click the button at the top of the page for either the 32-bit (`msys2-i686-`*`yyyymmdd`*`.exe`)
    or the 64-bit (`msys2-x86_64-`*`yyyymmdd`*`.exe`) version of the Msys2 installer.^([19](footnote.xhtml#ch17fn19))
    When the download completes, run the installer and you’re presented with a dialog-based
    installation wizard. The welcome page is shown in [Figure 17-21](ch17.xhtml#ch17fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-21: The welcome page of the Msys2 install utility*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to move to the next page, shown in [Figure 17-22](ch17.xhtml#ch17fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-22: The installation folder page of the Msys2 install utility*'
  prefs: []
  type: TYPE_NORMAL
- en: Select an installation location. Like Cygwin and MinGW, Msys2 wants to be installed
    at the root of the system drive. I recommend sticking with the default location
    for the same reasons I gave for the other two systems. Click **Next** to move
    to the next page, shown in [Figure 17-23](ch17.xhtml#ch17fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-23: The shortcuts page of the Msys2 install utility*'
  prefs: []
  type: TYPE_NORMAL
- en: You can select the Windows Start Menu folder in which you’d like the installer
    to create its shortcuts. The default is sufficient. Click **Next** to move to
    the next page and begin installation, shown in [Figure 17-24](ch17.xhtml#ch17fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-24: The installation progress page (showing details) of the Msys2
    install utility*'
  prefs: []
  type: TYPE_NORMAL
- en: When installation has completed, click **Next** to move to the final page, shown
    in [Figure 17-25](ch17.xhtml#ch17fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/17fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-25: The final page of the Msys2 install utility*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re given the option here of starting Msys2 upon completion. Click **Finish**
    to exit the installer. Allow the installer to execute Msys2 as it exits or go
    to the Windows 10 Start Menu, locate the **MSYS2 64bit** folder, and click the
    **MSYS2 MSYS** entry. Both options start the Msys2 terminal window in the same
    manner by executing the `C:\msys64\msys2_shell.cmd` script with a command line
    option of `-msys`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other systems’ installers, the Msys2 installer doesn’t download packages
    from the internet. Rather, much like a Linux distribution release, Msys2 installs
    a small base set of packages that get further out-of-date as time goes by until,
    eventually, a new installer is made available by the Msys2 maintainers. Therefore,
    the first thing you need to do is update these installed base packages.
  prefs: []
  type: TYPE_NORMAL
- en: Msys2 uses a Windows port of the Arch Linux package manager, Pacman, to provide
    access to repositories of packages ported to Msys2\. The basic installation provides
    relatively few packages, and it needs to be updated with Pacman before additional
    packages can be installed.
  prefs: []
  type: TYPE_NORMAL
- en: With the terminal window open, we’ll update the Msys2 system using the command
    `pacman -Syu`. Pacman commands are uppercase, and options to those commands are
    lowercase. The `-S` command is the remote repository “sync” command. The `-u`
    option of this command updates existing packages from the remote repository. The
    `-y` option updates the catalog from the repository before checking for updates.
    To get help on the commands, run `pacman -h`. To get help on the available options
    for a command, add `-h` to the command line along with the command. For example,
    to get help on available options for the `-S` command, run `pacman -Sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and update the system now, downloading the latest catalog first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Press y (or just enter to accept the default) at the prompt to continue updating
    the Msys2 system. You’ll note the small number of packages being updated. The
    base Msys2 system provides almost nothing. The core system comes with Bash, a
    Unix-like filesystem emulator that sits on top of the Windows filesystem, mintty,
    the Msys2 Msys runtime, and the Pacman package manager, so it’s not really a problem
    that the Msys2 installer installs out-of-date packages that need to be updated
    upon first use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pacman will download and install several packages, including Pacman:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When you reach this point, Pacman itself needs to be updated, but it cannot
    update itself while it’s running—an artifact of the way Windows manages running
    executable images. It displays a message indicating that you should close the
    terminal window by clicking the X in the upper-right corner and then restart Msys2
    from the Windows Start Menu and continue the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you get a pop-up box warning you of running processes, just click ***OK***
    to close the window anyway.*'
  prefs: []
  type: TYPE_NORMAL
- en: Run `pacman -Su` again (no need to update the catalog again) to continue the
    update process and press enter when prompted again. This time, many more packages
    are updated. Press y (or just enter) to continue and then wait for the update
    process to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue installing additional packages, let’s take a look at the
    filesystem by running the `mount` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the Msys2 base installation directory, *C:\msys64*, is mounted
    at */* and that *C:\msys64\usr\bin* is mounted at */bin*. As with the other systems,
    Windows drives are mounted as their drive letter. Msys2 mounts them off the root
    like MinGW. (Cygwin can be configured to do the same.) Like Cygwin, Msys2 doesn’t
    mount optical drives without media, so you don’t see my *D:* drive mounted here
    as */d*, but if I inserted a virtual disc and then executed `mount`, it would
    show up in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '*Installing Tools*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, Msys2 is completely up-to-date and ready for you to add tools.
    But what tools should we add? I’d venture to guess this is the point where most
    uncommitted Msys2 explorers bail out. There is fairly complete documentation on
    the Msys2 wiki site, but you really need to read at least the introductory material
    in order to understand Msys2 the way you should.
  prefs: []
  type: TYPE_NORMAL
- en: While Cygwin and MinGW make it pretty obvious which path you should take at
    each turn, Msys2 simply offers options. You can build POSIX-only software for
    the Msys2 environment, or you can build native 32- or 64-bit Windows applications.
    Msys2 doesn’t attempt to persuade you to go one way or the other by preinstalling
    software for a particular goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Msys2 provides three different terminal window shortcuts, each configured (using
    different command line options) to build software for one of the three targets
    Msys2 supports: Msys2 native applications, 32-bit Windows applications, or 64-bit
    Windows applications. This is not really any different from cross-compiling; it
    just targets a specific tool chain with a custom environment instead of using
    options on the `configure` command line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, our goal here is not to build Msys2 software. Rather, we want to
    build Windows software, and Msys2 fully supports this goal. To find out what needs
    to be installed to meet our goals, read the Msys2 wiki page titled “Creating Packages.”^([20](footnote.xhtml#ch17fn20))
    According to this page, the following are the important Pacman groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base-devel**   Required by all targets'
  prefs: []
  type: TYPE_NORMAL
- en: '**msys2-devel**   For building Msys2 native POSIX packages'
  prefs: []
  type: TYPE_NORMAL
- en: '**mingw-w64-i686-toolchain**   For building native 32-bit Windows software'
  prefs: []
  type: TYPE_NORMAL
- en: '**mingw-w64-x86_64-toolchain**   For building native 64-bit Windows software'
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, the first and last of these packages will suffice. It’s not
    necessarily obvious, but you don’t get `gcc` and the *binutils* package unless
    you install the *msys2-devel* meta package. Like Cygwin, Msys2 sees its own platform,
    which generates applications that fully depend on *msys2.0.dll*, as owning the
    native Msys2 tool chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no GUI package installer in Msys2, so let’s begin by exploring a few
    Pacman commands. Like most package management systems, the packages available
    to Pacman are grouped into logical sets. The `-Sg` option shows you a list of
    package groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out what packages are in a group, just add the group name to the end
    of the previous command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `pacman -S` to install a package and give it a group name, it
    shows you a list of group members and asks which of these members to install.
    If you simply press enter, it installs all of them. The `--needed` option ensures
    that only packages that are not already installed are downloaded. Without it,
    you’ll download and install packages in your target groups that are already installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Press y to download and then install the packages you requested. This could
    take a while, so I guess it’s time for another snack.
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing the Build*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once these packages have been installed, your Msys2 environment is ready to
    use. Let’s change into the *b64* directory again, clean up, and create another
    build directory for Msys2 build testing.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been working through this chapter and just came out of testing MinGW,
    your `bootstrap.sh` and *configure.ac* files have probably been modified. These
    changes will work fine in this environment. However, if you do decide to revert,
    only revert the *configure.ac* changes. The `bootstrap.sh` file should remain
    as is with the relative-path reference to `gnulib-tool`. If you skipped the section
    on MinGW, you’ll need to modify `bootstrap.sh` by adding a relative path to the
    Gnulib repository work area to the execution of `gnulib-tool`. Msys2 has the same
    problem as MinGW in that it creates copies of the target, rather than working
    symlinks, so creating a symlink in */usr/bin* for `gnulib-tool` will not work
    here:^([21](footnote.xhtml#ch17fn21))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Before we can build b64, we need to change terminals. You may have noticed that
    Msys2 configured three shortcuts in the **MSYS2 64bit** folder it created in the
    Windows Start Menu. Up to this point, we’ve been using the **MSYS2 MSYS** shortcut
    to start an Msys2 terminal. This was fine as long as we were just installing packages
    or if we were going to target the Msys2 platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re building 64-bit native Windows software, so open a MinGW 64-bit terminal
    now. Then, from within that terminal window, change into the *b64/ms2-builds/mw64*
    directory and build b64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The difference between these terminal windows is defined by the values of various
    environment variables starting with `MSYS`. These variables are used to configure
    the site configuration file referenced in the first line of `configure`’s output.
    See the Msys2 wiki for lots of details on how to configure environments this way.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `b64.exe` program through `DependenciesGUI.exe`, we can see that
    it’s a true native 64-bit Windows program, dependent only on Windows system and
    Visual Studio runtime libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the whirlwind tour we just took, you should now have no trouble building
    Windows software using GNU tools. Personally, I find the Cygwin and Msys2 environments
    to be the most useful for many purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Msys2 is a bit more modern and fresh, but they both serve as good general-purpose
    platforms for the GNU tools. Msys2 also has the distinct advantage of building
    pure Windows software wherever possible, while Cygwin (unless using the mingw-w64
    cross tools) builds apps that, although they do run on Windows, rely heavily on
    the Cygwin system library. That’s not necessarily a showstopper for me. If there
    are other factors and Cygwin comes out on top, then I don’t mind the extra library,
    but the purist in me leans toward a desire for no unnecessary third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin has the advantage of maturity. It’s not so far behind Msys2 that it’s
    unusable, but it’s been around long enough that it has some nice features, like
    integrating a working symbolic link mechanism into all of its utilities so it
    can properly emulate POSIX symlinks. It also has many more packages available
    for installation within the environment.
  prefs: []
  type: TYPE_NORMAL
- en: MinGW is a bit out-of-date, and it really needs to support 64-bit Windows builds,
    but it’s clean and small. With its new package manager, it stacks up pretty well
    against the other two. All it really needs to move into the big leagues is to
    embrace the newer 64-bit code generator in the *mingw-w64* package. It might also
    be nice to upgrade to mintty from the conhost-based console it uses.
  prefs: []
  type: TYPE_NORMAL
