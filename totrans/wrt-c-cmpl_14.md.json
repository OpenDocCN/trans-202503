["```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, exp? init,\n                        type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\ntype = Int | Long | **UInt | ULong |** FunType(type* params, type ret)\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int) **| ConstUInt(int) | ConstULong(int)**\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ <identifier> [\"=\" <exp>] \";\"\n<function-declaration> ::= {<specifier>}+ <identifier> \"(\" <param-list> \")\" (<block> | \";\")\n<param-list> ::= \"void\"\n               | {<type-specifier>}+ <identifier> {\",\" {<type-specifier>}+ <identifier>}\n<type-specifier> ::= \"int\" | \"long\" **| \"unsigned\" | \"signed\"**\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= <const> | <identifier>\n           | \"(\" {<type-specifier>}+ \")\" <factor>\n           | <unop> <factor> | \"(\" <exp> \")\"\n           | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | **<uint> | <ulong>**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? An int token ?\n<long> ::= ? An int or long token ?\n**<uint> ::= ? An unsigned int token ?**\n**<ulong> ::= ? An unsigned int or unsigned long token ?**\n```", "```\nparse_type(specifier_list):\n    if (specifier_list is empty\n        or specifier_list contains the same specifier twice\n        or specifier_list contains both \"signed\" and \"unsigned\"):\n        fail(\"Invalid type specifier\")\n    if specifier_list contains \"unsigned\" and \"long\":\n        return ULong\n    if specifier_list contains \"unsigned\":\n        return UInt\n    if specifier_list contains \"long\":\n        return Long\n    return Int\n```", "```\nget_common_type(type1, type2):\n  ❶ if type1 == type2:\n        return type1\n  ❷ if size(type1) == size(type2):\n        if type1 is signed:\n            return type2\n        else:\n            return type1\n  ❸ if size(type1) > size(type2):\n        return type1\n    else:\n        return type2\n```", "```\nstatic_init = IntInit(int) | LongInit(int) | **UIntInit(int) | ULongInit(int)**\n```", "```\nstatic unsigned int u = 4294967299L;\n```", "```\nstatic int i = 4294967246u;\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, static_init init)\ninstruction = Return(val)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            **| ZeroExtend(val src, val dst)**\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\nemit_tacky(e, instructions, symbols):\n    match e with\n    | `--snip--`\n    | Cast(t, inner) ->\n        result = emit_tacky(inner, instructions, symbols)\n        inner_type = get_type(inner)\n        if t == inner_type:\n            return result\n        dst = make_tacky_variable(t, symbols)\n      ❶ if size(t) == size(inner_type):\n            instructions.append(Copy(result, dst))\n      ❷ else if size(t) < size(inner_type):\n            instructions.append(Truncate(result, dst))\n      ❸ else if inner_type is signed:\n            instructions.append(SignExtend(result, dst))\n      ❹ else:\n            instructions.append(ZeroExtend(result, dst))\n        return dst\n```", "```\n 1000\n+ 0010\n------\n  1010\n```", "```\n 1111\n- 0011\n------\n  1100\n```", "```\ncmpl    $10, %edx\nmovl    $0, %eax\nseta    %al\n```", "```\nmovl    -4(%rbp), %eax\nmovq    %rax, -16(%rbp)\n```", "```\nprogram = Program(top_level*)\nassembly_type = Longword | Quadword\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(operand src, operand dst)\n            **| MovZeroExtend(operand src, operand dst)**\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            **| Div(assembly_type, operand)**\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\n\nunary_operator = Neg | Not\nbinary_operator = Add | Sub | Mult\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | Data(identifier)\ncond_code = E | NE | G | GE | L | LE **| A | AE | B | BE**\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP\n```", "```\nBinary(LessThan, Var(\"src1\"), Var(\"src2\"), Var(\"dst\"))\n```", "```\nCmp(Longword, Pseudo(\"src2\"), Pseudo(\"src1\"))\nMov(Longword, Imm(0), Pseudo(\"dst\"))\nSetCC(B, Pseudo(\"dst\"))\n```", "```\nBinary(Remainder, ConstULong(100), Var(\"x\"), Var(\"dst\"))\n```", "```\nMov(Quadword, Imm(100), Reg(AX))\nMov(Quadword, Imm(0), Reg(DX))\nDiv(Quadword, Pseudo(\"x\"))\nMov(Quadword, Reg(DX), Pseudo(\"dst\"))\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src1, Reg(AX))\nCdq(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)\nIdiv(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src2)\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(AX), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, src1, Reg(AX))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, Imm(0), Reg(DX))\nDiv(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, src2)\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, Reg(AX), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src1, Reg(AX))\nCdq(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)\nIdiv(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src2)\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Reg(DX), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, src1, Reg(AX))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, Imm(0), Reg(DX))\nDiv(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, src2)\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src1 type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, Reg(DX), dst)</samp>\n```", "```\nMovZeroExtend(Stack(-16), Reg(AX))\n```", "```\nMov(Longword, Stack(-16), Reg(AX))\n```", "```\nMovZeroExtend(Imm(100), Stack(-16))\n```", "```\nMov(Longword, Imm(100), Reg(R11))\nMov(Quadword, Reg(R11), Stack(-16))\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">div</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><t>    <operand></samp>\n```"]