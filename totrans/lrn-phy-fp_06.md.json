["```\nphysicists :: [String]\nphysicists = [\"Einstein\",\"Newton\",\"Maxwell\"]\n```", "```\ntype R = Double\n```", "```\nvelocities :: [R]\nvelocities = [0,-9.8,-19.6,-29.4]\n```", "```\nPrelude> :l Lists.hs\n[1 of 1] Compiling Main            ( Lists.hs, interpreted )\nOk, one module loaded.\n*Main> velocities !! 0\n0.0\n*Main> velocities !! 1\n-9.8\n*Main> velocities !! 3\n-29.4\n```", "```\nmoreVelocities :: [R]\nmoreVelocities = [-39.2,-49.0]\n```", "```\n*Main> velocities ++ moreVelocities\n[0.0,-9.8,-19.6,-29.4,-39.2,-49.0]\n*Main> :t velocities ++ moreVelocities\nvelocities ++ moreVelocities :: [R]\n```", "```\n   *Main> physicists ++ velocities\n\n➊ <interactive>:7:15: error:\n   ➋ • Couldn't match type Double with [Char]\n     ➌ Expected type: [String]\n       ➍ Actual type: [R]\n   ➎ • In the second argument of (++), namely velocities\n        In the expression: physicists ++ velocities\n        In an equation for it: it = physicists ++ velocities\n```", "```\nshortWords :: [String]\nshortWords = [\"am\",\"I\",\"to\"]\n```", "```\n*Main> concat [shortWords,physicists,shortWords]\n[\"am\",\"I\",\"to\",\"Einstein\",\"Newton\",\"Maxwell\",\"am\",\"I\",\"to\"]\n```", "```\nns :: [Int]\nns = [0..10]\n```", "```\n*Main>  [0,2,5+3]\n[0,2,8]\n```", "```\n*Main>  [0..10]\n[0,1,2,3,4,5,6,7,8,9,10]\n```", "```\n*Main>  [-2,-1.5..1]\n[-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0]\n```", "```\n*Main>  [10,9.5..8]\n[10.0,9.5,9.0,8.5,8.0]\n```", "```\nsquare :: R -> R\nsquare x = x**2\n```", "```\nfuncs :: [R -> R]\nfuncs = [cos,square,sin]\n```", "```\n*Main> :t []\n[] :: [a]\n```", "```\n*Main> 0.4 / 4\n0.1\n```", "```\noneDouble :: Double\noneDouble = 1\n\ntwoInt :: Int\ntwoInt = 2\n```", "```\n*Main> oneDouble / twoInt\n\n<interactive>:42:13: error:\n    • Couldn't match expected type Double with actual type Int\n    • In the second argument of (/), namely twoInt\n      In the expression: oneDouble / twoInt\n      In an equation for it: it = oneDouble / twoInt\n```", "```\n*Main> oneDouble / fromIntegral twoInt\n0.5\n```", "```\n*Main> length velocities\n4\n*Main> length ns\n11\n\n*Main> length funcs\n3\n```", "```\n*Main> :t length\nlength :: Foldable t => t a -> Int\n```", "```\nlen :: [a] -> Int\nlen = length\n```", "```\n*Main> :t len\nlen :: [a] -> Int\n```", "```\n*Main>  ['W','h','y','?'] == \"Why?\"\nTrue\n```", "```\nts :: [R]\nts = [0,0.1..6]\n```", "```\nyRock30 :: R -> R\nyRock30 t = 30 * t - 0.5 * 9.8 * t**2\n```", "```\nxs :: [R]\nxs = [yRock30 t | t <- ts]\n```", "```\n*Main> take 10 [3..]\n[3,4,5,6,7,8,9,10,11,12]\n```", "```\n*Main> take 10 (cycle [4,7,8])\n[4,7,8,4,7,8,4,7,8,4]\n```", "```\nsndItem :: [a] -> a\nsndItem ys = case ys of\n               []     -> error \"Empty list has no second element.\"\n               (x:xs) -> if null xs\n                         then error \"1-item list has no 2nd item.\"\n                         else head xs\n```", "```\nsndItem2 :: [a] -> a\nsndItem2 []     = error \"Empty list has no second element.\"\nsndItem2 (x:xs) = if null xs\n                  then error \"1-item list has no 2nd item.\"\n                  else head xs\n```", "```\nsndItem3 :: [a] -> a\nsndItem3 ys = case ys of\n                []      -> error \"Empty list has no second element.\"\n                (x:[])  -> error \"1-item list has no 2nd item.\"\n                (x:z:_) -> z\n```", "```\nsndItem4 :: [a] -> a\nsndItem4 []      = error \"Empty list has no second element.\"\nsndItem4 (x:[])  = error \"1-item list has no 2nd item.\"\nsndItem4 (x:z:_) = z\n```", "```\nnumbers :: [R]\nnumbers = [-2.0,-1.2,-0.4,0.4,1.2,2.0]\n```", "```\nlength \"Hello, world!\"\n```", "```\n*Main>  [0,3..8]\n[0,3,6]\n*Main>  [0,3..8.0]\n[0.0,3.0,6.0,9.0]\n```", "```\nfact :: Integer -> Integer\nfact n = undefined\n```", "```\nexpList :: R -> [R]\nexpList x = undefined\n```", "```\nexpSeries :: R -> [R]\nexpSeries x = undefined\n```"]