<html><head></head><body>
		<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_145"/><strong><span class="big">6</span></strong><br/><strong>CONSTANTS AND HIGH-LEVEL LANGUAGES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Some programmers may not realize it, but many CPUs do not treat constant and variable data identically at the machine code level. Most CPUs provide a special <em>immediate addressing mode</em> that allows a language translator to embed a constant value directly into a machine instruction rather than storing it in a memory location and accessing it as a variable. However, the CPU’s ability to represent constant data efficiently varies by CPU and, in fact, by the type of the data. By understanding how a CPU treats constant data at the machine code level, you can choose appropriate ways to represent constants in your HLL source code to produce smaller and faster executable programs. To that end, this chapter discusses the following topics:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">How to use literal constants properly to improve the efficiency of your programs</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The difference between a literal constant and a manifest constant</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How compilers process compile-time constant expressions to reduce program size and avoid runtime calculations</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_146"/>&#13;
			<p class="noindent">The difference between a compile-time constant and read-only data kept in memory</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">How compilers represent noninteger constants, such as enumerated data types, Boolean data types, floating-point constants, and string constants</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How compilers represent composite data type constants, such as array constants and record/struct constants</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">By the time you finish this chapter, you should have a clear understanding of how various constants can affect the efficiency of the machine code your compiler produces.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>If you’ve already read</em> WGC1, <em>you may just want to skim through this chapter, which for the sake of completeness repeats some of the information from <a href="ch06.xhtml#ch06">Chapters 6</a> and <a href="ch07.xhtml#ch07">7</a> of that volume.</em></p>&#13;
		</div>&#13;
		<h3 class="h3" id="ch00lev1sec50"><strong>6.1 Literal Constants and Program Efficiency</strong></h3>&#13;
		<p class="noindent">High-level programming languages and most modern CPUs allow you to specify constant values just about anywhere you can legally read the value of a memory variable. Consider the following Visual Basic and HLA statements, which assign the constant <code>1000</code> to the variable <code>i</code>:</p>&#13;
		<pre class="programs">&#13;
			i = 1000<br/><br/>mov( 1000, i );</pre>&#13;
		<p class="indent">The 80x86, like most CPUs, actually encodes the constant representation for 1,000 directly into the machine instruction. This provides a compact and efficient way to work with constants at the machine level. Therefore, statements that use literal constants in this manner are often more efficient that those that assign constant values to a variable and then reference that variable later in the code. Consider the following Visual Basic code sequence:</p>&#13;
		<pre class="programs">&#13;
			oneThousand = 1000<br/>    .<br/>    .<br/>    .<br/>x = x + oneThousand 'Using "oneThousand" rather than<br/>                    ' a literal constant.<br/>y = y + 1000        'Using a literal constant.</pre>&#13;
		<p class="indent">Now consider the 80x86 assembly code you would probably write for these last two statements. For the first statement, we must use two instructions because we can’t add the value of one memory location directly to another:</p>&#13;
		<pre class="programs">&#13;
			mov( oneThousand, eax ); // x = x + oneThousand<br/>add( eax, x );</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_147"/>But we can add a constant to a memory location, so the second Visual Basic statement translates to a single machine instruction:</p>&#13;
		<pre class="programs">add( 1000, y ); // y = y + 1000</pre>&#13;
		<p class="indent">As you can see, using a literal constant, rather than a variable, is more efficient. This is not to suggest, however, that every processor operates more efficiently using literal constants, or that every CPU operates more efficiently no matter the value of the constant. Some very old CPUs don’t provide the ability to embed literal constants within a machine instruction at all; and many RISC processors, such as the ARM, do so only for smaller 8-, 12-, or 16-bit constants.<sup><a id="ch6fn_1"/><a href="footnotes.xhtml#ch6fn1">1</a></sup> Even those CPUs that allow you to load any integer constant may not support literal floating-point constants—the ubiquitous 80x86 processor being one example. Few CPUs provide the ability to encode large data structures (such as an array, record, or string) as part of a machine instruction. For example, consider the following C code:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv, char **envp )<br/>{<br/>  int i,j,k;<br/><br/>  i = 1;<br/>  j = 16000;<br/>  k = 100000;<br/>  printf( "%d, %d, %d\n", i, j, k );<br/><br/>}</pre>&#13;
		<p class="indent">Its compilation to PowerPC assembly by the GCC compiler looks like this (edited to remove the nonrelevant code):</p>&#13;
		<pre class="programs">&#13;
			L1$pb:<br/>    mflr r31<br/>    stw r3,120(r30)<br/>    stw r4,124(r30)<br/>    stw r5,128(r30)<br/><br/>; The following two instructions copy the value 1 into the variable "i"<br/><br/>    li r0,1<br/>    stw r0,64(r30)<br/><br/>; The following two instructions copy the value 16,000 into the variable "j"<br/><br/>    li r0,16000<br/>    stw r0,68(r30)<br/><br/><span epub:type="pagebreak" id="page_148"/>; It takes three instructions to copy the value 100,000 into variable "k"<br/><br/>    lis r0,0x1<br/>    ori r0,r0,34464<br/>    stw r0,72(r30)<br/><br/>; The following code sets up and calls the printf function:<br/><br/>    addis r3,r31,ha16(LC0-L1$pb)<br/>    la r3,lo16(LC0-L1$pb)(r3)<br/>    lwz r4,64(r30)<br/>    lwz r5,68(r30)<br/>    lwz r6,72(r30)<br/>    bl L_printf$stub<br/>    mr r3,r0<br/>    lwz r1,0(r1)<br/>    lwz r0,8(r1)<br/>    mtlr r0<br/>    lmw r30,-8(r1)<br/>    blr</pre>&#13;
		<p class="indent">The PowerPC CPU allows only 16-bit immediate constants in a single instruction. In order to load a larger value into a register, the program has to first use the <code>lis</code> instruction to load the higher-order (HO) 16 bits of a 32-bit register and then use the <code>ori</code> instruction to merge in the lower-order (LO) 16 bits. The exact operation of these instructions isn’t too important. What’s notable is that the compiler emits three instructions for large constants, and only two for smaller constants. Therefore, using 16-bit constant values on the PowerPC produces shorter and faster machine code.</p>&#13;
		<p class="indent">The compilation of this C code to ARMv7 assembly by the GCC compiler looks like this (edited to remove the nonrelevant code):</p>&#13;
		<pre class="programs">&#13;
			.LC0:<br/>    .ascii  "i=%d, j=%d, k=%d\012\000"<br/>    .text<br/>    .align  2<br/>    .global main<br/>    .type   main, %function<br/>main:<br/>    @ args = 0, pretend = 0, frame = 24<br/>    @ frame_needed = 1, uses_anonymous_args = 0<br/>    stmfd   sp!, {fp, lr}<br/>    add fp, sp, #4<br/>    sub sp, sp, #24<br/>    str r0, [fp, #-24]<br/>    str r1, [fp, #-28]<br/><br/>; Store 1 into 'i' variable:<br/><br/>    mov r3, #1<br/>    str r3, [fp, #-8]<br/><span epub:type="pagebreak" id="page_149"/>@ Store 16000 into 'j' variable:<br/><br/>    mov r3, #16000<br/>    str r3, [fp, #-12]<br/><br/>@ Store 100,000 (constant appears in memory) into 'k' variable:<br/><br/>    ldr r3, .L3<br/>    str r3, [fp, #-16]<br/><br/>@ Fetch the values and print them:<br/><br/>    ldr r0, .L3+4<br/>    ldr r1, [fp, #-8]<br/>    ldr r2, [fp, #-12]<br/>    ldr r3, [fp, #-16]<br/>    bl  printf<br/>    mov r3, #0<br/>    mov r0, r3<br/>    sub sp, fp, #4<br/>    @ sp needed<br/>    ldmfd   sp!, {fp, pc}<br/>.L4:<br/><br/>@ constant value for k appears in memory:<br/><br/>    .align  2<br/>.L3:<br/>    .word    100000<br/>    .word   .LC0</pre>&#13;
		<p class="indent">The ARM CPU allows only 16-bit immediate constants in a single instruction. In order to load a larger value into a register, the compiler places the constant into a memory location and loads the constant from memory.</p>&#13;
		<p class="indent">Even though CISC processors like the 80x86 can usually encode any integer constant (up to 32 bits) in a single instruction, this doesn’t mean that the program’s efficiency is independent of the sizes of the constants you use in your programs. CISC processors often use different encodings for machine instructions that have large or small immediate operands, allowing the program to use less memory for smaller constants. For example, consider the following two 80x86/HLA machine instructions:</p>&#13;
		<pre class="programs">&#13;
			add( 5, ebx );<br/>add( 500_000, ebx );</pre>&#13;
		<p class="indent">On the 80x86 an assembler can encode the first instruction in 3 bytes: 2 bytes for the opcode and addressing mode information, and 1 byte to hold the small immediate constant <code>5</code>. The second instruction, on the other hand, requires 6 bytes to encode: 2 bytes for the opcode and addressing mode information, and 4 bytes to hold the constant <code>500_000</code>. Certainly the second instruction is larger, and in some cases it may even run a little slower.</p>&#13;
		<h3 class="h3" id="ch00lev1sec51"><span epub:type="pagebreak" id="page_150"/><strong>6.2 Binding Times</strong></h3>&#13;
		<p class="noindent">What exactly is a constant? Obviously, from an HLL perspective, a constant is some sort of entity whose value doesn’t change (that is, remains constant). However, there is more to the definition. For example, consider the following Pascal constant declaration:</p>&#13;
		<pre class="programs">&#13;
			const <span class="codeitalic1">someConstant</span>:integer = 5;</pre>&#13;
		<p class="indent">In the code following this declaration,<sup><a id="ch6fn_2"/><a href="footnotes.xhtml#ch6fn2">2</a></sup> you can use the name <span class="codeitalic">someConstant</span> in place of the value <code>5</code>. But what about before this declaration? How about outside the scope to which this declaration belongs? Clearly the value of <span class="codeitalic">someConstant</span> can change upon the compiler processing this declaration. So the notion that a constant’s “value doesn’t change” doesn’t exactly apply here.</p>&#13;
		<p class="indent">The real concern here isn’t <em>where</em> the program associates a value with <span class="codeitalic">someConstant</span> but <em>when</em>. <em>Binding</em> is the technical name for creating associations between attributes (such as the name, value, and scope) of some object. For example, the earlier Pascal example binds the value <code>5</code> to the name <span class="codeitalic">someConstant</span>. <em>Binding time</em>—when the binding (association) occurs—can happen at several different points:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent"><em>At language definition time.</em> This refers to when the language designer(s) define the language. The constants <code>true</code> and <code>false</code> in many languages are good examples.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><em>During compilation.</em> The Pascal <span class="codeitalic">someConstant</span> declaration in this section is a good example.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><em>During the linking phase.</em> An example of this might be a constant that specifies the size of the object code (machine instructions) in a program. The program cannot compute this size any earlier than during the link phase, when the linker pulls in all the object code modules and combines them together.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><em>During program loading (into memory).</em> A good example of load time binding would be associating the address of an object in memory (such as a variable or machine instruction) with some pointer constant. On many systems, the operating system relocates the code when it loads it into memory, so the program can only determine absolute memory addresses after loading.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><em>During program execution.</em> Some bindings can occur only while the program is running. For example, when you assign the value of some (computed) arithmetic expression to a variable, the binding of the value to the variable occurs during execution.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent"><em>Dynamic bindings</em> are those that occur during program execution. <em>Static bindings</em> are those that occur at any other time. <a href="ch07.xhtml#ch07">Chapter 7</a> will take another look at binding (see “What Is a Variable?” on <a href="ch07.xhtml#page_180">page 180</a>).</p>&#13;
		<h3 class="h3" id="ch00lev1sec52"><span epub:type="pagebreak" id="page_151"/><strong>6.3 Literal Constants vs. Manifest Constants</strong></h3>&#13;
		<p class="noindent">A <em>manifest constant</em> is a constant value associated with—that is, bound to—a symbolic name. A language translator can directly substitute the value everywhere the name appears within the source code, producing easy-to-read and easily maintained programs. The proper use of manifest constants is a good indication of professionally written code.</p>&#13;
		<p class="indent">Declaring manifest constants is simple in many programming languages:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Pascal programmers use the <code>const</code> section.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">HLA programmers can use the <code>const</code> or the <code>val</code> declaration sections.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">C/C++ programmers can use the <code>#define</code> macro facility.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">This Pascal code fragment demonstrates an appropriate use of manifest constants in a program:</p>&#13;
		<pre class="programs">&#13;
			const<br/>    maxIndex = 9;<br/><br/>var<br/>    a :array[0..maxIndex] of integer;<br/>        .<br/>        .<br/>        .<br/>    for i := 0 to maxIndex do<br/>        a[i] := 0;</pre>&#13;
		<p class="indent">This code is much easier to read and maintain than code that uses literal constants. By changing a single statement in this program (the <code>maxIndex</code> constant declaration) and recompiling the source file, you can easily set the number of elements and the program will continue to function properly.</p>&#13;
		<p class="indent">Because the compiler substitutes the literal numeric constant in place of the symbolic name for the manifest constant, there is no performance penalty for using manifest constants. Given that they improve the readability of your programs without any loss in efficiency, manifest constants are an important component of great code. Use them.</p>&#13;
		<h3 class="h3" id="ch00lev1sec53"><strong>6.4 Constant Expressions</strong></h3>&#13;
		<p class="noindent">Many compilers support the use of <em>constant expressions</em>, which are expressions that can be evaluated during compilation. The component values of a constant expression are all known at compile time, so the compiler can evaluate the expression and substitute its value during compilation rather than computing it at runtime. As with manifest constants, constant expressions enable you to write more easily readable and maintainable code, without any runtime efficiency loss.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_152"/>For example, consider the following C code:</p>&#13;
		<pre class="programs">&#13;
			#define smArraySize 128<br/>#define bigArraySize (smArraySize*8)<br/>      .<br/>      .<br/>      .<br/>char name[ smArraySize ];<br/>int  values[ bigArraySize ];</pre>&#13;
		<p class="indent">These two array declarations expand to the following:</p>&#13;
		<pre class="programs">&#13;
			char name[ 128 ];<br/>int  values[ (smArraySize * 8) ];</pre>&#13;
		<p class="indent">The C preprocessor further expands this to:</p>&#13;
		<pre class="programs">&#13;
			char name[ 128 ];<br/>int  values[ (128 * 8) ];</pre>&#13;
		<p class="indent">Although the C language definition supports constant expressions, this feature is not available in every language, so you’ll need to check the language reference manual for your particular compiler. The Pascal language definition, for example, says nothing about constant expressions. Some Pascal implementations support them, but others do not.</p>&#13;
		<p class="indent">Modern optimizing compilers are capable of computing constant subexpressions within arithmetic expressions at compile time (known as <em>constant folding</em>; see “Common Compiler Optimizations” on <a href="ch04.xhtml#page_63">page 63</a>), thereby saving the expense of computing fixed values at runtime. Consider the following Pascal code:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    i   :integer;<br/>            .<br/>            .<br/>            .<br/>    i := j + (5*2-3);</pre>&#13;
		<p class="indent">Any decent Pascal implementation will recognize that the subexpression <code>5*2–3</code> is a constant expression, compute the value for this expression (<code>7</code>) during compilation, and substitute that value at compile time. In other words, a good Pascal compiler generally emits machine code that is equivalent to the following statement:</p>&#13;
		<pre class="programs">i := j + 7;</pre>&#13;
		<p class="indent">If your particular compiler fully supports constant expressions, you can use this feature to write better source code. It may seem paradoxical, but writing out a full expression at some point in your program can sometimes make that particular piece of code easier to read and understand; someone <span epub:type="pagebreak" id="page_153"/>reading your code can see exactly how you calculated a value, rather than having to figure out how you arrived at some “magic” number. For example, in the context of an invoicing or timesheet routine, the expression <code>5*2–3</code> might describe the computation “two persons working for five hours, minus three person-hours provided for the job” better than the literal constant <code>7</code>.</p>&#13;
		<p class="indent">The following sample C code, and the PowerPC output produced by the GCC compiler, demonstrates constant expression optimization in action:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv, char **envp )<br/>{<br/>  int j;<br/><br/>  j = argc+2*5+1;<br/>  printf( "%d %d\n", j, argc );<br/>}</pre>&#13;
		<p class="indent">Here’s the GCC output (PowerPC assembly language):</p>&#13;
		<pre class="programs">&#13;
			_main:<br/>    mflr r0<br/>    mr r4,r3            // Register r3 holds the ARGC value upon entry<br/>    bcl 20,31,L1$pb<br/>L1$pb:<br/>    mr r5,r4            // R5 now contains the ARGC value.<br/>    mflr r10<br/>    addi r4,r4,11       // R4 contains argc+ 2*5+1<br/>                        // (i.e., argc+11)<br/>    mtlr r0             // Code that calls the printf function.<br/>    addis r3,r10,ha16(LC0-L1$pb)<br/>    la r3,lo16(LC0-L1$pb)(r3)<br/>    b L_printf$stub</pre>&#13;
		<p class="indent">As you can see, GCC has replaced the constant expression <code>2*5+1</code> with the constant <code>11</code>.</p>&#13;
		<p class="indent">Making your code more readable is definitely a good thing to do and a major part of writing great code. Keep in mind, however, that some compilers may not support the use of constant expressions, instead emitting code to compute the constant value at runtime. Obviously, this will affect the size and execution speed of your resulting program. Knowing what your compiler can do will help you decide whether to use constant expressions or precompute expressions to increase efficiency at the cost of readability.</p>&#13;
		<h3 class="h3" id="ch00lev1sec54"><strong>6.5 Manifest Constants vs. Read-Only Memory Objects</strong></h3>&#13;
		<p class="noindent">C/C++ programmers may have noticed that the previous section did not discuss the use of the C/C++ <code>const</code> declaration. This is because symbolic names (hereafter <em>symbols</em>) you declare in a C/C++ <code>const</code> statement aren’t necessarily manifest constants. That is, C/C++ does not always substitute <span epub:type="pagebreak" id="page_154"/>the value for a symbol wherever it appears in a source file. Instead, a C/C++ compiler might store that <code>const</code> value in memory and then reference the <code>const</code> object as it would a static (read-only) variable. The only difference, then, between that <code>const</code> object and a static variable is that the C/C++ compiler doesn’t allow you to assign a value to <code>const</code> at runtime.</p>&#13;
		<p class="indent">C/C++ sometimes treats constants you declare in <code>const</code> statements as static variables for a very good reason—it allows you to create within a function local constants whose value can change each time that function executes (although while the function is executing, the value remains fixed). This is why you can’t always use such a “constant” within a <code>const</code> in C/C++ and expect the C/C++ compiler to precompute its value.</p>&#13;
		<p class="indent">Most C++ compilers will accept this:</p>&#13;
		<pre class="programs">&#13;
			const int arraySize = 128;<br/>      .<br/>      .<br/>      .<br/>int anArray[ arraySize ];</pre>&#13;
		<p class="indent">They will not, however, accept this sequence:</p>&#13;
		<pre class="programs">&#13;
			const int arraySizes[2] = {128,256}; // This is legal<br/>const int arraySize = arraySizes[0]; // This is also legal<br/><br/>int array[ arraySize ]; // This is not legal</pre>&#13;
		<p class="indent"><code>arraySize</code> and <code>arraySizes</code> are both constants. Yet the C++ compiler won’t allow you to use the <code>arraySizes</code> constant, or anything based on it, as an array bound. This is because <code>arraySizes[0]</code> is actually a runtime memory location and, therefore, <code>arraySize</code> must also be a runtime memory location. In theory, you’d think the compiler would be smart enough to figure out that <code>arraySize</code> is computable at compile time and just substitute that value (<code>128</code>). The C++ language, however, doesn’t allow this.</p>&#13;
		<h3 class="h3" id="ch00lev1sec55"><strong>6.6 Swift let Statements</strong></h3>&#13;
		<p class="noindent">In the Swift programming language, you can create constants using the <code>let</code> statement. For example:</p>&#13;
		<pre class="programs">&#13;
			let <span class="codeitalic1">someConstant</span> = 5</pre>&#13;
		<p class="indent">However, the value is bound to the constant’s name at runtime (that is, this is a dynamic binding). The expression on the right-hand side of the assignment operator (<code>=</code>) doesn’t have to be a constant expression; it can be an arbitrary expression involving variables and other nonconstant components. Every time the program executes this statement (such as in a loop), the program could bind a different value to <span class="codeitalic">someConstant</span>.</p>&#13;
		<p class="indent">The Swift <code>let</code> statement doesn’t truly define constants in the traditional sense; rather, it lets you create “write-once” variables. In other words, within <span epub:type="pagebreak" id="page_155"/>the scope of the symbol you define using the <code>let</code> statement, you can initialize the name with a value only once. Note that if you leave and re-enter the name’s scope, the value is destroyed (upon exiting the scope) and you can bind a new (possibly different) value to the name upon re-entering the scope. Unlike, say, the <code>const int</code> declaration in C++, <code>let</code> statements do not allow you to allocate storage for the object in read-only memory.</p>&#13;
		<h3 class="h3" id="ch00lev1sec56"><strong>6.7 Enumerated Types</strong></h3>&#13;
		<p class="noindent">Well-written programs often use a set of names to represent real-world quantities that don’t have an explicit numeric representation. An example of such a set of names might be various display technologies, like <code>crt</code>, <code>lcd</code>, <code>led</code>, and <code>plasma</code>. Even though the real world doesn’t associate numeric values with these concepts, you must encode the values numerically if you’re going to efficiently represent them in a computer system. The internal representation for each symbol is generally arbitrary, as long as the value we assign is unique. Many computer languages provide an <em>enumerated data type</em> that automatically associates a unique value with each name in a list. By using enumerated data types in your programs, you can assign meaningful names to your data rather than using “magic” numbers such as 0, 1, 2, and so on.</p>&#13;
		<p class="indent">For example, in early versions of the C language, you would create a sequence of identifiers, each with a unique value, as follows:</p>&#13;
		<pre class="programs">&#13;
			/*<br/>   Define a set of symbols representing the<br/>   different display technologies<br/>*/<br/><br/>#define crt 0<br/>#define lcd (crt+1)<br/>#define led (lcd+1)<br/>#define plasma (led+1)</pre>&#13;
		<p class="indent">By assigning values that are consecutive, you ensure that each is unique. Another advantage to this approach is that it orders the values. That is, <code>crt</code> &lt; <code>lcd</code> &lt; <code>led</code> &lt; <code>plasma</code>. Unfortunately, creating manifest constants this way is laborious and error-prone.</p>&#13;
		<p class="indent">Fortunately, in most languages enumerated constants can solve this problem. To “enumerate” means to number, and this is exactly what the compiler does—it numbers each constant, thereby handling the bookkeeping details of assigning values to enumerated constants.</p>&#13;
		<p class="indent">Most modern programming languages provide support for declaring enumerated types and constants. Here are some examples from C/C++, Pascal, Swift, and HLA:</p>&#13;
		<pre class="programs">&#13;
			enum displays {crt, lcd, led, plasma, oled };       // C++<br/>type displays = (crt, lcd, led, plasma, oled );     // Pascal<br/>type displays :enum{crt, lcd, led, plasma, oled };  // HLA<br/><span epub:type="pagebreak" id="page_156"/>// Swift example:<br/>enum Displays<br/>{<br/>    case crt<br/>    case lcd<br/>    case led<br/>    case plasma<br/>    case oled<br/>}</pre>&#13;
		<p class="indent">These four examples internally associate 0 with <code>crt</code>, 1 with <code>lcd</code>, 2 with <code>led</code>, 3 with <code>plasma</code>, and 4 with <code>oled</code>. Again, the exact internal representation is irrelevant (as long as each value is unique) because the value’s only purpose is to differentiate the enumerated objects.</p>&#13;
		<p class="indent">Most languages assign <em>monotonically increasing</em> values (that is, each successive value is greater than all previous values) to symbols in an enumerated list. Therefore, these examples have the following relationships:</p>&#13;
		<pre class="programs">crt &lt; lcd &lt; led &lt; plasma &lt; oled</pre>&#13;
		<p class="indent">Don’t let this give you the impression that all enumerated constants appearing in a single program have a unique internal representation, though. Most compilers assign a value of <code>0</code> to the first item in an enumeration list you create, a value of <code>1</code> to the second, and so on. For example, consider the following Pascal type declarations:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    colors = (red, green, blue);<br/>    fasteners = (bolt, nut, screw, rivet );</pre>&#13;
		<p class="indent">Most Pascal compilers would use the value <code>0</code> as the internal representation for both <code>red</code> and <code>bolt</code>; <code>1</code> for <code>green</code> and <code>nut</code>; and so on. In languages (like Pascal and Swift) that enforce type checking, you generally can’t use symbols of type <code>colors</code> and <code>fasteners</code> in the same expression. Therefore, the fact that these symbols share the same internal representation isn’t an issue because the compiler’s type-checking facilities preclude any possible confusion. Some languages, like C/C++ and assembly, do not provide strong type checking, however, and so this kind of confusion can occur. In those languages, it is the programmer’s responsibility to avoid mixing different types of enumeration constants.</p>&#13;
		<p class="indent">Most compilers allocate the smallest unit of memory the CPU can efficiently access in order to represent an enumerated type. Because most enumerated type declarations define fewer than 256 symbols, compilers on machines that can efficiently access byte data will usually allocate a byte for any variable with an enumerated data type. Compilers on many RISC machines can allocate a 32-bit word (or more) simply because it’s faster to access such blocks of data. The exact representation is language and compiler/implementation dependent, so check your compiler’s reference manual for the details.</p>&#13;
		<h3 class="h3" id="ch00lev1sec57"><span epub:type="pagebreak" id="page_157"/><strong>6.8 Boolean Constants</strong></h3>&#13;
		<p class="noindent">Many high-level programming languages provide <em>Boolean</em>, or <em>logical</em>, constants to represent the values <code>true</code> and <code>false</code>. Because there are only two possible Boolean values, their representation requires only a single bit. However, because most CPUs do not allow you to allocate a single bit of storage, most programming languages use a whole byte or even a larger object to represent a Boolean value. What happens to any leftover bits in a Boolean object? Unfortunately, the answer varies by language.</p>&#13;
		<p class="indent">Many languages treat the Boolean data type as an enumerated type. For example, in Pascal, the Boolean type is defined this way:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    boolean = (false, true);</pre>&#13;
		<p class="indent">This declaration associates the internal value <code>0</code> with <code>false</code> and <code>1</code> with <code>true</code>. This association has a couple of desirable attributes:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Most of the Boolean functions and operators behave as expected—for example, (<code>true</code> and <code>true</code>) = <code>true</code>, (<code>true</code> and <code>false</code>) = <code>false</code>, and so on.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">When you compare the two values, <code>false</code> is less than <code>true</code>—an intuitive result.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Unfortunately, associating <code>0</code> with <code>false</code> and <code>1</code> with <code>true</code> isn’t always the best solution. Here are some reasons why:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Certain Boolean operations, applied to a bit string, do not produce expected results. For example, you might expect (not <code>false</code>) to be equal to <code>true</code>. However, if you store a Boolean variable in an 8-bit object, then (not <code>false</code>) is equal to <code>$FF</code>, which is not equal to <code>true</code> (<code>1</code>).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Many CPUs provide instructions that easily test for <code>0</code> or nonzero after an operation; few CPUs provide an implicit test for <code>1</code>.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Many languages, such as C, C++, C#, and Java, treat <code>0</code> as <code>false</code> and anything else as <code>true</code>. This has a couple of advantages:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">CPUs that provide easy checks for <code>0</code> and nonzero can easily test a Boolean result.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The <code>0</code>/nonzero representation is valid regardless of the size of the object holding a Boolean variable.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Unfortunately, this scheme also has some drawbacks:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Many bitwise logical operations produce incorrect results when applied to <code>0</code> and nonzero Boolean values. For example <code>$A5</code> (<code>true</code>/nonzero) AND <code>$5A</code> (<code>true</code>/nonzero) is equal to <code>0</code> (<code>false</code>). Logically ANDing <code>true</code> and <code>true</code> should not produce <code>false</code>. Similarly, (NOT <code>$A5</code>) produces <code>$5A</code>. Generally, you’d expect (NOT <code>true</code>) to produce <code>false</code> rather than <code>true</code> (<code>$5A</code>).</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_158"/>&#13;
			<p class="noindent">When a bit string is treated as a two’s-complement signed-integer value, it’s possible for certain values of <code>true</code> to be less than zero (for example, the 8-bit value <code>$FF</code> is equivalent to <code>-1</code>). So, in some cases, the intuitive result that <code>false</code> is less than <code>true</code> may not be correct.</p>&#13;
			</li>&#13;
		</ul>&#13;
		<p class="indent">Unless you are working in assembly language (where you get to define the values for <code>true</code> and <code>false</code>), you’ll have to live with whatever scheme your HLL uses to represent Boolean values, as explained in its language reference manual.</p>&#13;
		<p class="indent">Knowing how your language represents <code>true</code> and <code>false</code> can help you write high-level source code that produces better machine code. For example, suppose you are writing C/C++ code. In these languages, <code>false</code> is <code>0</code> and <code>true</code> is anything else. Consider the following statement in C:</p>&#13;
		<pre class="programs">&#13;
			int i, j, k;<br/>      .<br/>      .<br/>      .<br/>    i = j &amp;&amp; k;</pre>&#13;
		<p class="indent">The machine code produced for this assignment statement by many compilers is absolutely horrid. It often looks like the following (Visual C++ output):</p>&#13;
		<pre class="programs">&#13;
			; Line 8<br/>        cmp     DWORD PTR j$[rsp], 0<br/>        je      SHORT $LN3@main<br/>        cmp     DWORD PTR k$[rsp], 0<br/>        je      SHORT $LN3@main<br/>        mov     DWORD PTR tv74[rsp], 1<br/>        jmp     SHORT $LN4@main<br/>$LN3@main:<br/>        mov     DWORD PTR tv74[rsp], 0<br/>$LN4@main:<br/>        mov     eax, DWORD PTR tv74[rsp]<br/>        mov     DWORD PTR i$[rsp], eax<br/>;</pre>&#13;
		<p class="indent">Now, suppose that you always ensure that you use the values <code>0</code> for <code>false</code> and <code>1</code> for <code>true</code> (with no possibility of any other value). Under these conditions, you could write the previous statement this way:</p>&#13;
		<pre class="programs">i = j &amp; k;  /* Notice the bitwise AND operator */</pre>&#13;
		<p class="indent">Here’s the code that Visual C++ generates for the preceding statement:</p>&#13;
		<pre class="programs">&#13;
			; Line 8<br/>        mov     eax, DWORD PTR k$[rsp]<br/>        mov     ecx, DWORD PTR j$[rsp]<br/>        and     ecx, eax<br/>        mov     DWORD PTR i$[rsp], ecx</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_159"/>As you can see, this code is significantly better. Provided that you always use <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>, you can get away with using the bitwise AND (<code>&amp;</code>) and OR (<code>|</code>) operators in place of the logical operators.<sup><a id="ch6fn_3"/><a href="footnotes.xhtml#ch6fn3">3</a></sup> As noted earlier, you can’t get consistent results using the bitwise NOT operator; you can, however, do the following to produce correct results for a logical NOT operation:</p>&#13;
		<pre class="programs">i = ~j &amp; 1; /* "~" is C's bitwise not operator */</pre>&#13;
		<p class="indent">This short sequence inverts all the bits in <code>j</code> and then clears all bits except bit 0.</p>&#13;
		<p class="indent">The bottom line is that you should be intimately aware of how your particular compiler represents Boolean constants. If you’re given a choice (such as any nonzero value), then you can pick appropriate values for <code>true</code> and <code>false</code> to help your compiler emit better code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec58"><strong>6.9 Floating-Point Constants</strong></h3>&#13;
		<p class="noindent">Floating-point constants are special cases on most computer architectures. Because floating-point representations can consume a large number of bits, few CPUs provide an immediate addressing mode to load an arbitrary constant into a floating-point register. This is true even for small (32-bit) floating-point constants. It is even true on many CISC processors such as the 80x86. Therefore, compilers often have to place floating-point constants in memory and then have the program read them from memory, just as though they were variables. Consider, for example, the following C program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv, char **envp )<br/>{<br/>  static int j;<br/>  static double i = 1.0;<br/>  static double a[8] = {0,1,2,3,4,5,6,7};<br/>  j = 0;<br/>  a[j] = i+1.0;<br/><br/><br/>}</pre>&#13;
		<p class="indent">Now consider the PowerPC code that GCC generates for this program with the <code>-O2</code> option:</p>&#13;
		<pre class="programs">&#13;
			.lcomm _j.0,4,2<br/>.data<br/><span epub:type="pagebreak" id="page_160"/>// This is the variable i.<br/>// As it is a static object, GCC emits the data directly<br/>// for the variable in memory. Note that "1072693248" is<br/>// the HO 32-bits of the double-precision floating-point<br/>// value 1.0, 0 is the LO 32-bits of this value (in integer<br/>// form).<br/><br/>    .align 3<br/>_i.1:<br/>    .long       1072693248<br/>    .long       0<br/><br/>// Here is the "a" array. Each pair of double words below<br/>// holds one element of the array. The funny integer values<br/>// are the integer (bitwise) representation of the values<br/>// 0.0, 1.0, 2.0, 3.0, ..., 7.0.<br/><br/>    .align 3<br/>_a.2:<br/>    .long       0<br/>    .long       0<br/>    .long       1072693248<br/>    .long       0<br/>    .long       1073741824<br/>    .long       0<br/>    .long       1074266112<br/>    .long       0<br/>    .long       1074790400<br/>    .long       0<br/>    .long       1075052544<br/>    .long       0<br/>    .long       1075314688<br/>    .long       0<br/>    .long       1075576832<br/>    .long       0<br/><br/>// The following is a memory location that GCC uses to represent<br/>// the literal constant 1.0. Note that these 64 bits match the<br/>// same value as a[1] in the _a.2 array. GCC uses this memory<br/>// location whenever it needs the constant 1.0 in the program.<br/><br/>.literal8<br/>    .align 3<br/>LC0:<br/>    .long       1072693248<br/>    .long       0<br/><br/>// Here's the start of the main program:<br/><br/>.text<br/>    .align 2<br/>    .globl _main<br/>_main:<br/><br/><span epub:type="pagebreak" id="page_161"/>// This code sets up the static pointer register (R10), used to<br/>// access the static variables in this program.<br/><br/>    mflr r0<br/>    bcl 20,31,L1$pb<br/>L1$pb:<br/>    mflr r10<br/>    mtlr r0<br/><br/>    // Load floating-point register F13 with the value<br/>    // in variable "i":<br/><br/>    addis r9,r10,ha16(_i.1-L1$pb)  // Point R9 at i<br/>    li r0,0<br/>    lfd f13,lo16(_i.1-L1$pb)(r9)   // Load F13 with i's value.<br/><br/>    // Load floating-point register F0 with the constant 1.0<br/>    // (which is held in "variable" LC0:<br/><br/>    addis r9,r10,ha16(LC0-L1$pb)   // Load R9 with the<br/>                                   //  address of LC0<br/>    lfd f0,lo16(LC0-L1$pb)(r9)     // Load F0 with the value<br/>                                   //  of LC0 (1.0).<br/><br/>    addis r9,r10,ha16(_j.0-L1$pb)  // Load R9 with j's address<br/>    stw r0,lo16(_j.0-L1$pb)(r9)    // Store a zero into j.<br/><br/>    addis r9,r10,ha16(_a.2-L1$pb)  // Load a[j]'s address into R9<br/><br/>    fadd f13,f13,f0                // Compute i+1.0<br/><br/>    stfd f13,lo16(_a.2-L1$pb)(r9)  // Store sum into a[j]<br/>    blr                            // Return to caller</pre>&#13;
		<p class="indent">Because the PowerPC processor is a RISC CPU, the code that GCC generates for this simple sequence is rather convoluted. For comparison with a CISC equivalent, consider the following HLA code for the 80x86; it is a line-by-line translation of the C code:</p>&#13;
		<pre class="programs">&#13;
			program main;<br/>static<br/>    j:int32;<br/>    i:real64 := 1.0;<br/>    a:real64[8] := [0,1,2,3,4,5,6,7];<br/><br/>readonly<br/>    OnePointZero : real64 := 1.0;<br/><br/>begin main;<br/><br/>    mov( 0, j );  // j=0;<br/><br/>    // push i onto the floating-point stack<br/><span epub:type="pagebreak" id="page_162"/><br/>    fld( i );<br/><br/>    // push the value 1.0 onto the floating-point stack<br/><br/>    fld( OnePointZero );<br/><br/>    // pop i and 1.0, add them, push sum onto the FP stack<br/><br/>    fadd();<br/><br/>    // use j as an index<br/><br/>    mov( j, ebx );<br/><br/>    // Pop item off FP stack and store into a[j].<br/><br/>    fstp( a[ ebx*8 ] );<br/><br/>end main;</pre>&#13;
		<p class="indent">This code is much easier to follow than the PowerPC code (this is one advantage of CISC code over RISC code). Note that like the PowerPC, the 80x86 does not support an immediate addressing mode for most floating-point operands. Therefore, as on the PowerPC, you have to place a copy of the constant <code>1.0</code> in some memory location and access that memory location whenever you want to work with the value <code>1.0</code>.<sup><a id="ch6fn_4"/><a href="footnotes.xhtml#ch6fn4">4</a></sup></p>&#13;
		<p class="indent">Because most modern CPUs do not support an immediate addressing mode for all floating-point constants, using such constants in your programs is equivalent to accessing variables initialized with those constants. Don’t forget that accessing memory can be very slow if the locations you’re referencing are not in the data cache. Accordingly, using floating-point constants can be very slow compared with accessing integer or other constant values that fit within a register.</p>&#13;
		<p class="indent">Note that some CPUs do allow you to encode certain floating-point immediate constants as part of the instruction’s opcode. The 80x86, for example, has a special “load zero” instruction that loads <code>0.0</code> onto the floating-point stack. The ARM processor also provides an instruction that allows you to load certain floating-point constants into a CPU floating-point register (see “The <code>vmov</code> Instructions” in Appendix C online).</p>&#13;
		<p class="indent">On 32-bit processors, a CPU can often do simple 32-bit floating-point operations using integer registers and the immediate addressing mode. For example, you can easily assign a 32-bit single-precision floating-point value to a variable by loading a 32-bit integer register with the bit pattern for that <span epub:type="pagebreak" id="page_163"/>number and then storing the integer register into the floating-point variable. Consider the following code:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>int main( int argc, char **argv, char **envp )<br/>{<br/><br/>  static float i;<br/><br/>  i = 1.0;<br/><br/><br/>}</pre>&#13;
		<p class="indent">Here’s the PowerPC code that GCC generates for this sequence:</p>&#13;
		<pre class="programs">&#13;
			.lcomm _i.0,4,2 // Allocate storage for float variable i<br/><br/>.text<br/>    .align 2<br/>    .globl _main<br/>_main:<br/><br/>    // Set up the static data pointer in R10:<br/><br/>    mflr r0<br/>    bcl 20,31,L1$pb<br/>L1$pb:<br/>    mflr r10<br/>    mtlr r0<br/><br/>    // Load the address of i into R9:<br/><br/>    addis r9,r10,ha16(_i.0-L1$pb)<br/><br/>    // Load R0 with the floating-point representation of 1.0<br/>    // (note that 1.0 is equal to 0x3f800000):<br/><br/>    lis r0,0x3f80 // Puts 0x3f80 in HO 16 bits, 0 in LO bits<br/><br/>    // Store 1.0 into variable i:<br/><br/>    stw r0,lo16(_i.0-L1$pb)(r9)<br/><br/>    // Return to whomever called this code:<br/><br/>    blr</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_164"/>The 80x86, being a CISC processor, makes this task trivial in assembly language. Here’s the HLA code that does the same job:</p>&#13;
		<pre class="programs">&#13;
			program main;<br/>static<br/>    i:real32;<br/>begin main;<br/><br/>    mov( $3f800_0000, i ); // i = 1.0;<br/><br/>end main;</pre>&#13;
		<p class="indent">Simple assignments of single-precision floating-point constants to floating-point variables can often use a CPU’s immediate addressing mode, sparing the program the expense of accessing memory (whose data might not be in the cache). Unfortunately, compilers don’t always take advantage of this trick for assigning a floating-point constant to a double-precision variable. GCC on the PowerPC or ARM, for example, reverts to keeping a copy of the constant in memory and copying that memory location’s value when assigning the constant to a floating-point variable.</p>&#13;
		<p class="indent">Most optimizing compilers are smart enough to maintain a table of constants they’ve created in memory. Therefore, if you reference the constant <code>2.0</code> (or any other floating-point constant) multiple times in your source file, the compiler will allocate only one memory object for that constant. Keep in mind, however, that this optimization works only within the same source file. If you reference the same constant value but in different source files, the compiler will probably create multiple copies of that constant.</p>&#13;
		<p class="indent">It’s certainly true that having multiple copies of the data wastes storage, but given the amount of memory in most modern systems, that’s a minor concern. A bigger problem is that the program usually accesses these constants in a random fashion, so they’re rarely sitting in cache and, in fact, they often evict some other more frequently used data from cache.</p>&#13;
		<p class="indent">One solution to this problem is to manage the floating-point “constants” yourself. Because these constants are effectively variables as far as the program is concerned, you can take charge of this process and place the floating-point constants you’ll need in initialized static variables. For example:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>static double OnePointZero_c = 1.0;<br/><br/>int main( int argc, char **argv, char **envp )<br/>{<br/>  static double i;<br/><br/>  i = OnePointZero_c;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_165"/>In this example, of course you gain absolutely nothing by treating the floating-point constants as static variables. However, in more complex situations where you have several floating-point constants, you can analyze your program to determine which constants you access often and place the variables for those constants at adjacent memory locations. Because of the way most CPUs handle spatial locality of reference (see <em>WGC1</em>), when you access one of these constant objects, the cache line will be filled with the values of the adjacent objects as well. Therefore, when you access those other objects within a short period of time, it’s likely that their values will be in the cache. Another advantage to managing these constants yourself is that you can create a global set of constants that you can reference from different compilation units (source files), so the program accesses only a single memory object for a given constant rather the multiple memory objects (one for each compilation unit). Compilers generally aren’t smart enough to make decisions like this concerning your data.</p>&#13;
		<h3 class="h3" id="ch00lev1sec59"><strong>6.10 String Constants</strong></h3>&#13;
		<p class="noindent">Like floating-point constants, string constants cannot be processed efficiently by most compilers (even if they are literal or manifest constants). Understanding when you should use manifest constants and when you should replace them with memory references can help you guide the compiler to produce better machine code. For example, most CPUs are not capable of encoding a string constant as part of an instruction. Using a manifest string constant may actually make your program less efficient. Consider the following C code:</p>&#13;
		<pre class="programs">&#13;
			#define strConst "A string constant"<br/>        .<br/>        .<br/>        .<br/>    printf( "string: %s\n", strConst );<br/>        .<br/>        .<br/>        .<br/>    sptr = strConst;<br/>        .<br/>        .<br/>        .<br/>    result = strcmp( s, strConst );<br/>        .<br/>        .<br/>        .</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_166"/>The compiler (actually, the C preprocessor) expands the macro <code>strConst</code> to the string literal <code>"A string constant"</code> everywhere the identifier <code>strConst</code> appears in the source file, so this code is actually equivalent to:</p>&#13;
		<pre class="programs">&#13;
			    .<br/>    .<br/>    .<br/>printf( "string: %s\n", "A string constant" );<br/>    .<br/>    .<br/>    .<br/>sptr = "A string constant";<br/>    .<br/>    .<br/>    .<br/>result = strcmp( s, "A string constant" );</pre>&#13;
		<p class="indent">The problem with this code is that the same string constant appears at different places throughout the program. In C/C++, the compiler places the string constant in memory and substitutes a pointer to the string. A nonoptimizing compiler might wind up making three separate copies of the string in memory, which wastes space because the data is exactly the same in all three cases. (Remember that we’re talking about <em>constant</em> strings here.)</p>&#13;
		<p class="indent">Compiler writers discovered this problem a few decades ago and modified their compilers to keep track of the strings in a given source file. If a program used the same string literal two or more times, the compiler wouldn’t allocate storage for a second copy of the string. Instead, it would simply use the address of the earlier string. This optimization (constant folding) could reduce the size of the code if the same string appeared throughout a source file.</p>&#13;
		<p class="indent">Unfortunately, constant folding doesn’t always work properly. One problem is that many older C programs assign a string literal constant to a character pointer variable and then proceed to change the characters in that literal string. For example:</p>&#13;
		<pre class="programs">&#13;
			sptr = "A String Constant";<br/>    .<br/>    .<br/>    .<br/>*(sptr+2) = 's';<br/>    .<br/>    .<br/>    .<br/>/* The following displays "string: 'a string Constant'" */<br/><br/>printf( "string: '%s'\n", sptr );<br/>    .<br/>    .<br/>    .<br/>/* This prints "a string Constant"! */<br/><br/>printf( "A String Constant" );</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_167"/>Compilers that reuse the same string constant fail if the user stores data into the string object, as this code demonstrates. Although this is bad programming practice, it occurred frequently enough in older C programs that compiler vendors couldn’t use the same storage for multiple copies of the same string literal. Even if the compiler vendor were to place the string literal constant into write-protected memory to prevent this problem, there are other semantic issues that this optimization raises. Consider the following C/C++ code:</p>&#13;
		<pre class="programs">&#13;
			sptr1 = "A String Constant";<br/>sptr2 = "A String Constant";<br/>s1EQs2 = sptr1 == sptr2;</pre>&#13;
		<p class="indent">Will <code>s1EQs2</code> contain <code>true</code> (<code>1</code>) or <code>false</code> (<code>0</code>) after executing this instruction sequence? In programs written before C compilers had good optimizers available, this sequence of statements would leave <code>false</code> in <code>s1EQs2</code>. This was because the compiler created two different copies of the same string data and placed those strings at different addresses in memory (so the addresses the program assigns to <code>sptr1</code> and <code>sptr2</code> would be different). In a later compiler that kept only a single copy of the string data in memory, this code sequence would leave <code>true</code> sitting in <code>s1EQs2</code> because both <code>sptr1</code> and <code>sptr2</code> would be pointing at the same memory address. This difference exists regardless of whether or not the string data appears in write-protected memory.</p>&#13;
		<p class="indent">To solve this dilemma, many compiler vendors provide a compiler option to enable programmers to determine whether the compiler should emit a single copy of each string or one copy for each occurrence of the string. If you don’t write data into string literal constants or compare their addresses, you can select this option to reduce the size of your programs. If you have old code that requires separate copies of the string data (hopefully, you won’t write new code that requires this), you can enable this option.</p>&#13;
		<p class="indent">Unfortunately, many programmers are completely unaware of this option, and the default condition on some compilers is generally to make multiple copies of the string data. If you’re using C/C++ or some other language that manipulates strings via pointers to the character data, investigate whether the compiler provides an option to merge identical strings and, if so, activate that feature in your compiler.</p>&#13;
		<p class="indent">If your C/C++ compiler does not offer this string-merging optimization, you can implement it manually. To do so, just create a <code>char</code> array variable in your program and initialize it with the address of the string. Then use the name of that array variable exactly as you would a manifest constant throughout your program. For example:</p>&#13;
		<pre class="programs">&#13;
			char strconst[] = "A String Constant";<br/>        .<br/>        .<br/>        .<br/>    sptr = strconst;<br/>        .<br/>        .<br/><span epub:type="pagebreak" id="page_168"/>        .<br/>    printf( strconst );<br/>        .<br/>        .<br/>        .<br/>    if( strcmp( string, strconst ) == 0 )<br/>    {<br/>        .<br/>        .<br/>        .<br/>    }</pre>&#13;
		<p class="indent">This code will maintain only a single copy of the string literal constant in memory, even if the compiler doesn’t directly support the optimization. Actually, even if your compiler does directly support this optimization, there are several good reasons why you should use this trick rather than relying on your compiler to do the work for you.</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">In the future you might have to port your code to a different compiler that doesn’t support this optimization.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">By handling the optimization manually, you don’t have to worry about it.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">By using a pointer variable rather than a string literal constant, you have the option of easily changing the string whose address this pointer contains under program control.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">In the future you might want to modify the program to switch (natural) languages under program control.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You can easily share the string between multiple files.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">This string optimization discussion assumes that your programming language manipulates strings by reference (that is, by using a pointer to the actual string data). Although this is certainly true for C/C++ programs, it is not true of all languages. Pascal implementations that support strings (such as Free Pascal) typically manipulate them by value rather than by reference. Any time you assign a string value to a string variable, the compiler makes a copy of the string data and places that copy in the storage reserved for the string variable. This copying process can be expensive and is unnecessary if your program never changes the data in the string variable. Worse still, if the (Pascal) program assigns a string literal to a string variable, the program will have two copies of the string floating around (the string literal constant in memory and the copy that the program made for the string variable). If the program never again changes the string (which is not at all uncommon), it will waste memory by maintaining two copies of the string when one would suffice. These reasons (space and speed) are probably why Borland went to a much more sophisticated string format when they created Delphi 4.0, abandoning the string format in earlier versions of Delphi.<sup><a id="ch6fn_5"/><a href="footnotes.xhtml#ch6fn5">5</a></sup></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_169"/>Swift also treats strings as value objects. This means that, in the worst case, it will make a copy of a string literal whenever you assign that string literal to a string variable. However, Swift implements an optimization known as <em>copy-on-write</em>. Whenever you assign one string object to another, Swift just copies a pointer. Therefore, if multiple strings have been assigned the same value, Swift will use the same string data in memory for all the copies. When you modify some portion of the string, Swift will make a copy of the string prior to the modification (hence the name “copy-on-write”) so that other string objects referencing the original string data are not affected by the change.</p>&#13;
		<h3 class="h3" id="ch00lev1sec60"><strong>6.11 Composite Data Type Constants</strong></h3>&#13;
		<p class="noindent">Many languages support other composite constant types (such as arrays, structures/records, and sets) in addition to strings. Usually, the languages use these constants to statically initialize variables prior to the program’s execution. For example, consider the following C/C++ code:</p>&#13;
		<pre class="programs">static int arrayOfInts[8] = {1,2,3,4,5,6,7,8};</pre>&#13;
		<p class="indent">Note that <code>arrayOfInts</code> is not a constant. Rather, it is the initializer that constitutes the array constant—that is, <code>{1,2,3,4,5,6,7,8}</code>. In the executable file, most C compilers simply overlay the eight integers at the address associated with <code>arrayOfInts</code> with these eight numeric values.</p>&#13;
		<p class="indent">For example, here’s what GCC emits for this variable:</p>&#13;
		<pre class="programs">&#13;
			LC0:          // LC0 is the internal label associated<br/>              //  with arrayOfInts<br/>    .long       1<br/>    .long       2<br/>    .long       3<br/>    .long       4<br/>    .long       5<br/>    .long       6<br/>    .long       7<br/>    .long       8</pre>&#13;
		<p class="indent">There is no extra space consumed to hold the constant data, assuming that <code>arrayOfInts</code> is a static object in C.</p>&#13;
		<p class="indent">The rules change, however, if the variable you’re initializing is not a statically allocated object. Consider the following short C sequence:</p>&#13;
		<pre class="programs">&#13;
			int f()<br/>{<br/>  int arrayOfInts[8] = {1,2,3,4,5,6,7,8};<br/>    .<br/>    .<br/>    .<br/>} // end f</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_170"/>In this example, <code>arrayOfInts</code> is an <em>automatic</em> variable, meaning that the program allocates storage on the stack for the variable each time the program calls function <code>f()</code>. For this reason, the compiler cannot simply initialize the array with the constant data when the program loads into memory. The <code>arrayOfInts</code> object could actually lie at a different address on each activation of the function. To obey the semantics of the C programming language, the compiler will have to make a copy of the array constant and then physically copy that constant data into the <code>arrayOfInts</code> variable whenever the program calls the function. Using an array constant this way consumes extra space (to hold a copy of the array constant) and extra time (to copy the data). Sometimes the semantics of your algorithm requires a fresh copy of the data upon each new activation of the function <code>f()</code>. However, you need to recognize when this is necessary (and when the extra space and time are warranted) rather than blowing memory and CPU cycles.</p>&#13;
		<p class="indent">If your program doesn’t modify the array’s data, you can use a static object that the compiler can initialize once when it loads the program into memory:</p>&#13;
		<pre class="programs">&#13;
			int f()<br/>{<br/>  static int arrayOfInts[8] = {1,2,3,4,5,6,7,8};<br/>    .<br/>    .<br/>    .<br/>} // end f</pre>&#13;
		<p class="indent">The C/C++ languages also support struct constants. The same space and speed considerations we’ve seen for arrays when initializing automatic variables also apply to struct constants.</p>&#13;
		<p class="indent">Embarcadero’s Delphi programming language also supports structured constants, though the term “constant” is a bit misleading here. Embarcadero calls them <em>typed constants</em>, and you declare them in the Delphi <code>const</code> section like this:</p>&#13;
		<pre class="programs">&#13;
			const<br/>    ary: array[0..7] of integer = (1,2,3,4,5,6,7,8);</pre>&#13;
		<p class="indent">Although the declaration appears in a Delphi <code>const</code> section, Delphi actually treats it as a variable declaration. It’s an unfortunate design choice, but for a programmer who wants to create structured constants, this mechanism works fine. As with the C/C++ examples in this section, it’s important to remember that the constant in this example is actually the <code>(1,2,3,4,5,6,7,8)</code> object, not the <code>ary</code> variable.</p>&#13;
		<p class="indent">Delphi (along with most modern Pascals, such as Free Pascal) supports several other composite constant types as well. Set constants are good examples. Whenever you create a set of objects, the Pascal compiler generally initializes some memory location with a powerset (bitmap) representation of the set’s data. Wherever you refer to that set constant in your program, the Pascal compiler generates a memory reference to the set’s constant data in memory.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_171"/>Swift also supports composite data type constants for arrays, tuples, dictionaries, structs/classes, and other data types. For example, the following <code>let</code> statement creates an array constant with eight elements:</p>&#13;
		<pre class="programs">&#13;
			let <span class="codeitalic1">someArray</span> = [1,2,3,4,11,12,13,14]</pre>&#13;
		<h3 class="h3" id="ch00lev1sec61"><strong>6.12 Constants Don’t Change</strong></h3>&#13;
		<p class="noindent">In theory, values bound to a constant don’t change (Swift’s <code>let</code> statement being the obvious exception). In modern systems, compilers that place constants in memory often put them in write-protected memory regions to force an exception if an inadvertent write occurs. Of course, few programs can be written using only read-only (or write-once) objects. Most programs require the ability to change the values of objects (<em>variables</em>) they manipulate. That is the subject of the next chapter.</p>&#13;
		<h3 class="h3" id="ch00lev1sec62"><strong>6.13 For More Information</strong></h3>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">———. <em>Write Great Code, Volume 1: Understanding the Machine</em>. 2nd ed. San Francisco: No Starch Press, 2020.<span epub:type="pagebreak" id="page_172"/></p>&#13;
	</body></html>