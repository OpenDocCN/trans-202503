<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="intro"><span epub:type="pagebreak" id="page_xxv"/>INTRODUCTION</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">One of the best ways to learn something is to teach it. It is invaluable to have a person who is willing to listen to what we say, to read what we write, and to respond. Knowing that someone is listening or reading encourages us to spend time and effort creating something of quality. And if our writing incites a response, so much the better, for we have started a conversation that might challenge us to sharpen our understanding.</p>&#13;
<p class="indent">A pleasant and productive way to learn physics is to teach a computer how to do it. We admit up front that the computer is not as rich a listener as a person and cannot provide the depth or breadth of response to our writing that a person can. On the other hand, the computer is very attentive, willing to listen incessantly, and unwilling to accept statements unless they are expressed in clear language and make sense. The computer can provide us with a useful response because it will happily calculate what we ask it to calculate, and it will quickly tell us if what we just said makes no sense (and hopefully give us a clue about why it makes no sense).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxvi"/>This book is about learning basic theoretical physics by teaching a computer how to do it. We will spend a substantial amount of time with Newton’s second law. We will focus on the concept of the <em>state</em> of a physical system and see that Newton’s second law is the core rule for describing how the state changes in time. We will study basic electromagnetic theory, asking the computer to calculate electric and magnetic fields produced by charge and current distributions. The point is to deepen our understanding of physics by approaching it from a new angle, with a new language. The language we will use is precise and will help to clarify our thinking.</p>&#13;
<h3 class="h3" id="introlev1">Who This Book Is For</h3>&#13;
<p class="noindent">This book arises from a course in computational physics I teach to second-year students of physics at Lebanon Valley College. I expect that you have had one year of introductory physics and at least one semester of calculus. No previous programming experience is required. The purpose of the book is to deepen your understanding of basic physics by exploring it in a new language. By using a formal language to express the ideas of physics, we will stretch our ability to formulate and communicate the ideas of physics as we also calculate quantities we are interested in and make graphs and animations.</p>&#13;
<p class="indent">Because the book begins with a self-contained introduction to the Haskell programming language for people who have not programmed before, it can be used as a supplement for introductory and intermediate courses in physics in which the instructor or student</p>&#13;
<ul class="bull">&#13;
<li class="noindent">wishes to include a computational component, or</li>&#13;
<li class="noindent">desires a deeper understanding of the structure of basic physical theories.</li>&#13;
</ul>&#13;
<p class="indentt">The book is also appropriate for self-study by any student who wishes to deepen their understanding of physics by programming.</p>&#13;
<h3 class="h3" id="introlev2">Why Functional Programming, and Why Haskell?</h3>&#13;
<p class="noindent">Many scientists, after learning their second programming language, develop the idea that all programming languages are more or less the same and that the difference between languages is mainly one of syntax. Scientists are busy people, and they have their work to do, so perhaps they can be excused for choosing not to dive into the sea of available programming languages to learn the more complex truth that languages can differ on a semantic level and can have profound effects on the way a person thinks about the problem they are writing code to solve. The style of programming called <em>functional programming</em> grows from a different branch of the programming language tree than object-oriented programming, and the two do not mix well together. Neither is clearly better for all applications.</p>&#13;
<p class="indent">Physics can be encoded in any programming language. Why use a functional language instead of a more mainstream object-oriented language? <span epub:type="pagebreak" id="page_xxvii"/>Beauty and power are to be found more in verbs than in nouns. Newton found beauty and power not in the world per se, but in the description of how the world changes. Functional programming found beauty and power not in objects but in the functions that take objects as input and produce objects as output, and in the notion that such objects might themselves be functions. Haskell is a good programming language for learning physics for two reasons. First, Haskell is a functional programming language. This means that functions play a central role in the language, including functions that take other functions as arguments and return functions as results. Many physical ideas are naturally expressed in the language of higher-order functions. Second, Haskell’s type system provides a clean way to organize our thinking about the physical quantities and procedures of interest in physics. I know of no better way to clarify my thinking than expressing my ideas in functional language.</p>&#13;
<h3 class="h3" id="introlev3">About This Book</h3>&#13;
<p class="noindent">This book is composed of three parts. The first part is an introduction to functional programming in general and Haskell in particular, aimed at people who have never programmed before. The second part shows how to use a functional language to express Newton’s second law, and consequently to solve mechanics problems. The third part aims at electromagnetic theory, showing how Faraday and Maxwell’s ideas can be expressed in functional language, and how problems that involve electric and magnetic fields can be solved. Throughout, we’ll see how functional language is close to mathematics; how it’s really a form of mathematics that computers can understand. Many of the deep ideas of physics that are so eloquently and succinctly expressed in mathematical language find beautiful expression in functional language as well.</p>&#13;
<p class="indent">The book includes the following elements:</p>&#13;
<p class="noindentt"><strong><a href="part01.xhtml">Part I: The Haskell Language</a></strong></p>&#13;
<p class="noindente"><strong><a href="ch01.xhtml">Chapter 1: Calculating with Haskell</a></strong> This chapter is all about how to use Haskell as a calculator. Basic mathematical operations are built into Haskell, and these are immediately available to do calculations.</p>&#13;
<p class="noindente"><strong><a href="ch02.xhtml">Chapter 2: Writing Basic Functions</a></strong> Here we begin writing functions. Haskell functions are very much like mathematical functions. The simplest Haskell functions take a number as input and produce a number as output. As you might guess, functions play a central role in functional programming languages.</p>&#13;
<p class="noindente"><strong><a href="ch03.xhtml">Chapter 3: Types and Entities</a></strong> This chapter introduces the idea of types. The entities, such as numbers and functions, with which Haskell deals are classified into types; every entity has a type. Types guide our thinking about what can be done with an entity. Real numbers can be squared, for example, but it doesn’t always make sense to square a function.</p>&#13;
<p class="noindente"><span epub:type="pagebreak" id="page_xxviii"/><strong><a href="ch04.xhtml">Chapter 4: Describing Motion</a></strong> Here we look at how the motion of a particle in one dimension is described in Haskell. We introduce position, velocity, and acceleration, and we notice how these quantities are related by the notion of a derivative from calculus.</p>&#13;
<p class="noindente"><strong><a href="ch05.xhtml">Chapter 5: Working with Lists</a></strong> This chapter discusses lists in Haskell. Lists can be lists of numbers, lists of functions, or lists of more complicated things. After functions, lists are probably the most important structures in functional programming because they are used in the process of iteration (doing something over and over again).</p>&#13;
<p class="noindente"><strong><a href="ch06.xhtml">Chapter 6: Higher-Order Functions</a></strong> This chapter introduces higher-order functions, which are functions that take other functions as input or produce functions as output. Higher-order functions are central to the power and concision of functional languages. We give examples of how higher-order functions naturally appear in physics.</p>&#13;
<p class="noindente"><strong><a href="ch07.xhtml">Chapter 7: Graphing Functions</a></strong> This chapter shows how to graph a function such as the cosine function or a function that you define that takes numbers as input and produces numbers as output.</p>&#13;
<p class="noindente"><strong><a href="ch08.xhtml">Chapter 8: Type Classes</a></strong> Here we introduce type classes in Haskell. Type classes own functions that need to be able to work with some, but not all, types. Equality checking is such a function. We want to be able to check equality of numbers, equality of lists, and equality of other things. The equality checking function is owned by a type class.</p>&#13;
<p class="noindente"><strong><a href="ch09.xhtml">Chapter 9: Tuples and Type Constructors</a></strong> This chapter introduces tuples, a structure that holds two or more objects. This chapter also discusses type constructors, which are functions at the type level (in other words, functions that take a type as input and produce a type as output).</p>&#13;
<p class="noindente"><strong><a href="ch10.xhtml">Chapter 10: Describing Motion in Three Dimensions</a></strong> This chapter is similar in outlook to <a href="ch04.xhtml">Chapter 4</a> in that it focuses on a particular need that physics has (in this case, a need for vectors) and shows how that need is satisfied in the Haskell language.</p>&#13;
<p class="noindente"><strong><a href="ch11.xhtml">Chapter 11: Creating Graphs</a></strong> Here we return to the topic of making graphs, first broached in <a href="ch07.xhtml">Chapter 7</a>, and include more detail about how to make pleasing and informative graphs.</p>&#13;
<p class="noindente"><strong><a href="ch12.xhtml">Chapter 12: Creating Stand-Alone Programs</a></strong> In the beginning of the book, we interact with Haskell primarily through the GHCi interactive compiler. Later in the book, when we start doing animation, we make stand-alone programs. This chapter shows several ways to produce stand-alone programs.</p>&#13;
<p class="noindente"><strong><a href="ch13.xhtml">Chapter 13: Creating 2D and 3D Animations</a></strong> This chapter introduces animation, showing how to make simple 2D and 3D animations.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_xxix"/><strong><a href="part02.xhtml">Part II: Newtonian Mechanics</a></strong></p>&#13;
<p class="noindente"><strong><a href="ch14.xhtml">Chapter 14: Newton’s Second Law and Differential Equations</a></strong> Here we introduce Newton’s first and second laws. We learn how to solve a limited class of mechanics problems in one spatial dimension. We also learn why some mechanics problems are easy to solve and others are difficult. It comes down to what the forces depend on. This chapter covers situations of increasing complexity, starting with constant forces and ending with forces that depend on time and the particle’s velocity. This chapter introduces the concept of differential equations, and we write code capable of solving a first-order differential equation.</p>&#13;
<p class="noindente"><strong><a href="ch15.xhtml">Chapter 15: Mechanics in One Dimension</a></strong> This chapter continues the path of increasing complexity, looking at forces that depend on time, position, and velocity. Such situations lead to a second-order differential equation, which we solve by introducing state variables.</p>&#13;
<p class="noindente"><strong><a href="ch16.xhtml">Chapter 16: Mechanics in Three Dimensions</a></strong> Here we return to the vector setting first seen in <a href="ch10.xhtml">Chapter 10</a>, completing the theory of the mechanics of a single object. We show how to express and solve Newton’s second law for a single particle in three dimensions.</p>&#13;
<p class="noindente"><strong><a href="ch17.xhtml">Chapter 17: Satellite, Projectile, and Proton Motion</a></strong> This chapter gives three extended examples, applying the ideas and tools developed in the previous chapter.</p>&#13;
<p class="noindente"><strong><a href="ch18.xhtml">Chapter 18: A Very Short Primer on Relativity</a></strong> This chapter shows what mechanics looks like if we embrace the ideas of special relativity in favor of those of Newton. We see that many of our tools survive the transition, enabling us to solve problems in relativity.</p>&#13;
<p class="noindente"><strong><a href="ch19.xhtml">Chapter 19: Interacting Particles</a></strong> This chapter introduces Newton’s third law, which is needed when we care about more than one object. We develop a theory of interacting particles and express the key ideas in Haskell.</p>&#13;
<p class="noindente"><strong><a href="ch20.xhtml">Chapter 20: Springs, Billiard Balls, and a Guitar String</a></strong> This chapter gives three extended examples of interacting particles in which we use the ideas and tools of <a href="ch19.xhtml">Chapter 19</a>. Having dealt with the mechanics of arbitrarily many interacting particles in three dimensions, our treatment of Newtonian mechanics is complete.</p>&#13;
<p class="noindentt"><strong><a href="part03.xhtml">Part III: Electromagnetic Theory</a></strong></p>&#13;
<p class="noindente"><strong><a href="ch21.xhtml">Chapter 21: Electricity</a></strong> This chapter looks at the old electric theory of Coulomb, in which electricity is simply a force on charged particles produced by other charged particles, similar in spirit to Newtonian gravity. Coulomb’s electricity does not use the electric field.</p>&#13;
<p class="noindente"><span epub:type="pagebreak" id="page_xxx"/><strong><a href="ch22.xhtml">Chapter 22: Coordinate Systems and Fields</a></strong> Here we introduce the key idea of a field, which is a function of space—a quantity that can have a different value at each position in space. This chapter also introduces Cartesian, cylindrical, and spherical coordinates for three-dimensional space.</p>&#13;
<p class="noindente"><strong><a href="ch23.xhtml">Chapter 23: Curves, Surfaces, and Volumes</a></strong> This chapter discusses how we can describe curves, surfaces, and volumes in the Haskell language.</p>&#13;
<p class="noindente"><strong><a href="ch24.xhtml">Chapter 24: Electric Charge</a></strong> This chapter covers electric charge, the quantity responsible for electrical phenomena, and the different kinds of charge distributions.</p>&#13;
<p class="noindente"><strong><a href="ch25.xhtml">Chapter 25: Electric Field</a></strong> This chapter describes how electric charge produces an electric field, beginning our study of modern Faraday-Maxwell electromagnetic theory in which electric and magnetic fields play such a crucial role.</p>&#13;
<p class="noindente"><strong><a href="ch26.xhtml">Chapter 26: Electric Current</a></strong> This chapter discusses electric current and current distributions, paralleling the discussion of charge in <a href="ch24.xhtml">Chapter 24</a>.</p>&#13;
<p class="noindente"><strong><a href="ch27.xhtml">Chapter 27: Magnetic Field</a></strong> This chapter describes how current produces a magnetic field, paralleling <a href="ch25.xhtml">Chapter 25</a> in that charge is to electric field as current is to magnetic field, at least in static situations.</p>&#13;
<p class="noindente"><strong><a href="ch28.xhtml">Chapter 28: The Lorentz Force Law</a></strong> While <a href="ch24.xhtml">Chapters 24</a> through <a href="ch27.xhtml">27</a> deal with the aspect of electromagnetic theory in which charge creates fields, this chapter discusses the second aspect of electromagnetic theory, in which fields exert forces on charge. The Lorentz force law describes this second aspect.</p>&#13;
<p class="noindente"><strong><a href="ch29.xhtml">Chapter 29: The Maxwell Equations</a></strong> This chapter presents the Maxwell equations, in which the first aspect of electromagnetic theory reaches its full sophistication, and we see how electric and magnetic fields are dynamic quantities, interacting and changing in time. Although there are many situations and applications we won’t discuss, the Maxwell equations and the Lorentz force law give a complete description of modern electromagnetic theory—a theory important not just for explaining electricity, magnetism, and light, but also for serving as the prototype for present-day theories of elementary particle physics.</p>&#13;
<p class="noindente"><strong><a href="app.xhtml">Appendix: Installing Haskell</a></strong> This appendix shows how to install the Haskell compiler and software libraries we will use.</p>&#13;
<p class="indentta">This book has been a labor of love, meaning that my motivation for writing it comes from a love of the ideas presented and a desire to share them. I hope that I have created a beautiful book, but even more than that, I hope that this book helps you to express beautiful ideas with beautiful code. Enjoy!</p>&#13;
</div></body></html>