- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**The Cryptography Behind Bitcoin**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特币背后的加密技术**'
- en: Bitcoin relies on cryptography to function, which is why it is sometimes called
    a *cryptocurrency*.^([1](../Text/footnote.html#footnote41)) But what role does
    cryptography play in Bitcoin, and why is it needed? We’ll begin with a short introduction
    to some necessary cryptography concepts (if they are familiar to you, you can
    just skip to “The Reasons Bitcoin Needs Cryptography” on [page 137](../Text/ch07.html#page_137)),
    and then we’ll explore the specific cryptographic methods used in Bitcoin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币依赖于加密技术来运作，这也是它有时被称为*加密货币*的原因。^([1](../Text/footnote.html#footnote41)) 但是，加密技术在比特币中扮演什么角色，为什么它是必要的呢？我们将首先简要介绍一些必要的加密技术概念（如果你已经熟悉这些概念，可以直接跳到[第137页](../Text/ch07.html#page_137)的“比特币为何需要加密技术”部分），然后我们将探讨比特币中使用的具体加密方法。
- en: 'If you flipped to this chapter only because you wanted to know whether the
    cryptography used by Bitcoin is safe, you can rest easy knowing that Bitcoin uses
    only tried-and-tested cryptographic techniques: All of the cryptographic methods
    used by Bitcoin have been widely used in the past by governments and major corporations
    to secure financial, medical, and other sensitive information, as well as personal
    identification data.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你翻到这一章只是因为你想知道比特币使用的加密技术是否安全，那么你可以放心，因为比特币仅使用经过验证的加密技术：比特币使用的所有加密方法，过去已被各国政府和大公司广泛应用于保护金融、医疗和其他敏感信息，以及个人身份数据。
- en: In fact, the cryptography in Bitcoin could be described as *boring*, simply
    because it relies on very conservative cryptographic algorithms. But in some fields
    of study, such as accounting and dentistry, boring is good; in the case of Bitcoin,
    conservative and well-established cryptography helps make it more secure. The
    interesting part is what Bitcoin *does* with cryptography.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，比特币中的加密技术可以说是*无聊的*，因为它依赖于非常保守的加密算法。但在一些学科领域，如会计和牙科，*无聊*其实是好事；对于比特币来说，保守且成熟的加密技术有助于使其更加安全。真正有趣的部分是比特币如何*使用*加密技术。
- en: '![image](../Images/f0130-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0130-01.jpg)'
- en: Fortunately, as you’ll see, although Bitcoin cryptography may be old hat to
    the experts, it is still immensely fascinating to a novice!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如你所看到的，尽管比特币的加密技术对专家来说可能是陈词滥调，但对于新手来说，它依然非常有趣！
- en: '**A Brief Cryptography Overview**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密技术简述**'
- en: Historically, cryptography was used to send secret messages when necessary to
    protect information. Messages were systematically scrambled, or *encrypted*, in
    a way that hopefully only the recipient of the message knew how to *decrypt.*
    A well-encrypted message might be intelligible as battle plans to the intended
    recipient, but to anyone else it would just be a well-tossed word salad with a
    side order of alphabet soup. Historically, encryption and decryption were laborious
    tasks and were reserved only for secure clandestine communication (usually of
    a military or illicit romantic nature). With the advent of computers, which could
    do in milliseconds what used to take hours manually, cryptography is now used
    routinely by the masses to encrypt/decrypt very important (e.g., financial) and
    not-so-important (e.g., pay-per-view TV) communication. Perhaps surprisingly,
    the convenience and speed of computers has led to the adoption of cryptographic
    methods for more than just encrypting secret messages. Common examples include
    logging in to websites with a username and password combination and using a registration
    key to install software. Both use cryptographic methods, but no message encryption
    is involved in either case.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，加密技术用于在必要时发送秘密信息，以保护信息的安全。信息通过系统地加密，或称为*加密*，使得只有接收者知道如何*解密*。一条加密得当的信息可能对接收者来说能理解为战斗计划，但对其他人来说，这就像是乱七八糟的文字拼盘，配上一碗字母汤。历史上，加密和解密是繁琐的任务，只用于安全的秘密通信（通常是军事或非法的浪漫性质）。随着计算机的出现，它们能够在毫秒内完成曾经需要数小时才能手动完成的任务，现在加密技术已被大众日常使用，用于加密/解密非常重要（例如，金融）和不太重要（例如，付费电视）通信。或许令人惊讶的是，计算机的便捷性和速度促使了加密方法的应用不仅仅局限于加密秘密信息。常见的例子包括使用用户名和密码登录网站以及使用注册码安装软件。两者都使用了加密技术，但在这两种情况下都没有涉及信息加密。
- en: In addition to encrypting messages, modern cryptography is used to verify the
    validity of information (through *cryptographic hash functions*) and to prove
    one’s identity (through *digital signatures*). For example, without modern cryptography,
    you wouldn’t be able to distinguish between two identical websites that both claimed
    to belong to your bank. One might be phony and run by thieves to steal your money.
    But only your bank’s website can provide the correct digital signature. Before
    we explain how digital signatures and cryptographic hash functions work, let’s
    explore one-way functions, a feature that both rely on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加密信息外，现代密码学还用于验证信息的有效性（通过*加密哈希函数*）和证明身份（通过*数字签名*）。例如，如果没有现代密码学，你将无法区分两个自称是你银行网站的完全相同的网站。其中一个可能是虚假的，由小偷操控来窃取你的钱财。但只有你银行的网站能够提供正确的数字签名。在我们解释数字签名和加密哈希函数如何工作之前，让我们先了解一下单向函数，这是这两者所依赖的特性。
- en: '***One-Way Functions***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单向函数***'
- en: '*One-way functions* are mathematical functions that make it easy to calculate
    an output based on the input but difficult to do the reverse. A precise mathematical
    definition of what is easy or difficult doesn’t exist but depends on the complexity
    of the calculation and the effort required to solve it.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*单向函数* 是一种数学函数，基于输入容易计算出输出，但反向操作却很困难。什么是“容易”或“困难”的精确定义并不存在，而是取决于计算的复杂性和解决问题所需的努力。'
- en: 'A typical example is called *integer factorization*, which asks you to write
    an integer^([2](../Text/footnote.html#footnote42)) as the product of only prime
    numbers—for example, the factors of 6 are 2 and 3, which are both prime. Given
    the prime factors as input, it is easy to multiply them to produce an output integer,
    but the reverse is not true (at least for larger numbers). Given a large integer,
    finding its prime factors is very difficult. The only known methods involve systematically
    guessing different combinations of prime factors, but the amount of time required
    to find the right answer increases exponentially with the number of digits. Imagine
    trying to multiply 2 × 7 × 7 in your head. It is not that difficult to calculate
    the answer of 98; however, if you were given the number 98 and were required to
    find its prime factors, generating 2, 2, and 7 would be more difficult. A typical
    laptop can factor a 60–80 digit number in less than a second, but the required
    time grows exponentially: To factor a 300-digit number or greater would take a
    modern supercomputer decades.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子叫做*整数因式分解*，它要求你将一个整数^([2](../Text/footnote.html#footnote42))写成仅由素数组成的乘积。例如，6
    的因子是 2 和 3，这两者都是素数。给定素因子作为输入，乘它们得到输出整数是很容易的，但反过来却不行（至少对于更大的数字来说）。给定一个大整数，找到它的素因子是非常困难的。已知的唯一方法是系统地猜测不同的素因子组合，但找到正确答案所需的时间会随着数字位数的增加而指数级增长。想象一下，在脑海中计算
    2 × 7 × 7。计算出答案 98 其实并不困难；然而，如果你得到数字 98，并且要求找出它的素因子，生成 2、2 和 7 将会更为困难。一台典型的笔记本电脑可以在不到一秒的时间内因式分解一个
    60–80 位的数字，但所需时间是指数级增长的：因式分解一个 300 位或更大的数字将需要现代超级计算机几十年的时间。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another one-way function, which is a bit more complicated but is commonly used
    in cryptography, involves the *discrete logarithm*. Consider a set of integers
    {0, 1, 2, 3, ..., *n* − 1} where *n* is a prime number and where we only use modular
    arithmetic with modulo *n:*^([3](../Text/footnote.html#footnote43))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个单向函数，虽然稍微复杂一些，但在密码学中常见的函数涉及到*离散对数*。考虑一个整数集合 {0, 1, 2, 3, ..., *n* − 1}，其中
    *n* 是一个素数，并且我们只使用模 *n* 的模算术：^([3](../Text/footnote.html#footnote43))
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is easy (as in, you can do it with a pocket calculator) to raise an integer,
    *a*, to the *k*th power to calculate the integer *b*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个整数 *a* 提升到 *k* 次方来计算整数 *b* 是很容易的（比如，你可以用一个口袋计算器完成这项操作）：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, the discrete logarithm, which is finding *k* given only *a, b*, and
    *n,* is difficult to calculate. The only known methods to find *k* are variations
    on trying to guess every value between 0 and *n* that satisfy the preceding equation.
    The larger the value of *n*, the harder it is (and the more time it will take)
    to calculate *k*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，离散对数问题，即给定 *a, b* 和 *n*，找出 *k* 是非常困难的。已知的求解 *k* 的方法是对0到 *n* 之间的每个值进行猜测，以满足前述方程。*n*
    的值越大，计算 *k* 就越困难（所需时间也越长）。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the early days of computers, people started applying the asymmetry in these
    one-way functions to build various classes of cryptographic algorithms, which
    is what we’ll discuss next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的早期，人们开始利用这些单向函数的非对称性来构建各种类别的密码学算法，这也是我们接下来要讨论的内容。
- en: '***Cryptographic Hash Functions Verify Information***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码学哈希函数验证信息***'
- en: Cryptographic hash functions are one-way functions designed to take arbitrary
    data as input (e.g., a number, a short message, an image, or the collected works
    of Shakespeare) and generate fixed-length output (e.g., a 128-bit or 256-bit number).
    The output is called a *hash* or *hash value.* Hash values can act like a fingerprint—a
    unique identifier—for files or texts. They’re designed in a way that makes it
    extremely unlikely that any two non-identical inputs would output the same hash
    value (when this does happen, it is called a *collision*). In particular, even
    a small change to the input data, such as changing one letter in the entire collected
    works of Shakespeare, would result in a new hash value that is completely unrelated
    to the original hash.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数是单向函数，设计用于将任意数据作为输入（例如，数字、简短信息、图片或莎士比亚的全集），并生成固定长度的输出（例如，128位或256位数字）。这个输出被称为*哈希*或*哈希值*。哈希值可以像指纹一样，作为文件或文本的唯一标识符。它们的设计方式使得两个不同的输入产生相同哈希值的可能性极小（当这种情况发生时，称为*碰撞*）。特别是，即使输入数据发生微小变化，例如在莎士比亚全集中改变一个字母，也会导致生成一个与原哈希值完全不同的新哈希值。
- en: 'A commonly used cryptographic hash function is MD5 (message digest algorithm,
    iteration five), which takes any data as input and outputs a 128-bit hash value,
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的密码学哈希函数是MD5（消息摘要算法，第五版），它将任何数据作为输入并输出一个128位的哈希值，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, changing just one character in *mysecretpasswordisCATS* results
    in a completely different hash output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在*mysecretpasswordisCATS*中仅更改一个字符就会导致完全不同的哈希输出：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This property enables hash functions to be used to verify that certain information
    is correct or to match what someone else claims is correct, without needing to
    scrutinize the actual information. For example, MD5 is used to check whether a
    downloaded file is safe to use and is free of errors that might have occurred
    during data transmission. If the MD5 hash value of the downloaded data matches
    the hash value provided by a reputable source, you can be certain that data does
    not contain any hidden viruses and was not corrupted during the file transfer.
    The slightest alteration to the file would cause a noticeable change to the hash
    output. A hash is like a tamperproof seal: If it’s broken, don’t buy the product.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性使得哈希函数可以用于验证某些信息是否正确，或与其他人声称的正确信息进行匹配，而不需要仔细检查实际信息。例如，MD5用于检查下载的文件是否安全可用，并且在数据传输过程中没有发生错误。如果下载的数据的MD5哈希值与可靠来源提供的哈希值匹配，那么你可以确定该数据没有隐藏的病毒，也没有在文件传输过程中损坏。文件的任何轻微改动都会导致哈希值发生明显变化。哈希值就像一个防篡改的封条：如果它被破坏了，千万不要购买该产品。
- en: Another, more exciting, use of cryptographic hash functions is proving that
    you know a secret password without giving it away. Imagine you are a spy behind
    enemy lines. After many days of traveling under the cloak of darkness, you finally
    reach a guarded warehouse to meet with fellow agents. A guard at the front door
    asks you for the secret code, but you aren’t sure whether the guard is on your
    side. You need to prove that you know the code without risking the mission by
    letting your secret code fall into the wrong hands! What do you do? You give him
    a hash of the secret code. If he knows the code, he can calculate the hash and
    verify that you also know it. If he doesn’t and isn’t supposed to know the code,
    you haven’t revealed it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数的另一个更令人兴奋的应用是证明你知道一个秘密密码而不将其透露。假设你是一个敌后间谍。经过多天在黑暗中旅行后，你终于到达一个守卫的仓库，与同胞特工见面。前门的守卫要求你提供秘密代码，但你不确定他是否是你方的人员。你需要证明你知道密码，但又不想冒着让密码落入敌人之手的风险！你该怎么办？你给他密码的哈希值。如果他知道密码，他就能计算出哈希值并验证你也知道密码。如果他不知道密码并且不应该知道，你就没有泄露它。
- en: This dramatic example describes current standard procedure whenever you create
    a new account with a username and password for a website. The password is never
    stored on the website’s servers; instead, the hash of the password is stored,
    and the server checks whether the hash of what you typed matches what is on record.
    As a result, if the server is ever stolen or hacked into, no passwords will be
    revealed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个极具戏剧性的例子描述了当你为一个网站创建新账户并设置用户名和密码时的标准程序。密码从不存储在网站的服务器上；而是存储密码的哈希值，服务器会检查你输入的哈希值是否与记录中的哈希值匹配。因此，如果服务器被盗或遭到黑客攻击，密码将不会被泄露。
- en: '***Public Key Cryptography***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***公钥密码学***'
- en: The invention of public key cryptography in the 1970s was a significant breakthrough,
    allowing for much of the technology we take for granted today. Until then, all
    methods of encryption required the sender and receiver to know the same secret
    encryption key to encrypt and decrypt the message (also known as *symmetric key*
    cryptography). However, this method presented a problem because it assumed that,
    at some earlier time, the sender and receiver had a safe way of communicating
    to decide on an encryption key without the fear of anyone eavesdropping.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学的发明出现在1970年代，是一次重大的突破，推动了我们今天所依赖的许多技术。直到那时，所有的加密方法都需要发送方和接收方知道相同的秘密加密密钥来加密和解密消息（也叫做*对称密钥*密码学）。然而，这种方法存在一个问题，因为它假设发送方和接收方在某个较早的时间有一种安全的方式来沟通，以便决定加密密钥，而不必担心有人窃听。
- en: 'In public key cryptography (also known as *asymmetric key* cryptography), two
    different keys are created: a public key that is shared to *encrypt* the message
    and a private key that is confidential to *decrypt* the message (yes, the same
    private key that is used to spend bitcoins). With asymmetric key cryptography,
    communicating securely with anyone using an unsafe channel, like the radio or
    Internet, is easy: You share your public key with others who want to communicate
    with you, and then anyone can send you encrypted messages that only you can read
    using your private key. Because the public key cannot be used to decrypt messages,
    no danger occurs if it falls into the wrong hands. If others want you to send
    *them* encrypted messages, they give you *their* public key, and so on.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥密码学（也叫做*非对称密钥*密码学）中，创建了两把不同的密钥：一把公钥用于*加密*消息，另一把私钥用于*解密*消息（没错，就是用于花费比特币的那把私钥）。使用非对称密钥密码学，通过不安全的渠道（如无线电或互联网）进行安全通信变得简单：你将公钥分享给希望与你通信的人，然后任何人都可以发送加密消息，而只有你能用私钥解密。因为公钥无法用于解密消息，即使它落入错误的手中也没有危险。如果别人希望你发送*加密*消息给他们，他们会给你*他们*的公钥，依此类推。
- en: How does asymmetric key cryptography work? The original method, called *RSA
    encryption* after its developers—Ron Rivest, Adi Shamir, and Leonard Adleman,
    is based on integer factorization.^([4](../Text/footnote.html#footnote44)) Let’s
    imagine that Crowley wants to communicate with others using the RSA method. Crowley
    first needs to create a public and a private key (see [Table 7-1](../Text/ch07.html#ch07table1)).
    He can do this at any time before he starts his communications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密钥密码学是如何工作的？原始方法被称为*RSA加密*，以其开发者Ron Rivest、Adi Shamir和Leonard Adleman命名，基于整数分解。^([4](../Text/footnote.html#footnote44))
    假设Crowley想要使用RSA方法与其他人通信。Crowley首先需要创建一把公钥和一把私钥（见[表7-1](../Text/ch07.html#ch07table1)）。他可以在任何时间创建这些密钥，然后开始通信。
- en: '**Table 7-1:** Sending an Encrypted Message Using the RSA Method'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 使用RSA方法发送加密消息'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **说明** | **示例** |'
- en: '| 1 | Crowley chooses two prime numbers, *p* and *q*, and multiplies them to
    get the prime product *n*. Recall that this is a one-way function; there is no
    easy way to obtain *p* and *q* given only *n*. | *p* = 71, *q* = 149 *n* = 71
    × 149 = 10579 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Crowley选择两个质数，*p* 和 *q*，并将它们相乘得到质数乘积 *n*。回想一下，这是一种单向函数；仅凭 *n* 是无法轻易获得
    *p* 和 *q* 的。 | *p* = 71, *q* = 149 *n* = 71 × 149 = 10579 |'
- en: '| 2 | Crowley calculates *t* = (*p* − 1)(*q* − 1). | *t* = (71 − 1) × (149
    − 1)= 10360 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Crowley计算 *t* = (*p* − 1)(*q* − 1)。 | *t* = (71 − 1) × (149 − 1)= 10360
    |'
- en: '| 3 | Crowley chooses an integer *e* such that *e* and *t* do not share a common
    denominator (other than 1 of course). He has many possible values of *e* from
    which to choose. This is Crowley’s public key. | Choose *e* = 3453 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Crowley选择一个整数 *e*，使得 *e* 和 *t* 没有共同的约数（当然除了1）。他有许多可能的 *e* 值可供选择。这就是Crowley的公钥。
    | 选择 *e* = 3453 |'
- en: '| 4 | Crowley finds *d* such that *d* × *e* (mod *t*) = 1.This is Crowley’s
    private key. | *d* × 3453 (mod 10360) = 1 satisfied when *d* = 10357 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 克劳利找到 *d*，使得 *d* × *e* (mod *t*) = 1。这是克劳利的私钥。 | *d* × 3453 (mod 10360)
    = 1，当 *d* = 10357 时满足 |'
- en: Once the public and private keys are generated, Crowley can distribute the public
    key widely (along with the prime product, *n*). Then anyone can use this key to
    encrypt a message meant only for Crowley.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦公钥和私钥生成，克劳利可以广泛分发公钥（以及质数积 *n*）。这样任何人都可以使用这个公钥加密只供克劳利查看的消息。
- en: Of course, to encrypt and decrypt messages, you need some way of converting
    text into a mathematical form, which is called *encoding.* Converting a number
    back to text is called *decoding*. Encoding and decoding should not be confused
    with encrypting or decrypting because you are not scrambling the information.
    Many different encoding schemes exist, and it doesn’t matter which one you use,
    but all parties involved need to use the same one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要加密和解密消息，你需要某种方法将文本转换为数学形式，这被称为 *编码*。将数字转换回文本称为 *解码*。编码和解码不应与加密或解密混淆，因为你并不是在混淆信息。存在许多不同的编码方案，使用哪种方案并不重要，但所有相关方需要使用相同的方案。
- en: Let’s assume that the letter *a* becomes a 0, the letter *b* becomes a 1, the
    letter *c* becomes a 2, and so on through the alphabet. In [Table 7-2](../Text/ch07.html#ch07table2)
    we’ve encoded the message “fade” using this technique.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设字母 *a* 对应 0，字母 *b* 对应 1，字母 *c* 对应 2，以此类推。在[表 7-2](../Text/ch07.html#ch07table2)中，我们使用这种方法对消息“fade”进行了编码。
- en: '**Table 7-2:** Encoding the Word “Fade” Using a Simple Scheme'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：** 使用简单方案对单词“Fade”进行编码'
- en: '| **Letter** | **Position in alphabet starting with zero** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **字母** | **从零开始的字母位置** |'
- en: '| F | 5 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| F | 5 |'
- en: '| A | 0 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| A | 0 |'
- en: '| D | 3 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| D | 3 |'
- en: '| E | 4 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| E | 4 |'
- en: Now that we have an encoded message we want to send to Crowley, as well as Crowley’s
    public key, we can encrypt his message so that only Crowley can decrypt it, as
    shown in [Table 7-3](../Text/ch07.html#ch07table3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个编码后的消息，准备发送给克劳利，并且也有了克劳利的公钥，我们可以加密这个消息，使得只有克劳利能够解密，正如[表 7-3](../Text/ch07.html#ch07table3)所示。
- en: '**Table 7-3:** Encrypting the Word “Fade” Using Crowley’s Public Key'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 使用克劳利的公钥加密单词“Fade”'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **指令** | **示例** |'
- en: '| 1 | To encrypt a message, use the public key, *e*, to calculate:*c* = *m*^e
    (mod *n*)*c* is referred to as the ciphertext | *c* = 5034^3453 (mod 10579)= 5272decoded
    as *fchc* |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 要加密消息，使用公钥 *e* 进行计算：*c* = *m*^e (mod *n*)。*c* 被称为密文 | *c* = 5034^3453
    (mod 10579) = 5272，解码为 *fchc* |'
- en: '| 2 | To decrypt a message, use the private key, d, to calculate*m* = *c*^d
    (mod *n*)*m* is the original message | *m* = 5272^10357 (mod 10579)= 5034decoded
    as *fade* |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 要解密消息，使用私钥 *d* 进行计算：*m* = *c*^d (mod *n*)。*m* 是原始消息 | *m* = 5272^10357
    (mod 10579) = 5034，解码为 *fade* |'
- en: Almost an identical scheme can be used to prove one’s identity, using what is
    referred to as a *digital signature*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以使用相同的方案来证明一个人的身份，这种方式被称为 *数字签名*。
- en: '***Digital Signatures***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字签名***'
- en: In the public key encryption scheme described earlier, anyone can send you encrypted
    messages without you knowing who they are. Consider Crowley on his island trying
    to arrange a transfer of pineapples with Satoshi on another island. If Crowley
    receives two messages with contradictory information both claiming to come from
    Satoshi (for example, “Send pineapples to the north island. —Your friend, Satoshi”
    and “Send pineapples to the south island. —Your friend, Satoshi”), how does Crowley
    know which message really came from Satoshi?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面描述的公钥加密方案中，任何人都可以向你发送加密消息，而你却不知道他们是谁。假设克劳利在他的岛屿上，试图与另一个岛屿上的佐藤安排转交菠萝。如果克劳利收到两条信息，内容相互矛盾，但都声称来自佐藤（例如：“把菠萝送到北岛。——你的朋友，佐藤”和“把菠萝送到南岛。——你的朋友，佐藤”），克劳利怎么知道哪条信息才是真正来自佐藤呢？
- en: 'Fortunately, Satoshi can use a trick to prove his identity *and* the authenticity
    of his messages: He can encrypt messages not only with his public key but also
    with his private key. This backward encryption method reverses the mathematics
    of encryption, just as you’d expect: Although it’s very difficult to encrypt a
    message (only the person with access to the private key can accomplish this),
    it’s very easy to decrypt a message (anyone with the public key can do so).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，中本聪可以使用一个技巧来证明自己的身份*以及*信息的真实性：他不仅可以使用自己的公钥加密信息，还可以使用自己的私钥进行加密。这种反向加密方法颠倒了加密数学原理，正如你所预期的那样：尽管加密信息非常困难（只有拥有私钥的人才能完成加密），但解密信息却非常容易（任何拥有公钥的人都可以解密）。
- en: 'Therefore, if Satoshi uses this backward method to encrypt the message: “My
    name is Satoshi, I live on the south island, and I double-pinky-swear to pay you
    for some pineapples,” anyone, including Crowley, can decrypt this message using
    Satoshi’s public key (which, let’s assume, was previously established to be 100
    percent authentic). Crowley can then say, “I know Satoshi is the only person on
    Earth who has access to his private key, and this message was written by someone
    who must have access to this private key; therefore, these words are Satoshi’s
    words.”'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果中本聪使用这种反向加密方法加密消息：“我的名字是中本聪，我住在南岛，我承诺会支付你一些菠萝的钱，”任何人，包括克劳利，都可以使用中本聪的公钥解密这条消息（假设这个公钥已经被确认是百分之百真实的）。然后克劳利可以说：“我知道中本聪是地球上唯一拥有他私钥的人，而这条消息是由一个必须能够访问该私钥的人写的；因此，这些话是中本聪说的。”
- en: When you use this method to prove your identity, the functions of the public
    and private key are reversed. Satoshi can use his private key to encrypt a message,
    and everyone else can decrypt it using his public key. Because others have Satoshi’s
    public key, the contents of the message wouldn’t be secret, but the fact that
    it was encrypted using Satoshi’s private key proves that it could not have been
    sent by anyone else.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这种方法来证明你的身份时，公钥和私钥的功能发生了逆转。中本聪可以使用他的私钥加密一条消息，其他人则可以使用他的公钥解密它。因为其他人拥有中本聪的公钥，消息的内容就不再是秘密，但消息被私钥加密这一事实证明了它不可能是由其他任何人发送的。
- en: '**Whis Is It Called a Digital Signature?**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为什么这叫做数字签名？**'
- en: 'The term *digital signature* is used because the most convenient way to send
    a reverse encryption is to send two separate bits of information: a *message*
    and a *message signature*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*数字签名*的使用源于这样一个事实：发送反向加密的最方便方式是传递两部分信息：*消息*和*消息签名*。
- en: 'Think about it: Satoshi has nothing to hide in the message he is sending (in
    fact, he explicitly wants everyone to be able to read his message); therefore,
    it is arguably more convenient for Satoshi to send the message in an unencrypted
    form and then a duplicate it in encrypted form. Crowley can easily read the message
    and only bother using Satoshi’s public key to decrypt the duplicate if he is suspicious
    of whether Satoshi actually wrote it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想：中本聪在发送的消息中没有什么需要隐藏的（事实上，他明确希望每个人都能阅读他的消息）；因此，可以说对中本聪来说，直接发送未加密的消息，然后再以加密形式发送一份副本会更为方便。如果克劳利怀疑这条信息是否确实是中本聪写的，他可以轻松地阅读消息，并且只有在有疑虑时，才会使用中本聪的公钥解密副本。
- en: However, it seems inefficient to send a message twice. Clearly, Satoshi must
    send the entire *unencrypted* message to get the message out to the world. But
    could the *encrypted* message be shortened? In fact it can, by using cryptographic
    hash functions. Remember that if anyone tries to tamper with a message, the hash
    of that message will be different as a result. Satoshi can therefore simply calculate
    the hash output of his message and then encrypt *only that hash* using his private
    key. Then anyone who reads the message can decrypt Satoshi’s hash output (using
    his public key) and also calculate the hash of the unencrypted message, checking
    whether the two agree.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，发送两次消息似乎效率不高。显然，中本聪必须发送整个*未加密*的消息才能让世界看到这条消息。但*加密*消息能不能缩短呢？事实上是可以的，通过使用加密哈希函数。记住，如果任何人试图篡改一条消息，该消息的哈希值会发生变化。因此，中本聪可以简单地计算出他消息的哈希值，然后仅使用他的私钥加密*该哈希值*。然后，任何阅读该消息的人都可以使用他的公钥解密中本聪的哈希输出，并计算出未加密消息的哈希值，检查两者是否一致。
- en: Keep in mind that a hash of a message, no matter how long the original message,
    is a short piece of data. Therefore, by only encrypting the hash of the original
    message, you can create a short digital signature of a much longer message. More
    important, even the slightest alteration to the unencrypted message would cause
    the cryptographic hash to be completely different, thus preventing any interceptor
    from modifying the signed message. As a result, not only does a digital signature
    prove that the real Satoshi signed the message, but it also proves that he signed
    a very specific message. In this regard, digital signatures are even better than
    analog handwritten signatures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，消息的哈希值无论原始消息多长，都是一段很短的数据。因此，通过仅加密原始消息的哈希值，你可以创建一个非常短的数字签名来表示一个更长的消息。更重要的是，即使对未加密的消息进行最微小的修改，也会导致加密哈希值完全不同，从而防止任何拦截者篡改已签名的消息。因此，数字签名不仅证明了真正的中本聪签署了消息，而且还证明了他签署了一条非常特定的消息。在这方面，数字签名甚至比模拟的手写签名更好。
- en: '***Using Digital Signatures***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用数字签名***'
- en: Using the RSA encryption scheme, implementing digital signatures is straightforward.
    Let’s assume that we are using the same encoding scheme as in [Table 7-2](../Text/ch07.html#ch07table2)
    and we want to send the message “fade” unencrypted but signed. [Table 7-4](../Text/ch07.html#ch07table4)
    shows how to use a digital signature to prove authorship of the message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA加密方案，实现数字签名非常简单。假设我们使用与[表7-2](../Text/ch07.html#ch07table2)中相同的编码方案，并且我们希望以未加密但已签名的方式发送消息“fade”。[表7-4](../Text/ch07.html#ch07table4)展示了如何使用数字签名证明消息的作者身份。
- en: Now we can send the message “fade” and sign it with *ifda*. The recipient doesn’t
    need any additional information to read the message, because it can be read plainly.
    But to verify the identity of the sender, the recipient needs to know the hash
    function used (in this case MD5), the prime product *n*, and the public key of
    the sender, *e*. The recipient then decrypts the signature with the public key
    to obtain the hash value, in this case 8808, and checks to see whether it matches
    the MD5 hash of the message “fade.” If a match is made, the recipient knows who
    the message came from and that the message was not altered in transit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以发送消息“fade”，并用*ifda*进行签名。接收者无需任何额外信息即可读取消息，因为它可以直接读取。但为了验证发送者的身份，接收者需要知道所使用的哈希函数（在本例中是MD5）、素数积*n*和发送者的公钥*e*。接收者随后使用公钥解密签名以获得哈希值，本例中是8808，并检查它是否与消息“fade”的MD5哈希值匹配。如果匹配，接收者就知道消息来自哪里，并且消息在传输过程中没有被篡改。
- en: '**Table 7-4:** Signing the Message “Fade” Using RSA Encryption'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-4：** 使用RSA加密签名消息“Fade”'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **说明** | **示例** |'
- en: '| 1 | Calculate the hash of the message using a suitable cryptographic hash
    function (e.g., MD5). The hash output must be less than the prime product *n*,
    which can be accomplished by calculating the modulus of the output.^**h* = MD5(*message*)
    (mod *n*) | *fade* encoded as 5034*h* = MD5(5034) (mod 10579)= 8808 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 使用合适的加密哈希函数（例如MD5）计算消息的哈希值。哈希输出必须小于素数积*n*，这可以通过计算输出的模来实现。^**h* = MD5(*message*)
    (mod *n*) | *fade* 编码为 5034*h* = MD5(5034) (mod 10579)= 8808 |'
- en: '| 2 | Encrypt the hash, *h*, using the RSA encryption method, namely calculate:
    *s* = *h*^d (mod *n*), where *s* is the signature (it is a ciphertext) | *s* =
    8808^10357 (mod 10579)= 8530decoded as *ifda* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 使用RSA加密方法加密哈希值*h*，即计算：*s* = *h*^d (mod *n*)，其中*s*是签名（它是一个密文） | *s* =
    8808^10357 (mod 10579)= 8530 解密为 *ifda* |'
- en: '* If you are following along, keep in mind that the input format for a hash
    function is important. The MD5 hash of the integer 5034 is not the same as the
    MD5 hash of the word *5034*, which is in text format. For numbers, the base of
    the number needs to be specified as well.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '* 如果你在跟随本教程，记住哈希函数的输入格式非常重要。整数5034的MD5哈希值与单词*5034*（文本格式）的MD5哈希值不同。对于数字，还需要指定数字的进制。'
- en: 'This is how digital signatures work. Of course, in this example, the prime
    product chosen was a low number so the examples were easy to follow. In practice,
    RSA cryptography uses 512-bit or 1024-bit prime products (or even higher for military
    communications), which looks something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数字签名的工作原理。当然，在这个例子中，选择的素数积是一个较小的数字，因此例子比较容易理解。在实际应用中，RSA加密使用的是512位或1024位的素数积（甚至更高的位数用于军事通信），它看起来大致是这样的：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other small details differ in practice to further increase the security of the
    procedure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些小细节在实际操作中有所不同，进一步增强了程序的安全性。
- en: '**Why Bitcoin Needs Cryptography**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么比特币需要加密技术**'
- en: 'So why is cryptography necessary to make Bitcoin work, even though Bitcoin
    does not involve sending secret messages? In Bitcoin, hash functions and digital
    signatures are used for the following important purposes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么比特币必须依赖加密技术才能正常工作，即使比特币并不涉及发送秘密消息？在比特币中，哈希函数和数字签名用于以下几个重要目的：
- en: • Authorizing transactions with digital signatures
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用数字签名授权交易
- en: • Verifying the validity of the transaction history
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: • 验证交易历史的有效性
- en: • Proof-of-work in Bitcoin mining
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: • 比特币挖矿中的工作量证明
- en: • Extra protection for Bitcoin private keys
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: • 比特币私钥的额外保护
- en: Let’s explore the functions of Bitcoin that require cryptography and then delve
    into the specific methods that Bitcoin uses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索比特币需要加密技术的功能，然后深入了解比特币使用的具体方法。
- en: '***Authorizing Transactions with Digital Signatures***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用数字签名授权交易***'
- en: Bitcoin uses digital signatures to authorize transactions so that you, and *only*
    you, can spend the bitcoins you own. With credit card payments and bank transfers,
    you authorize a transaction by providing proof of your personal identity (and
    these days, the amount of proof you have to show is getting quite burdensome).
    With Bitcoin, no personal information is tied to any Bitcoin address; instead,
    you must prove that you own the private key. Showing people your private key would
    certainly be valid as proof, but by knowing the private key, the people you’ve
    shown could then claim *they owned* the bitcoins at that address. Therefore, you
    need to prove that you have the private key without actually sharing it. But there’s
    more to it than that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用数字签名来授权交易，以便只有你，*而且仅仅是你*，可以花费你拥有的比特币。在信用卡支付和银行转账中，你通过提供个人身份的证明来授权交易（而如今，你需要提供的证明越来越多，负担也越来越重）。而在比特币中，没有任何个人信息与比特币地址相关联；相反，你必须证明你拥有私钥。将私钥展示给别人肯定可以作为证明，但通过知道私钥，那些你展示过私钥的人就可能声称*他们拥有*该地址上的比特币。因此，你需要证明你拥有私钥，而不必实际共享它。但问题远不止于此。
- en: 'A Bitcoin transaction contains a fair amount of information: the number of
    bitcoins transferred, the address they are being transferred to, the transaction
    fee, and so on. You don’t want any of that information to be altered without your
    permission, so in addition to proving you own the bitcoins you are sending, you
    also need to ensure that the transaction details are followed exactly as you wrote
    them. A Bitcoin transaction is a message with instructions, and by signing it
    with a digital signature, you simultaneously prove that you have the private key
    and ensure that the transaction details are what you intended. If the signature
    is missing or doesn’t match the public key, nodes on the Bitcoin network will
    consider the transaction invalid and will not add it to the blockchain.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一笔比特币交易包含相当多的信息：转移的比特币数量、接收地址、交易费用等等。你不希望这些信息在未经你许可的情况下被更改，因此，除了证明你拥有正在发送的比特币外，你还需要确保交易细节完全按照你所写的执行。比特币交易是一条包含指令的信息，通过用数字签名对其进行签名，你可以同时证明你拥有私钥，并确保交易细节正是你所意图的。如果签名缺失或与公钥不匹配，比特币网络中的节点会认为该交易无效，并不会将其加入区块链。
- en: '***Verifying the Validity of the Transaction History***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验证交易历史的有效性***'
- en: Bitcoin depends on the blockchain being widely distributed among the nodes in
    the network. But how can you be sure that any individual node in the network with
    a copy of the blockchain has not been surreptitiously altered? A malicious attacker
    could try to distribute a fraudulent blockchain where just a single transaction
    has been modified in the attacker’s favor. However, such an attack could never
    work for several reasons. One reason is that the slightest change in the transaction
    history would completely change the *block hash* of all the blocks after it in
    the chain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币依赖于区块链在网络中的节点广泛分发。但是，你怎么能确保网络中的任何单个节点拥有的区块链副本没有被偷偷篡改呢？恶意攻击者可能试图分发一个伪造的区块链，其中仅有一笔交易被篡改以利于攻击者。然而，这种攻击绝对行不通，原因有很多。一个原因是交易历史的最小变化就会完全改变该交易后所有区块的*区块哈希*。
- en: Each block in the blockchain contains a list of transactions and a hash of the
    transactions in the previous block in the chain. Hence, it’s impossible to alter
    just one transaction in a block in the middle without causing a mismatch between
    the expected block hash and the hash recorded in the next block.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的每个区块都包含一个交易列表和上一个区块交易的哈希值。因此，要想单独修改中间区块中的一个交易，必须导致预期区块哈希与下一个区块记录的哈希值不匹配，这几乎是不可能的。
- en: This verification provides an efficient way for a single node to check whether
    transactions in its copy of the blockchain have been tampered with. Rather than
    checking every transaction in the entire transaction history, a node can simply
    check whether the hash of each block matches the recorded hash of subsequent blocks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证为单个节点提供了一种高效的方式来检查其区块链副本中的交易是否被篡改。节点无需检查整个交易历史中的每一笔交易，而只需检查每个区块的哈希值是否与后续区块记录的哈希值匹配。
- en: '***Proof-of-Work in Bitcoin Mining***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币挖矿中的工作量证明***'
- en: Bitcoin mining is based on a lottery system that you can win only by guessing
    numbers repeatedly, but that makes it is easy for others to check when you’re
    right. If this sounds similar to a one-way function, that’s because it is. The
    one-way function used in Bitcoin mining is a cryptographic hash function. Miners
    are given the output criteria (the output can be any number less than some threshold),
    but by design, cryptographic hash functions make it difficult to reverse calculate
    what the corresponding input needs to be. Therefore, Bitcoin miners can only randomly
    choose different inputs, hoping that the output will be a number below the threshold.
    Once a miner determines the correct input value, it is easy to prove his or her
    work to others by sharing that value with others who can easily recalculate the
    hash.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币挖矿基于一种抽奖系统，你只能通过反复猜测数字来获胜，但这使得他人容易检查你是否猜对了。如果这听起来像是单向函数，那是因为它确实是。比特币挖矿中使用的单向函数是加密哈希函数。矿工会得到输出标准（输出可以是低于某个阈值的任意数字），但由于加密哈希函数的设计使得逆向计算对应的输入非常困难，因此比特币矿工只能随机选择不同的输入，希望输出能低于阈值。一旦矿工确定了正确的输入值，他或她可以通过与他人共享该值来轻松证明自己的工作，其他人可以轻松重新计算哈希值。
- en: '***Extra Protection for Bitcoin Private Keys***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币私钥的额外保护***'
- en: Authorizing transactions with digital signatures requires sharing your public
    key with others. Although it is thought to be computationally infeasible to calculate
    a private key from a public key, it is similarly difficult to calculate the input
    of a hash function given just the output, and it is doubly difficult to do both.
    Instead of sharing a public key, users share a *Bitcoin address*, which is a cryptographic
    hash of a public key. In fact, the public key is hashed twice using two different
    cryptographic hash functions to create a Bitcoin address. This extra protection
    ensures that no amount of analysis of a Bitcoin address can reveal the underlying
    private key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字签名授权交易需要与他人共享你的公钥。虽然从公钥计算私钥在计算上被认为是不可行的，但仅凭输出计算哈希函数的输入同样困难，而且同时做两者则更难。用户共享的是一个*比特币地址*，这是公钥的加密哈希值。事实上，公钥会被使用两种不同的加密哈希函数进行两次哈希处理，从而生成比特币地址。这一额外保护措施确保了通过对比特币地址的任何分析都无法揭示底层的私钥。
- en: Bitcoin uses cryptographic hash functions to accomplish a variety of other important
    tasks as well. Next, you’ll explore the specific cryptographic methods Bitcoin
    uses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用加密哈希函数来完成其他多项重要任务。接下来，你将探讨比特币使用的具体加密方法。
- en: '**Cryptographic Methods Used in Bitcoin**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比特币使用的加密方法**'
- en: '![image](../Images/f0139-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0139-01.jpg)'
- en: Public key cryptography is a high-level framework that can be implemented many
    different ways. You learned how the RSA method, using integers factored into large
    prime numbers, could be used to implement digital signatures. But how are digital
    signatures implemented in Bitcoin? Many different cryptographic hash functions
    exist, and although the MD5 method mentioned earlier is widely used, it is not
    sufficiently secure for a cryptocurrency (collisions have been detected in MD5,
    resulting in two different inputs leading to the same output).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密是一个高级框架，可以通过多种不同的方式实现。你已经了解了如何使用将整数分解为大素数的RSA方法来实现数字签名。那么比特币中的数字签名是如何实现的呢？存在多种不同的加密哈希函数，尽管之前提到的MD5方法被广泛使用，但它对于加密货币来说并不够安全（MD5中已发现碰撞，导致两个不同的输入得到相同的输出）。
- en: SHA256 and RIPEMD160 are the two cryptographic hash functions used in the Bitcoin
    protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SHA256和RIPEMD160是比特币协议中使用的两种加密哈希函数。
- en: '***Cryptographic Hash Functions: SHA256 and RIPEMD160***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密哈希函数：SHA256和RIPEMD160***'
- en: Secure Hash Algorithm (SHA) was developed by the US National Security Agency
    (NSA). Race Integrity Primitives Evaluation Message Digest (RIPEMD) was designed
    in the academic community by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel
    at the Katholieke Universiteit Leuven.^([5](../Text/footnote.html#footnote45))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希算法（SHA）由美国国家安全局（NSA）开发。竞赛完整性原语评估信息摘要（RIPEMD）由汉斯·多贝廷（Hans Dobbertin）、安东·博塞尔（Antoon
    Bosselaers）和巴特·普雷内尔（Bart Preneel）在鲁汶天主教大学（Katholieke Universiteit Leuven）设计。^([5](../Text/footnote.html#footnote45))
- en: The prefixes *SHA* and *RIPEMD* refer to the underlying algorithms, and the
    numerical suffixes 256 and 160 refer to the bit-length of the output. A spectrum
    of other SHA functions, like SHA224 and SHA512, output other bit-length hashes
    as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀*SHA*和*RIPEMD*指的是底层算法，而数字后缀256和160则指示输出的位长。其他SHA函数，如SHA224和SHA512，也会输出不同位长的哈希值。
- en: Both SHA256 and RIPEMD160 are widely used, but the SHA methods are more popular
    and have undergone a higher degree of scrutiny from cryptographers. At the time
    of this writing, nobody has detected a collision in either SHA256 or RIPEMD160,
    which is an important measure of the security of a cryptographic hash function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SHA256和RIPEMD160都被广泛使用，但SHA方法更为流行，并且得到了密码学家更高程度的审查。在本文撰写时，没有人发现SHA256或RIPEMD160中存在碰撞，这是衡量加密哈希函数安全性的重要标准。
- en: 'In the Bitcoin protocol, SHA256 and RIPEMD160 are used together to protect
    the public key used in digital signatures. The SHA256 method is also used for
    the proof-of-work function in Bitcoin mining and as part of the digital signature
    algorithm. Here are some examples of encrypting a sentence with a slight variation
    in both SHA256 and RIPEMD160 (all of the following outputs are in base 16 format):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在比特币协议中，SHA256和RIPEMD160一起用于保护数字签名中使用的公钥。SHA256方法还用于比特币挖矿中的工作量证明功能，以及作为数字签名算法的一部分。以下是使用SHA256和RIPEMD160对一个稍微有变化的句子进行加密的示例（以下所有输出均为16进制格式）：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A completely different result is produced with a single character change:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单一字符的变化，产生了完全不同的结果：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The same happens using RIPEMD160:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RIPEMD160时也会发生相同的情况：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This hash is completely different:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个哈希完全不同：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you’d expect and appreciate in an effective hash function, a minor change
    to the text (capitalizing the word *Island*) completely changes the resulting
    hash value in both methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期待并欣赏的那样，一个有效的哈希函数中，文本中的微小变化（例如将*Island*一词大写）会完全改变两种方法产生的哈希值。
- en: Now that you understand the hash functions Bitcoin uses, let’s discuss the algorithm
    Bitcoin digital signatures use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了比特币使用的哈希函数，让我们讨论比特币数字签名所使用的算法。
- en: '**Crowley and the Unfortunate Jelly-Filled Donut Incident**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**克劳利和不幸的果冻填充甜甜圈事件**'
- en: For the remainder of this chapter, we’ll discuss the details of elliptical curve
    cryptography (ECC). But before we delve into the details of this algorithm, and
    to help you understand the basic concept behind it, let us tell you a story.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章余下的部分，我们将讨论椭圆曲线加密（ECC）的详细信息。但在深入讨论该算法的细节之前，为了帮助你理解其背后的基本概念，让我们给你讲个故事。
- en: '![image](../Images/f0141-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0141-01.jpg)'
- en: One day Crowley was driving through Cryptoville in his car, minding his own
    business, when suddenly, BAM! His car was thrown into the air!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一天，克劳利正在开车穿过加密镇（Cryptoville），悠闲地做着自己的事，突然，砰！他的车被抛向了空中！
- en: '![image](../Images/f0141-02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0141-02.jpg)'
- en: He had been driving by a donut shop that was trying to beat the world record
    for the largest jelly-filled donut. Unfortunately, the bakers miscalculated the
    correct pressure of jelly to inject into the donut, causing the explosion.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 他开车经过了一家甜甜圈店，那家店正在尝试打破世界上最大果冻填充甜甜圈的纪录。不幸的是，面包师傅错误地计算了应该注入甜甜圈的果冻压力，导致了爆炸。
- en: '![image](../Images/f0142-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0142-01.jpg)'
- en: After tumbling through the air, Crowley landed safely and was relieved to realize
    he wasn’t hurt. However, he was a bit shaken from this frightful incident, and
    his car was covered in jelly. Because he had tumbled through the air, he was lost
    and no longer knew where he was in Cryptoville. What was he going to do now?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在空中翻滚了一会儿后，克劳利安全着陆，并松了口气，意识到自己没有受伤。然而，这次可怕的经历让他有些震惊，车上也满是果冻。由于他在空中翻滚过，已经迷失了方向，不再知道自己在加密镇的哪个地方。现在他该怎么办？
- en: '![image](../Images/f0142-02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0142-02.jpg)'
- en: Suddenly, Satoshi stepped out of a nearby house. Quite by accident, Crowley
    had found out where the secretive Satoshi lived!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这时，佐藤从附近的一栋房子里走了出来。克劳利无意中发现了佐藤神秘住所的所在！
- en: '![image](../Images/f0143-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0143-01.jpg)'
- en: Crowley proceeded to explain to Satoshi what had happened to him and his car.
    Satoshi was concerned to hear that Crowley was lost but also a bit relieved because
    it meant that his home address was still a secret.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳利随后向佐藤解释了发生在他和他车上的事情。听到克劳利迷路了，佐藤既感到担忧，也稍微松了口气，因为这意味着他的住址仍然是个秘密。
- en: 'Crowley asked Satoshi to give him a ride home or call a tow truck. But Satoshi
    refused, saying, “If I do either of those things, you’ll be able to figure out
    where you are in Cryptoville, and then you’ll be able to figure out my secret
    home address. Luckily I have another idea: Why don’t you come into my home as
    a guest and enjoy a cup of coffee as you regain your wits from your harrowing
    experience today. I’ll be back in a couple of hours and will then share my plan
    to get you and your car home again.”'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳利请求佐藤载他回家，或者打电话叫拖车。但佐藤拒绝了，他说：“如果我做了其中一件事，你就能知道自己在加密镇的位置，进而推算出我的秘密住址。幸运的是，我还有一个主意：不如你进我家做客，喝杯咖啡，恢复一下因为今天那场惊魂经历而有些混乱的思绪。我过几个小时就回来，到时候再告诉你如何把你和你的车送回家。”
- en: '![image](../Images/f0143-02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0143-02.jpg)'
- en: Sure enough, Satoshi returned to the house after a while carrying an iPod, of
    all things. “OK, Crowley, here’s what I did. I just drove to your house with my
    own car. While doing so, I recorded my drive on this iPod and recorded every action
    as I drove along. When I turned the steering wheel 10 degrees to the left, I said
    this on the recording. If I accelerated from 20 mph to 40 mph, I recorded this
    as well. Everything I did I recorded at the exact time I did it.”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，佐藤过了一会儿后拿着一台 iPod 回到了屋里。“好吧，克劳利，事情是这样。我开着自己的车开到了你家。在这个过程中，我用这台 iPod 记录了我的驾驶过程，每当我做出某个动作时，就在录音中标记出来。比如，当我将方向盘左转
    10 度时，我在录音中说了这一点。如果我从 20 英里每小时加速到 40 英里每小时，我也会记录下来。我所做的每一件事，我都会在准确的时间记录下来。”
- en: 'Crowley then understood the plan: Even though his car was covered in jelly
    and it was impossible for him to see through the windows, he could still follow
    the simple instructions on the tape. After all, his car motor still ran fine,
    and he could see the speedometer on his car’s dashboard. Satoshi added, “It’ll
    be very hard for you to reverse engineer the exact physics of how the car was
    driving based solely on the instructions I recorded on the iPod. Therefore, the
    location of my home will remain unknown to you. However, to make it extra hard,
    I also took a very circuitous route, driving through almost all of Cryptoville
    along the way to your house!”'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳利这时明白了计划：尽管他的车上覆盖着果冻，无法透过窗户看清楚外面，但他仍然可以根据录音带上的简单指示来操作。毕竟，他的车引擎还正常运转，而且他可以看到车内仪表盘上的速度表。佐藤补充道：“仅凭我在
    iPod 上录下的指示，你很难逆向推算出汽车驾驶的精确物理原理。因此，我的家在哪个地方，你永远也不会知道。不过，为了让你更加难以猜出，我还特意绕了一大圈，几乎穿过了整个加密镇，才开到你家！”
- en: '![image](../Images/f0144-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0144-01.jpg)'
- en: But sure enough, using Satoshi’s iPod, Crowley was able to drive his car back
    home without being able to see a thing through his car windows. He simply followed
    the instructions, and when the recording finished, he was back home. He still
    didn’t have the slightest clue where Satoshi lived, and he miraculously avoided
    hitting any pedestrians or other cars in the process!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但果然，使用佐藤的iPod，克劳利能够在看不见车窗外任何事物的情况下将车开回家。他仅仅是跟随指示操作，当录音结束时，他就回到家了。他依然完全不知道佐藤住在哪里，但他奇迹般地避免了撞到行人或其他车辆！
- en: '![image](../Images/f0144-02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f0144-02.jpg)'
- en: 'To thank Satoshi for helping him, Crowley sent Satoshi an email inviting him
    to lasagna at Crowley’s house on Saturday night and asking him to suggest a time
    for dinner. Here is the email Satoshi wrote back:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感谢佐藤的帮助，克劳利给佐藤发了一封电子邮件，邀请他周六晚上到克劳利家吃千层面，并请他提出一个合适的晚餐时间。下面是佐藤的回信：
- en: Thanks Crowley—Dinner sounds great, and I love lasagna! Let’s meet at 9:25 P.M.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢克劳利——晚餐听起来不错，我很喜欢千层面！我们晚上9:25见面吧。
- en: Oh, and to prove that this email is legit, I can tell you that I was on the
    300 block of Main Street driving north at exactly 38.7 mph when the iPod displayed
    9 minutes and 25 seconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，为了证明这封邮件是合法的，我可以告诉你，我当时正开车在Main Street的300号街区，朝北行驶，速度恰好为38.7英里每小时，而iPod显示的是9分钟25秒。
- en: 'Being a stickler for verifying identities, Crowley tested this fact: He first
    had his car (still covered in jelly) towed to the location mentioned in the email
    and then started the iPod at the 9 minute and 25 second mark. Following the instructions
    on the iPod explicitly until they completed, he once again stepped out of the
    car and found he was back at home!'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个严格验证身份的人，克劳利验证了这个事实：他首先让他的车（仍然覆盖着果冻）被拖到电子邮件中提到的位置，然后在9分钟25秒时启动了iPod。按照iPod上的指示明确操作，直到完成，他再次走出车外，发现自己已经回到家了！
- en: 'This silly parable is meant to give you a rough outline of one way you could
    create a digital signature: Imagine that Satoshi’s home address is Satoshi’s private
    key, and Crowley’s home address is the public key. The instructions on an iPod
    are a one-way function that’s difficult to reverse. Using this information, you
    could *sign* an arbitrary message (in this case the number *925*, which corresponds
    to the meeting time). Only the person who knows the private key (Satoshi’s home
    address) could generate this signature.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个愚蠢的寓言旨在给你大致概述一种创建数字签名的方式：假设佐藤的家庭地址是佐藤的私钥，而克劳利的家庭地址是公钥。iPod上的指示是一个难以逆向的单向函数。使用这些信息，你可以*签名*任意消息（在本例中为数字*925*，即会议时间）。只有知道私钥的人（佐藤的家庭地址）才能生成这个签名。
- en: As you’ll see, with ECC, we’ll instead “drive around town” by jumping between
    points on a special two-dimensional curve, which makes it even harder to reverse
    engineer the directions. However, the overall process will remain roughly analogous
    to that in the story.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用ECC时，我们将“绕着城镇开车”，通过在一个特殊的二维曲线上跳跃，从一个点到另一个点，这使得逆向工程这些指令变得更加困难。然而，整个过程仍然大致类似于这个故事中的情节。
- en: '***Moving Around on a Line***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***沿直线移动***'
- en: Before we start thinking about what’s involved in driving around on a curve,
    let’s use an easier scenario and imagine driving around on a line (see [Figure
    7-1](../Text/ch07.html#ch07fig1)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始思考驾驶时如何绕过弯道之前，让我们先用一个更简单的情景，假设是在一条直线上驾驶（见[图7-1](../Text/ch07.html#ch07fig1)）。
- en: 'If we have a straight line that passes through the origin (i.e., the point
    at *x* = 0, *y* = 0), we can create a new point on the line by using two points
    A and B to create a point C by simply adding A and B. Here is the obvious formula
    for adding two points:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一条通过原点的直线（即，*x* = 0，*y* = 0的点），我们可以通过使用两个点A和B来创建一个新点C，只需将A和B相加即可。下面是加法的显而易见公式：
- en: A(*x*[1], *y*[1]) + B(*x*[2], *y*[2]) = C(*x*[3], *y*[3]) *x*[3] = *x*[1] +
    *x*[2] *y*[3] = *y*[1] + *y*[2]
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: A(*x*[1], *y*[1]) + B(*x*[2], *y*[2]) = C(*x*[3], *y*[3]) *x*[3] = *x*[1] +
    *x*[2] *y*[3] = *y*[1] + *y*[2]
- en: 'We need to add the two x-coordinates to get a new *x* (simply 1 + 3 = 4) and
    add the two y-coordinates (also 1 + 3 = 4). Note that we can also use a simple
    geometric trick to generate point C without using arithmetic: Simply start at
    point B and then move at the same angle and amount as point A is from the origin.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将两个x坐标相加，得到一个新的*x*（简单地说，1 + 3 = 4），并将两个y坐标相加（同样是1 + 3 = 4）。请注意，我们也可以使用一个简单的几何技巧来生成点C，而不使用算术：只需从点B开始，然后按与点A从原点的角度和距离相同的方向移动。
- en: '![image](../Images/f07-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-01.jpg)'
- en: '*Figure 7-1: Adding two points (A and B) on a line to get point C*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：将直线上的两点（A 和 B）相加得到点 C*'
- en: For a line, this addition process is very simple but is not useful for cryptography
    (and equally not useful for creating driving instructions for our “car” that are
    hard to reverse engineer). But as you’ll see, the process for adding points is
    very different with elliptical curves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直线，这一加法过程非常简单，但对于加密学而言并不有用（同样，对于创建难以逆向工程的“汽车”行驶指令也没有用）。但正如你将看到的，椭圆曲线上的点加法过程是完全不同的。
- en: '***Elliptic Curve Digital Signature Algorithm (ECDSA)***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***椭圆曲线数字签名算法（ECDSA）***'
- en: Instead of integer factorization-based schemes, digital signatures in Bitcoin
    are based on ECC. Although integer factorization works well in principle, faster
    computers and better algorithms to factor integers have over time increasingly
    required the use of ever larger prime factors to ensure reasonable security. The
    recommended size of encryption keys used for RSA encryption is between 1024 and
    4096 bits. In contrast, elliptic curves offer the same functionality but are not
    affected by advances in factoring integers; therefore, shorter keys can be used
    (a 256-bit key in ECC is believed to offer comparable security to a 1024-bit key
    in an RSA-type scheme). In short, ECC is thought to be stronger than methods based
    on factoring integers for the same key length.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于整数因式分解的方案不同，比特币的数字签名是基于椭圆曲线加密（ECC）。尽管整数因式分解在理论上运作良好，但随着计算机的变得更快，以及用于因式分解整数的算法不断改进，逐渐需要使用更大的质因子来确保合理的安全性。RSA
    加密使用的推荐加密密钥大小在 1024 位和 4096 位之间。相比之下，椭圆曲线提供相同的功能，但不受整数因式分解技术进步的影响；因此，可以使用更短的密钥（在
    ECC 中，256 位密钥被认为提供与 1024 位 RSA 密钥相当的安全性）。简而言之，ECC 被认为比基于整数因式分解的方法在相同密钥长度下更强。
- en: 'Bitcoin uses elliptic curves to create digital signatures, specifically by
    using a protocol called the Elliptic Curve Digital Signature Algorithm (ECDSA).
    An elliptic curve is any two-dimensional curve that satisfies the equation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用椭圆曲线创建数字签名，具体来说，使用一种称为椭圆曲线数字签名算法（ECDSA）的协议。椭圆曲线是任何满足以下方程的二维曲线：
- en: '*y*² = *x*³ + *ax* + *b*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*³ + *ax* + *b*'
- en: A few sample curves that satisfy this equation are shown in [Figure 7-2](../Text/ch07.html#ch07fig2).
    Public/private key pairs are generated by choosing points on these elliptic curves
    that are mathematically related to each other.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些满足此方程的曲线示例显示在[图 7-2](../Text/ch07.html#ch07fig2)中。公钥/私钥对是通过选择位于这些椭圆曲线上的点来生成的，这些点在数学上是相互关联的。
- en: '![image](../Images/f07-02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-02.jpg)'
- en: '*Figure 7-2: Different elliptic curves can be generated using different parameters
    in our starting equation.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：使用我们起始方程中的不同参数可以生成不同的椭圆曲线。*'
- en: As with the property of a straight line, when you add the coordinates of any
    two points on the curve, the result is another point on the curve.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与直线的性质一样，当你将曲线上任何两点的坐标相加时，结果是曲线上的另一个点。
- en: 'However, with elliptic curves *addition* has a special meaning and is defined
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在椭圆曲线中，*加法*有特殊含义，定义如下：
- en: '![image](../Images/e0147-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/e0147-01.jpg)'
- en: Clearly, this formula for adding two points is much more complex than the addition
    formula we used for straight lines. [Figure 7-3](../Text/ch07.html#ch07fig3) shows
    an example elliptic curve with two points A and B and the resulting point C created
    by following these addition rules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，两个点的加法公式比我们用于直线的加法公式要复杂得多。[图 7-3](../Text/ch07.html#ch07fig3)展示了一个示例椭圆曲线，其中有两个点
    A 和 B，通过遵循这些加法规则得到的结果点是 C。
- en: '![image](../Images/f07-03.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-03.jpg)'
- en: '*Figure 7-3: Two points (A and B) on an elliptic curve are added to create
    point C, using our special method of addition.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：通过我们特殊的加法方法，将椭圆曲线上的两个点（A 和 B）相加得到点 C。*'
- en: 'In the example in [Figure 7-3](../Text/ch07.html#ch07fig3), points A and B
    are not special in any way. Choosing different A and B points would lead to a
    different point C ([Figure 7-4](../Text/ch07.html#ch07fig4)), which is the whole
    point of using this type of addition for cryptography: In the earlier jelly donut
    incident, Crowley had to drive a long, circuitous route back to his house so Satoshi’s
    home address would remain obscured. Repeatedly jumping between points on the elliptic
    curve using this method of addition can help you obscure your private key in a
    digital signature system in the same way, as you’ll soon see.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-3](../Text/ch07.html#ch07fig3)的例子中，点A和B没有任何特殊之处。选择不同的A和B点会导致不同的点C（见[图7-4](../Text/ch07.html#ch07fig4)），这就是使用这种加法进行加密的全部意义：在之前的果冻甜甜圈事件中，克劳利不得不绕远路返回家中，以保持中本聪的住址不被暴露。通过这种加法方法在椭圆曲线上反复跳跃，可以帮助你在数字签名系统中模糊你的私钥，就像你很快会看到的那样。
- en: '![image](../Images/f07-04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-04.jpg)'
- en: '*Figure 7-4: When different points A and B are chosen, a different point C
    is created.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：当选择不同的点A和B时，会创建不同的点C。*'
- en: Similar to lines, you can use a geometric trick to calculate the sum of adding
    two points on elliptic curves (i.e., without needing to do the tedious arithmetic).
    Simply draw a line through points A and B, and find another location where the
    line intersects the curve. Then draw a vertical line starting at this point of
    intersection and see where else it crosses the elliptic curve. This second crossing
    is point C ([Figure 7-5](../Text/ch07.html#ch07fig5)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于直线，你可以使用几何技巧来计算在椭圆曲线上两个点的和（即，无需进行繁琐的算术运算）。只需画一条通过点A和B的直线，并找到该直线与曲线的另一个交点。然后，从交点处画一条垂直线，看看它还与椭圆曲线相交的其他位置。第二次交点就是点C（见[图7-5](../Text/ch07.html#ch07fig5)）。
- en: '![image](../Images/f07-05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-05.jpg)'
- en: '*Figure 7-5: Using simple geometry, you can find point C by just drawing a
    line through points A and B and then moving vertically to find point C.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：通过简单的几何方法，你可以通过画一条经过点A和B的直线，再垂直移动来找到点C。*'
- en: A fundamental property of elliptic curves is that any line that intersects at
    least two points must also intersect a third (except for vertical lines and lines
    that are tangent to a point on the curve^([6](../Text/footnote.html#footnote46))).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线的一个基本性质是，任何与至少两个点相交的直线也必须与第三个点相交（除了垂直线和与曲线某点相切的线^([6](../Text/footnote.html#footnote46))）。
- en: 'Of course, if we want to “drive around” our elliptic curve, as in our conceptual
    example involving a car, it’s somewhat awkward that we need two points to generate
    every new point: As with a car, it would be ideal to go from a single point to
    another single point so our “car” only has to be in one place at a time. Fortunately,
    this is possible with elliptic curves as well by using a form of multiplication
    to multiply a point on the curve by an integer, which is the same as adding a
    point to itself multiple times. It might seem like the geometric trick does not
    work in this case. How do you draw a straight line through two points if they
    are in the same place? You can probably guess by imagining what happens when you
    consider adding two points, A and B, that are very close together: The line that
    passes through A and B will resemble the tangent to the curve near those points.
    So when we add A + A (or equivalently, multiply A by 2), we draw a tangent to
    the curve at point A and find where else it intersects. Then we draw a vertical
    line, as before, to find the resulting point, 2A ([Figure 7-6](../Text/ch07.html#ch07fig6)).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想“环绕”我们的椭圆曲线，就像我们在概念性例子中提到的汽车那样，问题就在于我们需要两个点才能生成每个新点：就像汽车一样，理想的情况是从一个点到另一个点，这样我们的“车”就只需在一个地方停留。幸运的是，椭圆曲线也可以通过一种形式的乘法来实现这一点，即将曲线上的一个点与一个整数相乘，这相当于将一个点与自身多次相加。看起来似乎几何技巧在这种情况下不起作用。那么，如果两个点在同一个地方，如何画出一条通过这两个点的直线呢？你可以通过想象当你考虑将两个非常接近的点A和B相加时发生的情况来猜测：通过A和B的直线将类似于这些点附近曲线的切线。因此，当我们将A
    + A（或者等价地，将A乘以2）时，我们会画出在点A处的切线，并找到它与曲线的其他交点。然后，我们像之前一样画一条垂直线，以找到结果点2A（见[图7-6](../Text/ch07.html#ch07fig6)）。
- en: '![image](../Images/f07-06.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-06.jpg)'
- en: '*Figure 7-6: With only one starting point, we can point multiply by 2 by using
    the tangent line through point A.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：仅通过一个起始点，我们可以使用通过点A的切线将其乘以2。*'
- en: To calculate 3A, you first calculate 2A, as we just did, and then adding an
    additional A is just like adding any two nonoverlapping points. In elliptic curve
    terminology, calculating *k*A, where *k* is an arbitrary integer, is called point
    multiplication. Calculating *k*A for large values of *k* is computationally expensive
    without efficient implementations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算3A，你首先计算2A，就像我们刚才做的那样，然后再加上一个A就像加两个不重叠的点。在椭圆曲线术语中，计算*k*A，其中*k*是任意整数，称为点乘法。对于大的*k*值，计算*k*A在没有高效实现的情况下是计算密集型的。
- en: So as with our conceptual example, we’ll now use point multiplication to “drive”
    from one point on the curve to another. In ECC, point multiplication is used to
    generate the public key from the private key. However, there will be one important
    difference between our jelly-filled donut story and how ECC really works. In our
    story, Satoshi’s house represented a private key and Crowley’s house a public
    key, but in ECC the starting point and destination point are *both* publicly known—it
    is only the path between them that is secret. So it is in fact the *path* that
    is the private key; the destination point is the public key (as it was before),
    and the starting point is simply a standard location that everyone agrees to use.
    In ECC it’s as if Satoshi’s home address were widely known to be in the center
    of a very complex labyrinth—everyone knows where he lives, but no one knows how
    to get there. Given a previously agreed-upon point on the curve, G, and a private
    key, *d*, the public key, Q, is calculated by point multiplication such that Q
    = *d*G. Note that the public key is a point on the curve but the private key is
    just an integer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们的概念性例子一样，我们现在将使用点乘法来“驱动”从曲线上的一个点到另一个点。在椭圆曲线加密（ECC）中，点乘法用于从私钥生成公钥。然而，我们的果冻夹心甜甜圈故事与ECC实际工作方式之间将有一个重要的区别。在我们的故事中，佐藤的房子代表了私钥，而克劳利的房子代表了公钥，但在ECC中，起始点和目标点是*公开*已知的——只有它们之间的路径是保密的。因此，实际上是*路径*是私钥；目标点是公钥（就像之前一样），而起始点只是一个大家一致同意使用的标准位置。在ECC中，就好像佐藤的家庭住址广为人知，位于一个非常复杂的迷宫的中心——每个人都知道他住在哪里，但没有人知道如何到达那里。给定一个之前约定的曲线上的点G和一个私钥*d*，公钥Q通过点乘法计算得出，满足Q
    = *d*G。请注意，公钥是曲线上的一个点，而私钥只是一个整数。
- en: So far we’ve been depicting elliptic curves as smooth, continuous functions
    that extend into infinity. However, computers have limited memory, and it isn’t
    possible to use real-valued numbers as coordinates for points on the curve without
    introducing rounding errors (which are unacceptable in cryptography). For practical
    implementations, only integer-valued points on elliptic curves are allowed, and
    modular arithmetic is used to keep all of the points within certain bounds (from
    0 to 512, for example). This technique of using only integer-valued points is
    best illustrated with an example. Let’s first choose the same elliptic curve that
    Bitcoin uses, which is called a *Koblitz curve* ([Figure 7-7](../Text/ch07.html#ch07fig7)),
    using the parameters *a* = 0 and *b* = 7.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将椭圆曲线描绘为平滑、连续的函数，延伸到无限远。然而，计算机的内存是有限的，不能使用实数作为曲线上点的坐标而不引入舍入误差（在密码学中这是不可接受的）。对于实际应用，只允许使用整数值的椭圆曲线上的点，并且使用模运算将所有点限制在某些边界内（例如，从0到512）。这种只使用整数值点的技术通过一个例子最为形象。让我们首先选择比特币使用的相同椭圆曲线，这条曲线叫做*Koblitz曲线*（[图7-7](../Text/ch07.html#ch07fig7)），使用参数*a*
    = 0和*b* = 7。
- en: '![image](../Images/f07-07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-07.jpg)'
- en: '*Figure 7-7: A Koblitz curve*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：一个Koblitz曲线*'
- en: 'We then choose a prime modulo *p* so that the elliptic curve satisfies this
    equation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择一个质数模*p*，使得椭圆曲线满足这个方程：
- en: '*y*² = *x*² + *ax* + *b*(mod*p*)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*² + *ax* + *b*(mod*p*)'
- en: '**NOTE**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this type of math notation, the modulo operation is performed after the
    additions so first you calculate* x*²* + ax + b *and then you perform mod* p *on
    the result.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这种数学符号中，模运算是在加法之后执行的，所以你首先计算* x*²* + ax + b*，然后对结果执行模* p*运算。*'
- en: Bitcoin uses a very large *p* value (specifically *p* = 2^(256) − 2^(32) − 2⁹
    − 2⁸ − 2^([7](../Text/footnote.html#footnote47)) − 2⁶ − 2⁴ − 1), which is important
    for cryptographic strength, but we can use a smaller number to illustrate how
    “driving around on integer-valued points on a Koblitz curve” works. Let’s choose
    *p* = 67\. In fact, many curves satisfy the modular equation (namely, every curve
    where *p* is added to or subtracted from the *b* parameter any number of times;
    see the left-hand chart in [Figure 7-8](../Text/ch07.html#ch07fig8)), and from
    those curves we can use all of the points that have integer-valued coordinates
    (shown in [Figure 7-8](../Text/ch07.html#ch07fig8) as dots).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f07-08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: On the left is a standard picture of the elliptic curve in the
    form we’re familiar with (the bold curve) with additional curves that are drawn
    by using other multiples of* p *(the thin curves.) On the right, we’ve taken a
    larger section of the coordinate plane that is an expansion of the upper-right
    quadrant. This is the section of the curve that is most convenient when using
    the integer-based variant of ECC.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Given the choice of *p* = 67, only 79 unique points with integer-valued coordinates
    exist, and 78 of them can be found in the upper-right quadrant from 0 < *x* <
    66 and 0 < *y* < 66 (shown in the chart on the right in [Figure 7-8](../Text/ch07.html#ch07fig8);
    note that the left chart shows the entire range). The number of unique points,
    *n,* is called the *order* of the curve. The 79th point is the *zero* point, which
    is not at (0,0) as you might expect but rather is the point at *y* = infinity.
    The zero point is important because it is valid output from an addition or point
    multiplication operation and therefore needs to be carefully accounted for (see
    the sample code in “[Pseudocode for Elliptic Point Summation and Point Multiplication](../Text/ch07.html#ch00leve1sec109)”
    on [page 158](../Text/ch07.html#page_158)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As a last step before we can generate public/private key pairs, we need to choose
    one of the 79 points to be a *generator* point, G. The generator needs to have
    the property that one can calculate every one of the other 78 points by multiplying
    G by some integer, *k* (i.e., so you can *generate* every point by calculating
    G, 2G, 3G, ..., 79G). If we choose the point (5,47) as our generator point, we
    can check whether by successively incrementing *k* we can travel to every point
    in the set (see [Figure 7-9](../Text/ch07.html#ch07fig9)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f07-09.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: On the left, starting with point G, we multiply G successively
    to create new points at 2G, 3G, and 4G. On the right, you see what happens when
    this multiplication is repeated even further.*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If the order of the curve is prime (i.e., there is a prime number of points),
    any point except the zero point works equally well as a generator. If the order
    is not prime, regardless of the *k* value, some points will travel only to a subset
    of points (which can lead to a reduction in cryptographic strength). In our case,
    we can safely use the point (5,47) because it generates all the other 78 points
    (as depicted in the chart in [Figure 7-9](../Text/ch07.html#ch07fig9)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果曲线的阶是素数（即有素数个点），则除零点外的任何点都可以作为生成点。如果阶不是素数，则无论*k*值如何，某些点只会遍历到部分点（这可能会导致加密强度的下降）。在我们的案例中，我们可以安全地使用点（5,47），因为它可以生成其他所有78个点（如[图7-9](../Text/ch07.html#ch07fig9)所示）。
- en: To return to our conceptual car example, point G in this figure could be Satoshi’s
    house and point 4G, for example, could be Crowley’s house. The points between
    represent the complicated drive through Cryptoville. Until you carry out the point
    multiplication operation, it certainly isn’t obvious what the path from G to 4G
    is. The 4 in 4G gives away the answer, namely that the path connecting those points
    can be found by taking three steps from G. However, if G and 4G were instead labeled
    A and B, it would take a long time to guess how to get from one to the other.
    In other words, if you know only the start and end points (i.e., the public key),
    it would take a long time to guess the path (i.e., the private key). But if you
    know the starting point and the path, then calculating the end point is easy.
    In terms of Bitcoin, it means that if someone knows the Bitcoin address that contains
    your money (which is based on the public key), it is still impossible for that
    person to figure out your private key to spend the bitcoins at that address.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们概念上的汽车示例，图中的点G可能是佐藤的家，点4G则可能是克劳利的家。两点之间的部分代表了穿越加密城（Cryptoville）的复杂旅程。在执行点乘运算之前，从G到4G的路径显然并不直观。4G中的4透露了答案，也就是说，连接这两点的路径可以通过从G出发走三步来找到。然而，如果G和4G被标记为A和B，则可能需要很长时间才能猜出如何从一个点到达另一个点。换句话说，如果你只知道起点和终点（即公钥），则很难猜出路径（即私钥）。但是，如果你知道起点和路径，那么计算终点就很容易了。就比特币而言，这意味着即使某人知道包含你资金的比特币地址（这是基于公钥的），他也无法通过该地址推算出你的私钥来花费这些比特币。
- en: '***Signing a Bitcoin Transaction Using ECDSA***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用ECDSA签署比特币交易***'
- en: Now that we’ve chosen *p*, *a, b,* and G and determined the order, *n*, we have
    all the information we need to create a public/private key pair following the
    steps in [Table 7-5](../Text/ch07.html#ch07table5).⁷
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了*p*、*a*、*b*和G，并确定了阶*n*，我们拥有了创建公钥/私钥对所需的所有信息，可以按照[表7-5](../Text/ch07.html#ch07table5)中的步骤进行操作。⁷
- en: '**Table 7-5:** Creating a Public/Private Key Pair with ECDSA, Assuming *p*
    = 67, *a* = 0, *b* = 7, G = (5,47), *n* = 79'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-5：** 使用ECDSA创建公钥/私钥对，假设*p* = 67，*a* = 0，*b* = 7，G = (5,47)，*n* = 79'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **说明** | **示例** |'
- en: '| 1 | Generate a private key, *d*, which can be any integer from 1 to (*n*
    − 1). It should be hard to guess. This can be done using a random number generator
    or other clever means.^* | *d* = Random # from 1 to 78Choose *d* = 13. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 生成私钥*d*，它可以是从1到(*n* − 1)之间的任何整数。私钥应该难以猜测。可以使用随机数生成器或其他巧妙的方法来生成。^* | *d*
    = 从1到78的随机数选择*d* = 13。 |'
- en: '| 2 | Generate a public key, Q, by point multiplication of the private key,
    *d*, and the generator point, G. Note that this is a one-way calculation. It is
    very hard to determine *d* given G and Q. | Q = *d* × G= 13 × (5,47)= (7,22)(see
    [Figure 7-10](../Text/ch07.html#ch07fig10)) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 通过将私钥*d*与生成点G进行点乘，生成公钥Q。请注意，这是一种单向计算。给定G和Q，很难确定*d*的值。 | Q = *d* × G =
    13 × (5,47) = (7,22)（见[图7-10](../Text/ch07.html#ch07fig10)） |'
- en: '* A clever way to generate a seemingly random but memorable private key is
    by coming up with a passphrase (i.e., *Crowley and Satoshi sitting in a tree*)
    and feeding it into a cryptographic hash function, which outputs an integer. This
    is called using a brainwallet. Because there are just slightly fewer than 2^(256)
    points on the curve Bitcoin uses (because the *p* value is much higher than the
    one we are using), brainwallets can use the SHA256 hash function (due to its 256-bit
    output).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '* 一种巧妙的生成看似随机但易于记忆的私钥的方法是通过构造一个口令短语（即*克劳利和佐藤坐在树上*），然后将其输入到加密哈希函数中，输出一个整数。这被称为使用脑钱包（brainwallet）。由于比特币使用的曲线上的点数略少于2^(256)（因为*p*值比我们使用的要大得多），脑钱包可以使用SHA256哈希函数（因为它的输出是256位的）。'
- en: '![image](../Images/f07-10.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f07-10.jpg)'
- en: '*Figure 7-10: Here are the 13 points we “drive through” as we point multiply
    to create a digital signature.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：以下是我们在进行点乘以创建数字签名时“经过”的13个点。*'
- en: 'Now let’s look at how we sign messages with our private and public keys (or
    Bitcoin transactions): The receiver of our message will need all the values we
    have calculated so far except the private key, namely *p*, *a*, *b*, G, *n*, and
    Q, in order to verify that the signature is valid. Let’s assume that our message
    is this: *Please update the blockchain so that 5 bitcoins from Crowley are given
    to Satoshi*. The steps to sign the message are listed in [Table 7-6](../Text/ch07.html#ch07table6).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何使用我们的私钥和公钥（或者比特币交易）来签名消息：接收者需要我们至今为止计算出的所有值，除了私钥，即 *p*、*a*、*b*、G、*n*
    和 Q，以验证签名的有效性。假设我们的消息是：*请更新区块链，将5个比特币从Crowley转给Satoshi*。签名消息的步骤列在[表7-6](../Text/ch07.html#ch07table6)中。
- en: '**Table 7-6:** Signing a Message with ECDSA, Assuming *p* = 67, *a* = 0, *b*
    = 7, G = (5,47), *n* = 79, *d* = 13'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-6：** 使用ECDSA签名消息，假设 *p* = 67，*a* = 0，*b* = 7，G = (5,47)，*n* = 79，*d* =
    13'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **指令** | **示例** |'
- en: '| 1 | Calculate the hash of the message, *h*. The Bitcoin protocol uses the
    SHA256 function for this purpose. The output of the hash needs to be less than
    *n*, so we need to calculate *h* = SHA256(*message*) (mod *n*). | *h* = SHA256(“Please
    update the blockchain so that 5 bitcoins from Crowley are given to Satoshi”) (mod
    79)= 46 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 计算消息的哈希值 *h*。比特币协议使用SHA256函数来实现此目的。哈希的输出需要小于 *n*，因此我们需要计算 *h* = SHA256(*message*)
    (mod *n*)。 | *h* = SHA256(“请更新区块链，将5个比特币从Crowley转给Satoshi”)(mod 79) = 46 |'
- en: '| 2 | Choose a random integer, *k*, between 1 and (*n* − 1). | *k* = Random
    integer from 1 to 78 Choose *k* = 6. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 选择一个介于1和(*n* − 1)之间的随机整数 *k*。 | *k* = 从1到78的随机整数 选择 *k* = 6。 |'
- en: '| 3 | Calculate the point (*r*,*s**) = *k*G. | (*r*,*s**) = *k* × G = 6 × (5,47)=
    (46,27) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 计算点 (*r*, *s**) = *k*G。 | (*r*, *s**) = *k* × G = 6 × (5,47) = (46,27)
    |'
- en: '| 4 | Find *s* such that *s* × *k* (mod *n*) = (*h* + (*r* × *d*)) (mod *n*).The
    signature is the pair of numbers (*r*,*s*) (not a point on the elliptic curve
    unless by coincidence). | Left side:*s* × *k* (mod *n*)= *s* × 6 (mod 79)Right
    side:(*h* + (*r* × *d*)) (mod *n*)= (46 + (46 × 13)) (mod 79)= 12Left = Right
    when *s* = 2 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 找到 *s* 使得 *s* × *k* (mod *n*) = (*h* + (*r* × *d*)) (mod *n*)。签名是数字对
    (*r*, *s*)（除非巧合，否则不是椭圆曲线上的点）。 | 左边：*s* × *k* (mod *n*) = *s* × 6 (mod 79) 右边：(*h*
    + (*r* × *d*)) (mod *n*) = (46 + (46 × 13)) (mod 79) = 12 左边 = 右边，当 *s* = 2 时
    |'
- en: When the message is signed, the receiver will need *p*, *a*, *b*, *n*, G, Q,
    and the signature pair (*r*,*s*) (and the message, of course). However, the parameters
    *p*, *a*, *b*, *n*, and G are standard to the Bitcoin protocol and therefore don’t
    need to be shared with every transaction. The only information specific to your
    message that needs to be shared is Q, (*r,s*), and the message. The message recipient
    can verify that you signed the message with your private key by using the steps
    in [Table 7-7](../Text/ch07.html#ch07table7).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息被签名时，接收者将需要 *p*、*a*、*b*、*n*、G、Q 和签名对 (*r*, *s*)（当然还有消息）。然而，*p*、*a*、*b*、*n*
    和 G 是比特币协议的标准参数，因此不需要与每个交易共享。唯一需要共享的特定于您消息的信息是 Q、(*r*, *s*) 和消息。消息接收者可以使用[表7-7](../Text/ch07.html#ch07table7)中的步骤来验证您是否用私钥签署了消息。
- en: '**Table 7-7:** Verifying a Signature with ECDSA, Assuming the Receiver Gets
    Q = (7,22), (*r* = 46, *s* = 2), and the message'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-7：** 使用ECDSA验证签名，假设接收者得到了Q = (7,22)，(*r* = 46，*s* = 2) 和消息'
- en: '| **Step** | **Instruction** | **Example** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **指令** | **示例** |'
- en: '| 1 | Repeat the hash calculation of the message to get the hash:*h* = SHA256(*message*)
    (mod *n*) | *h* = SHA256(“Please update the blockchain so that 5 bitcoins from
    Crowley are given to Satoshi”)(mod 79)= 46 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 重复计算消息的哈希值以获得哈希：*h* = SHA256(*message*) (mod *n*) | *h* = SHA256(“请更新区块链，将5个比特币从Crowley转给Satoshi”)(mod
    79) = 46 |'
- en: '| 2 | Find *w* such that *w* × *s* (mod *n*) = 1 (*w* is called the *modular
    inverse* of *s*). | *w* × *s* (mod *n*) = 1*w* × 2 (mod 79) = 1, *w* → 40 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 找到 *w* 使得 *w* × *s* (mod *n*) = 1 (*w* 是 *s* 的 *模逆*)。 | *w* × *s* (mod
    *n*) = 1 *w* × 2 (mod 79) = 1, *w* → 40 |'
- en: '| 3 | Calculate *u* = *h* × *w* (mod *n*). | *u* = *h* × *w* (mod *n*)= 46
    × 40 (mod 79)= 23 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 计算 *u* = *h* × *w* (mod *n*)。 | *u* = *h* × *w* (mod *n*) = 46 × 40 (mod
    79) = 23 |'
- en: '| 4 | Calculate *v* = *r* × *w* (mod *n*) (if *u* and *v* are the same, it
    is just a coincidence). | *v* = *r* × *w* (mod *n*)= 46 × 40 (mod 79)= 23 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 计算 *v* = *r* × *w* (mod *n*)（如果 *u* 和 *v* 相同，那只是巧合）。 | *v* = *r* × *w*
    (mod *n*) = 46 × 40 (mod 79) = 23 |'
- en: '| 5 | Calculate (*tx*,*ty*) = *u*G + *v*Q. | (*tx*,*ty*) = *u* × G + *v* ×
    Q= 23 × (5,47) + 23 × (7,22)= (11,47) + (2,22) = (46,27) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 计算 (*tx*,*ty*) = *u*G + *v*Q。 | (*tx*,*ty*) = *u* × G + *v* × Q= 23 ×
    (5,47) + 23 × (7,22)= (11,47) + (2,22) = (46,27) |'
- en: '| 6 | If *tx* = *r,* the signature is valid. | *tx* = 46, *r* = 46, signature
    is valid |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 如果 *tx* = *r*，则签名有效。 | *tx* = 46, *r* = 46，签名有效 |'
- en: 'In our car example, we were able to *sign messages* in a similar way by relating
    a message to a point that the car passed as it traveled toward its destination.
    However, this is where this analogy reaches its limits: In the car example, providing
    information about where the car traveled conveys some clues as to the path the
    car took, compromising the secret of Satoshi’s address a bit. Using the math in
    [Table 7-7](../Text/ch07.html#ch07table7) shows that signing a document does not
    provide any useful information that compromises the private key. We can sign as
    many documents as we want, and the private key will continue to remain fully obscured.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的汽车示例中，我们通过将消息与汽车行驶到目的地途中经过的一个点关联，能够以类似的方式*签名消息*。然而，这里是这个类比的局限所在：在汽车示例中，提供汽车行驶路径的某些信息会泄露出一些关于汽车行驶路径的线索，从而稍微泄露了中本聪地址的秘密。使用[表
    7-7](../Text/ch07.html#ch07table7)中的数学公式可以证明，签署一份文档并不会提供任何有用的信息，因而不会泄露私钥。我们可以签署任意多的文档，而私钥将继续保持完全隐匿。
- en: So this is how bitcoins are spent. When you sign a Bitcoin transaction with
    your private key, other nodes in the Bitcoin network can check that your signature
    is valid (by matching your public key and the contents of the transaction) and
    safely know you authorized it. Of course, if your private key falls into the wrong
    hands, someone else can sign transactions and steal your bitcoins.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是比特币是如何被花费的。当你用私钥签署比特币交易时，比特币网络中的其他节点可以检查你的签名是否有效（通过匹配公钥和交易内容），并安全地确认是你授权了该交易。当然，如果你的私钥落入不法分子之手，别人就可以签署交易并窃取你的比特币。
- en: Note that until you actually need to spend bitcoins, there is no need to share
    the public key. Although in principle sharing your public key far in advance of
    signing a transaction should be no problem, it’s possible that a weakness in ECC
    will be discovered that could allow an attacker with enough time and computing
    power to figure out your private key from your public key (i.e., figure out *d*,
    given G and Q in the equation Q = *d*G). So why give an attacker the extra time
    if it isn’t necessary? If an attacker doesn’t know your public key, the ability
    to determine your private key is drastically reduced. For this reason, Bitcoin
    users share *addresses* instead of public keys.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，直到你真正需要花费比特币时，才需要分享公钥。虽然原则上提前分享公钥在签署交易时应该没有问题，但有可能会发现 ECC 中的某个弱点，攻击者只要有足够的时间和计算能力，就能从公钥推算出私钥（即给定方程
    Q = *d*G 中的 G 和 Q，推算出 *d*）。那么，为什么如果不必要要给攻击者额外的时间呢？如果攻击者不知道你的公钥，那么推算出私钥的能力会大大降低。出于这个原因，比特币用户共享的通常是*地址*而不是公钥。
- en: The Bitcoin address described at length earlier in this book is actually a hash
    of the public key, using the SHA256 and RIPEMD160 hash functions. The public key
    is first input into the SHA256 hash function, and then the output is fed as input
    into the RIPEMD160 hash function. The resulting double hash is used to generate
    the Bitcoin address in a standard way.^([8](../Text/footnote.html#footnote48))
    When you spend bitcoins from a Bitcoin address, you must provide your public key,
    and others can check that the public key corresponds to the Bitcoin address by
    repeating the same double hash calculation (and of course, the signature proves
    that you have the private key).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前面详细描述的比特币地址实际上是公钥的哈希值，使用 SHA256 和 RIPEMD160 哈希函数生成。首先，将公钥输入 SHA256 哈希函数，然后将输出作为输入传递给
    RIPEMD160 哈希函数。最终得到的双重哈希值以标准方式生成比特币地址。^([8](../Text/footnote.html#footnote48))
    当你从比特币地址花费比特币时，你必须提供你的公钥，其他人可以通过重复相同的双重哈希计算来检查公钥是否与比特币地址对应（当然，签名证明了你拥有私钥）。
- en: In cryptography, the double hash scheme results in extremely strong security.
    Given only a Bitcoin address, it would require a simultaneously discovered weakness
    in three different cryptographic methods—SHA256, RIPEMD160, and ECDSA—for an attacker
    to guess a private key. If a weakness was discovered in one method but not the
    others, there would be time to update the cryptographic methods used in Bitcoin
    before anyone’s bitcoins were at risk.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密学中，双重哈希方案产生了极其强大的安全性。仅凭一个比特币地址，攻击者想要猜测私钥，需要同时在三种不同的加密方法——SHA256、RIPEMD160和ECDSA——中发现弱点。如果其中一种方法发现了弱点，而其他方法没有问题，那么在任何人的比特币面临风险之前，会有时间更新比特币使用的加密方法。
- en: '**The Security of Bitcoin’s Cryptography**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比特币加密技术的安全性**'
- en: A common anxiety among those new to Bitcoin is to wonder whether the cryptography
    used in Bitcoin is secure enough to protect against threats. Could a big, powerful
    government with huge computing resources break Bitcoin’s cryptography? What about
    a very clever hacker who might bring down the entire system? What about super
    powerful computers of the future, like quantum computers?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚接触比特币的人来说，一个常见的焦虑是，是否比特币所使用的加密技术足够安全，能够抵御威胁。一个拥有强大计算资源的大型政府是否能够破解比特币的加密技术？一个非常聪明的黑客是否能摧毁整个系统？未来的超级强大计算机，比如量子计算机，又如何呢？
- en: These are healthy concerns to have when a person is deciding whether Bitcoin
    is a sound protocol and worth investing in. Every Bitcoin private key is some
    number between 1 and 2^(256), and *in principle* a computer could continue generating
    numbers billions or trillions of times per second until it found one that could
    access your bitcoins. However, 2^(256) is a *very* big number; in fact, it’s approximately
    10^(77) or a 1 with 77 zeroes behind it. Putting that in perspective, approximately
    10^(50) atoms make up the earth. If you chose a single atom in the earth at random,
    and then chose a second atom, also at random, the odds that you picked the same
    atom twice would be *significantly* greater than randomly guessing someone’s private
    key.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是当一个人在决定比特币是否是一个稳健的协议以及是否值得投资时，应该有的健康担忧。每个比特币私钥都是介于1和2^(256)之间的一个数字，*理论上*，计算机可以继续生成数十亿次、数万亿次的数字，直到找到一个能够访问你比特币的数字。然而，2^(256)是一个*非常*大的数字；实际上，它大约是10^(77)，即一个后面跟着77个零的数字。换个角度看，地球上的原子大约是10^(50)个。如果你随机选择一个地球上的原子，然后再随机选择第二个原子，那么你选择到同一个原子的概率将会*显著*高于随机猜测某人的私钥。
- en: Could an extremely powerful computer, based on futuristic technology that is
    yet to be invented, guess a private key? Theoretical physicists have estimated
    that the smallest amount of energy to perform the simplest computation (changing
    a 0 to a 1 or vice versa) requires at least 3 × 10^(−21) joules (this is known
    as the Landauer limit^([9](../Text/footnote.html#footnote49))). A computer that
    used this amount of energy per computation would theoretically be the most efficient
    computer allowed by the laws of thermodynamics. If you then could harness 100
    percent of the energy of the sun (not just the tiny fraction that falls on the
    earth, but the entire amount, by building a sphere of perfect solar panels surrounding
    the entire star), with no losses, you could theoretically capture 10^(34) joules
    per year. If you harvested that energy for 100 years and fed all of it into your
    maximally efficient computer designed for the single purpose of guessing someone’s
    Bitcoin private key, it would be able to perform only 10^(55) computations. Of
    course, calculating a private key is more complicated than flipping a 0 into a
    1, but even if we assume that this computer could calculate 10^(55) private keys,
    it would run out of energy before it would even have onetrillionth of a chance
    of correctly guessing yours.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于尚未发明的未来技术的超级强大计算机，能否猜出一个私钥？理论物理学家估算出，执行最简单计算（将0变成1或反之）所需的最少能量是至少3 × 10^(−21)
    焦耳（这被称为兰道限制^([9](../Text/footnote.html#footnote49))）。一个每次计算都使用这种能量的计算机，理论上将是热力学定律允许的最有效计算机。如果你能够利用太阳的100%能量（不仅仅是落在地球上的那小部分，而是整个太阳的能量，假设你建造一个完全包围太阳的完美太阳能面板球体），而且没有任何损耗，你理论上每年能够捕获10^(34)焦耳的能量。如果你用这笔能量持续100年，并将所有能量都输入到这个为单一目的（猜测某人比特币私钥）设计的最高效计算机中，它理论上只能执行10^(55)次计算。当然，计算私钥比翻转0为1要复杂，但即便我们假设这台计算机可以计算10^(55)个私钥，它也会在甚至没有一万亿分之一的机会正确猜中之前就用完能量。
- en: In summary, it is physically impossible, independent of future technological
    developments, to create a computer that could steal bitcoins by randomly guessing
    private keys. However, that does not eliminate the concern that a weakness exists
    in the cryptographic methods that Bitcoin uses. Perhaps it is easier than we think
    to work backward from a Bitcoin address to calculate the underlying private key.
    Here, it is important to note that the cryptographic methods used by Bitcoin are
    standard methods used by governments and major corporations to ensure security
    in communications, financial transactions, and network security. If a weakness
    exists in the methods that Bitcoin uses, a weakness exists in the methods the
    entire world uses.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，无论未来技术如何发展，物理上是不可能创造出一台通过随机猜测私钥窃取比特币的计算机。然而，这并不能消除一个担忧，即比特币使用的加密方法中可能存在某种弱点。也许像我们想象的那样，通过比特币地址反向推算出私钥并不那么困难。在这里，重要的是要注意，比特币使用的加密方法是政府和大公司用于确保通信、金融交易和网络安全的标准方法。如果比特币所使用的加密方法存在弱点，那么全世界所使用的方法也就存在弱点。
- en: Also, if weaknesses *are* discovered in the cryptographic standards, such that
    new methods need to be used, it is possible to update the methods that Bitcoin
    uses without affecting how Bitcoin functions. A new version of the SHA256 algorithm
    may be used in the future, or ECDSA might be replaced with a different digital
    signature algorithm. However, Bitcoin’s reliance on cryptography in general will
    not change.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果发现加密标准存在*弱点*，需要使用新的方法，则可以在不影响比特币功能的前提下更新比特币使用的方法。未来可能会使用SHA256算法的新版本，或者ECDSA可能会被替换为其他数字签名算法。然而，比特币对加密技术的依赖总体上不会改变。
- en: The bottom line is that Bitcoin’s cryptography has a solid technical foundation.
    If a hacker ever does steal your bitcoins, it is far more likely the hacker would
    do so by finding a bug in a *specific implementation* of this cryptography that
    is flawed or by using the many other ways we’ve discussed, such as simply stealing
    your private key through a computer virus. It is far less likely that a hacker
    would be able to steal your money by finding a flaw in the mathematics of the
    cryptography.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结论是，比特币的加密技术具有坚实的技术基础。如果黑客真的窃取了你的比特币，更可能的情况是，黑客是通过发现*特定实现*中的加密漏洞，或者通过我们讨论过的其他方法（例如通过计算机病毒窃取你的私钥）来实现的。黑客通过发现加密数学原理中的漏洞来窃取你的资金的可能性要小得多。
- en: '**Pseudocode for Elliptic Point Summation and Point Multiplication**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**椭圆曲线点加法和点乘法的伪代码**'
- en: 'To follow along with the elliptic curve digital signature examples earlier
    in the chapter, you’ll need to be able to correctly calculate elliptic point summations
    and point multiplication operations using modular arithmetic. Pseudocode for the
    implementation of these operations follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章早些时候提到的椭圆曲线数字签名示例，你需要能够使用模运算正确地计算椭圆点加法和点乘法操作。以下是这些操作实现的伪代码：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this elliptic curve point summation (ECPS) pseudocode, which allows you to
    add two points on the elliptic curve to generate a third point, we first check
    whether A or B is the zero point ➊ (recall that this is the single weird point
    that’s part of an elliptic curve that is essentially at infinity). Next, we handle
    the typical case where two points have different *x* locations, and we don’t need
    to worry about the slope between the points being divided by zero ➋. Then, we
    handle the case where the slope is indeed zero, which forces C to be at the zero
    point ➌. Finally, we handle the case where A and B are the same, in which case
    we need to calculate the answer differently using a mathematical derivative to
    calculate C using the point’s tangent line ➍.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个椭圆曲线点加法（ECPS）伪代码中，它允许你将椭圆曲线上的两个点相加以生成第三个点，我们首先检查A或B是否是零点 ➊（回想一下，这是椭圆曲线上的唯一特殊点，本质上位于无限远处）。接下来，我们处理两个点具有不同*
    x *位置的典型情况，并且我们不需要担心点之间的斜率被零除 ➋。然后，我们处理斜率确实为零的情况，这迫使C位于零点 ➌。最后，我们处理A和B相同的情况，在这种情况下，我们需要使用数学导数来计算C，通过点的切线来计算
    ➍。
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For elliptic curve multiplication, we simply run the ECPS function repeatedly
    ➊. This is really inefficient! In fact, this method of point multiplication is
    so inefficient that it ceases to be a “one-way” function. It is just as computationally
    difficult to calculate the public key (knowing the private key) as it is to guess
    the private key (knowing the public key). For the small number of points we were
    using in this chapter, it’s fine to use our bruteforce approach, but for practical
    applications, more efficient schemes for point multiplication need to be used.
    We leave this as an exercise for the reader.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于椭圆曲线乘法，我们只需重复运行ECPS函数➊。这是非常低效的！实际上，这种点乘法的方法低效到，已不再是一个“单向”函数。计算公钥（已知私钥）和猜测私钥（已知公钥）同样困难。对于本章使用的少量点，使用我们这种暴力破解的方法是可以的，但在实际应用中，需要采用更高效的点乘法方案。我们将此留作读者的练习。
