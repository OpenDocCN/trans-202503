<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="267" id="Page_267"/>17</span><br/>
<span class="ChapterTitle">Modular Programming</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">So far we’ve been working with small, simple one-file programs, which is fine if all you’re going to do is write sample programs for a book. In the real world, however, you’re probably going to encounter programs with more than 50 lines in them.</p>
<p>The Linux kernel has 33,000 files and 28 million lines of code (and those numbers are increasing as you are reading this). You can’t deal with that amount of information without organizing it by dividing up the code into <em>modules</em>.</p>
<p>A module ideally is a single file containing a collection of data and functions that does one thing well with minimum interaction with other modules. We’ve already used the STM HAL collection of modules earlier in this book, including the module containing the <code>HAL_Init</code> function. It does a lot of work internally, but we never see it. We see only a simple module that does one thing well: it initializes all the stuff needed to get the hardware to work.</p>
<h2 id="h1-501621c17-0001"><span epub:type="pagebreak" title="268" id="Page_268"/>Simple Modules</h2>
<p class="BodyFirst">Let’s create a program that uses two files. The main program will be called <em>main.c</em> (see <a href="#listing17-1" id="listinganchor17-1">Listing 17-1</a>) and will call a function in the <em>func.c</em> file (see <a href="#listing17-2" id="listinganchor17-2">Listing 17-2</a>). We’ll use a makefile (see <a href="#listing17-3" id="listinganchor17-3">Listing 17-3</a>) to compile the two files into one program.</p>
<p class="CodeLabel"><b>main.c</b></p>
<pre><code>/**
 * Demonstrate the use of extern.
 * @note: Oversimplifies things.
 */
#include &lt;stdio.h&gt;

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> extern void funct(void);        // An external function

int main()
{
    printf("In main()\n");
    funct();
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-1">Listing 17-1</a>: The main program</p>
<p>The first thing to notice is the declaration of <code>funct</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> in <em>main.c</em>. The<em> </em><code>extern</code><em> </em>keyword tells C that the function is defined in another file, named <em>func.c</em>.<em> </em><a href="#listing17-2">Listing 17-2</a> contains that file.</p>
<p class="CodeLabel"><b>func.c</b></p>
<pre><code>/**
 * Demonstration of a function module
 */
#include &lt;stdio.h&gt;
/**
 * Demonstration function
 */
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> void funct(void)
{
    printf("In funct()\n");
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-2">Listing 17-2</a>: The file that defines the function</p>
<p>The <code>funct</code> function is defined <span class="CodeAnnotation" aria-label="annotation1">1</span> in the <em>func.c</em> file, and the makefile in <a href="#listing17-3">Listing 17-3</a> handles the compilation.</p>
<pre><code>main: main.c func.c
      gcc -g -Wall -Wextra -o main main.c func.c</code></pre>
<p class="CodeListingCaption"><em><a id="listing17-3">Listing 17-3</a>: simple/Makefile</em></p>
<p>The first line of the makefile tells <code>make</code> that the target <code>main</code> must be rebuilt if <em>main.c</em> or <em>func.c</em> changes. The second line tells <code>make</code> that when one of those files changes it should compile both files and use them to make the program.</p>
<p><span epub:type="pagebreak" title="269" id="Page_269"/>In this example, we’ve taken a function and a main program and put them in two different files. Then we told <code>make</code> to tell the compiler to combine them into one program. This is an oversimplified version of modular programming, but these basic principles are used with more complex programs with larger and more numerous modules.</p>
<h3 id="h2-501621c17-0001">Problems with the Simple Module</h3>
<p class="BodyFirst">The previous example has a few problems. The first one is that the same information is repeated twice.</p>
<p>In <em>main.c</em>, we have the following:</p>
<pre><code>extern void funct(void);        // An external function</code></pre>
<p>And in <em>func.c</em>, we have this:</p>
<pre><code>void funct(void)</code></pre>
<p class="BodyContinued">which means that if we change one file, we must change the other.</p>
<p>Worse, <em>C does not check types across files</em>, which means it’s possible to have the lines:</p>
<pre><code>// File a.c
extern uint32_t flag;    // A flag</code></pre>
<p class="BodyContinued">and:</p>
<pre><code>// File b.c
int16_t flag;        // A flag</code></pre>
<p class="BodyContinued">in two different files. Suppose file <em>a.c</em> decides to set <code>flag</code> to zero. The program is going to deposit 32 bits worth of zero into <code>flag</code>, which is defined in file <em>b.c</em> as being only 16 bits long. What will actually happen is that 16 bits will go into <code>flag</code>, and 16 bits will go into something else. The result is that unexpected, surprising, and difficult-to-debug things will happen to your program.</p>
<p>It is possible to declare a variable <code>extern</code> in a file and later declare it without the <code>extern</code>. C will check to make sure that the type in the <code>extern</code> definition matches the type in the actual declaration:</p>
<pre><code>#include &lt;stdint.h&gt;
extern uint32_t flag;     // A flag
int16_t flag;             // A flag</code></pre>
<p>Compiling this will result in an error:</p>
<pre><code>16.bad.c:3:9: error: conflicting types for 'flag'
 int16_t flag;  // A flag

16.bad.c:2:17: note: previous declaration of 'flag' was here
 extern uint32_t flag; // A flag</code></pre>
<p><span epub:type="pagebreak" title="270" id="Page_270"/>Concerning the second problem, suppose we want to use our external function <code>funct</code> in several different files. Do we want to add an <code>extern</code> statement to each of them? That would mean the definition of <code>funct</code> would be duplicated in many different places (and not checked by the compiler).</p>
<p>The solution is to create a header file to hold the <code>extern</code> definition. <a href="#listing17-4" id="listinganchor17-4">Listing 17-4</a> contains this file.</p>
<p class="CodeLabel"><b>func.h</b></p>
<pre><code>#ifndef __FUNC_H__
#define __FUNC_H__
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> extern void funct(void);
#endif // __FUNC_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-4">Listing 17-4</a>: The file that defines the function</p>
<p>Along with the function definition <span class="CodeAnnotation" aria-label="annotation1">1</span>, this file also contains <em>double inclusion protection</em>. The <code>#findef</code>/<code>#endif</code> pair prevents problems that might occur if your program does something like this:</p>
<pre><code>#include "func.h"
#include "func.h"</code></pre>
<p>This will cause the definitions in <em>func.h</em> to be defined twice, which is not a problem for <code>extern</code> declarations, but it will upset the compiler if multiple instances of <code>#define</code> are involved.</p>
<p>This example looks a bit silly, because in real programs, the problem is not so obvious. You may have a case where the code looks like:</p>
<pre><code>#include "database.h"
#include "service.h"</code></pre>
<p class="BodyContinued">but the <em>database.h</em> file includes the <em>direct_io.h</em> file, which includes <em>func.h</em>, and the <em>service.h</em> file includes the <em>network.h</em> file, which includes <em>func.h</em>. You then get <em>func.h</em> included twice, even though you took the long way to do it.</p>
<p>The format of the <code>#include</code> statement has changed slightly in these examples as well. Instead of:</p>
<pre><code>#include &lt;file.h&gt;</code></pre>
<p class="BodyContinued">it’s this:</p>
<pre><code>#include "file.h"</code></pre>
<p>The quotation marks indicate that the file to be included is a user-generated file. The compiler will search for it in the current directory instead of searching through the system files.</p>
<p><a href="#listing17-5" id="listinganchor17-5">Listing 17-5</a> contains an improved <em>main.c </em>that uses the include file to bring in the <code>extern</code> declarations.</p>
<p class="CodeLabel"><b>good/main.c</b></p>
<pre><code>/**
 * Demonstrate the use of extern.
 */
#include &lt;stdio.h&gt;
<span epub:type="pagebreak" title="271" id="Page_271"/>
#include "func.h"
  
int main()
{
    printf("In main()\n");
    funct();
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-5">Listing 17-5</a>: Improved<em> main.c</em></p>
<p><a href="#listing17-6" id="listinganchor17-6">Listing 17-6</a> contains the improved <em>func.c </em>that includes <em>func.h</em>. The <code>extern</code> functions defined in <em>func.h</em> are not really needed to compile <em>func.c</em>, but by bringing them in, we make sure that the <code>extern</code> matches the actual function declaration.</p>
<p class="CodeLabel"><b>good/func.c</b></p>
<pre><code>/**
 * Demonstration of a function module
 */
#include &lt;stdio.h&gt;
#include "func.h"
/**
 * Demonstration function
 */
void funct(void)
{
    printf("In funct()\n");
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-6">Listing 17-6</a>: Improved <em>func.c</em></p>
<p>By including the <em>func.h</em> file twice, we’ve solved the problem that can occur when the <code>extern</code> does not match the actual declaration. Including it in <em>func.c </em>lets the compiler check the definition of the function, while in <em>main.c</em>, the inclusion provides us with the definition of the function.</p>
<h3 id="h2-501621c17-0002">Making the Module</h3>
<p class="BodyFirst">The makefile for this program has changed as well (see <a href="#listing17-7" id="listinganchor17-7">Listing 17-7</a>).</p>
<pre><code>CFLAGS = -g -Wall -Wextra

OBJS = main.o func.o

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> main: $(OBJS)
        gcc -g -Wall -Wextra -o main $(OBJS)

main.o: main.c func.h

func.o: func.c func.h</code></pre>
<p class="CodeListingCaption"><a id="listing17-7">Listing 17-7</a>: Improved <em>Makefile</em></p>
<p><span epub:type="pagebreak" title="272" id="Page_272"/>The first line defines a macro called <code>CFLAGS</code>, which is a specific name used to compile C programs. The next line defines another macro called <code>OBJS</code> (there is nothing significant about that name), which contains a list of the objects we use to make our program. In this example, we’re going to compile <em>main.c</em> into the <em>main.o</em> object file and compile <em>func.c </em>into the <em>func.o</em> object file.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Object files on macOS and Linux systems end in <em>.o</em>. On Windows systems, object files end with <em>.obj</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>We’re using a macro here simply to avoid having to write the list twice in the next rule <span class="CodeAnnotation" aria-label="annotation1">1</span>, which tells <code>make</code> to create <em>main.o</em> from <em>main.c</em> and <em>func.h</em>. However, this rule isn’t followed by a rule telling <code>make</code> <em>how</em> to do this. When <code>make</code> doesn’t have a rule for something, it falls back to its list of built-in rules. When we create a <em>.o</em> (or .<em>obj</em>) file from a <em>.c</em> file, that built-in rule is:</p>
<pre><code>$(CC) $(CFLAGS) -c <code>file.c</code></code></pre>
<p class="BodyContinued">where <code>CC</code> is the macro containing the name of the C compiler (in this case, <code>cc</code>, which is an alias for <code>gcc</code>).</p>
<p>This example demonstrates a simple modular program, but the design pattern works when programs have additional modules.</p>
<h2 id="h1-501621c17-0002">What Makes Good Modules</h2>
<p class="BodyFirst">The following list outlines some rules for making good modules:</p>
<ul>
<li>Each module should have a header file with the same name as the module. That file should contain the definitions of the public types, variables, and functions in that module (and nothing else).</li>
<li>Every module should include its own header file so that C can check to make sure the header file and the implementation match.</li>
<li>Modules should contain code used for a common purpose, and they should expose the minimum amount of information to the outside world. The information they do expose through <code>extern</code> declarations is global (seen by the entire program), and as described in the next section, sometimes that can be a problem.</li>
</ul>
<h2 id="h1-501621c17-0003">Namespaces</h2>
<p class="BodyFirst">One problem with C is that it does not have namespaces. In C++, for example, you can tell the compiler that all the symbols in a given module belong to the <code>db</code> namespace, so you can create a module with entries like <code>insert</code>, <code>delete</code>, and <code>query</code> that are visible to other people as <code>db::insert</code>, <code>db::delete</code>, and <code>db::query</code>, respectively.</p>
<p><span epub:type="pagebreak" title="273" id="Page_273"/>In C, if you define a public function called <code>Init</code>, no one else can define a function called <code>Init</code> in any module. If this does happen, the linker will complain about a duplicate symbol. Since there may be more than one item that needs initialization, that can be a problem.</p>
<p>Most programmers solve this issue by adding a module prefix to the name of each public function, type, or variable. You can see this in action with the HAL library that gets added automatically to your Nucleo projects. For example, as shown in <a href="#listing17-8" id="listinganchor17-8">Listing 17-8</a>, all the functions that manipulate the UART begin with the <code>UART_</code> prefix.</p>
<pre><code>HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);</code></pre>
<p class="CodeListingCaption"><a id="listing17-8">Listing 17-8</a>: An excerpt from <em>stm32f0xx_hal_uart.h</em></p>
<p>The key point here is that a public symbol in the HAL library starts with <code>HAL_</code>, which makes it easy to determine whether a function belongs to the library. It also ensures that you don’t accidentally use a name already in use by the HAL library.</p>
<h2 id="h1-501621c17-0004">Libraries</h2>
<p class="BodyFirst">Listing every file that goes into a program is not too bad when there are fewer than 20 files. After that, it gets a little tedious, but it’s manageable until the number gets really big. The mainframe programs we’ve been writing use the standard C library functions. The C library has more than 1,600 files. Fortunately, we don’t need to list them all when we compile a program.</p>
<p>The standard C library is a file named <em>libc.a</em>, and it’s automatically loaded when your program is linked. The library is a collection of object files in a simple archive format (hence the <em>.a</em> extension).</p>
<p>Let’s create our own library containing several modules to square various types of numbers. <a href="#listing17-9" id="listinganchor17-9">Listing 17-9</a> shows a function to square a floating-point number.</p>
<p class="CodeLabel"><b>square_float.c</b></p>
<pre><code>#include "square_float.h"

/**
 * Square a floating-point number.
 *
 * @param number Number to square
 * @returns The square of the number
 */
float square_float(const float number) {
    return (number * number);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-9">Listing 17-9</a>: A function to square a floating-point number</p>
<p><a href="#listing17-10" id="listinganchor17-10">Listing 17-10</a> is the header for that module.</p>
<p class="CodeLabel"><span epub:type="pagebreak" title="274" id="Page_274"/><b>square_float.h</b></p>
<pre><code>#ifndef __SQUARE_FLOAT_H__
#define __SQUARE_FLOAT_H__
extern float square_float(const float number);
#endif // __SQUARE_FLOAT_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-10">Listing 17-10</a>: The header file for the <em>square_float.c</em> module</p>
<p><a href="#listing17-11" id="listinganchor17-11">Listing 17-11</a> defines a function to square an integer.</p>
<p class="CodeLabel"><b>square_int.c</b></p>
<pre><code>#include "square_int.h"

/**
 * Square an integer.
 *
 * @param number Number to square
 * @returns The square of the number
 */
int square_int(const int number) {
    return (number * number);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-11">Listing 17-11</a>: A function to square an integer</p>
<p><a href="#listing17-12" id="listinganchor17-12">Listing 17-12</a> defines its header file.</p>
<p class="CodeLabel"><b>square_int.h</b></p>
<pre><code>#ifndef __SQUARE_INT_H__
#define __SQUARE_INT_H__
extern int square_int(const int number);
#endif // __SQUARE_INT_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-12">Listing 17-12</a>: The header file for <em>square_int.c</em></p>
<p>Next, <a href="#listing17-13" id="listinganchor17-13">Listing 17-13</a> is a similar function to square an unsigned integer.</p>
<p class="CodeLabel"><b>square_unsigned.c</b></p>
<pre><code>#include "square_unsigned.h"

/**
 * Square an unsigned integer.
 *
 * @param number Number to square
 * @returns The square of the number
 */
unsigned int square_unsigned(const unsigned int number) {
    return (number * number);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-13">Listing 17-13</a>: A function to square an unsigned integer</p>
<p><a href="#listing17-14" id="listinganchor17-14">Listing 17-14</a> defines the header file.</p>
<p class="CodeLabel"><b>square_unsigned.h</b></p>
<pre><code>#ifndef __SQUARE_UNSIGNED_H__
#define __SQUARE_UNSIGNED_H__
extern unsigned int square_unsigned(const unsigned int number);
#endif // __SQUARE_UNSIGNED_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-14">Listing 17-14</a>: The header file for<em> square_unsigned.c</em></p>
<p><span epub:type="pagebreak" title="275" id="Page_275"/>We are going to put our three functions in a library. If users want to use this library, they will have to include all those header files. That’s a lot of work.</p>
<p>To make things easier, we’ll create a header file called <em>square.h</em> for the library. This file consolidates the individual headers for each of the preceding library components (modules). As a result, people who use this library just need to include <em>square.h</em> (see <a href="#listing17-15" id="listinganchor17-15">Listing 17-15</a>) instead of a bunch of individual headers.</p>
<p class="CodeLabel"><b>square.h</b></p>
<pre><code>#ifndef __SQUARE_H__
#define __SQUARE_H__
#include "square_float.h"
#include "square_int.h"
#include "square_unsigned.h"
#endif // __SQUARE_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-15">Listing 17-15</a>: The header file for the library</p>
<p>We’ve now followed our style rule of one header per program file, as well as the style rule that says the interface to a library should be as simple as possible.</p>
<p>Next, let’s create a small test program for our library (see <a href="#listing17-16" id="listinganchor17-16">Listing 17-16</a>).</p>
<p class="CodeLabel"><b>square.c</b></p>
<pre><code>/**
 * Test the square library.
 */
#include &lt;stdio.h&gt;

#include "square.h"

int main()
{
   printf("5 squared is %d\n", square_int(5));
   printf("5.3 squared is %f\n", square_float(5.3));
   return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-16">Listing 17-16</a>: A test program for the library</p>
<p>Notice that we don’t test all the members of the library (this will matter later).</p>
<p>Now that we have the source files for our library, we need to turn them into an actual library. As mentioned previously, a library is a set of object files in an archive format, sort of like a <em>.zip</em> file, only without the compression.</p>
<p>In this case, we’ll create the <em>libsquare.a</em> file (the library itself) from the <em>square_float.o</em>, <em>square_int.o</em>, and <em>square_unsigned.o</em> files.</p>
<p>The <code>make</code> program is quite intelligent and has the ability to update an archive’s components. For example, one of the components of <em>libsquare.a</em> is <em>square_int.o</em>. The following rule makes this a component of the library:</p>
<pre><code>libsquare.a(square_int.o): square_int.o
        ar crU libsquare.a square_int.o</code></pre>
<p><span epub:type="pagebreak" title="276" id="Page_276"/>The first line tells <code>make</code> that we are creating or updating the <em>square_int.o</em> component in the <em>libsquare.a</em> library. This component depends on the <em>square_int.o</em> object file.</p>
<p>The second line is the actual command to add the library. The <code>c</code> option tells <code>ar</code> to create the archive if it does not exist. The <code>r</code> causes <code>ar</code> to create or replace the <em>square_int.o</em> component in the archive. The <code>U</code> flag tells <code>ar</code> to run in nondeterministic mode, which stores the creation time of the file in the archive (we’ll discuss deterministic versus nondeterministic mode later in this chapter). Following that command is the name of the library (<em>libsquare.a</em>) and the name of the component to add or replace (<em>square_int.o</em>). The linker sets the naming convention. It must begin with <em>lib</em> and end with <em>.a</em> (more on this naming convention later).</p>
<p>Next, with the following directives, we tell <code>make</code> what components should make up the <em>libsquare.a </em>library:</p>
<pre><code>libsquare.a: libsquare.a(square_int.o) \
        libsquare.a(square_float.o)

libsquare.a(square_unsigned.o)
        ranlib libsquare.a</code></pre>
<p>The first two lines tell <code>make</code> what components to make <em>libsquare.a</em> out of. The third line, <code>ranlib libsquare.a</code>, tells <code>make</code> to run a program called <code>ranlib</code> on the archive after installing all the components to create a table of contents for the archive.</p>
<h3 id="h2-501621c17-0003">ranlib and Library Linking</h3>
<p class="BodyFirst">The reason we use <code>ranlib</code> is due to some of the early linkers. Suppose that we had an archive with the components <em>a.o</em> (defines <code>a_funct</code>), <em>b.o</em> (defines <code>b_funct</code>), and <em>c.o </em>(defines <code>c_funct</code>) and that the program needed a function in <em>b.o</em>. The linker would open the archive and go through it serially, looking at each member to see whether it was needed. The decision process goes like this:</p>
<ol class="decimal">
<li value="1">Look at the list of undefined symbols (the program uses <code>b_funct</code>, so it’s undefined).</li>
<li value="2">Open the archive.</li>
<li value="3">Look at <em>a.o</em>. Does it define a needed symbol? No. Do not load it.</li>
<li value="4">Look at <em>b.o</em>. Does it define a needed symbol? Yes. Load it.</li>
<li value="5">Look at <em>c.o</em>. Does it define a needed symbol? No. Do not load it.</li>
</ol>
<p>Now suppose that <em>b.o</em> needed the <code>a_funct</code> function. The linker would not go back and reexamine the archive. It would continue on and look only at <em>c.o</em>. Since <em>c.o</em> does not define the symbol, it would not be loaded. The linker would reach the end of the archive and abort because it did not find an object file to satisfy the need for <code>a_funct</code>.</p>
<p><span epub:type="pagebreak" title="277" id="Page_277"/>Because of the way the linker worked, sometimes you needed to specify the same library two or three times. To solve that problem, a table of contents was added to the archive so the components could be loaded in random order (thus the name <code>ranlib</code>).</p>
<p>Now the algorithm to load components is as follows:</p>
<ol class="decimal">
<li value="1">Look at the list of undefined symbols (the program uses <code>b_funct</code>, so it’s undefined).</li>
<li value="2">Open the archive.</li>
<li value="3">Do we have an undefined symbol that’s in the table of contents?</li>
<li value="4">If so, load it.</li>
<li value="5">Repeat until we have no more symbols that can be satisfied by this library.</li>
</ol>
<p>This process solves the ordering problem because the table of contents makes everything accessible.</p>
<p>The following command actually links the library with our program:</p>
<pre><code>square: square.o libsquare.a
        $(CC) $(CFLAGS) -o square square.o -L. -lsquare</code></pre>
<p>The <code>-L.</code> flag tells the linker to search the current directory (<code>.</code>) for library files. Otherwise, only the system library directories are searched. The library itself is specified with the <code>-lsquare</code> directive. The linker looks for a library called <em>libsquare.a</em>, first in the current directory (because of the <code>-L.</code>) and then in the system directories.</p>
<p><a href="#listing17-17" id="listinganchor17-17">Listing 17-17</a> shows the full makefile for this project.</p>
<pre><code>CFLAGS=-g -Wall -Wextra

all: square

square: square.o libsquare.a
        $(CC) $(CFLAGS) -o square square.o -L. -lsquare

libsquare.a: libsquare.a(square_int.o) \
        libsquare.a(square_float.o) libsquare.a(square_unsigned.o)
        ranlib libsquare.a

libsquare.a(square_int.o): square_int.o
       ar crU libsquare.a square_int.o

libsquare.a(square_float.o): square_float.o
        ar crU libsquare.a square_float.o

libsquare.a(square_unsigned.o): square_unsigned.o
        ar crU libsquare.a square_unsigned.o

square_int.o: square_int.h square_int.c

square_float.o: square_float.h square_float.c

<span epub:type="pagebreak" title="278" id="Page_278"/>square_unsigned.o: square_unsigned.h square_unsigned.c

square.o: square_float.h square.h square_int.h square_unsigned.h square.c</code></pre>
<p class="CodeListingCaption"><em><a id="listing17-17">Listing 17-17</a>: The full makefile</em></p>
<p>Because our test program does not call <code>square_unsigned</code>, the <em>square_unsigned.o</em> module will not be linked into our program. (The test for <code>square_unsigned</code> was omitted to demonstrate how the linker will not link in unneeded object files.)</p>
<h3 id="h2-501621c17-0004">Deterministic vs. Nondeterministic Libraries</h3>
<p class="BodyFirst">Ideally, if you run a <code>make</code> command, the resulting binary should be the same, no matter when the command was executed. For this reason, originally the library files did not store information on who created the components or when they were created.</p>
<p>However, that causes some difficulties for the <code>make</code> program. How can it determine whether the version of <em>square_int.o</em> in the archive is newer or older than the version you just compiled if the archive doesn’t store the modification date?</p>
<p>The <code>ar</code> command was modified to store this information. Because this feature broke legacy functionality, the <code>ar</code> maintainers decided to make storing this information optional. If you specify the <code>D</code> option, the modification times are not stored and you get a <em>deterministic archive</em> (the same binary every time). If you specify <code>U</code> for <em>nondeterministic</em>, you get a different binary each time, but one that the <code>make</code> program likes better. The default is <code>D</code>, the legacy format.</p>
<h2 id="h1-501621c17-0005">Weak Symbols</h2>
<p class="BodyFirst">So far, we’ve defined modules with functions and variables that are always loaded. In other words, if a module defines a <code>doIt</code> function, that’s the only definition of the function that’s loaded. An extension to the C language provided by GCC and most other compilers allows for <em>weak symbols</em>. A weak symbol tells the linker, “If no one else defines this symbol, use me.”</p>
<p>One example of where weak symbols are used is in the STM interrupt table. You <em>must</em> define functions to be called for every possible interrupt; the hardware requires it. So you have to write an interrupt route for interrupts that never occur. Since the function is never going to be called, that should make things simple.</p>
<p>However, the STM firmware is designed around the idea that although interrupt routes for disabled interrupts <em>should</em> never be called, that doesn’t mean that they will <em>never</em> be called. The STM firmware defines interrupt handlers for all interrupts that brick the system. If they ever do get called, your system stops and you get a chance to go in with the debugger and try and figure out why.</p>
<p><span epub:type="pagebreak" title="279" id="Page_279"/>The only way a default interrupt handler will be called is if you turn on interrupts and don’t provide your own interrupt handler. In that case the default interrupt knows something went wrong and just sits there waiting for you to figure out what.</p>
<p>The STM interrupt handler from the USART2 interrupts is the function <code>USART2_IRQHandler</code>, which is defined as follows:</p>
<pre><code>void USART2_IRQHandler(void) {
    while(true)
        continue;
}</code></pre>
<p>However, if we define our own, the one in the firmware library disappears, in spite of the fact that the other 40 or so interrupt functions in the same module will be loaded.</p>
<p>Let’s see this in action with our own code. In Listings 17-18 and 17-19 we have <code>sub1</code> and <code>sub2</code>, and <code>sub2</code> is defined twice (once in <em>main.c </em>and once in <em>sub.c</em>). When the linker looks at those two files, it says, “There are two <code>sub2</code> functions here. Should I raise an error? No. One of them is weak, and I can throw it away.” The <code>sub2</code> in <em>main.c</em> will get linked in and the one in <em>sub.c</em> will not.</p>
<p>Let’s first define a main program whose job is to call our two subroutines (see <a href="#listing17-18" id="listinganchor17-18">Listing 17-18</a>).</p>
<p class="CodeLabel"><b>main.c</b></p>
<pre><code>#include "sub.h"

int main()
{
    sub1();
    sub2();
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-18">Listing 17-18</a>: The main program to call the two subroutines</p>
<p>In <a href="#listing17-19" id="listinganchor17-19">Listing 17-19</a>, we tell the compiler that <code>sub2</code> in <em>sub.c</em> is weak through the GCC extension.</p>
<p class="CodeLabel"><b>sub.c</b></p>
<pre><code>#include "sub.h"

void sub2(void) __attribute__((weak));

void sub1(void) {}
void sub2(void) {}
</code></pre>
<p class="CodeListingCaption"><a id="listing17-19">Listing 17-19</a>: Tells the compiler <code>sub2</code> is weak</p>
<p>Next, we need a header file, so let’s produce one (see <a href="#listing17-20" id="listinganchor17-20">Listing 17-20</a>).</p>
<p class="CodeLabel"><b>sub.h</b></p>
<pre><code>#ifndef __SUB_H__
#define __SUB_H__
extern void sub1(void);
<span epub:type="pagebreak" title="280" id="Page_280"/>extern void sub2(void);
#endif // __SUB_H__</code></pre>
<p class="CodeListingCaption"><a id="listing17-20">Listing 17-20</a>: The header file</p>
<p>Finally, we define our own <code>sub2</code> function in <a href="#listing17-21" id="listinganchor17-21">Listing 17-21</a>.</p>
<p class="CodeLabel"><b>sub2.c</b></p>
<pre><code>#include &lt;stdio.h&gt;
#include "sub.h"

void sub2(void) {
    printf("The non-weak sub2\n");
}</code></pre>
<p class="CodeListingCaption"><a id="listing17-21">Listing 17-21</a>: Defining the <code>sub2</code> function</p>
<p>If we link <em>main.c </em>and <em>sub.c</em>, the weak <code>sub2</code> will be linked in. If we link <em>main.c</em>, <em>sub.c</em>, and <em>sub2.c</em>, the non-weak version defined in <em>sub2.c</em> will be used.</p>
<p>This is useful for cases like interrupt routines where you have to define one whether you use it or not. It allows you to supply a fallback or default version.</p>
<h2 id="h1-501621c17-0006">Summary</h2>
<p class="BodyFirst">Modules enable you to split up large programs into manageable units. Good design means a large program does not need to have large parts. Multiple modules can be organized into a library. The advantage of a library is that it can include a large number of specialized modules, and the linker will only link in the needed ones.</p>
<p>Good programming is all about organizing information, and modules and libraries let you organize a huge programming mess into manageable-sized units.</p>
<h2 id="h1-501621c17-0007">Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a library to compute the area of geometric shapes (<code>rectangle_area</code>, <code>triangle_area</code>, and so on). Each function should be in its own object file, and all the area functions should be combined into a single library. Write a main program to perform a unit test on the functions.</li>
<li value="2">Rewrite one of the serial output programs created in previous chapters so that all of the UART-related code is in a module of its own.</li>
<li value="3">Test to see what happens when:<ol class="lower-alpha">
<li value="1">You define two weak symbols and one strong one.</li>
<li value="2">You define two weak symbols and no strong one.</li>
<li value="3">You define two strong symbols.</li>
</ol>
</li>
</ol>
</section>
</body></html>