- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Ansible to Manage Passwords, Users, and Groups
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve built your VM, let’s move on to performing administrative tasks
    like user management. The DevOps practice of automation is key to building and
    managing resources. To manage any Linux host, you need a basic understanding of
    the workings of passwords, users, and groups. Users and passwords are the building
    blocks of identity management, while groups allow you to manage a collection of
    users and control access to files, directories, and commands. Dividing up responsibilities
    between users and groups can be the difference between allowing unauthorized access
    and thwarting it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll continue learning how to use Ansible, and you’ll also
    provision the VM you just created to improve your basic security policy. You’ll
    use some provided Ansible tasks to enforce complex passwords, manage users and
    groups, and control access to a shared directory and file. Once you have learned
    those security basics, you’ll be able to use them as the foundation of every playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Complex Passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Letting users decide what a strong password is can be a recipe for disaster,
    so you’ll need to enforce complex passwords on every host that users can access.
    Since automation is one of our guiding principles, you’ll use code to enforce
    strong passwords for all users. To do this, you can use an Ansible task to install
    a plug-in for *Pluggable Authentication Modules* *(PAM)*, which is a user authentication
    framework that most Linux distributions employ. The plug-in to provide complex
    passwords is called `pam_pwquality`. This module validates passwords based on
    criteria you set.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libpam-pwquality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pwquality` PAM module is available in the Ubuntu software repository under
    the name `libpam-pwquality`. You’ll use the Ansible tasks provided with this book
    to install and configure this package. Remember, the goal is to automate everything
    you can, and tasks provide the mechanism to carry out administrative work. These
    tasks are located in the repository you cloned from the Introduction. Navigate
    to the *ansible/chapter2/* directory and open the *pam_pwquality.yml* file in
    your favorite editor. This file contains two tasks: `Install libpam-pwquality`
    and `Configure pam_pwquality`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on the first task that uses the Ansible `package` module to install
    `libpam-pwquality` on the VM. At the top of the file, the install task should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each Ansible task should start with a `name` declaration that defines its goal.
    In this case, the `name` is `Install libpam-pwquality`. Next, the Ansible `package`
    module performs the software installation. The `package` module requires you to
    set two parameters: `name` and `state`. In this example, the package name (found
    in the Ubuntu repository) should be `libpam-pwquality`, and the `state` should
    be `present`. To remove a package, set the `state` to `absent`. This is a good
    example of declarative instruction, since you are telling Ansible to make sure
    this package is installed. You don’t need to worry how it gets installed, as long
    as it does. If you install the package (`present`) and then delete the task from
    Ansible, the package will still be installed on the next provision. You would
    have to explicitly set the package to `absent` if you wanted the host to represent
    your desired state.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in Chapter 1, Ansible modules (like the one above) perform common
    actions on an OS, such as enabling a firewall, managing users, or (in this case)
    installing software. Ansible allows your actions to be *idempotent*, which means
    you can do a specific action over and over again and the result will be the same
    as it was the last time you executed the action. Because of this, you should automate
    all you can! You’ll save time and avoid mistakes caused by manual fatigue. Imagine
    if you had to configure 1,000 machines a day. It would be almost impossible without
    automation!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring pam_pwquality to Enforce a Stricter Password Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a default Ubuntu system, password complexity is not as strong as it could
    be. It requires a minimum password length of six characters and executes only
    some basic complexity checks. To enforce more complexity, you’ll want to configure
    `pam_pwquality` to set a stricter password policy.
  prefs: []
  type: TYPE_NORMAL
- en: A file named */etc/pam.d/common-password* handles configuration of the `pam_pwquality`
    module. This file is where the Ansible task makes the necessary changes to validate
    passwords. All you need to do is change one line in that file. A common way to
    edit a line using Ansible is with the `lineinfile` module, which allows you to
    change a line in a file or check whether a line exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `pam_pwquality` task file still open, let’s review the second task
    from the top. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the task starts with a name, `Configure pam_pwquality`, that describes
    its intent. Then it tells Ansible to use the `lineinfile` module to edit the PAM
    password file. The `lineinfile` module requires the `path` of the file to which
    you want to make changes. In this case, it is the PAM password file */etc/pam.d/common-password*.
    Use a regular expression, or *regexp*, to find the line in the file you want to
    change. The regular expression locates the line that has `pam_pwquality.so` in
    it and replaces it with a new line. The replacement `line` parameter contains
    the `pwquality` configuration changes, which enforce more complexity. The options
    provided above enforce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A minimum password length of 12 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One lowercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One uppercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One numeric character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One nonalphanumeric character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three retries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable root override
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding these requirements will strengthen Ubuntu’s default password policy.
    Any new passwords will need to meet or exceed these requirements, which will make
    brute-forcing user passwords a bit harder for attackers.
  prefs: []
  type: TYPE_NORMAL
- en: Close the *pam_pwquality.yml* file so you can move on to creating users with
    an Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: Linux User Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to Linux, users come in three types: normal, system, and root.
    You can think of a *normal user* as a human account, and you’ll create one of
    those next. Every normal user is typically associated with a password, a group,
    and a username. Think of a *system user* as a nonhuman account, such as the user
    Nginx runs as. In fact, a system user is almost identical to a normal user, but
    it is located in a different user ID (UID) range for compartmental reasons. A
    *root user* (or *superuser*) account has unrestricted access to the operating
    system. You can tell the root user by its UID, which is always zero. As with all
    your configurations, you’ll use an Ansible module to do the heavy lifting when
    it comes to creating and configuring users.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with the Ansible User Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible comes with the `user` module, which makes managing users very easy.
    It handles all the messy details for accounts, like shells, keys, groups, and
    home directories. You’ll use the `user` module to create a new user called *bender**.*
    Feel free to name it something else if you want, but since the examples in this
    book use the *bender* username going forward, don’t forget to change the name
    in future chapters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *user_and_group.yml* file located in the *ansible/chapter2/* directory.
    This file contains the following five tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure group *developers* exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the user *bender*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign *bender* to the *developers* group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory named *engineering*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file in the engineering directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tasks will create a group and a user, assign a user to a group, and create
    a shared directory and file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though it’s counterintuitive, let’s start by focusing on the second task on
    the list, which creates the user *bender*. (We’ll get to the first task in the
    “Linux Groups” section on the next page.) It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This task, like all others, starts with a `name` that describes what it will
    do. In this case, it is `Create the user 'bender'`. You’ll use the Ansible `user`
    module to create a user. The `user` module has many options, but only the `name`
    parameter is required. In this example, the `name` is set to `bender`. Setting
    a user’s password at provision time can be useful, so set the optional `password`
    parameter field to a known password hash (more on this later). The `password`
    value, beginning with `$6`, is a cryptic hash that Linux supports. I have included
    a sample password hash for *bender* to show how you can automate this step. In
    the next section, I will walk through the process I used to generate it.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Complex Password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use many different methods to generate a password to match the complexity
    you set in `pam_pwquality`. As mentioned earlier, I’ve supplied a password hash
    for you that matches this threshold to save time. I used a combination of two
    command line applications, `pwgen` and `mkpasswd`, to create the complex password.
    The `pwgen` command can generate secure passwords, and the `mkpasswd` command
    can generate passwords using different hashing algorithms. The `pwgen` application
    is provided by the `pwgen` package, and the `mkpasswd` application is provided
    by a package named `whois`. Together, these tools can generate the hash that Ansible
    and Linux expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux stores password hashes in a file called *shadow*. On an Ubuntu system,
    the password hashing algorithm is SHA-512 by default. To create your own SHA-512
    hash for Ansible’s user module, use the commands below on an Ubuntu host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since these packages are not installed by default, you’ll need to install them
    first with the APT package manager. The `pwgen` command generates a complex password
    that matches what you need to satisfy `pwquality` and saves it into a variable
    called `pass`. Next, the contents of the variable `pass` are piped into `mkpasswd`
    to be hashed using the `sha-512` algorithm. The final output should contain two
    lines. The first line contains the SHA-512 hash, and the second line contains
    the new password. You can take the hash string and set the `password` value in
    the user creation task to change it. Feel free to try it!
  prefs: []
  type: TYPE_NORMAL
- en: Linux Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux groups allow you to manage multiple users on a host. Creating groups is
    also an efficient way to limit access to resources on a host. It is much easier
    to administer changes to a group than to hundreds of users individually. For the
    next example, I’ve provided an Ansible task to create a group called *developers*
    that you will use to limit access to a directory and a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with the Ansible Group Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `user` module, Ansible has a `group` module that can manage creating
    and removing groups. Compared to other Ansible modules, the `group` module is
    very minimal; it can only create or delete a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *user_and_group.yml* file in your editor to review the group creation
    task. The first task in the file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `name` of the task states that you want to make sure a group exists. Use
    the `group` module to create the group. This module requires you to set the `name`
    parameter, which is set to `developers` here. The `state` parameter is set to
    `present`, so it will create the group if it does not already exist.
  prefs: []
  type: TYPE_NORMAL
- en: The group creation task is the first one in the file, and that is not by accident.
    You need to create the *developers* group before executing any other tasks. Tasks
    are run in order, so you need to make sure the group exists first. If you tried
    to reference the group before creating it, you would get an error message stating
    that the *developers* group doesn’t exist, and the provisioning would fail. Understanding
    Ansible’s task order of operations is key to performing more complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the *user_and_group.yml* file open as you continue reviewing the other
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a User to the Group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a user to a group with Ansible, you’ll leverage the `user` module once
    again. In the *user_and_group.yml* file, locate the task that assigns *bender*
    to the *developers* group (the third task from the top in the file). It should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First is the `name` of the task, which describes its intention. The `user` module
    appends *bender* to the *developers* group. The `groups` option can accept multiple
    groups in a comma-separated string. By using the `append` option, you leave *bender*’s
    previous groups intact and add only the *developers*. If you omit the `append`
    option, *bender* will be removed from all groups except its primary group and
    the one(s) listed in the `groups` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Protected Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With *bender*’s group affiliation sorted out, let’s visit the last two tasks
    in the *user_and_group.yml* file, which deal with creating a directory (*/opt/engineering/*)
    and a file (*/opt/engineering/private.txt*) on the VM. You’ll use this directory
    and file to test user access for *bender* later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the *user_and_group.yml* file still open, locate the two tasks. Start
    with the directory creation task (the fourth from the top in the file), which
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, as before, set the `name` to match the task’s intent. Use the `file`
    module to manage the directory and its attributes. The `path` parameter is where
    you want to create the directory. In this case, it’s set to */opt/engineering/*.
    Since you want to create a directory, set the `state` parameter to the type of
    resource you want to create, which is `directory` in this example. You can use
    other types here, and you’ll see another one when you create the file later. The
    `mode`, or privilege, is set to `0750`. This number allows the owner (*root*)
    to read, write, and execute against this directory, while the group members are
    allowed only to read and execute. The execute permission is needed to enter the
    directory and list its contents. Linux uses octal numbers (`0750`, in this case)
    to define permissions on files and groups. See the `chmod` man page for more information
    on permission modes. Finally, set the `group` ownership of the directory to the
    *developers* group. This means only the users in the *developers* group can read
    or list the contents of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task in the *user_and_group.yml*file creates an empty file inside
    the */opt/engineering/* directory you just created. The task, located at the bottom
    of the file, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Set the task `name` to what you want to do on the host. Use the `file` module
    again to create a file and set some attributes on it. The `path`, which is required,
    gives the file’s location on the VM. This example shows creating a file named
    *private.txt* inside the */opt/engineering/* directory. The `state` parameter
    is set to `touch`, which means to create an empty file if it does not exist. If
    you need to create a nonempty file, you can use the `copy` or `template` Ansible
    modules. See the documentation for more details. The `mode`, or privileges, is
    set to read, write, and execute for any user in the group (`0770`). Finally, set
    the `group` ownership of the file to the *developers* group.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that there are many methods you can use to protect
    resources on a Linux host. Group restrictions are just a small piece of a larger
    authorization stack you would see in a production environment. I’ll discuss different
    access controls in a later chapter. But for now, just know that with Ansible’s
    tasks and modules, you can perform many common system configurations, such as
    securing files and directories across your whole environment.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been describing Ansible modules and reviewing the tasks that will
    provision the VM. The next step actually uses them. To provision the VM, you’ll
    need to uncomment the tasks in the playbook under the *ansible/* directory. The
    *site.yml* file is the playbook you referenced in the provisioners section of
    your Vagrantfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *site.yml* playbook file in your editor and locate the Chapter 2 tasks
    that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: They are commented out. Remove the hash marks (`#`) at the start of the two
    lines to uncomment them so Ansible can execute the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Both Chapter 2 tasks, `pam_pwquality` and `user_and_group`, are now uncommented,
    so they will execute the next time you provision the VM. Save and close the playbook
    file for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'You created the VM in Chapter 1. If the VM is not running, however, enter the
    `vagrant up` command to start it again. With the VM running, all you need to do
    is issue the `vagrant` `provision` command from within the *vagrant/* directory
    to run the provisioner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last line shows that the Ansible playbook ran and completed `8` actions.
    Think of *actions* as the tasks and other operations being run. Seven of those
    eight actions changed some state on the VM. The line shows that the provision
    is complete and had no errors or failed actions.
  prefs: []
  type: TYPE_NORMAL
- en: If your provision has failures, stop and try to troubleshoot them. Run the `provision`
    command again with the `--debug` flag, as shown in Chapter 1, to receive more
    information. You’ll need a successful provision to follow along with the examples
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Testing User and Group Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the user and group permissions you just configured, you’ll issue the
    `ssh` command for `vagrant` to access the VM. Make sure you are in the *vagrant/*
    directory so you have access to the Vagrantfile. Once there, enter the command
    below in your terminal to log in to the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should be logged in as the *vagrant* user, which is the default user Vagrant
    creates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to verify the user *bender* was created, you’ll use the `getent` command
    to query the *passwd* database for the user. This command allows you to query
    entries in files like */etc/passwd*, */etc/shadow*, and */etc/group*. To check
    *bender*’s existence, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Your result should look similar to the output above. If the user was not created,
    the command will complete without any result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should check whether the *developers* group exists and whether *bender*
    is a member of it. Query the *group* database for this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The result should look like the output above, with a *developers* group and
    the user *bender* assigned to it. If the group did not exist, the command would
    have exited without any result.
  prefs: []
  type: TYPE_NORMAL
- en: For the final check, test that only members of the *developers* group can access
    the */opt/engineering/* directory and the *private.txt* file. To do this, try
    to access the directory and file once as the *vagrant* user and then again as
    the *bender* user.
  prefs: []
  type: TYPE_NORMAL
- en: 'While logged in as *vagrant*, enter the command below to list the */opt/engineering/*
    directory and its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that access is `denied` when trying to list files in */opt/engineering*
    as the *vagrant* user. This is because the *vagrant* user is not a member of the
    *developers* group and thus does not have read access to the `directory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to test the file permissions for *vagrant*, use the `cat` command to view
    the */opt/engineering/private.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The same error occurs because the *vagrant* user does not have read permissions
    on the file.
  prefs: []
  type: TYPE_NORMAL
- en: The next test is to verify that *bender* has access to this same directory and
    file. To do this, you must be logged in as the *bender* user. Switch users from
    *vagrant* to *bender* using the `sudo` `su` command. (I’ll cover the `sudo` command
    in Chapter 4.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, enter the following command to switch users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have successfully switched users, try the command to list the directory
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you can see, you have successfully accessed the directory and its contents
    as *bender*, and the *private.txt* file is viewable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter the following command to check whether *bender* can read the contents
    of the */opt/engineering/private.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You use the `cat` command again to view the contents of the file. Since the
    file is empty, there is no output. More importantly, there are no errors from
    *bender*’s attempt to access the file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you provisioned the VM using the following Ansible modules:
    `package`, `lineinfile`, `user`, `group`, and `file`. These modules configured
    the host to enforce complex passwords, manage a user and group, and secure access
    to a file and directory. These are common tasks a DevOps engineer would do in
    a typical environment. Not only did you expand your Ansible knowledge, but you
    learned how to automate basic security hygiene on the VM. In the next chapter,
    you’ll continue with the provided tasks and increase SSH security to limit access
    to the VM.'
  prefs: []
  type: TYPE_NORMAL
