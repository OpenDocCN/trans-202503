- en: 'Chapter 32. Threads: Thread Cancellation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, multiple threads execute in parallel, with each thread performing
    its task until it decides to terminate by calling *pthread_exit()* or returning
    from the thread’s start function.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can be useful to *cancel* a thread; that is, to send it a request
    asking it to terminate now. This could be useful, for example, if a group of threads
    is performing a calculation, and one thread detects an error condition that requires
    the other threads to terminate. Alternatively, a GUI-driven application may provide
    a cancel button to allow the user to terminate a task that is being performed
    by a thread in the background; in this case, the main thread (controlling the
    GUI) needs to tell the background thread to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we describe the POSIX threads cancellation mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a Thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *pthread_cancel()* function sends a cancellation request to the specified
    *thread*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or a positive error number on error
  prefs: []
  type: TYPE_NORMAL
- en: Having made the cancellation request, *pthread_cancel()* returns immediately;
    that is, it doesn’t wait for the target thread to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Precisely what happens to the target thread, and when it happens, depends on
    that thread’s cancellation state and type, as described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation State and Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *pthread_setcancelstate()* and *pthread_setcanceltype()* functions set flags
    that allow a thread to control how it responds to a cancellation request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or a positive error number on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pthread_setcancelstate()* function sets the calling thread’s cancelability
    state to the value given in *state*. This argument has one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PTHREAD_CANCEL_DISABLE`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread is not cancelable. If a cancellation request is received, it remains
    pending until cancelability is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`PTHREAD_CANCEL_ENABLE`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread is cancelable. This is the default cancelability state in newly created
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: The thread’s previous cancelability state is returned in the location pointed
    to by *oldstate*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are not interested in the previous cancelability state, Linux allows *oldstate*
    to be specified as `NULL`. This is the case on many other implementations as well;
    however, SUSv3 doesn’t specify this feature, so portable applications can’t rely
    on it. We should always specify a non-`NULL` value for *oldstate*.
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily disabling cancellation (`PTHREAD_CANCEL_DISABLE`) is useful if a
    thread is executing a section of code where *all* of the steps must be completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a thread is cancelable (`PTHREAD_CANCEL_ENABLE`), then the treatment of
    a cancellation request is determined by the thread’s cancelability type, which
    is specified by the *type* argument in a call to *pthread_setcanceltype()*. This
    argument has one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PTHREAD_CANCEL_ASYNCHRONOUS`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread may be canceled at any time (perhaps, but not necessarily, immediately).
    Asynchronous cancelability is rarely useful, and we defer discussion of it until
    Section 32.6.
  prefs: []
  type: TYPE_NORMAL
- en: '`PTHREAD_CANCEL_DEFERRED`'
  prefs: []
  type: TYPE_NORMAL
- en: The cancellation remains pending until a cancellation point (see the next section)
    is reached. This is the default cancelability type in newly created threads. We
    say more about deferred cancelability in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The thread’s previous cancelability type is returned in the location pointed
    to by *oldtype*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the *pthread_setcancelstate() oldstate* argument, many implementations,
    including Linux, allow *oldtype* to be specified as `NULL` if we are not interested
    in the previous cancelability type. Again, SUSv3 doesn’t specify this feature,
    and portable applications can’t rely on it We should always specify a non-`NULL`
    value for *oldtype*.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls *fork()*, the child inherits the calling thread’s cancelability
    type and state. When a thread calls *exec()*, the cancelability type and state
    of the main thread of the new program are reset to `PTHREAD_CANCEL_ENABLE` and
    `PTHREAD_CANCEL_DEFERRED`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When cancelability is enabled and deferred, a cancellation request is acted
    upon only when a thread next reaches a *cancellation point*. A cancellation point
    is a call to one of a set of functions defined by the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 specifies that the functions shown in [Table 32-1](ch32.html#functions_required_to_be_cancellation_po
    "Table 32-1. Functions required to be cancellation points by SUSv3") *must* be
    cancellation points if they are provided by an implementation. Most of these are
    functions that are capable of blocking the thread for an indefinite period of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-1. Functions required to be cancellation points by SUSv3
  prefs: []
  type: TYPE_NORMAL
- en: '| *accept()**aio_suspend()**clock_nanosleep()**close()**connect()**creat()**fcntl(F_SETLKW)**fsync()**fdatasync()**getmsg()**getpmsg()**lockf(F_LOCK)**mq_receive()**mq_send()**mq_timedreceive()**mq_timedsend()**msgrcv()**msgsnd()**msync()*
    | *nanosleep()**open()**pause()**poll()**pread()**pselect()**pthread_cond_timedwait()**pthread_cond_wait()**pthread_join()**pthread_testcancel()**putmsg()**putpmsg()**pwrite()**read()**readv()**recv()**recvfrom()**recvmsg()**select()*
    | *sem_timedwait()**sem_wait()**send()**sendmsg()**sendto()**sigpause()**sigsuspend()**sigtimedwait()**sigwait()**sigwaitinfo()**sleep()**system()**tcdrain()**usleep()**wait()**waitid()**waitpid()**write()**writev()*
    |'
  prefs: []
  type: TYPE_TB
- en: In addition to the functions in [Table 32-1](ch32.html#functions_required_to_be_cancellation_po
    "Table 32-1. Functions required to be cancellation points by SUSv3"), SUSv3 specifies
    a larger group of functions that an implementation *may* define as cancellation
    points. These include the *stdio* functions, the *dlopen* API, the *syslog* API,
    *nftw()*, *popen()*, *semop()*, *unlink()*, and various functions that retrieve
    information from system files such as the *utmp* file. A portable program must
    correctly handle the possibility that a thread may be canceled when calling these
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 specifies that aside from the two lists of functions that must and may
    be cancellation points, none of the other functions in the standard may act as
    cancellation points (i.e., a portable program doesn’t need to handle the possibility
    that calling these other functions could precipitate thread cancellation).
  prefs: []
  type: TYPE_NORMAL
- en: SUSv4 adds *openat()* to the list of functions that must be cancellation points,
    and removes *sigpause()* (it moves to the list of functions that *may* be cancellation
    points) and *usleep()* (which is dropped from the standard).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An implementation is free to mark additional functions that are not specified
    in the standard as cancellation points. Any function that might block (perhaps
    because it might access a file) is a likely candidate to be a cancellation point.
    Within *glibc*, many nonstandard functions are marked as cancellation points for
    this reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon receiving a cancellation request, a thread whose cancelability is enabled
    and deferred terminates when it next reaches a cancellation point. If the thread
    was not detached, then some other thread in the process must join with it, in
    order to prevent it from becoming a zombie thread. When a canceled thread is joined,
    the value returned in the second argument to *pthread_join()* is a special thread
    return value: `PTHREAD_CANCELED`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 32-1](ch32.html#canceling_a_thread_with_pthread_undersco "Example 32-1. Canceling
    a thread with pthread_cancel()") shows a simple example of the use of *pthread_cancel()*.
    The main program creates a thread that executes an infinite loop, sleeping for
    a second and printing the value of a loop counter. (This thread will terminate
    only if it is sent a cancellation request or if the process exits.) Meanwhile,
    the main program sleeps for 3 seconds, and then sends a cancellation request to
    the thread that it created. When we run this program, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 32-1. Canceling a thread with *pthread_cancel()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Testing for Thread Cancellation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 32-1](ch32.html#canceling_a_thread_with_pthread_undersco "Example 32-1. Canceling
    a thread with pthread_cancel()"), the thread created by *main()* accepted the
    cancellation request because it executed a function that was a cancellation point
    (*sleep()* is a cancellation point; *printf()* may be one). However, suppose a
    thread executes a loop that contains no cancellation points (e.g., a compute-bound
    loop). In this case, the thread would never honor the cancellation request.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of *pthread_testcancel()* is simply to be a cancellation point.
    If a cancellation is pending when this function is called, then the calling thread
    is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A thread that is executing code that does not otherwise include cancellation
    points can periodically call *pthread_testcancel()* to ensure that it responds
    in a timely fashion to a cancellation request sent by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a thread with a pending cancellation were simply terminated when it reached
    a cancellation point, then shared variables and Pthreads objects (e.g., mutexes)
    might be left in an inconsistent state, perhaps causing the remaining threads
    in the process to produce incorrect results, deadlock, or crash. To get around
    this problem, a thread can establish one or more *cleanup handlers*—functions
    that are automatically executed if the thread is canceled. A cleanup handler can
    perform tasks such as modifying the values of global variables and unlocking mutexes
    before the thread is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Each thread can have a stack of cleanup handlers. When a thread is canceled,
    the cleanup handlers are executed working down from the top of the stack; that
    is, the most recently established handler is called first, then the next most
    recently established, and so on. When all of the cleanup handlers have been executed,
    the thread terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The *pthread_cleanup_push()* and *pthread_cleanup_pop()* functions respectively
    add and remove handlers on the calling thread’s stack of cleanup handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The *pthread_cleanup_push()* function adds the function whose address is specified
    in *routine* to the top of the calling thread’s stack of cleanup handlers. The
    *routine* argument is a pointer to a function that has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *arg* value given to *pthread_cleanup_push()* is passed as the argument
    of the cleanup handler when it is invoked. This argument is typed as *void **,
    but, using judicious casting, other data types can be passed in this argument.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a cleanup action is needed only if a thread is canceled during the
    execution of a particular section of code. If the thread reaches the end of that
    section without being canceled, then the cleanup action is no longer required.
    Thus, each call to *pthread_cleanup_push()* has an accompanying call to *pthread_cleanup_pop()*.
    This function removes the topmost function from the stack of cleanup handlers.
    If the *execute* argument is nonzero, the handler is also executed. This is convenient
    if we want to perform the cleanup action even if the thread was not canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have described *pthread_cleanup_push()* and *pthread_cleanup_pop()*
    as functions, SUSv3 permits them to be implemented as macros that expand to statement
    sequences that include an opening (`{`) and closing (`}`) brace, respectively.
    Not all UNIX implementations do things this way, but Linux and many others do.
    This means that each use of *pthread_cleanup_push()* must be paired with exactly
    one corresponding *pthread_cleanup_pop()* in the same lexical block. (On implementations
    that do things this way, variables declared between the *pthread_cleanup_push()*
    and *pthread_cleanup_pop()* will be limited to that lexical scope.) For example,
    it is not correct to write code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As a coding convenience, any cleanup handlers that have not been popped are
    also executed automatically if a thread terminates by calling *pthread_exit()*
    (but not if it does a simple `return`).
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Example 32-2](ch32.html#using_cleanup_handlers "Example 32-2. Using
    cleanup handlers") provides a simple example of the use of a cleanup handler.
    The main program creates a thread ![](figs/web/U008.png) whose first actions are
    to allocate a block of memory ![](figs/web/U003.png) whose location is stored
    in *buf*, and then lock the mutex *mtx* ![](figs/web/U004.png). Since the thread
    may be canceled, it uses *pthread_cleanup_push()* ![](figs/web/U005.png) to install
    a cleanup handler that is called with the address stored in *buf*. If it is invoked,
    the cleanup handler deallocates the freed memory ![](figs/web/U001.png) and unlocks
    the mutex ![](figs/web/U002.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The thread then enters a loop waiting for the condition variable *cond* to
    be signaled ![](figs/web/U006.png). This loop will terminate in one of two ways,
    depending on whether the program is supplied with a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: If no command-line argument is supplied, the thread is canceled by *main()*
    ![](figs/web/U009.png). In this case, cancellation will occur at the call to *pthread_cond_wait()*
    ![](figs/web/U006.png), which is one of the cancellation points shown in [Table 32-1](ch32.html#functions_required_to_be_cancellation_po
    "Table 32-1. Functions required to be cancellation points by SUSv3"). As part
    of cancellation, the cleanup handler established using *pthread_cleanup_push()*
    is invoked automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a command-line argument is supplied, the condition variable is signaled ![](figs/web/U010.png)
    after the associated global variable, *glob*, is first set to a nonzero value.
    In this case, the thread falls through to execute *pthread_cleanup_pop()* ![](figs/web/U007.png),
    which, given a nonzero argument, also causes the cleanup handler to be invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main program joins with the terminated thread ![](figs/web/U011.png), and
    reports whether the thread was canceled or terminated normally.
  prefs: []
  type: TYPE_NORMAL
- en: Example 32-2. Using cleanup handlers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the program in [Example 32-2](ch32.html#using_cleanup_handlers
    "Example 32-2. Using cleanup handlers") without any command-line arguments, then
    *main()* calls *pthread_cancel()*, the cleanup handler is invoked automatically,
    and we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the program with a command-line argument, then *main()* sets *glob*
    to 1 and signals the condition variable, the cleanup handler is invoked by *pthread_cleanup_pop()*,
    and we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous Cancelability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a thread is made asynchronously cancelable (cancelability type `PTHREAD_CANCEL_ASYNCHRONOUS`),
    it may be canceled at any time (i.e., at any machine-language instruction); delivery
    of a cancellation is not held off until the thread next reaches a cancellation
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with asynchronous cancellation is that, although cleanup handlers
    are still invoked, the handlers have no way of determining the state of a thread.
    In the program in [Example 32-2](ch32.html#using_cleanup_handlers "Example 32-2. Using
    cleanup handlers"), which employs the deferred cancelability type, the thread
    can be canceled only when it executes the call to *pthread_cond_wait()*, which
    is the only cancellation point. By this time, we know that *buf* has been initialized
    to point to a block of allocated memory and that the mutex *mtx* has been locked.
    However, with asynchronous cancelability, the thread could be canceled at any
    point; for example, before the *malloc()* call, between the *malloc()* call and
    locking the mutex, or after locking the mutex. The cleanup handler has no way
    of knowing where cancellation has occurred, or precisely which cleanup steps are
    required. Furthermore, the thread might even be canceled *during* the *malloc()*
    call, after which chaos is likely to result ([Implementation of *malloc()* and
    *free()*](ch07.html#implementation_of_malloc_open_parenthesi "Implementation of
    malloc() and free()")).
  prefs: []
  type: TYPE_NORMAL
- en: As a general principle, an asynchronously cancelable thread can’t allocate any
    resources or acquire any mutexes, semaphores, or locks. This precludes the use
    of a wide range of library functions, including most of the Pthreads functions.
    (SUSv3 makes exceptions for *pthread_cancel()*, *pthread_setcancelstate()*, and
    *pthread_setcanceltype()*, which are explicitly required to be *async-cancel-safe*;
    that is, an implementation must make them safe to call from a thread that is asynchronously
    cancelable.) In other words, there are few circumstances where asynchronous cancellation
    is useful. One such circumstance is canceling a thread that is in a compute-bound
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *pthread_cancel()* function allows one thread to send another thread a cancellation
    request, which is a request that the target thread should terminate.
  prefs: []
  type: TYPE_NORMAL
- en: How the target thread reacts to this request is determined by its cancelability
    state and type. If the cancelability state is currently set to disabled, the request
    will remain pending until the cancelability state is set to enabled. If cancelability
    is enabled, the cancelability type determines when the target thread reacts to
    the request. If the type is deferred, the cancellation occurs when the thread
    next calls one of a number of functions specified as cancellation points by SUSv3\.
    If the type is asynchronous, cancellation may occur at any time (this is rarely
    useful).
  prefs: []
  type: TYPE_NORMAL
- en: A thread can establish a stack of cleanup handlers, which are programmer-defined
    functions that are invoked automatically to perform cleanups (e.g., restoring
    the states of shared variables, or unlocking mutexes) if the thread is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Summary](ch29.html#summary-id28
    "Summary").
  prefs: []
  type: TYPE_NORMAL
