- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 3 STRINGS AND STRING FUNCTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 字符串与字符串函数
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll take a close look at strings, including how to create
    them, how to combine them, and how to search, transform, and otherwise manipulate
    them with PHP’s many built-in string functions. Almost every PHP program and web
    application involves text, so it’s important to understand how to create and work
    with strings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨字符串，包括如何创建它们、如何组合它们，以及如何使用PHP的许多内置字符串函数来搜索、转换和处理它们。几乎每个PHP程序和Web应用程序都涉及文本，因此了解如何创建和操作字符串非常重要。
- en: 'The chapter introduces PHP’s four styles for writing strings: inside single
    quotation marks or double quotation marks, or in longer, multiline spans as heredocs
    or nowdocs. These styles come with different features, such as the ability to
    incorporate variables or represent special symbols. Despite these differences,
    they all end up with the same result: a value of the string data type, which is
    to say, a sequence of characters.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了PHP的四种字符串写法风格：使用单引号或双引号，或者在较长的多行字符串中使用heredoc或nowdoc。这些风格有不同的特点，例如能否嵌入变量或表示特殊符号。尽管这些风格有所不同，它们最终都会得到相同的结果：一个字符串数据类型的值，也就是一串字符。
- en: '### Whitespace'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 空白字符'
- en: Before we consider strings with characters that you can see, such as letters
    and numerals, a word about *whitespace*, the characters you can’t see. These are
    characters that won’t use any ink when printing (for example, the space character,
    the tab character, the newline character, and so on). Sometimes it’s useful to
    distinguish between *horizontal* whitespace, such as spaces and tabs, and *vertical*
    whitespace, such as newline characters and vertical tabs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论可见字符的字符串（如字母和数字）之前，先谈谈*空白字符*，即那些你看不见的字符。这些字符在打印时不会使用任何墨水（例如空格字符、制表符字符、换行符字符等等）。有时区分*水平*空白字符（如空格和制表符）与*垂直*空白字符（如换行符和垂直制表符）是很有用的。
- en: 'When you write code, the details of the whitespace you use are often unimportant
    to the execution of the code. As long as you have a minimum of one whitespace
    character (such as a space or newline) between expressions, it doesn’t matter
    whether you have additional whitespace characters (such as extra spaces or tabs).
    For example, the PHP engine will interpret all four of the following statements
    as exactly the same, ignoring multiple spaces, tabs, and newlines around the variable
    name and equal sign, and on either side of the string:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，你使用的空白字符的细节通常对代码的执行并不重要。只要表达式之间至少有一个空白字符（例如空格或换行符），是否有额外的空白字符（如额外的空格或制表符）并不重要。例如，PHP引擎会将以下四个语句解释为完全相同，忽略变量名和等号两边的多个空格、制表符和换行符，以及字符串两边的空白字符：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you’re declaring or manipulating the contents in string expressions, however,
    you have to be precise about your use of whitespace. Otherwise, words may end
    up stuck together with no space between them, or some text may end up on a different
    line. For example, the strings in these four statements are all different, since
    the extra whitespace is *inside* the quotation marks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你声明或处理字符串表达式中的内容时，你必须精确地使用空白字符。否则，单词可能会粘在一起，没有空格，或者某些文本可能会出现在不同的行上。例如，这四个语句中的字符串都是不同的，因为多余的空白字符*在*引号内：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Whitespace doesn’t come just from the code you write. It can also be introduced
    when you take a string as input from a user or an external software system such
    as an application programming interface (API). In this case, you often need to
    validate that input and trim any unwanted whitespace at its beginning and end.
    Likewise, you may want to replace any tabs or newline characters inside a string
    with single spaces (sometimes users press function keys by accident while typing,
    adding unintended, invisible whitespace characters to their input). You’ll learn
    to do all these things in this chapter (for example, see “Removing All Unnecessary
    Whitespace” on [page 60](#pg_60)).  ### Single-Quoted Strings'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 空白字符不仅仅来源于你写的代码。当你从用户或外部软件系统（如应用程序编程接口（API））获取输入字符串时，也可能会引入空白字符。在这种情况下，你通常需要验证该输入并修剪其开头和结尾的任何不必要的空白字符。同样，你可能希望将字符串中的任何制表符或换行符替换为单个空格（有时用户在输入时不小心按下功能键，导致输入中出现了意外的、不可见的空白字符）。你将在本章中学习如何做这些事情（例如，参见“移除所有不必要的空白字符”在[第60页](#pg_60)）。
- en: The simplest type of string in PHP is enclosed in single quotation marks, such
    as 'matt smith'. Almost everything that appears inside the single quotes is treated
    literally, meaning it will be reproduced exactly as written, character for character,
    if the string is printed out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中最简单的字符串类型是用单引号括起来的，例如 'matt smith'。几乎所有出现在单引号内的内容都会被字面处理，意味着如果打印该字符串，内容将按原样逐字符输出。
- en: 'PHP has just two special cases for single-quoted strings. First, since single
    quotes serve to delimit the string, there must be a mechanism for including a
    single quotation mark inside the string itself. Otherwise, the single quote will
    be interpreted as the end of the string. The solution is to put a backslash in
    front of the single quote (\''), as in ''matt smith\''s string''. When this string
    prints, the single quote will show up, but not the backslash, as you can see here
    in PHP’s interactive mode:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 只有两个特殊的单引号字符串情况。首先，由于单引号用于限定字符串，因此必须有一种机制将单引号包含在字符串内部。否则，单引号会被解释为字符串的结束。解决方案是在单引号前加上反斜杠（\'），就像
    'matt smith\'s string' 中那样。当这个字符串打印时，单引号会显示出来，但反斜杠不会显示，正如你在 PHP 的交互模式中所看到的那样：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This technique of having a special sequence of characters in a string that
    PHP will interpret as a certain character is known as *escaping*. Since the backslash
    is needed to escape single quotation marks, there must also be a way to specify
    a backslash character in a single-quoted string. For that, write two backslashes:
    \\.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在字符串中使用特殊字符序列，并让 PHP 解释为某个特定字符的技术被称为 *转义*。由于反斜杠需要用来转义单引号，因此也必须有一种方法在单引号字符串中指定反斜杠字符。为此，可以写两个反斜杠：\\。
- en: The \' and \\ escape sequences are the only characters that the PHP engine will
    interpret to mean something else in a single-quoted string. Other escape sequences
    you might know from other programming languages, such as \n for newline, aren’t
    recognized in single-quoted strings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: \' 和 \\ 这两个转义序列是 PHP 引擎在单引号字符串中唯一会解释为其他意义的字符。你可能知道的其他转义序列，例如 \n 用于换行，在单引号字符串中不会被识别。
- en: That doesn’t mean you can’t include newlines in single-quoted strings, however.
    For that, simply add line breaks wherever you want them in the string, and PHP
    will reproduce the line breaks exactly as you’ve written them. In fact, one reason
    PHP requires a semicolon to declare the end of a statement is to allow a single
    statement to be written over several lines. [Listing 3-1](#lis3-1) illustrates
    a string broken across multiple lines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着你不能在单引号字符串中包含换行符。为此，只需在字符串中你希望出现换行的地方添加换行符，PHP 会按你写的方式精确地再现这些换行符。实际上，PHP
    要求用分号来声明语句结束的原因之一，是为了允许将单个语句分布在多行中。[列表 3-1](#lis3-1) 展示了一个跨多行的字符串。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-1: A script with a string containing line breaks'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：包含换行符的字符串脚本
- en: 'This script includes a single print statement for a string that contains several
    line breaks. Here’s the output of running this script at the command line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本包括一个打印语句，输出包含多个换行符的字符串。以下是在命令行运行此脚本的输出：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output includes all the newlines that were written into the string.  ###
    Joining Strings: Concatenation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '输出包括了字符串中所有的换行符。 ### 字符串连接：连接'
- en: 'Often you’ll need to combine several strings, variables, or constants to form
    a single string expression. You can do this with PHP’s string concatenation operator,
    represented by a period (.). Consider this example using PHP’s interactive mode:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 经常你需要将多个字符串、变量或常量组合成一个单一的字符串表达式。你可以通过 PHP 的字符串连接运算符实现，表示为句点（.）。考虑以下在 PHP 交互模式中的例子：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We declare the $name variable whose value is the string 'Matt Smith'. Then we
    use the string concatenation operator to combine the value of this variable with
    another string, and we print the resulting longer string. Note the extra space
    in the string 'my name is ' before the closing single quote. The concatenation
    operator doesn’t add any spaces between the strings it’s joining, so this extra
    space is to prevent something like isMatt from being printed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了变量 $name，其值是字符串 'Matt Smith'。然后，我们使用字符串连接运算符将这个变量的值与另一个字符串组合，并打印出结果的更长字符串。注意，在字符串
    'my name is ' 和闭合的单引号之间有额外的空格。连接运算符不会在连接的字符串之间添加任何空格，所以这个额外的空格是为了防止像 isMatt 这样的字符串被打印出来。
- en: When concatenating strings on a single line, it’s good programming practice
    to make the statement more readable by adding a space on each side of the period,
    as in the preceding example. You can also spread such statements over several
    lines, which can help make long string expressions more readable, as shown in
    the script in [Listing 3-2](#lis3-2). This shows my personal preference of indenting
    each subsequent line of the statement and beginning each line with the concatenation
    operator, so it’s clear that each line is appending more to the string expression.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一行中连接字符串时，良好的编程实践是在句点的两边添加空格，以提高可读性，如前面的示例所示。你也可以将这样的语句分布在几行上，这有助于使长字符串表达式更具可读性，正如[清单
    3-2](#lis3-2)中的脚本所示。这展示了我个人的偏好，即缩进语句的每一行，并让每行以连接操作符开始，这样就能清楚地表明每一行都在向字符串表达式追加内容。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-2: A script to concatenate and print out several strings'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-2：一个用于连接并打印多个字符串的脚本
- en: This script prints out a string formed by concatenating four shorter strings
    together, including the two from the previous example. Notice that we’ve escaped
    a single quote to create the apostrophe in the word I'm in the third string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本打印出一个由四个较短字符串连接而成的字符串，其中包括前一个示例中的两个字符串。请注意，我们已经转义了单引号，以在第三个字符串中的单词I'm中创建撇号。
- en: 'The fourth string at the end of the expression is the special string constant
    PHP_EOL, short for *end of line*. This is a string containing the system-appropriate
    character (or characters) to move the cursor to the beginning of the next line
    in a command line terminal (the same as hitting ENTER). Such a special constant
    used to be needed since different operating systems used slightly different ways
    to specify the end of a line. It’s not such an issue now since applications for
    most operating systems generally know how to work with each other’s files these
    days, but the constant is still handy for ensuring that the next terminal prompt
    after a single-quoted string starts on a new line. Here’s the output when this
    script is run at the command line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式末尾的第四个字符串是特殊的字符串常量PHP_EOL，代表*行结束符*。这是一个包含系统适用字符（或字符组）的字符串，用来将光标移动到命令行终端的下一行的开始位置（就像按下ENTER键一样）。由于不同操作系统在指定行结束符时采用的方式略有不同，过去曾经需要这种特殊常量。现在大多数操作系统的应用程序通常能够处理彼此的文件，因此这已经不再是问题，但该常量依然方便用来确保单引号字符串后面的下一个终端提示符出现在新的一行。以下是运行此脚本时在命令行中的输出：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I saved the script from [Listing 3-2](#lis3-2) in a file named *multi_line.php*.
    Running the script concatenates the strings and prints the result on a single
    line. Notice that the next terminal prompt (in this case, the percent character,
    %) appears on the next line, thanks to the PHP_EOL constant.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我将来自[清单 3-2](#lis3-2)的脚本保存为名为*multi_line.php*的文件。运行该脚本时，它将连接字符串并在同一行上打印结果。请注意，接下来的终端提示符（在本例中为百分号字符%）会出现在下一行，这要归功于PHP_EOL常量。
- en: 'If a variable already contains a string, we can use the concatenating assignment
    operator (.=) to append another string expression to the end of that variable.
    Here’s an example using PHP’s interactive mode:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量已经包含了一个字符串，我们可以使用连接赋值操作符（.=）将另一个字符串表达式追加到该变量的末尾。以下是使用PHP交互模式的示例：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we initialize the $name variable to the string ''Matt''. Then we use
    the concatenating assignment operator to append '' Smith'' to the end of the contents
    of $name. When we print out the variable, we can see that it now contains Matt
    Smith.  ### Double-Quoted Strings'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将$name变量初始化为字符串'Matt'。然后，我们使用连接赋值操作符将'Smith'追加到$name的内容末尾。当我们打印该变量时，可以看到它现在包含了Matt
    Smith。### 双引号字符串
- en: 'The second type of PHP string is enclosed in double quotes, as in "Matt Smith".
    Double-quoted strings differ from their single-quoted counterparts in that they
    are *parsed*, or processed, by the PHP engine, which means they can include PHP
    variables. When you write a variable (beginning with a dollar sign) in a double-quoted
    string, the PHP engine will look up the value of the variable and insert it into
    the string before printing. This is often more convenient than using a period
    to concatenate single-quoted strings with the contents of variables, as we did
    in the previous section. Here’s an example using PHP’s interactive mode:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PHP字符串的第二种类型是用双引号括起来的，例如"Matt Smith"。双引号字符串与单引号字符串的不同之处在于，它们会被PHP引擎*解析*，即PHP引擎会处理它们，这意味着它们可以包含PHP变量。当你在双引号字符串中写入一个变量（以美元符号开头）时，PHP引擎会查找变量的值，并在打印之前将其插入到字符串中。这通常比使用句点连接单引号字符串与变量内容更加方便，就像我们在上一节中所做的那样。以下是使用PHP交互模式的示例：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we assign the string 'Matt Smith' to the $name variable, as before. Note
    that we could have used double quotes for this string, but most PHP programmers
    use them only for strings that will need parsing. Next, we print a double-quoted
    string that includes the $name variable. The output shows that PHP has successfully
    parsed this string by inserting Matt Smith in place of the variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将字符串'Matt Smith'赋值给$name变量，就像之前一样。注意，我们本可以使用双引号表示这个字符串，但大多数PHP程序员通常仅在需要解析的字符串中使用双引号。接下来，我们打印一个包含$name变量的双引号字符串。输出显示PHP成功解析了这个字符串，并将Matt
    Smith替换为变量值。
- en: Notice that the double-quoted string includes a single-quote character in the
    contraction I'm. This is perfectly valid in a double-quoted string and doesn’t
    require escaping. Our double-quoted string also includes the escape sequence \n
    to create a newline in the middle of the output. This is one of several escape
    sequences available for use in double-quoted strings. [Table 3-1](#tab3-1) lists
    some of the most common.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，双引号字符串中包含了收缩词I'm中的单引号字符。这在双引号字符串中是完全有效的，并且不需要转义。我们的双引号字符串还包含了转义序列\n，用于在输出中间创建换行符。这是双引号字符串中可以使用的多个转义序列之一。[表格3-1](#tab3-1)列出了其中一些常见的转义序列。
- en: 'Table 3-1: Common Escape Sequences in Double-Quoted Strings'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表格3-1：双引号字符串中的常见转义序列
- en: '| Escape sequence | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 描述 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| \\ | Backslash |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 反斜杠 |'
- en: '| \" | Double-quote |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| \" | 双引号 |'
- en: '| \$ | Dollar sign |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| \$ | 美元符号 |'
- en: '| \n | Newline |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| \n | 换行符 |'
- en: '| \t | Tab |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| \t | 制表符 |'
- en: Notice in particular that since a dollar sign will make the PHP engine parse
    for a variable, you must use \$ to include an actual dollar sign in a double-quoted
    string. You also need to use \" to include a double quotation mark.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是，由于美元符号会让PHP引擎解析变量，所以在双引号字符串中包含实际的美元符号时，必须使用\$。同样，要在字符串中包含双引号，必须使用\"。
- en: You can’t include constants in double-quoted strings, since the PHP engine can’t
    tell the difference between characters that are part of the string and the name
    of the constant. (Recall from [Chapter 1](chapter1.xhtml) that constants don’t
    start with a dollar sign.) One side effect is that you can’t include the PHP_EOL
    constant in a double-quoted string to create a newline at the end of the string.
    Instead, use the \n newline escape sequence.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在双引号字符串中包含常量，因为PHP引擎无法分辨字符串中的字符和常量的名称之间的区别。（回忆一下[第1章](chapter1.xhtml)，常量是没有美元符号的。）其中一个副作用是，你不能在双引号字符串中包含PHP_EOL常量来在字符串末尾创建换行符。相反，你应该使用\n换行符转义序列。
- en: NOTE
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*On the rare occasions when you need the operating system–independent* PHP_EOL
    *constant with a double-quoted string, you can use the string concatenation operator
    to add the constant to the string, much as you saw in [Listing 3-2](#lis3-2).
    This situation might arise when a script needs to precisely output the appropriate
    newline and cursor-to-beginning-of-line character sequence for the system the
    PHP engine is running on (for example, to ensure that a system file has the correct
    line endings).*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*在极少数情况下，当你需要操作系统无关的* PHP_EOL *常量与双引号字符串一起使用时，可以通过字符串连接操作符将常量添加到字符串中，就像你在[示例3-2](#lis3-2)中看到的那样。这种情况可能发生在脚本需要根据PHP引擎运行的系统精确输出适当的换行符和光标到行首的字符序列时（例如，确保系统文件具有正确的行尾符）。*'
- en: Handling the Character After a Variable Name
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理变量名后的字符
- en: 'When you have a variable name followed by a space in a double-quoted string,
    such as "my name is $name \nI''m pleased to meet you", the PHP engine can easily
    identify the variable ($name) and recognize that a space should be present after
    its value. Even punctuation marks such as periods, commas, and colons are fine
    when they immediately follow a variable, and so are escape sequences, since these
    aren’t valid characters to have in variable names. Here, for example, using a
    comma immediately after the $name variable is perfectly fine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量名后跟一个空格出现在双引号字符串中时，例如"my name is $name \nI'm pleased to meet you"，PHP引擎可以轻松识别变量（$name），并确认其值后应跟一个空格。即使是标点符号，如句号、逗号和冒号，紧跟在变量后面也没有问题，转义序列也是如此，因为这些字符在变量名中是不合法的。例如，在$name变量后面紧跟逗号是完全可以的：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want other characters to be part of the string immediately after a variable,
    however, the situation becomes a little more difficult. After its first letter
    (or underscore character), the characters of a variable name can be letters, numbers
    and underscores, so if any of these are written immediately after a variable name
    in a double-quoted string, the PHP engine treats them as part of the variable
    name. For example, if we have a $weight variable and we want its value to be followed
    immediately by kg, as in 80kg, we can’t write something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你希望其他字符紧随变量后面成为字符串的一部分，情况就会变得稍微复杂一些。在变量名的第一个字母（或下划线字符）之后，变量名的字符可以是字母、数字和下划线，因此，如果在双引号字符串中紧跟这些字符，PHP引擎会将它们视为变量名的一部分。例如，如果我们有一个$weight变量，并希望其值后面紧跟kg（例如80kg），我们不能这样写：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The PHP engine would complain, saying there’s no variable named $weightkg.
    The solution for these more complex double-quoted-string parsing tasks is to enclose
    the variable name in curly brackets (braces):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PHP引擎会报错，提示没有名为$weightkg的变量。解决这些更复杂的双引号字符串解析任务的方法是将变量名用花括号（大括号）括起来：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to the curly brackets, PHP has no problem printing the characters kg
    immediately after the value of $weight. Note that this is an example of the string
    context of *type juggling*, as introduced in [Chapter 2](chapter2.xhtml). When
    the string "my weight is {$weight}kg" is parsed, the value of $weight will be
    juggled from the integer 80 into the string '80' for insertion into the final
    string.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了花括号，PHP可以顺利地在$weight的值后面直接打印出kg。请注意，这是*类型转换*字符串上下文的一个例子，如[第2章](chapter2.xhtml)中介绍的那样。当字符串"my
    weight is {$weight}kg"被解析时，$weight的值会从整数80转换为字符串'80'，并插入到最终字符串中。
- en: Incorporating Unicode Characters
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包含Unicode字符
- en: Not all characters are available to type directly from your keyboard or are
    part of the current language settings of your computer system, but that doesn’t
    mean you can’t include them in double-quoted strings. *Unicode* is an international
    standard for declaring and working with a wide range of characters and symbols,
    including ordinary English letters, emojis, letters from other alphabets, and
    more. Each Unicode character is defined by a unique hexadecimal code. For example,
    the code 1F60A corresponds to one of several smiling emojis.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有字符都可以直接通过键盘输入，或者属于当前计算机系统的语言设置，但这并不意味着你不能在双引号字符串中包含它们。*Unicode*是一个国际标准，用于声明和处理各种字符和符号，包括普通的英文字母、表情符号、其他字母表的字母等等。每个Unicode字符都有一个唯一的十六进制代码。例如，代码1F60A对应多个笑脸表情之一。
- en: To use a Unicode character in a double-quoted string, start with the escape
    sequence \u, then provide the character’s hexadecimal code in curly brackets.
    [Listing 3-3](#lis3-3) shows code to declare and print several Unicode characters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在双引号字符串中使用Unicode字符，可以以转义序列\u开始，然后在花括号中提供该字符的十六进制代码。[Listing 3-3](#lis3-3)展示了声明和打印多个Unicode字符的代码。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-3: A script to display various Unicode characters'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-3：显示各种Unicode字符的脚本
- en: 'First, we declare the variables $smiley, $elephant, and $cherokeeTSV to contain
    double-quoted strings with the Unicode characters for their respective smiley
    face and elephant emojis, and the Cherokee TSV symbol. Then we print some double-quoted
    strings that include those variables. Here’s the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明变量$smiley、$elephant和$cherokeeTSV，分别包含带有相应的笑脸和大象表情符号，以及切罗基TSV符号的双引号字符串。然后，我们打印一些包含这些变量的双引号字符串。结果如下：
- en: '![](../images/pg48.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg48.jpg)'
- en: 'Note that we could have included the Unicode character escape sequences directly
    in the double-quoted strings being printed rather than assigning them to variables
    first. Having them in variables makes it easier to reuse them throughout the script—for
    example, to print three elephants instead of just one. (The PHP community has
    a thing for elephants.) For a complete list of Unicode characters and their corresponding
    hexadecimal codes, visit *[https://home.unicode.org](https://home.unicode.org)*.  ###
    Heredocs'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们本可以直接在被打印的双引号字符串中包含Unicode字符的转义序列，而不是先将它们赋值给变量。将它们放在变量中可以让我们更容易地在整个脚本中重用它们——例如，打印三只大象，而不仅仅是一只。（PHP社区特别喜欢大象。）要查看完整的Unicode字符及其对应的十六进制代码，请访问*[https://home.unicode.org](https://home.unicode.org)*。###
    Heredocs
- en: '*Heredocs* are an alternative to double-quoted strings. They’re just like double-quoted
    strings in that they’re parsed and so can contain variables, but they differ in
    that heredocs typically span multiple lines. Although double-quoted strings can
    span multiple lines too, many programmers prefer heredocs for multiline strings
    since their syntax makes them stand out more obviously from the surrounding code.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*Heredoc*是双引号字符串的替代品。它们与双引号字符串类似，都会被解析，因此可以包含变量，但它们的不同之处在于，heredoc通常跨越多行。尽管双引号字符串也可以跨越多行，但许多程序员更喜欢使用heredoc来处理多行字符串，因为它们的语法使得它们与周围的代码更明显地区分开来。'
- en: To declare a heredoc, start with the heredoc operator (<<<), followed by a sequence
    of characters of your choice that will serve as a delimiter. Then, on a new line,
    start typing your string. When you get to the end of the string, repeat your chosen
    delimiter on its own line, followed by a semicolon to end the statement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个heredoc，首先使用heredoc运算符(<<<)，然后跟上你选择的字符序列，作为分隔符。接着，在新的一行开始编写字符串。当你写到字符串的结尾时，在独立的一行重复你选择的分隔符，后面加上分号以结束语句。
- en: The most commonly used delimiter for heredocs is EOT (short for *end of text*),
    but which delimiter you choose doesn’t really matter, as long as that character
    sequence doesn’t appear in the string being declared and as long as the delimiters
    at the beginning and end of the heredoc match. It makes code more readable to
    either always use EOT or choose something meaningful to the heredoc’s contents,
    such as SQL if it contains a SQL statement or HTML if it contains HTML. [Listing
    3-4](#lis3-4) shows a script with an example heredoc.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的heredoc分隔符是EOT（即*end of text*的缩写），但选择哪个分隔符并不重要，只要该字符序列没有出现在被声明的字符串中，并且heredoc的开头和结尾的分隔符匹配。为了提高代码的可读性，建议要么始终使用EOT，要么选择与heredoc内容相关的有意义的分隔符，例如，如果它包含SQL语句，则使用SQL，或者如果它包含HTML，则使用HTML。[列表3-4](#lis3-4)展示了一个包含示例heredoc的脚本。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-4: A heredoc string declared and printed with the EOT delimiter'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3-4：使用EOT分隔符声明并打印的heredoc字符串
- en: 'This code creates the variables $age and $weight containing 22 and 80, respectively.
    Then we assign a heredoc expression into the $message variable ❶. The heredoc
    starts with <<<EOT, and its content is everything from the next line until a newline
    character and the EOT; at the end ❷. Finally, we print the contents of $message.
    Here’s the result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了变量$age和$weight，分别包含22和80。然后，我们将一个heredoc表达式赋值给$message变量❶。heredoc以<<<EOT开始，它的内容是从下一行开始直到遇到换行符和EOT;结束❷。最后，我们打印$message的内容。以下是结果：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I saved the script as *heredoc.php* and ran it at the command line. Notice that
    the variables $age and $weight were successfully parsed within the heredoc, including
    when we used curly brackets to allow characters to be output immediately following
    a variable. Notice also that the next command line prompt starts on its own line.
    This is because of the blank line in the heredoc before the closing delimiter;
    heredocs can contain newlines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我将脚本保存为*heredoc.php*并在命令行运行。请注意，变量$age和$weight在heredoc中成功解析，包括当我们使用大括号时，使得变量后面的字符可以立即输出。还要注意，接下来的命令行提示符在新的一行开始。这是因为heredoc在关闭分隔符前有一个空行；heredoc可以包含换行符。
- en: Escape Sequences
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转义序列
- en: 'You can’t use the \" escape sequence to write a double quotation mark in a
    heredoc. If you write \" inside a heredoc, the backslash will become an ordinary
    character in the string, just like the double quote. You won’t need this escape
    sequence in heredocs anyway: since you’re no longer using double quotes to delimit
    the string, using them within the string won’t cause confusion.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用 \" 转义序列在 heredoc 中写入双引号。如果你在 heredoc 中写入 \"，反斜杠将成为字符串中的普通字符，就像双引号一样。在
    heredoc 中你根本不需要这个转义序列：由于你不再使用双引号来界定字符串，在字符串内使用双引号不会引起混淆。
- en: You *can* include other escape sequences in heredocs, such as \t for tabs and
    \n for newlines. These, too, aren’t strictly necessary, however, since you can
    just use the TAB and ENTER keys when writing the heredoc’s contents. You can also
    type Unicode characters directly into a heredoc (assuming your editor supports
    Unicode, that is). [Listing 3-5](#lis3-5) shows an example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*在 heredoc 中包含其他转义序列，比如 \t 表示制表符，\n 表示换行。然而，这些转义序列并不是严格必要的，因为你可以直接在编写 heredoc
    内容时使用 TAB 和 ENTER 键。如果你的编辑器支持 Unicode，你还可以直接在 heredoc 中输入 Unicode 字符。[清单 3-5](#lis3-5)展示了一个示例。
- en: '![](../images/pg50.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg50.jpg)'
- en: 'Listing 3-5: A script with Unicode characters declared in a heredoc string'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-5：在 heredoc 字符串中声明 Unicode 字符的脚本
- en: We declare this heredoc by using UNICODE as the delimiter. The code features
    Unicode characters typed directly into the string, rather than created via escape
    sequences. The output of running this script is identical to the output from [Listing
    3-3](#lis3-3).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 UNICODE 作为定界符来声明这个 heredoc。代码中的 Unicode 字符是直接输入到字符串中的，而不是通过转义序列创建的。运行这个脚本的输出与[清单
    3-3](#lis3-3)的输出相同。
- en: Indention
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩进
- en: An occasionally useful feature of heredocs is that if indention (spaces or tabs)
    appears before the closing delimiter, the PHP engine will attempt to remove that
    same amount of indention from all lines of the heredoc. In [Listing 3-6](#lis3-6),
    for example, we declare and print a heredoc string that has each of its lines,
    including the line with the ending TEXT delimiter, indented four spaces.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: heredocs 的一个偶尔有用的特性是，如果在结束定界符之前出现了缩进（空格或制表符），PHP 引擎会尝试从 heredoc 的所有行中移除相同数量的缩进。例如，在[清单
    3-6](#lis3-6)中，我们声明并打印了一个 heredoc 字符串，其中每一行（包括包含结束 TEXT 定界符的那一行）都缩进了四个空格。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-6: A script with an indented heredoc'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-6：带有缩进的 heredoc 脚本
- en: 'Since every line of this heredoc has the same indention as the closing delimiter
    line, all indention will be removed from all lines when the string is printed.
    Here’s the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个 heredoc 的每一行都与结束定界符行有相同的缩进，因此在打印字符串时，所有缩进都会从每一行中移除。输出结果如下：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If any lines in a heredoc have more indention than the line with the closing
    delimiter, that extra bit of indention will remain in the output. [Listing 3-7](#lis3-7)
    shows an example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 heredoc 中的任何行比结束定界符行有更多的缩进，这部分额外的缩进将保留在输出中。[清单 3-7](#lis3-7)展示了一个示例。
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-7: A script that retains extra indention in a heredoc'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-7：保留 heredoc 中额外缩进的脚本
- en: 'The first and last lines of the heredoc are indented four spaces, as is the
    closing delimiter. The middle two lines of the heredoc have two extra spaces of
    indention. In the output, four spaces will be stripped away from the start of
    each line, leaving two spaces of indention for the middle two lines, as shown
    here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 heredoc 的第一行和最后一行都缩进了四个空格，结束定界符也有四个空格的缩进。heredoc 中间的两行多缩进了两个空格。在输出中，四个空格将从每一行的开头被去掉，留下中间两行的两个空格缩进，如下所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This feature of removing indentation from a heredoc is primarily useful when
    the heredoc is declared as part of a function’s body, where it’s customary for
    all code to have some level of indention. This way, you can write cleaner-looking
    heredocs that adhere to the indention conventions of the code around them. We’ll
    meet functions in [Chapter 5](chapter5.xhtml).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 heredoc 缩进的这个特性主要在 heredoc 作为函数体的一部分时非常有用，因为在这种情况下，所有代码通常都有一定的缩进级别。这样，你就可以编写更整洁的
    heredoc，使其符合周围代码的缩进约定。我们将在[第 5 章](chapter5.xhtml)中介绍函数。
- en: NOTE
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If any lines in a heredoc have less indention than the closing delimiter,
    or if they have a different kind of indention (such as a tab character instead
    of spaces), an error will occur at runtime.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果 heredoc 中的任何行缩进比结束定界符少，或者它们使用了不同类型的缩进（比如使用了制表符而不是空格），则在运行时会发生错误。*'
- en: Nowdocs
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nowdocs
- en: The last style of PHP string is the *nowdoc*, an unparsed string written with
    the <<< operator and delimiters. Essentially, the nowdoc is to unparsed single-quoted
    strings what the heredoc is to parsed double-quoted strings. The only difference
    between declaring a nowdoc and a heredoc is that the opening delimiter for the
    nowdoc must be enclosed in single quotes, as in <<<'EOL'. The closing delimiter
    isn’t written with single quotes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 字符串的最后一种风格是 *nowdoc*，它是一个使用 <<< 运算符和定界符编写的未解析字符串。本质上，nowdoc 对未解析的单引号字符串的作用就像
    heredoc 对解析的双引号字符串的作用。声明 nowdoc 和 heredoc 的唯一区别是 nowdoc 的起始定界符必须用单引号括起来，如 <<<'EOL'。结束定界符则不使用单引号。
- en: One use of nowdocs is for printing out PHP code. Since nowdocs are unparsed,
    any code, including variable names, will be reproduced literally in the string
    expression. [Listing 3-8](#lis3-8) shows an example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: nowdocs 的一种用途是打印 PHP 代码。由于 nowdocs 是未解析的，任何代码，包括变量名，都将被字面复制到字符串表达式中。[清单 3-8](#lis3-8)
    显示了一个示例。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-8: A script declaring a nowdoc that contains unparsed PHP code'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-8：声明一个包含未解析 PHP 代码的 nowdoc 脚本
- en: 'First, we declare a $name variable ❶. Then we declare a nowdoc by using the
    delimiter PHP and assign it to the $codeSample variable ❷. (Notice that the starting
    delimiter is enclosed in single quotes, but the ending delimiter isn’t.) The nowdoc
    contains statements such as a variable declaration ($age), strings with escaped
    characters, and a reference to our $name variable ❸. All of this goes unparsed
    when we print the nowdoc, as you can see in the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个 $name 变量 ❶。然后，我们通过使用定界符 PHP 声明一个 nowdoc，并将其赋值给 $codeSample 变量 ❷。（注意，起始定界符用单引号括起来，而结束定界符没有。）nowdoc
    包含诸如变量声明（$age）、带有转义字符的字符串以及对 $name 变量的引用 ❸。当我们打印 nowdoc 时，所有这些内容都没有被解析，正如你在输出中看到的：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The entire nowdoc has been printed verbatim, including the escape sequences
    and the characters $name. No program statements within the nowdoc were executed;
    they just became part of the declared nowdoc string. Notice, however, that the
    indention in the nowdoc has been stripped away, since it matches the indention
    of the closing delimiter. This works just as with heredocs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 nowdoc 被逐字打印，包括转义序列和字符 $name。nowdoc 中的程序语句没有被执行；它们仅仅成为声明的 nowdoc 字符串的一部分。需要注意的是，nowdoc
    中的缩进被去除了，因为它与结束定界符的缩进相匹配。这与 heredoc 的行为一致。
- en: We’ve finished our overview of the four styles of strings. Deciding which to
    use is often a matter of personal preference. In general, single quotes are best
    for short strings that don’t include variables that require parsing. For longer,
    multiline strings with no parsing, consider using nowdocs. If you need to incorporate
    parsed variables, use double quotes for shorter strings or heredocs for longer,
    multiline strings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了四种字符串风格的概述。选择使用哪一种通常是个人偏好的问题。一般来说，单引号最适用于不包含需要解析的变量的短字符串。对于没有解析的较长多行字符串，可以考虑使用
    nowdocs。如果需要包含解析的变量，则对于较短的字符串使用双引号，或者对于较长的多行字符串使用 heredocs。
- en: Built-in String Functions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置字符串函数
- en: PHP has more than 100 built-in functions for manipulating and analyzing strings,
    ranging from standard tasks like toggling between uppercase and lowercase letters
    to more specialized tasks such as implementing hash algorithms. We’ll look at
    a few of the most commonly used string functions in this section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 有超过 100 个内置函数，用于操作和分析字符串，涵盖从标准任务（如大小写转换）到更专业的任务（如实现哈希算法）。我们将在本节中介绍一些最常用的字符串函数。
- en: If you’re coming to PHP from another language, you may be used to seeing these
    kinds of operations as methods that are called directly on the strings themselves.
    Since PHP wasn’t originally object-oriented, however, the operations instead exist
    as stand-alone functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从其他编程语言转到 PHP，可能已经习惯于将这些操作作为直接在字符串本身上调用的方法。然而，由于 PHP 最初并不是面向对象的，因此这些操作作为独立函数存在。
- en: NOTE
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For a complete list of PHP’s string functions, see* [https://www.php.net/manual/ref.strings.php](https://www.php.net/manual/ref.strings.php)*.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 PHP 字符串函数的完整列表，请参见* [https://www.php.net/manual/ref.strings.php](https://www.php.net/manual/ref.strings.php)*。*'
- en: Converting to Upper- and Lowercase
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换为大写和小写
- en: 'When working with user input, you’ll often need to standardize strings by ensuring
    that they all follow the same capitalization rules. This makes it easier to compare
    strings, or to store text in a database or send it to an API using a consistent
    format. To that end, PHP has functions for adjusting the capitalization of a string.
    The strtolower() and strtoupper() functions convert all the letters to lowercase
    or uppercase, respectively. Here are some examples illustrated using PHP’s interactive
    mode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户输入时，你经常需要通过确保所有字符串都遵循相同的大小写规则来标准化字符串。这使得比较字符串更容易，或者以一致的格式将文本存储到数据库或发送到
    API。为此，PHP 提供了调整字符串大小写的函数。strtolower() 和 strtoupper() 函数分别将所有字母转换为小写或大写。以下是一些使用
    PHP 交互模式演示的示例：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We declare a string with a mix of uppercase and lowercase letters. Passing the
    string to the strtolower() function converts everything to lowercase, while passing
    it to strtoupper() converts everything to uppercase.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个包含大写字母和小写字母的字符串。将该字符串传递给 strtolower() 函数会将所有字母转换为小写，而传递给 strtoupper()
    函数则会将所有字母转换为大写。
- en: 'PHP’s ucfirst() function capitalizes just the first letter of a string, if
    it isn’t capitalized already. This is useful when creating messages to be output
    to the user; capitalizing the first letter helps make the messages look like grammatically
    correct sentences:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 ucfirst() 函数将字符串的首字母大写（如果它还没有大写的话）。这在创建要输出给用户的消息时非常有用；将首字母大写有助于使消息看起来像语法正确的句子：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The related function lcfirst() lowercases just the first letter of a string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的函数 lcfirst() 会将字符串的首字母转换为小写：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Often this isn’t much of a grammatical improvement, but it can be useful, for
    example, if you’re writing a script to output code. In this case, to follow the
    naming conventions of the programming language (such as for variables), it can
    be important to ensure that the first character of a string is lowercase.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这不会对语法带来太大的改进，但它在某些情况下是有用的，例如，如果你正在编写一个输出代码的脚本。在这种情况下，为了遵循编程语言的命名约定（例如变量的命名），确保字符串的第一个字符是小写可能很重要。
- en: 'The ucwords() function capitalizes the first letter of every word in a string.
    PHP can distinguish between the different words if they’re separated by whitespace:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ucwords() 函数将字符串中每个单词的首字母大写。如果单词之间用空格分隔，PHP 可以区分这些不同的单词：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that if any subsequent letters in a word are capitalized, they remain
    so. Only the first letter of each word is affected. PHP doesn’t have an equivalent
    function for lowercasing the first letter of each word.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果单词中的后续字母是大写的，它们将保持不变。只有每个单词的首字母会受到影响。PHP 没有类似的函数可以将每个单词的首字母转换为小写。
- en: Searching and Counting
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索和计数
- en: Several of PHP’s built-in string functions serve analytical purposes, such as
    reporting the length of a string, searching for a character or substring within
    a string, or counting the number of occurrences of a character or substring within
    a string. (A *substring* is a portion of a larger string.) Before we examine these
    functions, though, it’s important to distinguish between the *number* of characters
    in a string and the *position* of each character within that string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的多个内置字符串函数用于分析目的，例如报告字符串的长度、在字符串中查找字符或子字符串，或计算字符串中字符或子字符串的出现次数。（*子字符串*是一个较大字符串的部分。）不过，在我们研究这些函数之前，有必要区分字符串中*字符的数量*和*字符在字符串中的位置*。
- en: 'Take the string ''cat scat'' as an example. It consists of eight characters
    (the space in the middle counts), but character positions in PHP are numbered
    starting from zero. Thus, the character at position 0 is c, at position 1 is a,
    and so on up to the final t at position 7. This counting from zero is called *zero-based
    indexing* and is common in computer programming. Using this system, we can say
    that the substring ''cat'' occurs twice in the string, starting at position 0
    for the first occurrence and at position 5 for the second:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以字符串 'cat scat' 为例。它包含八个字符（中间的空格也算），但是在 PHP 中，字符位置是从零开始编号的。因此，位置 0 上的字符是 c，位置
    1 上的是 a，以此类推，直到位置 7 上的 t。这个从零开始计数的方式被称为 *零基索引*，它在计算机编程中很常见。使用这个系统，我们可以说子字符串 'cat'
    在字符串中出现了两次，第一次出现在位置 0，第二次出现在位置 5：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this in mind, let’s try out some analytical string functions on the string
    ''cat scat''. First, the strlen() function reports the length of a string, as
    shown here in PHP’s interactive mode:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个概念，我们来试一下对字符串 'cat scat' 使用一些分析性字符串函数。首先，strlen() 函数报告字符串的长度，如下所示，使用 PHP
    交互模式：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, this tells us that 'cat scat' is eight characters long.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这告诉我们 'cat scat' 的长度是 8 个字符。
- en: 'The substr_count() function counts the number of times a substring appears
    within a string. Here, for example, we count the instances of the substring ''cat'':'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: substr_count() 函数用于计算子字符串在字符串中出现的次数。例如，在这里，我们计算子字符串 'cat' 出现的次数：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We pass two strings to the substr_count() function. The first is the string
    we want to search *in*, which here we’re providing as the $myString variable.
    The second is the string we want to search *for*: in this case, ''cat''. In computer
    search terminology, these two strings are often referred to as the *haystack*
    and the *needle*, respectively, after the expression “looking for a needle in
    a haystack.”'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 substr_count() 函数传递两个字符串。第一个是我们要搜索的字符串*所在*的位置，在这里我们提供的是 $myString 变量。第二个是我们要搜索的字符串*目标*：在这个例子中是
    'cat'。在计算机搜索术语中，这两个字符串通常被称为*大海捞针*中的*针*和*海*，来源于“在大海捞针”这一表达。
- en: NOTE
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The items entered within the parentheses of a function, such as* $myString
    *and* ''cat'' *in the preceding example, are called* arguments*. They’re pieces
    of data that the function needs to do its job. We’ll discuss functions in detail
    in [Chapter 5](chapter5.xhtml).*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*在函数的括号中输入的项目，例如* $myString *和* ''cat'' *在上面的例子中，被称为*参数*。它们是函数执行任务所需要的数据。我们将在[第
    5 章](chapter5.xhtml)详细讨论函数。*'
- en: 'Most PHP functions that involve searching within a string, including substr_count(),
    are case sensitive, so it’s important to be careful about capitalization. If we
    try searching ''cat scat'' for the substring ''Cat'' instead of ''cat'', for example,
    we’ll end up with a count of 0:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数涉及字符串搜索的 PHP 函数，包括 substr_count()，都是区分大小写的，因此在处理时需要注意字母的大小写。例如，如果我们尝试在 'cat
    scat' 中搜索子字符串 'Cat' 而不是 'cat'，我们会得到计数为 0 的结果：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The strpos() function reports the starting position (counting from zero) of
    a substring within a string. If the substring occurs multiple times, only the
    position of the first occurrence is given. Here we search for the first occurrence
    of the substring ''cat'':'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: strpos() 函数报告子字符串在字符串中出现的起始位置（从零开始计数）。如果子字符串出现多次，只会给出第一次出现的位置。在这里，我们搜索子字符串 'cat'
    的第一次出现：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with substr_count(), we provide two strings to the strpos() function as arguments,
    first the haystack and then the needle. The function reports the first occurrence
    of 'cat' at position 0.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与 substr_count() 相似，我们向 strpos() 函数传递两个字符串作为参数，第一个是大海（haystack），第二个是针（needle）。该函数报告
    'cat' 第一次出现的位置为 0。
- en: 'Optionally, you can provide an *offset* to the strpos() function as an additional
    argument, a number that tells it to start searching for the substring from a different
    position, rather than from the beginning of the string. Here we tell the function
    to start searching from position 2 onward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以向 strpos() 函数提供一个*偏移量*作为附加参数，这是一个告诉它从不同位置开始搜索子字符串的数字，而不是从字符串的开头开始搜索。在这里，我们告诉函数从位置
    2 开始搜索：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, since the function isn’t searching from the beginning of the string,
    it identifies the second occurrence of 'cat' at position 5. If the function can’t
    find any occurrences of the needle within the haystack, it reports false.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，由于函数不是从字符串的开头进行搜索，它会识别出 'cat' 的第二次出现，位置为 5。如果函数没有找到目标子字符串，它会返回 false。
- en: 'The count_chars() function analyzes which characters are, and are not, included
    in a string. It’s a powerful string analysis function that you might use when
    evaluating the complexity of a password or perhaps for data encryption and decryption
    tasks. It has a few modes, which you specify as a number when the function is
    called. In the following example, we use mode 3, which generates a new string
    consisting of all the unique characters used in the string being analyzed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: count_chars() 函数分析字符串中包含和不包含的字符。它是一个强大的字符串分析函数，你可能会在评估密码复杂度或进行数据加密和解密任务时使用。它有几个模式，可以通过在调用函数时指定数字来选择。在下面的例子中，我们使用模式
    3，它生成一个新字符串，其中包含被分析字符串中所有唯一的字符：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We call the count_chars() function on $myString, specifying mode 3\. The resulting
    string features one instance of each character from 'cat scat', arranged in alphabetical
    order. It shows us that 'cat scat' includes only the letters *a*, *c*, *s*, and
    *t*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 $myString 上调用 count_chars() 函数，并指定模式 3。结果字符串显示了 'cat scat' 中每个字符的一个实例，并按字母顺序排列。它告诉我们，'cat
    scat' 仅包含字母 *a*、*c*、*s* 和 *t*。
- en: NOTE
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* count_chars() *function has other modes that count the number of occurrences
    of each character, but the result is reported as an array, so we won’t consider
    those modes here. We’ll discuss arrays in [Chapters 7](chapter7.xhtml) and [8](chapter8.xhtml).*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Extracting and Replacing Substrings
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Other PHP functions manipulate strings by extracting a portion of the string
    or replacing a portion with something else. For example, the substr() function
    extracts part of a string, starting from a given position. Here’s how it works:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We declare a variable with the string 'do not enter', then pass it to the substr()
    function. The number 7 tells the function to extract all the characters from position
    7 to the end, giving us enter as a result.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a negative number instead, the function makes the extraction counting
    from the end of the string. For example, here we use -2 to get just the last two
    characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can optionally include a second number in the function call to specify
    a length for the extraction. Here, for example, we extract just three characters
    from the string, starting from position 7:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The strstr() function provides another technique for extracting part of a string.
    By default, it searches for the first occurrence of a substring within a string
    and extracts the contents of the string from that substring on. Here, for example,
    we search for the substring ''@'' to extract just the domain name and extension
    from an email address:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function searches for the first occurrence of an @ sign and reports everything
    in the string from that point on, including the @ sign itself. We can also use
    strstr() to extract everything in the string *before* the first occurrence of
    the substring. For that, add true to the end of the function call, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, we search the string for the first occurrence of an @ sign, but this
    time, thanks to the added true, the function reports the contents of the string
    up to but not including the @ sign. This gives us just the username from the email
    address.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* strstr() *function is case sensitive, but PHP provides a case-insensitive
    version called* stristr()*.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The str_replace() function finds all occurrences of a substring within a string
    and replaces them with a different substring. The result of the replacement is
    reported as a new string, meaning the original string itself isn’t modified. Here’s
    an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we call str_replace(), we need to provide three strings. The first is the
    substring to search for (in this case, 'eat'). The second is the substring to
    replace it with (in this case, 'help'). The third is the string to search in,
    which we’ve assigned to the $foodchain variable. The function generates a new
    string by replacing all instances of 'eat' with 'help'. Then we print the value
    of $foodchain to confirm that it wasn’t affected by the function call.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the replacement somewhat permanent, store the result of calling str_replace()
    in a new variable, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time when we call str_replace(), we assign the result to $friendchain ❶.
    The original $foodchain variable is still unaffected by the replacement operation
    ❷, but at least now we have the modified string available in a variable for later
    use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们调用 str_replace() 时，我们将结果赋值给 $friendchain ❶。原始的 $foodchain 变量仍然没有受到替换操作的影响
    ❷，但至少现在我们已经有了一个修改后的字符串，可以在之后使用。
- en: 'Another replacement function is substr_replace(). Rather than specifying a
    substring that should be replaced, this function lets you specify the position
    in the string at which the replacement should occur. Here’s an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替换函数是 substr_replace()。与指定要替换的子字符串不同，这个函数允许你指定替换操作应该发生的位置。以下是一个示例：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we call the substr_replace() function, we first provide the original string
    (in $foodchain) and the replacement string ('help'). Then we provide two numbers
    as additional arguments. The first, 5, is the position in the original string
    where the replacement should begin. The second, 3, is the number of characters
    in the original string that should be replaced, starting from the specified position.
    This has the effect of replacing the first instance of the word *eat* (which is
    three characters long and starts at position 5) with the word *help*, while leaving
    the rest of the string as is.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 substr_replace() 函数时，首先提供原始字符串（在 $foodchain 中）和替换字符串（'help'）。然后我们提供两个额外的数字作为参数。第一个数字
    5 是原始字符串中替换开始的位置。第二个数字 3 是原始字符串中从指定位置开始替换的字符数。这样会将单词 *eat*（该单词长度为 3，从位置 5 开始）替换为单词
    *help*，同时保留字符串的其余部分不变。
- en: 'By setting the replacement length to 0, we can use substr_replace() to insert
    a substring into a string without otherwise altering it, like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将替换长度设置为 0，我们可以使用 substr_replace() 向字符串中插入子字符串，而不对其进行其他修改，如下所示：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This inserts the word *don’t* into the $foodchain string starting at position
    5, without replacing any characters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 $foodchain 字符串的第 5 位开始插入单词 *don’t*，而不会替换任何字符。
- en: Trimming Whitespace
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 去除空白字符
- en: 'Often it’s necessary to remove whitespace from the beginning or end of a string,
    a task known as *trimming*. PHP provides three trimming functions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要去除字符串开头或结尾的空白字符，这个任务叫做 *trimming*（修剪）。PHP 提供了三个修剪函数：
- en: trim()   Removes whitespace from the beginning *and* end of a string
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: trim()   去除字符串开头和结尾的空白字符
- en: ltrim()   Removes whitespace from the beginning of a string (*l* is for *left*)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ltrim()   去除字符串开头的空白字符（*l* 代表 *left*，即左侧）
- en: rtrim()   Removes whitespace the from end of a string (*r* is for *right*)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: rtrim()   去除字符串结尾的空白字符（*r* 代表 *right*，即右侧）
- en: 'All three functions work in the same way: given a string, they remove any space,
    tab, vertical tab, newline, carriage return, or American Standard Code for Information
    Interchange (ASCII) null-byte characters, up to the first non-whitespace character
    and/or after the last non-whitespace character in the string. Here, for example,
    we use trim() to remove the spaces and newline characters at the start and end
    of a string:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数的工作原理相同：给定一个字符串，它们会去除所有的空格、制表符、垂直制表符、换行符、回车符或美国标准信息交换码（ASCII）空字节字符，直到第一个非空白字符和/或字符串最后一个非空白字符为止。例如，这里我们使用
    trim() 去除字符串开头和结尾的空格和换行符：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output shows that the newlines and the beginning and end of the string have
    been trimmed, but notice that a newline still remains between the words *CAT*
    and *DOG*. The trim functions have no effect on any whitespace in the middle of
    a string.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，字符串的换行符以及开头和结尾的空白字符已经被去除，但请注意，*CAT* 和 *DOG* 之间仍然保留了一个换行符。trim 函数对字符串中间的空白字符没有影响。
- en: 'You can optionally control which whitespace characters are trimmed by specifying
    them in a separate double-quoted string when calling the function. Here’s an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择性地通过在调用函数时，在一个单独的双引号字符串中指定要去除的空白字符。以下是一个示例：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This time we use the string "\n" ❶ to specify that only newline characters should
    be trimmed. In the output, notice that the spaces before the word CAT have been
    preserved, since the function ignored all but newline characters. The blank line
    ❷ before the next prompt also indicates that the newlines at the end of the string
    were left in place, since the ltrim() function affects only the start of the string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用字符串 "\n" ❶ 来指定仅去除换行符。在输出中，注意到单词 *CAT* 前的空格被保留，因为函数只忽略了除换行符外的其他字符。下一个提示符前的空行
    ❷ 也表明，字符串末尾的换行符保持原样，因为 ltrim() 函数只影响字符串的开头部分。
- en: '#### Removing All Unnecessary Whitespace'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove whitespace from throughout a string, not just the edges, use str_replace()
    to find all instances of a particular whitespace character and replace them with
    empty strings. For example, here we use this technique to get rid of all the tab
    characters in a string:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The string assigned to $tooTabby contains several tab characters. Replacing
    each instance of "\t" with '' (an empty string) gets rid of the tabs while preserving
    the regular spaces between each word.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](#lis3-9) pushes this technique even further, repeatedly using
    str_replace() to remove any whitespace from a string except for a single space
    character between words. This includes getting rid of tabs, newlines, and multiple
    space characters in a row.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 3-9: Replacing all whitespace (except single space characters) in a
    string'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We use a heredoc to declare the $string1 variable, which contains tabs, newline
    characters, and multiple spaces in a row between words ❶. Then we use the str_replace()
    function twice, first to replace all tabs with a single space, and a second time
    to replace all newline characters with a single space ❷. (We don’t replace them
    with empty strings in case a tab or newline is the only character between two
    words.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we repeatedly use str_replace() to replace any instances of two space
    characters with a single space ❸. It takes three function calls before only single
    spaces are left. (In [Chapter 6](chapter6.xhtml), we’ll delve into loops, which
    provide a more efficient way to repeat the same code several times, or until a
    particular condition is satisfied.) For good measure, we use trim() to remove
    any lingering whitespace at the start or end of the string before printing out
    the resulting string, enclosed in square brackets so it’s easier to see where
    it starts and ends. Here’s the output of running this script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The final string has no whitespace before or after it and only single spaces
    between each word. All the extra whitespace has been removed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Repeating and Padding
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some PHP string functions work by repeating a character or substring to generate
    a longer string. For example, to create a new string by repeating a string a given
    number of times, use str_repeat(), like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This gives our lonely string some company by repeating 'Cat' five times.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Closely related to repeating is *padding*: a character or substring is repeatedly
    added to the beginning or end of a string until the string reaches a desired length.
    Padding is useful, for example, if you’re displaying multiple numbers of different
    lengths and you want their digits to line up nicely. In that case, you might add
    spaces or zeros as padding in front of the numbers, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'PHP has a str_pad() function for such padding tasks. Here, for example, we
    pad the string ''Cat'' with hyphens (-) until it’s 20 characters long:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We call str_pad(), providing the original string ($tooShort), the desired length
    (20), and the string to use as padding (''-''). By default, PHP adds the padding
    to the right of the original string, but you can add the constants STR_PAD_LEFT
    or STR_PAD_BOTH to the function call to place the padding on the left or to pad
    both sides equally instead. Here are some examples:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In each case, the function adds hyphens until the resulting string is 20 characters
    long.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings are a core data type that you’ll probably use in every web application
    you create. In this chapter, you learned about the four ways to declare strings:
    single-quoted strings, double-quoted strings, heredocs, and nowdocs. You saw how
    double-quoted strings and heredocs are parsed and so can incorporate variables,
    while single-quoted strings and nowdocs are not. You also tried out PHP’s built-in
    functions for working with strings, and you learned how to combine strings by
    using the . and .= operators.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a script that declares a $name variable containing your name as
    a single-quoted string. Then include a print statement that uses the string concatenation
    operator (.) to combine the contents of $name with the string '' is learning PHP''.
    When you run your script, the output should look something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '2.   In a script, create a $fruit variable containing the string ''apple''.
    Then use a double-quoted string and a print statement to output the following
    message:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change your script so that $fruit contains orange, leading to the following
    output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Hint: You’ll need to use curly brackets to create the plural fruit names from
    the $fruit variable.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Write a script that declares a heredoc string variable $happyMessage containing
    the following (including the newlines):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg63.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Print out the contents of the $happyMessage variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 4.   In a script, create an $appleJuice variable containing the string 'apple
    juice is made from apples.' Then use the str_replace() function to create a new
    string variable, $grapefruitJuice, containing the string 'grapefruit juice is
    made from grapefruits.' Try using other PHP functions to further transform the
    string. For example, capitalize the first letter of the string so it looks like
    a grammatically correct sentence.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
