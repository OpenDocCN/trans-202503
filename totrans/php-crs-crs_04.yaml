- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 3 STRINGS AND STRING FUNCTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll take a close look at strings, including how to create
    them, how to combine them, and how to search, transform, and otherwise manipulate
    them with PHP’s many built-in string functions. Almost every PHP program and web
    application involves text, so it’s important to understand how to create and work
    with strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter introduces PHP’s four styles for writing strings: inside single
    quotation marks or double quotation marks, or in longer, multiline spans as heredocs
    or nowdocs. These styles come with different features, such as the ability to
    incorporate variables or represent special symbols. Despite these differences,
    they all end up with the same result: a value of the string data type, which is
    to say, a sequence of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Whitespace'
  prefs: []
  type: TYPE_NORMAL
- en: Before we consider strings with characters that you can see, such as letters
    and numerals, a word about *whitespace*, the characters you can’t see. These are
    characters that won’t use any ink when printing (for example, the space character,
    the tab character, the newline character, and so on). Sometimes it’s useful to
    distinguish between *horizontal* whitespace, such as spaces and tabs, and *vertical*
    whitespace, such as newline characters and vertical tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write code, the details of the whitespace you use are often unimportant
    to the execution of the code. As long as you have a minimum of one whitespace
    character (such as a space or newline) between expressions, it doesn’t matter
    whether you have additional whitespace characters (such as extra spaces or tabs).
    For example, the PHP engine will interpret all four of the following statements
    as exactly the same, ignoring multiple spaces, tabs, and newlines around the variable
    name and equal sign, and on either side of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re declaring or manipulating the contents in string expressions, however,
    you have to be precise about your use of whitespace. Otherwise, words may end
    up stuck together with no space between them, or some text may end up on a different
    line. For example, the strings in these four statements are all different, since
    the extra whitespace is *inside* the quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Whitespace doesn’t come just from the code you write. It can also be introduced
    when you take a string as input from a user or an external software system such
    as an application programming interface (API). In this case, you often need to
    validate that input and trim any unwanted whitespace at its beginning and end.
    Likewise, you may want to replace any tabs or newline characters inside a string
    with single spaces (sometimes users press function keys by accident while typing,
    adding unintended, invisible whitespace characters to their input). You’ll learn
    to do all these things in this chapter (for example, see “Removing All Unnecessary
    Whitespace” on [page 60](#pg_60)).  ### Single-Quoted Strings'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest type of string in PHP is enclosed in single quotation marks, such
    as 'matt smith'. Almost everything that appears inside the single quotes is treated
    literally, meaning it will be reproduced exactly as written, character for character,
    if the string is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP has just two special cases for single-quoted strings. First, since single
    quotes serve to delimit the string, there must be a mechanism for including a
    single quotation mark inside the string itself. Otherwise, the single quote will
    be interpreted as the end of the string. The solution is to put a backslash in
    front of the single quote (\''), as in ''matt smith\''s string''. When this string
    prints, the single quote will show up, but not the backslash, as you can see here
    in PHP’s interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique of having a special sequence of characters in a string that
    PHP will interpret as a certain character is known as *escaping*. Since the backslash
    is needed to escape single quotation marks, there must also be a way to specify
    a backslash character in a single-quoted string. For that, write two backslashes:
    \\.'
  prefs: []
  type: TYPE_NORMAL
- en: The \' and \\ escape sequences are the only characters that the PHP engine will
    interpret to mean something else in a single-quoted string. Other escape sequences
    you might know from other programming languages, such as \n for newline, aren’t
    recognized in single-quoted strings.
  prefs: []
  type: TYPE_NORMAL
- en: That doesn’t mean you can’t include newlines in single-quoted strings, however.
    For that, simply add line breaks wherever you want them in the string, and PHP
    will reproduce the line breaks exactly as you’ve written them. In fact, one reason
    PHP requires a semicolon to declare the end of a statement is to allow a single
    statement to be written over several lines. [Listing 3-1](#lis3-1) illustrates
    a string broken across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: A script with a string containing line breaks'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script includes a single print statement for a string that contains several
    line breaks. Here’s the output of running this script at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output includes all the newlines that were written into the string.  ###
    Joining Strings: Concatenation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you’ll need to combine several strings, variables, or constants to form
    a single string expression. You can do this with PHP’s string concatenation operator,
    represented by a period (.). Consider this example using PHP’s interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We declare the $name variable whose value is the string 'Matt Smith'. Then we
    use the string concatenation operator to combine the value of this variable with
    another string, and we print the resulting longer string. Note the extra space
    in the string 'my name is ' before the closing single quote. The concatenation
    operator doesn’t add any spaces between the strings it’s joining, so this extra
    space is to prevent something like isMatt from being printed.
  prefs: []
  type: TYPE_NORMAL
- en: When concatenating strings on a single line, it’s good programming practice
    to make the statement more readable by adding a space on each side of the period,
    as in the preceding example. You can also spread such statements over several
    lines, which can help make long string expressions more readable, as shown in
    the script in [Listing 3-2](#lis3-2). This shows my personal preference of indenting
    each subsequent line of the statement and beginning each line with the concatenation
    operator, so it’s clear that each line is appending more to the string expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: A script to concatenate and print out several strings'
  prefs: []
  type: TYPE_NORMAL
- en: This script prints out a string formed by concatenating four shorter strings
    together, including the two from the previous example. Notice that we’ve escaped
    a single quote to create the apostrophe in the word I'm in the third string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth string at the end of the expression is the special string constant
    PHP_EOL, short for *end of line*. This is a string containing the system-appropriate
    character (or characters) to move the cursor to the beginning of the next line
    in a command line terminal (the same as hitting ENTER). Such a special constant
    used to be needed since different operating systems used slightly different ways
    to specify the end of a line. It’s not such an issue now since applications for
    most operating systems generally know how to work with each other’s files these
    days, but the constant is still handy for ensuring that the next terminal prompt
    after a single-quoted string starts on a new line. Here’s the output when this
    script is run at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I saved the script from [Listing 3-2](#lis3-2) in a file named *multi_line.php*.
    Running the script concatenates the strings and prints the result on a single
    line. Notice that the next terminal prompt (in this case, the percent character,
    %) appears on the next line, thanks to the PHP_EOL constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a variable already contains a string, we can use the concatenating assignment
    operator (.=) to append another string expression to the end of that variable.
    Here’s an example using PHP’s interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we initialize the $name variable to the string ''Matt''. Then we use
    the concatenating assignment operator to append '' Smith'' to the end of the contents
    of $name. When we print out the variable, we can see that it now contains Matt
    Smith.  ### Double-Quoted Strings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second type of PHP string is enclosed in double quotes, as in "Matt Smith".
    Double-quoted strings differ from their single-quoted counterparts in that they
    are *parsed*, or processed, by the PHP engine, which means they can include PHP
    variables. When you write a variable (beginning with a dollar sign) in a double-quoted
    string, the PHP engine will look up the value of the variable and insert it into
    the string before printing. This is often more convenient than using a period
    to concatenate single-quoted strings with the contents of variables, as we did
    in the previous section. Here’s an example using PHP’s interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we assign the string 'Matt Smith' to the $name variable, as before. Note
    that we could have used double quotes for this string, but most PHP programmers
    use them only for strings that will need parsing. Next, we print a double-quoted
    string that includes the $name variable. The output shows that PHP has successfully
    parsed this string by inserting Matt Smith in place of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the double-quoted string includes a single-quote character in the
    contraction I'm. This is perfectly valid in a double-quoted string and doesn’t
    require escaping. Our double-quoted string also includes the escape sequence \n
    to create a newline in the middle of the output. This is one of several escape
    sequences available for use in double-quoted strings. [Table 3-1](#tab3-1) lists
    some of the most common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Common Escape Sequences in Double-Quoted Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| Escape sequence | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| \\ | Backslash |'
  prefs: []
  type: TYPE_TB
- en: '| \" | Double-quote |'
  prefs: []
  type: TYPE_TB
- en: '| \$ | Dollar sign |'
  prefs: []
  type: TYPE_TB
- en: '| \n | Newline |'
  prefs: []
  type: TYPE_TB
- en: '| \t | Tab |'
  prefs: []
  type: TYPE_TB
- en: Notice in particular that since a dollar sign will make the PHP engine parse
    for a variable, you must use \$ to include an actual dollar sign in a double-quoted
    string. You also need to use \" to include a double quotation mark.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t include constants in double-quoted strings, since the PHP engine can’t
    tell the difference between characters that are part of the string and the name
    of the constant. (Recall from [Chapter 1](chapter1.xhtml) that constants don’t
    start with a dollar sign.) One side effect is that you can’t include the PHP_EOL
    constant in a double-quoted string to create a newline at the end of the string.
    Instead, use the \n newline escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*On the rare occasions when you need the operating system–independent* PHP_EOL
    *constant with a double-quoted string, you can use the string concatenation operator
    to add the constant to the string, much as you saw in [Listing 3-2](#lis3-2).
    This situation might arise when a script needs to precisely output the appropriate
    newline and cursor-to-beginning-of-line character sequence for the system the
    PHP engine is running on (for example, to ensure that a system file has the correct
    line endings).*'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Character After a Variable Name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you have a variable name followed by a space in a double-quoted string,
    such as "my name is $name \nI''m pleased to meet you", the PHP engine can easily
    identify the variable ($name) and recognize that a space should be present after
    its value. Even punctuation marks such as periods, commas, and colons are fine
    when they immediately follow a variable, and so are escape sequences, since these
    aren’t valid characters to have in variable names. Here, for example, using a
    comma immediately after the $name variable is perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want other characters to be part of the string immediately after a variable,
    however, the situation becomes a little more difficult. After its first letter
    (or underscore character), the characters of a variable name can be letters, numbers
    and underscores, so if any of these are written immediately after a variable name
    in a double-quoted string, the PHP engine treats them as part of the variable
    name. For example, if we have a $weight variable and we want its value to be followed
    immediately by kg, as in 80kg, we can’t write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP engine would complain, saying there’s no variable named $weightkg.
    The solution for these more complex double-quoted-string parsing tasks is to enclose
    the variable name in curly brackets (braces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the curly brackets, PHP has no problem printing the characters kg
    immediately after the value of $weight. Note that this is an example of the string
    context of *type juggling*, as introduced in [Chapter 2](chapter2.xhtml). When
    the string "my weight is {$weight}kg" is parsed, the value of $weight will be
    juggled from the integer 80 into the string '80' for insertion into the final
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating Unicode Characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Not all characters are available to type directly from your keyboard or are
    part of the current language settings of your computer system, but that doesn’t
    mean you can’t include them in double-quoted strings. *Unicode* is an international
    standard for declaring and working with a wide range of characters and symbols,
    including ordinary English letters, emojis, letters from other alphabets, and
    more. Each Unicode character is defined by a unique hexadecimal code. For example,
    the code 1F60A corresponds to one of several smiling emojis.
  prefs: []
  type: TYPE_NORMAL
- en: To use a Unicode character in a double-quoted string, start with the escape
    sequence \u, then provide the character’s hexadecimal code in curly brackets.
    [Listing 3-3](#lis3-3) shows code to declare and print several Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: A script to display various Unicode characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare the variables $smiley, $elephant, and $cherokeeTSV to contain
    double-quoted strings with the Unicode characters for their respective smiley
    face and elephant emojis, and the Cherokee TSV symbol. Then we print some double-quoted
    strings that include those variables. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we could have included the Unicode character escape sequences directly
    in the double-quoted strings being printed rather than assigning them to variables
    first. Having them in variables makes it easier to reuse them throughout the script—for
    example, to print three elephants instead of just one. (The PHP community has
    a thing for elephants.) For a complete list of Unicode characters and their corresponding
    hexadecimal codes, visit *[https://home.unicode.org](https://home.unicode.org)*.  ###
    Heredocs'
  prefs: []
  type: TYPE_NORMAL
- en: '*Heredocs* are an alternative to double-quoted strings. They’re just like double-quoted
    strings in that they’re parsed and so can contain variables, but they differ in
    that heredocs typically span multiple lines. Although double-quoted strings can
    span multiple lines too, many programmers prefer heredocs for multiline strings
    since their syntax makes them stand out more obviously from the surrounding code.'
  prefs: []
  type: TYPE_NORMAL
- en: To declare a heredoc, start with the heredoc operator (<<<), followed by a sequence
    of characters of your choice that will serve as a delimiter. Then, on a new line,
    start typing your string. When you get to the end of the string, repeat your chosen
    delimiter on its own line, followed by a semicolon to end the statement.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used delimiter for heredocs is EOT (short for *end of text*),
    but which delimiter you choose doesn’t really matter, as long as that character
    sequence doesn’t appear in the string being declared and as long as the delimiters
    at the beginning and end of the heredoc match. It makes code more readable to
    either always use EOT or choose something meaningful to the heredoc’s contents,
    such as SQL if it contains a SQL statement or HTML if it contains HTML. [Listing
    3-4](#lis3-4) shows a script with an example heredoc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: A heredoc string declared and printed with the EOT delimiter'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates the variables $age and $weight containing 22 and 80, respectively.
    Then we assign a heredoc expression into the $message variable ❶. The heredoc
    starts with <<<EOT, and its content is everything from the next line until a newline
    character and the EOT; at the end ❷. Finally, we print the contents of $message.
    Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I saved the script as *heredoc.php* and ran it at the command line. Notice that
    the variables $age and $weight were successfully parsed within the heredoc, including
    when we used curly brackets to allow characters to be output immediately following
    a variable. Notice also that the next command line prompt starts on its own line.
    This is because of the blank line in the heredoc before the closing delimiter;
    heredocs can contain newlines.
  prefs: []
  type: TYPE_NORMAL
- en: Escape Sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can’t use the \" escape sequence to write a double quotation mark in a
    heredoc. If you write \" inside a heredoc, the backslash will become an ordinary
    character in the string, just like the double quote. You won’t need this escape
    sequence in heredocs anyway: since you’re no longer using double quotes to delimit
    the string, using them within the string won’t cause confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: You *can* include other escape sequences in heredocs, such as \t for tabs and
    \n for newlines. These, too, aren’t strictly necessary, however, since you can
    just use the TAB and ENTER keys when writing the heredoc’s contents. You can also
    type Unicode characters directly into a heredoc (assuming your editor supports
    Unicode, that is). [Listing 3-5](#lis3-5) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Listing 3-5: A script with Unicode characters declared in a heredoc string'
  prefs: []
  type: TYPE_NORMAL
- en: We declare this heredoc by using UNICODE as the delimiter. The code features
    Unicode characters typed directly into the string, rather than created via escape
    sequences. The output of running this script is identical to the output from [Listing
    3-3](#lis3-3).
  prefs: []
  type: TYPE_NORMAL
- en: Indention
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An occasionally useful feature of heredocs is that if indention (spaces or tabs)
    appears before the closing delimiter, the PHP engine will attempt to remove that
    same amount of indention from all lines of the heredoc. In [Listing 3-6](#lis3-6),
    for example, we declare and print a heredoc string that has each of its lines,
    including the line with the ending TEXT delimiter, indented four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: A script with an indented heredoc'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since every line of this heredoc has the same indention as the closing delimiter
    line, all indention will be removed from all lines when the string is printed.
    Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If any lines in a heredoc have more indention than the line with the closing
    delimiter, that extra bit of indention will remain in the output. [Listing 3-7](#lis3-7)
    shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: A script that retains extra indention in a heredoc'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and last lines of the heredoc are indented four spaces, as is the
    closing delimiter. The middle two lines of the heredoc have two extra spaces of
    indention. In the output, four spaces will be stripped away from the start of
    each line, leaving two spaces of indention for the middle two lines, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This feature of removing indentation from a heredoc is primarily useful when
    the heredoc is declared as part of a function’s body, where it’s customary for
    all code to have some level of indention. This way, you can write cleaner-looking
    heredocs that adhere to the indention conventions of the code around them. We’ll
    meet functions in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If any lines in a heredoc have less indention than the closing delimiter,
    or if they have a different kind of indention (such as a tab character instead
    of spaces), an error will occur at runtime.*'
  prefs: []
  type: TYPE_NORMAL
- en: Nowdocs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last style of PHP string is the *nowdoc*, an unparsed string written with
    the <<< operator and delimiters. Essentially, the nowdoc is to unparsed single-quoted
    strings what the heredoc is to parsed double-quoted strings. The only difference
    between declaring a nowdoc and a heredoc is that the opening delimiter for the
    nowdoc must be enclosed in single quotes, as in <<<'EOL'. The closing delimiter
    isn’t written with single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: One use of nowdocs is for printing out PHP code. Since nowdocs are unparsed,
    any code, including variable names, will be reproduced literally in the string
    expression. [Listing 3-8](#lis3-8) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-8: A script declaring a nowdoc that contains unparsed PHP code'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare a $name variable ❶. Then we declare a nowdoc by using the
    delimiter PHP and assign it to the $codeSample variable ❷. (Notice that the starting
    delimiter is enclosed in single quotes, but the ending delimiter isn’t.) The nowdoc
    contains statements such as a variable declaration ($age), strings with escaped
    characters, and a reference to our $name variable ❸. All of this goes unparsed
    when we print the nowdoc, as you can see in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The entire nowdoc has been printed verbatim, including the escape sequences
    and the characters $name. No program statements within the nowdoc were executed;
    they just became part of the declared nowdoc string. Notice, however, that the
    indention in the nowdoc has been stripped away, since it matches the indention
    of the closing delimiter. This works just as with heredocs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve finished our overview of the four styles of strings. Deciding which to
    use is often a matter of personal preference. In general, single quotes are best
    for short strings that don’t include variables that require parsing. For longer,
    multiline strings with no parsing, consider using nowdocs. If you need to incorporate
    parsed variables, use double quotes for shorter strings or heredocs for longer,
    multiline strings.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in String Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP has more than 100 built-in functions for manipulating and analyzing strings,
    ranging from standard tasks like toggling between uppercase and lowercase letters
    to more specialized tasks such as implementing hash algorithms. We’ll look at
    a few of the most commonly used string functions in this section.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming to PHP from another language, you may be used to seeing these
    kinds of operations as methods that are called directly on the strings themselves.
    Since PHP wasn’t originally object-oriented, however, the operations instead exist
    as stand-alone functions.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For a complete list of PHP’s string functions, see* [https://www.php.net/manual/ref.strings.php](https://www.php.net/manual/ref.strings.php)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Upper- and Lowercase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When working with user input, you’ll often need to standardize strings by ensuring
    that they all follow the same capitalization rules. This makes it easier to compare
    strings, or to store text in a database or send it to an API using a consistent
    format. To that end, PHP has functions for adjusting the capitalization of a string.
    The strtolower() and strtoupper() functions convert all the letters to lowercase
    or uppercase, respectively. Here are some examples illustrated using PHP’s interactive
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We declare a string with a mix of uppercase and lowercase letters. Passing the
    string to the strtolower() function converts everything to lowercase, while passing
    it to strtoupper() converts everything to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP’s ucfirst() function capitalizes just the first letter of a string, if
    it isn’t capitalized already. This is useful when creating messages to be output
    to the user; capitalizing the first letter helps make the messages look like grammatically
    correct sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The related function lcfirst() lowercases just the first letter of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Often this isn’t much of a grammatical improvement, but it can be useful, for
    example, if you’re writing a script to output code. In this case, to follow the
    naming conventions of the programming language (such as for variables), it can
    be important to ensure that the first character of a string is lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ucwords() function capitalizes the first letter of every word in a string.
    PHP can distinguish between the different words if they’re separated by whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if any subsequent letters in a word are capitalized, they remain
    so. Only the first letter of each word is affected. PHP doesn’t have an equivalent
    function for lowercasing the first letter of each word.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and Counting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several of PHP’s built-in string functions serve analytical purposes, such as
    reporting the length of a string, searching for a character or substring within
    a string, or counting the number of occurrences of a character or substring within
    a string. (A *substring* is a portion of a larger string.) Before we examine these
    functions, though, it’s important to distinguish between the *number* of characters
    in a string and the *position* of each character within that string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the string ''cat scat'' as an example. It consists of eight characters
    (the space in the middle counts), but character positions in PHP are numbered
    starting from zero. Thus, the character at position 0 is c, at position 1 is a,
    and so on up to the final t at position 7. This counting from zero is called *zero-based
    indexing* and is common in computer programming. Using this system, we can say
    that the substring ''cat'' occurs twice in the string, starting at position 0
    for the first occurrence and at position 5 for the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in mind, let’s try out some analytical string functions on the string
    ''cat scat''. First, the strlen() function reports the length of a string, as
    shown here in PHP’s interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, this tells us that 'cat scat' is eight characters long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The substr_count() function counts the number of times a substring appears
    within a string. Here, for example, we count the instances of the substring ''cat'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass two strings to the substr_count() function. The first is the string
    we want to search *in*, which here we’re providing as the $myString variable.
    The second is the string we want to search *for*: in this case, ''cat''. In computer
    search terminology, these two strings are often referred to as the *haystack*
    and the *needle*, respectively, after the expression “looking for a needle in
    a haystack.”'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The items entered within the parentheses of a function, such as* $myString
    *and* ''cat'' *in the preceding example, are called* arguments*. They’re pieces
    of data that the function needs to do its job. We’ll discuss functions in detail
    in [Chapter 5](chapter5.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most PHP functions that involve searching within a string, including substr_count(),
    are case sensitive, so it’s important to be careful about capitalization. If we
    try searching ''cat scat'' for the substring ''Cat'' instead of ''cat'', for example,
    we’ll end up with a count of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The strpos() function reports the starting position (counting from zero) of
    a substring within a string. If the substring occurs multiple times, only the
    position of the first occurrence is given. Here we search for the first occurrence
    of the substring ''cat'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As with substr_count(), we provide two strings to the strpos() function as arguments,
    first the haystack and then the needle. The function reports the first occurrence
    of 'cat' at position 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can provide an *offset* to the strpos() function as an additional
    argument, a number that tells it to start searching for the substring from a different
    position, rather than from the beginning of the string. Here we tell the function
    to start searching from position 2 onward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This time, since the function isn’t searching from the beginning of the string,
    it identifies the second occurrence of 'cat' at position 5. If the function can’t
    find any occurrences of the needle within the haystack, it reports false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The count_chars() function analyzes which characters are, and are not, included
    in a string. It’s a powerful string analysis function that you might use when
    evaluating the complexity of a password or perhaps for data encryption and decryption
    tasks. It has a few modes, which you specify as a number when the function is
    called. In the following example, we use mode 3, which generates a new string
    consisting of all the unique characters used in the string being analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We call the count_chars() function on $myString, specifying mode 3\. The resulting
    string features one instance of each character from 'cat scat', arranged in alphabetical
    order. It shows us that 'cat scat' includes only the letters *a*, *c*, *s*, and
    *t*.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* count_chars() *function has other modes that count the number of occurrences
    of each character, but the result is reported as an array, so we won’t consider
    those modes here. We’ll discuss arrays in [Chapters 7](chapter7.xhtml) and [8](chapter8.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting and Replacing Substrings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Other PHP functions manipulate strings by extracting a portion of the string
    or replacing a portion with something else. For example, the substr() function
    extracts part of a string, starting from a given position. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We declare a variable with the string 'do not enter', then pass it to the substr()
    function. The number 7 tells the function to extract all the characters from position
    7 to the end, giving us enter as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a negative number instead, the function makes the extraction counting
    from the end of the string. For example, here we use -2 to get just the last two
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can optionally include a second number in the function call to specify
    a length for the extraction. Here, for example, we extract just three characters
    from the string, starting from position 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The strstr() function provides another technique for extracting part of a string.
    By default, it searches for the first occurrence of a substring within a string
    and extracts the contents of the string from that substring on. Here, for example,
    we search for the substring ''@'' to extract just the domain name and extension
    from an email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The function searches for the first occurrence of an @ sign and reports everything
    in the string from that point on, including the @ sign itself. We can also use
    strstr() to extract everything in the string *before* the first occurrence of
    the substring. For that, add true to the end of the function call, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, we search the string for the first occurrence of an @ sign, but this
    time, thanks to the added true, the function reports the contents of the string
    up to but not including the @ sign. This gives us just the username from the email
    address.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* strstr() *function is case sensitive, but PHP provides a case-insensitive
    version called* stristr()*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The str_replace() function finds all occurrences of a substring within a string
    and replaces them with a different substring. The result of the replacement is
    reported as a new string, meaning the original string itself isn’t modified. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we call str_replace(), we need to provide three strings. The first is the
    substring to search for (in this case, 'eat'). The second is the substring to
    replace it with (in this case, 'help'). The third is the string to search in,
    which we’ve assigned to the $foodchain variable. The function generates a new
    string by replacing all instances of 'eat' with 'help'. Then we print the value
    of $foodchain to confirm that it wasn’t affected by the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the replacement somewhat permanent, store the result of calling str_replace()
    in a new variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time when we call str_replace(), we assign the result to $friendchain ❶.
    The original $foodchain variable is still unaffected by the replacement operation
    ❷, but at least now we have the modified string available in a variable for later
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another replacement function is substr_replace(). Rather than specifying a
    substring that should be replaced, this function lets you specify the position
    in the string at which the replacement should occur. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we call the substr_replace() function, we first provide the original string
    (in $foodchain) and the replacement string ('help'). Then we provide two numbers
    as additional arguments. The first, 5, is the position in the original string
    where the replacement should begin. The second, 3, is the number of characters
    in the original string that should be replaced, starting from the specified position.
    This has the effect of replacing the first instance of the word *eat* (which is
    three characters long and starts at position 5) with the word *help*, while leaving
    the rest of the string as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the replacement length to 0, we can use substr_replace() to insert
    a substring into a string without otherwise altering it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This inserts the word *don’t* into the $foodchain string starting at position
    5, without replacing any characters.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming Whitespace
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Often it’s necessary to remove whitespace from the beginning or end of a string,
    a task known as *trimming*. PHP provides three trimming functions:'
  prefs: []
  type: TYPE_NORMAL
- en: trim()   Removes whitespace from the beginning *and* end of a string
  prefs: []
  type: TYPE_NORMAL
- en: ltrim()   Removes whitespace from the beginning of a string (*l* is for *left*)
  prefs: []
  type: TYPE_NORMAL
- en: rtrim()   Removes whitespace the from end of a string (*r* is for *right*)
  prefs: []
  type: TYPE_NORMAL
- en: 'All three functions work in the same way: given a string, they remove any space,
    tab, vertical tab, newline, carriage return, or American Standard Code for Information
    Interchange (ASCII) null-byte characters, up to the first non-whitespace character
    and/or after the last non-whitespace character in the string. Here, for example,
    we use trim() to remove the spaces and newline characters at the start and end
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the newlines and the beginning and end of the string have
    been trimmed, but notice that a newline still remains between the words *CAT*
    and *DOG*. The trim functions have no effect on any whitespace in the middle of
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can optionally control which whitespace characters are trimmed by specifying
    them in a separate double-quoted string when calling the function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This time we use the string "\n" ❶ to specify that only newline characters should
    be trimmed. In the output, notice that the spaces before the word CAT have been
    preserved, since the function ignored all but newline characters. The blank line
    ❷ before the next prompt also indicates that the newlines at the end of the string
    were left in place, since the ltrim() function affects only the start of the string.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Removing All Unnecessary Whitespace'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove whitespace from throughout a string, not just the edges, use str_replace()
    to find all instances of a particular whitespace character and replace them with
    empty strings. For example, here we use this technique to get rid of all the tab
    characters in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The string assigned to $tooTabby contains several tab characters. Replacing
    each instance of "\t" with '' (an empty string) gets rid of the tabs while preserving
    the regular spaces between each word.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](#lis3-9) pushes this technique even further, repeatedly using
    str_replace() to remove any whitespace from a string except for a single space
    character between words. This includes getting rid of tabs, newlines, and multiple
    space characters in a row.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-9: Replacing all whitespace (except single space characters) in a
    string'
  prefs: []
  type: TYPE_NORMAL
- en: We use a heredoc to declare the $string1 variable, which contains tabs, newline
    characters, and multiple spaces in a row between words ❶. Then we use the str_replace()
    function twice, first to replace all tabs with a single space, and a second time
    to replace all newline characters with a single space ❷. (We don’t replace them
    with empty strings in case a tab or newline is the only character between two
    words.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we repeatedly use str_replace() to replace any instances of two space
    characters with a single space ❸. It takes three function calls before only single
    spaces are left. (In [Chapter 6](chapter6.xhtml), we’ll delve into loops, which
    provide a more efficient way to repeat the same code several times, or until a
    particular condition is satisfied.) For good measure, we use trim() to remove
    any lingering whitespace at the start or end of the string before printing out
    the resulting string, enclosed in square brackets so it’s easier to see where
    it starts and ends. Here’s the output of running this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The final string has no whitespace before or after it and only single spaces
    between each word. All the extra whitespace has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating and Padding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some PHP string functions work by repeating a character or substring to generate
    a longer string. For example, to create a new string by repeating a string a given
    number of times, use str_repeat(), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This gives our lonely string some company by repeating 'Cat' five times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closely related to repeating is *padding*: a character or substring is repeatedly
    added to the beginning or end of a string until the string reaches a desired length.
    Padding is useful, for example, if you’re displaying multiple numbers of different
    lengths and you want their digits to line up nicely. In that case, you might add
    spaces or zeros as padding in front of the numbers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP has a str_pad() function for such padding tasks. Here, for example, we
    pad the string ''Cat'' with hyphens (-) until it’s 20 characters long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We call str_pad(), providing the original string ($tooShort), the desired length
    (20), and the string to use as padding (''-''). By default, PHP adds the padding
    to the right of the original string, but you can add the constants STR_PAD_LEFT
    or STR_PAD_BOTH to the function call to place the padding on the left or to pad
    both sides equally instead. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the function adds hyphens until the resulting string is 20 characters
    long.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings are a core data type that you’ll probably use in every web application
    you create. In this chapter, you learned about the four ways to declare strings:
    single-quoted strings, double-quoted strings, heredocs, and nowdocs. You saw how
    double-quoted strings and heredocs are parsed and so can incorporate variables,
    while single-quoted strings and nowdocs are not. You also tried out PHP’s built-in
    functions for working with strings, and you learned how to combine strings by
    using the . and .= operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a script that declares a $name variable containing your name as
    a single-quoted string. Then include a print statement that uses the string concatenation
    operator (.) to combine the contents of $name with the string '' is learning PHP''.
    When you run your script, the output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '2.   In a script, create a $fruit variable containing the string ''apple''.
    Then use a double-quoted string and a print statement to output the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your script so that $fruit contains orange, leading to the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: You’ll need to use curly brackets to create the plural fruit names from
    the $fruit variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Write a script that declares a heredoc string variable $happyMessage containing
    the following (including the newlines):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg63.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Print out the contents of the $happyMessage variable.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   In a script, create an $appleJuice variable containing the string 'apple
    juice is made from apples.' Then use the str_replace() function to create a new
    string variable, $grapefruitJuice, containing the string 'grapefruit juice is
    made from grapefruits.' Try using other PHP functions to further transform the
    string. For example, capitalize the first letter of the string so it looks like
    a grammatically correct sentence.
  prefs: []
  type: TYPE_NORMAL
