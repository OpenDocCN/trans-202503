- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MEMOIZATION AND DYNAMIC PROGRAMMING**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we’ll study three problems that appear to be solvable using
    recursion. As you’ll see, while in theory we can use recursion, in practice it
    leads to an explosion of work that renders the problems unsolvable. Not to worry:
    you’ll learn two powerful, related techniques, called memoization and dynamic
    programming, that will lead to shocking performance increases, morphing runtimes
    from hours or days to seconds. In the next chapter, we’ll level up and solve two
    even more challenging problems using these techniques. Once you get the hang of
    this stuff, you’ll be able to solve hundreds of other programming problems as
    well. If you’re going to read one chapter in this book, read this one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Burger Fervor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is UVa problem `10465`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A man named Homer Simpson likes to eat and drink. He has *t* minutes that he’ll
    spend eating burgers and drinking beer. There are two kinds of burgers. One of
    them takes *m* minutes to eat, and the other takes *n* minutes to eat.
  prefs: []
  type: TYPE_NORMAL
- en: Homer likes burgers more than beer, so he’d like to spend the entire *t* minutes
    eating burgers. However, doing so isn’t always possible. For example, if *m* =
    4, *n* = 9, and *t* = 15, then no combination of the 4-minute and 9-minute burgers
    can take him exactly 15 minutes to eat. In such a case, he’ll spend as much time
    as possible eating burgers and then fill the rest of the time drinking beer. Our
    task is to determine the number of burgers that Homer can eat.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We read test cases until there is no more input. Each test case is represented
    by a line of three integers: *m*, the number of minutes it takes to eat the first
    kind of burger; *n*, the number of minutes it takes to eat the second kind of
    burger; and *t*, the number of minutes that Homer will spend eating burgers and
    drinking beer. Each *m*, *n*, and *t* value is less than 10,000.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case:'
  prefs: []
  type: TYPE_NORMAL
- en: If Homer can spend exactly *t* minutes eating burgers, then output the maximum
    number of burgers that he can eat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, output the maximum number of burgers that Homer can eat when maximizing
    his time eating burgers, a space, and the number of remaining minutes (during
    which he’ll drink beer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time limit for solving the test cases is three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Forming a Plan*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start by thinking about a few different test cases. Here’s the first
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first kind of burger takes 4 minutes to eat (*m* = 4), the second
    kind of burger takes 9 minutes to eat (*n* = 9), and Homer has 22 minutes to spend
    (*t* = 22). This is an example in which Homer can fill the entire time by eating
    burgers. The maximum number of burgers that Homer can eat here is three, so `3`
    is the correct output for this test case.
  prefs: []
  type: TYPE_NORMAL
- en: The three burgers that Homer should eat are one 4-minute burger and two 9-minute
    burgers. This takes him 1 × 4 + 2 × 9 = 22 minutes, as required. Notice, though,
    that we are *not* being asked to indicate the number of each kind of burger he
    should eat. All we’re asked to do is output the total number of burgers. When
    I provide the number of each kind of burger below, I do so only to offer evidence
    that the proposed output makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Again, Homer can fill the entire time with burgers. The correct output here
    is `11`, obtained by eating nine 4-minute burgers and two 9-minute burgers. Unlike
    the `4 9 22` test case, here Homer has multiple ways to spend exactly 54 minutes
    eating burgers. For example, he could eat six 9-minute burgers—that fills up the
    54 minutes, too—but, remember, if we can fill the entire `t` minutes, then we
    want to output the *maximum* number of burgers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in the problem description, it’s not always possible for Homer to
    completely fill the *t* minutes by eating burgers. Let’s study the example that
    I gave there as our next test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How many burgers should Homer eat here? He can eat a maximum of three burgers
    by eating three 4-minute burgers. By doing so, Homer would spend 12 minutes eating
    burgers, and he would have to spend the remaining 15 – 12 = 3 minutes drinking
    beer. So, he eats three burgers and has three minutes’ beer-drinking time, making
    the output `3 3`. Have we solved this test case?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have not! Carefully reread the problem description and zone in on this:
    “output the maximum number of burgers that Homer can eat when maximizing his time
    eating burgers.” That is, when Homer cannot fill the entire time by eating burgers,
    we want to maximize the *time* that he spends eating burgers and then the maximum
    number of burgers he can eat in that time. The correct output for `4 9 15` is
    in fact `2 2`: the first `2` means that he eats two burgers (one 4-minute burger
    and one 9-minute burger, for a total of 13 minutes) and the second `2` means that
    he has to spend 2 minutes (15 – 13) drinking beer.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `4 9 22` and `4 9 54` test cases, we’re asked to solve the problem for
    22 and 54 minutes, respectively. We found that there is indeed a way to spend
    the entire time eating burgers, so we can report the maximum number of burgers
    as our solution. However, in the `4 9 15` case, we found that there is no way
    to completely fill the 15 minutes by eating burgers. Thinking ahead to our code,
    how are we going to handle this? How will we be able to conclude that the answer
    is `2 2`?
  prefs: []
  type: TYPE_NORMAL
- en: 'One idea is that we can next try to fill exactly 14 minutes with the 4-minute
    and 9-minute burgers. If we succeed, then we have our answer: we report the maximum
    number of burgers that Homer can eat in exactly 14 minutes, followed by 1, the
    number of minutes Homer spends drinking beer. This would maximize the amount of
    time that Homer can spend eating burgers. We already know that eating burgers
    for exactly 15 minutes is impossible, so 14 minutes is the next best option.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see if 14 minutes works. Can we fill exactly 14 minutes with the 4-minute
    and 9-minute burgers? No! Like the 15-minute case, this will be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, though, fill exactly 13 minutes by eating two burgers: one 4-minute
    burger and one 9-minute burger. That leaves Homer two minutes for drinking beer.
    This justifies `2 2` as the correct output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, our plan is to determine whether Homer can eat burgers for exactly
    *t* minutes. If he can, then we’re done: we report the maximum number of burgers
    he can eat. If he can’t, then we next determine whether Homer can eat burgers
    for exactly *t* – 1 minutes. If he can, then we’re done, and we report the maximum
    number of burgers he can eat and the number of minutes spent drinking beer. If
    he can’t, then we will move on to trying *t* – 2 minutes, then *t* – 3 minutes,
    and so on, stopping when the time can be completely filled by eating burgers.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Characterizing Optimal Solutions*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the `4 9 22` test case. Whatever combination of burgers and beer we
    propose as the solution better take exactly 22 minutes, and it better actually
    be doable using the 4-minute and 9-minute burgers. Such a solution, which adheres
    to the rules of a problem, is called a *feasible* solution. A solution attempt
    that does not follow the rules is called an *infeasible* solution. For example,
    having Homer spend 4 minutes eating burgers and 18 minutes drinking beer is feasible.
    Having Homer spend 8 minutes eating burgers and 18 minutes drinking beer is infeasible,
    because 8 + 18 is not 22\. Having Homer spend 5 minutes eating burgers and 17
    minutes drinking beer is also infeasible, because there’s no way we can use the
    4-minute and 9-minute burgers to get a total of 5 minutes of burger time.
  prefs: []
  type: TYPE_NORMAL
- en: Burger Fervor is an *optimization problem*. An optimization problem involves
    choosing the best—that is, *optimal*—solution out of all feasible solutions. There
    may be many feasible solutions of varying quality. Some will be really poor, such
    as drinking beer for 22 minutes. Others will be close to but not quite optimal—maybe
    they’re off by one or two. And, of course, some of them will be optimal. Our goal
    is to identify an optimal solution among all possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’re solving a case where the first kind of burger takes *m* minutes
    to eat, the second kind of burger takes *n* minutes to eat, and we want to try
    to spend *exactly t* minutes eating burgers.
  prefs: []
  type: TYPE_NORMAL
- en: If *t* = 0, then the correct output is `0`, because we can fill the entire 0
    minutes by eating zero burgers. As we continue, we’ll therefore focus on what
    to do when *t* is greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about what an optimal solution for *t* minutes must look like. Of
    course, we can’t possibly know anything specific, such as “Homer eats a 4-minute
    burger, then a 9-minute burger, then another 9-minute burger, then . . . ” We
    haven’t done anything yet to solve the problem, so obtaining this level of detail
    is wishful thinking.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, something we can say that’s not wishful thinking. It’s at
    once so inane that you’d be forgiven for wondering why I am stating it at all
    and so powerful that at its core lies a solution strategy for a bewildering number
    of optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is: Suppose that Homer can fill exactly *t* minutes by eating burgers.
    (If this supposition ends up being wrong, then we’ll try it again with *t* – 1
    minutes, then *t* – 2 minutes, and so on.) The final burger that he eats, the
    one that finishes off his *t* minutes, must be an *m*-minute burger or an *n*-minute
    burger.'
  prefs: []
  type: TYPE_NORMAL
- en: How could that final burger be anything else? Homer can only eat *m*-minute
    and *n*-minute burgers, so there are only two choices for the last burger that
    he eats and so two choices for what the end of the optimal solution must look
    like.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know that the final burger that Homer eats in an optimal solution is
    an *m*-minute burger, we know he has *t* – *m* minutes left to spend. There must
    be a way to fill those *t* – *m* minutes with burgers, without drinking any beer:
    remember that we are assuming that Homer can spend the entire *t* minutes by eating
    burgers. If we could spend those *t* – *m* minutes optimally, with Homer eating
    the maximum number of burgers, then we’d have an optimal solution to the original
    problem of *t* minutes. We’d take the number of burgers that he can eat in *t*
    – *m* minutes and add one *m*-minute burger to fill the remaining *m* minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if we knew that the final burger that Homer eats in an optimal solution
    is an *n*-minute burger? Then he has *t* – *n* minutes left to spend. Again, by
    virtue of the entire *t* minutes being spent eating burgers, we know that it must
    be possible for Homer to eat burgers for the first *t* – *n* of those minutes.
    If we could spend those *t* – *n* minutes optimally, then we’d have an optimal
    solution to the original problem of *t* minutes. We’d take the number of burgers
    that he can eat in *t* – *n* minutes and add one *n*-minute burger to fill the
    remaining *n* minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Now we seem to be squarely in farce territory. We just assumed that we knew
    what the final burger was! However, there’s no way we could know this. We do know
    that the final burger is an *m*-minute burger *or* an *n*-minute burger. We definitely
    don’t know which it is.
  prefs: []
  type: TYPE_NORMAL
- en: The wonderful truth is that we don’t need to know. We can assume the final burger
    is an *m*-minute burger and solve the problem optimally given that choice. We
    then make the other choice—assume that the final burger is an *n*-minute burger—and
    solve the problem optimally given that choice. In the first case, we have a subproblem
    of *t* – *m* minutes to solve optimally; in the second case, we have a subproblem
    of *t* – *n* minutes to solve optimally. Whenever we have characterized a solution
    to a problem in terms of solutions to subproblems, we would do well to try a recursive
    approach as we did in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s attempt a recursive solution. We’ll begin by writing a helper function
    to solve for exactly *t* minutes. Once we’re done, we’ll rely on it to write a
    function that solves for exactly *t* minutes, *t* – 1 minutes, *t* – 2 minutes,
    and so on, until we can completely fill some number of minutes with burgers.
  prefs: []
  type: TYPE_NORMAL
- en: '##### The Helper Function: Solving for the Number of Minutes'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve each problem and subproblem instance, we need three things: *m* and
    *n* from the test case and the *t* value for the current instance. We’ll therefore
    write the body of the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If Homer can spend exactly `t` minutes eating burgers, then we’ll return the
    maximum number of burgers he can eat. If he can’t spend exactly `t` minutes eating
    burgers—meaning he must spend at least one minute drinking beer—then we’ll return
    `-1`. A return value of `0` or more means that we’ve solved the problem using
    burgers alone; a return value of `-1` means that the problem cannot be solved
    using burgers alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `solve_t(4, 9, 22)`, we expect to get `3` as the return value: three
    is the maximum number of burgers that Homer can eat in exactly 22 minutes. If
    we call `solve_t(4, 9, 15)`, we expect to get `-1` as the return value: there’s
    no combination of 4-minute and 9-minute burgers that gives us exactly 15 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already settled on what to do when *t* = 0: in this case, we have 0 minutes
    to spend, and we do so by having Homer eat zero burgers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s the base case of our recursion. To implement the rest of this function,
    we need the analysis from the last section. Remember that, to solve the problem
    for exactly *t* minutes, we think about the final burger that Homer eats. Maybe
    it’s an *m*-minute burger. To check that possibility, we solve the subproblem
    for exactly *t* – *m* minutes. Of course, the final burger can only be an *m*-minute
    burger if we’ve got at least *m* minutes to spend. This logic can be coded as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `first` to store the optimal solution to the `t - m` subproblem, with
    `-1` indicating “no solution.” If `t >= m`, then there’s a chance that an *m*-minute
    burger is the final one, so we make a recursive call to compute the optimal number
    of burgers that Homer can eat in exactly `t - m` minutes. That recursive call
    will return a number greater than `-1` if it can be solved exactly or `-1` if
    it can’t. If `t < m`, then there’s no recursive call to make: we set `first =
    -1` to signify that an *m*-minute burger isn’t the final burger and that it can’t
    participate in an optimal solution for exactly `t` minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about when an *n*-minute burger is the final burger? The code for
    this case is analogous to the *m*-minute burger case, this time storing the result
    in the variable `second` instead of `first`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s summarize our current progress:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `first` is the solution to the `t - m` subproblem. If it’s `-1`,
    then we can’t completely fill `t - m` minutes with burgers. If it’s anything else,
    then it gives the optimal number of burgers that Homer can eat in exactly `t -
    m` minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable `second` is the solution to the `t - n` subproblem. If it’s `-1`,
    then we can’t completely fill `t - n` minutes with burgers. If it’s anything else,
    then it gives the optimal number of burgers that Homer can eat in exactly `t -
    n` minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s a chance that both `first` and `second` have values of `-1`. A value
    of `-1` for `first` means that an *m*-minute burger can’t be the final burger.
    A value of `-1` for `second` means that an *n*-minute burger can’t be the final
    burger. If the final burger can’t be an *m*-minute burger and can’t be an *n*-minute
    burger, then we’re out of options and have to conclude that there’s no way to
    solve the problem for exactly `t` minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if `first` or `second` or both are greater than `-1`, then we can
    build at least one solution for exactly `t` minutes. In this case, we start with
    the maximum of `first` and `second` to choose the better subproblem solution.
    If we add one to that maximum, thereby incorporating the final burger, then we
    obtain the maximum for the original problem of exactly `t` minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The full function is given in [Listing 3-1](ch03.xhtml#ch03ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Solving for exactly t minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth spending a few minutes getting a feel for what the function does—even
    if you’re already convinced of its correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with `solve_t(4, 9, 22)`. The recursive call for `first` ❶ solves
    the subproblem for 18 minutes (22 – 4). That recursive call returns `2`, because
    two is the maximum number of burgers that Homer can eat in exactly 18 minutes.
    The recursive call for `second` ➋ solves the subproblem for 13 minutes (22 – 9).
    That recursive call returns `2` as well, because two is the maximum number of
    burgers that Homer can eat in exactly 13 minutes. That is, both `first` and `second`
    are `2` in this case; tacking on the final four-minute or nine-minute burger gives
    a solution of `3` ➍ for the original problem of exactly 22 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now try `solve_t(4, 9, 20)`. The recursive call for `first` ❶ solves the
    subproblem for 16 minutes (20 – 4) and yields `4` as a result, but what about
    the recursive call for `second` ➋? Well, that one is asked to solve the subproblem
    for 11 minutes (20 – 9), but there is no way to spend exactly 11 minutes by eating
    4-minute and 9-minute burgers! Thus this second recursive call returns `-1`. The
    maximum of `first` and `second` is therefore `4` (the value of `first`), and so
    we return `5` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve seen an example where the two recursive calls both give subproblem
    solutions with the same number of burgers and an example where only one recursive
    call gives a subproblem solution. Now let’s look at a case where each recursive
    call returns a subproblem solution, but where one is better than the other! Consider
    `solve_t(4, 9, 36)`. The recursive call for `first` ❶ yields `8`, the maximum
    number of burgers that Homer can eat in exactly 32 minutes (36 – 4). The recursive
    call for `second` ➋ yields `3`, the maximum number of burgers that Homer can eat
    in exactly 27 minutes (36 – 9). The maximum of `8` and `3` is `8`, and so we return
    `9` as the overall solution ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, try `solve_t(4, 9, 15)`. The recursive call for `first` ❶ is asked
    to solve for exactly 11 minutes (15 – 4) and, since this is impossible with these
    kinds of burger, returns `-1`. The result for the `second` recursive call ➋ is
    similar: solving for exactly 6 minutes (15 – 9) is impossible, so it also returns
    `-1`. There is therefore no way to solve for exactly 15 minutes, so we return
    `-1` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '##### The solve and main Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from “Forming a Plan” on [page 78](#sec36) that if we can fill exactly
    *t* minutes by eating burgers, then we output the maximum number of burgers. Otherwise,
    Homer has to spend at least one minute drinking beer. To figure out the number
    of minutes that he must spend drinking beer, we try to solve for exactly *t* –
    1 minutes, *t* – 2 minutes, and so on, until we find a number of minutes that
    can be filled by eating burgers. Happily, with our `solve_t` function, we can
    set the `t` parameter to whatever we want. We can start at the given value of
    `t` and then, as needed, make calls on `t - 1`, `t - 2`, and so on. We effect
    this plan in [Listing 3-2](ch03.xhtml#ch03ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we solve the problem for exactly `t` minutes ❶. If our result is at least
    zero, then we output the maximum number of burgers ➋ and stop.
  prefs: []
  type: TYPE_NORMAL
- en: If it wasn’t possible for Homer to eat burgers for the entire `t` minutes, we
    set `i` to `t - 1`, since `t - 1` is the next-best number of minutes that we should
    try. We then solve the problem for this new value of `i` ➌. If we don’t get a
    value of `-1`, we’re successful and the `while` loop is skipped. If we’re not
    successful, the `while` loop executes until we successfully solve a subproblem.
    Inside the `while` loop, we decrement the value of `i` and solve that smaller
    subproblem ➍. The `while` loop will eventually terminate; for example, we can
    certainly fill zero minutes with burgers. Once we escape the `while` loop, we’ve
    found the largest number of minutes, `i`, that can be filled by burgers. At that
    point, `result` will hold the maximum number of burgers, and `t - i` is the number
    of minutes that remain, so we output both values ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s that. We use recursion in `solve_t` to solve for `t` exactly. We tested
    `solve_t` on different kinds of test cases, and everything looked good. Not being
    able to solve for exactly `t` poses no problem: we use a loop inside of `solve`
    to try the minutes one by one, from largest to smallest. All we need now is a
    `main` function to read the input and call `solve`; [Listing 3-3](ch03.xhtml#ch03ex03)
    provides the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: The main function*'
  prefs: []
  type: TYPE_NORMAL
- en: Ah, a harmonious moment. We’re now ready to submit Solution 1 to the judge.
    Please do that now. I’ll wait . . . and wait . . . and wait.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Memoization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solution 1 fails, not because it’s incorrect, but because it’s too slow. If
    you submit Solution 1 to the judge, you’ll receive a “Time-Limit Exceeded” error.
    Remember the “Time-Limit Exceeded” error we received in Solution 1 of the Unique
    Snowflakes problem in [Chapter 1](ch01.xhtml)? There, the inefficiency was emblematic
    of doing unnecessary work. Here, as we’ll soon see, the inefficiency does not
    lie in doing unnecessary work, but in doing necessary work over and over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem description says that *t* can be any number of minutes less than
    10,000\. Surely, then, the following test case should pose no problem at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The *m* and *n* values, `4` and `2`, are very small. Relative to 10,000, the
    *t* value of `88` is very small as well. You may be surprised and disappointed
    that our code on this test case may not run within the three-second problem time
    limit. On my laptop, it takes about 10 seconds. That’s 10 seconds on a puny `88`
    test case. While we’re at it, let’s try this slightly bigger test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All we did was increase `t` from `88` to `90`, but this small increase has
    a disproportionate effect on runtime: on my laptop, this test case takes about
    18 seconds—almost double what the `88` test case takes! Testing with a `t` value
    of 92 just about doubles the runtime again, and so on and so on. No matter how
    fast the computer, you’re unlikely to ever make it to a `t` value of even 100\.
    By extrapolating from this trend, we can see that it’s unfathomable how much time
    it would take to run our code on a test case where `t` is in the thousands. This
    kind of algorithm, in which a fixed increment in problem size leads to a doubling
    of runtime, is called an *exponential-time algorithm*.'
  prefs: []
  type: TYPE_NORMAL
- en: We have established that our code is slow—but why? Where is the inefficiency?
  prefs: []
  type: TYPE_NORMAL
- en: '##### Counting the Function Calls'
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to take Solution 1 and add some code that counts the number of times
    that `solve_t` is called; see [Listing 3-4](ch03.xhtml#ch03ex04) for the new `solve_t`
    and `solve` functions. We now have a global variable `total_calls` that is initialized
    to `0` on entry to `solve` and is increased by `1` on every call of `solve_t`.
    That variable is of type `long long`; `long` or `int` simply isn’t big enough
    to capture the explosion of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: Solution 1, instrumented*'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of `solve_t`, we increase `total_calls` by `1` ❶ to count this
    function call. In `solve`, we initialize `total_calls` to `0` ➋ so that the count
    of calls is reset before each test case is processed. For each test case, the
    code prints the number of times that `solve_t` was called ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we give it a go with this input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'we get this as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve made billions of calls!
  prefs: []
  type: TYPE_NORMAL
- en: Consider a given *m*, *n*, *t* test case. Our `solve_t` function has three parameters,
    but only the third parameter *t* ever changes. There are, therefore, only *t*
    + 1 different ways that `solve_t` can be called. For example, if *t* in a test
    case is `88`, then the only calls that can be made to `solve_t` are those with
    *t* values of `88`, `87`, `86`, and so on. Once we know the answer for some *t*
    value, such as `86`, there’s no reason to ever compute that answer again.
  prefs: []
  type: TYPE_NORMAL
- en: Of those billions of calls, only about 88 or 90 of them can be distinct. We
    conclude that the same subproblems are being solved a staggering number of times.
  prefs: []
  type: TYPE_NORMAL
- en: Remembering Our Answers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s some intuition for the staggering number of calls we make. If we call
    `solve_t(4, 2, 88)`, it makes two recursive calls: one to `solve_t(4, 2, 86)`
    and the other to `solve_t(4, 2, 84)`. So far, so good. Now consider what will
    happen for the `solve_t(4, 2, 86)` call. It will make two recursive calls of its
    own, the first of which is `solve_t(4, 2, 84)`—exactly one of the recursive calls
    made by `solve_t(4, 2, 88)`! That `solve_t(4, 2, 84)` work will therefore be performed
    twice. Once would have been enough!'
  prefs: []
  type: TYPE_NORMAL
- en: However, the imprudent duplication is only just beginning. Consider the two
    `solve_t(4, 2, 84)` calls. By reasoning as in the previous paragraph, we see that
    each call eventually leads to two calls of `solve_t(4, 2, 80)`, for a total of
    four. Again, once would have been enough!
  prefs: []
  type: TYPE_NORMAL
- en: Well, it would have been enough if we had somehow remembered the answer from
    the first time we computed it. If we remember the answer to a call of `solve_t`
    the first time we compute it, we can just look it up later when we need that answer
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember, don’t refigure*. That’s the maxim of the *memoization* technique.
    Memoization comes from the word *memoize*, which means to store as if on a memo.
    It is a clunky word, sure, but one that’s in widespread use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using memoization involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Declare an array large enough to hold the solutions to all possible subproblems.
    In Burger Fervor, `t` is less than 10,000, so an array of 10,000 elements suffices.
    This array is typically given the name `memo`.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the elements of `memo` to a value reserved to mean “unknown value.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the start of the recursive function, add code to check whether the subproblem
    solution has already been solved. This involves checking the corresponding index
    of `memo`: if the “unknown value” is there, then we have to solve this subproblem
    now; otherwise, the answer is already stored in `memo` and we simply return it,
    without doing any further recursion. Whenever we solve a new subproblem, we store
    its solution in `memo`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s augment Solution 1 with memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Memoization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The appropriate place to declare and initialize the `memo` array is in `solve`,
    since that’s the function that first gets triggered for each test case. We’ll
    use a value of `-2` to represent an unknown value; we can’t use positive numbers
    because those would be confused with numbers of burgers, and we can’t use `-1`
    because we’re already using `-1` to mean “no solution possible.” The updated `solve`
    function is given in [Listing 3-5](ch03.xhtml#ch03ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Solution 2, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `memo` array using the maximum possible size for any test case
    ❶. Then we loop from `0` to `t` and set each element in the range to `-2`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a small but important change in our calls to `solve_t`. Now we’re
    passing in `memo` along with the other arguments; in this way, `solve_t` can check
    `memo` to determine whether the current subproblem has already been solved and
    update `memo` if it has not.
  prefs: []
  type: TYPE_NORMAL
- en: The updated `solve_t` code is given in [Listing 3-6](ch03.xhtml#ch03ex06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: Solving for exactly t minutes, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The game plan is the same as it was in Solution 1, [Listing 3-1](ch03.xhtml#ch03ex01):
    if `t` is `0`, solve the base case; otherwise, solve for `t - m` minutes and `t
    - n` minutes and use the better one.'
  prefs: []
  type: TYPE_NORMAL
- en: To this structure we fasten memoization. The huge reduction in time is realized
    when we check if a solution for `t` is already in the `memo` array ❶, returning
    that stored result if it is. There is no fussing over whether the final burger
    takes *m* or *n* minutes. There is no further recursion. All we have is an immediate
    return from the function.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t find a solution in `memo`, then we have work to do. The work is
    the same as before—except that, whenever we’re about to return the solution, we
    first store it in the memo. Before each of our `return` statements, we store the
    value we’re about to return in `memo` so that our program maintains a memory of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Testing Our Memoization'
  prefs: []
  type: TYPE_NORMAL
- en: 'I demonstrated that Solution 1 was doomed by showing you two things: that small
    test cases took far too long to run and that the slowness was caused by making
    an exorbitant number of function calls. How does Solution 2 fare in terms of these
    metrics?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try Solution 2 with the input that bested Solution 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On my laptop, the time taken is imperceptibly small.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many function calls are made? I encourage you to instrument Solution 2
    in the way that we did for Solution 1 ([Listing 3-4](ch03.xhtml#ch03ex04)). If
    you do that and run it with the above input, you should get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 88 calls when `t` is `88`. 90 calls when `t` is `90`. The difference between
    Solution 2 and Solution 1 is like night and a few billion days. We’ve gone from
    an exponential-time algorithm to a linear-time algorithm. Specifically, we now
    have an *O*(*t*) algorithm, where *t* is the number of Homer’s minutes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s judge time. If you submit Solution 2, you’ll see that we pass all of the
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: This is certainly a milestone, but it is not the last word on Homer and his
    burgers. We’ll be able to use something called dynamic programming to eliminate
    the recursion from our code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 3: Dynamic Programming*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll bridge our way from memoization to dynamic programming by making explicit
    the purpose of recursion in Solution 2\. Consider the `solve_t` code in [Listing
    3-7](ch03.xhtml#ch03ex07); it’s the same as the code in [Listing 3-6](ch03.xhtml#ch03ex06)
    except that I’m now highlighting just the two recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Solving for exactly t minutes, focusing on recursive calls*'
  prefs: []
  type: TYPE_NORMAL
- en: At the first recursive call ❶, one of two very different things will happen.
    The first is that the recursive call finds its subproblem solution in the memo
    and returns immediately. The second is that the recursive call does not find the
    subproblem solution in the memo, in which case it carries out its own recursive
    calls. All of this is true of the second recursive call ➋ as well.
  prefs: []
  type: TYPE_NORMAL
- en: When we make a recursive call and it finds its subproblem solution in the memo,
    we have to wonder why we made the recursive call at all. The only thing that the
    recursive call will do is check the memo and return; we could have done that ourselves.
    If the subproblem solution is not in the memo, however, then the recursion is
    really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we could orchestrate things so that the `memo` array always holds
    the next subproblem solution that we need to look up. We want to know the optimal
    solution when `t` is `5`? It’s in `memo`. What about when `t` is `18`? That’s
    in `memo`, too. By virtue of always having the subproblem solutions in the memo,
    we’ll never require a recursive call; we can just look up the solution right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have the difference between memoization and dynamic programming. A
    function that uses memoization makes a recursive call to solve a subproblem. Maybe
    the subproblem was already solved, maybe it wasn’t— regardless, it will be solved
    when the recursive call returns. A function that uses *dynamic programming* organizes
    the work so that a subproblem is already solved by the time we need it. We then
    have no reason to use recursion: we just look up the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization uses recursion to ensure that a subproblem is solved; dynamic programming
    ensures that the subproblem is already solved and therefore has no use for recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Our dynamic-programming solution dispenses with the `solve_t` function and systematically
    solves for all values of `t` in `solve`. [Listing 3-8](ch03.xhtml#ch03ex08) gives
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: Solution 3, with dynamic programming*'
  prefs: []
  type: TYPE_NORMAL
- en: The canonical name for a dynamic-programming array is `dp`. We could have called
    it `memo`, since it serves the same purpose as a memo table, but we call it `dp`
    to follow convention. Once we declare the array, we solve the base case, explicitly
    storing the fact that the optimal solution for zero minutes is to eat zero burgers
    ❶. Then we have the loop that controls the order in which the subproblems are
    solved. Here, we solve the subproblems from smallest number of minutes (`1`) to
    largest number of minutes (`t`). The variable `i` determines which subproblem
    is being solved. Inside our loop, we have the familiar check of whether it makes
    sense to test the *m*-minute burger as the final burger ➋. If so, we look up the
    solution to the `i - m` subproblem in the `dp` array ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we just look up the value from the array ➌, without using any recursion.
    We can do that because we know, by virtue of the fact that `i - m` is less than
    `i`, that we’ve already solved subproblem `i - m`. This is precisely why we solve
    subproblems in order, from smallest to largest: larger subproblems will require
    solutions to smaller subproblems, so we must ensure that those smaller subproblems
    have already been solved.'
  prefs: []
  type: TYPE_NORMAL
- en: The next `if` statement ➍ is analogous to the previous one ➋ and handles the
    case when the final burger is an *n*-minute burger. As before, we look up the
    solution to a subproblem using the `dp` array. We know for sure that the `i -
    n` subproblem has already been solved, because the `i - n` iteration took place
    before this `i` iteration.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the solutions to both of the required subproblems. All that’s left
    to do is store the optimal solution for `i` in `dp[i]` ➎ ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve built up the `dp` array, solving subproblems `0` to `t`, we can look
    up subproblem solutions at will. We thus simply look up the solution to subproblem
    `t` ❼, printing it if there’s a solution and looking up solutions to progressively
    smaller subproblems if there’s not ❽.
  prefs: []
  type: TYPE_NORMAL
- en: Like our memoized solution, this is a linear-time solution. In general, the
    dynamic-programming and memoized solutions of a problem will have the same efficiency,
    but, that efficiency may be easier to identify in dynamic-programming solutions
    because they use a loop rather than recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one example `dp` array before moving on. For the test case that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'the final contents of the `dp` array are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can trace the code in [Listing 3-8](ch03.xhtml#ch03ex08) to confirm each
    of these subproblem solutions. For example, `dp[0]`, the maximum number of burgers
    that Homer can eat in zero minutes, is `0` ❶. `dp[1]` is `-1` because both checks
    ➋ ➍ fail, meaning we store `-1` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: As a final example, we’re going to reverse-engineer how `dp[12]` got its value
    of `3`. Since 12 is greater than 4, the first check passes ➋. We then set `first`
    to `dp[8]` ➌, which has a value of `2`. Similarly, 12 is greater than 9, so the
    second check passes ➍, and we set `second` to `dp[3]`, which has a value of `-1`.
    The maximum of `first` and `second` is therefore `2`, so we set `dp[12]` to `3`,
    one more than that maximum ➏.
  prefs: []
  type: TYPE_NORMAL
- en: Please feel free to submit our dynamic programming solution to the judge. It
    should pass all test cases just like our memoization solution did. Is one of these
    solutions better than the other? And when should we be using memoization and dynamic
    programming, anyway? Read on to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization and Dynamic Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We solved Burger Fervor in four steps. First, we characterized what an optimal
    solution must look like; second, we wrote a recursive solution; third, we added
    memoization; and fourth, we eliminated the recursion by explicitly solving subproblems
    from smallest to largest. These four steps offer a general plan for tackling many
    other optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Step 1: Structure of Optimal Solutions*'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to show how to decompose an optimal solution to a problem
    into optimal solutions for smaller subproblems. In Burger Fervor, we did this
    by reasoning about the final burger that Homer eats. Is it an *m*-minute burger?
    That leaves the subproblem of filling *t* – *m* minutes. What if it is an *n*-minute
    burger? That leaves the problem of filling *t* – *n* minutes. We don’t know which
    it is, of course, but we can simply solve these two subproblems to find out.
  prefs: []
  type: TYPE_NORMAL
- en: It’s critical that our subproblems really are *smaller* than the original problem.
    If they are not, then we will fail to eventually reach a base case. The problems
    in [Chapter 5](ch05.xhtml) serve as examples of what we need to do when subproblems
    cannot be easily ordered by size.
  prefs: []
  type: TYPE_NORMAL
- en: We also require that an optimal solution to a problem contains within it not
    just some solutions to the smaller subproblems but *optimal* solutions to those
    subproblems. Let’s make this point explicit here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Burger Fervor, when supposing that the final burger in an optimal solution
    is an *m*-minute burger, we argued that a solution to the *t* – *m* subproblem
    was part of the solution to the overall *t* problem. Moreover, an optimal solution
    for *t* must include the optimal solution for *t* – *m*: if it didn’t, then the
    solution for *t* wouldn’t be optimal after all, since we could improve it by using
    the better solution for *t* – *m*! A similar argument can be used to show that,
    if the last burger in an optimal solution is an *n*-minute burger, then the remaining
    *t* – *n* minutes should be filled with an optimal solution for *t* – *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let me unpack this a little through an example. Suppose that *m* = 4, *n* =
    9, and *t* = 54\. The value of an optimal solution is 11\. There is an optimal
    solution *S* where the final burger is a 9-minute burger. My claim is that *S*
    must consist of this 9-minute burger along with an optimal solution for 45 minutes.
    The optimal solution for 45 minutes is 10 burgers. If *S* used some suboptimal
    solution for the first 45 minutes, then *S* wouldn’t be an example of an optimal
    11-burger solution. For example, if *S* used a suboptimal five-burger solution
    for the first 45 minutes, then it would use a total of only six burgers for the
    full 54 minutes!
  prefs: []
  type: TYPE_NORMAL
- en: If an optimal solution to a problem is composed of optimal solutions to subproblems,
    we say that the problem has *optimal substructure*. If a problem has optimal substructure,
    the techniques from this chapter are likely to apply.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve read and heard people claim that solving optimization problems using memoization
    or dynamic programming is formulaic, that once you’ve seen one such problem, you’ve
    seen them all, and you can just turn the crank when a new problem arises. I don’t
    think so. That perspective belies the challenges of both characterizing the structure
    of optimal solutions and identifying that this will be fruitful in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when discussing the structure of an optimal solution for Burger
    Fervor, I made a big deal about focusing on *exactly t* minutes. As a result,
    in our code we couldn’t necessarily look up the answer in one shot—we needed to
    check for a solution to exactly *t* minutes, then exactly *t* – 1 minutes, then
    exactly *t* – 2 minutes, and so on, until we found a solution. But couldn’t we
    have found a way to characterize the optimal solution so that we didn’t need to
    search like that? Well, we could have, but that would have led to an overall trickier
    solution for this problem. (We’ll see this alternate kind of approach as an effective
    way to solve Problem 3 later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: My point here is simply that discovering what an optimal solution looks like
    can be surprisingly tricky. The sheer breadth of problems that can be solved using
    memoization and dynamic programming means that practicing with and generalizing
    from as many problems as possible is the only way forward.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2: Recursive Solution*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Step 1 not only suggests to us that memoization and dynamic programming will
    lead to a solution, but also leaves in its wake a recursive approach for solving
    the problem. To solve the original problem, try each of the possibilities for
    an optimal solution, solving subproblems optimally using recursion. In Burger
    Fervor, we argued that an optimal solution for exactly *t* minutes might consist
    of an *m*-minute burger and an optimal solution for exactly *t* – *m* minutes
    or an *n*-minute burger and an optimal solution for exactly *t* – *n* minutes.
    Solving the *t* – *m* and *t* – *n* subproblems is therefore required and, as
    these are smaller subproblems than *t*, we used recursion to solve them. In general,
    the number of recursive calls depends on the number of available candidates competing
    to be the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3: Memoization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we succeed with Step 2, then we have a correct solution to the problem.
    As we saw with Burger Fervor, though, such a solution may require an absolutely
    unreasonable amount of time to execute. The culprit is that the same subproblems
    are being solved over and over, as a result of a phenomenon known as *overlapping
    subproblems*. Really, if we didn’t have overlapping subproblems, then we could
    stop right here: recursion would be fine on its own. Think back to [Chapter 2](ch02.xhtml)
    and the two problems we solved there. We solved those successfully with recursion
    alone, and that worked because each subproblem was solved only once. In Halloween
    Haul, for example, we calculated the total amount of candy in a tree. The two
    subproblems were finding the total amounts of candy in the left and right subtrees.
    Those problems are independent: there’s no way that solving the subproblem for
    the left subtree could somehow require information about the right subtree, or
    vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no subproblem overlap, we can just use recursion. When there is subproblem
    overlap, however, it’s time for memoization. As we learned when solving Burger
    Fervor, memoization means that we store the solution to a subproblem the first
    time we solve it. Then, whenever that subproblem solution is needed in the future,
    we simply look it up rather than recalculate it. Yes, the subproblems still overlap,
    but now they are solved only once, just like in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Step 4: Dynamic Programming*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very likely, the solution resulting from Step 3 will be fast enough. Such a
    solution still uses recursion, but without the risk of duplicating work. As I’ll
    explain in the next paragraph, sometimes we want to eliminate the recursion. We
    can do so as long as we systematically solve smaller subproblems before larger
    subproblems. This is dynamic programming: the use of a loop in lieu of recursion,
    explicitly solving all subproblems in order from smallest to largest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what’s better: memoization or dynamic programming? For many problems, they
    are roughly equivalent and, in those cases, you should use what you find more
    comfortable. My personal choice is memoization. We’ll see an example (Problem
    3 later in this chapter) where the `memo` and `dp` tables have multiple dimensions.
    In such problems, I often have trouble getting all of the base cases and bounds
    for the `dp` table correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization solves subproblems on an as-needed basis. For example, consider
    the Burger Fervor test case where we have a kind of burger that takes 2 minutes
    to eat, a kind of burger that takes 4 minutes to eat, and 90 minutes of time.
    A memoized solution will never solve for odd numbers of minutes, such as 89 or
    87 or 85, because those subproblems do not result from subtracting multiples of
    2 and 4 from 90\. Dynamic programming, by contrast, solves all subproblems on
    its way up to 90\. The difference here seems to favor memoized solutions; indeed,
    if huge swaths of the subproblem space are never used, then memoization may be
    faster than dynamic programming. This has to be balanced against the overhead
    inherent in recursive code, though, with all of the calling and returning from
    functions. If you’re so inclined, it wouldn’t hurt to code up both solutions to
    a problem and see which is faster!
  prefs: []
  type: TYPE_NORMAL
- en: You’ll commonly see people refer to memoized solutions as *top-down* solutions
    and dynamic-programming solutions as *bottom-up* solutions. It’s called “top-down”
    because, to solve large subproblems, we recurse down to small subproblems. In
    “bottom-up” solutions, we start from the bottom—the smallest subproblems—and work
    our way to the top.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization and dynamic programming are captivating to me. They can solve so
    many types of problems; I don’t know another algorithm design technique that even
    comes close. Many of the tools that we learn in this book, such as hash tables
    in [Chapter 1](ch01.xhtml), offer valuable speedups. The truth is that, even without
    those tools, we could solve many problem instances— not in time to have such solutions
    accepted by the judge, but perhaps still in time to be practically useful. However,
    memoization and dynamic programming are different. They vivify recursive ideas,
    turning algorithms that are astonishingly slow into those that are astonishingly
    fast. I hope I can pull you into the fold with this chapter and the next and that
    you won’t stop when these chapters do.
  prefs: []
  type: TYPE_NORMAL
- en: '### Problem 2: Moneygrubbers'
  prefs: []
  type: TYPE_NORMAL
- en: In Burger Fervor, we were able to solve each problem by considering only two
    subproblems. Here, we’ll see an example where each problem may require solving
    many more subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: This is UVa problem `10980`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You want to buy apples, so you go to an apple store. The store has a price for
    buying one apple—for example, $1.75\. The store also has *m* pricing schemes,
    where each pricing scheme gives a number *n* and a price *p* for buying *n* apples.
    For example, one pricing scheme might state that three apples cost a total of
    $4.00; another might state that two apples cost a total of $2.50\. You want to
    buy *at least k* apples and do so as cheaply as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We read test cases until there’s no more input. Each test case consists of
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the price for buying one apple, followed by the number *m*
    of pricing schemes for this test case. *m* is at most 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each of which gives a number *n* and total price *p* for buying
    *n* apples. *n* is between 1 and 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing integers, where each integer *k* is between 0 and 100 and
    gives the desired number of apples to buy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each price in the input is a floating-point number with exactly two decimal
    digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the problem description, I gave an example price of one apple as $1.75\.
    I also gave two example pricing schemes: three apples for $4.00 and two apples
    for $2.50\. Using that data, suppose we wanted to determine the minimum price
    for buying at least one apple and at least four apples, respectively. Here’s the
    input for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case, output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing `Case` c:, where c is the number of the test case starting
    at 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each integer *k*, a line containing `Buy` *k* `for $*d*`, where d is the
    cheapest cost for which we can buy at least k apples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the output for the above sample input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The time limit for solving the test cases is three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Characterizing Optimal Solutions*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The problem description specifies that we want to buy *at least k* apples as
    cheaply as possible. This means that buying exactly *k* apples is only one option;
    we can buy more than *k* apples if it’s cheaper that way. We’re going to start
    by trying to solve for exactly *k* apples, much as we solved for exactly *t* minutes
    in Burger Fervor. Back then, we found a way when necessary to move from exactly
    *t* minutes to smaller numbers of minutes. The hope is that we can do something
    similar here, starting with *k* apples and finding the cheapest cost for *k*,
    *k* + 1, *k* + 2, and so on. If it ain’t broke . . .
  prefs: []
  type: TYPE_NORMAL
- en: Before just recalling the title of this chapter and diving headlong into memoization
    and dynamic programming, let’s make sure that we really do need those tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s better: buying three apples for a total of $4.00 (Scheme 1) or two apples
    for a total of $2.50 (Scheme 2)? We can try to answer this by calculating the
    cost per apple for each of these pricing schemes. In Scheme 1, we have $4.00/3
    = $1.33 per apple, and in Scheme 2 we have $2.50/2 = $1.25 per apple. It looks
    like Scheme 2 is better than Scheme 1\. Let’s also suppose that we can buy one
    apple for $1.75, which looks even worse than the two schemes. We therefore have
    the cost per apple, from cheapest to most expensive, as follows: $1.25, $1.33,
    $1.75.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that we want to buy *exactly k* apples. How’s this for an algorithm:
    at each step, use the cheapest cost per apple, until we’ve bought *k* apples?'
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to buy exactly four apples for the above case, then we’d start
    with Scheme 2, because it lets us buy apples with the best price per apple. Using
    Scheme 2 once costs us $2.50 for two apples, and it leaves us with two apples
    to buy. We can then use Scheme 2 again, buying two more apples (for a total now
    of four apples) for another $2.50\. We’d have spent $5.00 for the four apples
    and, indeed, we cannot do better.
  prefs: []
  type: TYPE_NORMAL
- en: Note that just because an algorithm is intuitive or works on one test case does
    not mean that it is correct in general. This algorithm of using the best-available
    price per apple is flawed, and there are test cases that prove it. Try to find
    such a test case before continuing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one: suppose that we want to buy exactly three apples, not four. We’d
    start with Scheme 2 again, giving us two apples for a total of $2.50\. Now we
    have only one apple to buy—and the only choice is to pay $1.75 for the one apple.
    The total cost is $4.25—but there is a better way. Namely, we should simply have
    used Scheme 1 once, costing us $4.00: yes, it has a higher cost per apple than
    Scheme 2, but it makes up for that by freeing us from paying for one apple that
    has a still higher cost per apple.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to start affixing extra rules to our algorithm to try to fix it;
    for example, “if there’s a pricing scheme for exactly the number of apples that
    we need, then use it.” Suppose, however, we want to buy exactly three apples.
    We can easily break this augmented algorithm by adding a scheme in which the store
    sells three apples for $100.00.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using memoization and dynamic programming, we try all the available options
    for an optimal solution and then pick the best one. In Burger Fervor, should Homer
    end with an *m*-minute burger or an *n*-minute burger? We don’t know, so we try
    both. By contrast, a *greedy algorithm* is an algorithm that tries just one option:
    the one that looks like the best choice at the time.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the best price per apple, as we did above, is an example of a greedy algorithm,
    because at each step it chooses what to do without considering other options.
    Sometimes greedy algorithms work. Moreover, since they often run faster than dynamic-programming
    algorithms and are easier to implement , a working greedy algorithm may be better
    than a working dynamic-programming algorithm. For this problem, it appears that
    greedy algorithms—whether the one above or others that might come to mind—are
    not sufficiently powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Burger Fervor, we reasoned that, if it’s possible to spend *t* minutes eating
    burgers, then the final burger in an optimal solution must be an *m*-minute burger
    or an *n*-minute burger. For the present problem, we want to say something analogous:
    that an optimal solution for buying *k* apples must end in one of a small number
    of ways. Here’s a claim: if the available pricing schemes are Scheme 1, Scheme
    2, . . . , Scheme *m*, then the final thing we do must be to use one of these
    *m* pricing schemes. There can’t be anything else that we could do, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is not quite true. The final thing that we do in an optimal solution
    might be buying one apple. We always have that as an option. Rather than solve
    two subproblems as in Burger Fervor, we solve *m* + 1 subproblems: one for each
    of the *m* pricing schemes and one for buying one apple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an optimal solution for buying *k* apples ends with us paying
    *p* dollars for *n* apples. We then need to optimally buy *k* – *n* apples and
    add that cost to *p*. We need to establish that the overall optimal solution for
    *k* apples contains within it an optimal solution for *k* – *n* apples. This is
    the optimal substructure requirement of memoization and dynamic programming. As
    with Burger Fervor, optimal substructure does hold. If a solution for *k* didn’t
    use an optimal solution for *k* – *n*, then that solution for *k* cannot be optimal
    after all: it’s not as good as what we’d get if we built it on the optimal solution
    for *k* – *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don’t know what to do at the end of the solution to make it optimal.
    Do we use Scheme 1, use Scheme 2, use Scheme 3, or just buy one apple? Who knows?
    As in any memoization or dynamic-programming algorithm, we simply try them all
    and choose the best one.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at a recursive solution, note that, for any number *k*, we can
    always find a way to buy exactly *k* apples. Whether one apple, two apples, five
    apples, whatever, we can buy that many. The reason is that we always have the
    option of buying one apple, and we can do that as many times as we like. Compare
    this to Burger Fervor, where there were values of *t* such that *t* minutes could
    not be filled by the available burgers. As a consequence of this difference, here
    we won’t have to worry about the case where a recursive call on a smaller subproblem
    fails to find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like in Burger Fervor, the first thing to do is write a helper function to solve
    for a specific number of apples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Helper Function: Solving for the Number of Apples'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s write the function `solve_k`, whose job will be analogous to the `solve_t`
    functions that we wrote for Burger Fervor. The function signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these parameters except for the last comes directly from the current
    test case. Here’s what each parameter is for:'
  prefs: []
  type: TYPE_NORMAL
- en: num   An array of numbers of apples, with one element per pricing scheme. For
    example, if we have two pricing schemes, the first for three apples and the second
    for two apples, then this array would be `[3, 2]`.
  prefs: []
  type: TYPE_NORMAL
- en: price   An array of prices, one element per pricing scheme. For example, if
    we have two pricing schemes, the first with cost `4.00` and the second with cost
    `2.50`, then this array would be `[4.00, 2.50]`. Notice that `num` and `price`
    together give us all of the information about the pricing schemes.
  prefs: []
  type: TYPE_NORMAL
- en: num_schemes   The number of pricing schemes. It’s the `m` value from the test
    case.
  prefs: []
  type: TYPE_NORMAL
- en: unit_price   The price for one apple.
  prefs: []
  type: TYPE_NORMAL
- en: num_apples   The number of apples that we want to buy.
  prefs: []
  type: TYPE_NORMAL
- en: The `solve_k` function returns the minimum cost for buying exactly `num_apples`
    apples.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `solve_k` is given in [Listing 3-9](ch03.xhtml#ch03ex09). In addition
    to studying this code on its own, I strongly encourage you to compare it to the
    `solve_t` function from Burger Fervor ([Listing 3-1](ch03.xhtml#ch03ex01)). What
    differences do you notice? Why are these differences present? Memoization and
    dynamic-programming solutions share a common code structure. If we can nail that
    structure, then we can focus on what’s different in and specific to each problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: Solving for exactly num_apples apples*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a little `min` function ❶: we’ll need that for comparing solutions
    and picking the smaller one. In Burger Fervor, we used a similar `max` function,
    because we wanted the maximum number of burgers. Here, we want the minimum cost.
    Some optimization problems are *maximization problems* (Burger Fervor) and others
    are *minimization problems* (Moneygrubbers)— carefully read problem statements
    to make sure you’re optimizing in the right direction!'
  prefs: []
  type: TYPE_NORMAL
- en: What do we do if asked to solve for `0` apples ➋? We return `0` ➌, because the
    minimum cost to buy zero apples is exactly $0.00\. That’s a base case, just like
    filling zero minutes in Burger Fervor. As with recursion in general, at least
    one base case is required for any optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re not in the base case, then `num_apples` will be a positive integer,
    and we need to find the optimal way to buy exactly that many apples. The variable
    `best` is used to track the best (minimum-cost) option that has been found so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to optimally solve for `num_apples - 1` apples ➍ and add the cost
    of the final apple ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now hit the big structural difference between this problem and Burger Fervor:
    a loop inside of the recursive function. In Burger Fervor, we didn’t need a loop,
    because we only had two subproblems to try. We just tried the first one and then
    tried the second one. Here, though, we have one subproblem per pricing scheme,
    and we have to go through all of them. We check whether the current pricing scheme
    can be used at all ➏: if its number of apples is no larger than the number that
    we need, then we can try it. We make a recursive call to solve the subproblem
    resulting from removing the number of apples in this pricing scheme ❼. (It’s similar
    to the earlier recursive call where we subtracted one for the single apple ➍.)
    If that subproblem solution plus the price of the current scheme is our best option
    so far, then we update `best` accordingly ❽.'
  prefs: []
  type: TYPE_NORMAL
- en: The solve Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ve optimally solved for exactly *k* apples, but there’s this detail from
    the problem statement that we haven’t addressed yet: “You want to buy *at least
    k* apples and to do so as cheaply as possible.” Why does the difference between
    exactly *k* apples and at least *k* apples matter in the first place? Can you
    find a test case where it’s cheaper to buy more than *k* apples than it is to
    buy *k* apples?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one for you. We’ll say that one apple costs $1.75\. We have two pricing
    schemes: Scheme 1 is that we can buy four apples for $3.00, and Scheme 2 is that
    we can buy two apples for $2.00\. Now, we want to buy at least three apples. This
    test case in the form of problem input is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The cheapest way to buy exactly three apples is to spend $3.75: one apple for
    $1.75 and two apples using Scheme 2 for $2.00\. However, we can spend less money
    by in fact buying four apples, not three. The cheapest way to buy four apples
    is to use Scheme 1 once, which costs us only $3.00\. That is, the correct output
    for this test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: (This output is a bit confusing, because we’re actually buying four apples,
    not three, but it is correct to output `Buy 3` here. We always output the number
    of apples that we’re asked to buy, whether or not we buy more than that to save
    money.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a `solve` function like the one we had for Burger Fervor in
    [Listing 3-2](ch03.xhtml#ch03ex02). There, we tried smaller and smaller values
    until we found a solution. Here, we’ll try larger and larger values, keeping track
    of the minimum solution as we go. Here’s a first crack at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We initialize `best` to the optimal solution for buying exactly `num_apples`
    apples ❶. Then, we use a `for` loop to try larger and larger numbers of apples
    ➋. The `for` loop stops when . . . uh-oh. How do we know when it’s safe to stop?
    Maybe we’re being asked to buy 3 apples, but the cheapest thing to do is to buy
    4 or 5 or 10 or even 20\. We didn’t have this problem in Burger Fervor, because
    there we were making our way downward, toward zero, rather than upward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find a game-saving observation from the problem input specification:
    it says that the number of apples in a given pricing scheme is at most 100\. How
    does this help?'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’re being asked to buy at least 50 apples. Might it be best to buy
    exactly 60 apples? Sure! Maybe the final pricing scheme in an optimal solution
    for 60 apples is for 20 apples. Then we could combine those 20 apples with an
    optimal solution for 40 apples to get a total of 60 apples.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose again that we’re buying 50 apples. Could it make sense for us to buy
    exactly 180 apples? Well, think about an optimal solution for buying exactly 180
    apples. The final pricing scheme that we use gives us at most 100 apples. Before
    using that final pricing scheme, we’d have bought at least 80 apples and had done
    so more cheaply than we did for 180 apples. Crucially, 80 is still greater than
    50! Therefore, buying 80 apples is cheaper than buying 180 apples. Buying 180
    apples cannot be the optimal thing to do if we want at least 50 apples.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, for 50 apples, the maximum number of apples we should even consider
    buying is 149\. If we buy 150 or more apples, then removing the final pricing
    scheme gives us a cheaper way to buy 50 or more apples.
  prefs: []
  type: TYPE_NORMAL
- en: The problem input specification not only limits the number of apples per pricing
    scheme to 100, it also limits the number of apples to buy to 100\. In the case
    in which we are asked to buy 100 apples, then, the maximum number of apples we
    should consider buying is 100 + 99 = 199\. Incorporating this observation leads
    to the `solve` function in [Listing 3-10](ch03.xhtml#ch03ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Now all we need is a `main` function and we can start submitting stuff to the
    judge.
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s get a `main` function written. See [Listing 3-11](ch03.xhtml#ch03ex11).
    It’s not completely self-contained, but all we’ll need is one helper function,
    `get_number`, that I’ll describe shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: The main function*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by using `scanf` to try to read the first line of the next test case
    from the input ❶. The next `scanf` call ➋ is in a nested loop, and it reads the
    number of apples and price for each pricing scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the `scanf` format strings ends with a space, which ensures
    that we’re always positioned at the start of each line. This becomes important
    once we get to the line containing the numbers of apples that we are asked to
    buy, because we’re going to use a helper function that assumes we’re at the start
    of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need a helper function? Well, we can’t just airily keep calling `scanf`
    to read those numbers of apples, because we have to be able to stop at a newline.
    That’s why we use my `get_number` helper function instead, described further below.
    It returns `1` if there are more numbers to read and `0` if this is the last number
    on the line. We call this function to read each number in the loop ➌ that solves
    the test cases. We also need some code below the loop ➍: when the loop terminates
    because it has read the final number on the line, we still need to solve that
    final test case.'
  prefs: []
  type: TYPE_NORMAL
- en: The code for `get_number` is given in [Listing 3-12](ch03.xhtml#ch03ex012).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: The function to get an integer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function reads an integer value using an approach reminiscent of [Listing
    2-17](ch02.xhtml#ch02ex017). The loop continues as long as we haven’t yet hit
    a space or new-line character ❶. When the loop terminates, we store what was read
    in the pointer parameter passed to this function call ➋. We use that pointer parameter,
    rather than return the value, because the return value has another role: to indicate
    whether or not this is the last number on the line ➌. That is, if `get_number`
    returns `1` (because it found a space after the number that it read), it means
    that there are more numbers on this line; if it returns `0`, then this is the
    final number on this line.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a complete solution now, but its performance is glacial. Even test
    cases that look small will take ages, because we’re going all the way up to 299
    apples no matter what.
  prefs: []
  type: TYPE_NORMAL
- en: Oh well. Let’s memoize the heck out of this thing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Memoization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We introduced the `memo` array in `solve` ([Listing 3-5](ch03.xhtml#ch03ex05))
    when memoizing Burger Fervor. That was because each call of `solve` was for an
    independent test case. However, in Moneygrubbers, we have that line where each
    integer specifies a number of apples to buy, and we have to solve each one. It
    would be wasteful to throw away the `memo` array before we’ve completely finished
    with the test case!
  prefs: []
  type: TYPE_NORMAL
- en: We’re therefore going to declare and initialize `memo` in `main`. The updated
    `main` function is in [Listing 3-13](ch03.xhtml#ch03ex013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-13: The main function, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `memo` array ❶, and we set each element of `memo` to `-1` (“unknown”
    value) ➋ ➌. Notice that the initialization of `memo` occurs just once per test
    case. The only other change is that we add `memo` as a new parameter to the `solve`
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: The new code for `solve` is given in [Listing 3-14](ch03.xhtml#ch03ex014).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-14: Solution 2, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to adding `memo` as a new parameter at the end of the parameter
    list, we pass `memo` to the `solve_k` calls. That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s take a look at the changes required to memoize `solve_k`. We
    will store in `memo[num_apples]` the minimum cost of buying exactly `num_apples`
    apples. See [Listing 3-15](ch03.xhtml#ch03ex015).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-15: Solving for exactly num_apples apples, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the first thing we do when solving with memoization is check whether
    the solution is already known ❶. If any value besides `-1` is stored for the `num_apples`
    subproblem, we return it. Otherwise, as with any memoized function, we store a
    new subproblem solution in `memo` before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now reached a natural stopping point for this problem: this memoized
    solution can be submitted to the judge and should pass all test cases. If you’d
    like more practice with dynamic programming, though, here’s a perfect opportunity
    for you to convert this memoized solution into a dynamic-programming solution!
    Otherwise, we’ll put this problem on ice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Hockey Rivalry'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first two problems used a one-dimensional `memo` or `dp` array. Let’s look
    at a problem whose solution dictates using a two-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: I live in Canada, so I suppose we weren’t getting through this book without
    some hockey. Hockey is a team sport like soccer . . . but with goals.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `cco18p1`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Geese played *n* games, each of which had one of two outcomes: a win for
    the Geese (`W`) or a loss for the Geese (`L`). (There are no tie games.) For each
    of their games, we know whether they won or lost and we know the number of goals
    that they scored. For example, we might know that their first game was a win (`W`)
    and that they scored four goals in that game. (Their opponent, whoever it was,
    must therefore have lost and scored fewer than four goals.) The Hawks also played
    *n* games and, the same as the Geese, each game was a win or loss for the Hawks.
    Again, for each of their games, we know whether they won or lost and we know the
    number of goals that they scored.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the games that these teams played may have been against each other,
    but there are other teams, too, and some of the games may have been against these
    other teams.
  prefs: []
  type: TYPE_NORMAL
- en: We have no information about who played whom. We might know that the Geese won
    a certain game and that they scored four goals in that game, but we don’t know
    who their opponent was—their opponent could have been the Hawks, but it also could
    have been some other team.
  prefs: []
  type: TYPE_NORMAL
- en: A *rivalry game* is a game where the Geese played the Hawks.
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to determine the maximum number of goals that could have been scored
    in rivalry games.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, the information for which is spread over
    five lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains *n*, the number of games that each team played. *n*
    is between 1 and 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains a string of length *n*, where each character is a `W`
    (win) or `L` (loss). This line tells us the outcome of each game played by the
    Geese. For example, `WLL` means that the Geese won their first game, lost their
    second game, and lost their third game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains *n* integers, giving the number of goals scored in each
    game by the Geese. For example, `4 1 2` means that the Geese scored four goals
    in their first game, one goal in their second game, and two goals in their third
    game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line is like the second, but it tells us the outcome of each game
    for the Hawks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth line is like the third, but it tells us the number of goals scored
    in each game by the Hawks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a single integer: the maximum number of goals scored in possible
    rivalry games.'
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*About Rivalries*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before jumping to the structure of optimal solutions, let’s be sure that we
    understand exactly what’s being asked by working through some test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There can’t be *any* rivalry games at all here. A rivalry game, like any game,
    requires that one team win and the other lose—but the Geese won all their games
    and the Hawks won all their games, so the Geese and Hawks could not have played
    each other. Since there are no rivalry games possible, there are no goals scored
    in rivalry games. The correct output is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now have the Hawks lose all their games:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Are there any rivalry games now? The answer is still no! The Geese won their
    first game by scoring two goals. For that game to be a rivalry game, it must be
    with a game where the Hawks lost and where the Hawks scored fewer than two goals.
    Since the fewest goals scored by the Hawks was five, though, none of those games
    can be a rivalry game with the Geese’s first game. Similarly, the Geese won their
    second game by scoring five goals, but there is no loss for the Hawks where they
    scored four goals or fewer. That is, there is no rivalry involving the Geese’s
    second game. The same kind of analysis shows that the Geese’s third game also
    cannot be part of a rivalry. Again, `0` is the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move past these zero cases. Here’s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We’ve changed the first Hawks game so that they scored four goals instead of
    five, and this is enough to produce a possible rivalry game! Specifically, the
    second game played by the Geese, where the Geese won and scored five goals, could
    be a rivalry game with the first game by the Hawks, where the Hawks lost and scored
    four goals. That game had nine goals scored in it. As there are no other rivalry
    games that we can include, there are no other goals that we can add to our total.
    The correct output here is `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the final game that each team played: the Geese won and scored two
    goals, and the Hawks lost and scored one goal. That could be a rivalry game, with
    a total of three goals. The first game played by each team cannot be a rivalry
    game (the Geese won with six goals, and the Hawks could not have lost the same
    game with eight goals), so we can’t add any more goals. Is `3` the correct output?'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not! We chose poorly, matching those final games. What we should have
    done is match the first game played by the Geese with the second game played by
    the Hawks. That could be a rivalry game, and it has seven goals. This time we’ve
    got it: the correct output is `7`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one more example. Try to figure out the maximum total before
    reading my answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct output is `20`, witnessed by having two rivalry games: the second
    Geese game with the first Hawks game (9 goals there) and the fourth Geese game
    with the fourth Hawks game (11 goals there).'
  prefs: []
  type: TYPE_NORMAL
- en: Did you predict instead that the correct output would be `25`? If so, we’re
    not allowed to add a rivalry of the first Geese game with the third Hawks game.
    Call that pair *x*. Each team’s games are played in order, so if we used *x* as
    a rivalry game, then we wouldn’t be allowed to also pair the second Geese game
    (played after *x*) with the first Hawks game (played before *x*).
  prefs: []
  type: TYPE_NORMAL
- en: '*Characterizing Optimal Solutions*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider an optimal solution to this problem: a solution that maximizes the
    number of goals scored in rivalry games. What might this optimal solution look
    like? Assume that the games for each team are numbered from 1 to *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is that the optimal solution uses the final game *n* played by the
    Geese and the final game *n* played by the Hawks as a rivalry game. That game
    has a certain number of goals scored in it: call that *g*. We can then strip out
    both of these games and optimally solve the smaller subproblem on the Geese’s
    first *n*–1 games and the Hawks’ first *n*–1 games. That subproblem solution,
    plus *g*, is the optimal solution overall. Note, though, that this option is only
    available if the two *n* games can really be a rivalry game. For example, if both
    teams have a `W` for that game, then this cannot be a rivalry game and Option
    1 cannot apply.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember this test case from the prior section?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s an example of Option 1: we match the two rightmost scores, `8` and `3`,
    and then optimally solve the subproblem for the remaining games.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is that the optimal solution has nothing to do with these final
    games at all. In that case, we strip out game *n* played by the Geese and game
    *n* played by the Hawks, and we optimally solve the subproblem on the Geese’s
    first *n* – 1 games and the Hawks’ first *n* – 1 games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test case from the prior section that is an example of Option 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `1` and `8` at the right are not part of an optimal solution. The optimal
    solution for the other games is the optimal solution overall.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve covered the case where both game *n* scores are used and the case
    where neither game *n* score is used. Are we done?
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that we are not done, consider this test case from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Option 1, matching the `2` and `1`, leads to a maximum of three goals in rivalry
    games. Option 2, throwing away both the `2` and `1`, leads to a maximum of zero
    goals in rivalry games. However, the maximum overall here is seven. Our coverage
    of types of optimal solutions, using only Option 1 and Option 2, is therefore
    spotty.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to be able to do here is drop a game from the Geese but not from
    the Hawks. Specifically, we’d like to drop the Geese’s second game and then solve
    the subproblem consisting of the Geese’s first game and *both* of the Hawks’ games.
    For symmetry, we should also be able to drop the second Hawks game and solve the
    resulting subproblem on the first Hawks game and both Geese games. Let’s get these
    two additional options in there.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Our third option is that the optimal solution has nothing to do with the Geese’s
    game *n*. In that case, we strip out game *n* played by the Geese, and we optimally
    solve the subproblem on the Geese’s first *n* – 1 games and the Hawks’ first *n*
    games.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 4**'
  prefs: []
  type: TYPE_NORMAL
- en: Our fourth and final option is that the optimal solution has nothing to do with
    the Hawks’ game *n*. In that case, we strip out game *n* played by the Hawks,
    and we optimally solve the subproblem on the Geese’s first *n* games and the Hawks’
    first *n* – 1 games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options 3 and 4 induce a change in the structure of a solution to this problem—whether
    that solution uses recursion, memoization, or dynamic programming. In the previous
    problems of this chapter, our subproblems were characterized by only one varying
    parameter: *t* for Burger Fervor and *k* for Moneygrubbers. Without Options 3
    and 4, we’d have gotten away with a single parameter, *n*, for the Hockey Rivalry
    problem, too. That *n* parameter would have reflected the fact that we were solving
    a subproblem for the first *n* games played by the Geese and the first *n* games
    played by the Hawks. With Options 3 and 4 in the mix, however, these *n* values
    are no longer yoked: one can change when the other does not. For example, if we’re
    solving a subproblem concerning the first five games played by the Geese, this
    does not mean that we’re stuck looking at the first five games played by the Hawks.
    Symmetrically, a subproblem concerning the first five games played by the Hawks
    doesn’t tell us anything about the number of games played by the Geese.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore need two parameters for our subproblems: *i*, the number of games
    played by the Geese, and *j*, the number of games played by the Hawks.'
  prefs: []
  type: TYPE_NORMAL
- en: For a given optimization problem, the number of subproblem parameters could
    be one, two, three, or more. When confronting a new problem, I suggest beginning
    with one subproblem parameter. Then, think about the possible options for an optimal
    solution. Perhaps each option can be solved by solving one-parameter subproblems,
    in which case additional parameters are not required. However, sometimes it will
    be that one or more options require the solution to a subproblem that cannot be
    pinned down by one parameter. In these cases, a second parameter can often help.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of adding additional subproblem parameters is the larger subproblem
    space in which to couch our optimal solutions. The cost is the responsibility
    of solving more subproblems. Keeping the number of parameters small—one, two,
    or perhaps three—is key for designing fast solutions to optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, I want to highlight an important difference between the way
    that we solved Burger Fervor and Moneygrubbers and the way that we’re solving
    Hockey Rivalry. In the two earlier problems, we focused on solving for exactly
    *t* minutes or exactly *k* apples. Here, by contrast, we’re not forcing our subproblems
    to use any specific game. For example, a subproblem involving the first *i* games
    played by the Geese isn’t forced to use Geese game *i*. The difference arose as
    a byproduct of our analysis of the structure of optimal solutions. Each time we
    use dynamic programming, we need to choose whether to use “exactly.” If we had
    chosen to use “exactly” for Hockey Rivalry, then we would have ended up with comparably
    slower and more complicated code. I’ve included that code in the online resources
    for this book—check it out once you’re done here!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re struggling to relate a problem to smaller subproblems, or struggling
    to solve subproblems efficiently, it’s worth adding or removing “exactly” and
    trying again. We’ll continue to practice identifying subproblems in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s now time for our recursive solution. Here’s the signature for the `solve`
    function that we’ll write this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four parameters come directly from the current test case, while the
    fifth and sixth are the subproblem parameters. Here are brief descriptions of
    the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: outcome1   The array of `W` and `L` characters for the Geese
  prefs: []
  type: TYPE_NORMAL
- en: outcome2   The array of `W` and `L` characters for the Hawks
  prefs: []
  type: TYPE_NORMAL
- en: goals1   The array of goals scored for the Geese
  prefs: []
  type: TYPE_NORMAL
- en: goals2   The array of goals scored for the Hawks
  prefs: []
  type: TYPE_NORMAL
- en: i   The number of Geese games that we’re considering in this subproblem
  prefs: []
  type: TYPE_NORMAL
- en: j   The number of Hawks games that we’re considering in this subproblem
  prefs: []
  type: TYPE_NORMAL
- en: The last two parameters—the ones specific to the current subproblem—are the
    only parameters that change on recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: If we started each of the arrays at index `0`, as is standard for C arrays,
    then we’d have to keep in our minds that information for some game `k` was not
    at index `k` but at index `k - 1`. For example, information about game four would
    be at index `3`. To avoid this, we’ll store information about games starting at
    index `1`, so information about game four will be at index `4`. This leaves us
    with one less mistake to make! In addition, it frees up the value `0` to characterize
    zero games played.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the recursive solution is given in [Listing 3-16](ch03.xhtml#ch03ex016).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-16: Solution 1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a maximization problem: we want to maximize the number of goals scored
    in rivalry games. We start with a `max` function ❶—we’ll use that when we need
    to determine which of the options is best. We then declare four integer variables,
    one for each of the four options ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with base cases: What do we return if both `i` and `j` are `0`?
    This subproblem is for the first zero Geese games and zero Hawks games. Since
    there are no games, there are certainly no rivalry games, and since there are
    no rivalry games, there are no goals scored in rivalry games. We should therefore
    return `0` here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That isn’t the only base case, though. For example, consider the subproblem
    where the Geese play zero games (`i = 0`) and the Hawks play three games (`j =
    3`). As with the case in the prior paragraph, there can’t be any rivalry games
    here, because the Geese don’t have any games! A similar situation arises when
    the Hawks play zero games: even if the Geese play some games, none of them can
    be against the Hawks.'
  prefs: []
  type: TYPE_NORMAL
- en: That captures all of the base cases. That is to say, if `i` has value `0` *or*
    `j` has value `0`, then we have zero goals scored in rivalry games ➌.
  prefs: []
  type: TYPE_NORMAL
- en: With the base cases out of the way, we must now try the four possible options
    for an optimal solution and choose the best one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that this option is valid only when the final Geese game and final Hawks
    game can be a rivalry game. There are two ways for this game to be a rivalry game:'
  prefs: []
  type: TYPE_NORMAL
- en: The Geese win, the Hawks lose, and the Geese score more goals than the Hawks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Geese lose, the Hawks win, and the Geese score fewer goals than the Hawks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We encode these two possibilities ➍. If the game can be a rivalry game, we
    compute the optimal solution for this option ➎: it consists of the optimal solution
    for the first `i - 1` Geese games and `j - 1` Hawks games plus the total goals
    scored in the rivalry game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  prefs: []
  type: TYPE_NORMAL
- en: For this one, we solve the subproblem for the first `i - 1` Geese games and
    `j - 1` Hawks games ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we solve the subproblem for the first `i - 1` Geese games and `j` Hawks
    games ❼. Notice that `i` changes but `j` does not. This is exactly why we need
    two subproblem parameters here, not one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 4**'
  prefs: []
  type: TYPE_NORMAL
- en: We solve the subproblem for the first `i` Geese games and `j - 1` Hawks games
    ❽. Again, one subproblem parameter changes but the other does not; it’s a good
    thing there’s no need for us to keep them at the same value!
  prefs: []
  type: TYPE_NORMAL
- en: 'There we go: `first`, `second`, `third`, and `fourth`—those are the only four
    possibilities for our optimal solution. We want the maximum of these, and that
    is what we compute and return ❾. The innermost `max` call calculates the maximum
    of `third` and `fourth`. Working outward, the next `max` call calculates the maximum
    of that winner and `second`. Finally, the outermost call calculates the maximum
    of that winner and `first`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re just about there. All we need now is a `main` function that reads the
    five lines of input and calls `solve`. The code is given in [Listing 3-17](ch03.xhtml#ch03ex017).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-17: The main function*'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the outcome (`W` and `L`) ❶ and goals-scored arrays ➋. The `+ 1`
    there is because of our choice to begin indexing at `1`. If we had used just `SIZE`,
    then valid indices would go from zero to 999, when what we need is to include
    index 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: We then read the integer on the first line ➌, which gives the number of games
    played by the Geese and Hawks. There’s a space right after the `%d` and before
    the closing quote. That space causes `scanf` to read whitespace following the
    integer. Crucially, this reads the newline character at the end of the line, which
    otherwise would be included when we use `scanf` to read individual characters
    . . . which we do next!
  prefs: []
  type: TYPE_NORMAL
- en: We read the `W` and `L` information for the Geese and then read the goals-scored
    information for the Geese. We then do the same for the Hawks. Finally, we call
    `solve`. We want to solve the problem considering all *n* Geese games and all
    *n* Hawks games, which explains why the last two arguments are `n`. We know exactly
    how to call `solve` to get our answer in one shot; unlike for our solutions to
    Burger Fervor and Moneygrubbers, we don’t need to search for it.
  prefs: []
  type: TYPE_NORMAL
- en: Any chance you’ll submit this solution to the judge? The “Time-Limit Exceeded”
    error should come as no surprise.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Memoization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Burger Fervor and Moneygrubbers, we used a one-dimensional array for the
    memo. That’s because our subproblems had but one parameter: the number of minutes
    and number of apples, respectively. In contrast, the subproblems in Hockey Rivalry
    have two parameters, not one. We’ll correspondingly need a memo array with two
    dimensions, not one. Element `memo[i][j]` is used to hold the solution to the
    subproblem on the first `i` Geese games and the first `j` Hawks games. Other than
    switching from one to two dimensions in the memo, the technique remains as before:
    return the solution if it’s already stored; calculate and store it if it’s not.'
  prefs: []
  type: TYPE_NORMAL
- en: The updated `main` function is given in [Listing 3-18](ch03.xhtml#ch03ex018).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-18: The main function, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `memo` array is huge—over 1,000 elements in each dimension and
    therefore over 1 million elements in all—so we make the array static as in [Listing
    1-8](ch01.xhtml#ch01ex08).
  prefs: []
  type: TYPE_NORMAL
- en: The memoized `solve` function is given in [Listing 3-19](ch03.xhtml#ch03ex019).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-19: Solution 2, with memoization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: This solution passes all test cases and does so quickly. If we just wanted to
    solve this problem, we would stop right now, but here we have the opportunity
    to plumb further and learn more about dynamic programming as we do so.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 3: Dynamic Programming*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We just saw that to memoize this problem we needed a two-dimensional `memo`
    array, not a one-dimensional array. To develop a dynamic-programming solution,
    we’ll correspondingly need a two-dimensional `dp` array. We declared the `memo`
    array as follows in [Listing 3-18](ch03.xhtml#ch03ex018):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'and we’ll do likewise for the `dp` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As in the `memo` array, element `dp[i][j]` will hold the subproblem solution
    for the first `i` Geese games and first `j` Hawks games. Our task, then, is to
    solve each of these subproblems and return `dp[n][n]` once we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: In memoized solutions to optimization problems, it’s not our responsibility
    to determine an order in which to solve the subproblems. We make our recursive
    calls, and those calls return to us the solutions for their corresponding subproblems.
    In dynamic-programming solutions, however, it *is* our responsibility to determine
    an order in which to solve the subproblems. We can’t just solve them in any order
    we want, because then a subproblem solution might not be available when we need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we wanted to fill in `dp[3][5]`—that’s the cell for the
    first three Geese games and the first five Hawks games. Take another look back
    at the four options for an optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 requires us to look up `dp[2][4]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 2 also requires us to look up `dp[2][4]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 3 requires us to look up `dp[2][5]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 4 requires us to look up `dp[3][4]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must arrange it so that these elements of `dp` are already stored by the
    time we want to store `dp[3][5]`.
  prefs: []
  type: TYPE_NORMAL
- en: For subproblems with only one parameter, you generally solve those subproblems
    from smallest index to largest index. For subproblems with more than one parameter,
    things are not so simple, as there are many more orders in which the array can
    be filled. Only some of these orders maintain the property that a subproblem solution
    is available by the time we need it.
  prefs: []
  type: TYPE_NORMAL
- en: For the Hockey Rivalry problem, we can solve `dp[i][j]` if we’ve already stored
    `dp[i - 1][j - 1]` (Option 1 and Option 2), `dp[i - 1][j]` (Option 3), and `dp[i][j
    - 1]` (Option 4). One order we can use is to solve all of the `dp[i - 1]` subproblems
    before solving any of the `dp[i]` subproblems. For example, this would result
    in `dp[2][4]` being solved before `dp[3][5]`, which is exactly what we need to
    satisfy Options 1 and 2\. It would also result in `dp[2][5]` being solved before
    `dp[3][5]`, which is what we need for Option 3\. That is, solving row `i - 1`
    before row `i` satisfies Options 1 to 3.
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy Option 4, we can solve the `dp[i]` subproblems from smallest `j`
    index to largest `j` index. That, for example, would solve `dp[3][4]` before `dp[3][5]`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we solve all of the subproblems in row `0` from left to right, then
    all of the subproblems in row `1` from left to right, and so on, until we have
    solved all subproblems in row `n`.
  prefs: []
  type: TYPE_NORMAL
- en: The `solve` function is given in [Listing 3-20](ch03.xhtml#ch03ex020).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-20: Solution 3, with dynamic programming*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by initializing the base case subproblems, which are those in which
    at least one of the indices is `0`. Then, we hit the double `for` loop ❶ ➋, which
    controls the order in which the non-base-case subproblems are solved. We first
    range over the rows ❶ and then the elements in each row ➋, which, as we have argued,
    is a valid order for solving the subproblems. Once we have filled in the table,
    we return the solution for the original problem ➌.
  prefs: []
  type: TYPE_NORMAL
- en: We’re solving *n*² subproblems here, each of which takes us a constant number
    of steps. Therefore, we’ve achieved an *O*(*n*²) solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the array produced by a two-dimensional dynamic-programming
    algorithm as a table. This is helpful for getting a feel for how the elements
    of the array are filled in. Let’s look at the final array for the following test
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the resulting array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider, for example, the computation for the element in row `4`, column `2`
    or, in terms of the `dp` table, `dp[4][2]`. This is the subproblem for the first
    four Geese games and first two Hawks games. Looking at the Geese’s game four and
    the Hawks’ game two, we see that the Geese won with eight goals and the Hawks
    lost with one goal, so this game could be a rivalry game. Option 1 is therefore
    a possible option. Nine goals were scored in this game. To that nine, we add the
    value at row `3`, column `1`, which is nine again. This gives us a total of 18\.
    That’s our maximum so far—now we have to try Options 2 to 4 to see whether they
    are better. If you do that, you should observe that they all happen to have the
    value nine. We therefore store 18, the maximum of all available options, in `dp[4][2]`.
  prefs: []
  type: TYPE_NORMAL
- en: The only quantity of real interest here, of course, is that in the topmost,
    rightmost cell, corresponding to the subproblem allowing the full `n` games for
    the Geese and `n` games for the Hawks. That value, 20, is what we return as the
    optimal solution. The other quantities in the table are only useful insofar as
    they help us make progress toward calculating that 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the `main` function, we make one small change to the code of [Listing
    3-17](ch03.xhtml#ch03ex017): the only thing to do is remove the second `n` passed
    to `solve`, resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*A Space Optimization*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I mentioned in “Step 4: Dynamic Programming” on [page 97](#sec44) that memoization
    and dynamic programming are roughly equivalent. *Roughly*, because sometimes there
    are benefits to be had by choosing one or the other. The Hockey Rivalry problem
    furnishes an example of a typical optimization that we can perform when using
    dynamic programming but not when using memoization. The optimization is not one
    of speed but of space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the key question: When solving a subproblem in row `i` of the `dp` array,
    which rows do we access? Look back at the four options. The only rows used are
    `i - 1` (the previous row) and `i` (the current row). There’s no `i - 2` or `i
    - 3` or anything else in there. As such, keeping the entire two-dimensional array
    in memory is wasteful. Suppose we’re solving subproblems in row 500\. All we need
    is access to row 500 and row 499\. We might as well not have row 498 or 497 or
    496 or any other row in memory, because we’ll never look at these again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than a two-dimensional table, we can pull through with only two one-dimensional
    arrays: one for the previous row and one for the current row we are solving.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-21](ch03.xhtml#ch03ex021) implements this optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-21: Solution 3, with space optimization implemented*'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize `previous` to all zeros ❶ ➋, thereby solving all subproblems in
    row `0`. In the rest of the code, whenever we previously referred to row `i -
    1`, we now use `previous`. In addition, whenever we previously referred to row
    `i`, we now use `current`. Once a new row has been fully solved and stored in
    `current`, we copy `current` into `previous` ➌ ➍ so that `current` can be used
    to solve the next row.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve presented what I think of as the core of memoization and dynamic programming:
    explicating the structure of an optimal solution, developing a recursive algorithm,
    speeding it up through memoization, and optionally replacing the recursion by
    filling a table.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to learn, though. What if I showed you how to crack some nasty
    dynamic-programming problems merely through a change in perspective? What if I
    told you that we can work with three or more dimensions to solve the toughest
    dynamic-programming problems?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn all that and more. See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hockey Rivalry is originally from the 2018 Canadian Computing Olympiad.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you need to know not only the value of an optimal solution, but
    the decisions that you should make to achieve that solution. Check out “Burger
    Fervor: Reconstructing a Solution” in [Appendix B](app02.xhtml) for an example
    of how to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: Many algorithm textbooks delve deeper into the theory and application of memoization
    and dynamic programming. My favorite treatment is *Algorithm Design* by Jon Kleinberg
    and Éva Tardos (2006).
  prefs: []
  type: TYPE_NORMAL
