- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: MEMOIZATION AND DYNAMIC PROGRAMMING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录化和动态规划
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: 'In this chapter, we’ll study three problems that appear to be solvable using
    recursion. As you’ll see, while in theory we can use recursion, in practice it
    leads to an explosion of work that renders the problems unsolvable. Not to worry:
    you’ll learn two powerful, related techniques, called memoization and dynamic
    programming, that will lead to shocking performance increases, morphing runtimes
    from hours or days to seconds. In the next chapter, we’ll level up and solve two
    even more challenging problems using these techniques. Once you get the hang of
    this stuff, you’ll be able to solve hundreds of other programming problems as
    well. If you’re going to read one chapter in this book, read this one.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将研究三个看似可以通过递归解决的问题。正如你所看到的，虽然理论上我们可以使用递归，但在实践中它会导致工作量的爆炸，使得问题变得不可解。别担心：你将学到两种强大的相关技巧，叫做备忘录化和动态规划，它们将带来惊人的性能提升，把运行时间从小时或天缩短到秒。在下一章中，我们将提升难度，使用这些技巧解决两个更具挑战性的问题。一旦你掌握了这些技巧，你将能够解决数百个其他编程问题。如果你要读本书的一章，那就读这一章。
- en: 'Problem 1: Burger Fervor'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：汉堡狂热
- en: This is UVa problem `10465`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UVa问题`10465`。
- en: '*The Problem*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: A man named Homer Simpson likes to eat and drink. He has *t* minutes that he’ll
    spend eating burgers and drinking beer. There are two kinds of burgers. One of
    them takes *m* minutes to eat, and the other takes *n* minutes to eat.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一位名叫霍默·辛普森的人喜欢吃喝。他有*t*分钟来吃汉堡和喝啤酒。有两种汉堡。一个汉堡需要*m*分钟吃完，另一个汉堡需要*n*分钟吃完。
- en: Homer likes burgers more than beer, so he’d like to spend the entire *t* minutes
    eating burgers. However, doing so isn’t always possible. For example, if *m* =
    4, *n* = 9, and *t* = 15, then no combination of the 4-minute and 9-minute burgers
    can take him exactly 15 minutes to eat. In such a case, he’ll spend as much time
    as possible eating burgers and then fill the rest of the time drinking beer. Our
    task is to determine the number of burgers that Homer can eat.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 霍默喜欢汉堡比啤酒更多，所以他想花整个*t*分钟吃汉堡。然而，这并不总是可能的。例如，如果 *m* = 4，*n* = 9，*t* = 15，那么无论如何组合4分钟和9分钟的汉堡，他都不能刚好花15分钟吃完汉堡。在这种情况下，他会尽可能多地吃汉堡，然后把剩下的时间用来喝啤酒。我们的任务是确定霍默能吃多少个汉堡。
- en: Input
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'We read test cases until there is no more input. Each test case is represented
    by a line of three integers: *m*, the number of minutes it takes to eat the first
    kind of burger; *n*, the number of minutes it takes to eat the second kind of
    burger; and *t*, the number of minutes that Homer will spend eating burgers and
    drinking beer. Each *m*, *n*, and *t* value is less than 10,000.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续读取测试用例，直到没有更多输入。每个测试用例由一行三个整数表示：*m*，吃第一种汉堡所需的分钟数；*n*，吃第二种汉堡所需的分钟数；*t*，霍默将花费的分钟数来吃汉堡和喝啤酒。每个*m*，*n*，和*t*值都小于10,000。
- en: Output
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'For each test case:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例：
- en: If Homer can spend exactly *t* minutes eating burgers, then output the maximum
    number of burgers that he can eat.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果霍默可以刚好花*t*分钟吃汉堡，那么输出他可以吃到的最多汉堡数。
- en: Otherwise, output the maximum number of burgers that Homer can eat when maximizing
    his time eating burgers, a space, and the number of remaining minutes (during
    which he’ll drink beer).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，输出霍默在尽量多吃汉堡的情况下能吃到的最多汉堡数，并输出空间和剩余的分钟数（在这段时间里，他会喝啤酒）。
- en: The time limit for solving the test cases is three seconds.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为三秒。
- en: '*Forming a Plan*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*制定计划*'
- en: 'Let’s start by thinking about a few different test cases. Here’s the first
    one:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑几个不同的测试用例开始。这里是第一个：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the first kind of burger takes 4 minutes to eat (*m* = 4), the second
    kind of burger takes 9 minutes to eat (*n* = 9), and Homer has 22 minutes to spend
    (*t* = 22). This is an example in which Homer can fill the entire time by eating
    burgers. The maximum number of burgers that Homer can eat here is three, so `3`
    is the correct output for this test case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一种汉堡需要4分钟吃完（*m* = 4），第二种汉堡需要9分钟吃完（*n* = 9），霍默有22分钟可以花费（*t* = 22）。这是一个霍默可以通过吃汉堡填满全部时间的例子。霍默能吃到的最多汉堡数是三个，因此`3`是这个测试用例的正确输出。
- en: The three burgers that Homer should eat are one 4-minute burger and two 9-minute
    burgers. This takes him 1 × 4 + 2 × 9 = 22 minutes, as required. Notice, though,
    that we are *not* being asked to indicate the number of each kind of burger he
    should eat. All we’re asked to do is output the total number of burgers. When
    I provide the number of each kind of burger below, I do so only to offer evidence
    that the proposed output makes sense.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 荷马应该吃的三种汉堡是一个4分钟的汉堡和两个9分钟的汉堡。这样他需要花费 1 × 4 + 2 × 9 = 22分钟，正好符合要求。不过请注意，我们*并没有*被要求标明每种汉堡的数量。我们唯一被要求的是输出汉堡的总数量。当我在下面提供每种汉堡的数量时，我这样做只是为了提供证据，证明所提的输出是合理的。
- en: 'Here’s another test case:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个测试用例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Again, Homer can fill the entire time with burgers. The correct output here
    is `11`, obtained by eating nine 4-minute burgers and two 9-minute burgers. Unlike
    the `4 9 22` test case, here Homer has multiple ways to spend exactly 54 minutes
    eating burgers. For example, he could eat six 9-minute burgers—that fills up the
    54 minutes, too—but, remember, if we can fill the entire `t` minutes, then we
    want to output the *maximum* number of burgers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，荷马可以通过吃汉堡填满整个时间。这里的正确输出是 `11`，通过吃九个4分钟的汉堡和两个9分钟的汉堡得到的。与 `4 9 22` 测试用例不同，在这里荷马有多种方法可以用汉堡恰好填满54分钟。例如，他可以吃六个9分钟的汉堡——这也能填满54分钟——但请记住，如果我们能够填满整个
    `t` 分钟，那么我们需要输出 *最大* 的汉堡数量。
- en: 'As noted in the problem description, it’s not always possible for Homer to
    completely fill the *t* minutes by eating burgers. Let’s study the example that
    I gave there as our next test case:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如问题描述中所提到的，荷马并不总能完全用吃汉堡的方式填满 *t* 分钟。让我们以我在问题描述中给出的例子作为下一个测试用例来研究：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How many burgers should Homer eat here? He can eat a maximum of three burgers
    by eating three 4-minute burgers. By doing so, Homer would spend 12 minutes eating
    burgers, and he would have to spend the remaining 15 – 12 = 3 minutes drinking
    beer. So, he eats three burgers and has three minutes’ beer-drinking time, making
    the output `3 3`. Have we solved this test case?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 荷马应该吃多少个汉堡呢？他最多可以通过吃三个4分钟的汉堡来吃完三个汉堡。这样一来，荷马将花费12分钟吃汉堡，剩下的15 – 12 = 3分钟用来喝啤酒。所以他吃了三个汉堡，并且有3分钟的喝啤酒时间，输出为
    `3 3`。我们是否解决了这个测试用例？
- en: 'We have not! Carefully reread the problem description and zone in on this:
    “output the maximum number of burgers that Homer can eat when maximizing his time
    eating burgers.” That is, when Homer cannot fill the entire time by eating burgers,
    we want to maximize the *time* that he spends eating burgers and then the maximum
    number of burgers he can eat in that time. The correct output for `4 9 15` is
    in fact `2 2`: the first `2` means that he eats two burgers (one 4-minute burger
    and one 9-minute burger, for a total of 13 minutes) and the second `2` means that
    he has to spend 2 minutes (15 – 13) drinking beer.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解决！仔细重新阅读问题描述并专注于这一点：“输出荷马能吃到的最大数量的汉堡，以最大化他吃汉堡的时间。”也就是说，当荷马无法用吃汉堡的方式填满整个时间时，我们希望最大化他吃汉堡的
    *时间*，然后输出他能在这段时间内吃到的最大数量的汉堡。对于 `4 9 15`，正确的输出实际上是 `2 2`：第一个 `2` 表示他吃了两个汉堡（一个4分钟的汉堡和一个9分钟的汉堡，共花费13分钟），第二个
    `2` 表示他需要花2分钟（15 – 13）喝啤酒。
- en: In the `4 9 22` and `4 9 54` test cases, we’re asked to solve the problem for
    22 and 54 minutes, respectively. We found that there is indeed a way to spend
    the entire time eating burgers, so we can report the maximum number of burgers
    as our solution. However, in the `4 9 15` case, we found that there is no way
    to completely fill the 15 minutes by eating burgers. Thinking ahead to our code,
    how are we going to handle this? How will we be able to conclude that the answer
    is `2 2`?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `4 9 22` 和 `4 9 54` 测试用例中，我们被要求分别解决22分钟和54分钟的情况。我们发现确实有一种方法可以用汉堡填满整个时间，所以我们可以报告最大数量的汉堡作为我们的解决方案。然而，在
    `4 9 15` 的情况下，我们发现没有办法完全用吃汉堡的方式填满15分钟。想到我们的代码时，我们该如何处理呢？我们怎样才能得出答案是 `2 2` 呢？
- en: 'One idea is that we can next try to fill exactly 14 minutes with the 4-minute
    and 9-minute burgers. If we succeed, then we have our answer: we report the maximum
    number of burgers that Homer can eat in exactly 14 minutes, followed by 1, the
    number of minutes Homer spends drinking beer. This would maximize the amount of
    time that Homer can spend eating burgers. We already know that eating burgers
    for exactly 15 minutes is impossible, so 14 minutes is the next best option.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思路是，我们可以接下来尝试用4分钟和9分钟的汉堡准确填满14分钟。如果成功，那么我们就得到了答案：我们报告霍默在准确14分钟内能吃的最大汉堡数量，然后是1，霍默花在喝啤酒上的分钟数。这将最大化霍默吃汉堡的时间。我们已经知道吃汉堡15分钟是不可能的，所以14分钟是下一个最佳选择。
- en: Let’s see if 14 minutes works. Can we fill exactly 14 minutes with the 4-minute
    and 9-minute burgers? No! Like the 15-minute case, this will be impossible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看14分钟能否成功。我们能用4分钟和9分钟的汉堡准确填满14分钟吗？不能！就像15分钟的情况一样，这也是不可能的。
- en: 'We can, though, fill exactly 13 minutes by eating two burgers: one 4-minute
    burger and one 9-minute burger. That leaves Homer two minutes for drinking beer.
    This justifies `2 2` as the correct output.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以通过吃两个汉堡来准确填满13分钟：一个4分钟汉堡和一个9分钟汉堡。这就给霍默留了2分钟喝啤酒。这就证明了`2 2`是正确的输出。
- en: 'In summary, our plan is to determine whether Homer can eat burgers for exactly
    *t* minutes. If he can, then we’re done: we report the maximum number of burgers
    he can eat. If he can’t, then we next determine whether Homer can eat burgers
    for exactly *t* – 1 minutes. If he can, then we’re done, and we report the maximum
    number of burgers he can eat and the number of minutes spent drinking beer. If
    he can’t, then we will move on to trying *t* – 2 minutes, then *t* – 3 minutes,
    and so on, stopping when the time can be completely filled by eating burgers.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的计划是确定霍默是否能在准确的*t*分钟内吃汉堡。如果可以，那么任务完成：我们报告霍默能够吃的最大汉堡数量。如果不行，那么接下来我们要确定霍默是否能在准确的*t*
    – 1分钟内吃汉堡。如果可以，那么任务完成，我们报告霍默能吃的最大汉堡数量以及他花在喝啤酒上的时间。如果不行，那么我们将继续尝试*t* – 2分钟，再尝试*t*
    – 3分钟，依此类推，直到找到可以完全用吃汉堡填满的时间。
- en: '*Characterizing Optimal Solutions*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*优化问题的表征*'
- en: Consider the `4 9 22` test case. Whatever combination of burgers and beer we
    propose as the solution better take exactly 22 minutes, and it better actually
    be doable using the 4-minute and 9-minute burgers. Such a solution, which adheres
    to the rules of a problem, is called a *feasible* solution. A solution attempt
    that does not follow the rules is called an *infeasible* solution. For example,
    having Homer spend 4 minutes eating burgers and 18 minutes drinking beer is feasible.
    Having Homer spend 8 minutes eating burgers and 18 minutes drinking beer is infeasible,
    because 8 + 18 is not 22\. Having Homer spend 5 minutes eating burgers and 17
    minutes drinking beer is also infeasible, because there’s no way we can use the
    4-minute and 9-minute burgers to get a total of 5 minutes of burger time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以`4 9 22`测试案例为例。无论我们提出哪种汉堡和啤酒的组合，解决方案都必须正好用22分钟完成，而且必须能用4分钟和9分钟的汉堡来实现。符合问题规则的解决方案被称为*可行*解决方案。不符合规则的解决方案称为*不可行*解决方案。例如，让霍默花4分钟吃汉堡，18分钟喝啤酒是可行的。让霍默花8分钟吃汉堡，18分钟喝啤酒则是不可行的，因为8
    + 18并不等于22。让霍默花5分钟吃汉堡，17分钟喝啤酒也是不可行的，因为我们无法用4分钟和9分钟的汉堡来凑满5分钟的汉堡时间。
- en: Burger Fervor is an *optimization problem*. An optimization problem involves
    choosing the best—that is, *optimal*—solution out of all feasible solutions. There
    may be many feasible solutions of varying quality. Some will be really poor, such
    as drinking beer for 22 minutes. Others will be close to but not quite optimal—maybe
    they’re off by one or two. And, of course, some of them will be optimal. Our goal
    is to identify an optimal solution among all possible solutions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 汉堡热潮是一个*优化问题*。优化问题涉及从所有可行解中选择最好的——也就是*最优*的解决方案。可能会有许多可行解，质量各异。有些会很差，比如花22分钟喝啤酒。其他解可能接近但不是完全最优——可能相差一两分钟。当然，也会有一些是最优解。我们的目标是从所有可能的解中识别出最优解。
- en: Suppose we’re solving a case where the first kind of burger takes *m* minutes
    to eat, the second kind of burger takes *n* minutes to eat, and we want to try
    to spend *exactly t* minutes eating burgers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在解决一个案例，其中第一种汉堡需要*m*分钟吃，第二种汉堡需要*n*分钟吃，而我们希望尝试花*exactly t*分钟吃汉堡。
- en: If *t* = 0, then the correct output is `0`, because we can fill the entire 0
    minutes by eating zero burgers. As we continue, we’ll therefore focus on what
    to do when *t* is greater than 0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*t* = 0，那么正确的输出是`0`，因为我们可以通过吃零个汉堡填满整个0分钟。接下来，我们将重点讨论*t*大于0时该怎么做。
- en: Let’s think about what an optimal solution for *t* minutes must look like. Of
    course, we can’t possibly know anything specific, such as “Homer eats a 4-minute
    burger, then a 9-minute burger, then another 9-minute burger, then . . . ” We
    haven’t done anything yet to solve the problem, so obtaining this level of detail
    is wishful thinking.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下，最优解在*t*分钟内应该是什么样子的。当然，我们不可能知道任何具体的内容，比如“霍默先吃一个4分钟的汉堡，然后是一个9分钟的汉堡，再来一个9分钟的汉堡，接下来……”我们还没有做出任何解决方案，所以得到这种具体的细节只是痴心妄想。
- en: There is, however, something we can say that’s not wishful thinking. It’s at
    once so inane that you’d be forgiven for wondering why I am stating it at all
    and so powerful that at its core lies a solution strategy for a bewildering number
    of optimization problems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一件事我们可以说，并非痴心妄想。它既简单到你可能会疑惑我为何要提及，又强大到它的核心包含了无数优化问题的解决策略。
- en: 'Here it is: Suppose that Homer can fill exactly *t* minutes by eating burgers.
    (If this supposition ends up being wrong, then we’ll try it again with *t* – 1
    minutes, then *t* – 2 minutes, and so on.) The final burger that he eats, the
    one that finishes off his *t* minutes, must be an *m*-minute burger or an *n*-minute
    burger.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 事实如下：假设霍默可以通过吃汉堡来正好填满*t*分钟。（如果这个假设不成立，那么我们可以再尝试用*t* – 1分钟、*t* – 2分钟，依此类推。）他吃的最后一个汉堡，完成了他的*t*分钟，必须是一个*m*分钟的汉堡或一个*n*分钟的汉堡。
- en: How could that final burger be anything else? Homer can only eat *m*-minute
    and *n*-minute burgers, so there are only two choices for the last burger that
    he eats and so two choices for what the end of the optimal solution must look
    like.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，最后一个汉堡怎么可能是别的呢？霍默只能吃*m*分钟和*n*分钟的汉堡，因此他吃的最后一个汉堡只有两种选择，最优解的结尾也只有两种可能。
- en: 'If we know that the final burger that Homer eats in an optimal solution is
    an *m*-minute burger, we know he has *t* – *m* minutes left to spend. There must
    be a way to fill those *t* – *m* minutes with burgers, without drinking any beer:
    remember that we are assuming that Homer can spend the entire *t* minutes by eating
    burgers. If we could spend those *t* – *m* minutes optimally, with Homer eating
    the maximum number of burgers, then we’d have an optimal solution to the original
    problem of *t* minutes. We’d take the number of burgers that he can eat in *t*
    – *m* minutes and add one *m*-minute burger to fill the remaining *m* minutes.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道霍默在一个最优解中吃的最后一个汉堡是一个*m*分钟的汉堡，那么我们就知道他还剩下*t* – *m*分钟可以花费。必须有一种方法来用汉堡填充这*t*
    – *m*分钟，而不喝啤酒：记住，我们假设霍默可以用吃汉堡来度过整个*t*分钟。如果我们能以最优方式度过这*t* – *m*分钟，让霍默吃到最多的汉堡，那么我们就得到了原始问题*t*分钟的最优解。我们会计算他在*t*
    – *m*分钟内能吃多少个汉堡，然后加上一个*m*分钟的汉堡来填补剩余的*m*分钟。
- en: Now, what if we knew that the final burger that Homer eats in an optimal solution
    is an *n*-minute burger? Then he has *t* – *n* minutes left to spend. Again, by
    virtue of the entire *t* minutes being spent eating burgers, we know that it must
    be possible for Homer to eat burgers for the first *t* – *n* of those minutes.
    If we could spend those *t* – *n* minutes optimally, then we’d have an optimal
    solution to the original problem of *t* minutes. We’d take the number of burgers
    that he can eat in *t* – *n* minutes and add one *n*-minute burger to fill the
    remaining *n* minutes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们知道霍默在最优解中吃的最后一个汉堡是一个*n*分钟的汉堡？那么他还有*t* – *n*分钟可以花费。同样，由于整个*t*分钟都花在吃汉堡上，我们知道霍默在前*t*
    – *n*分钟内一定能吃汉堡。如果我们能以最优方式度过这*t* – *n*分钟，那么我们就得到了原始问题*t*分钟的最优解。我们会计算他在*t* – *n*分钟内能吃多少个汉堡，然后加上一个*n*分钟的汉堡来填补剩余的*n*分钟。
- en: Now we seem to be squarely in farce territory. We just assumed that we knew
    what the final burger was! However, there’s no way we could know this. We do know
    that the final burger is an *m*-minute burger *or* an *n*-minute burger. We definitely
    don’t know which it is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们似乎完全进入了荒诞的领域。我们刚才假设知道了最后一个汉堡是什么！然而，我们怎么可能知道这个呢？我们确实知道最后一个汉堡是一个*m*分钟的汉堡*或者*一个*n*分钟的汉堡。我们肯定不知道它是哪一个。
- en: The wonderful truth is that we don’t need to know. We can assume the final burger
    is an *m*-minute burger and solve the problem optimally given that choice. We
    then make the other choice—assume that the final burger is an *n*-minute burger—and
    solve the problem optimally given that choice. In the first case, we have a subproblem
    of *t* – *m* minutes to solve optimally; in the second case, we have a subproblem
    of *t* – *n* minutes to solve optimally. Whenever we have characterized a solution
    to a problem in terms of solutions to subproblems, we would do well to try a recursive
    approach as we did in [Chapter 2](ch02.xhtml).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙的事实是，我们不需要知道确切答案。我们可以假设最后一个汉堡是一个*m*分钟的汉堡，并在这种选择下最优地解决问题。然后我们再做另一个假设——假设最后一个汉堡是一个*n*分钟的汉堡，并在这种选择下最优地解决问题。在第一种情况下，我们有一个*t*
    - *m*分钟的子问题需要最优解决；在第二种情况下，我们有一个*t* - *n*分钟的子问题需要最优解决。每当我们用子问题的解法来描述一个问题的解法时，我们就应该尝试递归方法，就像我们在[第二章](ch02.xhtml)中做的那样。
- en: '*Solution 1: Recursion*'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 1：递归*'
- en: Let’s attempt a recursive solution. We’ll begin by writing a helper function
    to solve for exactly *t* minutes. Once we’re done, we’ll rely on it to write a
    function that solves for exactly *t* minutes, *t* – 1 minutes, *t* – 2 minutes,
    and so on, until we can completely fill some number of minutes with burgers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个递归解法。我们将首先编写一个辅助函数，用来精确求解*t*分钟。完成后，我们将依赖这个函数来求解精确的*t*分钟、*t* - 1分钟、*t*
    - 2分钟，依此类推，直到我们能够完全用汉堡填满一些分钟数。
- en: '##### The Helper Function: Solving for the Number of Minutes'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 辅助函数：求解分钟数'
- en: 'To solve each problem and subproblem instance, we need three things: *m* and
    *n* from the test case and the *t* value for the current instance. We’ll therefore
    write the body of the following function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决每个问题和子问题实例，我们需要三样东西：测试用例中的*m*和*n*，以及当前实例的*t*值。因此，我们将编写以下函数的主体：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If Homer can spend exactly `t` minutes eating burgers, then we’ll return the
    maximum number of burgers he can eat. If he can’t spend exactly `t` minutes eating
    burgers—meaning he must spend at least one minute drinking beer—then we’ll return
    `-1`. A return value of `0` or more means that we’ve solved the problem using
    burgers alone; a return value of `-1` means that the problem cannot be solved
    using burgers alone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果霍默能恰好花`t`分钟吃汉堡，那么我们将返回他能够吃的最大汉堡数量。如果他无法恰好花`t`分钟吃汉堡——这意味着他至少需要花费1分钟喝啤酒——那么我们将返回`-1`。返回值为`0`或更大的数表示我们仅用汉堡就解决了问题；返回值为`-1`表示无法仅用汉堡解决问题。
- en: 'If we call `solve_t(4, 9, 22)`, we expect to get `3` as the return value: three
    is the maximum number of burgers that Homer can eat in exactly 22 minutes. If
    we call `solve_t(4, 9, 15)`, we expect to get `-1` as the return value: there’s
    no combination of 4-minute and 9-minute burgers that gives us exactly 15 minutes.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`solve_t(4, 9, 22)`，我们期望返回值为`3`：这表示霍默在恰好22分钟内能吃的最大汉堡数量是3个。如果我们调用`solve_t(4,
    9, 15)`，我们期望返回值为`-1`：没有任何4分钟和9分钟的汉堡组合能恰好给我们15分钟。
- en: 'We’ve already settled on what to do when *t* = 0: in this case, we have 0 minutes
    to spend, and we do so by having Homer eat zero burgers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了当*t* = 0时该怎么做：在这种情况下，我们没有时间，霍默吃零个汉堡：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That’s the base case of our recursion. To implement the rest of this function,
    we need the analysis from the last section. Remember that, to solve the problem
    for exactly *t* minutes, we think about the final burger that Homer eats. Maybe
    it’s an *m*-minute burger. To check that possibility, we solve the subproblem
    for exactly *t* – *m* minutes. Of course, the final burger can only be an *m*-minute
    burger if we’ve got at least *m* minutes to spend. This logic can be coded as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们递归的基准情况。为了实现这个函数的其余部分，我们需要上一节的分析。记住，要精确解决*t*分钟的问题，我们需要考虑霍默最后吃的那个汉堡。也许它是一个*m*分钟的汉堡。为了验证这个可能性，我们将求解*t*
    - *m*分钟的子问题。当然，最后的汉堡只有在我们至少有*m*分钟时间时，才可能是一个*m*分钟的汉堡。这个逻辑可以如下编程实现：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use `first` to store the optimal solution to the `t - m` subproblem, with
    `-1` indicating “no solution.” If `t >= m`, then there’s a chance that an *m*-minute
    burger is the final one, so we make a recursive call to compute the optimal number
    of burgers that Homer can eat in exactly `t - m` minutes. That recursive call
    will return a number greater than `-1` if it can be solved exactly or `-1` if
    it can’t. If `t < m`, then there’s no recursive call to make: we set `first =
    -1` to signify that an *m*-minute burger isn’t the final burger and that it can’t
    participate in an optimal solution for exactly `t` minutes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`first`来存储` t - m `子问题的最优解，`-1`表示“没有解”。如果`t >= m`，则表示有可能最后一个汉堡是*m*分钟的汉堡，因此我们进行递归调用来计算霍默在恰好`
    t - m `分钟内能够吃到的最优汉堡数量。如果可以精确解决，递归调用会返回大于`-1`的数字，如果无法解决，则返回`-1`。如果`t < m`，则不进行递归调用：我们将`first
    = -1`，表示*m*分钟的汉堡不能是最后一个汉堡，也无法在恰好`t`分钟内参与最优解。
- en: 'Now, what about when an *n*-minute burger is the final burger? The code for
    this case is analogous to the *m*-minute burger case, this time storing the result
    in the variable `second` instead of `first`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，假设最后一个汉堡是*n*分钟的情况呢？这个情况的代码类似于*m*分钟汉堡的情况，只不过这次将结果存储在变量`second`中，而不是`first`：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s summarize our current progress:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下当前的进展：
- en: The variable `first` is the solution to the `t - m` subproblem. If it’s `-1`,
    then we can’t completely fill `t - m` minutes with burgers. If it’s anything else,
    then it gives the optimal number of burgers that Homer can eat in exactly `t -
    m` minutes.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`first`是` t - m `子问题的解。如果它是`-1`，那么我们无法用汉堡完全填满` t - m `分钟。如果是其他值，它则表示霍默可以在恰好`
    t - m `分钟内吃的最优汉堡数量。
- en: The variable `second` is the solution to the `t - n` subproblem. If it’s `-1`,
    then we can’t completely fill `t - n` minutes with burgers. If it’s anything else,
    then it gives the optimal number of burgers that Homer can eat in exactly `t -
    n` minutes.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`second`是` t - n `子问题的解。如果它是`-1`，那么我们无法用汉堡完全填满` t - n `分钟。如果是其他值，它则表示霍默可以在恰好`
    t - n `分钟内吃的最优汉堡数量。
- en: 'There’s a chance that both `first` and `second` have values of `-1`. A value
    of `-1` for `first` means that an *m*-minute burger can’t be the final burger.
    A value of `-1` for `second` means that an *n*-minute burger can’t be the final
    burger. If the final burger can’t be an *m*-minute burger and can’t be an *n*-minute
    burger, then we’re out of options and have to conclude that there’s no way to
    solve the problem for exactly `t` minutes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能`first`和`second`都为`-1`。如果`first`为`-1`，则意味着*m*分钟的汉堡不能是最后一个汉堡。如果`second`为`-1`，则意味着*n*分钟的汉堡不能是最后一个汉堡。如果最后一个汉堡既不能是*m*分钟的汉堡，也不能是*n*分钟的汉堡，那么我们就没有其他选项，只能得出结论，无法在恰好`t`分钟内解决这个问题：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Otherwise, if `first` or `second` or both are greater than `-1`, then we can
    build at least one solution for exactly `t` minutes. In this case, we start with
    the maximum of `first` and `second` to choose the better subproblem solution.
    If we add one to that maximum, thereby incorporating the final burger, then we
    obtain the maximum for the original problem of exactly `t` minutes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果`first`、`second`或两者都大于`-1`，那么我们至少可以构造一个解决方案来解决恰好`t`分钟的问题。在这种情况下，我们从`first`和`second`的最大值开始，选择更好的子问题解。如果我们将该最大值加一，从而包括最后一个汉堡，我们就得到了原问题在恰好`t`分钟的最优解：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The full function is given in [Listing 3-1](ch03.xhtml#ch03ex01).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的函数请参考[列表 3-1](ch03.xhtml#ch03ex01)。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-1: Solving for exactly t minutes*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：求解恰好 t 分钟的情况*'
- en: It’s worth spending a few minutes getting a feel for what the function does—even
    if you’re already convinced of its correctness.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间了解这个函数的作用是值得的——即使你已经确信它是正确的。
- en: Let’s begin with `solve_t(4, 9, 22)`. The recursive call for `first` ❶ solves
    the subproblem for 18 minutes (22 – 4). That recursive call returns `2`, because
    two is the maximum number of burgers that Homer can eat in exactly 18 minutes.
    The recursive call for `second` ➋ solves the subproblem for 13 minutes (22 – 9).
    That recursive call returns `2` as well, because two is the maximum number of
    burgers that Homer can eat in exactly 13 minutes. That is, both `first` and `second`
    are `2` in this case; tacking on the final four-minute or nine-minute burger gives
    a solution of `3` ➍ for the original problem of exactly 22 minutes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`solve_t(4, 9, 22)`开始。`first` ❶的递归调用求解了18分钟（22 - 4）的子问题。该递归调用返回`2`，因为Homer在恰好18分钟内能吃的最大汉堡数是2个。`second`
    ➋的递归调用求解了13分钟（22 - 9）的子问题。该递归调用也返回`2`，因为Homer在恰好13分钟内能吃的最大汉堡数也是2个。也就是说，在这种情况下，`first`和`second`的值都是`2`；再加上最后四分钟或九分钟的汉堡，原始问题（恰好22分钟）的解就是`3`
    ➍。
- en: Let’s now try `solve_t(4, 9, 20)`. The recursive call for `first` ❶ solves the
    subproblem for 16 minutes (20 – 4) and yields `4` as a result, but what about
    the recursive call for `second` ➋? Well, that one is asked to solve the subproblem
    for 11 minutes (20 – 9), but there is no way to spend exactly 11 minutes by eating
    4-minute and 9-minute burgers! Thus this second recursive call returns `-1`. The
    maximum of `first` and `second` is therefore `4` (the value of `first`), and so
    we return `5` ➍.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试`solve_t(4, 9, 20)`。`first` ❶的递归调用求解了16分钟（20 - 4）的子问题，并返回了`4`，但`second`
    ➋的递归调用又如何呢？它需要解决11分钟（20 - 9）的子问题，但无法通过吃4分钟和9分钟的汉堡恰好填满11分钟！因此，这个第二次递归调用返回`-1`。`first`和`second`中的最大值是`4`（`first`的值），因此我们返回`5`
    ➍。
- en: So far we’ve seen an example where the two recursive calls both give subproblem
    solutions with the same number of burgers and an example where only one recursive
    call gives a subproblem solution. Now let’s look at a case where each recursive
    call returns a subproblem solution, but where one is better than the other! Consider
    `solve_t(4, 9, 36)`. The recursive call for `first` ❶ yields `8`, the maximum
    number of burgers that Homer can eat in exactly 32 minutes (36 – 4). The recursive
    call for `second` ➋ yields `3`, the maximum number of burgers that Homer can eat
    in exactly 27 minutes (36 – 9). The maximum of `8` and `3` is `8`, and so we return
    `9` as the overall solution ➍.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到过一个例子，其中两个递归调用都返回相同数量的汉堡子问题解，以及一个只有一个递归调用返回子问题解的例子。现在，让我们看一个每个递归调用都返回子问题解，但其中一个比另一个更优的情况！考虑`solve_t(4,
    9, 36)`。`first` ❶的递归调用返回了`8`，这是Homer在恰好32分钟（36 - 4）内能吃的最大汉堡数。`second` ➋的递归调用返回了`3`，这是Homer在恰好27分钟（36
    - 9）内能吃的最大汉堡数。`8`和`3`中的最大值是`8`，因此我们返回`9`作为整体解 ➍。
- en: 'Finally, try `solve_t(4, 9, 15)`. The recursive call for `first` ❶ is asked
    to solve for exactly 11 minutes (15 – 4) and, since this is impossible with these
    kinds of burger, returns `-1`. The result for the `second` recursive call ➋ is
    similar: solving for exactly 6 minutes (15 – 9) is impossible, so it also returns
    `-1`. There is therefore no way to solve for exactly 15 minutes, so we return
    `-1` ➌.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试`solve_t(4, 9, 15)`。`first` ❶的递归调用要求解决恰好11分钟（15 - 4）的子问题，但由于无法用这些汉堡填满11分钟，它返回了`-1`。`second`递归调用
    ➋ 的结果类似：解决恰好6分钟（15 - 9）的子问题也是不可能的，因此它也返回了`-1`。因此，无法解决恰好15分钟的问题，所以我们返回`-1` ➌。
- en: '##### The solve and main Functions'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '##### solve 和 main 函数'
- en: Recall from “Forming a Plan” on [page 78](#sec36) that if we can fill exactly
    *t* minutes by eating burgers, then we output the maximum number of burgers. Otherwise,
    Homer has to spend at least one minute drinking beer. To figure out the number
    of minutes that he must spend drinking beer, we try to solve for exactly *t* –
    1 minutes, *t* – 2 minutes, and so on, until we find a number of minutes that
    can be filled by eating burgers. Happily, with our `solve_t` function, we can
    set the `t` parameter to whatever we want. We can start at the given value of
    `t` and then, as needed, make calls on `t - 1`, `t - 2`, and so on. We effect
    this plan in [Listing 3-2](ch03.xhtml#ch03ex02).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在“制定计划”部分提到的内容，见于[第78页](#sec36)，如果我们能够通过吃汉堡填满恰好*t*分钟，那么我们就能吃到最多的汉堡。否则，Homer就必须至少花费一分钟喝啤酒。为了计算他必须花费的喝啤酒的时间，我们尝试计算恰好*t*
    - 1分钟、*t* - 2分钟，依此类推，直到找到一个可以通过吃汉堡填满的分钟数。幸运的是，通过我们的`solve_t`函数，我们可以将`t`参数设置为任何我们想要的值。我们可以从给定的`t`值开始，然后根据需要依次调用`t
    - 1`、`t - 2`等值。我们在[示例3-2](ch03.xhtml#ch03ex02)中实现了这个计划。
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-2: Solution 1*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-2：解法1*'
- en: First, we solve the problem for exactly `t` minutes ❶. If our result is at least
    zero, then we output the maximum number of burgers ➋ and stop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们针对准确的 `t` 分钟解决问题 ❶。如果结果至少为零，那么我们输出最大数量的汉堡 ➋ 并停止。
- en: If it wasn’t possible for Homer to eat burgers for the entire `t` minutes, we
    set `i` to `t - 1`, since `t - 1` is the next-best number of minutes that we should
    try. We then solve the problem for this new value of `i` ➌. If we don’t get a
    value of `-1`, we’re successful and the `while` loop is skipped. If we’re not
    successful, the `while` loop executes until we successfully solve a subproblem.
    Inside the `while` loop, we decrement the value of `i` and solve that smaller
    subproblem ➍. The `while` loop will eventually terminate; for example, we can
    certainly fill zero minutes with burgers. Once we escape the `while` loop, we’ve
    found the largest number of minutes, `i`, that can be filled by burgers. At that
    point, `result` will hold the maximum number of burgers, and `t - i` is the number
    of minutes that remain, so we output both values ➎.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Homer 无法在整个 `t` 分钟内吃完汉堡，我们将 `i` 设置为 `t - 1`，因为 `t - 1` 是我们应该尝试的下一个最佳分钟数。然后我们针对这个新的
    `i` 值 ➌ 来解决问题。如果结果不是 `-1`，则表示成功，跳过 `while` 循环。如果没有成功，`while` 循环将继续执行，直到我们成功解决一个子问题。在
    `while` 循环中，我们递减 `i` 的值并解决那个更小的子问题 ➍。`while` 循环最终会终止；例如，我们肯定能用汉堡填满零分钟。一旦跳出 `while`
    循环，我们就找到了可以用汉堡填满的最大分钟数 `i`。此时，`result` 将保存最大数量的汉堡，`t - i` 是剩余的分钟数，所以我们输出这两个值 ➎。
- en: 'That’s that. We use recursion in `solve_t` to solve for `t` exactly. We tested
    `solve_t` on different kinds of test cases, and everything looked good. Not being
    able to solve for exactly `t` poses no problem: we use a loop inside of `solve`
    to try the minutes one by one, from largest to smallest. All we need now is a
    `main` function to read the input and call `solve`; [Listing 3-3](ch03.xhtml#ch03ex03)
    provides the code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们在 `solve_t` 中使用递归来解决准确的 `t`。我们在不同的测试用例上测试了 `solve_t`，一切看起来都很不错。无法准确求解
    `t` 并不成问题：我们在 `solve` 中使用一个循环，逐一尝试分钟数，从大到小。现在我们只需要一个 `main` 函数来读取输入并调用 `solve`；[清单
    3-3](ch03.xhtml#ch03ex03) 提供了代码。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-3: The main function*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：主函数*'
- en: Ah, a harmonious moment. We’re now ready to submit Solution 1 to the judge.
    Please do that now. I’ll wait . . . and wait . . . and wait.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这是一个和谐的时刻。我们现在准备将解法 1 提交给评审。请现在提交。我会等待……再等待……再等待。
- en: '*Solution 2: Memoization*'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法 2：记忆化*'
- en: Solution 1 fails, not because it’s incorrect, but because it’s too slow. If
    you submit Solution 1 to the judge, you’ll receive a “Time-Limit Exceeded” error.
    Remember the “Time-Limit Exceeded” error we received in Solution 1 of the Unique
    Snowflakes problem in [Chapter 1](ch01.xhtml)? There, the inefficiency was emblematic
    of doing unnecessary work. Here, as we’ll soon see, the inefficiency does not
    lie in doing unnecessary work, but in doing necessary work over and over and over.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解法 1 失败了，不是因为它不正确，而是因为它太慢。如果你将解法 1 提交给评审，你将收到一个 “超时” 错误。还记得在[第 1 章](ch01.xhtml)中的
    Unique Snowflakes 问题中我们收到的 “超时” 错误吗？当时，低效的表现是做了不必要的工作。而在这里，正如我们很快就会看到的，低效的原因并不在于做了不必要的工作，而是做了必要的工作一遍又一遍。
- en: 'The problem description says that *t* can be any number of minutes less than
    10,000\. Surely, then, the following test case should pose no problem at all:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 问题描述中提到，*t* 可以是小于 10,000 的任意分钟数。那么，下面这个测试用例应该不会有问题：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The *m* and *n* values, `4` and `2`, are very small. Relative to 10,000, the
    *t* value of `88` is very small as well. You may be surprised and disappointed
    that our code on this test case may not run within the three-second problem time
    limit. On my laptop, it takes about 10 seconds. That’s 10 seconds on a puny `88`
    test case. While we’re at it, let’s try this slightly bigger test case:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*m* 和 *n* 的值，`4` 和 `2`，都非常小。相对于 10,000，*t* 的值 `88` 也非常小。你可能会感到惊讶和失望，我们在这个测试用例上的代码可能无法在三秒的时间限制内运行。在我的笔记本上，它大约需要
    10 秒钟。这是一个微不足道的 `88` 测试用例，居然要花 10 秒钟。既然我们说到这，不如再试一个稍大的测试用例：'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All we did was increase `t` from `88` to `90`, but this small increase has
    a disproportionate effect on runtime: on my laptop, this test case takes about
    18 seconds—almost double what the `88` test case takes! Testing with a `t` value
    of 92 just about doubles the runtime again, and so on and so on. No matter how
    fast the computer, you’re unlikely to ever make it to a `t` value of even 100\.
    By extrapolating from this trend, we can see that it’s unfathomable how much time
    it would take to run our code on a test case where `t` is in the thousands. This
    kind of algorithm, in which a fixed increment in problem size leads to a doubling
    of runtime, is called an *exponential-time algorithm*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We have established that our code is slow—but why? Where is the inefficiency?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '##### Counting the Function Calls'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to take Solution 1 and add some code that counts the number of times
    that `solve_t` is called; see [Listing 3-4](ch03.xhtml#ch03ex04) for the new `solve_t`
    and `solve` functions. We now have a global variable `total_calls` that is initialized
    to `0` on entry to `solve` and is increased by `1` on every call of `solve_t`.
    That variable is of type `long long`; `long` or `int` simply isn’t big enough
    to capture the explosion of function calls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-4: Solution 1, instrumented*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: At the start of `solve_t`, we increase `total_calls` by `1` ❶ to count this
    function call. In `solve`, we initialize `total_calls` to `0` ➋ so that the count
    of calls is reset before each test case is processed. For each test case, the
    code prints the number of times that `solve_t` was called ➌.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'If we give it a go with this input:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'we get this as output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve made billions of calls!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Consider a given *m*, *n*, *t* test case. Our `solve_t` function has three parameters,
    but only the third parameter *t* ever changes. There are, therefore, only *t*
    + 1 different ways that `solve_t` can be called. For example, if *t* in a test
    case is `88`, then the only calls that can be made to `solve_t` are those with
    *t* values of `88`, `87`, `86`, and so on. Once we know the answer for some *t*
    value, such as `86`, there’s no reason to ever compute that answer again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Of those billions of calls, only about 88 or 90 of them can be distinct. We
    conclude that the same subproblems are being solved a staggering number of times.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Remembering Our Answers
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here’s some intuition for the staggering number of calls we make. If we call
    `solve_t(4, 2, 88)`, it makes two recursive calls: one to `solve_t(4, 2, 86)`
    and the other to `solve_t(4, 2, 84)`. So far, so good. Now consider what will
    happen for the `solve_t(4, 2, 86)` call. It will make two recursive calls of its
    own, the first of which is `solve_t(4, 2, 84)`—exactly one of the recursive calls
    made by `solve_t(4, 2, 88)`! That `solve_t(4, 2, 84)` work will therefore be performed
    twice. Once would have been enough!'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: However, the imprudent duplication is only just beginning. Consider the two
    `solve_t(4, 2, 84)` calls. By reasoning as in the previous paragraph, we see that
    each call eventually leads to two calls of `solve_t(4, 2, 80)`, for a total of
    four. Again, once would have been enough!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Well, it would have been enough if we had somehow remembered the answer from
    the first time we computed it. If we remember the answer to a call of `solve_t`
    the first time we compute it, we can just look it up later when we need that answer
    again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember, don’t refigure*. That’s the maxim of the *memoization* technique.
    Memoization comes from the word *memoize*, which means to store as if on a memo.
    It is a clunky word, sure, but one that’s in widespread use.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Using memoization involves three steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Declare an array large enough to hold the solutions to all possible subproblems.
    In Burger Fervor, `t` is less than 10,000, so an array of 10,000 elements suffices.
    This array is typically given the name `memo`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the elements of `memo` to a value reserved to mean “unknown value.”
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the start of the recursive function, add code to check whether the subproblem
    solution has already been solved. This involves checking the corresponding index
    of `memo`: if the “unknown value” is there, then we have to solve this subproblem
    now; otherwise, the answer is already stored in `memo` and we simply return it,
    without doing any further recursion. Whenever we solve a new subproblem, we store
    its solution in `memo`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s augment Solution 1 with memoization.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Memoization
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The appropriate place to declare and initialize the `memo` array is in `solve`,
    since that’s the function that first gets triggered for each test case. We’ll
    use a value of `-2` to represent an unknown value; we can’t use positive numbers
    because those would be confused with numbers of burgers, and we can’t use `-1`
    because we’re already using `-1` to mean “no solution possible.” The updated `solve`
    function is given in [Listing 3-5](ch03.xhtml#ch03ex05).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-5: Solution 2, with memoization implemented*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `memo` array using the maximum possible size for any test case
    ❶. Then we loop from `0` to `t` and set each element in the range to `-2`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a small but important change in our calls to `solve_t`. Now we’re
    passing in `memo` along with the other arguments; in this way, `solve_t` can check
    `memo` to determine whether the current subproblem has already been solved and
    update `memo` if it has not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The updated `solve_t` code is given in [Listing 3-6](ch03.xhtml#ch03ex06).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-6: Solving for exactly t minutes, with memoization implemented*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The game plan is the same as it was in Solution 1, [Listing 3-1](ch03.xhtml#ch03ex01):
    if `t` is `0`, solve the base case; otherwise, solve for `t - m` minutes and `t
    - n` minutes and use the better one.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: To this structure we fasten memoization. The huge reduction in time is realized
    when we check if a solution for `t` is already in the `memo` array ❶, returning
    that stored result if it is. There is no fussing over whether the final burger
    takes *m* or *n* minutes. There is no further recursion. All we have is an immediate
    return from the function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t find a solution in `memo`, then we have work to do. The work is
    the same as before—except that, whenever we’re about to return the solution, we
    first store it in the memo. Before each of our `return` statements, we store the
    value we’re about to return in `memo` so that our program maintains a memory of
    it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '##### Testing Our Memoization'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'I demonstrated that Solution 1 was doomed by showing you two things: that small
    test cases took far too long to run and that the slowness was caused by making
    an exorbitant number of function calls. How does Solution 2 fare in terms of these
    metrics?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Try Solution 2 with the input that bested Solution 1:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On my laptop, the time taken is imperceptibly small.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'How many function calls are made? I encourage you to instrument Solution 2
    in the way that we did for Solution 1 ([Listing 3-4](ch03.xhtml#ch03ex04)). If
    you do that and run it with the above input, you should get this output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 88 calls when `t` is `88`. 90 calls when `t` is `90`. The difference between
    Solution 2 and Solution 1 is like night and a few billion days. We’ve gone from
    an exponential-time algorithm to a linear-time algorithm. Specifically, we now
    have an *O*(*t*) algorithm, where *t* is the number of Homer’s minutes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: It’s judge time. If you submit Solution 2, you’ll see that we pass all of the
    test cases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: This is certainly a milestone, but it is not the last word on Homer and his
    burgers. We’ll be able to use something called dynamic programming to eliminate
    the recursion from our code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 3: Dynamic Programming*'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll bridge our way from memoization to dynamic programming by making explicit
    the purpose of recursion in Solution 2\. Consider the `solve_t` code in [Listing
    3-7](ch03.xhtml#ch03ex07); it’s the same as the code in [Listing 3-6](ch03.xhtml#ch03ex06)
    except that I’m now highlighting just the two recursive calls.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-7: Solving for exactly t minutes, focusing on recursive calls*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: At the first recursive call ❶, one of two very different things will happen.
    The first is that the recursive call finds its subproblem solution in the memo
    and returns immediately. The second is that the recursive call does not find the
    subproblem solution in the memo, in which case it carries out its own recursive
    calls. All of this is true of the second recursive call ➋ as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: When we make a recursive call and it finds its subproblem solution in the memo,
    we have to wonder why we made the recursive call at all. The only thing that the
    recursive call will do is check the memo and return; we could have done that ourselves.
    If the subproblem solution is not in the memo, however, then the recursion is
    really necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we could orchestrate things so that the `memo` array always holds
    the next subproblem solution that we need to look up. We want to know the optimal
    solution when `t` is `5`? It’s in `memo`. What about when `t` is `18`? That’s
    in `memo`, too. By virtue of always having the subproblem solutions in the memo,
    we’ll never require a recursive call; we can just look up the solution right away.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have the difference between memoization and dynamic programming. A
    function that uses memoization makes a recursive call to solve a subproblem. Maybe
    the subproblem was already solved, maybe it wasn’t— regardless, it will be solved
    when the recursive call returns. A function that uses *dynamic programming* organizes
    the work so that a subproblem is already solved by the time we need it. We then
    have no reason to use recursion: we just look up the solution.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Memoization uses recursion to ensure that a subproblem is solved; dynamic programming
    ensures that the subproblem is already solved and therefore has no use for recursion.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Our dynamic-programming solution dispenses with the `solve_t` function and systematically
    solves for all values of `t` in `solve`. [Listing 3-8](ch03.xhtml#ch03ex08) gives
    the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-8: Solution 3, with dynamic programming*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The canonical name for a dynamic-programming array is `dp`. We could have called
    it `memo`, since it serves the same purpose as a memo table, but we call it `dp`
    to follow convention. Once we declare the array, we solve the base case, explicitly
    storing the fact that the optimal solution for zero minutes is to eat zero burgers
    ❶. Then we have the loop that controls the order in which the subproblems are
    solved. Here, we solve the subproblems from smallest number of minutes (`1`) to
    largest number of minutes (`t`). The variable `i` determines which subproblem
    is being solved. Inside our loop, we have the familiar check of whether it makes
    sense to test the *m*-minute burger as the final burger ➋. If so, we look up the
    solution to the `i - m` subproblem in the `dp` array ➌.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we just look up the value from the array ➌, without using any recursion.
    We can do that because we know, by virtue of the fact that `i - m` is less than
    `i`, that we’ve already solved subproblem `i - m`. This is precisely why we solve
    subproblems in order, from smallest to largest: larger subproblems will require
    solutions to smaller subproblems, so we must ensure that those smaller subproblems
    have already been solved.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The next `if` statement ➍ is analogous to the previous one ➋ and handles the
    case when the final burger is an *n*-minute burger. As before, we look up the
    solution to a subproblem using the `dp` array. We know for sure that the `i -
    n` subproblem has already been solved, because the `i - n` iteration took place
    before this `i` iteration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We now have the solutions to both of the required subproblems. All that’s left
    to do is store the optimal solution for `i` in `dp[i]` ➎ ➏.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve built up the `dp` array, solving subproblems `0` to `t`, we can look
    up subproblem solutions at will. We thus simply look up the solution to subproblem
    `t` ❼, printing it if there’s a solution and looking up solutions to progressively
    smaller subproblems if there’s not ❽.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Like our memoized solution, this is a linear-time solution. In general, the
    dynamic-programming and memoized solutions of a problem will have the same efficiency,
    but, that efficiency may be easier to identify in dynamic-programming solutions
    because they use a loop rather than recursion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see one example `dp` array before moving on. For the test case that follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'the final contents of the `dp` array are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch03fig02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: We can trace the code in [Listing 3-8](ch03.xhtml#ch03ex08) to confirm each
    of these subproblem solutions. For example, `dp[0]`, the maximum number of burgers
    that Homer can eat in zero minutes, is `0` ❶. `dp[1]` is `-1` because both checks
    ➋ ➍ fail, meaning we store `-1` ➎.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As a final example, we’re going to reverse-engineer how `dp[12]` got its value
    of `3`. Since 12 is greater than 4, the first check passes ➋. We then set `first`
    to `dp[8]` ➌, which has a value of `2`. Similarly, 12 is greater than 9, so the
    second check passes ➍, and we set `second` to `dp[3]`, which has a value of `-1`.
    The maximum of `first` and `second` is therefore `2`, so we set `dp[12]` to `3`,
    one more than that maximum ➏.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Please feel free to submit our dynamic programming solution to the judge. It
    should pass all test cases just like our memoization solution did. Is one of these
    solutions better than the other? And when should we be using memoization and dynamic
    programming, anyway? Read on to find out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Memoization and Dynamic Programming
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We solved Burger Fervor in four steps. First, we characterized what an optimal
    solution must look like; second, we wrote a recursive solution; third, we added
    memoization; and fourth, we eliminated the recursion by explicitly solving subproblems
    from smallest to largest. These four steps offer a general plan for tackling many
    other optimization problems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Step 1: Structure of Optimal Solutions*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to show how to decompose an optimal solution to a problem
    into optimal solutions for smaller subproblems. In Burger Fervor, we did this
    by reasoning about the final burger that Homer eats. Is it an *m*-minute burger?
    That leaves the subproblem of filling *t* – *m* minutes. What if it is an *n*-minute
    burger? That leaves the problem of filling *t* – *n* minutes. We don’t know which
    it is, of course, but we can simply solve these two subproblems to find out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是展示如何将一个问题的最优解分解成更小子问题的最优解。在《汉堡狂热》中，我们通过推理 Homer 吃的最终汉堡来完成这一点。它是一个 *m* 分钟汉堡吗？那就剩下填充
    *t* – *m* 分钟的子问题。如果它是一个 *n* 分钟汉堡呢？那就剩下填充 *t* – *n* 分钟的问题。当然，我们并不知道它是哪种，但我们可以简单地解决这两个子问题来找出答案。
- en: It’s critical that our subproblems really are *smaller* than the original problem.
    If they are not, then we will fail to eventually reach a base case. The problems
    in [Chapter 5](ch05.xhtml) serve as examples of what we need to do when subproblems
    cannot be easily ordered by size.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们的子问题比原问题更 *小*。如果它们不是，那我们最终将无法达到基本情况。第 [5 章](ch05.xhtml) 中的问题就作为了一个例子，说明了当子问题无法按照大小轻松排序时，我们需要做什么。
- en: We also require that an optimal solution to a problem contains within it not
    just some solutions to the smaller subproblems but *optimal* solutions to those
    subproblems. Let’s make this point explicit here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还要求，一个问题的最优解不仅包含一些子问题的解，而且包含这些子问题的 *最优* 解。让我们在这里明确这一点。
- en: 'In Burger Fervor, when supposing that the final burger in an optimal solution
    is an *m*-minute burger, we argued that a solution to the *t* – *m* subproblem
    was part of the solution to the overall *t* problem. Moreover, an optimal solution
    for *t* must include the optimal solution for *t* – *m*: if it didn’t, then the
    solution for *t* wouldn’t be optimal after all, since we could improve it by using
    the better solution for *t* – *m*! A similar argument can be used to show that,
    if the last burger in an optimal solution is an *n*-minute burger, then the remaining
    *t* – *n* minutes should be filled with an optimal solution for *t* – *n*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在《汉堡狂热》中，假设最优解中的最终汉堡是一个 *m* 分钟汉堡时，我们认为 *t* – *m* 子问题的解是整体 *t* 问题解的一部分。而且，*t*
    的最优解必须包含 *t* – *m* 的最优解：如果不包含，那么 *t* 的解就不是最优的，因为我们可以通过使用更好的 *t* – *m* 解来改进它！一个类似的论证可以用来说明，如果最优解中的最后一个汉堡是
    *n* 分钟汉堡，那么剩余的 *t* – *n* 分钟应该用 *t* – *n* 的最优解来填充。
- en: Let me unpack this a little through an example. Suppose that *m* = 4, *n* =
    9, and *t* = 54\. The value of an optimal solution is 11\. There is an optimal
    solution *S* where the final burger is a 9-minute burger. My claim is that *S*
    must consist of this 9-minute burger along with an optimal solution for 45 minutes.
    The optimal solution for 45 minutes is 10 burgers. If *S* used some suboptimal
    solution for the first 45 minutes, then *S* wouldn’t be an example of an optimal
    11-burger solution. For example, if *S* used a suboptimal five-burger solution
    for the first 45 minutes, then it would use a total of only six burgers for the
    full 54 minutes!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过一个例子来解释一下。假设 *m* = 4，*n* = 9，*t* = 54。最优解的值是 11。存在一个最优解 *S*，其中最后一个汉堡是一个
    9 分钟汉堡。我声称 *S* 必须由这个 9 分钟的汉堡和一个 45 分钟的最优解组成。45 分钟的最优解是 10 个汉堡。如果 *S* 在前 45 分钟使用了某个非最优解，那么
    *S* 就不是一个最优的 11 汉堡解。例如，如果 *S* 在前 45 分钟使用了一个非最优的 5 汉堡解，那么它在 54 分钟的总汉堡数就只有 6 个！
- en: If an optimal solution to a problem is composed of optimal solutions to subproblems,
    we say that the problem has *optimal substructure*. If a problem has optimal substructure,
    the techniques from this chapter are likely to apply.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个问题的最优解由子问题的最优解组成，我们说该问题具有 *最优子结构*。如果一个问题具有最优子结构，那么本章中的技术很可能适用。
- en: I’ve read and heard people claim that solving optimization problems using memoization
    or dynamic programming is formulaic, that once you’ve seen one such problem, you’ve
    seen them all, and you can just turn the crank when a new problem arises. I don’t
    think so. That perspective belies the challenges of both characterizing the structure
    of optimal solutions and identifying that this will be fruitful in the first place.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我读过并听说过一些人声称，使用记忆化或动态规划来解决优化问题是公式化的，意思是说一旦你见过一个这样的题目，就能见到所有题目，你只需要转动把手应对新的问题。我不这么认为。这样的观点忽视了两方面的挑战：一是如何表征最优解的结构，二是如何识别最初就能确定这种方法会带来有用的结果。
- en: For example, when discussing the structure of an optimal solution for Burger
    Fervor, I made a big deal about focusing on *exactly t* minutes. As a result,
    in our code we couldn’t necessarily look up the answer in one shot—we needed to
    check for a solution to exactly *t* minutes, then exactly *t* – 1 minutes, then
    exactly *t* – 2 minutes, and so on, until we found a solution. But couldn’t we
    have found a way to characterize the optimal solution so that we didn’t need to
    search like that? Well, we could have, but that would have led to an overall trickier
    solution for this problem. (We’ll see this alternate kind of approach as an effective
    way to solve Problem 3 later in this chapter.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: My point here is simply that discovering what an optimal solution looks like
    can be surprisingly tricky. The sheer breadth of problems that can be solved using
    memoization and dynamic programming means that practicing with and generalizing
    from as many problems as possible is the only way forward.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2: Recursive Solution*'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Step 1 not only suggests to us that memoization and dynamic programming will
    lead to a solution, but also leaves in its wake a recursive approach for solving
    the problem. To solve the original problem, try each of the possibilities for
    an optimal solution, solving subproblems optimally using recursion. In Burger
    Fervor, we argued that an optimal solution for exactly *t* minutes might consist
    of an *m*-minute burger and an optimal solution for exactly *t* – *m* minutes
    or an *n*-minute burger and an optimal solution for exactly *t* – *n* minutes.
    Solving the *t* – *m* and *t* – *n* subproblems is therefore required and, as
    these are smaller subproblems than *t*, we used recursion to solve them. In general,
    the number of recursive calls depends on the number of available candidates competing
    to be the optimal solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3: Memoization*'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we succeed with Step 2, then we have a correct solution to the problem.
    As we saw with Burger Fervor, though, such a solution may require an absolutely
    unreasonable amount of time to execute. The culprit is that the same subproblems
    are being solved over and over, as a result of a phenomenon known as *overlapping
    subproblems*. Really, if we didn’t have overlapping subproblems, then we could
    stop right here: recursion would be fine on its own. Think back to [Chapter 2](ch02.xhtml)
    and the two problems we solved there. We solved those successfully with recursion
    alone, and that worked because each subproblem was solved only once. In Halloween
    Haul, for example, we calculated the total amount of candy in a tree. The two
    subproblems were finding the total amounts of candy in the left and right subtrees.
    Those problems are independent: there’s no way that solving the subproblem for
    the left subtree could somehow require information about the right subtree, or
    vice versa.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no subproblem overlap, we can just use recursion. When there is subproblem
    overlap, however, it’s time for memoization. As we learned when solving Burger
    Fervor, memoization means that we store the solution to a subproblem the first
    time we solve it. Then, whenever that subproblem solution is needed in the future,
    we simply look it up rather than recalculate it. Yes, the subproblems still overlap,
    but now they are solved only once, just like in [Chapter 2](ch02.xhtml).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '#### *Step 4: Dynamic Programming*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Very likely, the solution resulting from Step 3 will be fast enough. Such a
    solution still uses recursion, but without the risk of duplicating work. As I’ll
    explain in the next paragraph, sometimes we want to eliminate the recursion. We
    can do so as long as we systematically solve smaller subproblems before larger
    subproblems. This is dynamic programming: the use of a loop in lieu of recursion,
    explicitly solving all subproblems in order from smallest to largest.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'So what’s better: memoization or dynamic programming? For many problems, they
    are roughly equivalent and, in those cases, you should use what you find more
    comfortable. My personal choice is memoization. We’ll see an example (Problem
    3 later in this chapter) where the `memo` and `dp` tables have multiple dimensions.
    In such problems, I often have trouble getting all of the base cases and bounds
    for the `dp` table correct.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Memoization solves subproblems on an as-needed basis. For example, consider
    the Burger Fervor test case where we have a kind of burger that takes 2 minutes
    to eat, a kind of burger that takes 4 minutes to eat, and 90 minutes of time.
    A memoized solution will never solve for odd numbers of minutes, such as 89 or
    87 or 85, because those subproblems do not result from subtracting multiples of
    2 and 4 from 90\. Dynamic programming, by contrast, solves all subproblems on
    its way up to 90\. The difference here seems to favor memoized solutions; indeed,
    if huge swaths of the subproblem space are never used, then memoization may be
    faster than dynamic programming. This has to be balanced against the overhead
    inherent in recursive code, though, with all of the calling and returning from
    functions. If you’re so inclined, it wouldn’t hurt to code up both solutions to
    a problem and see which is faster!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: You’ll commonly see people refer to memoized solutions as *top-down* solutions
    and dynamic-programming solutions as *bottom-up* solutions. It’s called “top-down”
    because, to solve large subproblems, we recurse down to small subproblems. In
    “bottom-up” solutions, we start from the bottom—the smallest subproblems—and work
    our way to the top.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Memoization and dynamic programming are captivating to me. They can solve so
    many types of problems; I don’t know another algorithm design technique that even
    comes close. Many of the tools that we learn in this book, such as hash tables
    in [Chapter 1](ch01.xhtml), offer valuable speedups. The truth is that, even without
    those tools, we could solve many problem instances— not in time to have such solutions
    accepted by the judge, but perhaps still in time to be practically useful. However,
    memoization and dynamic programming are different. They vivify recursive ideas,
    turning algorithms that are astonishingly slow into those that are astonishingly
    fast. I hope I can pull you into the fold with this chapter and the next and that
    you won’t stop when these chapters do.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '### Problem 2: Moneygrubbers'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In Burger Fervor, we were able to solve each problem by considering only two
    subproblems. Here, we’ll see an example where each problem may require solving
    many more subproblems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This is UVa problem `10980`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You want to buy apples, so you go to an apple store. The store has a price for
    buying one apple—for example, $1.75\. The store also has *m* pricing schemes,
    where each pricing scheme gives a number *n* and a price *p* for buying *n* apples.
    For example, one pricing scheme might state that three apples cost a total of
    $4.00; another might state that two apples cost a total of $2.50\. You want to
    buy *at least k* apples and do so as cheaply as possible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We read test cases until there’s no more input. Each test case consists of
    the following lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A line containing the price for buying one apple, followed by the number *m*
    of pricing schemes for this test case. *m* is at most 20.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each of which gives a number *n* and total price *p* for buying
    *n* apples. *n* is between 1 and 100.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing integers, where each integer *k* is between 0 and 100 and
    gives the desired number of apples to buy.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each price in the input is a floating-point number with exactly two decimal
    digits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In the problem description, I gave an example price of one apple as $1.75\.
    I also gave two example pricing schemes: three apples for $4.00 and two apples
    for $2.50\. Using that data, suppose we wanted to determine the minimum price
    for buying at least one apple and at least four apples, respectively. Here’s the
    input for this test case:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Output
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For each test case, output the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: A line containing `Case` c:, where c is the number of the test case starting
    at 1.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each integer *k*, a line containing `Buy` *k* `for $*d*`, where d is the
    cheapest cost for which we can buy at least k apples.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the output for the above sample input:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The time limit for solving the test cases is three seconds.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*Characterizing Optimal Solutions*'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The problem description specifies that we want to buy *at least k* apples as
    cheaply as possible. This means that buying exactly *k* apples is only one option;
    we can buy more than *k* apples if it’s cheaper that way. We’re going to start
    by trying to solve for exactly *k* apples, much as we solved for exactly *t* minutes
    in Burger Fervor. Back then, we found a way when necessary to move from exactly
    *t* minutes to smaller numbers of minutes. The hope is that we can do something
    similar here, starting with *k* apples and finding the cheapest cost for *k*,
    *k* + 1, *k* + 2, and so on. If it ain’t broke . . .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Before just recalling the title of this chapter and diving headlong into memoization
    and dynamic programming, let’s make sure that we really do need those tools.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s better: buying three apples for a total of $4.00 (Scheme 1) or two apples
    for a total of $2.50 (Scheme 2)? We can try to answer this by calculating the
    cost per apple for each of these pricing schemes. In Scheme 1, we have $4.00/3
    = $1.33 per apple, and in Scheme 2 we have $2.50/2 = $1.25 per apple. It looks
    like Scheme 2 is better than Scheme 1\. Let’s also suppose that we can buy one
    apple for $1.75, which looks even worse than the two schemes. We therefore have
    the cost per apple, from cheapest to most expensive, as follows: $1.25, $1.33,
    $1.75.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that we want to buy *exactly k* apples. How’s this for an algorithm:
    at each step, use the cheapest cost per apple, until we’ve bought *k* apples?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to buy exactly four apples for the above case, then we’d start
    with Scheme 2, because it lets us buy apples with the best price per apple. Using
    Scheme 2 once costs us $2.50 for two apples, and it leaves us with two apples
    to buy. We can then use Scheme 2 again, buying two more apples (for a total now
    of four apples) for another $2.50\. We’d have spent $5.00 for the four apples
    and, indeed, we cannot do better.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Note that just because an algorithm is intuitive or works on one test case does
    not mean that it is correct in general. This algorithm of using the best-available
    price per apple is flawed, and there are test cases that prove it. Try to find
    such a test case before continuing!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one: suppose that we want to buy exactly three apples, not four. We’d
    start with Scheme 2 again, giving us two apples for a total of $2.50\. Now we
    have only one apple to buy—and the only choice is to pay $1.75 for the one apple.
    The total cost is $4.25—but there is a better way. Namely, we should simply have
    used Scheme 1 once, costing us $4.00: yes, it has a higher cost per apple than
    Scheme 2, but it makes up for that by freeing us from paying for one apple that
    has a still higher cost per apple.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to start affixing extra rules to our algorithm to try to fix it;
    for example, “if there’s a pricing scheme for exactly the number of apples that
    we need, then use it.” Suppose, however, we want to buy exactly three apples.
    We can easily break this augmented algorithm by adding a scheme in which the store
    sells three apples for $100.00.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'When using memoization and dynamic programming, we try all the available options
    for an optimal solution and then pick the best one. In Burger Fervor, should Homer
    end with an *m*-minute burger or an *n*-minute burger? We don’t know, so we try
    both. By contrast, a *greedy algorithm* is an algorithm that tries just one option:
    the one that looks like the best choice at the time.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Using the best price per apple, as we did above, is an example of a greedy algorithm,
    because at each step it chooses what to do without considering other options.
    Sometimes greedy algorithms work. Moreover, since they often run faster than dynamic-programming
    algorithms and are easier to implement , a working greedy algorithm may be better
    than a working dynamic-programming algorithm. For this problem, it appears that
    greedy algorithms—whether the one above or others that might come to mind—are
    not sufficiently powerful.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In Burger Fervor, we reasoned that, if it’s possible to spend *t* minutes eating
    burgers, then the final burger in an optimal solution must be an *m*-minute burger
    or an *n*-minute burger. For the present problem, we want to say something analogous:
    that an optimal solution for buying *k* apples must end in one of a small number
    of ways. Here’s a claim: if the available pricing schemes are Scheme 1, Scheme
    2, . . . , Scheme *m*, then the final thing we do must be to use one of these
    *m* pricing schemes. There can’t be anything else that we could do, right?'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is not quite true. The final thing that we do in an optimal solution
    might be buying one apple. We always have that as an option. Rather than solve
    two subproblems as in Burger Fervor, we solve *m* + 1 subproblems: one for each
    of the *m* pricing schemes and one for buying one apple.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an optimal solution for buying *k* apples ends with us paying
    *p* dollars for *n* apples. We then need to optimally buy *k* – *n* apples and
    add that cost to *p*. We need to establish that the overall optimal solution for
    *k* apples contains within it an optimal solution for *k* – *n* apples. This is
    the optimal substructure requirement of memoization and dynamic programming. As
    with Burger Fervor, optimal substructure does hold. If a solution for *k* didn’t
    use an optimal solution for *k* – *n*, then that solution for *k* cannot be optimal
    after all: it’s not as good as what we’d get if we built it on the optimal solution
    for *k* – *n*.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don’t know what to do at the end of the solution to make it optimal.
    Do we use Scheme 1, use Scheme 2, use Scheme 3, or just buy one apple? Who knows?
    As in any memoization or dynamic-programming algorithm, we simply try them all
    and choose the best one.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at a recursive solution, note that, for any number *k*, we can
    always find a way to buy exactly *k* apples. Whether one apple, two apples, five
    apples, whatever, we can buy that many. The reason is that we always have the
    option of buying one apple, and we can do that as many times as we like. Compare
    this to Burger Fervor, where there were values of *t* such that *t* minutes could
    not be filled by the available burgers. As a consequence of this difference, here
    we won’t have to worry about the case where a recursive call on a smaller subproblem
    fails to find a solution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like in Burger Fervor, the first thing to do is write a helper function to solve
    for a specific number of apples.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The Helper Function: Solving for the Number of Apples'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s write the function `solve_k`, whose job will be analogous to the `solve_t`
    functions that we wrote for Burger Fervor. The function signature is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each of these parameters except for the last comes directly from the current
    test case. Here’s what each parameter is for:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: num   An array of numbers of apples, with one element per pricing scheme. For
    example, if we have two pricing schemes, the first for three apples and the second
    for two apples, then this array would be `[3, 2]`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: price   An array of prices, one element per pricing scheme. For example, if
    we have two pricing schemes, the first with cost `4.00` and the second with cost
    `2.50`, then this array would be `[4.00, 2.50]`. Notice that `num` and `price`
    together give us all of the information about the pricing schemes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: num_schemes   The number of pricing schemes. It’s the `m` value from the test
    case.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: unit_price   The price for one apple.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: num_apples   The number of apples that we want to buy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The `solve_k` function returns the minimum cost for buying exactly `num_apples`
    apples.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The code for `solve_k` is given in [Listing 3-9](ch03.xhtml#ch03ex09). In addition
    to studying this code on its own, I strongly encourage you to compare it to the
    `solve_t` function from Burger Fervor ([Listing 3-1](ch03.xhtml#ch03ex01)). What
    differences do you notice? Why are these differences present? Memoization and
    dynamic-programming solutions share a common code structure. If we can nail that
    structure, then we can focus on what’s different in and specific to each problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-9: Solving for exactly num_apples apples*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a little `min` function ❶: we’ll need that for comparing solutions
    and picking the smaller one. In Burger Fervor, we used a similar `max` function,
    because we wanted the maximum number of burgers. Here, we want the minimum cost.
    Some optimization problems are *maximization problems* (Burger Fervor) and others
    are *minimization problems* (Moneygrubbers)— carefully read problem statements
    to make sure you’re optimizing in the right direction!'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: What do we do if asked to solve for `0` apples ➋? We return `0` ➌, because the
    minimum cost to buy zero apples is exactly $0.00\. That’s a base case, just like
    filling zero minutes in Burger Fervor. As with recursion in general, at least
    one base case is required for any optimization problem.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: If we’re not in the base case, then `num_apples` will be a positive integer,
    and we need to find the optimal way to buy exactly that many apples. The variable
    `best` is used to track the best (minimum-cost) option that has been found so
    far.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: One option is to optimally solve for `num_apples - 1` apples ➍ and add the cost
    of the final apple ➎.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We now hit the big structural difference between this problem and Burger Fervor:
    a loop inside of the recursive function. In Burger Fervor, we didn’t need a loop,
    because we only had two subproblems to try. We just tried the first one and then
    tried the second one. Here, though, we have one subproblem per pricing scheme,
    and we have to go through all of them. We check whether the current pricing scheme
    can be used at all ➏: if its number of apples is no larger than the number that
    we need, then we can try it. We make a recursive call to solve the subproblem
    resulting from removing the number of apples in this pricing scheme ❼. (It’s similar
    to the earlier recursive call where we subtracted one for the single apple ➍.)
    If that subproblem solution plus the price of the current scheme is our best option
    so far, then we update `best` accordingly ❽.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The solve Function
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ve optimally solved for exactly *k* apples, but there’s this detail from
    the problem statement that we haven’t addressed yet: “You want to buy *at least
    k* apples and to do so as cheaply as possible.” Why does the difference between
    exactly *k* apples and at least *k* apples matter in the first place? Can you
    find a test case where it’s cheaper to buy more than *k* apples than it is to
    buy *k* apples?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one for you. We’ll say that one apple costs $1.75\. We have two pricing
    schemes: Scheme 1 is that we can buy four apples for $3.00, and Scheme 2 is that
    we can buy two apples for $2.00\. Now, we want to buy at least three apples. This
    test case in the form of problem input is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The cheapest way to buy exactly three apples is to spend $3.75: one apple for
    $1.75 and two apples using Scheme 2 for $2.00\. However, we can spend less money
    by in fact buying four apples, not three. The cheapest way to buy four apples
    is to use Scheme 1 once, which costs us only $3.00\. That is, the correct output
    for this test case is:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: (This output is a bit confusing, because we’re actually buying four apples,
    not three, but it is correct to output `Buy 3` here. We always output the number
    of apples that we’re asked to buy, whether or not we buy more than that to save
    money.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a `solve` function like the one we had for Burger Fervor in
    [Listing 3-2](ch03.xhtml#ch03ex02). There, we tried smaller and smaller values
    until we found a solution. Here, we’ll try larger and larger values, keeping track
    of the minimum solution as we go. Here’s a first crack at the code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We initialize `best` to the optimal solution for buying exactly `num_apples`
    apples ❶. Then, we use a `for` loop to try larger and larger numbers of apples
    ➋. The `for` loop stops when . . . uh-oh. How do we know when it’s safe to stop?
    Maybe we’re being asked to buy 3 apples, but the cheapest thing to do is to buy
    4 or 5 or 10 or even 20\. We didn’t have this problem in Burger Fervor, because
    there we were making our way downward, toward zero, rather than upward.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find a game-saving observation from the problem input specification:
    it says that the number of apples in a given pricing scheme is at most 100\. How
    does this help?'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’re being asked to buy at least 50 apples. Might it be best to buy
    exactly 60 apples? Sure! Maybe the final pricing scheme in an optimal solution
    for 60 apples is for 20 apples. Then we could combine those 20 apples with an
    optimal solution for 40 apples to get a total of 60 apples.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Suppose again that we’re buying 50 apples. Could it make sense for us to buy
    exactly 180 apples? Well, think about an optimal solution for buying exactly 180
    apples. The final pricing scheme that we use gives us at most 100 apples. Before
    using that final pricing scheme, we’d have bought at least 80 apples and had done
    so more cheaply than we did for 180 apples. Crucially, 80 is still greater than
    50! Therefore, buying 80 apples is cheaper than buying 180 apples. Buying 180
    apples cannot be the optimal thing to do if we want at least 50 apples.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In fact, for 50 apples, the maximum number of apples we should even consider
    buying is 149\. If we buy 150 or more apples, then removing the final pricing
    scheme gives us a cheaper way to buy 50 or more apples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The problem input specification not only limits the number of apples per pricing
    scheme to 100, it also limits the number of apples to buy to 100\. In the case
    in which we are asked to buy 100 apples, then, the maximum number of apples we
    should consider buying is 100 + 99 = 199\. Incorporating this observation leads
    to the `solve` function in [Listing 3-10](ch03.xhtml#ch03ex010).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 3-10: Solution 1*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now all we need is a `main` function and we can start submitting stuff to the
    judge.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s get a `main` function written. See [Listing 3-11](ch03.xhtml#ch03ex11).
    It’s not completely self-contained, but all we’ll need is one helper function,
    `get_number`, that I’ll describe shortly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 3-11: The main function*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We begin by using `scanf` to try to read the first line of the next test case
    from the input ❶. The next `scanf` call ➋ is in a nested loop, and it reads the
    number of apples and price for each pricing scheme.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the `scanf` format strings ends with a space, which ensures
    that we’re always positioned at the start of each line. This becomes important
    once we get to the line containing the numbers of apples that we are asked to
    buy, because we’re going to use a helper function that assumes we’re at the start
    of the line.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need a helper function? Well, we can’t just airily keep calling `scanf`
    to read those numbers of apples, because we have to be able to stop at a newline.
    That’s why we use my `get_number` helper function instead, described further below.
    It returns `1` if there are more numbers to read and `0` if this is the last number
    on the line. We call this function to read each number in the loop ➌ that solves
    the test cases. We also need some code below the loop ➍: when the loop terminates
    because it has read the final number on the line, we still need to solve that
    final test case.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The code for `get_number` is given in [Listing 3-12](ch03.xhtml#ch03ex012).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 3-12: The function to get an integer*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'This function reads an integer value using an approach reminiscent of [Listing
    2-17](ch02.xhtml#ch02ex017). The loop continues as long as we haven’t yet hit
    a space or new-line character ❶. When the loop terminates, we store what was read
    in the pointer parameter passed to this function call ➋. We use that pointer parameter,
    rather than return the value, because the return value has another role: to indicate
    whether or not this is the last number on the line ➌. That is, if `get_number`
    returns `1` (because it found a space after the number that it read), it means
    that there are more numbers on this line; if it returns `0`, then this is the
    final number on this line.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a complete solution now, but its performance is glacial. Even test
    cases that look small will take ages, because we’re going all the way up to 299
    apples no matter what.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Oh well. Let’s memoize the heck out of this thing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Memoization*'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We introduced the `memo` array in `solve` ([Listing 3-5](ch03.xhtml#ch03ex05))
    when memoizing Burger Fervor. That was because each call of `solve` was for an
    independent test case. However, in Moneygrubbers, we have that line where each
    integer specifies a number of apples to buy, and we have to solve each one. It
    would be wasteful to throw away the `memo` array before we’ve completely finished
    with the test case!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We’re therefore going to declare and initialize `memo` in `main`. The updated
    `main` function is in [Listing 3-13](ch03.xhtml#ch03ex013).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-13: The main function, with memoization implemented*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We declare the `memo` array ❶, and we set each element of `memo` to `-1` (“unknown”
    value) ➋ ➌. Notice that the initialization of `memo` occurs just once per test
    case. The only other change is that we add `memo` as a new parameter to the `solve`
    calls.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The new code for `solve` is given in [Listing 3-14](ch03.xhtml#ch03ex014).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-14: Solution 2, with memoization implemented*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In addition to adding `memo` as a new parameter at the end of the parameter
    list, we pass `memo` to the `solve_k` calls. That’s it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s take a look at the changes required to memoize `solve_k`. We
    will store in `memo[num_apples]` the minimum cost of buying exactly `num_apples`
    apples. See [Listing 3-15](ch03.xhtml#ch03ex015).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 3-15: Solving for exactly num_apples apples, with memoization implemented*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the first thing we do when solving with memoization is check whether
    the solution is already known ❶. If any value besides `-1` is stored for the `num_apples`
    subproblem, we return it. Otherwise, as with any memoized function, we store a
    new subproblem solution in `memo` before returning it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now reached a natural stopping point for this problem: this memoized
    solution can be submitted to the judge and should pass all test cases. If you’d
    like more practice with dynamic programming, though, here’s a perfect opportunity
    for you to convert this memoized solution into a dynamic-programming solution!
    Otherwise, we’ll put this problem on ice.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 3: Hockey Rivalry'
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first two problems used a one-dimensional `memo` or `dp` array. Let’s look
    at a problem whose solution dictates using a two-dimensional array.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: I live in Canada, so I suppose we weren’t getting through this book without
    some hockey. Hockey is a team sport like soccer . . . but with goals.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `cco18p1`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Geese played *n* games, each of which had one of two outcomes: a win for
    the Geese (`W`) or a loss for the Geese (`L`). (There are no tie games.) For each
    of their games, we know whether they won or lost and we know the number of goals
    that they scored. For example, we might know that their first game was a win (`W`)
    and that they scored four goals in that game. (Their opponent, whoever it was,
    must therefore have lost and scored fewer than four goals.) The Hawks also played
    *n* games and, the same as the Geese, each game was a win or loss for the Hawks.
    Again, for each of their games, we know whether they won or lost and we know the
    number of goals that they scored.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Some of the games that these teams played may have been against each other,
    but there are other teams, too, and some of the games may have been against these
    other teams.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We have no information about who played whom. We might know that the Geese won
    a certain game and that they scored four goals in that game, but we don’t know
    who their opponent was—their opponent could have been the Hawks, but it also could
    have been some other team.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: A *rivalry game* is a game where the Geese played the Hawks.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Our task is to determine the maximum number of goals that could have been scored
    in rivalry games.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The input contains one test case, the information for which is spread over
    five lines as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains *n*, the number of games that each team played. *n*
    is between 1 and 1,000.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains a string of length *n*, where each character is a `W`
    (win) or `L` (loss). This line tells us the outcome of each game played by the
    Geese. For example, `WLL` means that the Geese won their first game, lost their
    second game, and lost their third game.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains *n* integers, giving the number of goals scored in each
    game by the Geese. For example, `4 1 2` means that the Geese scored four goals
    in their first game, one goal in their second game, and two goals in their third
    game.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line is like the second, but it tells us the outcome of each game
    for the Hawks.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth line is like the third, but it tells us the number of goals scored
    in each game by the Hawks.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '##### Output'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a single integer: the maximum number of goals scored in possible
    rivalry games.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '*About Rivalries*'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before jumping to the structure of optimal solutions, let’s be sure that we
    understand exactly what’s being asked by working through some test cases.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with this one:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There can’t be *any* rivalry games at all here. A rivalry game, like any game,
    requires that one team win and the other lose—but the Geese won all their games
    and the Hawks won all their games, so the Geese and Hawks could not have played
    each other. Since there are no rivalry games possible, there are no goals scored
    in rivalry games. The correct output is `0`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now have the Hawks lose all their games:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Are there any rivalry games now? The answer is still no! The Geese won their
    first game by scoring two goals. For that game to be a rivalry game, it must be
    with a game where the Hawks lost and where the Hawks scored fewer than two goals.
    Since the fewest goals scored by the Hawks was five, though, none of those games
    can be a rivalry game with the Geese’s first game. Similarly, the Geese won their
    second game by scoring five goals, but there is no loss for the Hawks where they
    scored four goals or fewer. That is, there is no rivalry involving the Geese’s
    second game. The same kind of analysis shows that the Geese’s third game also
    cannot be part of a rivalry. Again, `0` is the correct output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move past these zero cases. Here’s one:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’ve changed the first Hawks game so that they scored four goals instead of
    five, and this is enough to produce a possible rivalry game! Specifically, the
    second game played by the Geese, where the Geese won and scored five goals, could
    be a rivalry game with the first game by the Hawks, where the Hawks lost and scored
    four goals. That game had nine goals scored in it. As there are no other rivalry
    games that we can include, there are no other goals that we can add to our total.
    The correct output here is `9`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this one:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Look at the final game that each team played: the Geese won and scored two
    goals, and the Hawks lost and scored one goal. That could be a rivalry game, with
    a total of three goals. The first game played by each team cannot be a rivalry
    game (the Geese won with six goals, and the Hawks could not have lost the same
    game with eight goals), so we can’t add any more goals. Is `3` the correct output?'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not! We chose poorly, matching those final games. What we should have
    done is match the first game played by the Geese with the second game played by
    the Hawks. That could be a rivalry game, and it has seven goals. This time we’ve
    got it: the correct output is `7`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one more example. Try to figure out the maximum total before
    reading my answer:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The correct output is `20`, witnessed by having two rivalry games: the second
    Geese game with the first Hawks game (9 goals there) and the fourth Geese game
    with the fourth Hawks game (11 goals there).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Did you predict instead that the correct output would be `25`? If so, we’re
    not allowed to add a rivalry of the first Geese game with the third Hawks game.
    Call that pair *x*. Each team’s games are played in order, so if we used *x* as
    a rivalry game, then we wouldn’t be allowed to also pair the second Geese game
    (played after *x*) with the first Hawks game (played before *x*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '*Characterizing Optimal Solutions*'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider an optimal solution to this problem: a solution that maximizes the
    number of goals scored in rivalry games. What might this optimal solution look
    like? Assume that the games for each team are numbered from 1 to *n*.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is that the optimal solution uses the final game *n* played by the
    Geese and the final game *n* played by the Hawks as a rivalry game. That game
    has a certain number of goals scored in it: call that *g*. We can then strip out
    both of these games and optimally solve the smaller subproblem on the Geese’s
    first *n*–1 games and the Hawks’ first *n*–1 games. That subproblem solution,
    plus *g*, is the optimal solution overall. Note, though, that this option is only
    available if the two *n* games can really be a rivalry game. For example, if both
    teams have a `W` for that game, then this cannot be a rivalry game and Option
    1 cannot apply.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Remember this test case from the prior section?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That’s an example of Option 1: we match the two rightmost scores, `8` and `3`,
    and then optimally solve the subproblem for the remaining games.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Another option is that the optimal solution has nothing to do with these final
    games at all. In that case, we strip out game *n* played by the Geese and game
    *n* played by the Hawks, and we optimally solve the subproblem on the Geese’s
    first *n* – 1 games and the Hawks’ first *n* – 1 games.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test case from the prior section that is an example of Option 2:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `1` and `8` at the right are not part of an optimal solution. The optimal
    solution for the other games is the optimal solution overall.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve covered the case where both game *n* scores are used and the case
    where neither game *n* score is used. Are we done?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that we are not done, consider this test case from the previous section:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Option 1, matching the `2` and `1`, leads to a maximum of three goals in rivalry
    games. Option 2, throwing away both the `2` and `1`, leads to a maximum of zero
    goals in rivalry games. However, the maximum overall here is seven. Our coverage
    of types of optimal solutions, using only Option 1 and Option 2, is therefore
    spotty.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: What we need to be able to do here is drop a game from the Geese but not from
    the Hawks. Specifically, we’d like to drop the Geese’s second game and then solve
    the subproblem consisting of the Geese’s first game and *both* of the Hawks’ games.
    For symmetry, we should also be able to drop the second Hawks game and solve the
    resulting subproblem on the first Hawks game and both Geese games. Let’s get these
    two additional options in there.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Our third option is that the optimal solution has nothing to do with the Geese’s
    game *n*. In that case, we strip out game *n* played by the Geese, and we optimally
    solve the subproblem on the Geese’s first *n* – 1 games and the Hawks’ first *n*
    games.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 4**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Our fourth and final option is that the optimal solution has nothing to do with
    the Hawks’ game *n*. In that case, we strip out game *n* played by the Hawks,
    and we optimally solve the subproblem on the Geese’s first *n* games and the Hawks’
    first *n* – 1 games.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Options 3 and 4 induce a change in the structure of a solution to this problem—whether
    that solution uses recursion, memoization, or dynamic programming. In the previous
    problems of this chapter, our subproblems were characterized by only one varying
    parameter: *t* for Burger Fervor and *k* for Moneygrubbers. Without Options 3
    and 4, we’d have gotten away with a single parameter, *n*, for the Hockey Rivalry
    problem, too. That *n* parameter would have reflected the fact that we were solving
    a subproblem for the first *n* games played by the Geese and the first *n* games
    played by the Hawks. With Options 3 and 4 in the mix, however, these *n* values
    are no longer yoked: one can change when the other does not. For example, if we’re
    solving a subproblem concerning the first five games played by the Geese, this
    does not mean that we’re stuck looking at the first five games played by the Hawks.
    Symmetrically, a subproblem concerning the first five games played by the Hawks
    doesn’t tell us anything about the number of games played by the Geese.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore need two parameters for our subproblems: *i*, the number of games
    played by the Geese, and *j*, the number of games played by the Hawks.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: For a given optimization problem, the number of subproblem parameters could
    be one, two, three, or more. When confronting a new problem, I suggest beginning
    with one subproblem parameter. Then, think about the possible options for an optimal
    solution. Perhaps each option can be solved by solving one-parameter subproblems,
    in which case additional parameters are not required. However, sometimes it will
    be that one or more options require the solution to a subproblem that cannot be
    pinned down by one parameter. In these cases, a second parameter can often help.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of adding additional subproblem parameters is the larger subproblem
    space in which to couch our optimal solutions. The cost is the responsibility
    of solving more subproblems. Keeping the number of parameters small—one, two,
    or perhaps three—is key for designing fast solutions to optimization problems.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, I want to highlight an important difference between the way
    that we solved Burger Fervor and Moneygrubbers and the way that we’re solving
    Hockey Rivalry. In the two earlier problems, we focused on solving for exactly
    *t* minutes or exactly *k* apples. Here, by contrast, we’re not forcing our subproblems
    to use any specific game. For example, a subproblem involving the first *i* games
    played by the Geese isn’t forced to use Geese game *i*. The difference arose as
    a byproduct of our analysis of the structure of optimal solutions. Each time we
    use dynamic programming, we need to choose whether to use “exactly.” If we had
    chosen to use “exactly” for Hockey Rivalry, then we would have ended up with comparably
    slower and more complicated code. I’ve included that code in the online resources
    for this book—check it out once you’re done here!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: If you’re struggling to relate a problem to smaller subproblems, or struggling
    to solve subproblems efficiently, it’s worth adding or removing “exactly” and
    trying again. We’ll continue to practice identifying subproblems in the next chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 1: Recursion*'
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s now time for our recursive solution. Here’s the signature for the `solve`
    function that we’ll write this time:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first four parameters come directly from the current test case, while the
    fifth and sixth are the subproblem parameters. Here are brief descriptions of
    the parameters:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: outcome1   The array of `W` and `L` characters for the Geese
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: outcome2   The array of `W` and `L` characters for the Hawks
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: goals1   The array of goals scored for the Geese
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: goals2   The array of goals scored for the Hawks
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: i   The number of Geese games that we’re considering in this subproblem
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: j   The number of Hawks games that we’re considering in this subproblem
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The last two parameters—the ones specific to the current subproblem—are the
    only parameters that change on recursive calls.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: If we started each of the arrays at index `0`, as is standard for C arrays,
    then we’d have to keep in our minds that information for some game `k` was not
    at index `k` but at index `k - 1`. For example, information about game four would
    be at index `3`. To avoid this, we’ll store information about games starting at
    index `1`, so information about game four will be at index `4`. This leaves us
    with one less mistake to make! In addition, it frees up the value `0` to characterize
    zero games played.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The code for the recursive solution is given in [Listing 3-16](ch03.xhtml#ch03ex016).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 3-16: Solution 1*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a maximization problem: we want to maximize the number of goals scored
    in rivalry games. We start with a `max` function ❶—we’ll use that when we need
    to determine which of the options is best. We then declare four integer variables,
    one for each of the four options ➋.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with base cases: What do we return if both `i` and `j` are `0`?
    This subproblem is for the first zero Geese games and zero Hawks games. Since
    there are no games, there are certainly no rivalry games, and since there are
    no rivalry games, there are no goals scored in rivalry games. We should therefore
    return `0` here.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'That isn’t the only base case, though. For example, consider the subproblem
    where the Geese play zero games (`i = 0`) and the Hawks play three games (`j =
    3`). As with the case in the prior paragraph, there can’t be any rivalry games
    here, because the Geese don’t have any games! A similar situation arises when
    the Hawks play zero games: even if the Geese play some games, none of them can
    be against the Hawks.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: That captures all of the base cases. That is to say, if `i` has value `0` *or*
    `j` has value `0`, then we have zero goals scored in rivalry games ➌.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: With the base cases out of the way, we must now try the four possible options
    for an optimal solution and choose the best one.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that this option is valid only when the final Geese game and final Hawks
    game can be a rivalry game. There are two ways for this game to be a rivalry game:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The Geese win, the Hawks lose, and the Geese score more goals than the Hawks.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Geese lose, the Hawks win, and the Geese score fewer goals than the Hawks.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We encode these two possibilities ➍. If the game can be a rivalry game, we
    compute the optimal solution for this option ➎: it consists of the optimal solution
    for the first `i - 1` Geese games and `j - 1` Hawks games plus the total goals
    scored in the rivalry game.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: For this one, we solve the subproblem for the first `i - 1` Geese games and
    `j - 1` Hawks games ➏.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Here, we solve the subproblem for the first `i - 1` Geese games and `j` Hawks
    games ❼. Notice that `i` changes but `j` does not. This is exactly why we need
    two subproblem parameters here, not one.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 4**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We solve the subproblem for the first `i` Geese games and `j - 1` Hawks games
    ❽. Again, one subproblem parameter changes but the other does not; it’s a good
    thing there’s no need for us to keep them at the same value!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'There we go: `first`, `second`, `third`, and `fourth`—those are the only four
    possibilities for our optimal solution. We want the maximum of these, and that
    is what we compute and return ❾. The innermost `max` call calculates the maximum
    of `third` and `fourth`. Working outward, the next `max` call calculates the maximum
    of that winner and `second`. Finally, the outermost call calculates the maximum
    of that winner and `first`.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: We’re just about there. All we need now is a `main` function that reads the
    five lines of input and calls `solve`. The code is given in [Listing 3-17](ch03.xhtml#ch03ex017).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 3-17: The main function*'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We declare the outcome (`W` and `L`) ❶ and goals-scored arrays ➋. The `+ 1`
    there is because of our choice to begin indexing at `1`. If we had used just `SIZE`,
    then valid indices would go from zero to 999, when what we need is to include
    index 1,000.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: We then read the integer on the first line ➌, which gives the number of games
    played by the Geese and Hawks. There’s a space right after the `%d` and before
    the closing quote. That space causes `scanf` to read whitespace following the
    integer. Crucially, this reads the newline character at the end of the line, which
    otherwise would be included when we use `scanf` to read individual characters
    . . . which we do next!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: We read the `W` and `L` information for the Geese and then read the goals-scored
    information for the Geese. We then do the same for the Hawks. Finally, we call
    `solve`. We want to solve the problem considering all *n* Geese games and all
    *n* Hawks games, which explains why the last two arguments are `n`. We know exactly
    how to call `solve` to get our answer in one shot; unlike for our solutions to
    Burger Fervor and Moneygrubbers, we don’t need to search for it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Any chance you’ll submit this solution to the judge? The “Time-Limit Exceeded”
    error should come as no surprise.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 2: Memoization*'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Burger Fervor and Moneygrubbers, we used a one-dimensional array for the
    memo. That’s because our subproblems had but one parameter: the number of minutes
    and number of apples, respectively. In contrast, the subproblems in Hockey Rivalry
    have two parameters, not one. We’ll correspondingly need a memo array with two
    dimensions, not one. Element `memo[i][j]` is used to hold the solution to the
    subproblem on the first `i` Geese games and the first `j` Hawks games. Other than
    switching from one to two dimensions in the memo, the technique remains as before:
    return the solution if it’s already stored; calculate and store it if it’s not.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The updated `main` function is given in [Listing 3-18](ch03.xhtml#ch03ex018).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 3-18: The main function, with memoization implemented*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `memo` array is huge—over 1,000 elements in each dimension and
    therefore over 1 million elements in all—so we make the array static as in [Listing
    1-8](ch01.xhtml#ch01ex08).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The memoized `solve` function is given in [Listing 3-19](ch03.xhtml#ch03ex019).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 3-19: Solution 2, with memoization implemented*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: This solution passes all test cases and does so quickly. If we just wanted to
    solve this problem, we would stop right now, but here we have the opportunity
    to plumb further and learn more about dynamic programming as we do so.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '*Solution 3: Dynamic Programming*'
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We just saw that to memoize this problem we needed a two-dimensional `memo`
    array, not a one-dimensional array. To develop a dynamic-programming solution,
    we’ll correspondingly need a two-dimensional `dp` array. We declared the `memo`
    array as follows in [Listing 3-18](ch03.xhtml#ch03ex018):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'and we’ll do likewise for the `dp` array:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As in the `memo` array, element `dp[i][j]` will hold the subproblem solution
    for the first `i` Geese games and first `j` Hawks games. Our task, then, is to
    solve each of these subproblems and return `dp[n][n]` once we’re done.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In memoized solutions to optimization problems, it’s not our responsibility
    to determine an order in which to solve the subproblems. We make our recursive
    calls, and those calls return to us the solutions for their corresponding subproblems.
    In dynamic-programming solutions, however, it *is* our responsibility to determine
    an order in which to solve the subproblems. We can’t just solve them in any order
    we want, because then a subproblem solution might not be available when we need
    it.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we wanted to fill in `dp[3][5]`—that’s the cell for the
    first three Geese games and the first five Hawks games. Take another look back
    at the four options for an optimal solution.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 requires us to look up `dp[2][4]`.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 2 also requires us to look up `dp[2][4]`.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 3 requires us to look up `dp[2][5]`.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option 4 requires us to look up `dp[3][4]`.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must arrange it so that these elements of `dp` are already stored by the
    time we want to store `dp[3][5]`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: For subproblems with only one parameter, you generally solve those subproblems
    from smallest index to largest index. For subproblems with more than one parameter,
    things are not so simple, as there are many more orders in which the array can
    be filled. Only some of these orders maintain the property that a subproblem solution
    is available by the time we need it.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: For the Hockey Rivalry problem, we can solve `dp[i][j]` if we’ve already stored
    `dp[i - 1][j - 1]` (Option 1 and Option 2), `dp[i - 1][j]` (Option 3), and `dp[i][j
    - 1]` (Option 4). One order we can use is to solve all of the `dp[i - 1]` subproblems
    before solving any of the `dp[i]` subproblems. For example, this would result
    in `dp[2][4]` being solved before `dp[3][5]`, which is exactly what we need to
    satisfy Options 1 and 2\. It would also result in `dp[2][5]` being solved before
    `dp[3][5]`, which is what we need for Option 3\. That is, solving row `i - 1`
    before row `i` satisfies Options 1 to 3.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy Option 4, we can solve the `dp[i]` subproblems from smallest `j`
    index to largest `j` index. That, for example, would solve `dp[3][4]` before `dp[3][5]`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we solve all of the subproblems in row `0` from left to right, then
    all of the subproblems in row `1` from left to right, and so on, until we have
    solved all subproblems in row `n`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The `solve` function is given in [Listing 3-20](ch03.xhtml#ch03ex020).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 3-20: Solution 3, with dynamic programming*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We begin by initializing the base case subproblems, which are those in which
    at least one of the indices is `0`. Then, we hit the double `for` loop ❶ ➋, which
    controls the order in which the non-base-case subproblems are solved. We first
    range over the rows ❶ and then the elements in each row ➋, which, as we have argued,
    is a valid order for solving the subproblems. Once we have filled in the table,
    we return the solution for the original problem ➌.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: We’re solving *n*² subproblems here, each of which takes us a constant number
    of steps. Therefore, we’ve achieved an *O*(*n*²) solution.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the array produced by a two-dimensional dynamic-programming
    algorithm as a table. This is helpful for getting a feel for how the elements
    of the array are filled in. Let’s look at the final array for the following test
    case:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the resulting array:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch03fig01.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: Consider, for example, the computation for the element in row `4`, column `2`
    or, in terms of the `dp` table, `dp[4][2]`. This is the subproblem for the first
    four Geese games and first two Hawks games. Looking at the Geese’s game four and
    the Hawks’ game two, we see that the Geese won with eight goals and the Hawks
    lost with one goal, so this game could be a rivalry game. Option 1 is therefore
    a possible option. Nine goals were scored in this game. To that nine, we add the
    value at row `3`, column `1`, which is nine again. This gives us a total of 18\.
    That’s our maximum so far—now we have to try Options 2 to 4 to see whether they
    are better. If you do that, you should observe that they all happen to have the
    value nine. We therefore store 18, the maximum of all available options, in `dp[4][2]`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The only quantity of real interest here, of course, is that in the topmost,
    rightmost cell, corresponding to the subproblem allowing the full `n` games for
    the Geese and `n` games for the Hawks. That value, 20, is what we return as the
    optimal solution. The other quantities in the table are only useful insofar as
    they help us make progress toward calculating that 20.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the `main` function, we make one small change to the code of [Listing
    3-17](ch03.xhtml#ch03ex017): the only thing to do is remove the second `n` passed
    to `solve`, resulting in:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*A Space Optimization*'
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I mentioned in “Step 4: Dynamic Programming” on [page 97](#sec44) that memoization
    and dynamic programming are roughly equivalent. *Roughly*, because sometimes there
    are benefits to be had by choosing one or the other. The Hockey Rivalry problem
    furnishes an example of a typical optimization that we can perform when using
    dynamic programming but not when using memoization. The optimization is not one
    of speed but of space.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the key question: When solving a subproblem in row `i` of the `dp` array,
    which rows do we access? Look back at the four options. The only rows used are
    `i - 1` (the previous row) and `i` (the current row). There’s no `i - 2` or `i
    - 3` or anything else in there. As such, keeping the entire two-dimensional array
    in memory is wasteful. Suppose we’re solving subproblems in row 500\. All we need
    is access to row 500 and row 499\. We might as well not have row 498 or 497 or
    496 or any other row in memory, because we’ll never look at these again.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than a two-dimensional table, we can pull through with only two one-dimensional
    arrays: one for the previous row and one for the current row we are solving.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-21](ch03.xhtml#ch03ex021) implements this optimization.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 3-21: Solution 3, with space optimization implemented*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: We initialize `previous` to all zeros ❶ ➋, thereby solving all subproblems in
    row `0`. In the rest of the code, whenever we previously referred to row `i -
    1`, we now use `previous`. In addition, whenever we previously referred to row
    `i`, we now use `current`. Once a new row has been fully solved and stored in
    `current`, we copy `current` into `previous` ➌ ➍ so that `current` can be used
    to solve the next row.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve presented what I think of as the core of memoization and dynamic programming:
    explicating the structure of an optimal solution, developing a recursive algorithm,
    speeding it up through memoization, and optionally replacing the recursion by
    filling a table.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to learn, though. What if I showed you how to crack some nasty
    dynamic-programming problems merely through a change in perspective? What if I
    told you that we can work with three or more dimensions to solve the toughest
    dynamic-programming problems?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn all that and more. See you there!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hockey Rivalry is originally from the 2018 Canadian Computing Olympiad.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you need to know not only the value of an optimal solution, but
    the decisions that you should make to achieve that solution. Check out “Burger
    Fervor: Reconstructing a Solution” in [Appendix B](app02.xhtml) for an example
    of how to do this.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Many algorithm textbooks delve deeper into the theory and application of memoization
    and dynamic programming. My favorite treatment is *Algorithm Design* by Jon Kleinberg
    and Éva Tardos (2006).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
