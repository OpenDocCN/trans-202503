- en: Chapter 4. User Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 用户管理
- en: Android originally targeted personal devices such as smartphones and assumed
    that each device had only one user. With the increase in popularity of tablets
    and other shared devices, multi-user support was added in version 4.2 and extended
    in later versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android 最初是面向个人设备（如智能手机）的，假设每个设备只有一个用户。随着平板电脑和其他共享设备的普及，Android 在 4.2 版本中增加了多用户支持，并在后续版本中进行了扩展。
- en: In this chapter, we’ll discuss how Android manages users who share devices and
    data. We begin with a look at the types of users Android supports and how it stores
    user metadata. We then discuss how Android shares installed applications between
    users while isolating application data and keeping it private to each user. Finally,
    we cover how Android implements isolated external storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Android 如何管理共享设备和数据的用户。我们首先介绍 Android 支持的用户类型及其如何存储用户元数据。接着，我们讨论 Android
    如何在用户之间共享已安装的应用程序，同时隔离应用程序数据并确保每个用户的数据隐私。最后，我们讲解 Android 如何实现隔离的外部存储。
- en: Multi-User Support Overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多用户支持概述
- en: Android’s multi-user support allows multiple users to share a single device
    by providing each user with an isolated, personal environment. Each user can have
    their own home screen, widgets, apps, online accounts, and files that are not
    accessible to other users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的多用户支持允许多个用户共享同一设备，通过为每个用户提供一个独立的、个人化的环境。每个用户可以拥有自己的主屏幕、小部件、应用程序、在线账户和文件，这些内容对其他用户不可访问。
- en: 'Users are identified by a unique *user ID* (not to be confused with Linux UIDs)
    and only the system can switch between users. User switching is normally triggered
    by selecting a user from the Android lockscreen and (optionally) authenticating
    using a pattern, PIN, password, and so on (see [Chapter 10](ch10.html "Chapter 10. Device
    Security")). Applications can get information about the current user via the `UserManager`
    API, but typically code modification is not required in order to support a multi-user
    environment. Applications that need to modify their behavior when used by a restricted
    profile are an exception: these applications require additional code that checks
    what restrictions (if any) are imposed on the current user (see “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for details).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过一个独特的*用户ID*（不要与Linux的UID混淆）进行标识，只有系统可以在用户之间切换。用户切换通常通过从 Android 锁屏界面选择一个用户来触发，并（可选地）通过图案、PIN、密码等方式进行身份验证（详见[第10章](ch10.html
    "第10章 设备安全")）。应用程序可以通过 `UserManager` API 获取当前用户的信息，但通常不需要修改代码即可支持多用户环境。需要在受限配置文件下修改行为的应用程序是一个例外：这些应用程序需要额外的代码来检查当前用户所施加的任何限制（详见“[受限配置文件](ch04.html#restricted_profiles
    "受限配置文件")”了解详情）。
- en: Multi-user support is built into the core Android platform and is thus available
    on all devices that run Android 4.2 or later. However, the default platform configuration
    only allows for a single user, which effectively disables multi-user support.
    In order to enable support for multiple users, the *config_multiuserMaximumUsers*
    system resource must be set to a value greater than one, typically by adding a
    device-specific overlay configuration file. For example, on the Nexus 7 (2013),
    the overlay is placed in the *device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml*
    file and the *config_multiuserMaximumUsers* setting is defined as shown in [Example 4-1](ch04.html#enabling_multi-user_support_with_a_resou
    "Example 4-1. Enabling multi-user support with a resource overlay file"), to allow
    a maximum of eight users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多用户支持内建于 Android 核心平台，因此在所有运行 Android 4.2 或更高版本的设备上均可使用。然而，默认的平台配置只允许单个用户，这实际上禁用了多用户支持。为了启用多用户支持，*config_multiuserMaximumUsers*
    系统资源必须设置为大于 1 的值，通常通过添加设备特定的覆盖配置文件来实现。例如，在 Nexus 7（2013）上，覆盖文件放置在 *device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml*
    文件中，*config_multiuserMaximumUsers* 设置如下所示，在[示例 4-1](ch04.html#enabling_multi-user_support_with_a_resou
    "示例 4-1. 使用资源覆盖文件启用多用户支持")中定义，允许最多支持 8 个用户。
- en: Example 4-1. Enabling multi-user support with a resource overlay file
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. 使用资源覆盖文件启用多用户支持
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Android Compatibility Definition requires that devices that support telephony
    (such as mobile phones) must not enable multi-user support because “the behavior
    of the telephony APIs on devices with multiple users is currently undefined.”*^([[29](#ftn.ch04fn01)])
    *Therefore, in current production builds, all handsets are configured as single-user
    devices.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android 兼容性定义要求支持电话功能的设备（如手机）不得启用多用户支持，因为“目前多用户设备上的电话 API 行为未定义。”*^([[29](#ftn.ch04fn01)])
    *因此，在当前的生产版本中，所有手机都被配置为单用户设备。*'
- en: When multi-user support is enabled, the system Settings application displays
    a Users entry that allows the device owner (the first user created, as discussed
    in the next section) to create and manage users. The user management screen is
    shown in [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User management
    screen").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用多用户支持时，系统设置应用会显示一个“用户”条目，允许设备所有者（下一节中讨论的第一个创建的用户）创建和管理其他用户。[图 4-1](ch04.html#user_management_screen
    "图 4-1. 用户管理屏幕") 显示了用户管理屏幕。
- en: '![User management screen](figs/web/04fig01.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![用户管理屏幕](figs/web/04fig01.png.jpg)'
- en: Figure 4-1. User management screen
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1. 用户管理屏幕
- en: As soon as more than one user has been created, the lockscreen shows a user
    widget that displays the current users and allows switching to a different user.
    [Figure 4-2](ch04.html#lockscreen_with_user_switcher_widget "Figure 4-2. Lockscreen
    with user switcher widget") shows how the lockscreen might look on a device with
    eight users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了多个用户，锁屏上会显示一个用户小部件，显示当前用户并允许切换到其他用户。[图 4-2](ch04.html#lockscreen_with_user_switcher_widget
    "图 4-2. 带有用户切换小部件的锁屏") 展示了一个包含八个用户的设备上的锁屏界面。
- en: '![Lockscreen with user switcher widget](figs/web/04fig02.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![带有用户切换小部件的锁屏](figs/web/04fig02.png.jpg)'
- en: Figure 4-2. Lockscreen with user switcher widget
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2. 带有用户切换小部件的锁屏
- en: Types of Users
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类型
- en: Even though Android lacks the full user management features of most multi-user
    operating systems, which typically allow users to add multiple administrators
    and define user groups, it does support configuring user types with different
    privileges. Each user type and its privileges will be described in the following
    sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Android 缺乏大多数多用户操作系统的完整用户管理功能，这些操作系统通常允许用户添加多个管理员并定义用户组，但它确实支持配置具有不同权限的用户类型。每种用户类型及其权限将在接下来的章节中详细描述。
- en: The Primary User (Owner)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要用户（所有者）
- en: 'The *primary user*, also known as the device *owner*, is the first user created
    on a multi-user device, or the sole user on single-user devices. The owner is
    created by default and is always present. The primary user is assigned user ID
    0\. On single-user devices where the primary user is the only user, Android behaves
    much like previous versions that lacked multi-user support: directories and UIDs
    assigned to installed applications maintain the same format and permissions as
    in previous versions (see “[User Management](ch04.html#user_management-id00008
    "User Management")” and “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")” for details).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要用户*，也称为设备的*所有者*，是多用户设备上创建的第一个用户，或者是单用户设备上的唯一用户。所有者默认创建并始终存在。主要用户被分配用户 ID
    0。在单用户设备上，主要用户是唯一用户，Android 的行为类似于没有多用户支持的早期版本：已安装应用程序分配的目录和 UID 保持与早期版本相同的格式和权限（详细内容请参见“[用户管理](ch04.html#user_management-id00008
    "用户管理")”和“[应用程序共享](ch04.html#application_sharing "应用程序共享")”）。'
- en: The primary user is assigned all privileges and can create and delete other
    users, as well as change system settings that affect all users, including settings
    related to device security, network connectivity, and application management.
    Device and user management privileges are granted to the primary user by showing
    the respective settings screens in system settings and hiding them from other
    users. Additionally, the underlying system services check the identity of the
    calling user before performing operations that can affect all users, and only
    allow execution when called by the device owner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用户被分配所有权限，可以创建和删除其他用户，并更改影响所有用户的系统设置，包括与设备安全性、网络连接性和应用程序管理相关的设置。设备和用户管理权限通过在系统设置中显示相关设置界面并将其隐藏于其他用户之外来授予主要用户。此外，底层系统服务在执行可能影响所有用户的操作之前，会检查调用用户的身份，仅当由设备所有者调用时才允许执行。
- en: 'As of Android version 4.4, the following screens in the Wireless and Networks
    section of system settings are displayed to only the primary user:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Cell broadcasts
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage mobile plan
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile network
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tethering and portable hotspot
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPN
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WiMAX (shown if supported by the device)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screens in the Security section are also reserved for the primary
    user:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Device encryption
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SIM card lock
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown sources (controls app sideloading; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify apps (controls package verification; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary Users
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the exception of restricted profiles (discussed in the next section), all
    added users are *secondary users*. Each gets a dedicated user directory (see “[User
    Management](ch04.html#user_management-id00008 "User Management")”), their own
    list of installed apps, and private data directories for each installed app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Secondary users cannot add or manage users; they can only set their own username
    via the Users screen (see [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User
    management screen")). Additionally, they cannot perform any privileged operation
    reserved for the primary user as listed in the previous sections. Otherwise, secondary
    users can perform all the operations that a primary user can, including installing
    and using applications, and changing the system appearance and settings.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Although secondary users are restricted, their actions can still affect device
    behavior and other users. For example, they can add and connect to a new Wi-Fi
    network. Because Wi-Fi connectivity state is shared across the system, switching
    to a different user does not reset the wireless connection, and that user will
    be connected to the wireless network selected by the previous user. Secondary
    users can also toggle airplane mode and NFC, and change the global sound and display
    settings. Most importantly, as application packages are shared across all users
    (as discussed in “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")”), if a secondary user updates an application that adds new permissions,
    permissions are granted to the application without requiring the consent of other
    users, and other users are not notified of permission changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Restricted Profiles
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike secondary users, restricted profiles (added in Android 4.3) are based
    on the primary user and share its applications, data, and accounts, with certain
    restrictions. As such, the primary user must set up a lockscreen password in order
    to protect their data. If no lockscreen password is in place when the primary
    user creates a restricted profile, Android prompts them to set up one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: User Restrictions
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android defines the following default restrictions in order to control what
    users are allowed to do. All restrictions are `false` by default. The list below
    shows their value for restricted users in parentheses.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '****`DISALLOW_CONFIG_BLUETOOTH`****. Specifies whether a user is prevented
    from configuring Bluetooth. (default: `false`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_BLUETOOTH`****。指定是否禁止用户配置蓝牙。（默认值：`false`）'
- en: '****`DISALLOW_CONFIG_CREDENTIALS`****. Specifies whether a user is prevented
    from configuring user credentials. When this restriction is set to `true`, restricted
    profiles cannot add trusted CA certificates or import private keys into the system
    credential store; see [Chapter 6](ch06.html "Chapter 6. Network Security and PKI")
    and [Chapter 7](ch07.html "Chapter 7. Credential Storage") for details. (default:
    `false`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_CREDENTIALS`****。指定是否禁止用户配置用户凭证。当该限制设置为 `true` 时，受限配置文件无法向系统凭证存储中添加受信任的
    CA 证书或导入私钥；有关详细信息，请参见 [第 6 章](ch06.html "第 6 章：网络安全和 PKI") 和 [第 7 章](ch07.html
    "第 7 章：凭证存储")。（默认值：`false`）'
- en: '****`DISALLOW_CONFIG_WIFI`****. Specifies whether a user is prevented from
    changing Wi-Fi access points. (default: `false`)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_WIFI`****。指定是否禁止用户更改 Wi-Fi 接入点。（默认值：`false`）'
- en: '****`DISALLOW_INSTALL_APPS`****. Specifies whether a user is prevented from
    installing applications. (default: `false`)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_INSTALL_APPS`****。指定是否禁止用户安装应用程序。（默认值：`false`）'
- en: '****`DISALLOW_INSTALL_UNKNOWN_SOURCES`****. Specifies whether a user is prevented
    from enabling the Unknown sources setting (see [Chapter 3](ch03.html "Chapter 3. Package
    Management")). (default: `false`)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_INSTALL_UNKNOWN_SOURCES`****。指定是否禁止用户启用未知来源设置（见 [第 3 章](ch03.html
    "第 3 章：包管理")）。（默认值：`false`）'
- en: '****`DISALLOW_MODIFY_ACCOUNTS`****. Specifies whether a user is prevented from
    adding and removing accounts. (default: `true`)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_MODIFY_ACCOUNTS`****。指定是否禁止用户添加和删除账户。（默认值：`true`）'
- en: '****`DISALLOW_REMOVE_USER`****. Specifies whether a user is prevented from
    removing users. (default: `false`)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_REMOVE_USER`****。指定是否禁止用户删除其他用户。（默认值：`false`）'
- en: '****`DISALLOW_SHARE_LOCATION`****. Specifies whether a user is prevented from
    toggling location sharing. (default: `true`)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_SHARE_LOCATION`****。指定是否禁止用户切换位置共享。（默认值：`true`）'
- en: '****`DISALLOW_UNINSTALL_APPS`****. Specifies whether a user is prevented from
    uninstalling applications. (default: `false`)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_UNINSTALL_APPS`****。指定是否禁止用户卸载应用程序。（默认值：`false`）'
- en: '****`DISALLOW_USB_FILE_TRANSFER`****. Specifies whether a user is prevented
    from transferring files over USB. (default: `false`)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_USB_FILE_TRANSFER`****。指定是否禁止用户通过 USB 转移文件。（默认值：`false`）'
- en: Applying Restrictions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用限制
- en: 'At runtime, applications can use the `UserManager.getUserRestrictions()` method
    to get a `Bundle` (a universal container class that maps string keys to various
    value types) containing the restrictions imposed on a user. Restrictions are defined
    as key-value pairs, where the key is the restriction name and the Boolean value
    specifies whether it is in effect. Applications can use that value in order to
    disable certain functionality when running within a restricted profile. For example,
    the system Settings app checks the value of the `DISALLOW_SHARE_LOCATION` restriction
    when displaying location preferences. If the value is `true`, it disables the
    location mode setting. Another example is the `PackageManagerService`: it checks
    the `DISALLOW_INSTALL_APPS` and `DISALLOW_UNINSTALL_APPS` restrictions before
    installing or uninstalling apps and returns the `INSTALL_FAILED_USER_RESTRICTED`
    error code if any of those restrictions are set to `true` for the calling user.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，应用程序可以使用 `UserManager.getUserRestrictions()` 方法获取一个包含用户限制的 `Bundle`（一个将字符串键映射到各种值类型的通用容器类）。限制被定义为键值对，其中键是限制名称，布尔值指定该限制是否生效。应用程序可以使用该值来禁用在受限配置文件下运行时的某些功能。例如，系统设置应用会在显示位置偏好时检查
    `DISALLOW_SHARE_LOCATION` 限制的值。如果值为 `true`，则禁用位置模式设置。另一个例子是 `PackageManagerService`：它会在安装或卸载应用之前检查
    `DISALLOW_INSTALL_APPS` 和 `DISALLOW_UNINSTALL_APPS` 限制，并在这些限制中的任何一个被设置为 `true`
    时返回 `INSTALL_FAILED_USER_RESTRICTED` 错误代码。
- en: The primary user can select which applications will be available to a restricted
    profile. When a restricted profile is created, all installed applications are
    initially disabled, and the owner must explicitly enable the ones that they want
    to make available to the restricted profile (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用户可以选择哪些应用程序对受限配置文件可用。当创建受限配置文件时，所有已安装的应用程序默认会被禁用，所有者必须明确启用他们希望让受限配置文件使用的应用程序（见
    [图 4-3](ch04.html#restricted_profile_management_screen "图 4-3：受限配置文件管理屏幕")）。
- en: '![Restricted profile management screen](figs/web/04fig03.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![受限个人资料管理界面](figs/web/04fig03.png.jpg)'
- en: Figure 4-3. Restricted profile management screen
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3. 受限个人资料管理界面
- en: In addition to the built-in restrictions defined by the OS, applications can
    define custom restrictions by creating a `BroadcastReceiver` that receives the
    `ACTION_GET_RESTRICTION_ENTRIES` intent. Android invokes this intent to query
    all apps for available restrictions and automatically builds a UI that allows
    device owners to toggle the app’s custom restrictions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作系统定义的内置限制外，应用程序还可以通过创建一个接收`ACTION_GET_RESTRICTION_ENTRIES`意图的`BroadcastReceiver`来定义自定义限制。Android会调用此意图查询所有应用程序的可用限制，并自动构建一个用户界面，允许设备所有者切换应用程序的自定义限制。
- en: At runtime, applications can use the `UserManager.getApplicationRestrictions()`
    method to obtain a `Bundle` that contains saved restrictions as key-value pairs.
    The application can then disable or modify certain features based on the applied
    restrictions. The device owner can toggle system and custom restrictions on the
    same settings screen used to manage applications available to a restricted profile.
    For example, in [Figure 4-3](ch04.html#restricted_profile_management_screen "Figure 4-3. Restricted
    profile management screen"), the single application restriction supported by the
    Settings app (whether to let apps use location information) is shown below the
    main application toggle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，应用程序可以使用`UserManager.getApplicationRestrictions()`方法获取一个包含保存的限制条件的`Bundle`，这些限制以键值对的形式存储。然后，应用程序可以根据所应用的限制禁用或修改某些功能。设备所有者可以在同一个设置界面上切换系统和自定义限制，这个界面用于管理可供受限个人资料使用的应用程序。例如，在[图4-3](ch04.html#restricted_profile_management_screen
    "图4-3. 受限个人资料管理界面")中，设置应用程序支持的单一应用程序限制（是否允许应用程序使用位置信息）显示在主应用程序切换按钮下方。
- en: Access to Online Accounts
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问在线帐户
- en: Restricted profiles can also access the online accounts of the primary user
    via the `AccountManager` API (see [Chapter 8](ch08.html "Chapter 8. Online Account
    Management")), but this access is disabled by default. Applications that need
    access to accounts when running within a restricted profile must explicitly declare
    the account types they require using the `restrictedAccountType` attribute of
    the `<application>` tag, as shown in [Example 4-2](ch04.html#allowing_access_to_the_ownerapostrophes
    "Example 4-2. Allowing access to the owner’s accounts from a restricted profile").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 受限个人资料也可以通过`AccountManager` API访问主用户的在线帐户（参见[第8章](ch08.html "第8章. 在线帐户管理")），但默认情况下该访问是禁用的。需要访问帐户的应用程序在受限个人资料下运行时，必须明确声明它们所需的帐户类型，使用`<application>`标签的`restrictedAccountType`属性，如[示例4-2](ch04.html#allowing_access_to_the_ownerapostrophes
    "示例4-2. 允许受限个人资料访问所有者的帐户")所示。
- en: Example 4-2. Allowing access to the owner’s accounts from a restricted profile
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-2. 允许受限个人资料访问所有者的帐户
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the other hand, applications that do not want to expose account information
    to restricted profiles can declare this by specifying the account type (an asterisk
    can be used to match all account types) as the value of the `requiredAccountType`
    attribute of the `<application>` tag. If the `requiredAccountType` attribute is
    specified, Android will automatically disable such applications for restricted
    profiles. For example, because the Android Calendar application declares `android:requiredAccountType="*"`
    in its manifest, it cannot be made available to restricted profiles and is disabled
    in the restrictions settings screen (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不希望向受限个人资料公开帐户信息的应用程序可以通过指定帐户类型（可以使用星号来匹配所有帐户类型）作为`<application>`标签的`requiredAccountType`属性的值来声明这一点。如果指定了`requiredAccountType`属性，Android将自动禁用这些应用程序的受限个人资料。例如，由于Android日历应用程序在其清单文件中声明了`android:requiredAccountType="*"`，因此无法向受限个人资料提供该应用程序，并且在限制设置界面中被禁用（参见[图4-3](ch04.html#restricted_profile_management_screen
    "图4-3. 受限个人资料管理界面")）。
- en: Guest User
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端用户
- en: Android supports a single guest user, but this functionality is disabled by
    default. While the guest user can be enabled by calling the `UserManager.setGuestEnabled()`
    method, the guest user does not appear to be referenced anywhere other than by
    the `UserManager` and related classes in current Android versions. Code comments
    indicate that the guest user might be transient, but as of this writing its exact
    purpose is not clear. It appears to be a remnant of a proposed feature that was
    rejected or never fully implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持单个访客用户，但该功能默认情况下是禁用的。虽然可以通过调用 `UserManager.setGuestEnabled()` 方法启用访客用户，但在当前
    Android 版本中，访客用户似乎只在 `UserManager` 和相关类中被引用。代码注释表明访客用户可能是临时的，但截至目前，其确切用途尚不明确。它似乎是一个被拒绝或从未完全实现的拟议功能的遗留物。
- en: User Management
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理
- en: Android users are managed by the `UserManagerService`, which is responsible
    for reading and persisting user information and maintaining the list of active
    users. Because user management is closely related to package management, the `PackageManagerService`
    calls the `UserManagerService` to query or modify users when packages are installed
    or removed. The `android.os.UserManager` class provides a facade to the `UserManagerService`
    and exposes a subset of its functionality to third-party applications. Applications
    can get the number of users on a system, a user’s serial number, the name and
    list of restrictions for the current user, as well as the list of restrictions
    for a package without the need for any special permissions. All other user operations,
    including querying, adding, removing, or modifying users, require the `MANAGE_USERS`
    system signature permission.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android 用户由 `UserManagerService` 管理，后者负责读取和持久化用户信息，并维护活跃用户的列表。由于用户管理与包管理密切相关，`PackageManagerService`
    在安装或移除包时会调用 `UserManagerService` 查询或修改用户。`android.os.UserManager` 类为 `UserManagerService`
    提供了一个外观，并将其部分功能暴露给第三方应用程序。应用程序可以获取系统中的用户数量、用户的序列号、当前用户的名称和限制列表，以及某个包的限制列表，而无需任何特殊权限。所有其他用户操作，包括查询、添加、删除或修改用户，都需要
    `MANAGE_USERS` 系统签名权限。
- en: Command-Line Tools
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行工具
- en: User management operations can also be performed on the Android shell with the
    `pm` command. These commands can be run via the shell without root permissions,
    because the *shell* user (UID 2000) is granted the `MANAGE_USERS` permission.
    You can use the `pm create-user` command to create a new user, and the `pm remove-user`
    to remove it. The command `pm get-max-users` returns the maximum number of users
    supported by the OS, and `pm list users` lists all users. The output of the `pm
    list users` command might look like [Example 4-3](ch04.html#listing_users_using_the_pm_list_command
    "Example 4-3. Listing users using the pm list command") on a device with five
    users. The numbers in curly braces are the user ID, name, and flags, in that order.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理操作也可以通过 Android shell 使用 `pm` 命令来执行。这些命令可以通过 shell 运行，无需 root 权限，因为 *shell*
    用户（UID 2000）被授予了 `MANAGE_USERS` 权限。你可以使用 `pm create-user` 命令创建新用户，使用 `pm remove-user`
    删除用户。命令 `pm get-max-users` 返回操作系统支持的最大用户数，而 `pm list users` 列出所有用户。`pm list users`
    命令的输出可能像 [示例 4-3](ch04.html#listing_users_using_the_pm_list_command "示例 4-3. 使用
    pm list 命令列出用户") 中的输出那样，显示设备上有五个用户。大括号中的数字依次表示用户 ID、姓名和标志。
- en: Example 4-3. Listing users using the `pm list` command
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 使用 `pm list` 命令列出用户
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: User States and Related Broadcasts
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户状态和相关广播
- en: The `UserManagerService` sends several broadcasts to notify other components
    of user-related events. When a user is added, it sends the `USER_ADDED` broadcast,
    and when a user is removed, it sends `USER_REMOVED`. If the user-name or their
    profile icon is changed, the `UserManagerService` sends the `USER_INFO_CHANGED`
    broadcast. Switching users triggers the `USER_BACKGROUND`, `USER_FOREGROUND`,
    and `USER_SWITCHED` broadcasts, all of which contain the relevant user ID as an
    extra.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManagerService` 会发送多个广播来通知其他组件有关用户的事件。当添加用户时，它会发送 `USER_ADDED` 广播；当移除用户时，它会发送
    `USER_REMOVED` 广播。如果用户名称或头像被更改，`UserManagerService` 会发送 `USER_INFO_CHANGED` 广播。切换用户时，会触发
    `USER_BACKGROUND`、`USER_FOREGROUND` 和 `USER_SWITCHED` 广播，所有这些广播都会包含相关的用户 ID 作为附加信息。'
- en: While Android supports a maximum of eight users, only three users can be running
    at a time. A user is started when it is first switched to via the lockscreen user
    switcher. Android stops inactive users based on a least recently used (LRU) cache
    algorithm to ensure that no more than three users are active.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android最多支持八个用户，但一次只能有三个用户处于活动状态。当通过锁屏用户切换器首次切换到某个用户时，该用户会被启动。Android根据最少最近使用（LRU）缓存算法停止不活跃的用户，以确保最多只有三个用户处于活动状态。
- en: When a user is stopped, its processes are killed and it no longer receives any
    broadcasts. When users are started or stopped, the system sends the `USER_STARTING`,
    `USER_STARTED`, `USER_STOPPING`, and `USER_STOPPED` broadcasts. The primary user
    is started automatically when the system boots and is never stopped.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户被停止时，其进程会被终止，且不再接收任何广播。启动或停止用户时，系统会发送`USER_STARTING`、`USER_STARTED`、`USER_STOPPING`和`USER_STOPPED`广播。主用户在系统启动时自动启动，并且永远不会停止。
- en: Starting, stopping, and switching users, as well as targeting a specific user
    with a broadcast, requires the `INTERACT_ACROSS_USERS` permission. This is a system
    permission with signature protection, but it also has the `development` flag set
    (see [Chapter 2](ch02.html "Chapter 2. Permissions")) so it can be dynamically
    granted to non-system applications that declare it (using the `pm grant` command).
    The `INTERACT_ACROSS_USERS_FULL` signature permission allows sending broadcasts
    to all users, changing the device administrator, as well as other privileged operations
    that affect all users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 启动、停止、切换用户，以及通过广播定位特定用户，需要`INTERACT_ACROSS_USERS`权限。这是一个具有签名保护的系统权限，但它也设置了`development`标志（见[第2章](ch02.html
    "第2章. 权限")），因此可以动态授予声明该权限的非系统应用（使用`pm grant`命令）。`INTERACT_ACROSS_USERS_FULL`签名权限允许向所有用户发送广播、更改设备管理员以及执行其他影响所有用户的特权操作。
- en: User Metadata
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户元数据
- en: Android stores user data in the */data/system/users/* directory that hosts metadata
    about users in XML format, as well as user directories. On a device with five
    users, its contents may look like [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/") (timestamps have been omitted).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Android将用户数据存储在*/data/system/users/*目录中，该目录包含以XML格式存储的用户元数据以及用户目录。在一个有五个用户的设备上，其内容可能类似于[示例
    4-4](ch04.html#contents_of_solidusdatasolidussystemsoli "示例 4-4. /data/system/users/目录内容")（时间戳已省略）。
- en: Example 4-4. Contents of /data/system/users/
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4. /data/system/users/目录内容
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The User List File
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户列表文件
- en: As shown in [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/"), each user has a dedicated directory
    called the *user system directory* with a name that matches the assigned user
    ID (➊ for the primary user) and an XML file that stores metadata about the user,
    again with a filename based on the user ID (➋ for the primary user). The *userlists.xml*
    file ➌ holds data about all users created on a system and may look like [Example 4-5](ch04.html#contents_of_userlistdotxml
    "Example 4-5. Contents of userlist.xml") on a system with five users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli "示例 4-4. /data/system/users/目录内容")所示，每个用户都有一个名为*用户系统目录*的专用目录，目录名与分配的用户ID匹配（➊为主用户），并且有一个存储用户元数据的XML文件，文件名同样基于用户ID（➋为主用户）。*userlists.xml*文件➌保存了关于系统上所有用户的数据，系统上有五个用户时，它可能类似于[示例
    4-5](ch04.html#contents_of_userlistdotxml "示例 4-5. userlist.xml文件内容")。
- en: Example 4-5. Contents of userlist.xml
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. userlist.xml文件内容
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The file format is basically a list of `<user>` tags holding the ID assigned
    to each user. The root `<users>` element has a `version` attribute specifying
    the current file version and a `nextSerialNumber` attribute holding the serial
    number to be assigned to the next user. The primary user is always assigned user
    ID 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式基本上是一个包含每个用户ID的`<user>`标签列表。根元素`<users>`具有一个`version`属性，指定当前文件版本，还有一个`nextSerialNumber`属性，表示下一个用户将分配的序列号。主用户的ID总是分配为0。
- en: The fact that UIDs assigned to applications are based on the user ID of the
    owning user ensures that on single-user devices, UIDs assigned to applications
    are the same as they were before multi-user support was introduced. (For more
    on application UIDs, see “[Application Data Directories](ch04.html#application_data_directories
    "Application Data Directories")”.) Secondary users and restricted profiles are
    assigned IDs beginning with the number 10.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: User Metadata Files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attributes of each user are stored in a dedicated XML file. [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents") shows an example for a restricted
    profile.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6. User metadata file contents
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `<name>` tag ➋ holds the user’s name and the `<restrictions>` tag
    ➌ has attributes for each enabled restriction. (See “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for a list of built-in restrictions.) [Table 4-1](ch04.html#less_thanusergreater_than_element_attrib
    "Table 4-1. <user> Element Attributes") summarizes the attributes of the root
    `<user>` element shown at ➊ in [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. <user> Element Attributes
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Format | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `id` | integer | User ID |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `serialNumber` | integer | User serial number |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `flags` | integer | Flags that indicate the type of user |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `created` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | User creation time |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `lastLoggedIn` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | Last login time |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `icon` | string | Full path to the user icon file |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `partial` | Boolean | Indicates that the user is partially initialized. Partial
    users may not have all of their files and directories created yet. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `pinHash` | hexadecimal string | The salted SHA1+MD5 PIN hash for PIN-protected
    restrictions |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `salt` | long integer | The PIN salt for PIN-protected restrictions |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `failedAttempts` | integer | The number of failed PIN entry attempts for
    PIN-protected restrictions |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `lastAttemptMs` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | The time of the last PIN entry attempt for PIN-protected restrictions (in milliseconds
    since the Unix epoch, per `System.currentTimeMillis()`) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: 'The `flags` attribute is one of the most important as it determines the user
    type. As of this writing, six bits of the flag value are used for the user type
    and the rest are reserved with the following flags currently defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**`FLAG_PRIMARY` (0x00000001)** Marks the primary user.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_ADMIN` (0x00000002)** Marks administrator users. Administrator can
    create and delete users.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_GUEST` (0x00000004)** Marks the guest user.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_RESTRICTED` (0x00000008)** Marks restricted users.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_INITIALIZED` (0x00000010)** Marks a user as fully initialized.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While different flag combinations are possible, most combinations don’t represent
    a valid user type or state, and in practice the attributes for the primary owner
    are set to 19 (0x13 or `FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY`), secondary
    users have flags 16 (0x10 or `FLAG_INITIALIZED`), and restricted profiles have
    flags 24 (0x18 or `FLAG_INITIALIZED|FLAG_RESTRICTED`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不同的标志组合是可能的，但大多数组合并不表示有效的用户类型或状态，实际中主拥有者的属性设置为19（0x13或`FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY`），辅助用户的标志为16（0x10或`FLAG_INITIALIZED`），限制配置文件的标志为24（0x18或`FLAG_INITIALIZED|FLAG_RESTRICTED`）。
- en: User System Directory
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户系统目录
- en: Each user system directory contains user-specific system settings and data but
    no application data. As we’ll see in the next section, each application that a
    user installs gets a dedicated data directory under */data*, much like on single-user
    devices. (See [Chapter 3](ch03.html "Chapter 3. Package Management") for more
    on application data directories.) For example, in the case of a secondary user
    with user ID 12, the user system directory would be named */data/system/users/12/*
    and might contain the files and directories listed in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户系统目录包含特定用户的系统设置和数据，但不包含应用数据。如我们在下一节中所看到的，每个用户安装的应用都会在*/data*目录下获得一个专用的数据目录，类似于单用户设备上的情况。（有关应用数据目录的更多信息，请参见[第3章](ch03.html
    "Chapter 3. Package Management")）。例如，对于用户ID为12的辅助用户，用户系统目录将命名为*/data/system/users/12/*，并可能包含[示例4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory")中列出的文件和目录。
- en: Example 4-7. Contents of a user directory
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-7. 用户目录的内容
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The file *accounts.db* ➊ is an SQLite database that holds online account details.
    (We discuss online account management in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").) The file *appwidgets.xml* ➋ holds information about widgets
    that the user has added to their home screen. The *device_policies.xml* ➌ file
    describes the current device policy (see [Chapter 9](ch09.html "Chapter 9. Enterprise
    Security") for details), and *gesture.key* ➍ and *password.key* ➐ contain the
    hash of the currently selected lockscreen pattern or PIN/password, respectively
    (see [Chapter 10](ch10.html "Chapter 10. Device Security") for format details).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*accounts.db* ➊是一个SQLite数据库，存储在线账户的详细信息。（我们在[第8章](ch08.html "Chapter 8. Online
    Account Management")中讨论在线账户管理。）文件*appwidgets.xml* ➋存储有关用户已添加到主屏幕的小部件的信息。*device_policies.xml*
    ➌文件描述了当前设备策略（有关详细信息，请参见[第9章](ch09.html "Chapter 9. Enterprise Security")），而*gesture.key*
    ➍和*password.key* ➐分别包含当前选定的锁屏图案或PIN码/密码的哈希值（有关格式的详细信息，请参见[第10章](ch10.html "Chapter
    10. Device Security")）。
- en: The *inputmethod* directory ➎ contains information about input methods. The
    *photo.png* file ➑ stores the user’s profile image or picture. The file *settings.db*
    ➒ holds system settings specific to that user, and *wallpaper* ➓ is the currently
    selected wallpaper image. The *package-restrictions.xml* file ➏ defines what applications
    the user has installed and stores their state. (We discuss application sharing
    and per-user application data in the next section.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*inputmethod*目录 ➎包含有关输入法的信息。*photo.png*文件 ➑存储用户的个人资料图片或照片。*settings.db*文件 ➒保存特定于该用户的系统设置，而*wallpaper*
    ➓是当前选定的壁纸图片。*package-restrictions.xml*文件 ➏定义了用户安装了哪些应用，并存储它们的状态。（我们将在下一节中讨论应用共享和每用户应用数据。）'
- en: Per-User Application Management
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每用户应用管理
- en: As mentioned in “[Multi-User Support Overview](ch04.html#multi-user_support_overview
    "Multi-User Support Overview")”, besides dedicated accounts and settings, each
    user gets their own copy of application data that cannot be accessed by other
    users. Android achieves this by assigning a new, per-user effective UID for each
    application and creating a dedicated application data directory owned by that
    UID. We’ll discuss the details of this implementation in the following sections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[多用户支持概述](ch04.html#multi-user_support_overview "Multi-User Support Overview")”中提到的，除了专用账户和设置外，每个用户都会获得自己的一份应用数据副本，其他用户无法访问。Android通过为每个应用分配一个新的、按用户划分的有效UID，并为该UID创建一个专用的应用数据目录来实现这一点。我们将在接下来的章节中讨论这一实现的细节。
- en: Application Data Directories
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数据目录
- en: As we covered in [Chapter 3](ch03.html "Chapter 3. Package Management"), Android
    installs APK packages by copying them to the */data/app/* directory, and creates
    a dedicated data directory for each application under */data/data/*. When multi-user
    support is enabled, this layout is not changed but extended to support additional
    users. Application data for the primary user is still stored in */data/data/*
    for backward compatibility.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: If other users exist on the system when a new application is being installed,
    the `PackageManagerService` creates application data directories for each user.
    As with the data directory for the primary user, those directories are created
    with the help of the *installd* daemon (using the `mkuserdata` command) because
    the *system* user does not have enough privileges to change directory ownership.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: User data directories are stored in */data/user/* and named after the user’s
    ID. The device owner directory (*0/*) is a symbolic link to */data/data/*, as
    shown in [Example 4-8](ch04.html#contents_of_solidusdatasolidususersolidu "Example 4-8. Contents
    of /data/user/ on a multi-user device").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. Contents of /data/user/ on a multi-user device
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The contents of each application data directory are the same as */data/ data/*,
    but application directories for each user’s instance of the same application are
    owned by a different Linux user, as shown in [Example 4-9](ch04.html#contents_of_application_data_directories
    "Example 4-9. Contents of application data directories for the primary user and
    one secondary user").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. Contents of application data directories for the primary user and
    one secondary user
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This listing shows the contents of the app data directories for the primary
    user ➊ and the secondary user with user ID 13 ➌. As you can see, even though both
    users have data directories for the same apps, such as the browser app (➋ for
    the owner and ➍ for the secondary user), those directories are owned by different
    Linux users: *u0_a16* in the case of the owner and *u13_a16* in the case of the
    secondary user. If we check the UID for those users using the `su` and `id` commands,
    we find that *u0_a16* has UID=10016, and *u13_a16* has UID=1310016.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that both UIDs contain the number 10016 is no coincidence. The repeating
    part is called the *app ID* and is the same as the UID assigned to the app when
    first installed on a single-user device. On multiuser devices, the app UID is
    derived from the user ID and the app ID using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because the owner’s user ID is always 0, the UIDs for the device owner’s apps
    are always the same as their app IDs. When the same application is executed in
    the context of different users, it executes under the respective UIDs assigned
    to each user’s application instance. For example, if the browser application is
    executed simultaneously by the device owner and a secondary user with user ID
    13, two separate processes running as the *u0_a16* and *u13_a16* Linux users will
    be created (UID 10016, for the owner ➊ and UID 1310016, for the secondary user
    ➋) as shown in [Example 4-10](ch04.html#process_information_for_the_browser_appl
    "Example 4-10. Process information for the browser application when executed by
    different device users").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. Process information for the browser application when executed
    by different device users
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Application Sharing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While installed applications have a dedicated data directory for each user,
    the APK files are shared among all users. The APK files are copied to */data/app/*
    and are readable by all users; shared libraries used by apps are copied to */data/app-lib/<package
    name>/* and are symlinked to */data/ user/<user ID>/<package name>/lib/*; and
    the optimized DEX files for each app are stored in */data/dalvik-cache/* and are
    also shared by all users. Thus once an application is installed, it is accessible
    to all device users, and an app data directory is automatically created for each
    user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Android makes it possible for users to have different applications by creating
    a *package-restrictions.xml* file (➏ in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory")) in the system directory of each
    user, which it uses to track whether an app is enabled for a user or not. Besides
    the install state of packages, this file contains information about the disabled
    components of each application, as well as a list of preferred applications to
    start when processing intents that can be handled by more than one application
    (such as opening a text file, for example). The contents of *package-restrictions.xml*
    might look like [Example 4-11](ch04.html#contents_of_the_package-restrictionsdotx
    "Example 4-11. Contents of the package-restrictions.xml file") for a secondary
    user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Contents of the package-restrictions.xml file
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `com.example.app` package is available on the system but is not installed
    for that secondary user, as expressed by adding a `<pkg>` for the app and setting
    the `inst` attribute to `false` ➊. Based on this information, the `PackageManagerService`
    marks the `com.example.app` package as not installed for that user and the package
    doesn’t show up in the launcher or the list of apps in Settings.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Applications can be installed but still marked as stopped, as shown at ➋. Here,
    the `com.example.app2` package is installed but marked as stopped by setting the
    `stopped` attribute to `true`. Android has a special state for applications that
    have never been launched; a state that is persisted with the `nl` attribute of
    the `<pkg>` tag. The device owner can block a package for a certain user, in which
    case the `blocked` attribute is set to `true`, though this is not shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When a device user installs an application, a `<pkg>` tag with `inst="false"`
    is added to the *package-restrictions.xml* files for all users. When another user
    installs the same application, the `inst` attribute is removed and the application
    is considered installed for that user. (Depending on how the second user started
    the install process, the APK file in */data/app/* may be replaced, as it is in
    an application update.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Restricted users cannot install applications, but the same procedure is applied
    when the device owner enables an app for a restricted user: the application is
    installed by calling the `PackageManagerService.installExistingPackageAsUser()`
    method, which sets the installed flag for the package and updates *package-restrictions.xml*
    accordingly.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Warning shown when the device owner tries to uninstall an app for all users](figs/web/04fig04.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When a user uninstalls a package, their app data is deleted and the internal
    per-user package installed flag is set to `false`. This state is then persisted
    by setting `inst="false"` to the removed package’s tag in the user’s *package-restrictions.xml*
    file. The APK file and native library directory are only removed when the last
    user that has the app installed uninstalls it. However, the owner can see all
    apps installed on the system in the All tab of the Apps Settings screen, including
    ones they haven’t installed, and they can uninstall those apps for all users.
    The **`Uninstall for all users`** action is hidden in the overflow menu so that
    it isn’t selected accidentally. It produces the warning shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users"). If the owner selects OK in this warning dialog, app directories for
    all users are removed and the APK file is deleted from the device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The app-sharing scheme implemented on multi-user Android devices is backward-compatible
    with previous versions and saves device space by not copying APK files for all
    users. However, it has one major disadvantage: any user can update an application,
    even if it was originally installed by another user.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: This scheme is usually not a problem, because every user’s app instance has
    a separate data directory, except when the update adds new permissions. Because
    Android grants permissions at install time, if a user updates an app and accepts
    a new permission that affects user privacy (for example, `READ_CONTACTS`), that
    permission will apply to all users who use the app. Other users are not notified
    that the app has been granted a new permission and may never notice the change,
    unless they manually inspect the app’s details in system Settings. Android does
    show a warning that notifies users about this fact when they first enable multi-user
    support, but does not send subsequent notifications about specific apps.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: External Storage
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android has included support for external storage since the first public versions.
    Because the first few generations of Android devices implemented external storage
    by simply mounting a FAT-formatted removable SD card, external storage is often
    referred to as “the SD card.” However, the definition of external storage is broader
    and simply requires that external storage be a “case-insensitive filesystem with
    immutable POSIX permission classes and modes.”^([[30](#ftn.ch04fn02)]) The underlying
    implementation may be anything that satisfies this definition.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: External Storage Implementations
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Newer devices tend to implement external storage by emulation, and some don’t
    have an SD card slot at all. For example, the last Google Nexus device that had
    an SD card slot was the Nexus One, released in January 2010, and all Nexus devices
    released after the Nexus S (which uses a dedicated partition for external storage)
    implement external storage by emulation. On devices that lack an SD card, external
    storage is implemented either by directly mounting a FAT-formatted partition,
    which resides on the same block device as primary storage, or by using a helper
    daemon to emulate it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android version 4.4, apps have been able to manage their package-specific
    directories (*Android/data/com.example.app/* for an app with the `com.example.app`
    package) on external storage without requiring the `WRITE_EXTERNAL_STORAGE` permission,
    which grants access to all data on external storage, including camera pictures,
    videos, and other media. This feature is called *synthesized permissions* and
    its AOSP implementation is based on a FUSE daemon that wraps the raw device storage
    and manages file access and permission based on a specified permission emulation
    mode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filesystem in Userspace*, or* FUSE,^([[31](#ftn.ch04fn03)]) *is a Linux feature
    that allows the implementation of a fully functional filesystem in a userspace
    program. This is achieved by using a generic FUSE kernel module that routes all
    Virtual Filesystem (VFS) system calls for the target filesystem to its userspace
    implementation. The kernel module and the user-space implementation communicate
    via a special file descriptor obtained by opening* /dev/fuse.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As of Android version 4.4, multiple external storage devices can be accessed
    by applications, but the applications are only allowed to write arbitrary files
    on *primary external storage* (if they hold the `WRITE_EXTERNAL_STORAGE` permission),
    and they have only limited access to other external storage devices, referred
    to as *secondary external storage*. Our discussion will focus on primary external
    storage as it’s most closely related to multi-user support.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User External Storage
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to uphold the Android security model in a multi-user environment, the
    Android Compatibility Definition Document (CDD) places numerous requirements on
    external storage. The most important of these is that “Each user instance on an
    Android device MUST have separate and isolated external storage directories.”
    ^([[32](#ftn.ch04fn04)])
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, implementing this requirement poses a problem because external
    storage has traditionally been world-readable and implemented using the FAT filesystem,
    which does not support permissions. Google’s implementation of multi-user external
    storage leverages three Linux kernel features in order to provide backward-compatible,
    per-user external storage: mount namespaces, bind mounts, and shared subtrees.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Linux Mount Features
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in other Unix systems, Linux manages all files from all storage devices as
    part of a single directory tree. Each filesystem is linked to a specific subtree
    by mounting it at a specified directory, called the *mount point*. Traditionally,
    the directory tree has been shared by all processes, and each process sees the
    same directory hierarchy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Linux 2.4.19 and later versions added support for per-process mount namespaces,
    which allows each process to have its own set of mount points and thus use a directory
    hierarchy different from that of other processes.^([[33](#ftn.ch04fn05)]) The
    current list of mounts for each process can be read from the */proc/PID/ mounts*
    virtual file, where *PID* is the process ID. A forked Linux process can request
    a separate mount namespace by specifying the `CLONE_NEWNS` flag to the Linux-specific
    `clone()`^([[34](#ftn.ch04fn06)]) and `unshare()`^([[35](#ftn.ch04fn07)]) system
    calls. In this case, the namespace of the parent process is referred to as the
    *parent namespace*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: A *bind mount* allows a directory or file to be mounted at another path in the
    directory tree, making the same file or directory visible at multiple locations.
    A bind mount is created by specifying the `MS_BIND` flag to the `mount()` system
    call, or by passing the `--bind` parameter to the `mount` command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, *shared subtrees*,^([[36](#ftn.ch04fn08)]) which were first introduced
    in Linux 2.6.15, provide a way to control how filesystem mounts are propagated
    across mount namespaces. Shared subtrees make it possible for a process to have
    its own namespace but still access filesystems that are mounted after it starts.
    Shared subtrees provide four different mount types, of which Android uses the
    shared and slave mount. A *shared mount* created in a parent namespace propagates
    to all child namespaces and is thus visible to all processes that have cloned
    off a namespace. A *slave mount* has a master mount that is a shared mount, and
    also propagates new mounts. However, the propagation is one-way only: mounts at
    the master propagate to the slave, but mounts at the slave do not propagate to
    the master. This scheme allows a process to keep its mounts invisible to any other
    process, while still being able to see shared system mounts. Shared mounts are
    created by passing the `MS_SHARED` flag to the `mount()` system call, while creating
    slave mounts requires passing the `MS_SLAVE` flag.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Android Implementation
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Android 4.4, mounting external storage directly is no longer supported
    but is emulated using the FUSE *sdcard* daemon, even when the underlying device
    is a physical SD card. We’ll base our discussion on a configuration that is backed
    by a directory on internal storage, which is typical for devices without a physical
    SD card. (The official documentation^([[37](#ftn.ch04fn09)]) contains more details
    on other possible configurations.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: On a device where primary external storage is backed by internal storage, the
    *sdcard* FUSE daemon uses the */data/media/* directory as a source and creates
    an emulated filesystem at */mnt/shell/emulated*. [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage") shows
    how the *sdcard* service is declared in the device-specific *init.rc* file in
    this case ➐.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. sdcard service declaration for emulated external storage
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `-u` and `-g` options specify the user and group the daemon should
    run as, and `-l` specifies the layout used for emulated storage (discussed later
    in this section). As you can see at ➊, the */mnt/shell/emulated/* directory (available
    via the `EMULATED_STORAGE_SOURCE` environment variable ➍) is owned and only accessible
    by the *shell* user. Its contents might look like [Example 4-13](ch04.html#contents_of_solidusmntsolidusshellsolidu
    "Example 4-13. Contents of /mnt/shell/emulated/") on a device with five users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. Contents of /mnt/shell/emulated/
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As with app data directories, each user gets a dedicated external storage data
    directory named after their user ID. Android uses a combination of mount namespaces
    and bind mounts in order to make each user’s external storage data directory available
    only to the applications that the user starts, without showing them other users’
    data directories. Because all applications are forked off the *zygote* process
    (discussed in [Chapter 2](ch02.html "Chapter 2. Permissions")), external storage
    setup is implemented in two steps: the first one is common to all processes, and
    the second is specific to each process. First, mount points that are shared by
    all forked app processes are set up in the unique *zygote* process. Then dedicated
    mount points, which are visible only to that process, are set up as part of each
    app’s process specialization.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first look at the shared part in the *zygote* process. [Example 4-14](ch04.html#mount_point_setup_in_zygote
    "Example 4-14. Mount point setup in zygote") shows an excerpt of the `initZygote()`
    function (found in *dalvik/vm/Init.cpp*) that highlights mount point setup.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. Mount point setup in zygote
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, *zygote* passes the `CLONE_NEWNS` flag to the `unshare()` system call
    ➊ in order to create a new, private mount namespace that will be shared by all
    its children (app processes). It then marks the root filesystem (mounted at /)
    as a slave by passing the `MS_SLAVE` flag to the `mount()` system call ➋. This
    ensures that changes from the default mount namespace, such as mounting encrypted
    containers or removable storage, only propagate to its children, while at the
    same time making sure that any mounts created by children do not propagate into
    the default namespace. Finally, *zygote* creates the memory-backed `EMULATED_STORAGE_TARGET`
    (usually */storage/emulated/*) mount point by creating a *tmpfs* filesystem ➌,
    which children use to bind mount external storage into their private namespaces.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-15](ch04.html#external_storage_setup_for_app_processes "Example 4-15. External
    storage setup for app processes") shows the process-specific mount point setup
    found in *dalvik/vm/native/dalvik_system_Zygote.cpp* that is executed when forking
    each app process off *zygote*. (Error handling, logging, and some variable declarations
    have been omitted.)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. External storage setup for app processes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the `mountEmulatedStorage()` function first obtains the current user ID
    from the process UID ➊, then uses the `unshare()` system call to create a new
    mount namespace for the process by passing the `CLONE_NEWNS` flag ➋. The function
    then obtains the values of the `EMULATED_STORAGE_SOURCE` ➌, `EMULATED_STORAGE_TARGET`
    ➍, and `EXTERNAL_STORAGE` ➎ environment variables, which are all initialized in
    the device-specific *init.rc* file (see ➌, ➍, and ➎ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")). It
    then prepares the mount source ➏ and target ➐ directory paths based on the values
    of `EMULATED_STORAGE_SOURCE`, `EMULATED_STORAGE_TARGET`, and the current user
    ID.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The directories are created if they don’t exist, and then the method bind mounts
    the source directory (such as */mnt/shell/emulated/0* for the owner user) at the
    target path (for example, */storage/emulated/0* for the owner user) ➑. This ensures
    that external storage is accessible from the Android shell (started with the *adb
    shell* command), which is used extensively for application development and debugging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to recursively bind mount the target directory at the fixed
    legacy directory (*/storage/emulated/legacy/*) ➒. The legacy directory is symlinked
    to */sdcard/* in the device-specific *init.rc* file (➏ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")) for
    backward compatibility with apps that hardcode this path (normally obtained using
    the `android.os.Environment.getExternalStorageDirectory()` API).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: After all steps have been executed, the newly created app process is guaranteed
    to see only the external storage allotted to the user that started it. We can
    verify this by looking at the list of mounts for two app process executed by different
    users as shown in [Example 4-16](ch04.html#list_of_mount_points_for_process_started
    "Example 4-16. List of mount points for process started by different users").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16. List of mount points for process started by different users
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the process started by the owner user with PID 7382 has a */storage/ emulated/0*
    mount point ➋, which is a bind mount of */mnt/shell/emulated/0/*, and process
    7538 (started by a secondary user) has a */storage/emulated/10* mount point ➎,
    which is a bind mount of */mnt/shell/emulated/10/*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Because neither process has a mount point for the other process’s external storage
    directory, each process can only see and modify its own files. Both processes
    have a */storage/emulated/legacy* mount point (➌ and ➏), but because it is bound
    to different directories (*/storage/emulated/0/* and */mnt/ shell/emulated/10/*,
    respectively), each process sees different contents. Both process can see */mnt/shell/emulated/*
    (➊ and ➍), but because this directory is only accessible to the *shell* user (permissions
    0700), app processes cannot see its contents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: External Storage Permissions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to emulate the FAT filesystem that was originally used for external
    storage, the *sdcard* FUSE daemon assigns fixed owner, group, and access permissions
    to each file or directory on external storage. Additionally, permissions are not
    changeable, and symlinks and hardlinks are not supported. The assigned owner and
    permission are determined by the permission derivation mode that the *sdcard*
    daemon uses.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In legacy mode (specified with the `-l` option), which is backward-compatible
    with previous Android versions and which is still the default in Android 4.4,
    most files and directories are owned by the root user and their group is set to
    *sdcard_r*. Applications that are granted the `READ_EXTERNAL_STORAGE` permission
    have *sdcard_r* as one of their supplementary groups, and thus can read most files
    on external storage even if they were originally created by a different application.
    [Example 4-17](ch04.html#owner_and_permissions_of_files_on_extern "Example 4-17. Owner
    and permissions of files on external storage") shows the owner and permission
    of files and directories in the root of external storage.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-17. Owner and permissions of files on external storage
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In previous versions of Android, all files and directories on external storage
    were assigned the same owner and permissions, but Android 4.4 treats the application-specific
    external files directory (*Android/data/<package-name>/*, the exact path is returned
    by the `Context.getExternalFilesDir()` method) differently. Applications don’t
    have to hold the `WRITE_EXTERNAL_STORAGE` permission in order to read and write
    files in this directory because it is owned by the creating application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: That said, even in Android 4.4, the application’s external files directory is
    accessible by any application that holds the `READ_EXTERNAL_STORAGE` or `WRITE_EXTERNAL_STORAGE`
    permissions because the group of the directory is set to *sdcard_r*, as shown
    in [Example 4-18](ch04.html#owner_and_permissions_of_an_appapostroph "Example 4-18. Owner
    and permissions of an app’s external files directory").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-18. Owner and permissions of an app’s external files directory
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Android 4.4 supports a more flexible permission derivation mode that is based
    on directory structure, and which is specified by passing the `-d` option to the
    *sdcard* daemon. This derivation mode sets dedicated groups to the directories
    *Pictures/* and *Music/* (*sdcard_pics* ➊ and *sdcard_av* ➋, as shown in [Example 4-19](ch04.html#directory_owners_and_permission_in_the_n
    "Example 4-19. Directory owners and permission in the new permission derivation
    mode")), which allows for fine-grained control over which files applications can
    access. As of this writing, Android doesn’t support such fine-grained access control,
    but it can easily be implemented by defining additional permissions that map to
    the *sdcard_pics* and *sdcard_av* groups. In the directory-structure-based permission
    mode, user directories are hosted under *Android/user/* ➌.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While this new permission derivation mode is supported in Android 4.4, as
    of this writing, Nexus devices still use the legacy permission mode.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-19. Directory owners and permission in the new permission derivation
    mode
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Other Multi-User Features
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides dedicated app directories, external storage and settings, other Android
    features also support a multi-user device configuration. For example, as of version
    4.4, Android’s credential storage (which allows for secure management of cryptographic
    keys) lets each user have their own key storage. (We discuss credential storage
    in more detail in [Chapter 7](ch07.html "Chapter 7. Credential Storage").)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Android’s online account database, accessible via the `AccountManager`
    API, has been extended to allow secondary users to have their own accounts, as
    well as to allow restricted profiles to share some of the primary user’s accounts
    (if the app that needs account access supports it). We discuss online account
    support and the `AccountManager` API in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: And finally, Android allows setting different device administration policies
    for each user. As of version 4.4, it also supports setting up per-user VPNs that
    only route a single user’s traffic and which are not accessible by other users.
    (We discuss device administration, VPNs, and other enterprise features in [Chapter 9](ch09.html
    "Chapter 9. Enterprise Security").)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android allows multiple users to share a device by providing dedicated internal
    and external storage to each user. Multi-user support follows the established
    security model and each user’s applications are assigned a unique UID and run
    in dedicated processes that cannot access other user’s data. User isolation is
    achieved by combining a UID assignment scheme that takes into account the user
    ID and storage mounting rules that allow each user to only see their own storage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, multi-user support is only available on devices without
    telephony support (usually tablets), as the behavior of telephony in a multi-user
    environment is currently undefined. Most Android features, including account database
    management, credential storage, device policies, and VPN support are multi-user-aware
    and allow each user to have their own configuration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#ch04fn01)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#ch04fn02)]) Google, “External Storage Technical Information,” *[http://source.android.com/devices/tech/storage/index.html](http://source.android.com/devices/tech/storage/index.html)*
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#ch04fn03)]) “Filesystem in Userspace,” *[http://fuse.sourceforge.net/](http://fuse.sourceforge.net/)*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#ch04fn04)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '^([[33](#ch04fn05)]) Michael Kerrisk, *The Linux Programming Interface: A Linux
    and UNIX System Programming Handbook*, No Starch Press, 2010, pp. 261'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#ch04fn06)]) Ibid., 598
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#ch04fn07)]) Ibid., 603
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#ch04fn08)]) Linux Kernel, *Shared Subtrees*, *[https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)*
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '^([[37](#ch04fn09)]) Google, “External Storage: Typical Configuration Examples,”
    *[http://source.android.com/devices/tech/storage/config-example.html](http://source.android.com/devices/tech/storage/config-example.html)*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
