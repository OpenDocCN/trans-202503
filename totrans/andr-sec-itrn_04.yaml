- en: Chapter 4. User Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android originally targeted personal devices such as smartphones and assumed
    that each device had only one user. With the increase in popularity of tablets
    and other shared devices, multi-user support was added in version 4.2 and extended
    in later versions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss how Android manages users who share devices and
    data. We begin with a look at the types of users Android supports and how it stores
    user metadata. We then discuss how Android shares installed applications between
    users while isolating application data and keeping it private to each user. Finally,
    we cover how Android implements isolated external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User Support Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android’s multi-user support allows multiple users to share a single device
    by providing each user with an isolated, personal environment. Each user can have
    their own home screen, widgets, apps, online accounts, and files that are not
    accessible to other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users are identified by a unique *user ID* (not to be confused with Linux UIDs)
    and only the system can switch between users. User switching is normally triggered
    by selecting a user from the Android lockscreen and (optionally) authenticating
    using a pattern, PIN, password, and so on (see [Chapter 10](ch10.html "Chapter 10. Device
    Security")). Applications can get information about the current user via the `UserManager`
    API, but typically code modification is not required in order to support a multi-user
    environment. Applications that need to modify their behavior when used by a restricted
    profile are an exception: these applications require additional code that checks
    what restrictions (if any) are imposed on the current user (see “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for details).'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-user support is built into the core Android platform and is thus available
    on all devices that run Android 4.2 or later. However, the default platform configuration
    only allows for a single user, which effectively disables multi-user support.
    In order to enable support for multiple users, the *config_multiuserMaximumUsers*
    system resource must be set to a value greater than one, typically by adding a
    device-specific overlay configuration file. For example, on the Nexus 7 (2013),
    the overlay is placed in the *device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml*
    file and the *config_multiuserMaximumUsers* setting is defined as shown in [Example 4-1](ch04.html#enabling_multi-user_support_with_a_resou
    "Example 4-1. Enabling multi-user support with a resource overlay file"), to allow
    a maximum of eight users.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1. Enabling multi-user support with a resource overlay file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Android Compatibility Definition requires that devices that support telephony
    (such as mobile phones) must not enable multi-user support because “the behavior
    of the telephony APIs on devices with multiple users is currently undefined.”*^([[29](#ftn.ch04fn01)])
    *Therefore, in current production builds, all handsets are configured as single-user
    devices.*'
  prefs: []
  type: TYPE_NORMAL
- en: When multi-user support is enabled, the system Settings application displays
    a Users entry that allows the device owner (the first user created, as discussed
    in the next section) to create and manage users. The user management screen is
    shown in [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User management
    screen").
  prefs: []
  type: TYPE_NORMAL
- en: '![User management screen](figs/web/04fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. User management screen
  prefs: []
  type: TYPE_NORMAL
- en: As soon as more than one user has been created, the lockscreen shows a user
    widget that displays the current users and allows switching to a different user.
    [Figure 4-2](ch04.html#lockscreen_with_user_switcher_widget "Figure 4-2. Lockscreen
    with user switcher widget") shows how the lockscreen might look on a device with
    eight users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lockscreen with user switcher widget](figs/web/04fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. Lockscreen with user switcher widget
  prefs: []
  type: TYPE_NORMAL
- en: Types of Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Android lacks the full user management features of most multi-user
    operating systems, which typically allow users to add multiple administrators
    and define user groups, it does support configuring user types with different
    privileges. Each user type and its privileges will be described in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Primary User (Owner)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *primary user*, also known as the device *owner*, is the first user created
    on a multi-user device, or the sole user on single-user devices. The owner is
    created by default and is always present. The primary user is assigned user ID
    0\. On single-user devices where the primary user is the only user, Android behaves
    much like previous versions that lacked multi-user support: directories and UIDs
    assigned to installed applications maintain the same format and permissions as
    in previous versions (see “[User Management](ch04.html#user_management-id00008
    "User Management")” and “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")” for details).'
  prefs: []
  type: TYPE_NORMAL
- en: The primary user is assigned all privileges and can create and delete other
    users, as well as change system settings that affect all users, including settings
    related to device security, network connectivity, and application management.
    Device and user management privileges are granted to the primary user by showing
    the respective settings screens in system settings and hiding them from other
    users. Additionally, the underlying system services check the identity of the
    calling user before performing operations that can affect all users, and only
    allow execution when called by the device owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Android version 4.4, the following screens in the Wireless and Networks
    section of system settings are displayed to only the primary user:'
  prefs: []
  type: TYPE_NORMAL
- en: Cell broadcasts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage mobile plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tethering and portable hotspot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WiMAX (shown if supported by the device)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screens in the Security section are also reserved for the primary
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: Device encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SIM card lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown sources (controls app sideloading; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify apps (controls package verification; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the exception of restricted profiles (discussed in the next section), all
    added users are *secondary users*. Each gets a dedicated user directory (see “[User
    Management](ch04.html#user_management-id00008 "User Management")”), their own
    list of installed apps, and private data directories for each installed app.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary users cannot add or manage users; they can only set their own username
    via the Users screen (see [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User
    management screen")). Additionally, they cannot perform any privileged operation
    reserved for the primary user as listed in the previous sections. Otherwise, secondary
    users can perform all the operations that a primary user can, including installing
    and using applications, and changing the system appearance and settings.
  prefs: []
  type: TYPE_NORMAL
- en: Although secondary users are restricted, their actions can still affect device
    behavior and other users. For example, they can add and connect to a new Wi-Fi
    network. Because Wi-Fi connectivity state is shared across the system, switching
    to a different user does not reset the wireless connection, and that user will
    be connected to the wireless network selected by the previous user. Secondary
    users can also toggle airplane mode and NFC, and change the global sound and display
    settings. Most importantly, as application packages are shared across all users
    (as discussed in “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")”), if a secondary user updates an application that adds new permissions,
    permissions are granted to the application without requiring the consent of other
    users, and other users are not notified of permission changes.
  prefs: []
  type: TYPE_NORMAL
- en: Restricted Profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike secondary users, restricted profiles (added in Android 4.3) are based
    on the primary user and share its applications, data, and accounts, with certain
    restrictions. As such, the primary user must set up a lockscreen password in order
    to protect their data. If no lockscreen password is in place when the primary
    user creates a restricted profile, Android prompts them to set up one.
  prefs: []
  type: TYPE_NORMAL
- en: User Restrictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android defines the following default restrictions in order to control what
    users are allowed to do. All restrictions are `false` by default. The list below
    shows their value for restricted users in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '****`DISALLOW_CONFIG_BLUETOOTH`****. Specifies whether a user is prevented
    from configuring Bluetooth. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_CONFIG_CREDENTIALS`****. Specifies whether a user is prevented
    from configuring user credentials. When this restriction is set to `true`, restricted
    profiles cannot add trusted CA certificates or import private keys into the system
    credential store; see [Chapter 6](ch06.html "Chapter 6. Network Security and PKI")
    and [Chapter 7](ch07.html "Chapter 7. Credential Storage") for details. (default:
    `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_CONFIG_WIFI`****. Specifies whether a user is prevented from
    changing Wi-Fi access points. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_INSTALL_APPS`****. Specifies whether a user is prevented from
    installing applications. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_INSTALL_UNKNOWN_SOURCES`****. Specifies whether a user is prevented
    from enabling the Unknown sources setting (see [Chapter 3](ch03.html "Chapter 3. Package
    Management")). (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_MODIFY_ACCOUNTS`****. Specifies whether a user is prevented from
    adding and removing accounts. (default: `true`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_REMOVE_USER`****. Specifies whether a user is prevented from
    removing users. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_SHARE_LOCATION`****. Specifies whether a user is prevented from
    toggling location sharing. (default: `true`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_UNINSTALL_APPS`****. Specifies whether a user is prevented from
    uninstalling applications. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`DISALLOW_USB_FILE_TRANSFER`****. Specifies whether a user is prevented
    from transferring files over USB. (default: `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Restrictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At runtime, applications can use the `UserManager.getUserRestrictions()` method
    to get a `Bundle` (a universal container class that maps string keys to various
    value types) containing the restrictions imposed on a user. Restrictions are defined
    as key-value pairs, where the key is the restriction name and the Boolean value
    specifies whether it is in effect. Applications can use that value in order to
    disable certain functionality when running within a restricted profile. For example,
    the system Settings app checks the value of the `DISALLOW_SHARE_LOCATION` restriction
    when displaying location preferences. If the value is `true`, it disables the
    location mode setting. Another example is the `PackageManagerService`: it checks
    the `DISALLOW_INSTALL_APPS` and `DISALLOW_UNINSTALL_APPS` restrictions before
    installing or uninstalling apps and returns the `INSTALL_FAILED_USER_RESTRICTED`
    error code if any of those restrictions are set to `true` for the calling user.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary user can select which applications will be available to a restricted
    profile. When a restricted profile is created, all installed applications are
    initially disabled, and the owner must explicitly enable the ones that they want
    to make available to the restricted profile (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Restricted profile management screen](figs/web/04fig03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. Restricted profile management screen
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the built-in restrictions defined by the OS, applications can
    define custom restrictions by creating a `BroadcastReceiver` that receives the
    `ACTION_GET_RESTRICTION_ENTRIES` intent. Android invokes this intent to query
    all apps for available restrictions and automatically builds a UI that allows
    device owners to toggle the app’s custom restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, applications can use the `UserManager.getApplicationRestrictions()`
    method to obtain a `Bundle` that contains saved restrictions as key-value pairs.
    The application can then disable or modify certain features based on the applied
    restrictions. The device owner can toggle system and custom restrictions on the
    same settings screen used to manage applications available to a restricted profile.
    For example, in [Figure 4-3](ch04.html#restricted_profile_management_screen "Figure 4-3. Restricted
    profile management screen"), the single application restriction supported by the
    Settings app (whether to let apps use location information) is shown below the
    main application toggle.
  prefs: []
  type: TYPE_NORMAL
- en: Access to Online Accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Restricted profiles can also access the online accounts of the primary user
    via the `AccountManager` API (see [Chapter 8](ch08.html "Chapter 8. Online Account
    Management")), but this access is disabled by default. Applications that need
    access to accounts when running within a restricted profile must explicitly declare
    the account types they require using the `restrictedAccountType` attribute of
    the `<application>` tag, as shown in [Example 4-2](ch04.html#allowing_access_to_the_ownerapostrophes
    "Example 4-2. Allowing access to the owner’s accounts from a restricted profile").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2. Allowing access to the owner’s accounts from a restricted profile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, applications that do not want to expose account information
    to restricted profiles can declare this by specifying the account type (an asterisk
    can be used to match all account types) as the value of the `requiredAccountType`
    attribute of the `<application>` tag. If the `requiredAccountType` attribute is
    specified, Android will automatically disable such applications for restricted
    profiles. For example, because the Android Calendar application declares `android:requiredAccountType="*"`
    in its manifest, it cannot be made available to restricted profiles and is disabled
    in the restrictions settings screen (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  prefs: []
  type: TYPE_NORMAL
- en: Guest User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android supports a single guest user, but this functionality is disabled by
    default. While the guest user can be enabled by calling the `UserManager.setGuestEnabled()`
    method, the guest user does not appear to be referenced anywhere other than by
    the `UserManager` and related classes in current Android versions. Code comments
    indicate that the guest user might be transient, but as of this writing its exact
    purpose is not clear. It appears to be a remnant of a proposed feature that was
    rejected or never fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: User Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android users are managed by the `UserManagerService`, which is responsible
    for reading and persisting user information and maintaining the list of active
    users. Because user management is closely related to package management, the `PackageManagerService`
    calls the `UserManagerService` to query or modify users when packages are installed
    or removed. The `android.os.UserManager` class provides a facade to the `UserManagerService`
    and exposes a subset of its functionality to third-party applications. Applications
    can get the number of users on a system, a user’s serial number, the name and
    list of restrictions for the current user, as well as the list of restrictions
    for a package without the need for any special permissions. All other user operations,
    including querying, adding, removing, or modifying users, require the `MANAGE_USERS`
    system signature permission.
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User management operations can also be performed on the Android shell with the
    `pm` command. These commands can be run via the shell without root permissions,
    because the *shell* user (UID 2000) is granted the `MANAGE_USERS` permission.
    You can use the `pm create-user` command to create a new user, and the `pm remove-user`
    to remove it. The command `pm get-max-users` returns the maximum number of users
    supported by the OS, and `pm list users` lists all users. The output of the `pm
    list users` command might look like [Example 4-3](ch04.html#listing_users_using_the_pm_list_command
    "Example 4-3. Listing users using the pm list command") on a device with five
    users. The numbers in curly braces are the user ID, name, and flags, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3. Listing users using the `pm list` command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: User States and Related Broadcasts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UserManagerService` sends several broadcasts to notify other components
    of user-related events. When a user is added, it sends the `USER_ADDED` broadcast,
    and when a user is removed, it sends `USER_REMOVED`. If the user-name or their
    profile icon is changed, the `UserManagerService` sends the `USER_INFO_CHANGED`
    broadcast. Switching users triggers the `USER_BACKGROUND`, `USER_FOREGROUND`,
    and `USER_SWITCHED` broadcasts, all of which contain the relevant user ID as an
    extra.
  prefs: []
  type: TYPE_NORMAL
- en: While Android supports a maximum of eight users, only three users can be running
    at a time. A user is started when it is first switched to via the lockscreen user
    switcher. Android stops inactive users based on a least recently used (LRU) cache
    algorithm to ensure that no more than three users are active.
  prefs: []
  type: TYPE_NORMAL
- en: When a user is stopped, its processes are killed and it no longer receives any
    broadcasts. When users are started or stopped, the system sends the `USER_STARTING`,
    `USER_STARTED`, `USER_STOPPING`, and `USER_STOPPED` broadcasts. The primary user
    is started automatically when the system boots and is never stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Starting, stopping, and switching users, as well as targeting a specific user
    with a broadcast, requires the `INTERACT_ACROSS_USERS` permission. This is a system
    permission with signature protection, but it also has the `development` flag set
    (see [Chapter 2](ch02.html "Chapter 2. Permissions")) so it can be dynamically
    granted to non-system applications that declare it (using the `pm grant` command).
    The `INTERACT_ACROSS_USERS_FULL` signature permission allows sending broadcasts
    to all users, changing the device administrator, as well as other privileged operations
    that affect all users.
  prefs: []
  type: TYPE_NORMAL
- en: User Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android stores user data in the */data/system/users/* directory that hosts metadata
    about users in XML format, as well as user directories. On a device with five
    users, its contents may look like [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/") (timestamps have been omitted).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4. Contents of /data/system/users/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The User List File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/"), each user has a dedicated directory
    called the *user system directory* with a name that matches the assigned user
    ID (➊ for the primary user) and an XML file that stores metadata about the user,
    again with a filename based on the user ID (➋ for the primary user). The *userlists.xml*
    file ➌ holds data about all users created on a system and may look like [Example 4-5](ch04.html#contents_of_userlistdotxml
    "Example 4-5. Contents of userlist.xml") on a system with five users.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5. Contents of userlist.xml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The file format is basically a list of `<user>` tags holding the ID assigned
    to each user. The root `<users>` element has a `version` attribute specifying
    the current file version and a `nextSerialNumber` attribute holding the serial
    number to be assigned to the next user. The primary user is always assigned user
    ID 0.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that UIDs assigned to applications are based on the user ID of the
    owning user ensures that on single-user devices, UIDs assigned to applications
    are the same as they were before multi-user support was introduced. (For more
    on application UIDs, see “[Application Data Directories](ch04.html#application_data_directories
    "Application Data Directories")”.) Secondary users and restricted profiles are
    assigned IDs beginning with the number 10.
  prefs: []
  type: TYPE_NORMAL
- en: User Metadata Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attributes of each user are stored in a dedicated XML file. [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents") shows an example for a restricted
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6. User metadata file contents
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `<name>` tag ➋ holds the user’s name and the `<restrictions>` tag
    ➌ has attributes for each enabled restriction. (See “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for a list of built-in restrictions.) [Table 4-1](ch04.html#less_thanusergreater_than_element_attrib
    "Table 4-1. <user> Element Attributes") summarizes the attributes of the root
    `<user>` element shown at ➊ in [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents").
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. <user> Element Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Format | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | integer | User ID |'
  prefs: []
  type: TYPE_TB
- en: '| `serialNumber` | integer | User serial number |'
  prefs: []
  type: TYPE_TB
- en: '| `flags` | integer | Flags that indicate the type of user |'
  prefs: []
  type: TYPE_TB
- en: '| `created` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | User creation time |'
  prefs: []
  type: TYPE_TB
- en: '| `lastLoggedIn` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | Last login time |'
  prefs: []
  type: TYPE_TB
- en: '| `icon` | string | Full path to the user icon file |'
  prefs: []
  type: TYPE_TB
- en: '| `partial` | Boolean | Indicates that the user is partially initialized. Partial
    users may not have all of their files and directories created yet. |'
  prefs: []
  type: TYPE_TB
- en: '| `pinHash` | hexadecimal string | The salted SHA1+MD5 PIN hash for PIN-protected
    restrictions |'
  prefs: []
  type: TYPE_TB
- en: '| `salt` | long integer | The PIN salt for PIN-protected restrictions |'
  prefs: []
  type: TYPE_TB
- en: '| `failedAttempts` | integer | The number of failed PIN entry attempts for
    PIN-protected restrictions |'
  prefs: []
  type: TYPE_TB
- en: '| `lastAttemptMs` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | The time of the last PIN entry attempt for PIN-protected restrictions (in milliseconds
    since the Unix epoch, per `System.currentTimeMillis()`) |'
  prefs: []
  type: TYPE_TB
- en: 'The `flags` attribute is one of the most important as it determines the user
    type. As of this writing, six bits of the flag value are used for the user type
    and the rest are reserved with the following flags currently defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`FLAG_PRIMARY` (0x00000001)** Marks the primary user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_ADMIN` (0x00000002)** Marks administrator users. Administrator can
    create and delete users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_GUEST` (0x00000004)** Marks the guest user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_RESTRICTED` (0x00000008)** Marks restricted users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`FLAG_INITIALIZED` (0x00000010)** Marks a user as fully initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While different flag combinations are possible, most combinations don’t represent
    a valid user type or state, and in practice the attributes for the primary owner
    are set to 19 (0x13 or `FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY`), secondary
    users have flags 16 (0x10 or `FLAG_INITIALIZED`), and restricted profiles have
    flags 24 (0x18 or `FLAG_INITIALIZED|FLAG_RESTRICTED`).
  prefs: []
  type: TYPE_NORMAL
- en: User System Directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each user system directory contains user-specific system settings and data but
    no application data. As we’ll see in the next section, each application that a
    user installs gets a dedicated data directory under */data*, much like on single-user
    devices. (See [Chapter 3](ch03.html "Chapter 3. Package Management") for more
    on application data directories.) For example, in the case of a secondary user
    with user ID 12, the user system directory would be named */data/system/users/12/*
    and might contain the files and directories listed in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7. Contents of a user directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The file *accounts.db* ➊ is an SQLite database that holds online account details.
    (We discuss online account management in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").) The file *appwidgets.xml* ➋ holds information about widgets
    that the user has added to their home screen. The *device_policies.xml* ➌ file
    describes the current device policy (see [Chapter 9](ch09.html "Chapter 9. Enterprise
    Security") for details), and *gesture.key* ➍ and *password.key* ➐ contain the
    hash of the currently selected lockscreen pattern or PIN/password, respectively
    (see [Chapter 10](ch10.html "Chapter 10. Device Security") for format details).
  prefs: []
  type: TYPE_NORMAL
- en: The *inputmethod* directory ➎ contains information about input methods. The
    *photo.png* file ➑ stores the user’s profile image or picture. The file *settings.db*
    ➒ holds system settings specific to that user, and *wallpaper* ➓ is the currently
    selected wallpaper image. The *package-restrictions.xml* file ➏ defines what applications
    the user has installed and stores their state. (We discuss application sharing
    and per-user application data in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: Per-User Application Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in “[Multi-User Support Overview](ch04.html#multi-user_support_overview
    "Multi-User Support Overview")”, besides dedicated accounts and settings, each
    user gets their own copy of application data that cannot be accessed by other
    users. Android achieves this by assigning a new, per-user effective UID for each
    application and creating a dedicated application data directory owned by that
    UID. We’ll discuss the details of this implementation in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Application Data Directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we covered in [Chapter 3](ch03.html "Chapter 3. Package Management"), Android
    installs APK packages by copying them to the */data/app/* directory, and creates
    a dedicated data directory for each application under */data/data/*. When multi-user
    support is enabled, this layout is not changed but extended to support additional
    users. Application data for the primary user is still stored in */data/data/*
    for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: If other users exist on the system when a new application is being installed,
    the `PackageManagerService` creates application data directories for each user.
    As with the data directory for the primary user, those directories are created
    with the help of the *installd* daemon (using the `mkuserdata` command) because
    the *system* user does not have enough privileges to change directory ownership.
  prefs: []
  type: TYPE_NORMAL
- en: User data directories are stored in */data/user/* and named after the user’s
    ID. The device owner directory (*0/*) is a symbolic link to */data/data/*, as
    shown in [Example 4-8](ch04.html#contents_of_solidusdatasolidususersolidu "Example 4-8. Contents
    of /data/user/ on a multi-user device").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. Contents of /data/user/ on a multi-user device
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The contents of each application data directory are the same as */data/ data/*,
    but application directories for each user’s instance of the same application are
    owned by a different Linux user, as shown in [Example 4-9](ch04.html#contents_of_application_data_directories
    "Example 4-9. Contents of application data directories for the primary user and
    one secondary user").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. Contents of application data directories for the primary user and
    one secondary user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This listing shows the contents of the app data directories for the primary
    user ➊ and the secondary user with user ID 13 ➌. As you can see, even though both
    users have data directories for the same apps, such as the browser app (➋ for
    the owner and ➍ for the secondary user), those directories are owned by different
    Linux users: *u0_a16* in the case of the owner and *u13_a16* in the case of the
    secondary user. If we check the UID for those users using the `su` and `id` commands,
    we find that *u0_a16* has UID=10016, and *u13_a16* has UID=1310016.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that both UIDs contain the number 10016 is no coincidence. The repeating
    part is called the *app ID* and is the same as the UID assigned to the app when
    first installed on a single-user device. On multiuser devices, the app UID is
    derived from the user ID and the app ID using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because the owner’s user ID is always 0, the UIDs for the device owner’s apps
    are always the same as their app IDs. When the same application is executed in
    the context of different users, it executes under the respective UIDs assigned
    to each user’s application instance. For example, if the browser application is
    executed simultaneously by the device owner and a secondary user with user ID
    13, two separate processes running as the *u0_a16* and *u13_a16* Linux users will
    be created (UID 10016, for the owner ➊ and UID 1310016, for the secondary user
    ➋) as shown in [Example 4-10](ch04.html#process_information_for_the_browser_appl
    "Example 4-10. Process information for the browser application when executed by
    different device users").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. Process information for the browser application when executed
    by different device users
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Application Sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While installed applications have a dedicated data directory for each user,
    the APK files are shared among all users. The APK files are copied to */data/app/*
    and are readable by all users; shared libraries used by apps are copied to */data/app-lib/<package
    name>/* and are symlinked to */data/ user/<user ID>/<package name>/lib/*; and
    the optimized DEX files for each app are stored in */data/dalvik-cache/* and are
    also shared by all users. Thus once an application is installed, it is accessible
    to all device users, and an app data directory is automatically created for each
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Android makes it possible for users to have different applications by creating
    a *package-restrictions.xml* file (➏ in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory")) in the system directory of each
    user, which it uses to track whether an app is enabled for a user or not. Besides
    the install state of packages, this file contains information about the disabled
    components of each application, as well as a list of preferred applications to
    start when processing intents that can be handled by more than one application
    (such as opening a text file, for example). The contents of *package-restrictions.xml*
    might look like [Example 4-11](ch04.html#contents_of_the_package-restrictionsdotx
    "Example 4-11. Contents of the package-restrictions.xml file") for a secondary
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Contents of the package-restrictions.xml file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `com.example.app` package is available on the system but is not installed
    for that secondary user, as expressed by adding a `<pkg>` for the app and setting
    the `inst` attribute to `false` ➊. Based on this information, the `PackageManagerService`
    marks the `com.example.app` package as not installed for that user and the package
    doesn’t show up in the launcher or the list of apps in Settings.
  prefs: []
  type: TYPE_NORMAL
- en: Applications can be installed but still marked as stopped, as shown at ➋. Here,
    the `com.example.app2` package is installed but marked as stopped by setting the
    `stopped` attribute to `true`. Android has a special state for applications that
    have never been launched; a state that is persisted with the `nl` attribute of
    the `<pkg>` tag. The device owner can block a package for a certain user, in which
    case the `blocked` attribute is set to `true`, though this is not shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users").
  prefs: []
  type: TYPE_NORMAL
- en: When a device user installs an application, a `<pkg>` tag with `inst="false"`
    is added to the *package-restrictions.xml* files for all users. When another user
    installs the same application, the `inst` attribute is removed and the application
    is considered installed for that user. (Depending on how the second user started
    the install process, the APK file in */data/app/* may be replaced, as it is in
    an application update.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Restricted users cannot install applications, but the same procedure is applied
    when the device owner enables an app for a restricted user: the application is
    installed by calling the `PackageManagerService.installExistingPackageAsUser()`
    method, which sets the installed flag for the package and updates *package-restrictions.xml*
    accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Warning shown when the device owner tries to uninstall an app for all users](figs/web/04fig04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users
  prefs: []
  type: TYPE_NORMAL
- en: When a user uninstalls a package, their app data is deleted and the internal
    per-user package installed flag is set to `false`. This state is then persisted
    by setting `inst="false"` to the removed package’s tag in the user’s *package-restrictions.xml*
    file. The APK file and native library directory are only removed when the last
    user that has the app installed uninstalls it. However, the owner can see all
    apps installed on the system in the All tab of the Apps Settings screen, including
    ones they haven’t installed, and they can uninstall those apps for all users.
    The **`Uninstall for all users`** action is hidden in the overflow menu so that
    it isn’t selected accidentally. It produces the warning shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users"). If the owner selects OK in this warning dialog, app directories for
    all users are removed and the APK file is deleted from the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app-sharing scheme implemented on multi-user Android devices is backward-compatible
    with previous versions and saves device space by not copying APK files for all
    users. However, it has one major disadvantage: any user can update an application,
    even if it was originally installed by another user.'
  prefs: []
  type: TYPE_NORMAL
- en: This scheme is usually not a problem, because every user’s app instance has
    a separate data directory, except when the update adds new permissions. Because
    Android grants permissions at install time, if a user updates an app and accepts
    a new permission that affects user privacy (for example, `READ_CONTACTS`), that
    permission will apply to all users who use the app. Other users are not notified
    that the app has been granted a new permission and may never notice the change,
    unless they manually inspect the app’s details in system Settings. Android does
    show a warning that notifies users about this fact when they first enable multi-user
    support, but does not send subsequent notifications about specific apps.
  prefs: []
  type: TYPE_NORMAL
- en: External Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android has included support for external storage since the first public versions.
    Because the first few generations of Android devices implemented external storage
    by simply mounting a FAT-formatted removable SD card, external storage is often
    referred to as “the SD card.” However, the definition of external storage is broader
    and simply requires that external storage be a “case-insensitive filesystem with
    immutable POSIX permission classes and modes.”^([[30](#ftn.ch04fn02)]) The underlying
    implementation may be anything that satisfies this definition.
  prefs: []
  type: TYPE_NORMAL
- en: External Storage Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Newer devices tend to implement external storage by emulation, and some don’t
    have an SD card slot at all. For example, the last Google Nexus device that had
    an SD card slot was the Nexus One, released in January 2010, and all Nexus devices
    released after the Nexus S (which uses a dedicated partition for external storage)
    implement external storage by emulation. On devices that lack an SD card, external
    storage is implemented either by directly mounting a FAT-formatted partition,
    which resides on the same block device as primary storage, or by using a helper
    daemon to emulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android version 4.4, apps have been able to manage their package-specific
    directories (*Android/data/com.example.app/* for an app with the `com.example.app`
    package) on external storage without requiring the `WRITE_EXTERNAL_STORAGE` permission,
    which grants access to all data on external storage, including camera pictures,
    videos, and other media. This feature is called *synthesized permissions* and
    its AOSP implementation is based on a FUSE daemon that wraps the raw device storage
    and manages file access and permission based on a specified permission emulation
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filesystem in Userspace*, or* FUSE,^([[31](#ftn.ch04fn03)]) *is a Linux feature
    that allows the implementation of a fully functional filesystem in a userspace
    program. This is achieved by using a generic FUSE kernel module that routes all
    Virtual Filesystem (VFS) system calls for the target filesystem to its userspace
    implementation. The kernel module and the user-space implementation communicate
    via a special file descriptor obtained by opening* /dev/fuse.
  prefs: []
  type: TYPE_NORMAL
- en: As of Android version 4.4, multiple external storage devices can be accessed
    by applications, but the applications are only allowed to write arbitrary files
    on *primary external storage* (if they hold the `WRITE_EXTERNAL_STORAGE` permission),
    and they have only limited access to other external storage devices, referred
    to as *secondary external storage*. Our discussion will focus on primary external
    storage as it’s most closely related to multi-user support.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-User External Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to uphold the Android security model in a multi-user environment, the
    Android Compatibility Definition Document (CDD) places numerous requirements on
    external storage. The most important of these is that “Each user instance on an
    Android device MUST have separate and isolated external storage directories.”
    ^([[32](#ftn.ch04fn04)])
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, implementing this requirement poses a problem because external
    storage has traditionally been world-readable and implemented using the FAT filesystem,
    which does not support permissions. Google’s implementation of multi-user external
    storage leverages three Linux kernel features in order to provide backward-compatible,
    per-user external storage: mount namespaces, bind mounts, and shared subtrees.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Linux Mount Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in other Unix systems, Linux manages all files from all storage devices as
    part of a single directory tree. Each filesystem is linked to a specific subtree
    by mounting it at a specified directory, called the *mount point*. Traditionally,
    the directory tree has been shared by all processes, and each process sees the
    same directory hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Linux 2.4.19 and later versions added support for per-process mount namespaces,
    which allows each process to have its own set of mount points and thus use a directory
    hierarchy different from that of other processes.^([[33](#ftn.ch04fn05)]) The
    current list of mounts for each process can be read from the */proc/PID/ mounts*
    virtual file, where *PID* is the process ID. A forked Linux process can request
    a separate mount namespace by specifying the `CLONE_NEWNS` flag to the Linux-specific
    `clone()`^([[34](#ftn.ch04fn06)]) and `unshare()`^([[35](#ftn.ch04fn07)]) system
    calls. In this case, the namespace of the parent process is referred to as the
    *parent namespace*.
  prefs: []
  type: TYPE_NORMAL
- en: A *bind mount* allows a directory or file to be mounted at another path in the
    directory tree, making the same file or directory visible at multiple locations.
    A bind mount is created by specifying the `MS_BIND` flag to the `mount()` system
    call, or by passing the `--bind` parameter to the `mount` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, *shared subtrees*,^([[36](#ftn.ch04fn08)]) which were first introduced
    in Linux 2.6.15, provide a way to control how filesystem mounts are propagated
    across mount namespaces. Shared subtrees make it possible for a process to have
    its own namespace but still access filesystems that are mounted after it starts.
    Shared subtrees provide four different mount types, of which Android uses the
    shared and slave mount. A *shared mount* created in a parent namespace propagates
    to all child namespaces and is thus visible to all processes that have cloned
    off a namespace. A *slave mount* has a master mount that is a shared mount, and
    also propagates new mounts. However, the propagation is one-way only: mounts at
    the master propagate to the slave, but mounts at the slave do not propagate to
    the master. This scheme allows a process to keep its mounts invisible to any other
    process, while still being able to see shared system mounts. Shared mounts are
    created by passing the `MS_SHARED` flag to the `mount()` system call, while creating
    slave mounts requires passing the `MS_SLAVE` flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Android Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Android 4.4, mounting external storage directly is no longer supported
    but is emulated using the FUSE *sdcard* daemon, even when the underlying device
    is a physical SD card. We’ll base our discussion on a configuration that is backed
    by a directory on internal storage, which is typical for devices without a physical
    SD card. (The official documentation^([[37](#ftn.ch04fn09)]) contains more details
    on other possible configurations.)
  prefs: []
  type: TYPE_NORMAL
- en: On a device where primary external storage is backed by internal storage, the
    *sdcard* FUSE daemon uses the */data/media/* directory as a source and creates
    an emulated filesystem at */mnt/shell/emulated*. [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage") shows
    how the *sdcard* service is declared in the device-specific *init.rc* file in
    this case ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. sdcard service declaration for emulated external storage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-u` and `-g` options specify the user and group the daemon should
    run as, and `-l` specifies the layout used for emulated storage (discussed later
    in this section). As you can see at ➊, the */mnt/shell/emulated/* directory (available
    via the `EMULATED_STORAGE_SOURCE` environment variable ➍) is owned and only accessible
    by the *shell* user. Its contents might look like [Example 4-13](ch04.html#contents_of_solidusmntsolidusshellsolidu
    "Example 4-13. Contents of /mnt/shell/emulated/") on a device with five users.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. Contents of /mnt/shell/emulated/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As with app data directories, each user gets a dedicated external storage data
    directory named after their user ID. Android uses a combination of mount namespaces
    and bind mounts in order to make each user’s external storage data directory available
    only to the applications that the user starts, without showing them other users’
    data directories. Because all applications are forked off the *zygote* process
    (discussed in [Chapter 2](ch02.html "Chapter 2. Permissions")), external storage
    setup is implemented in two steps: the first one is common to all processes, and
    the second is specific to each process. First, mount points that are shared by
    all forked app processes are set up in the unique *zygote* process. Then dedicated
    mount points, which are visible only to that process, are set up as part of each
    app’s process specialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first look at the shared part in the *zygote* process. [Example 4-14](ch04.html#mount_point_setup_in_zygote
    "Example 4-14. Mount point setup in zygote") shows an excerpt of the `initZygote()`
    function (found in *dalvik/vm/Init.cpp*) that highlights mount point setup.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. Mount point setup in zygote
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, *zygote* passes the `CLONE_NEWNS` flag to the `unshare()` system call
    ➊ in order to create a new, private mount namespace that will be shared by all
    its children (app processes). It then marks the root filesystem (mounted at /)
    as a slave by passing the `MS_SLAVE` flag to the `mount()` system call ➋. This
    ensures that changes from the default mount namespace, such as mounting encrypted
    containers or removable storage, only propagate to its children, while at the
    same time making sure that any mounts created by children do not propagate into
    the default namespace. Finally, *zygote* creates the memory-backed `EMULATED_STORAGE_TARGET`
    (usually */storage/emulated/*) mount point by creating a *tmpfs* filesystem ➌,
    which children use to bind mount external storage into their private namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-15](ch04.html#external_storage_setup_for_app_processes "Example 4-15. External
    storage setup for app processes") shows the process-specific mount point setup
    found in *dalvik/vm/native/dalvik_system_Zygote.cpp* that is executed when forking
    each app process off *zygote*. (Error handling, logging, and some variable declarations
    have been omitted.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. External storage setup for app processes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `mountEmulatedStorage()` function first obtains the current user ID
    from the process UID ➊, then uses the `unshare()` system call to create a new
    mount namespace for the process by passing the `CLONE_NEWNS` flag ➋. The function
    then obtains the values of the `EMULATED_STORAGE_SOURCE` ➌, `EMULATED_STORAGE_TARGET`
    ➍, and `EXTERNAL_STORAGE` ➎ environment variables, which are all initialized in
    the device-specific *init.rc* file (see ➌, ➍, and ➎ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")). It
    then prepares the mount source ➏ and target ➐ directory paths based on the values
    of `EMULATED_STORAGE_SOURCE`, `EMULATED_STORAGE_TARGET`, and the current user
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: The directories are created if they don’t exist, and then the method bind mounts
    the source directory (such as */mnt/shell/emulated/0* for the owner user) at the
    target path (for example, */storage/emulated/0* for the owner user) ➑. This ensures
    that external storage is accessible from the Android shell (started with the *adb
    shell* command), which is used extensively for application development and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to recursively bind mount the target directory at the fixed
    legacy directory (*/storage/emulated/legacy/*) ➒. The legacy directory is symlinked
    to */sdcard/* in the device-specific *init.rc* file (➏ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")) for
    backward compatibility with apps that hardcode this path (normally obtained using
    the `android.os.Environment.getExternalStorageDirectory()` API).
  prefs: []
  type: TYPE_NORMAL
- en: After all steps have been executed, the newly created app process is guaranteed
    to see only the external storage allotted to the user that started it. We can
    verify this by looking at the list of mounts for two app process executed by different
    users as shown in [Example 4-16](ch04.html#list_of_mount_points_for_process_started
    "Example 4-16. List of mount points for process started by different users").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16. List of mount points for process started by different users
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the process started by the owner user with PID 7382 has a */storage/ emulated/0*
    mount point ➋, which is a bind mount of */mnt/shell/emulated/0/*, and process
    7538 (started by a secondary user) has a */storage/emulated/10* mount point ➎,
    which is a bind mount of */mnt/shell/emulated/10/*.
  prefs: []
  type: TYPE_NORMAL
- en: Because neither process has a mount point for the other process’s external storage
    directory, each process can only see and modify its own files. Both processes
    have a */storage/emulated/legacy* mount point (➌ and ➏), but because it is bound
    to different directories (*/storage/emulated/0/* and */mnt/ shell/emulated/10/*,
    respectively), each process sees different contents. Both process can see */mnt/shell/emulated/*
    (➊ and ➍), but because this directory is only accessible to the *shell* user (permissions
    0700), app processes cannot see its contents.
  prefs: []
  type: TYPE_NORMAL
- en: External Storage Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to emulate the FAT filesystem that was originally used for external
    storage, the *sdcard* FUSE daemon assigns fixed owner, group, and access permissions
    to each file or directory on external storage. Additionally, permissions are not
    changeable, and symlinks and hardlinks are not supported. The assigned owner and
    permission are determined by the permission derivation mode that the *sdcard*
    daemon uses.
  prefs: []
  type: TYPE_NORMAL
- en: In legacy mode (specified with the `-l` option), which is backward-compatible
    with previous Android versions and which is still the default in Android 4.4,
    most files and directories are owned by the root user and their group is set to
    *sdcard_r*. Applications that are granted the `READ_EXTERNAL_STORAGE` permission
    have *sdcard_r* as one of their supplementary groups, and thus can read most files
    on external storage even if they were originally created by a different application.
    [Example 4-17](ch04.html#owner_and_permissions_of_files_on_extern "Example 4-17. Owner
    and permissions of files on external storage") shows the owner and permission
    of files and directories in the root of external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-17. Owner and permissions of files on external storage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In previous versions of Android, all files and directories on external storage
    were assigned the same owner and permissions, but Android 4.4 treats the application-specific
    external files directory (*Android/data/<package-name>/*, the exact path is returned
    by the `Context.getExternalFilesDir()` method) differently. Applications don’t
    have to hold the `WRITE_EXTERNAL_STORAGE` permission in order to read and write
    files in this directory because it is owned by the creating application.
  prefs: []
  type: TYPE_NORMAL
- en: That said, even in Android 4.4, the application’s external files directory is
    accessible by any application that holds the `READ_EXTERNAL_STORAGE` or `WRITE_EXTERNAL_STORAGE`
    permissions because the group of the directory is set to *sdcard_r*, as shown
    in [Example 4-18](ch04.html#owner_and_permissions_of_an_appapostroph "Example 4-18. Owner
    and permissions of an app’s external files directory").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-18. Owner and permissions of an app’s external files directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Android 4.4 supports a more flexible permission derivation mode that is based
    on directory structure, and which is specified by passing the `-d` option to the
    *sdcard* daemon. This derivation mode sets dedicated groups to the directories
    *Pictures/* and *Music/* (*sdcard_pics* ➊ and *sdcard_av* ➋, as shown in [Example 4-19](ch04.html#directory_owners_and_permission_in_the_n
    "Example 4-19. Directory owners and permission in the new permission derivation
    mode")), which allows for fine-grained control over which files applications can
    access. As of this writing, Android doesn’t support such fine-grained access control,
    but it can easily be implemented by defining additional permissions that map to
    the *sdcard_pics* and *sdcard_av* groups. In the directory-structure-based permission
    mode, user directories are hosted under *Android/user/* ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While this new permission derivation mode is supported in Android 4.4, as
    of this writing, Nexus devices still use the legacy permission mode.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-19. Directory owners and permission in the new permission derivation
    mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Other Multi-User Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides dedicated app directories, external storage and settings, other Android
    features also support a multi-user device configuration. For example, as of version
    4.4, Android’s credential storage (which allows for secure management of cryptographic
    keys) lets each user have their own key storage. (We discuss credential storage
    in more detail in [Chapter 7](ch07.html "Chapter 7. Credential Storage").)
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Android’s online account database, accessible via the `AccountManager`
    API, has been extended to allow secondary users to have their own accounts, as
    well as to allow restricted profiles to share some of the primary user’s accounts
    (if the app that needs account access supports it). We discuss online account
    support and the `AccountManager` API in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").
  prefs: []
  type: TYPE_NORMAL
- en: And finally, Android allows setting different device administration policies
    for each user. As of version 4.4, it also supports setting up per-user VPNs that
    only route a single user’s traffic and which are not accessible by other users.
    (We discuss device administration, VPNs, and other enterprise features in [Chapter 9](ch09.html
    "Chapter 9. Enterprise Security").)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android allows multiple users to share a device by providing dedicated internal
    and external storage to each user. Multi-user support follows the established
    security model and each user’s applications are assigned a unique UID and run
    in dedicated processes that cannot access other user’s data. User isolation is
    achieved by combining a UID assignment scheme that takes into account the user
    ID and storage mounting rules that allow each user to only see their own storage.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, multi-user support is only available on devices without
    telephony support (usually tablets), as the behavior of telephony in a multi-user
    environment is currently undefined. Most Android features, including account database
    management, credential storage, device policies, and VPN support are multi-user-aware
    and allow each user to have their own configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[29](#ch04fn01)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#ch04fn02)]) Google, “External Storage Technical Information,” *[http://source.android.com/devices/tech/storage/index.html](http://source.android.com/devices/tech/storage/index.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#ch04fn03)]) “Filesystem in Userspace,” *[http://fuse.sourceforge.net/](http://fuse.sourceforge.net/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#ch04fn04)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[33](#ch04fn05)]) Michael Kerrisk, *The Linux Programming Interface: A Linux
    and UNIX System Programming Handbook*, No Starch Press, 2010, pp. 261'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#ch04fn06)]) Ibid., 598
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#ch04fn07)]) Ibid., 603
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#ch04fn08)]) Linux Kernel, *Shared Subtrees*, *[https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[37](#ch04fn09)]) Google, “External Storage: Typical Configuration Examples,”
    *[http://source.android.com/devices/tech/storage/config-example.html](http://source.android.com/devices/tech/storage/config-example.html)*'
  prefs: []
  type: TYPE_NORMAL
