<html><head></head><body>
		<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_293"/><strong><span class="big">10</span></strong><br/><strong>STRING DATA TYPES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">After integers, character strings are probably the most commonly used data type in modern programs; after arrays, they’re the second most commonly used composite data type. A string is a sequence of objects. Most often, the term <em>string</em> describes a sequence of character values, but it’s also possible to have strings of integers, real values, Boolean values, and so on (for example, I’ve already discussed bit strings in this book and in <em>WGC1</em>). In this chapter, though, we’ll stick to character strings.</p>&#13;
		<p class="indent">In general, a character string possesses two main attributes: a <em>length</em> and some <em>character data</em>. Character strings can also possess other attributes, such as the <em>maximum length</em> allowable for that particular variable or a <em>reference count</em> specifying how many different string variables refer to the same character string. We’ll look at these attributes and how programs can use them, as well as the various string formats and possible string operations. Specifically, this chapter discusses the following topics:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Character string formats including zero-terminated strings, length-prefixed strings, HLA strings, and 7-bit strings</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_294"/>&#13;
			<p class="noindent">When to use (and when not to use) standard library string processing functions</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">Static, pseudo-dynamic, and dynamic strings</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Reference counting and strings</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Unicode and UTF-8/UTF-16/UTF-32 character data in strings</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">String manipulation consumes a fair amount of CPU time in today’s applications. Therefore, it’s important to understand how programming languages represent and operate on character strings if you want to write code that manipulates strings efficiently. This chapter provides the basic information you’ll need to do so.</p>&#13;
		<h3 class="h3" id="ch00lev1sec84"><strong>10.1 Character String Formats</strong></h3>&#13;
		<p class="noindent">Different languages use different data structures to represent strings. Some string formats use less memory, others allow faster processing, some are more convenient to use, some are easy for compiler writers to implement, and some provide additional functionality for the programmer and operating system.</p>&#13;
		<p class="indent">Although their internal representations vary, all string formats have one thing in common: the character data. This is a sequence of 0 or more bytes (the term <em>sequence</em> implies that the order of the characters is important). How a program references this sequence of characters varies by format. In some string formats, the sequence of characters is kept in an array; in other string formats the program maintains a pointer to the sequence of characters elsewhere in memory.</p>&#13;
		<p class="indent">All character string formats share the length attribute; however, they use several different ways to represent the length of a string. Some string formats use a special <em>sentinel character</em> to mark the end of the string. Other formats precede the character data with a numeric value that specifies the number of characters in the sequence. Still others encode the length as a numeric value in a variable that is not connected to the character sequence. Some character string formats use a special bit (set or cleared) to mark the end of a string. Finally, some string formats use a combination of these methods. How a particular string format determines the length of a string can have a big impact on the performance of the functions that manipulate those strings. It can also affect how much extra storage is needed to represent string data.</p>&#13;
		<p class="indent">Some string formats provide additional attributes, such as a maximum length and reference count values, that certain string functions can use to operate on string data more efficiently. These extra attributes are optional insofar as they aren’t strictly necessary to define a string value. They do, however, allow string manipulation functions to provide certain tests for correctness or to work more efficiently than they would otherwise.</p>&#13;
		<p class="indent">To help you better understand the reasoning behind the design of character strings, let’s look at some common string representations popularized by various languages.</p>&#13;
		<h4 class="h4" id="ch00lev2sec112"><span epub:type="pagebreak" id="page_295"/><strong>10.1.1 Zero-Terminated Strings</strong></h4>&#13;
		<p class="noindent">Without question, <em>zero-terminated strings</em> (see <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>) are probably the most common string representation in use today, because this is the native string format for C, C++, and several other languages. In addition, you’ll find zero-terminated strings used in programs written in languages that don’t have a specific native string format, such as assembly language.</p>&#13;
		<div class="image" id="ch10fig1">&#13;
			<img alt="Image" src="../images/10fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-1: Zero-terminated string format</em></p>&#13;
		<p class="indent">A zero-terminated ASCII string, also called an <em>ASCIIz</em> string or a <em>zstring</em>, is a sequence containing zero or more 8-bit character codes and ending with a byte containing <code>0</code>—or, in the case of Unicode (UTF-16), a sequence containing zero or more 16-bit character codes and ending with a 16-bit word containing <code>0</code>. For UTF-32 strings, each item in the string is 32 bits (4 bytes) wide, ending with a 32-bit <code>0</code> value. For example, in C/C++, the ASCIIz string <code>"abc"</code> requires 4 bytes: 1 byte for each of the three characters <code>a</code>, <code>b</code>, and <code>c</code>, followed by a <code>0</code> byte.</p>&#13;
		<p class="indent">Zero-terminated strings have a few advantages over other string formats:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Zero-terminated strings can represent strings of any practical length with only 1 byte of overhead (2 bytes in UTF-16, 4 in UTF-32).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Given the popularity of the C/C++ programming languages, high-performance string processing libraries are available that work well with zero-terminated strings.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Zero-terminated strings are easy to implement. Indeed, except for dealing with string literal constants, the C/C++ programming languages don’t provide native string support. As far as those languages are concerned, strings are just arrays of characters. That’s probably why C’s designers chose this format in the first place—so they wouldn’t have to clutter up the language with string operators.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You can easily represent zero-terminated strings in any language that provides the ability to create an array of characters.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">However, zero-terminated strings also have disadvantages that mean they are not always the best choice for representing character string data:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">String functions often aren’t very efficient when operating on zero-terminated strings. Many string operations need to know the length of the string before working on the string data. The only reasonable way to compute the length of a zero-terminated string is to scan the string from the beginning to the end. The longer your strings are, the slower <span epub:type="pagebreak" id="page_296"/>this function runs, so the zero-terminated string format isn’t the best choice if you need to process long strings.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Although it’s a minor problem, you cannot easily represent the character code <code>0</code> (such as the NUL character in ASCII and Unicode) with the zero-terminated string format.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Zero-terminated strings don’t contain any information that tells you how long the string can grow beyond the terminating <code>0</code> byte. Therefore, some string functions, like concatenation, can only extend the length of an existing string variable and check for overflow if the caller explicitly passes the maximum length.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">As noted, one nice feature of zero-terminated strings is that you can easily implement them using pointers and arrays of characters. Consider the following C/C++ statement:</p>&#13;
		<pre class="programs">someCharPtrVar = "Hello World";</pre>&#13;
		<p class="indent">Here’s the code the Borland C++ v5.0 compiler generates for this statement:</p>&#13;
		<pre class="programs">&#13;
			;       char *someCharPtrVar;<br/>   ;        someCharPtrVar = "Hello World";<br/>   ;<br/>@1:<br/>; "offset" means "take the address of" and "s@" is<br/>; the compiler-generated label where the string<br/>; "Hello World" can be found.<br/><br/>    mov       eax,offset s@<br/>        .<br/>        .<br/>        .<br/>_DATA   segment dword public use32 'DATA'<br/>;       s@+0:<br/>        ; Zero-terminated sequence of characters<br/>        ; emitted for the literal string "Hello World":<br/><br/>s@      label   byte<br/>        db      "Hello World",0<br/><br/>        ;       s@+12:<br/>        db      "%s",0<br/>        align   4<br/>_DATA   ends</pre>&#13;
		<p class="indent">The Borland C++ compiler simply emits the literal string <code>"Hello World"</code> to the global data segment in memory and then loads the <code>someCharPtrVar</code> variable with the address of the first character of this string literal in the data segment. From that point forward, the program can refer to the string data indirectly via this pointer. This is a very convenient scheme from the compiler writer’s point of view.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_297"/>When using zero-terminated strings in a language like C, C++, Python, or any of a dozen other languages that have adopted C’s string format, you can improve the performance of your string-handling code sequences by keeping a few points in mind:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Try to use the language’s runtime library functions rather than attempting to code comparable functions yourself. Most compiler vendors provide highly optimized versions of their string functions that will probably run many times faster than code you would write yourself.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Once you’ve computed the length of a string by scanning the entire string, save that length for future use (rather than recomputing it every time you need it).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Avoid copying string data from one string variable to another. Doing so is one of the more expensive operations (after length computation) in applications using zero-terminated strings.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">The following subsections discuss each point in turn.</p>&#13;
		<h5 class="h5" id="ch00lev3sec61"><strong>10.1.1.1 When to Use C Standard Library String Functions</strong></h5>&#13;
		<p class="noindent">Some programmers are skeptical that someone else could write faster or higher-quality code. But when it comes to standard library functions, you should avoid the temptation to replace them with code of your own choosing. Unless the library code you’re considering is especially bad, chances are you won’t come close to duplicating its efficiency. This is especially true for string functions that handle zero-terminated strings in languages like C and C++. There are three main reasons why standard libraries generally perform better than code you write yourself: experience, maturity, and inline substitution.</p>&#13;
		<p class="indent">The typical programmer who writes compiler runtime libraries has a lot of experience with string-handling functions. Although in the past new compilers were often accompanied by notoriously inefficient libraries, over time compiler programmers have gained considerable experience writing those library routines and have figured out how to deliver well-written string-handling functions. Unless you’ve spent considerable time writing those same types of routines, it’s highly unlikely that your code will perform as well as theirs. Many compiler vendors purchase their standard library code from a third party that specializes in writing library code, so now, even if the compiler you’re using is fairly new, it may have a good library. Few commercial compilers today contain horribly inefficient library code. For the most part, only research or “hobby” compilers contain library code so bad that you can easily write something better. Consider a simple example—the C standard library <code>strlen()</code> (string length) function. Here’s a typical implementation of <code>strlen()</code> that an inexperienced programmer might write:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><span epub:type="pagebreak" id="page_298"/>int myStrlen( char *s )<br/>{<br/>    char *start;<br/><br/>    start = s;<br/>    while( *s != 0 )<br/>    {<br/>        ++s;<br/>    }<br/>    return s - start;<br/>}<br/><br/>int main( int argc, char **argv )<br/>{<br/><br/><br/>    printf( "myStrlen = %d", myStrlen( "Hello World" ));<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">The 80x86 machine code that Microsoft’s Visual C++ compiler generates for <code>myStrlen()</code> is probably what any assembly programmer would expect:</p>&#13;
		<pre class="programs">&#13;
			myStrlen PROC                                           ; COMDAT<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 10                           // Pointer to string (s) is passed in RCX register.<br/>        cmp     BYTE PTR [rcx], 0   // Is *s = 0?<br/>        mov     rax, rcx            // Save ptr to start of string to compute length<br/>        je      SHORT $LN3@myStrlen // Bail if we hit the end of the string<br/>$LL2@myStrlen:<br/>; Line 12<br/>        inc     rcx                 // Move on to next char in string<br/>        cmp     BYTE PTR [rcx], 0   // Hit the 0 byte yet?<br/>        jne     SHORT $LL2@myStrlen // If not, repeat loop<br/>$LN3@myStrlen:<br/>; Line 14<br/>        sub     rcx, rax            // Compute length of string.<br/>        mov     eax, ecx            // Return function result in EAX.<br/>; Line 15<br/>        ret     0<br/>myStrlen ENDP</pre>&#13;
		<p class="indent">No doubt, an experienced assembly language programmer could rearrange these particular instructions to speed them up a bit. Indeed, even an average 80x86 assembly language programmer could point out that the 80x86 <code>scasb</code> instruction does most of the work in this code sequence. Although this code is fairly short and easy to understand, by no means will it run as fast as possible. An expert assembly language programmer might note that this loop repeats one iteration for each character in the string and accesses the characters in memory 1 byte at a time, and might improve <span epub:type="pagebreak" id="page_299"/>upon it by unrolling<sup><a id="ch10fn_1"/><a href="footnotes.xhtml#ch10fn1">1</a></sup> the loop and processing more than one character per loop iteration. For example, consider the following HLA standard library <code>zstr.len()</code> function, which computes the length of a zero-terminated string by processing four characters at a time:</p>&#13;
		<pre class="programs">&#13;
			unit stringUnit;<br/><br/>#include( "strings.hhf" );<br/><br/><br/>/*******************************************************************/<br/>/*                                                                 */<br/>/* zlen-                                                           */<br/>/*                                                                 */<br/>/* Returns the current length of the z-string passed as a parm.    */<br/>/*                                                                 */<br/>/*******************************************************************/<br/><br/>procedure zstr.len( zstr:zstring ); @noframe;<br/>const<br/>    zstrp   :text := "[esp+8]";<br/><br/>begin len;<br/><br/>    push( esi );<br/>    mov( zstrp, esi );<br/><br/>    // We need to get ESI dword-aligned before proceeding.<br/>    // If the LO 2 bits of ESI contain 0s, then<br/>    // the address in ESI is a multiple of 4. If they<br/>    // are not both 0, then we need to check the 1,<br/>    // 2, or 3 bytes starting at ESI to see if they<br/>    // contain a zero-terminator byte.<br/><br/>    test( 3, esi );<br/>    jz ESIisAligned;<br/><br/>    cmp( (type char [esi]), #0 );<br/>    je SetESI;<br/>    inc( esi );<br/>    test( 3, esi );<br/>    jz ESIisAligned;<br/><br/>    cmp( (type char [esi]), #0 );<br/>    je SetESI;<br/>    inc( esi );<br/>    test( 3, esi );<br/>    jz ESIisAligned;<br/><br/>    cmp( (type char [esi]), #0 );<br/><span epub:type="pagebreak" id="page_300"/>    je SetESI;<br/>    inc( esi );                 // After this, ESI is aligned.<br/><br/><br/>    ESIisAligned:<br/>        sub( 32, esi );         // To counteract add immediately below.<br/>    ZeroLoop:<br/>        add( 32, esi );         // Skip chars this loop just processed.<br/>    ZeroLoop2:<br/>        mov( [esi], eax );      // Get next four chars into EAX.<br/>        and( $7f7f7f7f, eax );  // Clear HO bit (note:$80-&gt;$00!)<br/>        sub( $01010101, eax );  // $00 and $80-&gt;$FF, all others have pos val.<br/>        and( $80808080, eax );  // Test all HO bits.  If any are set, then<br/>        jnz MightBeZero0;       // we've got a $00 or $80 byte.<br/><br/>        mov( [esi+4], eax );    // The following are all inline expansions<br/>        and( $7f7f7f7f, eax );  // of the above (we'll process 32 bytes on<br/>        sub( $01010101, eax );  // each iteration of this loop).<br/>        and( $80808080, eax );<br/>        jnz MightBeZero4;<br/><br/>        mov( [esi+8], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/>        jnz MightBeZero8;<br/><br/>        mov( [esi+12], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/>        jnz MightBeZero12;<br/><br/>        mov( [esi+16], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/>        jnz MightBeZero16;<br/><br/>        mov( [esi+20], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/>        jnz MightBeZero20;<br/><br/>        mov( [esi+24], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/>        jnz MightBeZero24;<br/><br/>        mov( [esi+28], eax );<br/>        and( $7f7f7f7f, eax );<br/>        sub( $01010101, eax );<br/>        and( $80808080, eax );<br/><span epub:type="pagebreak" id="page_301"/>        jz ZeroLoop;<br/><br/>    // The following code handles the case where we found a $80<br/>    // or a $00 byte. We need to determine whether it was a 0<br/>    // byte and the exact position of the 0 byte. If it was a<br/>    // $80 byte, then we've got to continue processing characters<br/>    // in the string.<br/><br/><br/>    // Okay, we've found a $00 or $80 byte in positions<br/>    // 28..31. Check for the location of the 0 byte, if any.<br/><br/>        add( 28, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 4..7:<br/><br/>    MightBeZero4:<br/>        add( 4, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 8..11:<br/><br/>    MightBeZero8:<br/>        add( 8, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 12..15:<br/><br/>    MightBeZero12:<br/>        add( 12, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 16..19:<br/><br/>    MightBeZero16:<br/>        add( 16, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 20..23:<br/><br/>    MightBeZero20:<br/>        add( 20, esi );<br/>        jmp MightBeZero0;<br/><br/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 24..27:<br/><br/>    MightBeZero24:<br/>        add( 24, esi );<br/><br/><span epub:type="pagebreak" id="page_302"/>    // If we get to this point, we've found a 0 byte in<br/>    // positions 0..3 or we've branched here from one of the<br/>    // above conditions<br/><br/>    MightBeZero0:<br/>        mov( [esi], eax );          // Get the original 4 bytes.<br/>        cmp( al, 0 );               // See if the first byte contained 0.<br/>        je SetESI;<br/>        cmp( ah, 0 );               // See if the second byte contained 0.<br/>        je SetESI1;<br/>        test( $FF_0000, eax );      // See if byte #2 contained a 0.<br/>        je SetESI2;<br/>        test( $FF00_0000, eax );    // See if the HO byte contained 0.<br/>        je SetESI3;<br/><br/>    // Well, it must have been a $80 byte we encountered.<br/>    // (Fortunately, they are rare in ASCII strings, so all this<br/>    // extra computation rarely occurs). Jump back into the 0<br/>    // loop and continue processing.<br/><br/>        add( 4, esi );              // Skip bytes we just processed.<br/>        jmp ZeroLoop2;              // Don't bother adding 32 in the ZeroLoop!<br/><br/>    // The following computes the length of the string by subtracting<br/>    // the current ESI value from the original value and then adding<br/>    // 0, 1, 2, or 3, depending on where we branched out<br/>    // of the MightBeZero0 sequence above.<br/><br/>    SetESI3:<br/>        sub( zstrp, esi );          // Compute length<br/>        lea( eax, [esi+3] );        // +3 since it was in the HO byte.<br/>        pop( esi );<br/>        ret(4);<br/><br/>    SetESI2:<br/>        sub( zstrp, esi );          // Compute length<br/>        lea( eax, [esi+2] );        // +2 since zero was in byte #2<br/>        pop( esi );<br/>        ret(4);<br/><br/>    SetESI1:<br/>        sub( zstrp, esi );          // Compute length<br/>        lea( eax, [esi+1] );        // +1 since zero was in byte #1<br/>        pop( esi );<br/>        ret(4);<br/><br/>    SetESI:<br/>        mov( esi, eax );<br/>        sub( zstrp, eax );          // Compute length. No extra addition since<br/>        pop( esi );                 // 0 was in LO byte.<br/>        ret( _parms_ );<br/><br/>end len;<br/>end stringUnit;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_303"/>Even though this function is much longer and more complex than the simple example given earlier, it runs faster because it processes four characters per loop iteration rather than one, which means it executes far fewer loop iterations. Also, this code reduces loop overhead by unrolling eight copies of the loop (that is, expanding eight copies of the loop body inline), which saves the execution of 87 percent of the loop control instructions. As a result, this code runs anywhere from two to six times faster than the code given earlier; the exact savings depend upon the length of the string.<sup><a id="ch10fn_2"/><a href="footnotes.xhtml#ch10fn2">2</a></sup></p>&#13;
		<p class="indent">The second reason to avoid writing your own library functions is the maturity of the code. Most popular optimizing compilers available today have been around for a while. During this time, the compiler vendors have used their routines, determined where the bottlenecks lie, and optimized their code. When you write your own version of a standard library string-handling function, you probably won’t have comparable time to dedicate to optimizing it—you’ve got your entire application to worry about. Because of project time constraints, you’ll likely never go back and rewrite that string function to improve its performance. Even if there’s a slight performance advantage to your routine now, the compiler vendor may very well update their library in the future, and you could take advantage of those improvements by simply relinking the updated code with your project. However, if you write the library code yourself, it will never improve unless you explicitly update it yourself. Most people are too busy working on new projects to go back and clean up their old code, so the likelihood of improving self-written string functions in the future is quite low.</p>&#13;
		<p class="indent">The third reason for using standard library string functions in a language like C or C++ is the most important: inline expansion. Many compilers recognize certain standard library function names and expand them inline to efficient machine code in place of the function call. This inline expansion can be many times faster than an explicit function call, especially if the function call contains several parameters. As a simple example, consider the following (almost trivial) C program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;string.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>int main( int argc, char **argv )<br/>{<br/>    char localStr[256];<br/><br/>    strcpy( localStr, "Hello World" );<br/>    printf( localStr );<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_304"/>The corresponding 64-bit x86-64 assembly code that Visual C++ produces is quite interesting:</p>&#13;
		<pre class="programs">&#13;
			; Storage for the literal string appearing in the<br/>; strcpy invocation:<br/><br/>_DATA   SEGMENT<br/>$SG6874 DB  'Hello World', 00H<br/>_DATA   ENDS<br/><br/><br/>_TEXT   SEGMENT<br/>localStr$ = 32<br/>__$ArrayPad$ = 288<br/>argc$ = 320<br/>argv$ = 328<br/>main    PROC<br/>; File c:\users\rhyde\test\t\t\t.cpp<br/>; Line 6<br/>$LN4:<br/>    sub rsp, 312                ; 00000138H<br/>    mov rax, QWORD PTR __security_cookie<br/>    xor rax, rsp<br/>    mov QWORD PTR __$ArrayPad$[rsp], rax<br/>; Line 9<br/>    movsd   xmm0, QWORD PTR $SG6874<br/>; Line 10<br/>    lea rcx, QWORD PTR localStr$[rsp]<br/>    mov eax, DWORD PTR $SG6874+8<br/>    movsd   QWORD PTR localStr$[rsp], xmm0<br/>    mov DWORD PTR localStr$[rsp+8], eax<br/>    call    printf<br/>; Line 11<br/>    xor eax, eax<br/>; Line 12<br/>    mov rcx, QWORD PTR __$ArrayPad$[rsp]<br/>    xor rcx, rsp<br/>    call    __security_check_cookie<br/>    add rsp, 312                ; 00000138H<br/>    ret 0<br/>main    ENDP<br/>_TEXT   ENDS</pre>&#13;
		<p class="indent">The compiler recognizes what’s going on and substitutes four inline instructions that copy the 12 bytes of the string from the literal constant in memory to the <code>localStr</code> variable (specifically, it copies 8 bytes using the XMM0 register and 4 bytes using the EAX register; note that this code uses RCX to pass the address of <code>localStr</code> to the <code>printf()</code> function). The overhead of a call and return to an actual <code>strcpy()</code> function will be more expensive than this (and that’s without considering the work needed to copy the string data). This example demonstrates quite well why you should usually call standard library functions rather than writing your own “optimized” functions to do the same job.</p>&#13;
		<h5 class="h5" id="ch00lev3sec62"><span epub:type="pagebreak" id="page_305"/><strong>10.1.1.2 When Not to Use Standard Library Functions</strong></h5>&#13;
		<p class="noindent">Although, as you’ve seen, it’s usually better to call a standard library routine rather than writing your own version, there are some special situations when you should <em>not</em> rely on one or more library functions in the standard library.</p>&#13;
		<p class="indent">Library functions work great when they perform exactly the function you need—no more and no less. One area where programmers get into trouble is when they misuse a library function and call it to do something that it wasn’t really intended to do, or they need only part of the functionality it provides. For example, consider the C standard library <code>strcspn()</code> function:</p>&#13;
		<pre class="programs">&#13;
			size_t strcspn( char *<span class="codeitalic1">source</span>, char *<span class="codeitalic1">cset</span> );</pre>&#13;
		<p class="indent">This function returns the number of characters in the <span class="codeitalic">source</span> string up to the first character it finds that also appears in the <span class="codeitalic">cset</span> string. It’s not at all uncommon to see calls to this function that look like this:</p>&#13;
		<pre class="programs">&#13;
			len = strcspn( <span class="codeitalic1">SomeString</span>, "a" );</pre>&#13;
		<p class="indent">The intent here is to return the number of characters in <span class="codeitalic">SomeString</span> before the first occurrence of an <code>a</code> character in that string. That is, it attempts to do something like the following:</p>&#13;
		<pre class="programs">&#13;
			len = 0;<br/>while<br/>(<br/>        <span class="codeitalic1">SomeString</span>[ len ] != '\0'<br/>    &amp;&amp;  <span class="codeitalic1">SomeString</span>[ len ] != 'a'<br/>){<br/>    ++len;<br/>}</pre>&#13;
		<p class="indent">Unfortunately, the call to the <code>strcspn()</code> function is probably a lot slower than this simple <code>while</code> loop implementation. That’s because <code>strcspn()</code> actually does a lot more work than search for a single character within a string. It looks for any character from a set of characters within the source string. The generic implementation of this function might be something like:</p>&#13;
		<pre class="programs">&#13;
			len = 0;<br/>for(;;) // Infinite loop<br/>{<br/>    ch = <span class="codeitalic1">SomeString</span>[ len ];<br/>    if( ch == '\0' ) break;<br/>    for( i=0; i&lt;strlen( cset ); ++i )<br/>    {<br/>        if( ch == cset[i] ) break;<br/>    }<br/>    if( ch == cset[i] ) break;<br/>    ++len;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_306"/>With a little analysis (and noting that we have a pair of nested loops here), it’s clear that this code is slower than the code given earlier, even if you pass in a <code>cset</code> string containing a single character. This is a classic example of calling a function that is more general than you need, because it searches for any of several termination characters rather than the special case of a single terminating character. When a function does exactly what you want, using the standard library’s version of it is a good idea. However, when it does more than you need, using the standard library function can be expensive, and it’s better to write your own version.</p>&#13;
		<h5 class="h5" id="ch00lev3sec63"><strong>10.1.1.3 Why to Avoid Length Recomputing Data</strong></h5>&#13;
		<p class="noindent">The last example in the previous section demonstrates a common C programming mistake. Consider the coded fragment:</p>&#13;
		<pre class="programs">&#13;
			for( i=0; i&lt;strlen( cset ); ++i )<br/>{<br/>    if( ch == cset[i] ) break;<br/>}</pre>&#13;
		<p class="indent">On each iteration of this loop, the code tests the loop index to see if it is less than the length of the <code>cset</code> string. But because the loop body does not modify the <code>cset</code> string (and because, presumably, this is not a multithreaded application with another thread modifying the <code>cset</code> string), there’s really no need to recompute the string length on each iteration of this loop. Look at the code that the Microsoft Visual C++ 32-bit compiler emits for this code fragment:</p>&#13;
		<pre class="programs">&#13;
			; Line 10<br/>        mov     DWORD PTR i$1[rsp], 0 ;for(i = 0;...;...)<br/>        jmp     SHORT $LN4@main<br/><br/>$LN2@main:<br/>        mov     eax, DWORD PTR i$1[rsp] ;for(...;...;++i)<br/>        inc     eax<br/>        mov     DWORD PTR i$1[rsp], eax<br/><br/>$LN4@main: ;for(...; i &lt; strlen(localStr);...)<br/>        movsxd  rax, DWORD PTR i$1[rsp]<br/>        mov     QWORD PTR tv65[rsp], rax<br/>        lea     rcx, QWORD PTR localStr$[rsp]<br/>        call    strlen<br/>        mov     rcx, QWORD PTR tv65[rsp]<br/>        cmp     rcx, rax<br/>        jae     SHORT $LN3@main<br/>; Line 12<br/>        movsx   eax, BYTE PTR ch$[rsp]<br/>        movsxd  rcx, DWORD PTR i$1[rsp]<br/>        movsx   ecx, BYTE PTR localStr$[rsp+rcx]<br/>        cmp     eax, ecx<br/>        jne     SHORT $LN5@main<br/>        jmp     SHORT $LN3@main<br/><span epub:type="pagebreak" id="page_307"/>$LN5@main:<br/>; Line 13<br/>        jmp     SHORT $LN2@main<br/>$LN3@main:</pre>&#13;
		<p class="indent">Again, the machine code recalculates the string’s length on every iteration of the innermost <code>for</code> loop, but because the <code>cset</code> string’s length never changes, this is totally unnecessary. We can easily rectify this problem by rewriting the code fragment this way:</p>&#13;
		<pre class="programs">&#13;
			slen = strlen( cset );<br/>len = 0;<br/>for(;;) // Infinite loop<br/>{<br/>    ch = SomeString[ len ];<br/>    if( ch == '\0' ) break;<br/>    for( i=0; i&lt;slen; ++i )<br/>    {<br/>        if( ch == cset[i] ) break;<br/>    }<br/>    if( ch == cset[i] ) break;<br/>    ++len;<br/>}</pre>&#13;
		<p class="indent">On the plus side, recent versions of Microsoft’s VC++ compiler will recognize this situation if you have optimizations turned on. As VC++ determines that the string length is a loop-invariant calculation (that is, its value does not change from one loop iteration to the next), VC++ will move the call to <code>strlen()</code> out of the loop. Unfortunately, VC++ can’t catch this in every situation. For example, if you call some function that VC++ doesn’t know about and you pass it the address of <code>localStr</code> as a (non-<code>const</code>) parameter, VC++ will have to assume that the string’s length could change (even if it doesn’t) and it won’t be able to move the <code>strlen()</code> call out of the loop.</p>&#13;
		<p class="indent">A fair number of string operations require the string’s length before they can execute. Consider the <code>strdup()</code> function commonly found in many C libraries.<sup><a id="ch10fn_3"/><a href="footnotes.xhtml#ch10fn3">3</a></sup> The following code is a common implementation of this function:</p>&#13;
		<pre class="programs">&#13;
			char *strdup( char *src )<br/>{<br/>    char *result;<br/><br/>    result = malloc( strlen( src ) + 1 );<br/>    assert( result != NULL ); // Check malloc check<br/>    strcpy( result, src );<br/>    return result;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_308"/>Fundamentally, nothing is wrong with this implementation of <code>strdup()</code>. If you know absolutely nothing about the string object you’re passing as a parameter, then you must compute the string’s length so you know how much memory to allocate for a copy of that string. Consider, however, the following code sequence that calls <code>strdup()</code>:</p>&#13;
		<pre class="programs">&#13;
			len = strlen( someStr );<br/>if( len == 0 )<br/>{<br/>    newStr = NULL;<br/>}<br/>else<br/>{<br/>    newStr = strdup( someStr );<br/>}</pre>&#13;
		<p class="indent">The problem here is that you wind up calling <code>strlen()</code> twice: once for the explicit call to <code>strlen()</code> in this code fragment, and once for the call buried in the <code>strdup()</code> function. Worse, it isn’t obvious that you’re calling <code>strlen()</code> twice, so it’s not even clear that you’re wasting CPU cycles in this code. This is another example of calling a function that is more general than you need, causing the program to recompute the string’s length (an inefficient process). One solution is to provide a less general version of <code>strdup()</code>, say <code>strduplen()</code>, that lets you pass it the length of the string you’ve already computed. You could implement <code>strduplen()</code> as follows:</p>&#13;
		<pre class="programs">&#13;
			char *strduplen( char *src, size_t len)<br/>{<br/>    char *result;<br/><br/>    // Allocate storage for new string:<br/><br/>    result = malloc( len + 1 );<br/>    assert( result != NULL );<br/><br/>    // Copy the source string and<br/>    // 0 byte to the new string:<br/><br/>    memcpy( result, src, len+1 );<br/>    return result;<br/>}</pre>&#13;
		<p class="indent">Notice the use of <code>memcpy()</code> rather than <code>strcpy()</code> (or, better yet, <code>strncpy()</code>). Again, we already know the length of the string, so there’s no need to execute any code looking for the <code>0</code> terminating byte (as both <code>strcpy()</code> and <code>strncpy()</code> will do). Of course, this function implementation assumes that the caller passes the correct length, but that’s a standard C assumption for most string and array operations.</p>&#13;
		<h5 class="h5" id="ch00lev3sec64"><span epub:type="pagebreak" id="page_309"/><strong>10.1.1.4 Why to Avoid Copying Data</strong></h5>&#13;
		<p class="noindent">Copying strings, especially long strings, can be a time-consuming process on a computer. Most programs maintain string data in memory, and memory is much slower than the CPU (often by an order of magnitude or more). Although cache memory can help mitigate this problem, processing a lot of string data can eliminate other data from the cache and lead to thrashing problems if you don’t frequently reuse all the string data you move through the cache. It’s not always possible to avoid moving string data around, but many programs needlessly copy data, and that can hamper program performance.</p>&#13;
		<p class="indent">A better solution is to pass around <em>pointers</em> to zero-terminated strings rather than copying those strings from string variable to string variable. Pointers to zero-terminated strings can fit in registers and don’t consume much memory when you use memory variables to hold them. Therefore, passing pointers has far less impact on cache and CPU performance than copying string data among string variables.</p>&#13;
		<p class="indent">As you’ve seen in this section, zero-terminated string functions are generally less efficient than functions that manipulate other types of strings. Furthermore, programs that utilize zero-terminated strings tend to make mistakes, such as calling <code>strlen()</code> multiple times or abusing generic functions to achieve specific goals. Fortunately, designing and using a more efficient string format is easy enough in languages whose native string format is the zero-terminated string.</p>&#13;
		<h4 class="h4" id="ch00lev2sec113"><strong>10.1.2 Length-Prefixed Strings</strong></h4>&#13;
		<p class="noindent">A second common string format, <em>length-prefixed strings</em>, overcomes some of the problems with zero-terminated strings. Length-prefixed strings are common in languages like Pascal; they generally consist of a single byte that specifies the length of the string, followed by zero or more 8-bit character codes (see <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>). In a length-prefixed scheme, the string <code>"String"</code> would consist of 4 bytes: the length byte (<code>6</code>), followed by the characters <code>S</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.</p>&#13;
		<div class="image" id="ch10fig2">&#13;
			<img alt="Image" src="../images/10fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-2: Length-prefixed string format</em></p>&#13;
		<p class="indent">Length-prefixed strings solve two of the problems associated with zeroterminated strings:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">NUL characters can be represented in length-prefixed strings.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">String operations are more efficient.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_310"/>Another advantage to length-prefixed strings is that the length is usually located at position <code>0</code> in the string (if we view the string as an array of characters), so the first character of the string begins at index <code>1</code> in the array representation of the string. For many string functions, having a <code>1</code>-based index into the character data is much more convenient than a <code>0</code>-based index (which zero-terminated strings use).</p>&#13;
		<p class="indent">Length-prefixed strings do suffer from their own drawbacks, the principal one being that they’re limited to a maximum of 255 characters in length (assuming a 1-byte length prefix). You can remove this limitation by using a 2- or 4-byte length value, but doing so increases the amount of overhead data from 1 to 2 or 4 bytes. It also changes the starting index of the string from 1 to either 2 or 4, eliminating the <code>1</code>-based index feature. While there are ways to overcome this problem, they entail even more overhead.</p>&#13;
		<p class="indent">Many string functions are much more efficient with length-prefixed strings. Obviously, computing the length of a string is a trivial operation—it’s just a memory access—but other string functions that ultimately need the string’s length (such as concatenation and assignment) are usually more efficient than similar functions for zero-terminated strings. Furthermore, you don’t have to worry about recomputing the string’s length every time you call a string function that is built into the language’s standard library.</p>&#13;
		<p class="indent">Despite these advantages, don’t get the impression that programs using length-prefixed string functions are always going to be efficient. You can still waste many CPU cycles by needlessly copying data. As with zero-terminated strings, if you use only a subset of a string function’s capabilities, you can waste lots of CPU cycles performing unnecessary tasks.</p>&#13;
		<p class="indent">When using length-prefixed string functions, keep the following points in mind:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Try to use the language’s runtime library functions rather than attempting to code comparable functions yourself. Most compiler vendors provide highly optimized versions of their string functions that will probably run many times faster than code you would write yourself.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Although computing the string length when using the length-prefixed string format is fairly trivial, many (Pascal) compilers actually emit a function call to extract the length value from the string’s data. The function call and return is far more expensive than retrieving the length value from a variable. So, once you compute the string’s length, consider saving that length in a local variable if you intend to use that value again. Of course, if a compiler is smart enough to replace a call to the length function with a simple data fetch from the string’s data structure, this “optimization” won’t buy you much.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Avoid copying string data from one string variable to another. Doing so is one of the more expensive operations in programs using length-prefixed strings. Passing around pointers to strings has the same benefit as for zero-terminated strings.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h4 class="h4" id="ch00lev2sec114"><span epub:type="pagebreak" id="page_311"/><strong>10.1.3 Seven-Bit Strings</strong></h4>&#13;
		<p class="noindent">The 7-bit string format is an interesting option that works for 7-bit encodings like ASCII. It uses the (normally unused) higher-order bit of the characters in the string to indicate the end of the string. All but the last character code in the string has its HO bit clear, and the last character in the string has its HO bit set (see <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>).</p>&#13;
		<div class="image" id="ch10fig3">&#13;
			<img alt="Image" src="../images/10fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-3: Seven-bit string format</em></p>&#13;
		<p class="indent">This 7-bit string format has several disadvantages:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">You have to scan the entire string in order to determine the length of the string.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You cannot have zero-length strings in this format.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Few languages provide literal string constants for 7-bit strings.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You’re limited to a maximum of 128 character codes, although this is fine when you are using plain ASCII.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">However, the big advantage of 7-bit strings is that they don’t require any overhead bytes to encode the length. Assembly language (using a macro to create literal string constants) is probably the best language to use when dealing with 7-bit strings. Because the benefit of 7-bit strings is that they’re compact and assembly language programmers tend to worry most about compactness, this is a good match. Here’s an HLA macro that converts a literal string constant to a 7-bit string:</p>&#13;
		<pre class="programs">&#13;
			#macro sbs( s );<br/><br/>    // Grab all but the last character of the string:<br/><br/>    (@substr( s, 0, @length(s) - 1) +<br/><br/>        // Concatenate the last character<br/>        // with its HO bit set:<br/><br/>        char<br/>        (<br/>            uns8<br/>            (<br/>               char( @substr( s, @length(s) - 1, 1))<br/>            ) | $80<br/>        )<br/>    )<br/><span epub:type="pagebreak" id="page_312"/>#endmacro<br/>    .<br/>    .<br/>    .<br/>byte sbs( "Hello World" );</pre>&#13;
		<p class="indent">Because few languages provide support for 7-bit strings, the first suggestion that applied to zero-terminated and length-prefixed strings doesn’t apply to 7-bit strings: you’ll probably have to write your own string-handling functions. Computing lengths and copying data are expensive operations even with 7-bit strings, however, so these two suggestions still apply:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Once you’ve computed the length of a string by scanning the entire string, save that length for future use (rather than recomputing it every time you need it).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Avoid copying string data from one string variable to another. Doing so is one of the more expensive operations in programs using 7-bit strings.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h4 class="h4" id="ch00lev2sec115"><strong>10.1.4 HLA Strings</strong></h4>&#13;
		<p class="noindent">As long as you’re not too concerned about a few extra bytes of overhead per string, you can create a string format that combines the advantages of both length-prefixed and zero-terminated strings without their respective disadvantages. The High-Level Assembly language has done this with its native string format.<sup><a id="ch10fn_4"/><a href="footnotes.xhtml#ch10fn4">4</a></sup></p>&#13;
		<p class="indent">The biggest drawback to the HLA character string format is the amount of overhead required for each string (which can be significant, percentage-wise, if you’re in a memory-constrained environment and you process many small strings). HLA strings contain a length prefix and a zero-terminating byte, as well as some other information, totaling 9 bytes of overhead per string.<sup><a id="ch10fn_5"/><a href="footnotes.xhtml#ch10fn5">5</a></sup></p>&#13;
		<p class="indent">The HLA string format uses a 4-byte length prefix, allowing character strings to be just over 4 billion characters long (far more than any practical application will use). HLA also appends a <code>0</code> byte to the character string data, so HLA strings are compatible with string functions that reference (but do not change the length of) zero-terminated strings. The remaining 4 bytes of overhead in an HLA string contain the maximum legal length for that string (plus a <code>0</code> terminating byte). Having this extra field allows HLA string functions to check for string overflow, if necessary. In memory, HLA strings take the form shown in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>&#13;
		<div class="image" id="ch10fig4">&#13;
			<img alt="Image" src="../images/10fig04.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-4: HLA string format</em></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_313"/>The 4 bytes immediately before the first character of the string contain the current string length. The 4 bytes preceding the current string length contain the maximum string length. Immediately following the character data is a <code>0</code> byte. Finally, HLA always ensures that the string data structure’s length is a multiple of 4 bytes for performance reasons, so there may be up to 3 additional bytes of padding at the end of the object in memory. (Note that the string shown in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a> requires only 1 byte of padding to ensure that the data structure is a multiple of 4 bytes in length.)</p>&#13;
		<p class="indent">HLA string variables are actually pointers that contain the byte address of the first character in the string. To access the length fields, you load the value of the string pointer into a 32-bit register, then access the length field at offset –4 from the register and the maximum length field at offset –8 from the register. Here’s an example:</p>&#13;
		<pre class="programs">&#13;
			static<br/>    s :string := "Hello World";<br/>        .<br/>        .<br/>        .<br/>// Move the address of 'H' in<br/>// "Hello World" into esi.<br/><br/>mov( s, esi );<br/><br/>// Puts length of string<br/>// (11 for "Hello World") into ECX.<br/><br/>mov( [esi-4], ecx );<br/>        .<br/>        .<br/>        .<br/>mov( s, esi );<br/><br/>// See if value in ECX exceeds the<br/>// maximum string length.<br/><br/>cmp( ecx, [esi-8] );<br/>jae StringOverflow;</pre>&#13;
		<p class="indent">As noted earlier, the amount of memory reserved to hold an HLA string’s character data (including the <code>0</code> byte) is always a multiple of 4 bytes. Therefore, it’s always guaranteed that you can move data from one HLA string to another by copying double words rather than individual bytes. This allows string copy routines to run up to four times faster, because you execute one-fourth the number of loop iterations copying a string of double words as you would copying the string a byte at a time. For example, here’s the highly modified version of the pertinent code in the HLA <code>str.cpy()</code> function that copies one string to another:</p>&#13;
		<pre class="programs">&#13;
			// Get the source string pointer into ESI,<br/>// and the destination pointer into EDI.<br/><span epub:type="pagebreak" id="page_314"/>    mov( dest, edi );<br/>    mov( src, esi );<br/><br/>    // Get the length of the source string<br/>    // and make sure that the source string<br/>    // will fit in the destination string.<br/><br/>    mov( [esi-4], ecx );<br/><br/>    // Save as the length of the destination string.<br/><br/>    mov( ecx, [edi-4] );<br/><br/><br/>    // Add 1 byte to the length so we will<br/>    // copy the 0 byte. Also compute the<br/>    // number of dwords to copy (rather than bytes).<br/>    // Then copy the data.<br/><br/>    add( 4, ecx );  // Adds one, after division by 4.<br/>    shr( 2, ecx );  // Divides length by 4<br/>    rep.movsd();    // Moves length/4 dwords</pre>&#13;
		<p class="indent">The HLA <code>str.cpy()</code> function also checks for string overflows and <code>NULL</code> pointer references (for clarity, that code does not appear in this example). However, the takeaway here is that HLA copies the strings as double words in order to improve performance.</p>&#13;
		<p class="indent">One nice thing about HLA string variables is that (as read-only objects) HLA strings are compatible with zero-terminated strings. For example, if you have a function written in C or some other language that expects you to pass a zero-terminated string to it, you can call that function and pass an HLA string variable to it, like this:</p>&#13;
		<pre class="programs"><span class="codeitalic1">someCFunc</span>( <span class="codeitalic1">hlaStringVar</span> );</pre>&#13;
		<p class="indent">The only catch is that the C function must not make any changes to the string that would affect its length (because the C code won’t update the <code>Length</code> field of the HLA string). Of course, you can always call a C <code>strlen()</code> function upon returning to update the length field yourself, but generally, it’s best not to pass HLA strings to a function that modifies zero-terminated strings.</p>&#13;
		<p class="indent">The comments on length-prefixed strings generally apply to HLA strings, specifically:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Try to use the HLA standard library functions rather than attempting to code comparable functions yourself. While you might want to check out the library function’s source code (available with HLA), most of the string functions do a good job on generic string data.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Although, in theory, you shouldn’t count on the explicit length field appearing in the HLA string data format, most programs simply grab the length from the 4 bytes immediately preceding the string data, so <span epub:type="pagebreak" id="page_315"/>there’s generally no need to save the length. Careful HLA programmers will actually call the <code>str.len()</code> function in the HLA standard library and simply save this value in a local variable for future use. However, accessing the length directly is probably safe.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Avoid copying string data from one string variable to another. Doing so is one of the more expensive operations in programs using HLA strings.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h4 class="h4" id="ch00lev2sec116"><strong>10.1.5 Descriptor-Based Strings</strong></h4>&#13;
		<p class="noindent">The string formats we’ve considered up to this point have kept the attribute information (that is, the lengths and terminating bytes) for a string in memory along with the character data. A slightly more flexible scheme is to maintain such information in a record structure, known as a <em>descriptor</em>, that also contains a pointer to the character data. Consider the following Pascal/Delphi data structure (see <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>):</p>&#13;
		<pre class="programs">&#13;
			type<br/>    dString = record<br/>        curLength  :integer;<br/>        strData    :^char;<br/>    end;</pre>&#13;
		<div class="image" id="ch10fig5">&#13;
			<img alt="Image" src="../images/10fig05.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-5: String descriptors</em></p>&#13;
		<p class="indent">Note that this data structure does not hold the actual character data. Instead, the <code>strData</code> pointer contains the address of the first character of the string. The <code>curLength</code> field specifies the current length of the string. You could add any other fields you like to this record, such as a maximum length field, although a maximum length isn’t usually necessary because most string formats employing a descriptor are dynamic (as the next section will discuss).</p>&#13;
		<p class="indent">An interesting attribute of a descriptor-based string system is that the actual character data associated with a string could be part of a larger string. Because no length or terminating bytes are in the actual character data, it’s possible to have the character data for two strings overlap (see <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>).</p>&#13;
		<div class="image" id="ch10fig6">&#13;
			<img alt="Image" src="../images/10fig06.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-6: Overlapping strings using descriptors</em></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_316"/>This example shows two strings—<code>"Hello World"</code> and <code>"World"</code>—that overlap. This can save memory and make certain functions, like <code>substring()</code>, very efficient. Of course, when strings overlap as these do, you can’t modify the string data because that could wipe out part of some other string.</p>&#13;
		<p class="indent">The suggestions given for other string formats don’t apply as strongly to descriptor-based strings. Certainly, if standard libraries are available, you should call those functions because they’re probably more efficient than the ones you would write yourself. There is no need to save the length, because extracting the length field from the string’s descriptor is usually a minor task. Also, many descriptor-based string systems use <em>copy on write</em> (see <em>WGC1</em> and the section “Dynamic Strings” on <a href="ch10.xhtml#page_317">page 317</a>) to reduce string copy overhead. In a string descriptor system, you should avoid making changes to a string, because the copy-on-write semantics generally require the system to make a complete copy of the string whenever you change a single character (something that isn’t necessary with other string formats).</p>&#13;
		<h3 class="h3" id="ch00lev1sec85"><strong>10.2 Static, Pseudo-Dynamic, and Dynamic Strings</strong></h3>&#13;
		<p class="noindent">Having covered the various string data formats, it’s time to consider where to store string data in memory. Strings can be classified according to when and where the system allocates storage for them. There are three categories: static strings, pseudo-dynamic strings, and dynamic strings.</p>&#13;
		<h4 class="h4" id="ch00lev2sec117"><strong>10.2.1 Static Strings</strong></h4>&#13;
		<p class="noindent">Pure <em>static strings</em> are those whose maximum size a programmer chooses when writing the program. Pascal strings and Delphi <em>short strings</em> fall into this category. Arrays of characters that you use to hold zero-terminated strings in C/C++ also fall into this category, as do fixed-length arrays of characters. Consider the following declaration in Pascal:</p>&#13;
		<pre class="programs">&#13;
			(* Pascal static string example *)<br/><br/>var<br/>    //Max length will always be 255 characters.<br/><br/>    pascalString :string[255];</pre>&#13;
		<p class="indent">And here’s an example in C/C++:</p>&#13;
		<pre class="programs">&#13;
			// C/C++ static string example:<br/><br/>//Max length will always be 255 characters (plus 0 byte).<br/><br/>char cString[256];</pre>&#13;
		<p class="indent">While the program is running, there’s no way to increase the maximum sizes of these static strings. Nor is there any way to reduce the storage they will use; these string objects will consume 256 bytes at runtime, period. <span epub:type="pagebreak" id="page_317"/>One advantage to pure static strings is that the compiler can determine their maximum length at compile time and implicitly pass this information to a string function so it can test for bounds violations at runtime.</p>&#13;
		<h4 class="h4" id="ch00lev2sec118"><strong>10.2.2 Pseudo-Dynamic Strings</strong></h4>&#13;
		<p class="noindent">A pseudo-dynamic string is one whose length the system sets at runtime by calling a memory management function like <code>malloc()</code> to allocate storage for it. However, once the system allocates storage for the string, the maximum length of the string is fixed. HLA strings generally fall into this category.<sup><a id="ch10fn_6"/><a href="footnotes.xhtml#ch10fn6">6</a></sup> An HLA programmer typically calls the <code>stralloc()</code> function to allocate storage for a string variable, after which that particular string object has a fixed length that cannot change.<sup><a id="ch10fn_7"/><a href="footnotes.xhtml#ch10fn7">7</a></sup></p>&#13;
		<h4 class="h4" id="ch00lev2sec119"><strong>10.2.3 Dynamic Strings</strong></h4>&#13;
		<p class="noindent">Dynamic string systems, which typically use a descriptor-based format, automatically allocate sufficient storage for a string object whenever you create a new string or otherwise do something that affects an existing string. Operations like string assignment and substring extraction are relatively trivial in dynamic string systems—generally they copy only the string descriptor data, so these operations are fast. However, as noted in the section “Descriptor-Based Strings” on <a href="ch10.xhtml#page_315">page 315</a>, when using strings this way, you cannot store data back into a string object, because it could modify data that is part of other string objects in the system.</p>&#13;
		<p class="indent">The solution to this problem is to use the copy-on-write technique. Whenever a string function needs to change characters in a dynamic string, the function first makes a copy of the string and then makes the necessary modifications to that copy. Research suggests that copy-on-write semantics can improve the performance of many typical applications, because operations like string assignment and substring extraction (which is just a partial string assignment) are far more common than the modification of character data within strings. The only drawback to this approach is that after several modifications to string data in memory, there may be sections of the string heap area that contain character data that’s no longer in use. To avoid a memory leak, dynamic string systems employing copy on write usually provide garbage collection code, which scans the string heap area looking for stale character data in order to recover that memory for other purposes. Unfortunately, depending on the algorithms in use, garbage collection can be quite slow.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>See <a href="ch09.xhtml#ch09">Chapter 9</a> for more information on memory leaks and garbage collection.</em></p>&#13;
		</div>&#13;
		<h3 class="h3" id="ch00lev1sec86"><span epub:type="pagebreak" id="page_318"/><strong>10.3 Reference Counting for Strings</strong></h3>&#13;
		<p class="noindent">Consider the case where you have two string descriptors (or pointers) pointing at the same string data in memory. Clearly, you can’t deallocate the storage associated with one pointer while the program is still using the other pointer to access the same data. One common solution is to make the programmer responsible for keeping track of such details. Unfortunately, as applications become more complex, this approach often leads to dangling pointers, memory leaks, and other pointer-related problems in the software. A better solution is to allow the programmer to deallocate the storage for the character data in the string and to have the actual deallocation process hold off until the programmer releases the last pointer referencing that data. To accomplish this, a string system can use <em>reference counters</em>, which track the pointers and their associated data.</p>&#13;
		<p class="indent">A reference counter is an integer that counts the number of pointers that reference a string’s character data in memory. Every time you assign the address of the string to some pointer, you increment the reference counter by 1. Likewise, whenever you want to deallocate the storage associated with the character data for the string, you decrement the reference counter. Deallocation of the storage for the actual character data doesn’t happen until the reference counter decrements to 0.</p>&#13;
		<p class="indent">Reference counting works great when the language handles the details of string assignment automatically for you. If you try to implement reference counting manually, you must be sure to always increment the reference counter when you assign a string pointer to some other pointer variable. The best way to do this is to never assign pointers directly, but rather handle all string assignments via some function (or macro) call that updates the reference counters in addition to copying the pointer data. If your code fails to update the reference counter properly, you’ll wind up with dangling pointers or memory leaks.</p>&#13;
		<h3 class="h3" id="ch00lev1sec87"><strong>10.4 Delphi Strings</strong></h3>&#13;
		<p class="noindent">Although Delphi provides a “short string” format that is compatible with the length-prefixed strings in earlier versions of Delphi and Turbo Pascal, later versions of Delphi (v4.0 and later) use dynamic strings for their native string format. While this string format is unpublished (and, therefore, subject to change), indications are that Delphi’s string format is very similar to HLA’s. Delphi uses a zero-terminated sequence of characters with a leading string length and a reference counter (rather than a maximum length as HLA uses). <a href="ch10.xhtml#ch10fig7">Figure 10-7</a> shows the layout of a Delphi string in memory.</p>&#13;
		<div class="image" id="ch10fig7">&#13;
			<img alt="Image" src="../images/10fig07.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-7: Delphi string data format</em></p>&#13;
		<p class="indent">As with HLA, Delphi string variables are pointers holding the address of the first character of the actual string data. To access the length and <span epub:type="pagebreak" id="page_319"/>reference counter fields, the Delphi string routines use a negative offset of –4 and –8 from the character data’s base address. However, because this string format is not published, applications should never access the length or reference counter fields directly (for example, these fields could be 64-bit values one day). Delphi provides a length function that extracts the string length for you, and there’s really no need for your applications to access the reference counter field because the Delphi string functions maintain it automatically.</p>&#13;
		<h3 class="h3" id="ch00lev1sec88"><strong>10.5 Using Strings in a High-Level Language</strong></h3>&#13;
		<p class="noindent">Strings are a very common data type in high-level programming languages. Because applications often make extensive use of string data, many HLLs provide libraries with lots of complex string manipulation routines that hide considerable complexity from the programmer. Unfortunately, it’s easy to forget the amount of work involved in a typical string operation when you execute a statement like this:</p>&#13;
		<pre class="programs"><span class="codeitalic1">aLengthPrefixedString</span> := 'Hello World';</pre>&#13;
		<p class="indent">In a typical Pascal implementation, this assignment statement calls a function that winds up copying each character from the string literal to the storage reserved for the <span class="codeitalic">aLengthPrefixedString</span> variable. That is, this statement roughly expands to the following:</p>&#13;
		<pre class="programs">&#13;
			(* Copy the characters in the string *)<br/><br/>    for i:= 1 to length( HelloWorldLiteralString ) do begin<br/><br/>        aLengthPrefixedString[ i ] :=<br/>            HelloWorldLiteralString[ i ];<br/><br/>    end;<br/><br/>    (* Set the string's length *)<br/><br/>    aLengthPrefixedString[0] :=<br/>        char( length( HelloWorldLiteralString ));</pre>&#13;
		<p class="indent">This code doesn’t even include the overhead of the procedure call, return, and parameter passing. As noted throughout the chapter, copying string data is one of the more expensive operations programs commonly do. This is why many HLLs have switched to dynamic strings and copy-on-write semantics—string assignments are far more efficient when you copy only a pointer rather than all of the character data. This is not to suggest that copy on write is always better, but for many string operations—such as assignment, substring, and other operations that do not change the string’s character data—it can be very efficient.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_320"/>Although few programming languages give you the option of choosing which string format you want to use, many do let you create pointers to strings, so you can manually support copy on write. If you’re willing to write your own string-handling functions, you can create some very efficient programs by avoiding the use of your language’s built-in string-handling capabilities. For example, the substring operation in C is usually handled by the <code>strncpy()</code> function and is often implemented like so:<sup><a id="ch10fn_8"/><a href="footnotes.xhtml#ch10fn8">8</a></sup></p>&#13;
		<pre class="programs">&#13;
			char *<br/>strncpy( char* dest, char *src, int max )<br/>{<br/>    char *result = dest;<br/>    while( max &gt; 0 )<br/>    {<br/>        *dest = *src++;<br/>        if( *dest++ == '\0') break;<br/>        --max;<br/>    }<br/>    return result;<br/>}</pre>&#13;
		<p class="indent">A typical “substring” operation might use <code>strncpy()</code> as follows:</p>&#13;
		<pre class="programs">&#13;
			strncpy( <span class="codeitalic1">substring</span>, <span class="codeitalic1">fullString</span> + <span class="codeitalic1">start</span>, <span class="codeitalic1">length</span> );<br/><span class="codeitalic1">substring</span>[ <span class="codeitalic1">length</span> ] = '\0';</pre>&#13;
		<p class="noindent">where <span class="codeitalic">substring</span> is the destination string object, <span class="codeitalic">fullString</span> is the source string, <span class="codeitalic">start</span> is the starting index of the substring to copy, and <span class="codeitalic">length</span> is the length of the substring to copy.</p>&#13;
		<p class="indent">If you create a descriptor-based string format in C using a <code>struct</code>, similar to the HLA record in “Descriptor-Based Strings” on <a href="ch10.xhtml#page_315">page 315</a>, you could do a substring operation with the following two statements in C:</p>&#13;
		<pre class="programs">&#13;
			// Assumption: ".strData" field is char*<br/><br/>    <span class="codeitalic1">substring</span>.<span class="codeitalic1">strData</span> = <span class="codeitalic1">fullString</span>.<span class="codeitalic1">strData</span> + <span class="codeitalic1">start</span>;<br/>    <span class="codeitalic1">substring</span>.<span class="codeitalic1">curLength</span> = <span class="codeitalic1">length</span>;</pre>&#13;
		<p class="indent">This code executes much faster than the <code>strncpy()</code> version.</p>&#13;
		<p class="indent">Sometimes, a particular programming language won’t provide access to the underlying string data representation it supports, and you’ll have to live with the performance loss, switch languages, or write your own string-handling code in assembly language. Generally, though, there are alternatives to copying string data in your applications, such as using a string descriptor as in the example just given.</p>&#13;
		<h3 class="h3" id="ch00lev1sec89"><span epub:type="pagebreak" id="page_321"/><strong>10.6 Unicode Character Data in Strings</strong></h3>&#13;
		<p class="noindent">Up to this point, we’ve assumed that each character in a string consumes exactly 1 byte of storage. We’ve also assumed the use of the 7-bit ASCII character set when discussing the character data appearing in a string. Traditionally, this has been the way programming languages have represented a string’s character data. Today, however, the ASCII character set is too limited for worldwide use, and several new character sets have risen in popularity, including the Unicode variants: UTF-8, UTF-16, UTF-32, and UTF-7. Because these character formats can have a big impact on the efficiency of string functions that operate upon them, we’ll spend some time covering them.</p>&#13;
		<h4 class="h4" id="ch00lev2sec120"><strong>10.6.1 The Unicode Character Set</strong></h4>&#13;
		<p class="noindent">A few decades back, engineers at Aldus, NeXT, Sun, Apple Computer, IBM, Microsoft, the Research Library Group, and Xerox realized that their new computer systems with bitmaps and user-selectable fonts could display far more than 256 different characters at one time. At the time, <em>double-byte character sets (DBCSs)</em> were the most common solution. DBCSs had a couple of issues, however. First, as they were typically variable-length encodings, DBCSs required special library code; common character/string algorithms that depended upon fixed-length character encodings would not work properly with them. Second, there was no consistent standard—different DBCSs used the same encoding for different characters. So, wanting to avoid these compatibility problems, the engineers sought a different route.</p>&#13;
		<p class="indent">The solution they came up with was the Unicode character set. The engineers who originally developed Unicode chose a 2-byte character size. Like DBCSs, this approach still required special library code (existing single-byte string functions would not always work with 2-byte characters), but other than changing the size of a character, most existing string algorithms would still work with 2-byte characters. The Unicode definition included all of the (known/living) character sets at the time, giving each character a unique encoding, to avoid the consistency problems that plagued differing DBCSs.</p>&#13;
		<p class="indent">The original Unicode standard used a 16-bit word to represent each character. Therefore, Unicode supported up to 65,536 different character codes—a huge advance over the 256 possible codes that are representable with an 8-bit byte. Furthermore, Unicode is upward compatible from ASCII. If the HO 9 bits<sup><a id="ch10fn_9"/><a href="footnotes.xhtml#ch10fn9">9</a></sup> of a Unicode character’s binary representation contain <code>0</code>, then the LO 7 bits use the standard ASCII code. If the HO 9 bits contain some nonzero value, then the 16 bits form an extended character code (extended from ASCII, that is). If you’re wondering why so many different character codes are necessary, note that, at the time, certain Asian character sets contained 4,096 characters. The Unicode character set even provided a set of codes you could use to create an application-defined character set. <span epub:type="pagebreak" id="page_322"/>Approximately half of the 65,536 possible character codes have been defined, and the remaining character encodings are reserved for future expansion.</p>&#13;
		<p class="indent">Today, Unicode is a universal character set, long replacing ASCII and older DBCSs. All modern operating systems (including macOS, Windows, Linux, iOS, Android, and Unix), web browsers, and most modern applications provide Unicode support. Unicode Consortium, a nonprofit corporation, maintains the Unicode standard. By maintaining the standard, Unicode, Inc. (<em><a href="https://home.unicode.org">https://home.unicode.org</a></em>), helps guarantee that a character you write on one system will display as you expect on a different system or application.</p>&#13;
		<h4 class="h4" id="ch00lev2sec121"><strong>10.6.2 Unicode Code Points</strong></h4>&#13;
		<p class="noindent">Alas, as well thought-out as the original Unicode standard was, it couldn’t have anticipated the explosion in characters that would occur. Emojis, astrological symbols, arrows, pointers, and a wide variety of symbols introduced for the internet, mobile devices, and web browsers have greatly expanded the Unicode symbol repertoire (along with a desire to support historic, obsolete, and rare scripts). In 1996, systems engineers discovered that 65,536 symbols were insufficient. Rather than require 3 or 4 bytes for each Unicode character, those in charge of the Unicode definition gave up on trying to create a fixed-size representation of characters and allowed for opaque (and multiple) encodings of Unicode characters. Today, Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity originally set aside for Unicode characters.</p>&#13;
		<p class="indent">A Unicode <em>code point</em> is simply an integer value that Unicode associates with a particular character symbol; you can think of it as the Unicode equivalent of the ASCII code for a character. The convention for Unicode code points is to specify the value in hexadecimal with a <code>U+</code> prefix; for example, <code>U+0041</code> is the Unicode code point for the letter <em>A</em>.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>See</em> <a href="https://en.wikipedia.org/wiki/Unicode#General_Category_property">https://en.wikipedia.org/wiki/Unicode#General_Category_property</a> <em>for more details on code points.</em></p>&#13;
		</div>&#13;
		<h4 class="h4" id="ch00lev2sec122"><strong>10.6.3 Unicode Code Planes</strong></h4>&#13;
		<p class="noindent">Because of its history, blocks of 65,536 characters are special in Unicode—they are known as a <em>multilingual plane</em>. The first multilingual plane, <code>U+000000</code> to <code>U+00FFFF</code>, roughly corresponds to the original 16-bit Unicode definition; the Unicode standard calls this the <em>Basic Multilingual Plane (BMP)</em>. Planes 1 (<code>U+010000</code> to <code>U+01FFFF</code>), 2 (<code>U+020000</code> to <code>U+02FFFF</code>), and 14 (<code>U+0E0000</code> to <code>U+0EFFFF</code>) are supplementary planes. Unicode reserves planes 3 through 13 for future expansion and planes 15 and 16 for user-defined character sets.</p>&#13;
		<p class="indent">The Unicode standard defines code points in the range <code>U+000000</code> to <code>U+10FFFF</code>. Note that <code>0x10ffff</code> is 1,114,111, which is where most of the 1,112,064 characters in the Unicode character set come from; the remaining 2,048 code points are reserved for use as <em>surrogates</em>, which are Unicode extensions. <em>Unicode scalar</em> is another term you might hear; this is a value from the set of all Unicode code points <em>except</em> the 2,048 surrogate code points. The HO two hexadecimal digits of the six-digit code point value <span epub:type="pagebreak" id="page_323"/>specify the multilingual plane. Why 17 planes? The reason, as you’ll see in a moment, is that Unicode uses special multiword entries to encode code points beyond <code>U+FFFF</code>. Each of the two possible extensions encodes 10 bits, for a total of 20 bits; 20 bits gives you 16 multilingual planes, which, plus the original BMP, produces 17 multilingual planes. This is also why code points fall in the range <code>U+000000</code> to <code>U+10FFFF</code>: it takes 21 bits to encode the 16 multilingual planes plus the BMP.</p>&#13;
		<h4 class="h4" id="ch00lev2sec123"><strong>10.6.4 Surrogate Code Points</strong></h4>&#13;
		<p class="noindent">As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding. When it became apparent that 16 bits were insufficient to handle all the possible characters that existed at the time, an expansion was necessary. As of Unicode v2.0, the Unicode, Inc., organization extended the definition of Unicode to include multiword characters. Now Unicode uses surrogate code points (<code>U+D800</code> through <code>U+DFFF</code>) to encode values larger than <code>U+FFFF</code>. <a href="ch10.xhtml#ch10fig8">Figure 10-8</a> shows the encoding.</p>&#13;
		<div class="image" id="ch10fig8">&#13;
			<img alt="Image" src="../images/10fig08.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 10-8: Surrogate code point encoding for Unicode planes 1 through 16</em></p>&#13;
		<p class="indent">Note that the two words (unit 1/high surrogate and unit 2/low surrogate) always appear together. The unit 1 value (with HO bits <code>%110110</code>) specifies the upper 10 bits (<code>b<sub>10</sub></code>..<code>b<sub>19</sub></code>) of the Unicode scalar, and the unit 2 value (with HO bits <code>%110111</code>) specifies the lower 10 bits (<code>b<sub>0</sub></code>..<code>b<sub>9</sub></code>) of the Unicode scalar. Therefore, the value of bits <code>b<sub>16</sub></code>..<code>b<sub>19</sub></code> plus 1 specifies Unicode plane 1 through 16. Bits <code>b<sub>0</sub></code>..<code>b<sub>15</sub></code> specify the Unicode scalar value within the plane.</p>&#13;
		<p class="indent">Note that surrogate codes only appear in the BMP. None of the other multilingual planes contain surrogate codes. Bits <code>b<sub>0</sub></code>..<code>b<sub>19</sub></code> extracted from the unit 1 and 2 values always specify a Unicode scalar value (even if the values fall in the range <code>U+D800</code> through <code>U+DFFF</code>).</p>&#13;
		<h4 class="h4" id="ch00lev2sec124"><strong>10.6.5 Glyphs, Characters, and Grapheme Clusters</strong></h4>&#13;
		<p class="noindent">Each Unicode code point has a unique name. For example, <code>U+0045</code> has the name “LATIN CAPITAL LETTER A.” Note that the symbol <em>A</em> is <em>not</em> the name of the character. <em>A</em> is a <em>glyph</em>—a series of strokes (one horizontal and two slanted strokes) that a device draws in order to represent the character.</p>&#13;
		<p class="indent">There are many different glyphs for the single Unicode character “LATIN CAPITAL LETTER A.” For example, a Times Roman A and a Times Roman Italic <em>A</em> have different glyphs, but Unicode doesn’t differentiate between them (or between the <em>A</em> character in any two different fonts). <span epub:type="pagebreak" id="page_324"/>The character “LATIN CAPITAL LETTER A” remains <code>U+0045</code> regardless of the font or style you use to draw it.</p>&#13;
		<p class="indent">As an interesting side note, if you have access to the Swift programming language, you can print the name of any Unicode character using the following code:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/>let charToPrintName  :String = "A"      // Print name of this character<br/><br/>let unicodeName =<br/>    String(charToPrintName).applyingTransform(<br/>        StringTransform(rawValue: "Any-Name"),<br/>        reverse: false<br/>    )! // Forced unwrapping is legit here because it always succeeds.<br/>print( unicodeName )<br/><br/>Output from program:<br/>\N{LATIN CAPITAL LETTER A}</pre>&#13;
		<p class="indent">So, what exactly is a character in Unicode? Unicode scalars are Unicode characters, but there’s a difference between what you’d normally call a character and the definition of a Unicode character (scalar). For example, is <em>é</em> one character or two? Consider the following Swift code:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/>let eAccent  :String = "e\u{301}"<br/>print( eAccent )<br/>print( "eAccent.count=\(eAccent.count)" )<br/>print( "eAccent.utf16.count=\(eAccent.utf16.count)" )</pre>&#13;
		<p class="indent"><code>"\u{301}"</code> is the Swift syntax for specifying a Unicode scalar value within a string; in this particular case <code>301</code> is the hexadecimal code for the <em>combining acute accent</em> character.</p>&#13;
		<p class="indent">The first <code>print</code> statement:</p>&#13;
		<pre class="programs">print( eAccent )</pre>&#13;
		<p class="indent">prints the character (producing <code>é</code> on the output, as we expect).</p>&#13;
		<p class="indent">The second <code>print</code> statement prints the number of characters Swift determines are present in the string:</p>&#13;
		<pre class="programs">print( "eAccent.count=\(eAccent.count)" )</pre>&#13;
		<p class="indent">This prints <code>1</code> to the standard output.</p>&#13;
		<p class="indent">The third <code>print</code> statement prints the number of elements (UTF-16 elements<sup><a id="ch10fn_10"/><a href="footnotes.xhtml#ch10fn10">10</a></sup>) in the string:</p>&#13;
		<pre class="programs">print( "eAccent.utf16.count=\(eAccent.utf16.count)" )</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_325"/>This prints <code>2</code> on the standard output, because the string holds 2 words of UTF-16 data.</p>&#13;
		<p class="indent">So, again, is this one character or two? Internally (assuming UTF-16 encoding), the computer sets aside 4 bytes of memory for this single character (two 16-bit Unicode scalar values).<sup><a id="ch10fn_11"/><a href="footnotes.xhtml#ch10fn11">11</a></sup> On the screen, however, the output takes only one character position and looks like a single character to the user. When this character appears within a text editor and the cursor is immediately to the right of the character, the user expects that pressing the backspace key will delete it. From the user’s perspective, then, this is a single character (as Swift reports when you print the <code>count</code> attribute of the string).</p>&#13;
		<p class="indent">In Unicode, however, a character is largely equivalent to a code point. This is not what people normally think of as a character. In Unicode terminology, a <em>grapheme cluster</em> is what people normally call a character—it’s a sequence of one or more Unicode code points that combine to form a single language element (that is, a single character). So, when we talk about characters with respect to symbols that an application displays to an end user, we’re really talking about grapheme clusters.</p>&#13;
		<p class="indent">Grapheme clusters can make life miserable for software developers. Consider the following Swift code (a modification of the earlier example):</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/>let eAccent  :String = "e\u{301}\u{301}"<br/>print( eAccent )<br/>print( "eAccent.count=\(eAccent.count)" )<br/>print( "eAccent.utf16.count=\(eAccent.utf16.count)" )</pre>&#13;
		<p class="indent">This code produces the same <code>é</code> and <code>1</code> outputs from the first two <code>print</code> statements. The following produces <code>é</code>:</p>&#13;
		<pre class="programs">print( eAccent )</pre>&#13;
		<p class="indent">and this <code>print</code> statement produces <code>1</code>.</p>&#13;
		<pre class="programs">print( "eAccent.count=\(eAccent.count)" )</pre>&#13;
		<p class="indent">However, the third <code>print</code> statement:</p>&#13;
		<pre class="programs">print( "eAccent.utf16.count=\(eAccent.utf16.count)" )</pre>&#13;
		<p class="noindent">displays <code>3</code> rather than <code>2</code> (as in the original example).</p>&#13;
		<p class="indent">There are definitely three Unicode scalar values in this string (<code>U+0065</code>, <code>U+0301</code>, and <code>U+0301</code>). When printing, the operating system combines the <code>e</code> and the two acute accent combining characters to form the single character <code>é</code> and then outputs the character to the standard output device. Swift is smart enough to know that this combination creates a single output symbol on the display, so printing the result of the <code>count</code> attribute continues to <span epub:type="pagebreak" id="page_326"/>output <code>1</code>. However, there are (undeniably) three Unicode code points in this string, so printing <code>utf16.count</code> produces <code>3</code> on output.</p>&#13;
		<h4 class="h4" id="ch00lev2sec125"><strong>10.6.6 Unicode Normals and Canonical Equivalence</strong></h4>&#13;
		<p class="noindent">The Unicode character <em>é</em> actually existed on personal computers long before Unicode came along. It’s part of the original IBM PC character set and also part of the Latin-1 character set (used, for example, on old DEC terminals). As it turns out, Unicode uses the Latin-1 character set for the code points in the range <code>U+00A0</code> to <code>U+00FF</code>, and <code>U+00E9</code> just happens to correspond to the <em>é</em> character. Therefore, we can modify the earlier program as follows:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/>let eAccent  :String = "\u{E9}"<br/>print( eAccent )<br/>print( "eAccent.count=\(eAccent.count)" )<br/>print( "eAccent.utf16.count=\(eAccent.utf16.count)" )</pre>&#13;
		<p class="indent">And here are the outputs from this program:</p>&#13;
		<pre class="programs">&#13;
			é<br/>1<br/>1</pre>&#13;
		<p class="indent">Ouch! Three different strings all producing <code>é</code> but containing a different number of code points. Imagine how this complicates programming strings containing Unicode characters. For example, if you have the following three strings (Swift syntax) and you try to compare them, what will the result be?</p>&#13;
		<pre class="programs">&#13;
			let eAccent1 :String = "\u{E9}"<br/>let eAccent2 :String = "e\u{301}"<br/>let eAccent3 :String = "e\u{301}\u{301}"</pre>&#13;
		<p class="indent">To the user, all three strings look the same on the screen. However, they clearly contain different values. If you compare them to see if they are equal, will the result be <code>true</code> or <code>false</code>?</p>&#13;
		<p class="indent">Ultimately, that depends upon whose string libraries you’re using. Most current string libraries would return <code>false</code> if you compared these strings for equality. Interestingly enough, Swift will claim that <code>eAccent1</code> is equal to <code>eAccent2</code>, but it isn’t smart enough to report that <code>eAccent1</code> is equal to <code>eAccent3</code> or that <code>eAccent2</code> is equal to <code>eAccent3</code>—despite the fact that it displays the same symbol for all three strings. Many languages’ string libraries simply report that all three strings are unequal.</p>&#13;
		<p class="indent">The three Unicode/Swift strings <code>"\u{E9}"</code>, <code>"e\u{301}"</code>, and <code>"e\u{301}\u{301}"</code> all produce the same output on the display. Therefore, they are canonically equivalent according to the Unicode standard. Some string libraries won’t report any of these strings as being equivalent. Some, like the one accompanying Swift, will handle small canonical equivalences (such as <code>"\u{E9}" == "e\u{301}"</code>) but not arbitrary sequences that should be equivalent (probably <span epub:type="pagebreak" id="page_327"/>a good balance of correctness versus efficiency; it can be computationally expensive to handle all the weird cases that won’t normally happen, such as <code>"e\u{301}\u{301}"</code>).</p>&#13;
		<p class="indent">Unicode defines <em>normal forms</em> for Unicode strings. One aspect of normal form is to replace canonically equivalent sequences with an equivalent sequence—for example, replace <code>"e\u{309}"</code> by <code>"\u{E9}"</code> or replace <code>"\u{E9}"</code> by <code>"e\u{309}"</code> (usually, the shorter form is preferable). Some Unicode sequences allow multiple combining characters. Often, the order of the combining characters is irrelevant to producing the desired grapheme cluster. However, it’s easier to compare two such strings if the combining characters are in a specified order. Normalizing Unicode strings may also produce results whose combining characters always appear in a fixed order (thereby improving efficiency of string comparisons).</p>&#13;
		<h4 class="h4" id="ch00lev2sec126"><strong>10.6.7 Unicode Encodings</strong></h4>&#13;
		<p class="noindent">As of Unicode v2.0, the standard supports a 21-bit character space capable of handling over a million characters (though most of the code points remain reserved for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding to allow the larger character set, Unicode, Inc., allows different encodings—UTF-32, UTF-16, and UTF-8—each with its own advantages and disadvantages.<sup><a id="ch10fn_12"/><a href="footnotes.xhtml#ch10fn12">12</a></sup></p>&#13;
		<p class="indent">UTF-32 uses 32-bit integers to hold Unicode scalars. The advantage to this scheme is that a 32-bit integer can represent every Unicode scalar value (which requires only 21 bits). Programs that require random access to characters in strings—without having to search for surrogate pairs—and other constant-time operations are (mostly) possible when using UTF-32. The obvious drawback to UTF-32 is that each Unicode scalar value requires 4 bytes of storage—twice that of the original Unicode definition and four times that of ASCII characters. It may seem that using two or four times as much storage (over ASCII and the original Unicode) is a small price to pay. After all, modern machines have several orders of magnitude more storage than they did when Unicode first appeared. However, that extra storage has a huge impact on performance, because those additional bytes quickly consume cache storage. Furthermore, modern string processing libraries often operate on character strings 8 bytes at a time (on 64-bit machines). With ASCII characters, that means a given string function can process up to eight characters concurrently; with UTF-32, that same string function can operate on only two characters concurrently. As a result, the UTF-32 version will run four times slower than the ASCII version. Ultimately, even Unicode scalar values are insufficient to represent all Unicode characters (that is, many Unicode characters require a sequence of Unicode scalars), so using UTF-32 doesn’t solve the problem.</p>&#13;
		<p class="indent">The second encoding format the Unicode supports is UTF-16. As the name suggests, UTF-16 uses 16-bit (unsigned) integers to represent Unicode values. To handle scalar values greater than <code>0xFFFF</code>, UTF-16 uses <span epub:type="pagebreak" id="page_328"/>the surrogate pair scheme to represent values in the range <code>0x010000</code> to <code>0x10FFFF</code> (see “Surrogate Code Points” on <a href="ch10.xhtml#page_323">page 323</a>). Because the vast majority of useful characters fit into 16 bits, most UTF-16 characters require only 2 bytes. For those rare cases where surrogates are necessary, UTF-16 requires 2 words (32 bits) to represent the character.</p>&#13;
		<p class="indent">The last encoding, and unquestionably the most popular, is UTF-8. The UTF-8 encoding is forward compatible from the ASCII character set. In particular, all ASCII characters have a single-byte representation (their original ASCII code, where the HO bit of the byte containing the character contains a <code>0</code> bit). If the UTF-8 HO bit is <code>1</code>, then UTF-8 requires between 1 and 3 additional bytes to represent the Unicode code point. <a href="ch10.xhtml#ch10tab1">Table 10-1</a> provides the UTF-8 encoding schema.</p>&#13;
		<p class="tabcap" id="ch10tab1"><strong>Table 10-1:</strong> UTF Encoding</p>&#13;
		<table class="all">&#13;
			<colgroup>&#13;
				<col style="width:10%"/>&#13;
				<col style="width:15%"/>&#13;
				<col style="width:15%"/>&#13;
				<col style="width:15%"/>&#13;
				<col style="width:15%"/>&#13;
				<col style="width:10%"/>&#13;
				<col style="width:10%"/>&#13;
				<col style="width:10%"/>&#13;
			</colgroup>&#13;
			<tbody>&#13;
				<tr>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Bytes</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Bits for code point</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>First code point</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Last code point</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Byte 1</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Byte 2</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Byte 3</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Byte 4</strong></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>7</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+00</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+7F</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code><em>xxxxxxx</em></p>&#13;
					</td>&#13;
					<td/>&#13;
					<td/>&#13;
					<td/>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>11</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+80</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+7FF</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>110</code><em>xxxxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
					<td/>&#13;
					<td/>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>16</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+800</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+FFFF</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>1110</code><em>xxxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
					<td/>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>4</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>21</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+10000</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>U+10FFFF</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>11110</code><em>xxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code><em>xxxxxx</em></p>&#13;
					</td>&#13;
				</tr>&#13;
			</tbody>&#13;
		</table>&#13;
		<p class="indent">The “<span class="codeitalic">xxx</span> . . . ” bits are the Unicode code point bits. For multibyte sequences, Byte 1 contains the HO bits, Byte 2 contains the next HO bits (LO bits compared to byte 1), and so on. For example, the 2-byte sequence (<code>%11011111</code>, <code>%10000001</code>) corresponds to the Unicode scalar <code>%0000_0111_1100_0001</code> (<code>U+07C1</code>).</p>&#13;
		<p class="indent">UTF-8 encoding is probably the most common encoding in use. Most web pages use it. Most C standard library string functions will operate on UTF-8 text without modification (although some C standard library functions can produce malformed UTF-8 strings if the programmer isn’t careful with them).</p>&#13;
		<p class="indent">Different languages and operating systems use different encodings as their default. For example, macOS and Windows tend to use UTF-16 encoding, whereas most Unix systems use UTF-8. Some variants of Python use UTF-32 as their native character format. By and large, though, most programming languages use UTF-8 because they can continue to use older ASCII-based character processing libraries to process UTF-8 characters. Apple’s Swift is one of the first programming languages that attempts to do Unicode right (though there is a huge performance hit for doing so).</p>&#13;
		<h4 class="h4" id="ch00lev2sec127"><strong>10.6.8 Unicode Combining Characters</strong></h4>&#13;
		<p class="noindent">Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU overhead and algorithmic complexities of dealing with multibyte (or multiword) characters sets complicates their use (introducing bugs and performance issues). Despite the issues of wasting memory (especially in the cache), why not simply define characters as 32-bit entities and be done with it? This seems like it would simplify string processing <span epub:type="pagebreak" id="page_329"/>algorithms, improving performance and reducing the likelihood of defects in the code.</p>&#13;
		<p class="indent">The problem with this theory is that you cannot represent all possible grapheme clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters consist of several concatenated Unicode code points. Here’s an example from Chris Eidhof and Ole Begemann’s <em>Advanced Swift</em> (CreateSpace, 2017):</p>&#13;
		<pre class="programs">&#13;
			let chars: [Character] = [<br/>    "\u{1ECD}\u{300}",<br/>    "\u{F2}\u{323}",<br/>    "\u{6F}\u{323}\u{300}",<br/>    "\u{6F}\u{300}\u{323}"<br/>]</pre>&#13;
		<p class="indent">Each of these Unicode grapheme clusters produces an identical character: an <code>ó</code> with a dot underneath the character (this is a character from the Yoruba character set). The character sequence (<code>U+1ECD</code>, <code>U+300</code>) is an <code>o</code> with a dot under it followed by a combining acute. The character sequence (<code>U+F2</code>, <code>U+323</code>) is an <code>ó</code> followed by a combining dot. The character sequence (<code>U+6F</code>, <code>U+323</code>, <code>U+300</code>) is an <code>o</code> followed by a combining dot, followed by a combining acute. Finally, the character sequence (<code>U+6F</code>, <code>U+300</code>, <code>U+323</code>) is an <code>o</code> followed by a combining acute, followed by a combining dot. All four strings produce the same output. Indeed, the Swift string comparisons treat all four strings as equal:</p>&#13;
		<pre class="programs">&#13;
			print("\u{1ECD} + \u{300} = \u{1ECD}\u{300}")<br/>print("\u{F2} + \u{323} = \u{F2}\u{323}")<br/>print("\u{6F} + \u{323} + \u{300} = \u{6F}\u{323}\u{300}")<br/>print("\u{6F} + \u{300} + \u{323} = \u{6F}\u{300}\u{323}")<br/>print( chars[0] == chars[1] ) // Outputs true<br/>print( chars[0] == chars[2] ) // Outputs true<br/>print( chars[0] == chars[3] ) // Outputs true<br/>print( chars[1] == chars[2] ) // Outputs true<br/>print( chars[1] == chars[3] ) // Outputs true<br/>print( chars[2] == chars[3] ) // Outputs true</pre>&#13;
		<p class="indent">Note that there is not a single Unicode scalar value that will produce this character. You must combine at least two Unicode scalars (or as many as three) to produce this grapheme cluster on the output device. Even if you used UTF-32 encoding, it would still require two (32-bit) scalars to produce this particular output.</p>&#13;
		<p class="indent">Emojis present another challenge that can’t be solved using UTF-32. Consider the Unicode scalar <code>U+1F471</code>. This prints an emoji of a person with blond hair. If we add a skin color modifier to this, we obtain (<code>U+1F471</code>, <code>U+1F3FF</code>), which produces a person with a dark skin tone (and blond hair). In both cases we have a single character displaying on the screen. The first example uses a single Unicode scalar value, but the second example requires two. There is no way to encode this with a single UTF-32 value.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_330"/>The bottom line is that certain Unicode grapheme clusters will require multiple scalars, no matter how many bits we assign to the scalar (it’s possible to combine 30 or 40 scalars into a single grapheme cluster, for example). That means we’re stuck dealing with multiword sequences to represent a single “character” regardless of how hard we try to avoid it. This is why UTF-32 has never really taken off. It doesn’t solve the problem of random access into a string of Unicode characters. If you’ve got to deal with normalizing and combining Unicode scalars, it’s more efficient to use UTF-8 or UTF-16 encodings.</p>&#13;
		<p class="indent">Again, most languages and operating systems today support Unicode in one form or another (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems with dealing with multibyte character sets, modern programs need to deal with Unicode strings rather than simple ASCII strings. Swift, which is almost “pure Unicode,” doesn’t even offer much in the way of standard ASCII character support.</p>&#13;
		<h3 class="h3" id="ch00lev1sec90"><strong>10.7 Unicode String Functions and Performance</strong></h3>&#13;
		<p class="noindent">Unicode strings have one fundamental problem: because Unicode is a multibyte character set, the number of bytes in a character string is not equal to the number of characters (or, more importantly, the number of glyphs) in the string. Unfortunately, the only way to determine the length of a string is to scan all bytes in the string (from the beginning to the end) and count those characters. In this respect, the performance of a Unicode string length function will be proportional to the size of the string, just as it is for zero-terminated strings.</p>&#13;
		<p class="indent">Worse still, the only way to compute the index of a character position in a string (that is, the offset in bytes from the beginning of the string) is to scan from the beginning of the string and count off the desired number of characters. Even zero-terminated (ASCII) strings don’t suffer from this problem. In Unicode, functions like substring or insert/delete characters in a string can be very expensive.</p>&#13;
		<p class="indent">The Swift standard library’s string function performance suffers as a result of the language’s Unicode purity. Swift programmers have to exercise caution when processing strings because operations that would normally be fast in C/C++ or other languages can be a source of performance problems in Swift’s Unicode environment.</p>&#13;
		<h3 class="h3" id="ch00lev1sec91"><strong>10.8 For More Information</strong></h3>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">———. <em>Write Great Code, Volume 1: Understanding the Machine</em>. 2nd ed. San Francisco: No Starch Press, 2020.</p>&#13;
	</body></html>