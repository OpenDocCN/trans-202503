<html><head></head><body><section class="chapter" title="Chapter&#xA0;2.&#xA0;F# Interactive" epub:type="chapter" id="fhash_interactive"><div class="titlepage"><div><div><h2 class="title">Chapter 2. F# Interactive</h2></div></div></div><p><a id="iddle1388" class="indexterm"/><a id="iddle1399" class="indexterm"/><a id="iddle1417" class="indexterm"/><a id="iddle1458" class="indexterm"/><a id="iddle1459" class="indexterm"/><a id="iddle1826" class="indexterm"/><a id="iddle1850" class="indexterm"/>If the prospect of doing true functional programming against the .NET Framework isn’t compelling enough, the productivity gains available through F# Interactive (FSI) should be. FSI is a <span class="emphasis"><em>read-evaluate-print loop (REPL)</em></span> utility you can use to explore problem domains and test code as you write. It also doubles as a script host that allows you to leverage the elegance of F# and the power of the .NET Framework to automate common tasks. How can a compiled language like F# be used interactively? Because behind the scenes FSI compiles its input to dynamically generate assemblies.</p><div class="sect1" title="Running F# Interactive"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="running_fhash_interactive">Running F# Interactive</h2></div></div></div><p>There are two ways to work in FSI: via the F# Interactive window in Visual Studio or the <span class="emphasis"><em>fsi.exe</em></span> console application. The choice is usually one of convenience. I typically prefer to work in the F# Interactive window because it <a id="iddle1038" class="indexterm"/><a id="iddle1398" class="indexterm"/>easily integrates into my Visual Studio development workflow. I generally use the window for exploratory tasks and reserve the console for script execution.</p><p>To open the F# Interactive window in Visual Studio, press <span class="smaller">CTRL</span>-<span class="smaller">ALT</span>-F; you should see a prompt like that shown in <a class="xref" href="ch02.html#fhash_interactive_window_in_visual_studi" title="Figure 2-1. The F# Interactive window in Visual Studio 2013">Figure 2-1</a>. By default, <span class="emphasis"><em>fsi.exe</em></span> is available only through the Visual Studio command prompt shortcuts and not through the basic Windows command prompt. If you want to make <span class="emphasis"><em>fsi.exe</em></span> available from another prompt, you’ll need to add its location to your path environment variable. By default, F# is installed to <span class="emphasis"><em>%PROGRAMFILES(x86)%\Microsoft SDKs\F#\3.0\Framework\v4.0\</em></span> (<span class="emphasis"><em>%PROGRAMFILES%</em></span> on 32-bit systems).</p><div class="figure"><a id="fhash_interactive_window_in_visual_studi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00007"/><img src="httpatomoreillycomsourcenostarchimages1981206.png.jpg" alt="The F# Interactive window in Visual Studio 2013"/></div></div><div class="figure-title">Figure 2-1. The F# Interactive window in Visual Studio 2013</div></div><p>In addition to just opening the Interactive window, you can send code to the window with <span class="smaller">ALT</span>-<span class="smaller">ENTER</span>, in which case the results from executing that code will also be shown. This makes it very easy to test new concepts: If you’re not sure how well something will work, you can typically try it immediately by writing a bit of code, sending it to FSI, and inspecting the result.</p><p>Sending code from the text editor isn’t the only way to evaluate expressions in FSI; you can also run code directly from its prompt. This flexibility is great for productivity because you can work on a block of code in the text editor, send it to FSI, and then experiment with it interactively in the FSI window itself.</p><p>There is an important difference between entering code directly in the Interactive window versus sending code from the text editor. When you send code from the editor, it’s compiled and executed automatically, whereas code entered directly won’t execute until you terminate it with a double semicolon pattern (<code class="literal">;;</code>). For example, to perform simple addition you could either enter <code class="literal">1 + 1</code> into the text editor and send it to FSI, or enter <code class="literal">1 + 1;;</code> directly at the FSI prompt. Both approaches yield the same result, but because double semicolons must be used to denote the end of the code input, FSI lets you enter and execute multiple lines of code directly at the prompt.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>Even though multiple-line entry at the prompt is possible, it’s often more trouble than it’s worth because if you make a silly typing mistake you must start over. I tend to use single-line statements at the prompt as much as possible. (Fortunately, recovering from such mistakes is usually just a matter of correcting the mistake and trying again.)</em></span></p></div></div><div class="sect1" title="F# Interactive Output"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="fhash_interactive_output">F# Interactive Output</h2></div></div></div><p><a id="iddle1400" class="indexterm"/><a id="iddle1416" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle2094" class="indexterm"/>One thing that makes FSI so useful is that it reports back everything that it does. Whenever you execute code in FSI, it displays <code class="literal">val</code> followed by the identifier name, data type, and value for each binding it creates. For example, when you define and invoke a function, FSI will create two bindings: one for the function itself and one for the result, as shown here.</p><a id="pro_id00015"/><pre class="programlisting">&gt; <span class="strong"><strong>let add a b = a + b</strong></span>
<span class="strong"><strong>let sum = add 1 2;;</strong></span>

val add : a:int -&gt; b:int -&gt; int
val sum : int = 3</pre></div><div class="sect1" title="The it Identifier"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="it_identifier">The it Identifier</h2></div></div></div><p>You don’t always have to explicitly define bindings in FSI; in most interactive sessions you can simply evaluate an expression. For example, you can call the <code class="literal">add</code> function without defining the <code class="literal">sum</code> identifier like this.</p><a id="pro_id00016"/><pre class="programlisting">&gt; <span class="strong"><strong>add 1 2;;</strong></span>
val it : int = 3</pre><p>When you don’t explicitly name something (as when performing a simple calculation or checking the output of a function), FSI automatically binds the result to the <code class="literal">it</code> identifier. You can refer to <code class="literal">it</code> in subsequent evaluations but be aware that, as in <span class="emphasis"><em>Highlander</em></span>, there can be only one; whenever FSI implicitly binds something, the value is replaced. You can see this behavior by evaluating multiple expressions without explicitly binding the results to an identifier, as shown here.</p><a id="pro_id00017"/><pre class="programlisting">&gt; <span class="strong"><strong>it;;</strong></span>
val it : int = 3

&gt; <span class="strong"><strong>add 3 4;;</strong></span>
val it : int = 7

&gt; <span class="strong"><strong>it;;</strong></span>
val it : int = 7</pre><p>The bottom line when it comes to the <code class="literal">it</code> identifier is love it, use it, but don’t rely on it.</p></div><div class="sect1" title="Playing in the Sandbox"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="playing_in_the_sandbox">Playing in the Sandbox</h2></div></div></div><p>Even when running within Visual Studio, FSI is a sandbox that’s isolated from and completely unaware of any code you haven’t explicitly told it about. This isolation provides a layer of protection between “work” and <a id="iddle1389" class="indexterm"/><a id="iddle1392" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1414" class="indexterm"/>“play,” but it also means that in order for it to be useful you’ll need ways to interact with the outside world. For this we turn to directives.</p><p>FSI provides several directives that you can invoke in an interactive session or a script. Among these are directives for refreshing your memory about which directives are available, loading code from other F# source files, referencing assemblies, and even providing some performance statistics.</p><div class="sect2" title="#help"><div class="titlepage"><div><div><h3 class="title" id="hashhelp">#help</h3></div></div></div><p>If you forget any of the directives, you can invoke the <code class="literal">#help</code> directive at the FSI prompt for a listing of available directives and a brief description of each.</p></div><div class="sect2" title="#quit"><div class="titlepage"><div><div><h3 class="title" id="hashquit">#quit</h3></div></div></div><p>If you need to get out of FSI from the command prompt, use the <code class="literal">#quit</code> directive to end the session. Although you can use <code class="literal">#quit</code> within the FSI window in Visual Studio, I suggest using the Reset Interactive Session context menu item shown in <a class="xref" href="ch02.html#reset_interactive_session_context_menu_i" title="Figure 2-2. Reset Interactive Session context menu item">Figure 2-2</a> because it clears previous output and begins a new session automatically.</p><div class="figure"><a id="reset_interactive_session_context_menu_i"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00008"/><img src="httpatomoreillycomsourcenostarchimages1981208.png.jpg" alt="Reset Interactive Session context menu item"/></div></div><div class="figure-title">Figure 2-2. Reset Interactive Session context menu item</div></div></div><div class="sect2" title="#load"><div class="titlepage"><div><div><h3 class="title" id="hashload">#load</h3></div></div></div><p>One way to load existing code into an FSI session is with the <code class="literal">#load</code> directive as shown next. The <code class="literal">#load</code> directive accepts one or more string parameters containing the absolute or relative paths to external source files. FSI should load, compile, and execute the listed files (in order) and make their contents available in the current session.</p><a id="pro_id00018"/><pre class="programlisting">&gt; <span class="strong"><strong>#load @"D:\Dev\FSharp\Samples\Chapter2\MySourceFile.fs";;</strong></span>
[Loading D:\Dev\FSharp\Samples\Chapter2\MySourceFile.fs]
-- <span class="emphasis"><em>snip</em></span> --</pre><div class="sidebar"><a id="loading_made_easy"/><div class="sidebar-title">Loading Made Easy</div><p><a id="iddle1390" class="indexterm"/><a id="iddle1395" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1415" class="indexterm"/><a id="iddle2018" class="indexterm"/>The F# project templates in Visual Studio encourage you to load multiple files by including a script that you can update to include any new files. By keeping this script synchronized with your project structure, you can easily load code from your project into FSI and experiment away.</p></div><p>Although you can include multiple source files in a single <code class="literal">#load</code> directive, it’s often easier to include each with a separate directive. The reason is that if you’re actively working on one of the files and you break something, the compiler highlights the entire directive as a problem. By using multiple directives, you can more quickly isolate the troublesome file.</p></div><div class="sect2" title="#r"><div class="titlepage"><div><div><h3 class="title" id="hashr">#r</h3></div></div></div><p>The <code class="literal">#r</code> directive is to assemblies what the <code class="literal">#load</code> directive is to source files. You can use <code class="literal">#r</code> to reference any .NET assembly (with the usual restrictions around target framework and platform). If the assembly you need is already located in one of the folders included in the assembly search path, identify it by name or you’ll need to include the full path. For example, if you need to load <code class="literal">System.Configuration</code>, you can use:</p><a id="pro_id00019"/><pre class="programlisting">&gt; <span class="strong"><strong>#r "System.Configuration";;</strong></span>
--&gt; Referenced 'C:\Program Files (x86)\Reference Assemblies\Microsoft\
Framework\.NETFramework\v4.5\System.Configuration.dll'</pre><p>FSI responds with the full path of each assembly it loads in this manner.</p></div><div class="sect2" title="#I"><div class="titlepage"><div><div><h3 class="title" id="hashi">#I</h3></div></div></div><p>When you need to reference multiple assemblies from a folder that is not already included in the search path, you can add the folder to the assembly search path in FSI with the <code class="literal">#I</code> directive.</p><a id="pro_id00020"/><pre class="programlisting">&gt; <span class="strong"><strong>#I @"D:\Dev\FSharp\Samples\Chapter2\Bin\Debug";;</strong></span>
--&gt; Added 'D:\Dev\FSharp\Samples\Chapter2\Bin\Debug' to library include path</pre><p>Once the folder is added to the search path, you should be able to reference assemblies in it by name instead of by their full path.</p></div><div class="sect2" title="#time"><div class="titlepage"><div><div><h3 class="title" id="hashtime">#time</h3></div></div></div><p>The <code class="literal">#time</code> directive provides extra visibility into what your code is doing by printing some statistics along with its output. You can enable timing information by using the <code class="literal">#time</code> directive with the <code class="literal">on</code> string argument.</p><a id="pro_id00021"/><pre class="programlisting">&gt; <span class="strong"><strong>#time "on";;</strong></span>
-- &gt; Timing now on</pre><p><a id="iddle1426" class="indexterm"/><a id="iddle1427" class="indexterm"/><a id="iddle1457" class="indexterm"/><a id="iddle1461" class="indexterm"/><a id="iddle1862" class="indexterm"/>With timing enabled, the statistics will be computed each time code is executed in FSI. These statistics include real time, CPU time, and the number of garbage collection operations over all three generations. For example, to help optimize a slow function you could invoke it with timing enabled and see something like this:</p><a id="pro_id00022"/><pre class="programlisting">&gt; <span class="strong"><strong>DoSomethingSlow();;</strong></span>
Real: 00:00:01.095, CPU: 00:00:01.107, GC gen0: 25, gen1: 23, gen2: 23
val it : unit = ()</pre><p>When you’re done with the statistics and no longer want to see them in the FSI output, disable them with the <code class="literal">#time</code> directive and the <code class="literal">off</code> string argument.</p><a id="pro_id00023"/><pre class="programlisting">&gt; <span class="strong"><strong>#time "off";;</strong></span>
--&gt; Timing now off</pre></div></div><div class="sect1" title="Scripting"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="scripting">Scripting</h2></div></div></div><p>As F# is a .NET language, most of your F# code will be placed in .<span class="emphasis"><em>fs</em></span> files and compiled into assemblies to be used by larger applications. When coupled with FSI, though, F# can serve as a scripting language so you can leverage its power to automate common tasks with full support from the .NET Framework.</p><p>For example, say you want to concatenate several PDF files into one document. You could write a console application for this, but it’s trivial to write it as a script using the open source PDFsharp library to manipulate the individual PDFs. That script would take about 30 lines of code, including blank lines. By providing terse syntax and exposing the power of the .NET Framework, F# is ideal for such a task.</p><p>Creating scripts as .<span class="emphasis"><em>fsx</em></span> files offers a few benefits. For one, the directives described in <a class="xref" href="ch02.html#playing_in_the_sandbox" title="Playing in the Sandbox">Playing in the Sandbox</a> are FSI features, so they aren’t allowed in standard source files. Also, because .<span class="emphasis"><em>fsx</em></span> files are associated with <span class="emphasis"><em>fsi.exe</em></span>, you can execute them directly from a shell context menu as shown in <a class="xref" href="ch02.html#run_with_fhash_interactive_context_menu" title="Figure 2-3. Run with F# Interactive context menu item">Figure 2-3</a>. This makes it easy to run scripts like the PDF concatenation as needed.</p><div class="figure"><a id="run_with_fhash_interactive_context_menu"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00009"/><img src="httpatomoreillycomsourcenostarchimages1981210.png.jpg" alt="Run with F# Interactive context menu item"/></div></div><div class="figure-title">Figure 2-3. Run with F# Interactive context menu item</div></div><p>To add scripts to a project, select the project in Solution Explorer, press <span class="smaller">CTRL</span>-<span class="smaller">SHIFT</span>-A to open the <span class="strong"><strong>Add New Item</strong></span> dialog, and select <span class="strong"><strong>F# Script File</strong></span> as shown in <a class="xref" href="ch02.html#adding_an_fhash_script_file_to_a_project" title="Figure 2-4. Adding an F# script file to a project">Figure 2-4</a>.</p><div class="figure"><a id="adding_an_fhash_script_file_to_a_project"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00010"/><img src="httpatomoreillycomsourcenostarchimages1981212.png.jpg" alt="Adding an F# script file to a project"/></div></div><div class="figure-title">Figure 2-4. Adding an F# script file to a project</div></div><p>To quickly create a standalone .<span class="emphasis"><em>fsx</em></span> file in Visual Studio 2013, press <span class="smaller">CTRL</span>-N to open the <span class="strong"><strong>New File</strong></span> dialog, select <span class="strong"><strong>Script</strong></span> from the menu on the left, and locate the <span class="strong"><strong>F# Script File</strong></span> option as shown in <a class="xref" href="ch02.html#creating_a_standalone_fhash_script_file" title="Figure 2-5. Creating a standalone F# script file">Figure 2-5</a>.</p><div class="figure"><a id="creating_a_standalone_fhash_script_file"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00011"/><img src="httpatomoreillycomsourcenostarchimages1981214.png.jpg" alt="Creating a standalone F# script file"/></div></div><div class="figure-title">Figure 2-5. Creating a standalone F# script file</div></div></div><div class="sect1" title="F# Interactive Options"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="fhash_interactive_options">F# Interactive Options</h2></div></div></div><p><a id="iddle1406" class="indexterm"/><a id="iddle1413" class="indexterm"/>In addition to the directives discussed in <a class="xref" href="ch02.html#playing_in_the_sandbox" title="Playing in the Sandbox">Playing in the Sandbox</a>, FSI provides several command-line options that allow you to control it. Some of these options offer alternatives to the functionality of the FSI directives, while others control compiler behavior. I won’t cover all of the available options here, but I will highlight the ones you’re most likely to use. (For a complete listing of FSI options, run <span class="strong"><strong><code class="literal">fsi.exe –help</code></strong></span>.) These options apply regardless of whether you’re running FSI through the command prompt or the F# Interactive window. To set the options in Visual Studio, go to <span class="strong"><strong>Tools</strong></span> ◂ <span class="strong"><strong>Options</strong></span>, find <span class="strong"><strong>F# Tools</strong></span> in the list on the left, and type the new options into the <span class="strong"><strong>F# Interactive options</strong></span> text box as shown in <a class="xref" href="ch02.html#setting_fhash_interactive_options" title="Figure 2-6. Setting F# Interactive options">Figure 2-6</a>.</p><div class="figure"><a id="setting_fhash_interactive_options"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00012"/><img src="httpatomoreillycomsourcenostarchimages1981216.png.jpg" alt="Setting F# Interactive options"/></div></div><div class="figure-title">Figure 2-6. Setting F# Interactive options</div></div><div class="note" title="Note"><h3 class="title"><a id="ch02note02"/>Note</h3><p><span class="emphasis"><em>The F# Interactive options setting in Visual Studio is a global setting. Changing it will affect all instances of the window.</em></span></p></div><div class="sect2" title="--load"><div class="titlepage"><div><div><h3 class="title" id="load">--load</h3></div></div></div><p>The <code class="literal">--load</code> option is the command-line equivalent of the <code class="literal">#load</code> directive. It allows you to specify external source files for FSI to compile and load into the session at startup, like this:</p><a id="pro_id00024"/><pre class="programlisting"><span class="strong"><strong>fsi --load:MyFirstScript.fsx</strong></span></pre><p><a id="iddle1256" class="indexterm"/><a id="iddle1391" class="indexterm"/><a id="iddle1393" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle1402" class="indexterm"/><a id="iddle1404" class="indexterm"/><a id="iddle1405" class="indexterm"/><a id="iddle1409" class="indexterm"/><a id="iddle1410" class="indexterm"/><a id="iddle1412" class="indexterm"/><a id="iddle1971" class="indexterm"/><a id="iddle1972" class="indexterm"/><a id="iddle1973" class="indexterm"/><a id="iddle1974" class="indexterm"/>The <code class="literal">--load</code> option doesn’t process any directives in the specified file, so if any directives must be evaluated use the <code class="literal">--use</code> option instead.</p></div><div class="sect2" title="--use"><div class="titlepage"><div><div><h3 class="title" id="use">--use</h3></div></div></div><p>Like <code class="literal">--load</code>, the <code class="literal">--use</code> option loads external source files, but it also processes directives such as <code class="literal">#load</code> or <code class="literal">#I</code> upon loading the file.</p><a id="pro_id00025"/><pre class="programlisting"><span class="strong"><strong>fsi --use:MyFirstScript.fsx</strong></span></pre></div><div class="sect2" title="--reference"><div class="titlepage"><div><div><h3 class="title" id="reference">--reference</h3></div></div></div><p>Just as you can use <code class="literal">--load</code> or <code class="literal">--use</code> to import a source file, you can use the <code class="literal">--reference</code> option (or its short form, <code class="literal">-r</code>) to reference an external assembly. This has the same effect as the <code class="literal">#r</code> directive.</p><a id="pro_id00026"/><pre class="programlisting"><span class="strong"><strong>fsi --reference:System.Configuration</strong></span></pre><p>As with the <code class="literal">#r</code> directive, be sure to include the full path to the assembly if it’s not in a location already included in the search path.</p></div><div class="sect2" title="--lib"><div class="titlepage"><div><div><h3 class="title" id="lib">--lib</h3></div></div></div><p>The <code class="literal">--lib</code> option serves the same role as the <code class="literal">#I</code> directive by adding the specified folder to the assembly search path. Its short form is <code class="literal">-I</code>.</p><a id="pro_id00027"/><pre class="programlisting"><span class="strong"><strong>fsi --lib:D:\Dev\FSharp\Samples\Chapter2\Bin\Debug</strong></span></pre></div><div class="sect2" title="--define"><div class="titlepage"><div><div><h3 class="title" id="define">--define</h3></div></div></div><p>As with other .NET languages, F# allows you to define conditional compilation symbols (like the predefined <code class="literal">DEBUG</code> and <code class="literal">RELEASE</code> symbols in Visual Studio) that can affect how code is compiled. To define symbols for use within an FSI session, use the <code class="literal">--define</code> option.</p><a id="pro_id00028"/><pre class="programlisting"><span class="strong"><strong>fsi --define:DEBUG</strong></span></pre><p>FSI and the F# compiler automatically define certain symbols for you, depending on how your code is compiled. For example, when you are running code compiled in an FSI session, whether by entering it at a prompt, sending it from the text editor, or importing another file, FSI defines the <code class="literal">INTERACTIVE</code> symbol. Directly compiled F# code gets the <code class="literal">COMPILED</code> symbol instead. These symbols become important when code must behave differently under an FSI session than in a compiled assembly due to environmental differences.</p></div><div class="sect2" title="--exec"><div class="titlepage"><div><div><h3 class="title" id="exec">--exec</h3></div></div></div><p><a id="iddle1245" class="indexterm"/><a id="iddle1257" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1403" class="indexterm"/><a id="iddle1408" class="indexterm"/><a id="iddle1490" class="indexterm"/><a id="iddle1861" class="indexterm"/>By default the FSI process doesn’t terminate when it finishes evaluating a script. To force it to quit rather than return you to the FSI prompt, specify the <code class="literal">--exec</code> option.</p><a id="pro_id00029"/><pre class="programlisting"><span class="strong"><strong>fsi --load:MyFirstScript.fsx --exec</strong></span></pre><p>Now, when the script completes you’ll automatically be returned to the command prompt.</p></div><div class="sect2" title="--"><div class="titlepage"><div><div><h3 class="title" id="ndashndash">--</h3></div></div></div><p>If your code expects command-line arguments, you can send them to FSI with the <code class="literal">--</code> option; this is essentially a delimiter that tells FSI to treat all remaining arguments as arguments to the code rather than to FSI itself.</p><a id="pro_id00030"/><pre class="programlisting"><span class="strong"><strong>fsi --load:MyFirstScript.fsx --exec -- Dave</strong></span></pre><p>When code that’s dependent on command-line arguments might be executed from either an FSI session or a compiled assembly, you should use the <code class="literal">INTERACTIVE</code> and <code class="literal">COMPILED</code> symbols to ensure that the parameters are read correctly. For example, in a typical .NET application you’d use <code class="literal">System.Environment.GetCommandLineArgs()</code> to resolve the arguments. The same holds true for <code class="literal">COMPILED</code> code, but in <code class="literal">INTERACTIVE</code> code the execution process is actually FSI rather than your assembly. Therefore, the <code class="literal">GetCommandLineArgs</code> method returns all arguments passed to the FSI process rather than only the ones intended for your script! To account for this difference, interactive code should typically call <code class="literal">fsi.CommandLineArgs</code> instead. You can easily change this behavior with conditional compilation, like this.</p><a id="pro_id00031"/><pre class="programlisting"><span class="strong"><strong>let getCommandLineArgs() =</strong></span>
<span class="strong"><strong>#if INTERACTIVE</strong></span>
  <span class="strong"><strong>fsi.CommandLineArgs</strong></span>
<span class="strong"><strong>#else</strong></span>
  <span class="strong"><strong>System.Environment.GetCommandLineArgs()</strong></span>
<span class="strong"><strong>#endif</strong></span>

getCommandLineArgs() |&gt; printfn "%A"</pre><p>Fortunately, both functions return the same result: a string array that includes the script/executable name as the first item. This greatly simplifies any argument-parsing code you have, because the end result is the same.</p></div><div class="sect2" title="--quiet"><div class="titlepage"><div><div><h3 class="title" id="quiet">--quiet</h3></div></div></div><p>Depending on what your script is doing, FSI can be pretty chatty and sometimes results can get lost in the noise. To tell FSI to be quiet, use the <code class="literal">--quiet</code> option.</p><a id="pro_id00032"/><pre class="programlisting"><span class="strong"><strong>fsi --quiet</strong></span></pre><p><a id="iddle1407" class="indexterm"/><a id="iddle1411" class="indexterm"/>The <code class="literal">--quiet</code> option suppresses virtually everything FSI would normally output, including bindings, file loads, and assembly references (but not statistics when timing is enabled). FSI will still display error messages and anything your code sends to the console.</p></div><div class="sect2" title="--optimize"><div class="titlepage"><div><div><h3 class="title" id="optimize">--optimize</h3></div></div></div><p>The <code class="literal">--optimize</code> option controls whether compiler optimizations will be applied to the code. It’s enabled by default in Visual Studio.</p></div><div class="sect2" title="--tailcalls"><div class="titlepage"><div><div><h3 class="title" id="tailcalls">--tailcalls</h3></div></div></div><p>We’ll look at tail recursion in detail in <a class="xref" href="ch05.html" title="Chapter 5. Let’s Get Functional">Chapter 5</a>, but for now just know that the <code class="literal">--tailcalls</code> option controls whether the compiler will optimize for tail-recursive functions. This option is enabled by default in FSI.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00002">Summary</h2></div></div></div><p>In this chapter you’ve learned how F#’s REPL tool, F# Interactive, can help you explore a problem and find a path to the solution. You’ve also learned how you can customize the behavior of FSI through directives and command-line options. In the next chapter, we’ll begin exploring the F# language itself by learning about a variety of key features that apply regardless of whether you’re programming in a functional, object-oriented, or imperative style.</p></div></section></body></html>