<html><head></head><body>
<section aria-labelledby="ch1" epub:type="chapter" role="doc-chapter">
<span aria-label="1" epub:type="pagebreak" id="pg_1" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch1">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">GETTING STARTED WITH C</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In this chapter, you’ll develop your first C program: the traditional “Hello, world!” program. We’ll examine the various aspects of this simple C program, compile it, and run it. Then I’ll review some editor and compiler options and lay out common portability issues you’ll quickly become familiar with as you code in C.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-7"/><samp class="SANS_Futura_Std_Bold_B_11">Developing Your First C Program</samp></h2>
<p class="TNI">The most effective way to learn C programming is to start writing C programs, and the traditional program to start with is “Hello, world!” Open your favorite text editor and enter the program in <a href="chapter1.xhtml#Lis1-1">Listing 1-1</a>.</p>
<span id="Lis1-1"/><p class="CodeLabel"><samp class="SANS_Futura_Std_Medium_Oblique_I_11">hello.c</samp></p>
<pre class="pre"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

<span aria-label="2" epub:type="pagebreak" id="pg_2" role="doc-pagebreak"/>int main() {
  puts("Hello, world!");
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: The “Hello, world!” program</samp></p>
<p class="TX">The first two lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> preprocessor directive, which behaves as if you replaced it with the contents of the specified file at the exact same location. In this program, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdlib.h&gt;</samp> are both headers. A <i>header</i> is a source file that, by convention, contains the definitions, function declarations, and constant definitions required by the users of the corresponding source file. As the filenames suggest, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp> defines the interface for C standard input/output (I/O) functions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdlib.h&gt;</samp> declares several general utility types and functions and defines several macros. You need to include the declarations for any library functions that you use in your program. (You’ll learn more about the appropriate use of headers in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.)</p>
<p class="TX">Here, we include <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp> to access the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function called by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function. We include the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdlib.h&gt;</samp> to access the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> macro, which is used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement.</p>
<p class="TX">This line defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function that’s called at program startup:</p>

<pre><code>int main() {</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function defines the entry point for the program that’s executed in a hosted environment when the program is invoked from the command line or from another program. C defines two possible execution environments: freestanding and hosted. A <i>freestanding</i> environment may not provide an operating system and is typically used in embedded programming. These implementations provide a minimal set of library functions, and the name and type of the function called at program startup are implementation defined. Most of the examples in this book work on the assumption that the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function is the one and only entry point.</p>
<p class="TX">Like other procedural languages, C programs contain <i>functions</i> that can accept arguments and return values. Each function is a reusable unit of work that you can invoke as often as required in your program. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is invoked from the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function to print out the line <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>:</p>

<pre><code>  puts("Hello, world!");</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a C standard library function that writes a string argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> stream and appends a newline character to the output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> stream typically represents the console or terminal window. <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, world!"</samp> is a string literal that behaves like a read-only string. This function invocation outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp> to the terminal.</p>
<p class="TX">Once your program has completed, you’ll want it to exit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement will exit <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and return an integer value to the host environment or invocation script:</p>

<pre><code><span aria-label="3" epub:type="pagebreak" id="pg_3" role="doc-pagebreak"/>  return EXIT_SUCCESS;</code></pre>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> is an object-like macro that may be defined as follows:</p>

<pre><code>#define EXIT_SUCCESS 0</code></pre>
<p class="TX">Each occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> is replaced by a 0, which is then returned to the host environment from the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The script that invokes the program can then check its status to determine whether the invocation was successful. A return from the initial call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function is equivalent to calling the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> function with the value returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function as its argument.</p>
<p class="TX">The final line of this program consists of a closing brace (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>), which closes the code block we opened with the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function:</p>

<pre><code>int main() {
  // <var>--snip--</var>
}</code></pre>
<p class="TX">You can place the opening brace on the same line as the declaration or on its own line, as follows:</p>

<pre><code>int main()
{
  // <var>--snip--</var>
}</code></pre>
<p class="TX">This decision is strictly a stylistic one, because whitespace characters (including newlines) are generally not syntactically meaningful. In this book, I usually place the opening brace on the line with the function declaration because it’s stylistically more compact.</p>
<p class="TX">For now, save this file as <i>hello.c</i>. The file extension <i>.c</i> indicates that the file contains C language source code.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>If you’ve purchased an ebook, cut and paste the program into the editor. Using cut and paste can reduce transcription errors.</i></p>
</section>
<section aria-labelledby="sec2" epub:type="division">

<h2 class="H1" id="sec2"><span id="h1-8"/><samp class="SANS_Futura_Std_Bold_B_11">Compiling and Running a Program</samp></h2>
<p class="TNI">Next, you need to compile and run the program, which involves two steps. The command to compile the program depends on which compiler you’re using. On Linux and other Unix-like operating systems, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cc</samp> on the command line followed by the name of the file you want to compile:</p>

<pre><code>$ <b>cc hello.c</b></code></pre>
<p class="TX">If you enter the program correctly, the compile command will create a new file called <i>a.out</i> in the same directory as your source code.</p>
<blockquote>
<p class="Note"><span aria-label="4" epub:type="pagebreak" id="pg_4" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Compilers are invoked differently on other operating systems such as Windows or macOS. Refer to the documentation for your specific compiler.</i></p>
<p class="TX">Inspect your directory with the following command:</p>

<pre><code>$ <b>ls</b>
a.out  hello.c</code></pre>
<p class="TX">The <i>a.out</i> file in the output is the executable program, which you can now run on the command line:</p>

<pre><code>$ <b>./a.out</b>
Hello, world!</code></pre>
<p class="TX">If everything goes right, the program should print <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp> to the terminal window. If it doesn’t, compare the program text from <a href="chapter1.xhtml#Lis1-1">Listing 1-1</a> to your program and make sure they are the same.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cc</samp> command accepts numerous compiler options. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o file</samp> compiler option, for example, lets you give the executable file a memorable name instead of <i>a.out</i>. The following compiler invocation names the executable <i>hello</i>:</p>

<pre><code>$ <b>cc -o hello hello.c</b>
$ <b>./hello</b>
Hello, world!</code></pre>
<p class="TX">We’ll introduce other compiler and linker options (aka flags) throughout the book and dedicate a section to them in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.</p>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-1"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Return Values</samp></h3>
<p class="TNI">Functions will often return a value that’s the result of a computation or that signifies whether the function successfully completed its task. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function we used in our “Hello, world!” program takes a string to print and returns a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function returns the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> (a negative integer) if a write error occurs; otherwise, it returns a nonnegative integer value.</p>
<p class="TX">Although it’s unlikely that the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function will fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> for our simple program, it’s possible. Because the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> can fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, it means that your first C program has a bug or, at least, can be improved as follows:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
  if (puts("Hello, world!") == EOF) {
    return EXIT_FAILURE;
    // code here never executes
  }
<span aria-label="5" epub:type="pagebreak" id="pg_5" role="doc-pagebreak"/>  return EXIT_SUCCESS;
  // code here never executes
}</code></pre>
<p class="TX">This revised version of the “Hello, world!” program checks whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> call returns the value <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, indicating a write error. If the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, the program returns the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp> macro (which evaluates to a nonzero value). Otherwise, the function succeeds, and the program returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>. The script that invokes the program can check its status to determine whether it was successful. Code following a return statement is <i>dead code</i> that never executes. This is indicated by a single-line comment in the revised program. Everything following <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> is disregarded by the compiler.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-2"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatted Output</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a simple way to write a string to <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>, but to print arguments other than strings, you’ll need the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function takes a format string that defines how the output is formatted, followed by a variable number of arguments that are the actual values you want to print. For example, if you want to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function to print out <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>, you could write it like this:</p>

<pre><code>printf("%s\n", "Hello, world!");</code></pre>
<p class="TX">The first argument is the format string <samp class="SANS_TheSansMonoCd_W5Regular_11">"%s\n"</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> is a conversion specification that instructs the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function to read the second argument (a string literal) and print it to <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> is an alphabetic escape sequence used to represent nongraphic characters and tells the function to include a new line after the string. Without the newline sequence, the next characters printed (likely the command prompt) would appear on the same line. This function call outputs the following:</p>

<pre><code>Hello, world!</code></pre>
<p class="TX">Take care not to pass user-supplied data as part of the first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function, because doing so can result in a formatted output security vulnerability (Seacord 2013).</p>
<p class="TX">The simplest way to output a string is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function, as previously shown. If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> in the revised version of the “Hello, world!” program, however, you’ll find it no longer works because the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function returns the status differently than the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function returns the number of characters printed when successful, or a negative value if an output or encoding error occurred. Try modifying the “Hello, world!” program to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function as an exercise.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<span aria-label="6" epub:type="pagebreak" id="pg_6" role="doc-pagebreak"/>
<h2 class="H1" id="sec5"><span id="h1-9"/><samp class="SANS_Futura_Std_Bold_B_11">Editors and Integrated Development Environments</samp></h2>
<p class="TNI">You can use a variety of editors and integrated development environments (IDEs) to develop your C programs. <a href="chapter1.xhtml#fig1-1">Figure 1-1</a> shows the most used editors, according to a 2023 JetBrains survey (<i><a href="https://www.jetbrains.com/lp/devecosystem-2023/c/">https://<wbr/>www<wbr/>.jetbrains<wbr/>.com<wbr/>/lp<wbr/>/devecosystem<wbr/>-2023<wbr/>/c<wbr/>/</a></i>).</p>
<figure class="IMG"><img alt="" class="img7" id="fig1-1" src="../images/f01001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Popular IDEs and editors</samp></p></figcaption>
</figure>
<p class="TX">The exact tools available depend on which system you’re using.</p>
<p class="TX">For Microsoft Windows, Microsoft’s Visual Studio IDE (<i><a href="https://visualstudio.microsoft.com">https://<wbr/>visualstudio<wbr/>.microsoft<wbr/>.com</a></i>) is an obvious choice. Visual Studio comes in three editions: Community, Professional, and Enterprise. The Community edition has the advantage of being free, while the other editions add features at a cost. For this book, you’ll need only the Community edition.</p>
<p class="TX">For Linux, the choice is less obvious as there are a variety of options. A popular choice is Visual Studio Code (VS Code). VS Code is a streamlined code editor with support for development operations such as debugging, task running, and version control (covered in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>). It provides just the tools a developer needs for a quick code-build-debug cycle. VS Code runs on macOS, Linux, and Windows and is free for private or commercial <span aria-label="7" epub:type="pagebreak" id="pg_7" role="doc-pagebreak"/>use. Installation instructions are available for Linux and other platforms (<i><a href="https://code.visualstudio.com">https://<wbr/>code<wbr/>.visualstudio<wbr/>.com</a></i>).</p>
<p class="TX"><a href="chapter1.xhtml#fig1-2">Figure 1-2</a> shows VS Code being used to develop the “Hello, world!” program on Ubuntu. The debug console shows that the program exited with status code 0 as expected.</p>
<figure class="IMG"><img alt="" class="img1" id="fig1-2" src="../images/f01002.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: Visual Studio Code running on Ubuntu</samp></p></figcaption>
</figure>
<p class="TX">Vim is the editor of choice for many developers and power users. It is a text editor based on the vi editor written by Bill Joy in the 1970s for a version of Unix. It inherits the key bindings of vi but also adds functionality and extensibility that are missing from the original vi. You can optionally install Vim plug-ins such as YouCompleteMe (<i><a href="https://github.com/ycm-core/YouCompleteMe">https://<wbr/>github<wbr/>.com<wbr/>/ycm<wbr/>-core<wbr/>/YouCompleteMe</a></i>) or deoplete (<i><a href="https://github.com/Shougo/deoplete.nvim">https://<wbr/>github<wbr/>.com<wbr/>/Shougo<wbr/>/deoplete<wbr/>.nvim</a></i>) that provide native semantic code completion for C programming.</p>
<p class="TX">GNU Emacs is an extensible, customizable, and free text editor. At its core, it’s an interpreter for Emacs Lisp, a dialect of the Lisp programming language with extensions to support text editing—although I’ve never found this to be a problem. Full disclosure: Almost all the production C code I’ve developed was edited in Emacs.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">

<h2 class="H1" id="sec6"><span id="h1-10"/><samp class="SANS_Futura_Std_Bold_B_11">Compilers</samp></h2>
<p class="TNI">Many C compilers are available, so I won’t discuss them all here. Different compilers implement different versions of the C standard. Many compilers for embedded systems support only C89/C90. Popular compilers for Linux and Windows work harder to support modern versions of the C standard, up to and including support for C23.</p>
<section aria-labelledby="sec7" epub:type="division">
<span aria-label="8" epub:type="pagebreak" id="pg_8" role="doc-pagebreak"/>
<h3 class="H2" id="sec7"><span id="h2-3"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GNU Compiler Collection</samp></h3>
<p class="TNI">The GNU Compiler Collection (GCC) includes frontends for C, C++, and Objective-C, as well as other languages (<i><a href="https://gcc.gnu.org">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org</a></i>). GCC follows a well-defined development plan under the guidance of the GCC steering committee.</p>
<p class="TX">GCC has been adopted as the standard compiler for Linux systems, although versions are also available for Microsoft Windows, macOS, and other platforms. Installing GCC on Linux is easy. The following command, for example, should install GCC on Ubuntu:</p>

<pre><code>$ <b>sudo apt-get install gcc</b></code></pre>
<p class="TX">You can test the version of GCC you’re using with the following command:</p>

<pre><code>$ <b>gcc --version</b></code></pre>
<p class="TX">The output will display the version and copyright information for the installed GCC version.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-4"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clang</samp></h3>
<p class="TNI">Another popular compiler is Clang (<i><a href="https://clang.llvm.org">https://<wbr/>clang<wbr/>.llvm<wbr/>.org</a></i>). Installing Clang on Linux is also easy. You can use the following command to install Clang on Ubuntu:</p>

<pre><code>$ <b>sudo apt-get install clang</b></code></pre>
<p class="TX">You can test the version of Clang you’re using with the following command:</p>

<pre><code>$ <b>clang --version</b></code></pre>
<p class="TX">This displays the installed Clang version.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h3 class="H2" id="sec9"><span id="h2-5"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft Visual Studio</samp></h3>
<p class="TNI">As previously mentioned, the most popular development environment for Windows is Microsoft Visual Studio, which includes both the IDE and the compiler. Visual Studio (<i><a href="https://visualstudio.microsoft.com/downloads/">https://<wbr/>visualstudio<wbr/>.microsoft<wbr/>.com<wbr/>/downloads<wbr/>/</a></i>) is bundled with Visual C++ 2022, which includes both the C and C++ compilers.</p>
<p class="TX">You can set options for Visual Studio on the Project Property pages. On the Advanced tab under C/C++, make sure you compile as C code by using the Compile as C Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>) option and not the Compile as C++ Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>) option. By default, when you name a file with a <i>.c</i> extension, it’s compiled with <samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>. If the file is named with <i>.cpp</i>, <i>.cxx</i>, or a few other extensions, it’s compiled with <samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<span aria-label="9" epub:type="pagebreak" id="pg_9" role="doc-pagebreak"/>
<h2 class="H1" id="sec10"><span id="h1-11"/><samp class="SANS_Futura_Std_Bold_B_11">Portability</samp></h2>
<p class="TNI">Every C compiler implementation is a little different. Compilers continually evolve—so, for example, a compiler like GCC might provide full support for C17 but be working toward support for C23, in which case it might have some C23 features implemented but not others. Consequently, compilers support a full spectrum of C standard versions (including in-between versions). The overall evolution of C implementations is slow, with many compilers significantly lagging behind the C standard.</p>
<p class="TX">Programs written for C can be considered <i>strictly conforming</i> if they use only those features of the language and library specified in the standard. These programs are intended to be maximally portable. However, because of the range of implementation behaviors, no real-world C program is strictly conforming, nor will it ever be (and probably shouldn’t be). Instead, the C standard allows you to write <i>conforming</i> programs that may depend on nonportable language and library features.</p>
<p class="TX">It’s common practice to write code for a single reference implementation, or sometimes several implementations, depending on the platforms to which you plan to deploy your code. The C standard ensures that these implementations don’t differ too much, and it allows you to target several at once without having to learn a new language each time.</p>
<p class="TX">Five kinds of portability issues are enumerated in Annex J of the C standard documents:</p>
<ul class="ul">
<li class="ListBullet">Implementation-defined behavior</li>
<li class="ListBullet">Unspecified behavior</li>
<li class="ListBullet">Undefined behavior</li>
<li class="ListBullet">Locale-specific behavior</li>
<li class="ListBullet">Common extensions</li>
</ul>
<p class="TX">As you learn about the C language, you’ll encounter examples of all five kinds of behaviors, so it’s important to understand precisely what these are.</p>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2" id="sec11"><span id="h2-6"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation-Defined Behavior</samp></h3>
<p class="TNI"><i>Implementation-defined behavior</i> is program behavior that’s not specified by the C standard and that may produce different results between implementations but has consistent, documented behavior within an implementation. An example of implementation-defined behavior is the number of bits in a byte.</p>
<p class="TX">Implementation-defined behaviors are mostly harmless but can cause defects when porting to different implementations. Whenever possible, avoid writing code that depends on implementation-defined behaviors that vary among the C implementations you plan to compile your code with. A complete list of implementation-defined behaviors is enumerated in Annex J.3 of the C standard. You can document your dependencies on these implementation-defined behaviors by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> declaration, as discussed in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<span aria-label="10" epub:type="pagebreak" id="pg_10" role="doc-pagebreak"/>
<h3 class="H2" id="sec12"><span id="h2-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unspecified Behavior</samp></h3>
<p class="TNI"><i>Unspecified behavior</i> is program behavior for which the standard provides two or more options but doesn’t mandate which option is chosen in any instance. Each execution of a given expression may yield different results or produce a different value than a previous execution of the same expression. An example of unspecified behavior is function parameter storage layout, which can vary among function invocations within the same program. Unspecified behaviors are enumerated in Annex J.1 of the C standard.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h3 class="H2" id="sec13"><span id="h2-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Undefined Behavior</samp></h3>
<p class="TNI"><i>Undefined behavior</i> is behavior that isn’t defined by the C standard or, less circularly, “behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which the standard imposes no requirements” (ISO/IEC 9899:2024). Examples of undefined behavior include signed integer overflow and dereferencing an invalid pointer value. Code that has undefined behavior is often incorrect, but not always. Undefined behaviors are identified in the standard as follows:</p>
<ul class="ul">
<li class="ListBullet">When a “shall” or “shall not” requirement is violated and that requirement appears outside a constraint, behavior is undefined.</li>
<li class="ListBullet">When behavior is explicitly specified by the words “undefined behavior.”</li>
<li class="ListBullet">By the omission of any explicit definition of behavior.</li>
</ul>
<p class="TX">The first two kinds of undefined behavior are frequently referred to as <i>explicit undefined behaviors</i>, while the third kind is referred to as <i>implicit undefined behavior</i>. There is no difference in emphasis among these three; they all describe behavior that is undefined. The C standard Annex J.2, “Undefined behavior,” lists the explicit undefined behaviors in C.</p>
<p class="TX">Developers often misconstrue undefined behaviors as errors or omissions in the C standard, but the decision to classify a behavior as undefined is <i>intentional</i> and <i>considered</i>. Behaviors are classified as undefined by the C standards committee for one of the following reasons:</p>
<ul class="ul">
<li class="ListBullet">Give the implementer license not to catch program errors that are difficult to diagnose</li>
<li class="ListBullet">Avoid defining obscure corner cases that would favor one implementation strategy over another</li>
<li class="ListBullet">Identify areas of possible conforming language extension in which the implementer may augment the language by providing a definition of the officially undefined behavior</li>
</ul>
<p class="TX">These three reasons are quite different but are all considered portability issues. We’ll examine examples of all three as they come up over the course of this book. Upon encountering undefined behavior, compilers have the latitude to do the following:</p>
<ul class="ul">
<li class="ListBullet"><span aria-label="11" epub:type="pagebreak" id="pg_11" role="doc-pagebreak"/>Ignore undefined behavior completely, giving unpredictable results</li>
<li class="ListBullet">Behave in a documented manner characteristic of the environment (with or without issuing a diagnostic)</li>
<li class="ListBullet">Terminate a translation or execution (and issue a diagnostic)</li>
</ul>
<p class="TX">None of these options are great (particularly the first), so it’s best to avoid undefined behaviors except when the compiler specifies that these behaviors are defined to allow you to invoke a language augmentation. Compilers sometimes have a <i>pedantic</i> mode that can help notify the programmer of these portability issues.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2" id="sec14"><span id="h2-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locale-Specific Behavior and Common Extensions</samp></h3>
<p class="TNI"><i>Locale-specific behavior</i> depends on local conventions of nationality, culture, and language that each implementation documents. <i>Common extensions</i> are widely used in many systems but are not portable to all implementations.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h2 class="H1" id="sec15"><span id="h1-12"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned how to write a simple C language program, compile it, and run it. We looked at several editors and integrated development environments as well as a few compilers that you can use to develop C programs on Windows, Linux, and macOS systems. You should use newer versions of the compilers and other tools, as they tend to support newer features of the C programming language and provide better diagnostics and optimizations. However, you may not want to use newer versions of compilers if they break your existing code or if you’re getting ready to deploy your code to avoid introducing unnecessary changes into your already tested application. We concluded this chapter with a discussion of the portability of C language programs.</p>
<p class="TX">Subsequent chapters will examine specific features of the C language and library, starting with objects, functions, and types in the next chapter.</p>
</section>
</section>
</body></html>