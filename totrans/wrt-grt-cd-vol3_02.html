<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_3"/><strong><span class="big">1</span><br/>SOFTWARE DEVELOPMENT METAPHORS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">How do we define the software development process? This might seem like a silly question. Why not just say “software development is software development” and leave it at that? Well, if we can draw analogies between software development tasks and other professional endeavors,</span> we can gain insight into the software development process. Then we can refine the process by studying process improvements in related fields. To that end, this chapter explores some of the common ways of understanding software development.</p>
<h3 class="h3" id="lev-1.1"><strong>1.1 What Is Software?</strong></h3>
<p class="noindent">To better understand how programmers create software, we can compare software to other things people create. Doing so will provide important insight into why certain creative metaphors apply, or don’t apply, to software development.</p>
<p class="indent"><span epub:type="pagebreak" id="page_4"/>In his book, <em>Software Engineering: A Beginner’s Approach</em>, Robert Pressman identifies several characteristics of software. This section explores those characteristics to illuminate the nature of software and how it defines a computer programmer’s work.</p>
<h4 class="h4" id="lev-1.1.1"><strong><em>1.1.1 Software Is Not Manufactured</em></strong></h4>
<p class="blockquote"><em>Software is developed or engineered; it is not manufactured in the classical sense.</em></p>
<p class="att1">—Robert Pressman</p>
<p class="noindent_1">Compared to hardware products, the manufacturing cost of a software product is very low: stamping out a CD or DVD costs only a few pennies, plus a small amount for shipping and handling (and electronic distribution is even less expensive). Also, the software design has very little impact on the quality or final cost of the manufactured CD/DVD. Assuming reasonable quality controls at the manufacturing plant, a computer programmer rarely has to consider manufacturing issues when designing a software application.<sup><a href="ch19_footnote.xhtml#ch01fn1" id="ch01fn1a">1</a></sup> Contrast this with other engineering professions where the engineer has to design in <em>manufacturability</em> of the product.</p>
<h4 class="h4" id="lev-1.1.2"><strong><em>1.1.2 Software Doesn’t Wear Out</em></strong></h4>
<p class="noindent">Both software and hardware suffer from failures due to poor design early in the products’ lives. However, if we could eliminate design flaws in the products (that is, deliver a defect-free piece of software or hardware), the differences between the two become obvious. Once a piece of software is correct, it doesn’t ever fail or “wear out.” As long as the underlying computer system is functioning properly, the software will continue to work.<sup><a href="ch19_footnote.xhtml#ch01fn2" id="ch01fn2a">2</a></sup> The software engineer, unlike the hardware engineer, doesn’t have to worry about designing in the ability to easily replace components that fail over time.</p>
<h4 class="h4" id="lev-1.1.3"><strong><em>1.1.3 Most Software Is Custom</em></strong></h4>
<p class="blockquote"><em>Most software is custom built rather than being assembled from existing [standard] components.</em></p>
<p class="att1">—Robert Pressman</p>
<p class="noindent_1">Although many attempts have been made to create similarly standardized software components that software engineers can assemble into large applications, the concept of a <em>software IC</em> (that is, the equivalent of an electronic integrated circuit) has never been realized. Software libraries and object-oriented programming techniques encourage reusing prewritten code, but the premise of constructing large software systems from smaller preassembled components has failed to produce anything close to what’s possible in hardware design.</p>
<h4 class="h4" id="lev-1.1.4"><span epub:type="pagebreak" id="page_5"/><strong><em>1.1.4 Software Can Be Easily Upgraded</em></strong></h4>
<p class="noindent">In many cases, it’s possible to completely replace an existing software application in the field with a new version (or even a completely different application) without incurring a huge cost.<sup><a href="ch19_footnote.xhtml#ch01fn3" id="ch01fn3a">3</a></sup> The application’s end user can simply replace the old software with the new and enjoy the benefits of the upgraded version. In fact, most modern software systems and applications auto-update via the internet during normal operation.</p>
<h4 class="h4" id="lev-1.1.5"><strong><em>1.1.5 Software Is Not an Independent Entity</em></strong></h4>
<p class="noindent">Software is not a stand-alone product. An electrical engineer can design a hardware device that can operate completely on its own. However, software depends upon something else (typically a computer system) for proper operation. Therefore, a software developer must live with the constraints imposed by external systems (computer systems, operating systems, programming languages, and so on) when designing and implementing a software application.</p>
<h3 class="h3" id="lev-1.2"><strong>1.2 Parallels to Other Fields</strong></h3>
<p class="noindent">Computer programmers are often compared to artists, craftsmen, engineers, architects, and technicians. Although computer programming doesn’t match any of these professions exactly, we can draw useful parallels to these fields and gain insight from the techniques they employ.</p>
<h4 class="h4" id="lev-1.2.1"><strong><em>1.2.1 Programmer as Artist</em></strong></h4>
<p class="noindent">In the early days of computer programming, software development was considered an art. The ability to write software—to make sense of so much nonsense to create a working program—seemed to be a God-given talent exercised by a select few, akin to master painters or musical virtuosos. (In fact, considerable anecdotal evidence suggests that musicians and computer programmers use the same areas of their brains for their creative activities, and a decent percentage of programmers were, or are, musicians.<sup><a href="ch19_footnote.xhtml#ch01fn4" id="ch01fn4a">4</a></sup>)</p>
<p class="indent">But is software development an actual art form? An <em>artist</em> is typically defined as someone blessed with certain talents and the skill to use them in a creative way. The key word here is <em>talent</em>, which is a natural ability. Because not everyone is born with the same talents, not everyone can be an artist. To apply the analogy, it would seem that if you want to be a programmer, you have to be born that way; indeed, some people seem to be born with a natural talent or aptitude for programming.</p>
<p class="indent"><span epub:type="pagebreak" id="page_6"/>The “programmer as artist” comparison seems to apply to the very best programmers. Although artists follow their own set of rules to produce quality art, they often produce their most exceptional art when they bend the rules and explore new creative ground. Similarly, the very best programmers are familiar with good software development rules but are also willing to experiment with new techniques to try to improve the development process. Just as true artists are not content with duplicating existing work or styles, the “programmer as artist” is happier creating new applications than grinding out yet another version of an old one.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>One of the most well-respected textbook series on computer science is Donald Knuth’s <em>The Art of Computer Programming</em>. Clearly, the notion of programming as an art form is well entrenched in the computer science field.</em></p>
</div>
<h4 class="h4" id="lev-1.2.2"><strong><em>1.2.2 Programmer as Architect</em></strong></h4>
<p class="noindent">The artist metaphor works great for small projects where the artist creates the idea and implements a work of art, much like a programmer designs and implements a small software system. However, for larger software systems, the “programmer as architect” analogy is probably a better fit. An architect designs the structure but leaves the implementation to others (because often it’s logistically impossible for one person to build it). In computer science, those who design a system for others to implement are often called <em>programmer/analysts</em>.</p>
<p class="indent">An architect exercises large-scale creative control over a project. For example, an architect designing a fancy building defines how it will look, what materials to use, and the guidelines for the construction workers to follow, but doesn’t handle the construction itself. An architect might supervise the build (much like a programmer/analyst would review modules others add to their software system); however, the architect doesn’t wield a hammer or operate a crane.</p>
<p class="indent">It might seem that this analogy doesn’t apply to small projects, but it can if you allow an individual to “change hats.” That is, during the first phase of the project, the programmer puts on their architect/programmer/analyst hat and creates the design for the system. Then the programmer switches hats and puts on their programmer/coder hat to implement the system.</p>
<p class="indent">What the “programmer as architect” paradigm adds over and above the “programmer as artist” model is verification and safety measures. When an artist paints an image, composes a piece of music, or sculpts an object, they generally don’t worry about whether that work meets any requirements other than their own. Also, they don’t have to worry about how that art might physically hurt life or property.<sup><a href="ch19_footnote.xhtml#ch01fn5" id="ch01fn5a">5</a></sup> An architect, on the other hand, must consider physical realities and the fact that a bad design can lead to injury or harm. The “programmer as architect” paradigm introduces personal responsibility, review (testing), and safety to the programmer’s task.</p>
<h4 class="h4" id="lev-1.2.3"><span epub:type="pagebreak" id="page_7"/><strong><em>1.2.3 Programmer as Engineer</em></strong></h4>
<p class="noindent">A NATO conference in 1968 challenged the notion that good programmers are born, not made. As mentioned in this book’s introduction, the world was facing a software crisis—new software applications were needed faster than programmers could be trained to create them. So NATO sponsored the 1968 conference, coining the term <em>software engineering</em> to describe how to tackle the problem by applying engineering principles to the wild world of computer programming.</p>
<p class="indent">Engineers are interested in solving practical problems cost-effectively, in terms of both the design effort and the cost of production. For this reason, coupled with the fact that the engineering profession has been around for a very long time (particularly mechanical and chemical engineering), a large number of procedures and policies have been created for engineers over the years to streamline their work.</p>
<p class="indent">In many engineering fields today, an engineer’s task is to construct a large system from smaller, predesigned building blocks. An electrical engineer who wants to design a computer system doesn’t start by designing custom transistors or other small components; instead, they use predesigned CPUs, memory elements, and I/O devices, assembling them into a complete system. Similarly, a mechanical engineer can use predesigned trusses and pedestals to design a new bridge. Design reuse is the hallmark of the engineering profession. It’s one of the key elements to producing safe, reliable, functional, and cost-effective designs as rapidly as possible.</p>
<p class="indent">Software engineers also follow a set of well-defined procedures and policies to construct large systems from smaller predefined systems. Indeed, the Institute of Electrical and Electronics Engineers (IEEE) defines <em>software engineering</em> as follows:</p>
<p class="blockquote">The application of a systematic, disciplined, quantifiable approach to development, operation, and maintenance of software; that is, the application of engineering to software.</p>
<h4 class="h4" id="lev-1.2.4"><strong><em>1.2.4 Programmer as Craftsman</em></strong></h4>
<p class="noindent">The craftsman model lies somewhere between the artist and the engineer. Central to this paradigm is the idea of programmers as individuals; that is, the software craftsman metaphor recognizes that people matter. Throwing more people and restrictive rules at a problem doesn’t produce higher-quality software, but training individuals better and allowing them to apply their natural talents and skills does.</p>
<p class="indent">There are parallels between the traditional craftsman’s development process and that of the software craftsman. Like all craftsmen, a software craftsman starts as an <em>apprentice</em> or an <em>intern</em>. An apprentice works under the close guidance of another craftsman. After learning the ropes, the apprentice programmer becomes a <em>journeyman</em>, usually working with teams of other programmers under the supervision of a software craftsman. Ultimately, the programmer’s skills increase to the point that they become a <em>master craftsman</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_8"/>The craftsman model provides the best metaphor for programmers intent upon becoming great programmers. I’ll return to the discussion of this metaphor later in this chapter, in the section “<a href="ch01.xhtml#lev-1.4">Software Craftsmanship</a>” on <a href="ch01.xhtml#page_13">page 13</a>.</p>
<h4 class="h4" id="lev-1.2.5"><strong><em>1.2.5 Artist, Architect, Engineer, or Craftsman?</em></strong></h4>
<p class="noindent">To write great code, you must understand what makes code great. You need to use the best tools, coding techniques, procedures, processes, and policies when writing code. In addition, you must constantly increase your knowledge and improve the development processes you use to enhance the quality of the software you develop. That’s why it’s important to consider different approaches to software development, understand the software product, and choose the best approach.</p>
<p class="indent">You need to work hard to learn how to write great code and then work hard at actually writing it. A great software developer adopts ideas that work from each of the fields just discussed and dispenses with those that don’t work. To summarize:</p>
<ul>
<li class="noindent"><em>Great artists</em> practice their skills to develop their talents. They engage in divergent thinking to explore new ways of presenting their message.</li>
<li class="noindent"><em>Great architects</em> know how to build upon existing designs using standard components to create custom objects. They understand cost constraints, safety issues, requirements, and the need for overdesign to ensure reliable operation. Great architects understand the relationship between form and function, as well as the need to fulfill customer requirements.</li>
<li class="noindent"><em>Great engineers</em> recognize the benefit of consistency. They document and automate development steps to avoid missing steps in the process. Like architects, engineers encourage the reuse of existing designs to deliver more robust and cost-effective solutions. Engineering provides procedures and policies to help overcome personal limitations in a project.</li>
<li class="noindent"><em>Great craftsmen</em> train and practice skills under the tutelage of a master with the ultimate goal of becoming a master craftsman. This metaphor emphasizes the qualities of the individual such as their problem-solving and organizational abilities.</li>
</ul>
<h3 class="h3" id="lev-1.3"><strong>1.3 Software Engineering</strong></h3>
<p class="noindent">Since its emergence in the late 1960s, software engineering has become an unqualified success. Today, few professional programmers would accept the coding horrors that were “standard procedure” at the dawn of the field. Concepts that modern programmers take for granted—such as structured programming, proper program layout (like indentation), commenting, and good naming policies—are all due to software engineering research. Indeed, decades of such research have greatly influenced modern programming languages and other programming tools.</p>
<p class="indent"><span epub:type="pagebreak" id="page_9"/>Software engineering has been around for so long and has had such an impact on all facets of computer programming that many people assume the term <em>software engineer</em> is synonymous with <em>computer programmer</em>. It’s certainly true that any professional software engineer should also be a capable computer programmer, but computer programming constitutes only a small part of software engineering. Software engineering largely involves economics and project management. Interestingly, those responsible for managing the projects, maintaining the schedules, choosing the methodologies to use, and so on are not called software engineers; they’re called managers, project leads, and other titles implying a position of authority. Likewise, the people we call software engineers don’t actually do the software engineering—they simply write the code specified by the actual software engineers (managers and project leads). This is, perhaps, why there is so much confusion around the term <em>software engineering</em>.</p>
<h4 class="h4" id="lev-1.3.1"><strong><em>1.3.1 A Formal Definition</em></strong></h4>
<p class="noindent">No single definition of <em>software engineering</em> seems to satisfy everyone. Different authors add their own “spin,” making their definition slightly (or greatly) different than those found in other texts. The reason this book is titled <em>Engineering Software</em> is because I want to avoid adding yet another definition to the mix. As a reminder, the IEEE defines <em>software engineering</em> as</p>
<p class="blockquote">The application of a systematic, disciplined, quantifiable approach to development, operation, and maintenance of software; that is, the application of engineering to software.</p>
<p class="indent">The original software engineering definition, and the one I use, is</p>
<p class="blockquote">Software engineering is the study of the development and management of large software systems.</p>
<p class="indent">The operative term here is <em>large</em>. Progress in software engineering has mostly been funded by defense contracts and the like, so it’s no surprise that software engineering is synonymous with large systems. The IEEE definition could apply to systems of nearly any size, but because most of the research into software engineering deals with very large systems, I prefer the second definition.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>To avoid confusion with the generic term <em>software engineering</em>, I use a more specialized term, <em>personal software engineering</em>, to describe those processes and methodologies that apply to a single programmer working on a small project or a small part of a larger project. My intent is to describe what computer programmers believe is the essence of software engineering without all the extraneous detail that has little to do with writing great code.</em></p>
</div>
<p class="indent">When it comes to software development, people have completely different concepts of what “large” means. An undergraduate in a computer science program might think that a program containing a couple thousand lines of source code is a large system. To a project manager at Boeing <span epub:type="pagebreak" id="page_10"/>(or other large firm), a large system contains well over one million lines of code. The last time I counted (which was a long time ago), Microsoft’s Windows operating system (OS) exceeded 50 million lines of source code; no one questions that Windows is a large system!</p>
<p class="indent">Because traditional software engineering definitions generally apply to large software systems, we need to come up with a reasonable definition of large (and small) software systems. Although <em>lines of code (LOC)</em> is the metric software engineers often use to describe the size of a software system, it is a low-quality metric with almost a two-order-of-magnitude variance.<sup><a href="ch19_footnote.xhtml#ch01fn6" id="ch01fn6a">6</a></sup> This book will often use the LOC or <em>thousands of lines of code (KLOC)</em> metric. But it’s not a good idea to base a formal definition on such a poor metric. Doing so weakens the definition.</p>
<h4 class="h4" id="lev-1.3.2"><strong><em>1.3.2 Project Size</em></strong></h4>
<p class="noindent">A <em>small project</em> is one that an average programmer can complete on their own in a reasonable amount of time (less than two years). A <em>medium-sized project</em> is too large for an individual to complete in a reasonable time frame, but a small team of two to five programmers can accomplish it. A <em>large project</em> requires a large team of programmers (more than five members). In terms of LOC, a small project contains about 50 to 100 KLOC; medium-sized projects fall into the 50 to 1,000 KLOC (one million lines of source code) range; and large projects start at around 500 to 1,000 KLOC.</p>
<p class="indent">Small projects are trivial to manage. Because small projects require no interaction between programmers and very little interaction between the programmer and the outside world, productivity depends almost solely upon the programmer’s abilities.</p>
<p class="indent">Medium-sized projects introduce new challenges. Because multiple programmers are working on the project, communication can become a problem, but the team is small enough that this overhead is manageable. Nevertheless, the group dynamics require extra support, which increases the cost of each line of code written.</p>
<p class="indent">Large projects require a large team of programmers. Communication and other overhead often consume 50 percent of each engineer’s productivity. Effective project management is crucial.</p>
<p class="indent">Software engineering deals with the methodologies, practices, and policies needed to successfully manage projects requiring large teams of programmers. Unfortunately, practices that work well for individuals, or even small teams, don’t scale up to large teams, and large-project methodologies, practices, and policies don’t scale down to small and medium-sized projects. Practices that work well for large projects typically inject unreasonable overhead into small and medium-sized projects, reducing the productivity of those small teams.</p>
<p class="indent">Let’s take a closer look at some benefits and drawbacks of projects of different sizes.</p>
<h5 class="h5" id="lev-1.3.2.1"><span epub:type="pagebreak" id="page_11"/><strong>1.3.2.1 Small Projects</strong></h5>
<p class="noindent">On small projects, a single software engineer is completely responsible for system design, implementation, testing, debugging, deployment, and documentation. On such a project, the lone engineer is accountable for far more tasks than a single engineer would be on a medium-sized or large project. But the tasks are small and therefore manageable. Because a small project requires an individual to perform a wide range of tasks, the programmer must possess a varied skill set. Personal software engineering covers all the activities a developer would do on a small project.</p>
<p class="indent">Small projects make the most efficient use of engineering resources. The engineer can employ the most productive approach to solving problems because they don’t have to reach a consensus with other engineers on the project. The engineer can also optimize the time they spend on each development phase. In a structured software design regimen, considerable time is spent documenting operations, which doesn’t make sense when there’s only a single programmer on a project (though a different programmer might need to work with the code later in the product’s lifetime).</p>
<p class="indent">The drawback, and the trap, of a small project is that an engineer must be capable of handling all the different tasks required. Many small projects fail (or their development cost is too high) because the engineer doesn’t have the proper training to handle an entire project. More than any other goal, the purpose of the <em>Write Great Code</em> series is to teach programmers how to do small projects properly.</p>
<h5 class="h5" id="lev-1.3.2.2"><strong>1.3.2.2 Medium-Sized Projects</strong></h5>
<p class="noindent">On a medium-sized project, personal software engineering encompasses those aspects of the project for which a single engineer is responsible. This typically includes the design of their system component, its implementation (coding), and the documentation for that module. Generally, they are also responsible for testing their component (<em>unit testing</em>), and then the team as a whole tests the entire system (<em>integration testing</em>). Usually, there’s one engineer in charge of the complete system design (the <em>project head</em> or <em>lead programmer</em>) who also handles deployment. Depending on the project, a technical writer might handle system documentation. Because engineers share tasks in a medium-sized project, specialization is possible, and the project doesn’t require each engineer to be capable of performing all the individual tasks. The lead programmer can direct the activities of those less experienced to maintain quality throughout the project.</p>
<p class="indent">A single engineer on a small project sees the total picture and can optimize certain activities based on their understanding of the entire project. On a large project, a single engineer is unaware of much of the project beyond their small piece of it. Medium-sized projects provide a hybrid of these two extremes: individuals can see much of the entire project and adjust their approach to system implementation. They can also specialize on certain aspects of the system without becoming overwhelmed by the details of the rest of the system.</p>
<h5 class="h5" id="lev-1.3.2.3"><span epub:type="pagebreak" id="page_12"/><strong>1.3.2.3 Large Projects</strong></h5>
<p class="noindent">On a large project, various team members have specialized roles, from system design to implementation, testing, documentation, deployment, and system enhancement and maintenance. As with medium-sized projects, in large projects personal software engineering encompasses only those activities for which an individual programmer is responsible. Software engineers on a large project generally do only a few tasks (such as coding and unit testing); therefore, they don’t require the wide-ranging skill set of a lone programmer on a small project.</p>
<p class="indent">Beyond the scope of activity, the size of a project affects the productivity of its engineers. On a large project, engineers can become very specialized and concentrate on their one area of expertise. This allows them to do their job more efficiently than if they had to use a more generalized skill set. However, large projects must use a common software development approach to be effective, and some engineers may not be as productive if they don’t like the approach.</p>
<h4 class="h4" id="lev-1.3.3"><strong><em>1.3.3 Where Software Engineering Fails</em></strong></h4>
<p class="noindent">It’s possible to apply engineering techniques to software development to produce applications in a more cost-effective manner. However, as Pete McBreen states in <em>Software Craftsmanship: The New Imperative</em>, the biggest problem with software engineering is the assumption that a “systematic, disciplined, quantifiable approach” is the only reasonable approach. In fact, he raises a very good question: is it even possible to make software development systematic and quantified? Quoting <em><a href="http://www.controlchaos.com/">http://www.controlchaos.com/</a></em>, McBreen says:</p>
<p class="blockquote">If a process can be fully defined, with all things known about it so that it can be designed and run repeatedly with predictable results, it is known as a defined process, and it can be subjected to automation. If all things about a process aren’t fully known—only what generally happens when you mix these inputs and what to measure and control to get the desired output—these are called empirical processes.</p>
<p class="indent">Software development is not a defined process; it’s an empirical process. As such, software development cannot be fully automated, and it’s often difficult to apply engineering principles to software development. Part of the problem is that practical engineering relies so much on the reuse of existing designs. Although a considerable amount of reuse is possible in computer programming, too, it requires much more customization than you find in other engineering professions.</p>
<p class="indent">Another significant problem with software engineering, as briefly discussed in the book’s introduction, is that software engineering treats software engineers as commodity resources that a manager can swap arbitrarily into and out of a project, which disregards the importance of an individual’s talents. The issue isn’t that engineering techniques aren’t ever valuable, but that management attempts to apply them uniformly to everyone and encourages the use of some current set of “best practices” in <span epub:type="pagebreak" id="page_13"/>software development. This approach can produce quality software, but it doesn’t allow for thinking outside the box and creating new practices that might be better.</p>
<h3 class="h3" id="lev-1.4"><strong>1.4 Software Craftsmanship</strong></h3>
<p class="noindent">Software craftmanship, where a programmer trains and practices skills under the tutelage of a master, is about lifelong learning to be the best software developer you can be. Following the craftmanship model, a programmer gets an education, completes an apprenticeship, becomes a journeyman programmer, and strives to develop a masterpiece.</p>
<h4 class="h4" id="lev-1.4.1"><strong><em>1.4.1 Education</em></strong></h4>
<p class="noindent">Colleges and universities provide the prerequisites that interns need to be software craftsmen. If an internship exposed a beginning programmer (intern/apprentice) to the same information and challenges that a formal education does, the internship might be equivalent to a formal education. Unfortunately, few software craftsmen have the time or ability to train an apprentice from scratch. They’re far too busy working on real-world projects to devote the time needed to teach an intern everything they need to know. Therefore, education is the first step on the road to software craftsmanship.</p>
<p class="indent">Additionally, a formal education at a college or university accomplishes two main objectives: first, you’re forced to study those computer science topics that you’d probably just skip over if you were studying the material on your own; and second, you prove to the world that you’re capable of finishing a major commitment that you’ve started. In particular, after you’ve completed a formal computer science program, you’re ready to <em>really</em> start learning about software development.</p>
<p class="indent">However, a college degree, no matter how advanced, doesn’t automatically qualify you as a software craftsman. A person with a graduate degree, which requires a deeper and more specialized study of computer science, starts out as an intern, just as someone with an undergraduate degree does. The intern with the graduate degree might spend fewer years as an apprentice but still needs considerable training.</p>
<h4 class="h4" id="lev-1.4.2"><strong><em>1.4.2 Apprenticeship</em></strong></h4>
<p class="noindent">Completing a formal computer science program prepares you to start learning, at an apprentice level, how to become a craftsman. A typical computer science program teaches you about programming languages (their syntax and semantics), data structures, and the theory of compilers, operating systems, and the like, but doesn’t teach you <em>how to program</em> beyond the first- or second-semester Introduction to Programming courses. An apprenticeship shows you what programming is about when you enter the real world. The purpose of an apprenticeship is to get the experience necessary to use what you’ve learned to approach problems in many different ways, and to gain as many different experiences as possible.</p>
<p class="indent"><span epub:type="pagebreak" id="page_14"/>An apprentice studies under someone who has mastered advanced programming techniques. This person can be either a <em>software journeyman</em> (see the next section) or a <em>software craftsman</em>. The “master” assigns tasks to the apprentice, demonstrates how to accomplish the task, and reviews the apprentice’s work, making appropriate mid-course corrections to obtain high-quality work. Most important, the apprentice also reviews their master’s work. This can take various forms, including testing, structured walk-throughs, and debugging. The important factor is that the apprentice learns how the master’s code operates.<sup><a href="ch19_footnote.xhtml#ch01fn7" id="ch01fn7a">7</a></sup> In doing so, the apprentice picks up programming techniques they would never master on their own.</p>
<p class="indent">If an apprentice is lucky, they’ll have the opportunity to study under several masters and learn solid techniques from all of them. With each project completed under the tutelage of an advanced programmer, the apprentice nears the end of their apprenticeship and moves on to the next stage in the software craftsman’s route: the software journeyman.</p>
<p class="indent">In one sense, an apprenticeship never ends. You should always be on the lookout for new techniques and new skills. For example, consider all the software engineers who grew up on structured programming and had to learn object-oriented programming. However, at some point, you reach the stage where you’re using your existing skills more often than developing new ones. At that point, you start imparting your wisdom to others rather than learning from others. It’s then that the “masters” you’re working with feel you’re ready to tackle projects on your own without assistance or supervision. That’s when you become a software journeyman.</p>
<h4 class="h4" id="lev-1.4.3"><strong><em>1.4.3 The Software Journeyman</em></strong></h4>
<p class="noindent">Software journeymen handle the bulk of software development. As the name suggests, they typically move from project to project, applying their skills to solve application problems. Even though a software developer’s education never ends, a software journeyman is more focused on application development than on learning how to develop applications.</p>
<p class="indent">Another important task that software journeymen take on is training new software apprentices. They review the work of apprentices on their project and share programming techniques and knowledge with them.</p>
<p class="indent">A software journeyman constantly looks for new tools and techniques that can improve the software development process. By adopting new (but proven) techniques early on, they stay ahead of the learning curve and keep up with current trends to avoid falling behind. Utilizing industry best practices to create efficient and cost-effective solutions for customers is the hallmark of this stage of craftsmanship. Software journeymen are productive, knowledgeable, and exactly the type of software developer most project managers hope to find when assembling a software team.</p>
<h4 class="h4" id="lev-1.4.4"><span epub:type="pagebreak" id="page_15"/><strong><em>1.4.4 The Master Craftsman</em></strong></h4>
<p class="noindent">The traditional way to become a master craftsman is to create a <em>masterpiece</em>, a work that sets you apart from your peers. Some (high-end) examples of software masterpieces include VisiCalc,<sup><a href="ch19_footnote.xhtml#ch01fn8" id="ch01fn8a">8</a></sup> the Linux operating system, and the vi and emacs text editors. These products were initially the brainchild and creation of a single person, even though they went on to involve dozens or hundreds of different programmers. A masterpiece doesn’t have to become famous, like Linux or some GNU tool. However, your immediate peers must recognize your masterpiece as a useful and creative solution to a problem. A masterpiece doesn’t have to be a stand-alone original piece of code, either. Writing a complex device driver for an operating system, or extending some other program in several useful ways, could very well qualify as a masterpiece. The purpose of the masterpiece is to create an item in your portfolio that tells the world: “I’m capable of producing serious software—take me seriously!” A masterpiece work lets others know that they should seriously consider your opinions and trust what you have to say.</p>
<p class="indent">Generally, the domain of the master craftsman is to determine what current best practices are and invent new ones. Best practices describe the best <em>known</em> way, not necessarily the absolute best way, to accomplish a task. The master craftsman investigates whether there’s a better approach for designing applications, recognizes the utility of a new technique or methodology as it applies to a wide spectrum of applications, and verifies that a practice is best and communicates that information to others.</p>
<h4 class="h4" id="lev-1.4.5"><strong><em>1.4.5 Where Software Craftsmanship Fails</em></strong></h4>
<p class="noindent">Steve McConnell, in his classic software engineering book <em>Code Complete</em>, claims that experience is one of those characteristics that doesn’t matter as much as people think: “If a programmer hasn’t learned C after a year or two, the next three years won’t make much difference.” He then asks, “If you work for 10 years, do you get 10 years of experience or do you get 1 year of experience 10 times?” McConnell even suggests that book learning might be more important than programming experience. He claims that the computer science field changes so fast that someone with 10 years of programming experience has missed out on all the great research to which new programmers have been exposed during that decade.</p>
<h3 class="h3" id="lev-1.5"><strong>1.5 The Path to Writing Great Code</strong></h3>
<p class="noindent">Writing great code doesn’t happen because you follow a list of rules. You must make a personal decision to put in the effort to ensure the code you’re writing is truly great. Violating well-understood software engineering principles is a good way to ensure that your code is not great, but rigidly following such rules doesn’t guarantee greatness, either. A well-experienced and meticulous developer, or software craftsman, can navigate both <span epub:type="pagebreak" id="page_16"/>approaches: following established practices when it’s required, but being unafraid to try a different technique or strategy when the need arises.</p>
<p class="indent">Unfortunately, a book can only teach you the rules and methodologies. Creativity and wisdom are qualities you need to develop on your own. This book teaches you the rules and suggests when you might consider breaking them. However, it’s still up to you to decide whether to do so.</p>
<h3 class="h3" id="lev-1.6"><strong>1.6 For More Information</strong></h3>
<p class="ref">Hunt, Andrew, and David Thomas. <em>The Pragmatic Programmer</em>. Upper Saddle River, NJ: Addison-Wesley Professional, 1999.</p>
<p class="ref">Kernighan, Brian, and Rob Pike. <em>The Practice of Programming</em>. Upper Saddle River, NJ: Addison-Wesley Professional, 1999.</p>
<p class="ref">McBreen, Pete. <em>Software Craftsmanship: The New Imperative</em>. Upper Saddle River, NJ: Addison-Wesley Professional, 2001.</p>
<p class="ref">McConnell, Steve. <em>Code Complete</em>. 2nd ed. Redmond, WA: Microsoft Press, 2004.</p>
<p class="ref">———. <em>Rapid Development: Taming Wild Software Schedules</em>. Redmond, WA: Microsoft Press, 1996.</p>
<p class="ref">Pressman, Robert S. <em>Software Engineering, A Practitioner’s Approach</em>. New York: McGraw-Hill, 2010.</p>
</div>



  </body></html>