<html><head></head><body>
<section epub:type="introduction">&#13;
<blockquote class="Epigraph pagebreak" epub:type="epigraph" style="text-align: center;">&#13;
<p class="Epigraph"><span epub:type="pagebreak" title="xiv" id="Page_xiv"/>We build our computer systems the way we build our cities: over time, without a plan, on top of ruins.</p>&#13;
<p class="Epigraph"><span class="Caps normal">—Ellen Ullman</span></p>&#13;
</blockquote>&#13;
<header><h1 class="FrontmatterTitleIntroduction" id="fm-501188f05-0001"><span epub:type="pagebreak" title="xv" id="Page_xv"/>Introduction</h1>&#13;
</header>&#13;
<p class="ChapterIntro"><span class="DropCap">I</span>n 1975, renowned physicist David L. Goodstein published his book <em>States of Matter</em> with the following introduction:</p>&#13;
<blockquote>&#13;
<p class="Blockquote"><em>Ludwig Boltzmann, who spent much of his life studying statistical mechanics, died in 1906, by his own hand. Paul Ehrenfest, carrying on the work, died similarly in 1933. Now it is our turn to study statistical mechanics.</em></p>&#13;
</blockquote>&#13;
<p>This is a book about how to run legacy modernizations, a topic many software engineers regard as slow-moving career suicide, if not the prologue to a literal one. This book is for people who work at large organizations with aging technology, but it is also a book for people who work at small startups still building their technology. Restoring legacy systems to operational excellence is ultimately about resuscitating an iterative development process so that the systems are being maintained and evolving as time goes on.</p>&#13;
<p>Most of the advice in this book can just as easily be used for building new technology, but legacy systems hold a special place in my heart. I spent the first 10 years of my professional career traveling around the <span epub:type="pagebreak" title="xvi" id="Page_xvi"/>world, looking for work in applied anthropology while programming computers for fun on the side. I knew how to program because my father was a computer programmer, and I grew up in a house filled with computers at a time when that was rare.</p>&#13;
<p>I never became the swashbuckling international aid worker I imagined myself to be, but I ended up finding my applied anthropology work in legacy modernizations. Like pottery sherds, old computer programs are artifacts of human thought. There’s so much you can tell about an organization’s past by looking at its code.</p>&#13;
<p>To understand legacy systems, you have to be able to define how the original requirements were determined. You have to excavate an entire thought process and figure out what the trade-offs look like now that the options are different.</p>&#13;
<p>Simply being old is not enough to make something legacy. The subtext behind the phrase <em>legacy technology</em> is that it’s also bad, barely functioning maybe, but legacy technology exists only if it is successful. These old programs are perhaps less efficient than they were before, but technology that isn’t used doesn’t survive decades.</p>&#13;
<p>We are past the point where all technical conversations and knowledge sharing can be about building new things. We have too many old things. People from my father’s generation wrote a lot of programs, and every year they are shocked by how much of their work survives, still running in a production system somewhere. My generation has programmed exponentially more, infecting every aspect of life with a computer chip and some runtime instructions. We will be similarly shocked when those systems are still in place 30, 40, or 50 years from now.</p>&#13;
<p>Because we don’t talk about modernizing old tech, organizations fall into the same traps over and over again. Failure is predictable because so many software engineers think the conversations about modernizing legacy technology are not relevant to their careers. Some of them are honestly surprised to find out that COBOL still runs much of the financial sector, that the majority of the web is still written in PHP, or that people <span epub:type="pagebreak" title="xvii" id="Page_xvii"/>are still looking to hire software engineers with ActionScript, Flash, and Visual Basic skills.</p>&#13;
<p>Failure can be so predictable that after a year or two of doing this work, I found that with a little basic information about the technology deployed, I could predict a series of problems the organization was facing and how its solutions had failed. Occasionally, I would perform this parlor trick for the amusement of other engineers and the advancement of my career, including once during a job interview at the <em>New York Times</em>.</p>&#13;
<p>When I left government to go back to the private sector, I discovered that the same techniques that had worked for old systems also worked really well with relatively new systems. I moved to a six-year-old company and did legacy modernization work. Then I moved to a six-month-old company and still did legacy modernization work. At one point, exasperated, I complained to my boss, “Why am I running a legacy modernization on a three-month-old system?” To which he retorted, “Serves you right for not showing up three months ago.”</p>&#13;
<p>That being said, there is little downside to maintaining all systems as if they are legacy systems. It is easy to build things, but it is difficult to rethink them once they are in place. Legacy modernizations are hard not because they are technically hard—the problems and the solutions are usually well understood—it’s the people side of the modernization effort that is hard. Getting the time and resources to actually implement the change, building an appetite for change to happen and keeping that momentum, managing the intra-organizational communication necessary to move a system that any number of other systems connect to or rely upon—those things are hard.</p>&#13;
<p>And yet, as an industry, we do not talk about these challenges. We assume the sun, moon, stars, and the board of directors will all magically reconfigure themselves around the right technical answer simply because it’s the right technical answer. We are horrified to discover that most people do not actually care how healthy a piece of technology is as long as it performs the function they need it to with a reasonable degree <span epub:type="pagebreak" title="xviii" id="Page_xviii"/>of accuracy in a timeframe that doesn’t exhaust their patience. In technology, “good enough” reigns supreme.</p>&#13;
<p>In trying to explain how to approach a legacy modernization, I first go back and explore how technology changes over time. Chapters 1 and 2 both explore the mechanics of computing trends and best practices: How did we settle on the technology that is legacy today, and what can we learn from that process to guide our modernization plans?</p>&#13;
<p>In Chapter 3, I discuss the three broad problems that make organizations feel like they need to modernize: technical debt, performance issues, and system stability. I give an example of each type of problem on a real (though anonymous) system and how the plan to modernize it might come together.</p>&#13;
<p> Chapter 4 discusses why legacy modernization is so hard and fails so often. I address the great myth of cross-platform compatibility and the role of abstraction in manipulating what we see as easy or hard.</p>&#13;
<p>Chapter 5 talks about the most critical feature of any legacy modernization: momentum. How do you get it, and how do you keep it? I outline a whole series of conditions—some of them momentum killers, some of them momentum growers.</p>&#13;
<p>Chapter 6 deals with coming into a modernization project that has already started and how to fix the most common problems that might be stalling it.</p>&#13;
<p>Chapter 7 provides as thorough of an overview as possible into design thinking and how we can use design to direct and ultimately improve the outcomes of technical conversations.</p>&#13;
<p>Chapter 8 is all about breaking stuff and the value of not being afraid of failure. I explore how chaos testing complements legacy modernization and how to work with an organization where the suggestion that you should break things on purpose might seem like a bridge too far.</p>&#13;
<p>Chapter 9 discusses why success is not as obvious or self-evident as you might assume and how to define criteria to determine when a project is finished.</p>&#13;
<p><span epub:type="pagebreak" title="xix" id="Page_xix"/>Finally, Chapter 10 lays out strategies to keep you from ever having to do a modernization on the same system again. How do you know if your software is maintainable? What can you do if it is not?</p>&#13;
<p>The language in this book is deliberate. I use the term <em>organization</em> instead of <em>company</em> or <em>business</em>. The vast majority of my work experience in this space is with governments and nonprofits, but legacy is everywhere. The organizations that need to build and maintain good technology are not exclusively in the private sector. The US federal government is one of the single largest producers of technology, for example. The conversation about legacy systems crosses from businesses to governments to hospitals to nonprofits. For that reason, when I mention the “business” side of the organization, I mean that in terms of the mission-focused components that engineering is building technology to support. An organization doesn’t have to make a profit to have a business side.</p>&#13;
<p>Throughout the book, I use the word <em>system</em> to refer to a grouping of technologies that work together for a common set of tasks. System is a troublesome word in technology conversations as it seems you can never find a group of engineers who agree where its boundaries are. For my purposes, though, that vagueness is beneficial. It allows me to talk about legacy modernizations in general.</p>&#13;
<p>To describe parts of a system, I frequently use the words <em>component</em> or occasionally <em>service</em>. While many of the techniques in this book are applicable to any type of technology, examples and discussions are heavily slanted toward software engineering and web-based development in particular. I couldn’t write a book about legacy systems without mainframes, data centers, and old operating systems, but most of my experience is with upgrading these systems to more internet-friendly options, and this book reflects that. I look forward to technologists with other backgrounds supplementing the material in this book with essays on whether my advice also applies to them.</p>&#13;
<p>My sincere hope is that as you read this, you find inspiration for your own technical projects, regardless of the age of your technology. I’ve tried <span epub:type="pagebreak" title="xx" id="Page_xx"/>my best to pack as many resources, exercises, and frameworks into this book as possible, to be as detailed as possible, and to ground as many assertions with real-world stories as I can.</p>&#13;
<p>We are reaching a tipping point with legacy systems. The generation that built the oldest of them is gradually dying off, and we are piling more and more layers of society on top of these old, largely undocumented and unmaintained computer programs. While I don’t believe society is going to crumble at our feet over it, there’s a lot of good, interesting work for people willing to jump in.</p>&#13;
</section>&#13;
</body></html>