- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MODULES AND PACKAGES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Information about the package is as important as the package itself.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*—*Frederick W. Smith, founder of FedEx'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, I mentioned that Julia programs are organized around
    collections of functions. The functions are the verbs of your program, meaning
    they describe what it does. You could spend your whole Julia programming life
    working in the REPL or in Pluto while saving programs in files using nothing more
    than function, variable, and data type definitions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes time to develop projects that build on your previous work
    systematically, or to allow other people to use your code in their projects, you
    will want to take advantage of the structures Julia provides to organize and share
    your programs. Even if you never reuse or distribute your own code, you will use
    code from the Julia standard library, from other official Julia packages, and
    perhaps from other researchers. In any case, familiarity with Julia’s module and
    package system is essential.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia programmers make liberal use of modules both in the REPL and in program
    files, and borrowing existing facilities for plotting, solving equations, serving
    websites, and countless other activities is routine. *Creating* modules, however,
    is of little use in the REPL. The modules you create will live in files, ready
    to be used as needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Namespaces***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *namespace* is a grouping for names that distinguishes them from identical
    names existing in other groups. We need namespaces because functions and variables
    may be defined in different places but happen to have identical names, and we
    need a way to make it clear which object we are referring to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define an object in the REPL we can refer to it later with its name.
    For example, after an assignment such as `a = 1`, the variable `a` will return
    `1`. We say that `a` is defined in the *global namespace*. The terminology varies:
    sometimes it’s *top-level namespace* and sometimes *main namespace*. In any case,
    the *current namespace* is the one in which we’re working.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: When we need to refer to objects defined elsewhere, we have two options. We
    can call them by their unadorned names, as if they had been defined in the current
    namespace, or we can refer to them with a name such as `SomeModule.a`. In the
    latter case, we say that `a` is in the `SomeModule` namespace, and we have used
    a *qualified name* for it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The two names `SomeModule.a` and `a` can refer to different objects—perhaps
    even to different types of objects. The identifier `a` might be a variable that
    we’ve defined in the REPL, and `SomeModule.a` might be a function defined in the
    `SomeModule` module. In the next section, we’ll learn how objects from other modules
    sometimes wind up in our current namespace and when we need to use qualified names
    to refer to them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Installed Modules***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Julia installation comes with many modules ready for use. The resources in
    two particular modules, `Base` and `Core`, are always automatically available,
    which is why we can invoke the functions that we used in the previous chapter,
    such as `abs()`, without loading anything explicitly. Most of these essential
    functions are in the `Base` module. `Base` also supplies such basics as the `+`
    operator, which is also a function under the hood. The `Core` module exists at
    an even deeper level and contains such foundation stones as the `Int64` data type.
    Although you can’t do much without `Base`, you can arrange for it to not be loaded.
    The small `Core` module is necessary for Julia to work, however, so it’s not optional.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Julia安装时自带许多模块可供使用。特别是`Base`和`Core`这两个模块中的资源总是自动可用的，这也是为什么我们可以直接调用前一章中使用的函数，如`abs()`，而无需显式加载任何内容。这些基本函数大多位于`Base`模块中。`Base`还提供了一些基础功能，如`+`运算符，实际上也是一个函数。`Core`模块存在于更深层次，包含了一些基础构件，如`Int64`数据类型。虽然没有`Base`你无法做太多事情，但你可以安排不加载它。然而，`Core`模块对Julia的运行是必需的，因此不可省略。
- en: The *standard library* is a collection of modules that’s always installed with
    Julia but that you need to load explicitly to be able to use. The modules in the
    standard library provide functionality that is commonly needed across a variety
    of computations, but that is less fundamental than, for example, the arithmetic
    operators. You will never need everything in the standard library in any particular
    program, but a typical program will make use of several of its modules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准库*是一个总是与Julia一起安装的模块集合，但你需要显式加载它们才能使用。标准库中的模块提供了在各种计算中常用的功能，但这些功能的基础性不如算术运算符等。你在任何特定的程序中都不需要标准库中的所有模块，但一个典型的程序会使用其中几个模块。'
- en: You can load the resources in a module with either the `using` or `import` statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`using`或`import`语句加载模块中的资源。
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most modules have uppercase initials and use “camel case” for their names,
    such as* LinearAlgebra *from the standard library. Although you’re free to ignore
    such naming conventions (including the use of ! explained in [“Functions That
    Mutate Their Arguments](ch02.xhtml#ch02lev1sec17)” on [page 56](ch02.xhtml#ch02lev1sec17))
    in your own projects, following them will make your code easier to read for other
    Julia programmers.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数模块的名称首字母为大写，并采用“驼峰命名法”，例如* LinearAlgebra *模块来自标准库。虽然你可以在自己的项目中忽略这种命名约定（包括在[《改变参数的函数》](ch02.xhtml#ch02lev1sec17)中解释的使用!符号，[第56页](ch02.xhtml#ch02lev1sec17)），但遵循这些约定会让你的代码更容易被其他Julia程序员阅读。*'
- en: The `using` statement provides access to everything in the module. It brings
    all the names that the module creator has marked for export into the current namespace.
    So, for example, after executing `using Plots`, we can use the `plot()` function
    directly, as in `plot(x -> x^2)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句提供对模块中所有内容的访问。它将模块创建者标记为导出的所有名称引入当前命名空间。因此，例如，在执行`using Plots`之后，我们可以直接使用`plot()`函数，如`plot(x
    -> x^2)`。'
- en: We can use any name that we know of, however, even if it’s not exported. Julia
    has no secrets. Prefix the unexported name with the name of the module and a dot.
    For example, `Plots.surface(x, y, f)` will work regardless of whether `surface`
    is exported. In this case, we are invoking `surface` in the `Plots` namespace.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用任何已知的名称，即使它没有被导出。Julia没有秘密。只需将未导出的名称与模块名和点符号组合。例如，`Plots.surface(x,
    y, f)`无论`surface`是否被导出都能正常工作。在这种情况下，我们是在调用`Plots`命名空间中的`surface`。
- en: The other way to use resources from other modules involves the `import` statement.
    The only difference between `import` and `using` has to do with how we use names.
    If we execute `import Plots`, `Plots.surface(x, y, f)` will work, but just using
    `surface(x, y, f)` will not. The `import` statement provides access to everything
    in the module, just as `using` does, but *not in the current namespace*. You must
    use the module’s namespace.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用其他模块资源的方式是`import`语句。`import`和`using`的唯一区别在于我们如何使用名称。如果执行`import Plots`，则`Plots.surface(x,
    y, f)`将正常工作，但直接使用`surface(x, y, f)`则不行。`import`语句提供对模块中所有内容的访问，和`using`一样，但*不会在当前命名空间中提供*。你必须使用模块的命名空间。
- en: 'You can use either statement with a list of modules separated by commas: `using
    *Module1, Module2, Module3*`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用带有逗号分隔的模块列表的语句：`using *Module1, Module2, Module3*`。
- en: 'To show the difference between the `using` and `import` statements, we’ll use
    two modules from the standard library: the `LinearAlgebra` module, which contains
    functions for solving sets of linear equations, inverting matrices, and other
    linear algebra operations, and `Random`, which provides random number functions.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`using`和`import`语句的区别，我们将使用两个来自标准库的模块：`LinearAlgebra`模块，它包含用于解线性方程组、求逆矩阵和其他线性代数操作的函数，以及`Random`模块，它提供随机数函数。
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) uses some functions from the standard library.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch3lis1)使用了一些来自标准库的函数。'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Two ways to import a module*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：导入模块的两种方式*'
- en: The first two lines make the resources from the two standard library modules
    available in the rest of the program. The difference between the `using` and `import`
    statements is in how we refer to those resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行使得来自两个标准库模块的资源在程序的其他部分可用。`using`和`import`语句之间的区别在于我们如何引用这些资源。
- en: The `using LinearAlgebra` statement allows us to use all of the *exported names*
    from this module directly. The exported names are those that appear in an `export`
    statement in the module. We can use the `dot()` function ➋, which computes the
    dot product of two vectors, directly, because it’s exported by `LinearAlgebra`,
    and the `using LinearAlgebra` statement pulled it into the current namespace.
    (The dot product of [*a*, *b*] and [*c*, *d*] is *ac*+*bd*.) We can refer to the
    function using `LinearAlgebra.dot()` as well; the two names refer to the same
    object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`using LinearAlgebra`语句允许我们直接使用该模块中所有的*导出名称*。导出名称是那些出现在模块的`export`语句中的名称。我们可以直接使用`dot()`函数
    ➋，它计算两个向量的点积，因为它是由`LinearAlgebra`导出的，而`using LinearAlgebra`语句将其引入当前命名空间。（[ *a*,
    *b* ]和[ *c*, *d* ]的点积是*ac*+*bd*。）我们也可以通过`LinearAlgebra.dot()`来引用这个函数；这两个名称指向相同的对象。'
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes* import *and* using *statements incur significant delays. Julia
    is precompiling some functions in the module to make their use more efficient.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时*，`import`和`using`语句会引起显著的延迟。Julia正在预编译模块中的一些函数，以提高它们的使用效率。'
- en: 'The other way to use resources from other modules involves the `import` statement,
    as we used in the second line: `import Random`. The only difference between `import`
    and `using` has to do with the use of names. Since we *imported* `Random`, to
    use its functions we must prefix them with the name of the module ➌.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用其他模块资源的方法涉及`import`语句，正如我们在第二行中使用的那样：`import Random`。`import`和`using`之间的唯一区别在于名称的使用。由于我们*导入了*`Random`，为了使用它的函数，我们必须在函数名前加上模块的名称
    ➌。
- en: If we pull in a module with `using` and already have some of its names defined
    in our program, Julia will print a warning. The next section describes other ways
    to handle this problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`using`引入一个模块，并且程序中已经定义了该模块的一些名称，Julia会打印一个警告。下一节将描述如何处理这个问题的其他方法。
- en: We use the `import` statement when we have names that happen to be the same
    within more than one module or that are identical in an imported module and in
    our program. The use of module namespaces will remove the ambiguity. For example,
    our program has our own `randexp()` function, which is different from the one
    supplied by the `Random` module. It returns `17`, which I chose at random when
    I wrote the function, hence the name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在多个模块中存在相同名称，或在导入的模块和程序中存在相同名称时，我们使用`import`语句。模块命名空间的使用将消除歧义。例如，我们的程序有我们自己的`randexp()`函数，它与`Random`模块中的函数不同。它返回`17`，这是我在编写函数时随机选择的，因此命名为`randexp`。
- en: After the definition of `randexp()` ➊, we define two vectors, `a` and `b`. We
    calculate their dot product using the `dot()` function, which is exported by `LinearAlgebra`,
    and pipe its output to `println()` so we can see it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`randexp()` ➊之后，我们定义了两个向量`a`和`b`。我们使用由`LinearAlgebra`导出的`dot()`函数计算它们的点积，并将其输出传递给`println()`以便我们查看结果。
- en: The next line calls the `randexp()` function from `Random` and prints the result.
    This function returns a number randomly selected from the exponential distribution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用了`Random`中的`randexp()`函数并打印结果。这个函数从指数分布中随机选择一个数字。
- en: 'Finally we call `randexp()` ➍ from the program’s global namespace and print
    the result: `17`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从程序的全局命名空间调用`randexp()` ➍并打印结果：`17`。
- en: 'Here is the output from one run of the program:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序运行的一次输出：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run it, the second number will be different because it’s randomly generated
    (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '***Selective Importing and Renaming***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve seen two Julia statements, each of which allows a program to refer
    to objects defined elsewhere. Both statements give access to everything in the
    target module, but differ in how we refer to the module’s objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We can supplement either command with specifications that provide more control.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `as` keyword lets us pick a name to use for the module within our program.
    If we change the second line in [Listing 3-1](ch03.xhtml#ch3lis1) to `import Random
    as Rnd`, we need to change the line that uses it to `Rnd.randexp() |> println`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We can append a colon to the module name to limit the import to only specified
    objects. Optionally, we can use the `as` keyword to rename those objects to names
    of our choosing. These methods can serve to avoid conflicts with existing names.
    Here is [Listing 3-1](ch03.xhtml#ch3lis1) with some modifications:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program has the same results as the previous version, but the `import`
    statement ➊ imports only the `randexp()` function from `Random` and renames it
    as `rrexp()`. When we call it ➋, we have to use its alias because its original
    name, `randexp()`, is unknown in its current environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Modules***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Julia, there is no relationship between modules and files or between filenames
    and module names. A file can contain any number of modules, and a module may be
    split among many files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a module in a program file using the `module` keyword. This begins
    a structure that resembles a block and is terminated with the `end` keyword, but
    is different from the blocks described in [Chapter 2](ch02.xhtml). Because it’s
    common for entire files to comprise the contents of a module, the conventional
    style does not indent module bodies. Such a practice would lead to uselessly indenting
    most of the file. Another distinction concerns scope: variables defined within
    a module, but outside any of the blocks that define local scopes, are global to
    the module. Each module has its own global scope, so a file with more than one
    module has more than one such scope.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s begin with a simple case: [Listing 3-2](ch03.xhtml#ch3lis2)
    is a small program containing two modules, with everything contained within a
    single file.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-2: A program containing two modules*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This program defines two modules, `M1` and `M2`. Each module defines one function,
    which it lists in an `export` statement. Usually `export` lines go near the top
    of the module, but they can appear anywhere. Running the program prints `100`
    twice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` statement ➊ brings the exported names of the two modules into the
    global namespace of the file. The dots in front of the module names mean that
    we are referring to modules defined *within the current module*. But it doesn’t
    appear as if we’re in a “current module”: the statement is simply at the top level
    of the file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We’re always in a module in Julia. The top-level module is automatically called
    `Main` if we don’t name it ourselves, so `M1` and `M2` are modules within the
    `Main` module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If we had used `import` rather than `using`, we would have been obliged to mention
    the module namespaces when invoking their functions. Although we need to use the
    dot when importing to indicate *where* the module is, its names are still given
    in the `module` statements. For example, the `plusone()` function is `M1.plusone()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Dots in module import statements have a significance similar to their use in
    directory names in Unix-like operating systems. Single dots refer to the current
    “directory,” or module, and a double dot goes up one level to the enclosing module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch3lis3) shows an example.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-3: Relative module imports*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve moved the definition of module `M2` inside `M1` ➊. Within `M2` we import
    `M1` ➋, which is now a *sibling module*: the double dot tells Julia to go up one
    level before looking for `M1`. After this `using` statement, `plusone()` is available
    within `M2`, so we can call it directly within the `println()` statement.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Back in the top level, which is the `Main` module, we again want to import every
    exported name from `M1` and `M2` into the global namespace, but now we need to
    specify that `M2` is within `M1` ➌.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This program prints `201` followed by the same output as the previous example
    in [Listing 3-2](ch03.xhtml#ch3lis2).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: If we simply want to insert the contents of a file into the current file, we
    use the `include()` statement with a string argument giving the file’s pathname.
    This is equivalent to pasting the file’s contents at the location of the `include()`
    statement. It doesn’t use any of the module namespacing machinery, pulling objects
    in the included file into the module’s namespace. Using file inclusion, we can
    split large modules among different files, helping to keep our code organized.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '***Documenting Functions with Docstrings***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous chapter described how to use the REPL’s help system to get information
    about functions. We can document our own functions so that the help system can
    provide nicely formatted information about them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a string literal immediately before the beginning of any function definition
    to document it, creating what’s called a *docstring*. The help system, as well
    as any other Julia documentation system, will associate this string with the function,
    and format and display it when the user asks for help. Here is a somewhat silly
    example, where I added some help text to [Listing 3-3](ch03.xhtml#ch3lis3) to
    document the `plusone()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example I use the triple-quoted string syntax explained on [page 45](ch02.xhtml#page_45)
    to conveniently embed newlines and other characters without needing to escape
    them. Most help strings are written this way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**MARKDOWN IN DOCSTRINGS**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation system understands a version of Markdown syntax and will
    format the output appropriately. Markdown is a simplified system of text markup
    where you can specify italics, boldface, and code using underscore, double underscore,
    and backtick delimiters, with asterisks accepted as alternatives to underscores.
    A blank line starts a new paragraph, and indenting text by four spaces sets it
    as code. Lines beginning with hash marks are not comments, as in Julia code, but
    become headings: `# Heading`, `##` `Subheading`, and so on.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The example demonstrates some of the documentation conventions the Julia community
    uses. Begin the help text with the function signature, followed by an imperative
    statement of what the function does. After that can come more explanation and
    examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](ch03.xhtml#ch3fig1) is a screenshot of a REPL session where I
    included the *modutst.jl* file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch03fig01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Using the documentation system*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In the REPL, the `println()` statements are run and produce the output shown
    previously. I pressed `?` to enter help mode and typed the name of the function.
    After showing the results of a fuzzy search on the name, the REPL renders the
    docstring of the most likely choice. The terminal REPL renders code using a contrasting
    color and italics with an underline. Other environments may use different typography.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: For more details about Markdown formatting, see “Further Reading” on [page 81](ch03.xhtml#fur3).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to reference modules defined in the current file using dots
    and extend the current file using `include()`. Before that, we were loading external
    modules with the same `using` and `import` statements, but with no dots in front
    of the module names. Somehow in those cases, Julia knew where to find the files
    containing the module definitions, and that is the subject of the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**The Package System**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most convenient way to interact with Julia’s package system is with the
    REPL’s package mode. Press `]` to enter and BACKSPACE to exit this mode.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Enter the package mode and have another look at the prompt. It looks something
    like `(@v1.8) pkg>`, where `v1.8` shows the currently installed Julia version.
    The part within the parentheses informs us of our current *environment*. We are
    always in some environment in the REPL. The environment is the project to which
    the package mode applies its commands.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: When we start the REPL we’re in the default project. Everything we do in the
    package manager applies to that environment, unless we change it with the `activate`
    command.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Enter activate. to change the environment to the current directory, or activate
    path to change it to a specified path. A simple activate changes to the default
    environment for the version of Julia in use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Add and Remove Packages***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important package command is `add`. To use it, enter add packageName
    from within the REPL’s package mode.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` command does two things: it downloads and precompiles the latest
    compatible version of the requested package, if it’s not already installed, and
    it records the package as a dependency of the current environment. The second
    step ensures that the set of package versions used in the project can always be
    reproduced, either by its author on a different computer or by a colleague.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: We will have to `add` any packages that are not in the standard library. This
    includes the vast majority of packages in the Julia ecosystem, such as `Plots`,
    for making scientific graphics, or `BenchmarkTools`, for timing and profiling
    programs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: If any package previously installed with `add` is no longer needed, we can remove
    it with the `rm` PackageName command, also from within package mode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The `rm` package mode command deletes a package from the list of direct dependencies
    of your project, but it does not immediately erase any files from the disk. An
    automatic garbage collection process runs periodically, reclaiming disk space
    by purging packages that no other installed package depends on and that haven’t
    been used for over 30 days. To reclaim disk space right away, call the garbage
    collector manually. Detailed instructions are in the package system manual (see
    “Further Reading” on [page 81](ch03.xhtml#fur3)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '***The Load Path***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The current environment influences where `using` and `import` look for packages
    and defines the default location for package commands. When executing statements
    like `using Plots` or `import Random` that mention package names without dots,
    Julia looks for the packages in a series of places derived from a vector of strings
    named `LOAD_PATH`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ask the REPL to show us the default initial value of `LOAD_PATH`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The contents of `LOAD_PATH` are clearly not filepaths. They’re a notation that
    the package manager translates into the appropriate paths for the system and installation.
    To see the results of the translation and the current values of the paths, we
    can call the `load_path()` function from `Base`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve already mentioned that `Base` contains the functions we almost always
    need, but they’re not all exported. Ones that are used infrequently, such as `load_path()`,
    need to be accessed in the `Base` namespace.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: My current load path contains two items. The first is a directory that Julia
    set up when I installed it. It corresponds to my default environment. When I execute
    a command like `add Plots` in the REPL, if I haven’t switched environments with
    the `activate` command, the package manager adds the current version of the `Plots`
    package as a *dependency* in the default *project*. It records the fact that this
    project depends on a particular version of `Plots` being available, and `using
    Plots` will import the functions from that version. This path is the translation
    of the second element in `LOAD_PATH`, `"@v#.#"`. The notation simply means “the
    default environment”; notice how its structure resembles the prompt in package
    mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我当前的加载路径包含两个项。第一个是Julia在我安装时设置的一个目录，它对应于我的默认环境。当我在REPL中执行像`add Plots`这样的命令时，如果我没有使用`activate`命令切换环境，包管理器会将`Plots`包的当前版本作为*依赖项*添加到默认的*项目*中。它记录了该项目依赖于某个特定版本的`Plots`可用，并且`using
    Plots`将导入该版本的函数。这个路径是`LOAD_PATH`中第二个元素`"@v#.#"`的翻译。这个符号表示“默认环境”；注意它的结构类似于包模式中的提示符。
- en: 'The package manager records these direct dependencies, the ones specified with
    `add` commands, in the *Project.toml* file. This file contains lines such as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器将这些直接依赖项，即通过`add`命令指定的依赖项，记录在*Project.toml*文件中。这个文件包含如下内容：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line shows that the particular version of the `Plots` package, made specific
    with a unique identifier called a *UUID*, is a dependency of the project that
    contains this file—in this case, the default project associated with my installation
    of v1.8 of Julia.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行显示了特定版本的`Plots`包，使用一个名为*UUID*的唯一标识符来指定，它是包含此文件的项目的依赖项——在本例中是与我安装的v1.8版本的Julia相关联的默认项目。
- en: The second path returned by `Base.load_path()` comes from the last element of
    `LOAD_PATH`, which refers to the standard library. As mentioned previously, the
    standard library consists of modules that are part of the Julia installation,
    so they don’t need to be installed with `add`. I left my installation in the download
    folder where my web browser put it, so that’s where its standard library lives.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base.load_path()`返回的第二个路径来自`LOAD_PATH`的最后一个元素，它指向标准库。如前所述，标准库包含的是Julia安装的一部分模块，因此它们不需要通过`add`命令安装。我把我的安装保留在了浏览器下载文件夹中，所以标准库也就位于那里。'
- en: The `LOAD_PATH` has three elements, but we see only two in its current translation
    by `Base.load_path()`. The first element, which is simply `@`, refers to the *current
    environment*. Julia searches for packages in the order in which they appear in
    `LOAD_PATH`, so it searches the current environment first. To change the current
    environment, execute activate path.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_PATH`有三个元素，但在`Base.load_path()`的当前翻译中我们只看到两个。第一个元素，仅仅是`@`，指的是*当前环境*。Julia会按照它们在`LOAD_PATH`中出现的顺序搜索包，因此它首先会搜索当前环境。要更改当前环境，执行`activate
    path`命令。'
- en: 'The current environment has two purposes: it comes first in the load path,
    so imports of packages will load the versions, if any, that have been added as
    dependencies in the environment, and the package system `add` command inserts
    a dependency there.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当前环境有两个用途：它在加载路径中排在最前面，因此包的导入将加载作为环境依赖项添加的版本（如果有的话），而包管理器的`add`命令会在那里插入一个依赖项。
- en: 'An environment is really nothing more than a place in the filesystem with a
    *Project.toml* file and a *Manifest.toml* file. The latter is a list of the entire
    *dependency graph* of the environment: all the packages that need to be loaded
    to satisfy the dependencies of the ones explicitly `add`ed, with their UUIDs,
    the list of dependencies of each of those dependencies, and so on. If we use the
    `activate` command on a path where there is no existing environment and execute
    one or more `add` commands, Julia will create these two files there and fill them
    with the specified package information.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 环境实际上不过是文件系统中的一个地方，里面包含一个*Project.toml*文件和一个*Manifest.toml*文件。后者是环境的*依赖关系图*的列表：所有需要加载的包，以满足显式`add`命令添加的包的依赖关系，包含它们的UUID、每个依赖项的依赖关系列表，依此类推。如果我们在一个没有现有环境的路径上使用`activate`命令，并执行一个或多个`add`命令，Julia将在该路径下创建这两个文件，并用指定的包信息填充它们。
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If we can’t use the filenames* Project.toml *or* Manifest.toml *because they
    conflict with another tool, we can use* JuliaProject.toml *and* JuliaManifest.toml
    *instead. If Julia sees either of those files, it will use it and ignore the one
    without the* Julia *prefix.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们不能使用文件名* Project.toml *或* Manifest.toml *，因为它们与其他工具冲突，我们可以使用*JuliaProject.toml*和*JuliaManifest.toml*代替。如果Julia发现其中一个文件，它将使用该文件，并忽略没有*Julia*前缀的文件。*'
- en: Environments contain no Julia code, only a list of dependencies. They may document
    a set of consistent modules that work for a particular purpose. For example, after
    using Pluto, we’ll discover that Julia has created an environment alongside the
    normal default environment whose *Project.toml* and *Manifest.toml* files contain
    a list of the modules that Pluto needs to work properly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 环境不包含任何Julia代码，仅仅是一个依赖列表。它们可能记录了一组为特定目的而工作的模块。例如，在使用Pluto之后，我们会发现Julia在默认环境旁边创建了一个环境，其中的*Project.toml*和*Manifest.toml*文件包含了Pluto正常工作所需的模块列表。
- en: '***The Nature of a Package***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包的本质***'
- en: I’ve mentioned *package* many times, and have used the term more or less interchangeably
    with *module*, a tradition well established in the Julia documentation. Now let’s
    make the relationship between these concepts precise and explore how packages
    are related to environments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到*包*，并且在Julia文档中，通常将这个术语与*模块*互换使用。现在，让我们精确定义这些概念之间的关系，并探讨包是如何与环境相关的。
- en: A package is a Julia module associated with a *Project.toml* file containing
    a few critical pieces of information. The file containing the module and the *Project.toml*
    file must be laid out in the filesystem as shown in [Figure 3-2](ch03.xhtml#ch3fig2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 包是与*Project.toml*文件相关联的Julia模块，该文件包含一些关键的资讯。包含模块的文件和*Project.toml*文件必须按照[图3-2](ch03.xhtml#ch3fig2)所示的方式在文件系统中排列。
- en: '![Image](../images/ch03fig02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch03fig02.jpg)'
- en: '*Figure 3-2: The filesystem layout of a package*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：包的文件系统布局*'
- en: Alongside the *Project.toml* file is a *src* directory, inside which must be
    the Julia program file, named after the package. Inside this file is the definition
    of a module also named after the package, which in this case is `module` `SomePackage`.
    The structure shown in [Figure 3-2](ch03.xhtml#ch3fig2) is usually placed inside
    a directory also named after the module, *SomePackage* in this case, but that
    is not strictly required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Project.toml*文件一同的是*src*目录，其中必须包含一个以包名命名的Julia程序文件。在这个文件中定义了一个与包同名的模块，在这个例子中是`module`
    `SomePackage`。如[图3-2](ch03.xhtml#ch3fig2)所示的结构通常会放置在一个同样以模块命名的目录中，在这个例子里是*SomePackage*，但这不是强制要求。
- en: For this arrangement to qualify as a package, the *Project.toml* file must provide
    the name of the package, its UUID, its authors, and its version number, in the
    format shown in [Listing 3-4](ch03.xhtml#ch3lis4).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个排列符合包的要求，*Project.toml*文件必须提供包的名称、UUID、作者和版本号，格式如[清单3-4](ch03.xhtml#ch3lis4)所示。
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-4: A package’s* Project.toml *file*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-4：一个包的*Project.toml* *文件*'
- en: The `name` must match the name of the module defined in *src/Some Package.jl*.
    If we have these two files, one within a *src* directory, we have a package. We
    can think of a package as an environment with a module inside and with these four
    pieces of information in *Project.toml*. In practice, as soon as we add dependencies
    to our package with the `add` command executed within the package’s environment,
    we will also have a *Manifest.toml* file alongside the *Project.toml* file that
    contains the complete dependency graph.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`必须与*src/SomePackage.jl*中定义的模块名称匹配。如果我们拥有这两个文件，其中一个位于*src*目录中，那么我们就拥有了一个包。我们可以把包看作是一个包含模块的环境，并且*Project.toml*中包含这四个信息。在实践中，一旦我们通过在包环境中执行`add`命令添加依赖项，我们将会在*Project.toml*文件旁边也看到一个*Manifest.toml*文件，其中包含完整的依赖图。'
- en: We can do all of our Julia development within *.jl* files, possibly using `include()`
    to split the code among several files, and share our work by emailing those files
    to colleagues. Many Julia programmers do no more than this and don’t bother creating
    packages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*.jl*文件中完成所有Julia开发，可能会使用`include()`将代码拆分为多个文件，并通过电子邮件将这些文件发送给同事分享我们的工作。许多Julia程序员仅仅做到这一点，并且不会去创建包。
- en: '***The Benefits of Packages***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包的好处***'
- en: After the exploratory REPL phase of your program development is over, and it’s
    time to save your code in the filesystem so you can use it later, possibly as
    a resource in other programs, I would like to encourage you to take advantage
    of Julia’s package system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: It’s sophisticated, easy to use, and will save you from dependency conflicts
    down the road. Most programs use modules from the standard library and other packages,
    and all are developed with a particular version of Julia itself. As all these
    components evolve, the possibility of conflict arises and, with time, becomes
    inevitable in large programs that use many external resources. The package system
    records the exact versions of all the resources your program uses, so you or anyone
    else can reproduce that environment in the future, and the program will always
    work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of dependency management, a statement like `using Plots` in your
    program imports whatever version of `Plots` is used by the environment in which
    a future user, including yourself, happens to run it. You may have used a feature
    that is later removed from the package, or a future version may introduce a bug
    that breaks your program. Without package management, your program is loading
    unknown code because you’re not being specific about what you mean by `Plots`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Packages often depend on other packages. A future user of your program, encountering
    a conflict with `Plots`, may try to resolve it by using a different version. But
    that version will depend on different versions of other packages, and some of
    those will have their own dependencies. Trying to sort out the dependency graph
    of packages manually to find a workable set quickly becomes a maddening task.
    It’s such a common headache in languages without good package management that
    there’s a name for it: *dependency hell*. Julia’s package system manages the dependency
    graph automatically. You can have various versions of Julia and of any number
    of packages installed on your machine at the same time with no issues. If you
    keep your programs in packages, you can upgrade the versions of modules that it
    imports without changing your actual code, and if the new versions create problems,
    you can downgrade as needed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to share your programs through the official community channels,
    you must use packages. The official repository, from which you get resources when
    you use the `add` command, is based on packages and the Git version control system,
    which I’ll treat in “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Create Packages***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s easy to create packages. First, we navigate to the directory in the filesystem
    where we want the package to be and start the Julia REPL. We can use any directory,
    and we can always move it later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*We don’t have to start a new REPL session just to change locations in the
    filesystem. To continue in an existing REPL session, we can move around the filesystem
    while staying in the REPL using two Julia function versions of the familiar Unix
    commands* pwd *and* cd*. The REPL maintains a notion of the current directory,
    which is where we gave the* julia *command that started the REPL, and it stays
    there unless we change it. The* pwd() *function in the REPL returns a string with
    the full pathname of the current directory. To change it, enter* cd(new_directory)*,
    substituting the name of the desired destination. (The name is a string, as returned
    by* pwd()*, so must be enclosed within quotes.)*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Within the REPL, press `]` to enter package mode, and execute generate Floof.
    That’s all we need to do to create a new package named `Floof`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Back in the system shell, or using the REPL’s shell mode, we’ll find the new
    directory named *Floof*, and within it, the minimal package files shown in [Figure
    3-2](ch03.xhtml#ch3fig2). Floof’s *Project.toml* file will contain lines similar
    to [Listing 3-4](ch03.xhtml#ch3lis4), but with the name *Floof* and a new, unique
    UUID. The `authors` field is populated from our Git configuration, so it’ll be
    empty if we haven’t installed Git (see “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11)).
    The `generate` statement gives our new package a version number of `0.1.0`, which
    we can change.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Descending into the *src* directory, the *Floof.jl* file has the following
    contents:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This defines a tiny module, called `Floof`, with one function, `greet()`, that
    greets the world. Julia sets up a minimal package with everything in place so
    we can begin development of our module. We’ll make one change to this file for
    now: add the statement `export greet` after the first line.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s experiment with this new mini-package. First, we’ll exercise it without
    using the package system:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We put the `Floof` package in the */tmp* directory. The first action in the
    REPL is to `include` the program file directly. This is equivalent to pasting
    it directly into the REPL. The feedback ➊ from the `include()` statement confirms
    that `Floof` is loaded into `Main`, which is always the name for the top-level
    module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use anything in the `Floof` module by mentioning its namespace. It
    has only one ingredient, the `greet()` function, which does what’s expected when
    we call it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We would prefer to call this function without having to type the module name,
    so we need to import its name into the current namespace. We tried to do this
    with the `using` statement, but Julia won’t let us ➋. After remembering that we
    need to prefix local modules with a dot, everything works as expected ➌. (I’ve
    omitted the stacktrace from the error message to save space, as I will do routinely.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Importing a name, whether with `using` or `import`, without a dot prefix tells
    Julia to import a package rather than a local module. This wakes up the package
    system, which consults the `LOAD_PATH` to search for the package. Although `Floof`
    is indeed a package, it’s not on the `LOAD_PATH`, which by default includes the
    activated environment, the default environment, and the standard library, in that
    order. Since we haven’t activated an environment, and the `Floof` package is in
    neither the standard library nor the default environment, Julia can’t find it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’re determined to import `greet()` into the global namespace, we can activate
    the environment that contains the `Floof` module. But first, we should quit and
    restart the REPL. Otherwise, this new attempt to import will generate an error
    complaining about a conflict with an existing name. After starting a fresh REPL,
    we can do this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After activating the `Floof` environment using its pathname, we exit package
    mode. Back in the REPL’s normal mode, after importing `Floof`’s names into the
    global namespace with `using`, a simple `greet()` invokes the function. This works
    only because we edited *Floof.jl* to `export greet`. Then we re-enter package
    mode—observe the prompt, which now indicates the `Floof` environment. The `add
    Random` command adds this package, which contains utilities related to random
    number generation, to the dependency list for `Floof`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add paths manually to `LOAD_PATH`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We do this, again, in a fresh REPL. The package system found `Floof` in the
    last entry in `*LOAD_PATH*`; it will find it regardless of the current environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`Floof`’s *Project.toml* file now contains two additional lines. Here are its
    contents after executing `add Random`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The lines after the `[deps]` label will record every dependency that we manually
    add with an `add` statement.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'A new *Manifest.toml* file has appeared alongside the *Project.toml* file with
    these contents:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Manifest files are for recording the dependency graph of a package or environment.
    For each dependency added manually, the system looks up its dependencies, and
    the dependencies of all of those dependencies, and so on, until it finds every
    dependency. Each of these dependencies is another package; all of them together,
    with all of their dependency relationships, is the dependency graph. As you can
    imagine, Manifest files can get rather large, but this one is not because `Random`
    apparently has only one dependency, a package called `Serialization`, and `Serialization`
    has no dependencies of its own.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our very own package, we should be able to add it as a dependency
    to other packages and environments, just as we did with other packages like `Random`
    and `Plots`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we use the `activate` statement with no argument to go back to the default
    environment. We try to add `Floof` to that environment, but the package manager
    has a complaint about not finding something called a *git repository*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '***Julia and Git***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Git is a *version control system*: a program that helps you keep track of your
    work as it changes over time. Git, in addition, focuses on collaboration, although
    it’s immensely useful to the solo creator as well.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Git is independent of Julia, but since its creation in 2005 by Linus Torvalds,
    the creator of Linux, its superiority over all other version control systems has
    led to a near monopoly in the free software community. Julia is part of this community,
    and Git is an intimate component of the development of the language and its packages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have Git installed and would prefer to continue your study
    of Julia without pausing to install Git and learning how to use it, skip this
    section for now. You can always return later. See “Further Reading” on [page 81](ch03.xhtml#fur3)
    for a link to an excellent learning resource. There are also many articles and
    several books about Git.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: I recommend installing Git and using it in your projects before your personal
    library of code becomes substantial. The small investment in time and effort to
    become familiar with a few basic operations has a huge payback. You’ll be able
    to travel back in time to past states of your programs, keep a log of changes,
    create alternative versions of your programs where you try out ideas, and merge
    the ideas into the main line of development when they’re ready.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If you’re already using one of the older version control systems, you can continue
    to do so. However, if you reach the stage where you would like to contribute your
    Julia programs to the community, you will have to use Git. As we’re about to see,
    Git is also required for adding your own packages as dependencies in your own
    projects and environments on your personal machine, which is something you may
    want to do even if you don’t share your programs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As shown in “How to Create Packages” on [page 73](ch03.xhtml#ch03lev1sec10),
    Julia complained when we tried to `add` my `Floof` package. The package system
    won’t let us add a package until we put it in a Git repository. Dependency management,
    which is the reason for the package system, tracks not simply packages, but versions
    of packages. Julia’s package system works with Git to track these versions. The
    rest of this section assumes Git is installed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: To allow the package system to deal with `Floof`, we have to put it in a Git
    repository and make an initial commit. In the */tmp/Floof* directory, we execute
    git init in the system shell to create the repository, then git add. and git commit
    -m "Begin repo" to begin tracking the contents.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Julia REPL, we try again:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It works this time: the package manager responds that it’s added `Floof` to
    the *Project.toml* and *Manifest.toml* files. The string in square brackets is
    the initial part of the UUID that the package manager has assigned to this version
    of `Floof`. The `#master` string refers to the branch name in Git.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The `status` package command returns a list of all the dependencies added to
    the current environment (not the entire dependency graph), and we see that `Floof`
    is among them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove a dependency—say, `Floof`—we enter rm Floof in package
    mode: note that when removing packages, we use just the package name, not the
    whole path on the filesystem. This does nothing to our files; it simply removes
    `Floof` from the *Project.toml* file. However, it may not remove it from *Manifest.toml*
    because it may be listed there as a dependency of some other package.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve made your program into a Julia package and are tracking it with Git,
    you’ll be prepared to request that it be included in the official repository if
    the day comes when you feel it will be of use to a wider audience. If you complete
    this step, any Julia user anywhere in the world can simply tell their package
    REPL to `add` `*YourPackage*`, and they’ll be able to use and build on your work.
    Sharing and collaboration are embedded in Julia’s DNA. [Chapters 9](ch09.xhtml)
    and [12](ch12.xhtml) demonstrate several interesting examples of how packages
    can be combined to create new capabilities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '***The Relationship Between Package Versions and Git Commits***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen how to request `status` at the package prompt to see a list of dependencies
    and abbreviations of their UUIDs, and how to see the complete UUID in the *Manifest.toml*
    file. We may be aware that Git identifies commits with a unique hash, but if we
    examine the hash of our project with `git log`, we won’t see anything that looks
    like Julia’s UUID.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant section of the default environment’s *Manifest.toml*,
    which is in *.julia/environments/v1.8/Manifest.toml* within the user’s home directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Random` is listed as a dependency because we had `add`ed it to the project
    earlier. In the last two lines, we see the full UUID and the initial version assigned
    by the package system. Before that, we have the path and the branch name from
    Git. Above that, we see something called the `git-tree-sha1`, which is a Git hash,
    but it’s not the commit hash that we see by default when we enter git log. Within
    `Floof`’s directory, if we enter this command with an option, we can see more:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The hash recorded in *Manifest.toml* is the *tree hash*. Most Git users are
    unaware of this hash because it’s rarely needed for anything. The tree hash encodes
    the actual contents of all the tracked files in the commit. Julia’s package manager
    uses this rather than the commit hash because it’s more reliable. Git provides
    powerful commands, such as `rebase`, that let users rewrite the commit history.
    If a conflict arises and something breaks, ideally we would like to identify the
    actual file contents of the programs involved. In practice, to identify a commit
    from the information recorded in *Manifest.toml*, we need to ask Git for the raw
    commit log and search for the tree hash.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '***Version Updating and Pinning***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another crucial package system command is `update` `*PackageName*`. Execute
    this operation to get the latest version of `*PackageName*` installed in the environment.
    Julia will check the registry for a new version, and download and precompile it
    if there is one. If `*PackageName*` has any dependencies, Julia will check their
    versions against the ones already installed, and download and precompile anything
    that’s changed. It will continue through the entire dependency graph, leaving
    us with a consistent environment, with no further action on our part.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If `*PackageName*` is our own project that we’re developing locally, the `update`
    command will cause the package manager to check its Git repository. If the tree
    hash at the `HEAD` of the tracked branch, as recorded in Git’s log, has changed,
    Julia will install the new version into the environment and precompile it. The
    *Manifest.toml* file will contain the new tree hash. If we’ve edited the source
    file but not yet made a new Git commit, the package manager won’t do anything.
    Even if we change the version number recorded in `*PackageName*`’s *Project.toml*
    file, that will not cause Julia to take any action. The package manager cares
    only about the tree hash. This means, for example, if we soft-reset to an earlier
    commit, then `update` in Julia, the package manager will revert to the version
    that our `HEAD` now points to, pulling the files from the Git repository and *not*
    from our working tree.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible for an `update` to lead to a conflict, where the current versions
    of two packages cannot work together. Use the `pin` command in the package manager
    to force it to hold particular packages at certain versions. Sometimes that’s
    the only way around a conflict until the bugs are fixed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The three versions of `pin` are `pin` `*PackageName*`, which holds `*PackageName*`
    at its current version; `pin` `*PackageName*@2.4.2`, which, in this example, holds
    `*PackageName*` at version 2.4.2; and `pin` `*PackageName=UUID*`, which holds
    the package using its UUID rather than the version number to identify the version.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Find Public Packages***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we discover if there is a Julia package that might help us write our
    program? The most productive approach is probably a general web search for projects
    or problems similar to ours, using Julia—this will quickly surface the most popular
    relevant packages. Of course, talking to people working in the same area is invaluable,
    if such a community is available. Asking on the Julia Discourse forum will almost
    certainly yield helpful replies, unless our project is quite niche or esoteric.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Since practically all development of public Julia packages takes place on GitHub,
    this is the place to search directly for solutions, especially if the previously
    mentioned approaches did not lead to anything appropriate, or if specific criteria
    are important to our project, such as recency of development.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: There are several sites that seem to offer a way to search through packages,
    but provide nothing beyond what GitHub offers directly, aside from incorrect and
    outdated information and an even worse interface. The best strategy for searching
    on GitHub is to use a language qualifier. For example, in the project search box
    we would enter `phylogenetics language:Julia` to look for projects that mention
    phylogenetics in their title or keywords, and that are written in Julia (and possibly
    other languages). This is effective because Julia packages are written in Julia,
    and it’s necessary because Julia packages often do not have a “Julia" keyword,
    so using that as a bare search term misses many projects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, we can then sort the resulting list based on several criteria, including
    recency of last update and the number of “stars” the project has. The latter,
    despite its unpleasant associations with internet popularity and gamification,
    is actually a useful proxy to uncover packages that are widely used and therefore
    more likely to be valuable and to have a community around them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The individual project pages in GitHub will contain a rendering of their README
    files, which range from a few cryptic phrases to a full introduction and tutorial
    with screenshots and animations. The README sometimes contains a link to further
    documentation; if it doesn’t, one can click one of the project’s documentation
    badges, but there is no guarantee that will lead to any actual documentation.
    Lack of documentation is not a good sign, but there may be linguistic or other
    reasons for the lapse. We can always look at the source code, all of which will
    be a click away on GitHub. Julia code is unusually easy to read, and obviously
    is the final source of truth about the operation of any package.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: After we discover a package that we want to try, it’s time to return to the
    REPL and `add` it to our project. We can add packages in the official registry,
    listed in the GitHub project `JuliaRegistries/General`, simply by using its name.
    In the probably unusual circumstance where we want to add a public project that
    is not in the general registry, we can add it using its URL. In package mode,
    we enter
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: for example, to add the project `projectname` by developer `developer`. This
    will only work if we are pointing at a proper Julia project with a *Project.toml*
    or *JuliaProject.toml* file. After adding the project, it will appear in our *Manifest.toml*
    file with the extra field `repo-url`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter describes some essential ingredients for using Julia effectively
    and making it possible for others to incorporate our programs into their work.
    Programming is rarely done in isolation. There is no need to reinvent the wheel
    if a solution to a part of your problem is as close as an `import` away. In later
    chapters, we’ll expand on these ideas and look at even more powerful ways to combine
    the resources of several packages. But first, in the next chapter we’ll explore
    an essential package that nearly all scientific Julia programmers use as we delve
    into the plotting system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: More details on what you can do with docstrings, mostly of interest to package
    developers, are available at [*https://docs.julialang.org/en/v1/manual/documentation/*](https://docs.julialang.org/en/v1/manual/documentation/).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When making those docstrings, you may need to know more about Markdown syntax:
    [*https://www.markdownguide.org/basic-syntax*](https://www.markdownguide.org/basic-syntax).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *.toml* file extension stands for “Tom’s Obvious, Minimal Language” designed
    by Tom Preston-Werner: [*https://github.com/toml-lang/toml*](https://github.com/toml-lang/toml).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good resource for getting started with Git is [*https://git-scm.com*](https://git-scm.com).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information about the package system, including instructions on
    how to submit your creations to the official repository, or *registry*, go to
    [*https://pkgdocs.julialang.org/*](https://pkgdocs.julialang.org/).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package system summary, and my first adventure in contributing to a public
    package, are available at [*https://lwn.net/Articles/871490/*](https://lwn.net/Articles/871490/).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For workflow tips, visit [*https://docs.julialang.org/en/v1/manual/workflow-tips/*](https://docs.julialang.org/en/v1/manual/workflow-tips/).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
