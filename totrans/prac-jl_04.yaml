- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MODULES AND PACKAGES**
  prefs: []
  type: TYPE_NORMAL
- en: '*Information about the package is as important as the package itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—*Frederick W. Smith, founder of FedEx'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, I mentioned that Julia programs are organized around
    collections of functions. The functions are the verbs of your program, meaning
    they describe what it does. You could spend your whole Julia programming life
    working in the REPL or in Pluto while saving programs in files using nothing more
    than function, variable, and data type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes time to develop projects that build on your previous work
    systematically, or to allow other people to use your code in their projects, you
    will want to take advantage of the structures Julia provides to organize and share
    your programs. Even if you never reuse or distribute your own code, you will use
    code from the Julia standard library, from other official Julia packages, and
    perhaps from other researchers. In any case, familiarity with Julia’s module and
    package system is essential.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Julia programmers make liberal use of modules both in the REPL and in program
    files, and borrowing existing facilities for plotting, solving equations, serving
    websites, and countless other activities is routine. *Creating* modules, however,
    is of little use in the REPL. The modules you create will live in files, ready
    to be used as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Namespaces***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *namespace* is a grouping for names that distinguishes them from identical
    names existing in other groups. We need namespaces because functions and variables
    may be defined in different places but happen to have identical names, and we
    need a way to make it clear which object we are referring to.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define an object in the REPL we can refer to it later with its name.
    For example, after an assignment such as `a = 1`, the variable `a` will return
    `1`. We say that `a` is defined in the *global namespace*. The terminology varies:
    sometimes it’s *top-level namespace* and sometimes *main namespace*. In any case,
    the *current namespace* is the one in which we’re working.'
  prefs: []
  type: TYPE_NORMAL
- en: When we need to refer to objects defined elsewhere, we have two options. We
    can call them by their unadorned names, as if they had been defined in the current
    namespace, or we can refer to them with a name such as `SomeModule.a`. In the
    latter case, we say that `a` is in the `SomeModule` namespace, and we have used
    a *qualified name* for it.
  prefs: []
  type: TYPE_NORMAL
- en: The two names `SomeModule.a` and `a` can refer to different objects—perhaps
    even to different types of objects. The identifier `a` might be a variable that
    we’ve defined in the REPL, and `SomeModule.a` might be a function defined in the
    `SomeModule` module. In the next section, we’ll learn how objects from other modules
    sometimes wind up in our current namespace and when we need to use qualified names
    to refer to them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Installed Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Julia installation comes with many modules ready for use. The resources in
    two particular modules, `Base` and `Core`, are always automatically available,
    which is why we can invoke the functions that we used in the previous chapter,
    such as `abs()`, without loading anything explicitly. Most of these essential
    functions are in the `Base` module. `Base` also supplies such basics as the `+`
    operator, which is also a function under the hood. The `Core` module exists at
    an even deeper level and contains such foundation stones as the `Int64` data type.
    Although you can’t do much without `Base`, you can arrange for it to not be loaded.
    The small `Core` module is necessary for Julia to work, however, so it’s not optional.
  prefs: []
  type: TYPE_NORMAL
- en: The *standard library* is a collection of modules that’s always installed with
    Julia but that you need to load explicitly to be able to use. The modules in the
    standard library provide functionality that is commonly needed across a variety
    of computations, but that is less fundamental than, for example, the arithmetic
    operators. You will never need everything in the standard library in any particular
    program, but a typical program will make use of several of its modules.
  prefs: []
  type: TYPE_NORMAL
- en: You can load the resources in a module with either the `using` or `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Most modules have uppercase initials and use “camel case” for their names,
    such as* LinearAlgebra *from the standard library. Although you’re free to ignore
    such naming conventions (including the use of ! explained in [“Functions That
    Mutate Their Arguments](ch02.xhtml#ch02lev1sec17)” on [page 56](ch02.xhtml#ch02lev1sec17))
    in your own projects, following them will make your code easier to read for other
    Julia programmers.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `using` statement provides access to everything in the module. It brings
    all the names that the module creator has marked for export into the current namespace.
    So, for example, after executing `using Plots`, we can use the `plot()` function
    directly, as in `plot(x -> x^2)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use any name that we know of, however, even if it’s not exported. Julia
    has no secrets. Prefix the unexported name with the name of the module and a dot.
    For example, `Plots.surface(x, y, f)` will work regardless of whether `surface`
    is exported. In this case, we are invoking `surface` in the `Plots` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The other way to use resources from other modules involves the `import` statement.
    The only difference between `import` and `using` has to do with how we use names.
    If we execute `import Plots`, `Plots.surface(x, y, f)` will work, but just using
    `surface(x, y, f)` will not. The `import` statement provides access to everything
    in the module, just as `using` does, but *not in the current namespace*. You must
    use the module’s namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use either statement with a list of modules separated by commas: `using
    *Module1, Module2, Module3*`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the difference between the `using` and `import` statements, we’ll use
    two modules from the standard library: the `LinearAlgebra` module, which contains
    functions for solving sets of linear equations, inverting matrices, and other
    linear algebra operations, and `Random`, which provides random number functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](ch03.xhtml#ch3lis1) uses some functions from the standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Two ways to import a module*'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines make the resources from the two standard library modules
    available in the rest of the program. The difference between the `using` and `import`
    statements is in how we refer to those resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `using LinearAlgebra` statement allows us to use all of the *exported names*
    from this module directly. The exported names are those that appear in an `export`
    statement in the module. We can use the `dot()` function ➋, which computes the
    dot product of two vectors, directly, because it’s exported by `LinearAlgebra`,
    and the `using LinearAlgebra` statement pulled it into the current namespace.
    (The dot product of [*a*, *b*] and [*c*, *d*] is *ac*+*bd*.) We can refer to the
    function using `LinearAlgebra.dot()` as well; the two names refer to the same
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sometimes* import *and* using *statements incur significant delays. Julia
    is precompiling some functions in the module to make their use more efficient.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to use resources from other modules involves the `import` statement,
    as we used in the second line: `import Random`. The only difference between `import`
    and `using` has to do with the use of names. Since we *imported* `Random`, to
    use its functions we must prefix them with the name of the module ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: If we pull in a module with `using` and already have some of its names defined
    in our program, Julia will print a warning. The next section describes other ways
    to handle this problem.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `import` statement when we have names that happen to be the same
    within more than one module or that are identical in an imported module and in
    our program. The use of module namespaces will remove the ambiguity. For example,
    our program has our own `randexp()` function, which is different from the one
    supplied by the `Random` module. It returns `17`, which I chose at random when
    I wrote the function, hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: After the definition of `randexp()` ➊, we define two vectors, `a` and `b`. We
    calculate their dot product using the `dot()` function, which is exported by `LinearAlgebra`,
    and pipe its output to `println()` so we can see it.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `randexp()` function from `Random` and prints the result.
    This function returns a number randomly selected from the exponential distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we call `randexp()` ➍ from the program’s global namespace and print
    the result: `17`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from one run of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you run it, the second number will be different because it’s randomly generated
    (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Selective Importing and Renaming***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve seen two Julia statements, each of which allows a program to refer
    to objects defined elsewhere. Both statements give access to everything in the
    target module, but differ in how we refer to the module’s objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can supplement either command with specifications that provide more control.
  prefs: []
  type: TYPE_NORMAL
- en: The `as` keyword lets us pick a name to use for the module within our program.
    If we change the second line in [Listing 3-1](ch03.xhtml#ch3lis1) to `import Random
    as Rnd`, we need to change the line that uses it to `Rnd.randexp() |> println`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can append a colon to the module name to limit the import to only specified
    objects. Optionally, we can use the `as` keyword to rename those objects to names
    of our choosing. These methods can serve to avoid conflicts with existing names.
    Here is [Listing 3-1](ch03.xhtml#ch3lis1) with some modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This program has the same results as the previous version, but the `import`
    statement ➊ imports only the `randexp()` function from `Random` and renames it
    as `rrexp()`. When we call it ➋, we have to use its alias because its original
    name, `randexp()`, is unknown in its current environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Julia, there is no relationship between modules and files or between filenames
    and module names. A file can contain any number of modules, and a module may be
    split among many files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a module in a program file using the `module` keyword. This begins
    a structure that resembles a block and is terminated with the `end` keyword, but
    is different from the blocks described in [Chapter 2](ch02.xhtml). Because it’s
    common for entire files to comprise the contents of a module, the conventional
    style does not indent module bodies. Such a practice would lead to uselessly indenting
    most of the file. Another distinction concerns scope: variables defined within
    a module, but outside any of the blocks that define local scopes, are global to
    the module. Each module has its own global scope, so a file with more than one
    module has more than one such scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s begin with a simple case: [Listing 3-2](ch03.xhtml#ch3lis2)
    is a small program containing two modules, with everything contained within a
    single file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: A program containing two modules*'
  prefs: []
  type: TYPE_NORMAL
- en: This program defines two modules, `M1` and `M2`. Each module defines one function,
    which it lists in an `export` statement. Usually `export` lines go near the top
    of the module, but they can appear anywhere. Running the program prints `100`
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` statement ➊ brings the exported names of the two modules into the
    global namespace of the file. The dots in front of the module names mean that
    we are referring to modules defined *within the current module*. But it doesn’t
    appear as if we’re in a “current module”: the statement is simply at the top level
    of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re always in a module in Julia. The top-level module is automatically called
    `Main` if we don’t name it ourselves, so `M1` and `M2` are modules within the
    `Main` module.
  prefs: []
  type: TYPE_NORMAL
- en: If we had used `import` rather than `using`, we would have been obliged to mention
    the module namespaces when invoking their functions. Although we need to use the
    dot when importing to indicate *where* the module is, its names are still given
    in the `module` statements. For example, the `plusone()` function is `M1.plusone()`.
  prefs: []
  type: TYPE_NORMAL
- en: Dots in module import statements have a significance similar to their use in
    directory names in Unix-like operating systems. Single dots refer to the current
    “directory,” or module, and a double dot goes up one level to the enclosing module.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch3lis3) shows an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Relative module imports*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve moved the definition of module `M2` inside `M1` ➊. Within `M2` we import
    `M1` ➋, which is now a *sibling module*: the double dot tells Julia to go up one
    level before looking for `M1`. After this `using` statement, `plusone()` is available
    within `M2`, so we can call it directly within the `println()` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the top level, which is the `Main` module, we again want to import every
    exported name from `M1` and `M2` into the global namespace, but now we need to
    specify that `M2` is within `M1` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: This program prints `201` followed by the same output as the previous example
    in [Listing 3-2](ch03.xhtml#ch3lis2).
  prefs: []
  type: TYPE_NORMAL
- en: If we simply want to insert the contents of a file into the current file, we
    use the `include()` statement with a string argument giving the file’s pathname.
    This is equivalent to pasting the file’s contents at the location of the `include()`
    statement. It doesn’t use any of the module namespacing machinery, pulling objects
    in the included file into the module’s namespace. Using file inclusion, we can
    split large modules among different files, helping to keep our code organized.
  prefs: []
  type: TYPE_NORMAL
- en: '***Documenting Functions with Docstrings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous chapter described how to use the REPL’s help system to get information
    about functions. We can document our own functions so that the help system can
    provide nicely formatted information about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a string literal immediately before the beginning of any function definition
    to document it, creating what’s called a *docstring*. The help system, as well
    as any other Julia documentation system, will associate this string with the function,
    and format and display it when the user asks for help. Here is a somewhat silly
    example, where I added some help text to [Listing 3-3](ch03.xhtml#ch3lis3) to
    document the `plusone()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example I use the triple-quoted string syntax explained on [page 45](ch02.xhtml#page_45)
    to conveniently embed newlines and other characters without needing to escape
    them. Most help strings are written this way.
  prefs: []
  type: TYPE_NORMAL
- en: '**MARKDOWN IN DOCSTRINGS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation system understands a version of Markdown syntax and will
    format the output appropriately. Markdown is a simplified system of text markup
    where you can specify italics, boldface, and code using underscore, double underscore,
    and backtick delimiters, with asterisks accepted as alternatives to underscores.
    A blank line starts a new paragraph, and indenting text by four spaces sets it
    as code. Lines beginning with hash marks are not comments, as in Julia code, but
    become headings: `# Heading`, `##` `Subheading`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The example demonstrates some of the documentation conventions the Julia community
    uses. Begin the help text with the function signature, followed by an imperative
    statement of what the function does. After that can come more explanation and
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](ch03.xhtml#ch3fig1) is a screenshot of a REPL session where I
    included the *modutst.jl* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Using the documentation system*'
  prefs: []
  type: TYPE_NORMAL
- en: In the REPL, the `println()` statements are run and produce the output shown
    previously. I pressed `?` to enter help mode and typed the name of the function.
    After showing the results of a fuzzy search on the name, the REPL renders the
    docstring of the most likely choice. The terminal REPL renders code using a contrasting
    color and italics with an underline. Other environments may use different typography.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about Markdown formatting, see “Further Reading” on [page 81](ch03.xhtml#fur3).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to reference modules defined in the current file using dots
    and extend the current file using `include()`. Before that, we were loading external
    modules with the same `using` and `import` statements, but with no dots in front
    of the module names. Somehow in those cases, Julia knew where to find the files
    containing the module definitions, and that is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Package System**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most convenient way to interact with Julia’s package system is with the
    REPL’s package mode. Press `]` to enter and BACKSPACE to exit this mode.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the package mode and have another look at the prompt. It looks something
    like `(@v1.8) pkg>`, where `v1.8` shows the currently installed Julia version.
    The part within the parentheses informs us of our current *environment*. We are
    always in some environment in the REPL. The environment is the project to which
    the package mode applies its commands.
  prefs: []
  type: TYPE_NORMAL
- en: When we start the REPL we’re in the default project. Everything we do in the
    package manager applies to that environment, unless we change it with the `activate`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Enter activate. to change the environment to the current directory, or activate
    path to change it to a specified path. A simple activate changes to the default
    environment for the version of Julia in use.
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Add and Remove Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important package command is `add`. To use it, enter add packageName
    from within the REPL’s package mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` command does two things: it downloads and precompiles the latest
    compatible version of the requested package, if it’s not already installed, and
    it records the package as a dependency of the current environment. The second
    step ensures that the set of package versions used in the project can always be
    reproduced, either by its author on a different computer or by a colleague.'
  prefs: []
  type: TYPE_NORMAL
- en: We will have to `add` any packages that are not in the standard library. This
    includes the vast majority of packages in the Julia ecosystem, such as `Plots`,
    for making scientific graphics, or `BenchmarkTools`, for timing and profiling
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: If any package previously installed with `add` is no longer needed, we can remove
    it with the `rm` PackageName command, also from within package mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `rm` package mode command deletes a package from the list of direct dependencies
    of your project, but it does not immediately erase any files from the disk. An
    automatic garbage collection process runs periodically, reclaiming disk space
    by purging packages that no other installed package depends on and that haven’t
    been used for over 30 days. To reclaim disk space right away, call the garbage
    collector manually. Detailed instructions are in the package system manual (see
    “Further Reading” on [page 81](ch03.xhtml#fur3)).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Load Path***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The current environment influences where `using` and `import` look for packages
    and defines the default location for package commands. When executing statements
    like `using Plots` or `import Random` that mention package names without dots,
    Julia looks for the packages in a series of places derived from a vector of strings
    named `LOAD_PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ask the REPL to show us the default initial value of `LOAD_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `LOAD_PATH` are clearly not filepaths. They’re a notation that
    the package manager translates into the appropriate paths for the system and installation.
    To see the results of the translation and the current values of the paths, we
    can call the `load_path()` function from `Base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already mentioned that `Base` contains the functions we almost always
    need, but they’re not all exported. Ones that are used infrequently, such as `load_path()`,
    need to be accessed in the `Base` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: My current load path contains two items. The first is a directory that Julia
    set up when I installed it. It corresponds to my default environment. When I execute
    a command like `add Plots` in the REPL, if I haven’t switched environments with
    the `activate` command, the package manager adds the current version of the `Plots`
    package as a *dependency* in the default *project*. It records the fact that this
    project depends on a particular version of `Plots` being available, and `using
    Plots` will import the functions from that version. This path is the translation
    of the second element in `LOAD_PATH`, `"@v#.#"`. The notation simply means “the
    default environment”; notice how its structure resembles the prompt in package
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package manager records these direct dependencies, the ones specified with
    `add` commands, in the *Project.toml* file. This file contains lines such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This line shows that the particular version of the `Plots` package, made specific
    with a unique identifier called a *UUID*, is a dependency of the project that
    contains this file—in this case, the default project associated with my installation
    of v1.8 of Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The second path returned by `Base.load_path()` comes from the last element of
    `LOAD_PATH`, which refers to the standard library. As mentioned previously, the
    standard library consists of modules that are part of the Julia installation,
    so they don’t need to be installed with `add`. I left my installation in the download
    folder where my web browser put it, so that’s where its standard library lives.
  prefs: []
  type: TYPE_NORMAL
- en: The `LOAD_PATH` has three elements, but we see only two in its current translation
    by `Base.load_path()`. The first element, which is simply `@`, refers to the *current
    environment*. Julia searches for packages in the order in which they appear in
    `LOAD_PATH`, so it searches the current environment first. To change the current
    environment, execute activate path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current environment has two purposes: it comes first in the load path,
    so imports of packages will load the versions, if any, that have been added as
    dependencies in the environment, and the package system `add` command inserts
    a dependency there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An environment is really nothing more than a place in the filesystem with a
    *Project.toml* file and a *Manifest.toml* file. The latter is a list of the entire
    *dependency graph* of the environment: all the packages that need to be loaded
    to satisfy the dependencies of the ones explicitly `add`ed, with their UUIDs,
    the list of dependencies of each of those dependencies, and so on. If we use the
    `activate` command on a path where there is no existing environment and execute
    one or more `add` commands, Julia will create these two files there and fill them
    with the specified package information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If we can’t use the filenames* Project.toml *or* Manifest.toml *because they
    conflict with another tool, we can use* JuliaProject.toml *and* JuliaManifest.toml
    *instead. If Julia sees either of those files, it will use it and ignore the one
    without the* Julia *prefix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Environments contain no Julia code, only a list of dependencies. They may document
    a set of consistent modules that work for a particular purpose. For example, after
    using Pluto, we’ll discover that Julia has created an environment alongside the
    normal default environment whose *Project.toml* and *Manifest.toml* files contain
    a list of the modules that Pluto needs to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Nature of a Package***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve mentioned *package* many times, and have used the term more or less interchangeably
    with *module*, a tradition well established in the Julia documentation. Now let’s
    make the relationship between these concepts precise and explore how packages
    are related to environments.
  prefs: []
  type: TYPE_NORMAL
- en: A package is a Julia module associated with a *Project.toml* file containing
    a few critical pieces of information. The file containing the module and the *Project.toml*
    file must be laid out in the filesystem as shown in [Figure 3-2](ch03.xhtml#ch3fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: The filesystem layout of a package*'
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the *Project.toml* file is a *src* directory, inside which must be
    the Julia program file, named after the package. Inside this file is the definition
    of a module also named after the package, which in this case is `module` `SomePackage`.
    The structure shown in [Figure 3-2](ch03.xhtml#ch3fig2) is usually placed inside
    a directory also named after the module, *SomePackage* in this case, but that
    is not strictly required.
  prefs: []
  type: TYPE_NORMAL
- en: For this arrangement to qualify as a package, the *Project.toml* file must provide
    the name of the package, its UUID, its authors, and its version number, in the
    format shown in [Listing 3-4](ch03.xhtml#ch3lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: A package’s* Project.toml *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` must match the name of the module defined in *src/Some Package.jl*.
    If we have these two files, one within a *src* directory, we have a package. We
    can think of a package as an environment with a module inside and with these four
    pieces of information in *Project.toml*. In practice, as soon as we add dependencies
    to our package with the `add` command executed within the package’s environment,
    we will also have a *Manifest.toml* file alongside the *Project.toml* file that
    contains the complete dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: We can do all of our Julia development within *.jl* files, possibly using `include()`
    to split the code among several files, and share our work by emailing those files
    to colleagues. Many Julia programmers do no more than this and don’t bother creating
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Benefits of Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the exploratory REPL phase of your program development is over, and it’s
    time to save your code in the filesystem so you can use it later, possibly as
    a resource in other programs, I would like to encourage you to take advantage
    of Julia’s package system.
  prefs: []
  type: TYPE_NORMAL
- en: It’s sophisticated, easy to use, and will save you from dependency conflicts
    down the road. Most programs use modules from the standard library and other packages,
    and all are developed with a particular version of Julia itself. As all these
    components evolve, the possibility of conflict arises and, with time, becomes
    inevitable in large programs that use many external resources. The package system
    records the exact versions of all the resources your program uses, so you or anyone
    else can reproduce that environment in the future, and the program will always
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of dependency management, a statement like `using Plots` in your
    program imports whatever version of `Plots` is used by the environment in which
    a future user, including yourself, happens to run it. You may have used a feature
    that is later removed from the package, or a future version may introduce a bug
    that breaks your program. Without package management, your program is loading
    unknown code because you’re not being specific about what you mean by `Plots`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packages often depend on other packages. A future user of your program, encountering
    a conflict with `Plots`, may try to resolve it by using a different version. But
    that version will depend on different versions of other packages, and some of
    those will have their own dependencies. Trying to sort out the dependency graph
    of packages manually to find a workable set quickly becomes a maddening task.
    It’s such a common headache in languages without good package management that
    there’s a name for it: *dependency hell*. Julia’s package system manages the dependency
    graph automatically. You can have various versions of Julia and of any number
    of packages installed on your machine at the same time with no issues. If you
    keep your programs in packages, you can upgrade the versions of modules that it
    imports without changing your actual code, and if the new versions create problems,
    you can downgrade as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to share your programs through the official community channels,
    you must use packages. The official repository, from which you get resources when
    you use the `add` command, is based on packages and the Git version control system,
    which I’ll treat in “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11).
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Create Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s easy to create packages. First, we navigate to the directory in the filesystem
    where we want the package to be and start the Julia REPL. We can use any directory,
    and we can always move it later.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We don’t have to start a new REPL session just to change locations in the
    filesystem. To continue in an existing REPL session, we can move around the filesystem
    while staying in the REPL using two Julia function versions of the familiar Unix
    commands* pwd *and* cd*. The REPL maintains a notion of the current directory,
    which is where we gave the* julia *command that started the REPL, and it stays
    there unless we change it. The* pwd() *function in the REPL returns a string with
    the full pathname of the current directory. To change it, enter* cd(new_directory)*,
    substituting the name of the desired destination. (The name is a string, as returned
    by* pwd()*, so must be enclosed within quotes.)*'
  prefs: []
  type: TYPE_NORMAL
- en: Within the REPL, press `]` to enter package mode, and execute generate Floof.
    That’s all we need to do to create a new package named `Floof`.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the system shell, or using the REPL’s shell mode, we’ll find the new
    directory named *Floof*, and within it, the minimal package files shown in [Figure
    3-2](ch03.xhtml#ch3fig2). Floof’s *Project.toml* file will contain lines similar
    to [Listing 3-4](ch03.xhtml#ch3lis4), but with the name *Floof* and a new, unique
    UUID. The `authors` field is populated from our Git configuration, so it’ll be
    empty if we haven’t installed Git (see “Julia and Git” on [page 77](ch03.xhtml#ch03lev1sec11)).
    The `generate` statement gives our new package a version number of `0.1.0`, which
    we can change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Descending into the *src* directory, the *Floof.jl* file has the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a tiny module, called `Floof`, with one function, `greet()`, that
    greets the world. Julia sets up a minimal package with everything in place so
    we can begin development of our module. We’ll make one change to this file for
    now: add the statement `export greet` after the first line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s experiment with this new mini-package. First, we’ll exercise it without
    using the package system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We put the `Floof` package in the */tmp* directory. The first action in the
    REPL is to `include` the program file directly. This is equivalent to pasting
    it directly into the REPL. The feedback ➊ from the `include()` statement confirms
    that `Floof` is loaded into `Main`, which is always the name for the top-level
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use anything in the `Floof` module by mentioning its namespace. It
    has only one ingredient, the `greet()` function, which does what’s expected when
    we call it.
  prefs: []
  type: TYPE_NORMAL
- en: We would prefer to call this function without having to type the module name,
    so we need to import its name into the current namespace. We tried to do this
    with the `using` statement, but Julia won’t let us ➋. After remembering that we
    need to prefix local modules with a dot, everything works as expected ➌. (I’ve
    omitted the stacktrace from the error message to save space, as I will do routinely.)
  prefs: []
  type: TYPE_NORMAL
- en: Importing a name, whether with `using` or `import`, without a dot prefix tells
    Julia to import a package rather than a local module. This wakes up the package
    system, which consults the `LOAD_PATH` to search for the package. Although `Floof`
    is indeed a package, it’s not on the `LOAD_PATH`, which by default includes the
    activated environment, the default environment, and the standard library, in that
    order. Since we haven’t activated an environment, and the `Floof` package is in
    neither the standard library nor the default environment, Julia can’t find it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’re determined to import `greet()` into the global namespace, we can activate
    the environment that contains the `Floof` module. But first, we should quit and
    restart the REPL. Otherwise, this new attempt to import will generate an error
    complaining about a conflict with an existing name. After starting a fresh REPL,
    we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After activating the `Floof` environment using its pathname, we exit package
    mode. Back in the REPL’s normal mode, after importing `Floof`’s names into the
    global namespace with `using`, a simple `greet()` invokes the function. This works
    only because we edited *Floof.jl* to `export greet`. Then we re-enter package
    mode—observe the prompt, which now indicates the `Floof` environment. The `add
    Random` command adds this package, which contains utilities related to random
    number generation, to the dependency list for `Floof`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add paths manually to `LOAD_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We do this, again, in a fresh REPL. The package system found `Floof` in the
    last entry in `*LOAD_PATH*`; it will find it regardless of the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: '`Floof`’s *Project.toml* file now contains two additional lines. Here are its
    contents after executing `add Random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The lines after the `[deps]` label will record every dependency that we manually
    add with an `add` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new *Manifest.toml* file has appeared alongside the *Project.toml* file with
    these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Manifest files are for recording the dependency graph of a package or environment.
    For each dependency added manually, the system looks up its dependencies, and
    the dependencies of all of those dependencies, and so on, until it finds every
    dependency. Each of these dependencies is another package; all of them together,
    with all of their dependency relationships, is the dependency graph. As you can
    imagine, Manifest files can get rather large, but this one is not because `Random`
    apparently has only one dependency, a package called `Serialization`, and `Serialization`
    has no dependencies of its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our very own package, we should be able to add it as a dependency
    to other packages and environments, just as we did with other packages like `Random`
    and `Plots`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First we use the `activate` statement with no argument to go back to the default
    environment. We try to add `Floof` to that environment, but the package manager
    has a complaint about not finding something called a *git repository*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Julia and Git***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Git is a *version control system*: a program that helps you keep track of your
    work as it changes over time. Git, in addition, focuses on collaboration, although
    it’s immensely useful to the solo creator as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Git is independent of Julia, but since its creation in 2005 by Linus Torvalds,
    the creator of Linux, its superiority over all other version control systems has
    led to a near monopoly in the free software community. Julia is part of this community,
    and Git is an intimate component of the development of the language and its packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have Git installed and would prefer to continue your study
    of Julia without pausing to install Git and learning how to use it, skip this
    section for now. You can always return later. See “Further Reading” on [page 81](ch03.xhtml#fur3)
    for a link to an excellent learning resource. There are also many articles and
    several books about Git.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend installing Git and using it in your projects before your personal
    library of code becomes substantial. The small investment in time and effort to
    become familiar with a few basic operations has a huge payback. You’ll be able
    to travel back in time to past states of your programs, keep a log of changes,
    create alternative versions of your programs where you try out ideas, and merge
    the ideas into the main line of development when they’re ready.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re already using one of the older version control systems, you can continue
    to do so. However, if you reach the stage where you would like to contribute your
    Julia programs to the community, you will have to use Git. As we’re about to see,
    Git is also required for adding your own packages as dependencies in your own
    projects and environments on your personal machine, which is something you may
    want to do even if you don’t share your programs.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in “How to Create Packages” on [page 73](ch03.xhtml#ch03lev1sec10),
    Julia complained when we tried to `add` my `Floof` package. The package system
    won’t let us add a package until we put it in a Git repository. Dependency management,
    which is the reason for the package system, tracks not simply packages, but versions
    of packages. Julia’s package system works with Git to track these versions. The
    rest of this section assumes Git is installed.
  prefs: []
  type: TYPE_NORMAL
- en: To allow the package system to deal with `Floof`, we have to put it in a Git
    repository and make an initial commit. In the */tmp/Floof* directory, we execute
    git init in the system shell to create the repository, then git add. and git commit
    -m "Begin repo" to begin tracking the contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Julia REPL, we try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It works this time: the package manager responds that it’s added `Floof` to
    the *Project.toml* and *Manifest.toml* files. The string in square brackets is
    the initial part of the UUID that the package manager has assigned to this version
    of `Floof`. The `#master` string refers to the branch name in Git.'
  prefs: []
  type: TYPE_NORMAL
- en: The `status` package command returns a list of all the dependencies added to
    the current environment (not the entire dependency graph), and we see that `Floof`
    is among them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove a dependency—say, `Floof`—we enter rm Floof in package
    mode: note that when removing packages, we use just the package name, not the
    whole path on the filesystem. This does nothing to our files; it simply removes
    `Floof` from the *Project.toml* file. However, it may not remove it from *Manifest.toml*
    because it may be listed there as a dependency of some other package.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve made your program into a Julia package and are tracking it with Git,
    you’ll be prepared to request that it be included in the official repository if
    the day comes when you feel it will be of use to a wider audience. If you complete
    this step, any Julia user anywhere in the world can simply tell their package
    REPL to `add` `*YourPackage*`, and they’ll be able to use and build on your work.
    Sharing and collaboration are embedded in Julia’s DNA. [Chapters 9](ch09.xhtml)
    and [12](ch12.xhtml) demonstrate several interesting examples of how packages
    can be combined to create new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Relationship Between Package Versions and Git Commits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen how to request `status` at the package prompt to see a list of dependencies
    and abbreviations of their UUIDs, and how to see the complete UUID in the *Manifest.toml*
    file. We may be aware that Git identifies commits with a unique hash, but if we
    examine the hash of our project with `git log`, we won’t see anything that looks
    like Julia’s UUID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant section of the default environment’s *Manifest.toml*,
    which is in *.julia/environments/v1.8/Manifest.toml* within the user’s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Random` is listed as a dependency because we had `add`ed it to the project
    earlier. In the last two lines, we see the full UUID and the initial version assigned
    by the package system. Before that, we have the path and the branch name from
    Git. Above that, we see something called the `git-tree-sha1`, which is a Git hash,
    but it’s not the commit hash that we see by default when we enter git log. Within
    `Floof`’s directory, if we enter this command with an option, we can see more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The hash recorded in *Manifest.toml* is the *tree hash*. Most Git users are
    unaware of this hash because it’s rarely needed for anything. The tree hash encodes
    the actual contents of all the tracked files in the commit. Julia’s package manager
    uses this rather than the commit hash because it’s more reliable. Git provides
    powerful commands, such as `rebase`, that let users rewrite the commit history.
    If a conflict arises and something breaks, ideally we would like to identify the
    actual file contents of the programs involved. In practice, to identify a commit
    from the information recorded in *Manifest.toml*, we need to ask Git for the raw
    commit log and search for the tree hash.
  prefs: []
  type: TYPE_NORMAL
- en: '***Version Updating and Pinning***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another crucial package system command is `update` `*PackageName*`. Execute
    this operation to get the latest version of `*PackageName*` installed in the environment.
    Julia will check the registry for a new version, and download and precompile it
    if there is one. If `*PackageName*` has any dependencies, Julia will check their
    versions against the ones already installed, and download and precompile anything
    that’s changed. It will continue through the entire dependency graph, leaving
    us with a consistent environment, with no further action on our part.
  prefs: []
  type: TYPE_NORMAL
- en: If `*PackageName*` is our own project that we’re developing locally, the `update`
    command will cause the package manager to check its Git repository. If the tree
    hash at the `HEAD` of the tracked branch, as recorded in Git’s log, has changed,
    Julia will install the new version into the environment and precompile it. The
    *Manifest.toml* file will contain the new tree hash. If we’ve edited the source
    file but not yet made a new Git commit, the package manager won’t do anything.
    Even if we change the version number recorded in `*PackageName*`’s *Project.toml*
    file, that will not cause Julia to take any action. The package manager cares
    only about the tree hash. This means, for example, if we soft-reset to an earlier
    commit, then `update` in Julia, the package manager will revert to the version
    that our `HEAD` now points to, pulling the files from the Git repository and *not*
    from our working tree.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible for an `update` to lead to a conflict, where the current versions
    of two packages cannot work together. Use the `pin` command in the package manager
    to force it to hold particular packages at certain versions. Sometimes that’s
    the only way around a conflict until the bugs are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The three versions of `pin` are `pin` `*PackageName*`, which holds `*PackageName*`
    at its current version; `pin` `*PackageName*@2.4.2`, which, in this example, holds
    `*PackageName*` at version 2.4.2; and `pin` `*PackageName=UUID*`, which holds
    the package using its UUID rather than the version number to identify the version.
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Find Public Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we discover if there is a Julia package that might help us write our
    program? The most productive approach is probably a general web search for projects
    or problems similar to ours, using Julia—this will quickly surface the most popular
    relevant packages. Of course, talking to people working in the same area is invaluable,
    if such a community is available. Asking on the Julia Discourse forum will almost
    certainly yield helpful replies, unless our project is quite niche or esoteric.
  prefs: []
  type: TYPE_NORMAL
- en: Since practically all development of public Julia packages takes place on GitHub,
    this is the place to search directly for solutions, especially if the previously
    mentioned approaches did not lead to anything appropriate, or if specific criteria
    are important to our project, such as recency of development.
  prefs: []
  type: TYPE_NORMAL
- en: There are several sites that seem to offer a way to search through packages,
    but provide nothing beyond what GitHub offers directly, aside from incorrect and
    outdated information and an even worse interface. The best strategy for searching
    on GitHub is to use a language qualifier. For example, in the project search box
    we would enter `phylogenetics language:Julia` to look for projects that mention
    phylogenetics in their title or keywords, and that are written in Julia (and possibly
    other languages). This is effective because Julia packages are written in Julia,
    and it’s necessary because Julia packages often do not have a “Julia" keyword,
    so using that as a bare search term misses many projects.
  prefs: []
  type: TYPE_NORMAL
- en: Crucially, we can then sort the resulting list based on several criteria, including
    recency of last update and the number of “stars” the project has. The latter,
    despite its unpleasant associations with internet popularity and gamification,
    is actually a useful proxy to uncover packages that are widely used and therefore
    more likely to be valuable and to have a community around them.
  prefs: []
  type: TYPE_NORMAL
- en: The individual project pages in GitHub will contain a rendering of their README
    files, which range from a few cryptic phrases to a full introduction and tutorial
    with screenshots and animations. The README sometimes contains a link to further
    documentation; if it doesn’t, one can click one of the project’s documentation
    badges, but there is no guarantee that will lead to any actual documentation.
    Lack of documentation is not a good sign, but there may be linguistic or other
    reasons for the lapse. We can always look at the source code, all of which will
    be a click away on GitHub. Julia code is unusually easy to read, and obviously
    is the final source of truth about the operation of any package.
  prefs: []
  type: TYPE_NORMAL
- en: After we discover a package that we want to try, it’s time to return to the
    REPL and `add` it to our project. We can add packages in the official registry,
    listed in the GitHub project `JuliaRegistries/General`, simply by using its name.
    In the probably unusual circumstance where we want to add a public project that
    is not in the general registry, we can add it using its URL. In package mode,
    we enter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: for example, to add the project `projectname` by developer `developer`. This
    will only work if we are pointing at a proper Julia project with a *Project.toml*
    or *JuliaProject.toml* file. After adding the project, it will appear in our *Manifest.toml*
    file with the extra field `repo-url`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter describes some essential ingredients for using Julia effectively
    and making it possible for others to incorporate our programs into their work.
    Programming is rarely done in isolation. There is no need to reinvent the wheel
    if a solution to a part of your problem is as close as an `import` away. In later
    chapters, we’ll expand on these ideas and look at even more powerful ways to combine
    the resources of several packages. But first, in the next chapter we’ll explore
    an essential package that nearly all scientific Julia programmers use as we delve
    into the plotting system.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: More details on what you can do with docstrings, mostly of interest to package
    developers, are available at [*https://docs.julialang.org/en/v1/manual/documentation/*](https://docs.julialang.org/en/v1/manual/documentation/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When making those docstrings, you may need to know more about Markdown syntax:
    [*https://www.markdownguide.org/basic-syntax*](https://www.markdownguide.org/basic-syntax).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *.toml* file extension stands for “Tom’s Obvious, Minimal Language” designed
    by Tom Preston-Werner: [*https://github.com/toml-lang/toml*](https://github.com/toml-lang/toml).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good resource for getting started with Git is [*https://git-scm.com*](https://git-scm.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information about the package system, including instructions on
    how to submit your creations to the official repository, or *registry*, go to
    [*https://pkgdocs.julialang.org/*](https://pkgdocs.julialang.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package system summary, and my first adventure in contributing to a public
    package, are available at [*https://lwn.net/Articles/871490/*](https://lwn.net/Articles/871490/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For workflow tips, visit [*https://docs.julialang.org/en/v1/manual/workflow-tips/*](https://docs.julialang.org/en/v1/manual/workflow-tips/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
