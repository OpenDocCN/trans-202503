- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 14 STRING OPERATIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *string* is a collection of values stored in contiguous memory locations.
    Strings are usually arrays of bytes, half words, words, dwords, or quad words.
    Some CISC CPUs, such as the Intel x86-64, support instructions that operate directly
    on strings of data. However, the ARM does not provide instructions for this purpose,
    as string operations tend to be complex and violate RISC design guidelines. Nevertheless,
    it is possible to operate on string data structures by using discrete ARM instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Although the ARM CPU does not support string-specific instructions, string operations
    are still an important function that CPUs must perform. This chapter discusses
    how to work with strings when using ARM assembly language. First off, this chapter
    describes how to call functions in the C stdlib to implement string operations.
    These functions are well written (typically in assembly language) and provide
    a high-performance implementation, as long as you are using zero-terminated strings.
    As noted throughout this book, however, zero-terminated strings are not the most
    suitable string data structure for high-performance string operations. Therefore,
    this chapter describes a better string format that allows you to write faster
    string functions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the problem with a new string implementation is that the C stdlib
    functions don’t support it, so this chapter also describes how to implement various
    string functions that support the new string format. Finally, this chapter concludes
    by discussing Unicode strings and string functions.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Zero-Terminated Strings and Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 4](chapter4.xhtml) briefly introduced the string data type, discussing
    zero-terminated strings (commonly used in C/C++ and languages derived from them),
    length-prefixed strings, string descriptors, and other string forms. As noted
    there, the zero-terminated string is the most common string form in use today.
    In particular, Linux (Pi OS) and macOS generally use zero-terminated strings for
    API functions to which you pass or receive string data. Therefore, you’ll often
    use zero-terminated strings in your ARM assembly language programs running under
    these OSes. This section describes the issues with zero-terminated strings and
    how to call functions in the C stdlib that support zero-terminated strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main problem with zero-terminated strings is performance. Such strings
    often require scanning over every character in the string to perform simple operations
    such as computing the string length. For example, the following code computes
    the length of a string named longZString:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If longZString is indeed very long, this code sequence can take a long time
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Length-prefixed strings (see section 4.6.2, “Length-Prefixed Strings,” on [page
    188](chapter4.xhtml#pg_188)) solve this problem by including the string’s current
    length along with the data. Any string function that uses the string’s length
    will operate much more efficiently because it doesn’t have to first scan the entire
    string to determine its length. If you get to choose the string format to use
    in your assembly language code, choosing a data type that includes the length
    as part of the string’s data can dramatically improve string-processing performance.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you don’t always get to choose the string format to use in your
    code. Sometimes external datasets, applications, or OSes force the zero-terminated
    string format on you (for example, OS API calls generally require zero-terminated
    strings).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to improve the performance of naive string functions such as
    the string-length code given earlier. In particular, the code at whileLp processes
    a single byte per iteration of the loop. Because the ARM64 CPU is capable of processing
    8 bytes at a time in general-purpose registers (and 16 bytes at a time in vector
    registers), you might wonder whether it’s possible to do better than one character
    per loop iteration. After all, if you can process 16 bytes per loop iteration
    (rather than 1), the function should run 16 times faster, right?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is a qualified yes. The first caveat is that processing 16 bytes
    per iteration is more complex and will require more than three instructions in
    the loop body. Expecting a 16-times improvement is therefore overly optimistic;
    4 to 8 times faster is probably a more reasonable expectation but still worth
    achieving.
  prefs: []
  type: TYPE_NORMAL
- en: The second caveat is that processing 16 characters at a time requires loading
    16 bytes from memory on each iteration, meaning that for many strings you’ll have
    to read data from memory beyond the end of the string. Thus, it’s possible to
    read beyond the end of an MMU page in memory containing the string, which could
    lead to a memory protection fault (see section 3.1.7, “Memory Access and MMU Pages,”
    on [page 127](chapter3.xhtml#pg_127)). While such a situation is rare, it nevertheless
    represents a defect in your code that could crash your application.
  prefs: []
  type: TYPE_NORMAL
- en: One last issue, while not as lethal as an illegal memory access, is that loading
    16 bytes of data from memory into a vector register works best if the data is
    aligned on a 16-byte boundary. Unfortunately, a zero-terminated string is not
    guaranteed to begin on such a boundary in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you have complete control of string placement in memory, you can arrange
    for strings to always begin on a 16-byte boundary. Likewise, you can always include
    padding at the end of the strings so you’re guaranteed to be able to read at least
    15 bytes beyond the end of the string’s data, thereby avoiding the MMU page-boundary
    problem. Unfortunately, few programs have such tight control over their strings
    that they can guarantee this arrangement in memory. For example, if an OS returns
    a pointer to a string, it may violate alignment and padding requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule, I recommend calling C stdlib functions if you’re going to
    manipulate zero-terminated (C) strings. In the past, C stdlib functions were written
    in C, and even with the best optimizing compilers it was easy enough for a good
    assembly language programmer to write faster code than the compiler produced.
    However, modern C stdlib string code is typically written in assembly language
    (by an *expert* programmer) and is often much better than any code you would write
    yourself. The GNU C stdlib for AARCH64, for example, has the following functions
    written in handcoded assembly language (see section 14.6, “For More Information,”
    on [page 859](chapter14.xhtml#pg_859) for more on these):'
  prefs: []
  type: TYPE_NORMAL
- en: strcpy
  prefs: []
  type: TYPE_NORMAL
- en: strchr
  prefs: []
  type: TYPE_NORMAL
- en: strchrnul
  prefs: []
  type: TYPE_NORMAL
- en: strcmp
  prefs: []
  type: TYPE_NORMAL
- en: strcpy
  prefs: []
  type: TYPE_NORMAL
- en: strlen
  prefs: []
  type: TYPE_NORMAL
- en: strncmp
  prefs: []
  type: TYPE_NORMAL
- en: strnlen
  prefs: []
  type: TYPE_NORMAL
- en: strrchr
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the GNU C stdlib *strlen.S* source file (slightly modified
    for formatting and comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The defines ❶ give the registers meaningful names within the function. Personally,
    I prefer to see the register names with comments describing their contents rather
    than redefined registers, to make it easier to avoid reusing registers, but this
    is certainly an acceptable style, especially for C library code that uses the
    ARM ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier, code that operates on 16 bytes at a time (as this version
    of strlen() does) has to deal with two issues: aligning data on a 16-byte boundary
    and preventing data access beyond the end of the MMU page containing the string.
    This code achieves both of those requirements by using the bic instruction ❷ to
    set the LO 4 bits of the string pointer to 0\. Setting the LO 4 bits to 0 will
    align the pointer on the 16-byte boundary on or before the beginning of the string.
    Note that src (X1) might now point at up to 15 characters before the actual start
    of the string (which might contain some 0 bytes; this function will deal with
    that issue later). Because MMU pages always begin on a 4,096-byte boundary (which
    are also 16-byte boundaries), adjusting the pointer to the beginning of the 16-byte
    boundary will never produce a memory access outside the MMU page containing the
    start of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to aligning the pointer on a 16-byte boundary is that you
    don’t have to worry about accidental illegal memory accesses at the end of the
    MMU page. Because 4,096 is divisible by 16, loading 16 bytes at a time on 16-byte
    boundaries will never produce a memory access that crosses a page boundary. If
    the zero-terminating byte is anywhere within those 16 bytes, reading data to the
    end of the 16-byte block is safe. Clearing the LO 4 bits of the pointer thus allows
    safe memory accesses within an MMU page.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with aligning the src pointer to a 16-byte boundary is that doing
    so may change the pointer to point at memory *before* the start of the string.
    While this won’t create MMU page fault problems, it might cause the code to incorrectly
    compute the string’s length. At the very least, you don’t want to count any extra
    bytes before the start of the string, nor do you want to terminate the string-length
    calculation, because 0s appear in those earlier bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the code handles this in a clever way ❷. First, the ld1 instruction
    starts the process by loading 16 bytes from the aligned address in src. The cmeq
    instruction then locates every 0 byte in those 16, then stores 0xFF in the corresponding
    bytes of V1 (vhas_null) and 0s everywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: The shrn instruction shifts the compare mask bits to the right 4 bit positions.
    The even bytes now contain two comparison masks in the LO and HO nibbles, and
    the “narrowing” component of the instruction extracts those even bytes and packs
    them into the LO 8 bytes of V2 (for a total of 16 nibbles), which the fmov instruction
    copies into X2.
  prefs: []
  type: TYPE_NORMAL
- en: The lsl instruction (which I skipped discussing in the previous paragraph) is
    part of the code that deals with extra bytes appearing in the 16-byte block prior
    to the string. This multiplies the original address by 4; this will be an index
    into the nibbles held in X2, where the string will actually start (using only
    the LO 6 bits of the shifted value). The lsr instruction shifts the nibble mask
    to the right by the number of bits held in the LO 6 bits of X4 (shift). This removes
    the cmeq nibble masks from X2 for the bytes that appear before the start of the
    string. These lsl and lsr instructions allow the algorithm to ignore the (possible)
    extra bytes in the 16-byte block before the string.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting value in X2 will contain 0b1111 nibbles everywhere a 0 byte appears
    in the portion of the string held in V0 (vdata), and 0b0000 in all the other nibbles.
    In particular, X2 will contain 0 if there were no 0 bytes in the string in V0\.
    If X2 contains 0 (meaning no 0 bytes), the string’s terminating 0 byte must appear
    later in the string; in that case, the cbz instruction transfers control to label
    zloop.
  prefs: []
  type: TYPE_NORMAL
- en: If X2 does not contain 0, a 0b1111 nibble indicates the position of a 0 byte
    in the string. The rbit (reverse bits) instruction ❸ reverses all the bits in
    X2, and the clz instruction counts the number of leading 0s. Because each byte
    in the string is marked by 4 bits in X2, the count in X0 (result) is four times
    the length of the string. The lsr instruction shifts this count right by 2, which
    divides the bit count by 4, producing the string length.
  prefs: []
  type: TYPE_NORMAL
- en: The function then returns this length to the caller in X0\. This code handles
    the case where the string appears in the first block of bytes loaded into V0 (vdata).
    If the string is sufficiently long that the code must fetch another block of 16
    bytes from memory, the function transfers control to the code ❹. The code at zloop
    is responsible for processing blocks of 16 characters, where the first byte read
    from memory is part of the string (unlike the previous code, where the first 1–15
    bytes might not be part of the string). This loop rapidly scans through blocks
    of 16 bytes, looking for the first one that contains a 0\. As this loop takes
    five instructions to process 16 bytes (versus three instructions to process a
    single byte in the original string-length example), you would expect it to run
    approximately eight times faster than the single-byte-at-a-time code.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop finds a 0 byte somewhere in a block of 16 bytes ❺, it determines
    the position of the 0 byte (using the same technique as earlier ❷ ❸), adds the
    distance from the start of the string to the current 16-byte block, then adds
    the number of nonzero bytes in the current 16-byte block.
  prefs: []
  type: TYPE_NORMAL
- en: Although this code is tricky and complex, computing the length of a zero-terminated
    string is a common operation, so it’s worth the optimization work. You would be
    hard-pressed to improve on this algorithm when writing your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Again, because the *glibc* (GNU Library for C) authors have spent considerable
    time optimizing their ARM string functions, I highly recommend calling the C stdlib
    functions if they are appropriate for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 A String Format for Assembly Language Programmers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned many times in this book, the zero-terminated string is not the
    best string data type to use if you want to write the highest-performing code.
    Choosing a string format that incorporates the length, and possibly other information,
    as well as providing data alignment for the string data, can improve performance
    in many cases. This section introduces a sample format that provides these improvements.
  prefs: []
  type: TYPE_NORMAL
- en: The string format discussed in this section is based on the HLA string format
    (see section 4.6.2, “Length-Prefixed Strings,” on [page 188](chapter4.xhtml#pg_188)).
    HLA strings consist of two 32-bit length values followed by the character data
    and a zero-terminating byte. A string “variable” is just a pointer object that
    points to the first character of the string (or to a zero-terminating byte, if
    the string is empty).
  prefs: []
  type: TYPE_NORMAL
- en: The current length of the string (character count, not including the zero-terminating
    byte) appears at address ptr-4, and a maximum allocated space (for characters)
    value appears at address ptr-8 (where ptr is the pointer to the character data).
    Both length values are unsigned 32-bit values, supporting strings up to 4GB in
    length. For HLA, string objects are always aligned on a 4-byte boundary and the
    storage allocated for the string (and 0 byte) is always a multiple of 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For strings on a 64-bit CPU, a few changes are appropriate. First, the 4-byte
    maximum length and current length fields can remain. You probably don’t need strings
    that can hold more than four billion characters. The alignment should be on a
    16-byte boundary, allowing the use of Neon vector registers to efficiently process
    16 bytes at a time from memory. Finally, storage allocated for strings should
    always be a multiple of 16 bytes (to prevent problems when reading bytes beyond
    the end of the string). Here’s a first pass at a structure that defines this string
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this struct declaration and a pointer to a string object in X0, you can
    access the fields of the string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that X0 points directly at the first character of the string (if it isn’t
    empty), so you can reference the character data by using [x0] directly (you don’t
    need to use the string.chars field name, which turns out to be 0, anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would actually like to allocate storage for string data, or initialize
    some string storage with character data, the following two macros are useful (as
    a first approximation, with a minor modification to appear in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The str.buf macro will allocate storage for a string that can hold a maximum
    of maxSize characters (plus a zero-terminating byte). The .align directive ensures
    that the object begins on a 16-byte boundary (2⁴). It initializes the first word
    of the structure (string.maxlen) with maxSize passed as the argument. It creates
    an empty string by initializing the second 4 bytes (the string.len field) with
    0\. Finally, it allocates sufficient storage for maxSize + 1 characters (for the
    string data and a zero-terminating byte, initializing them to zeros) and additional
    storage to ensure that the whole data structure (including the string.maxlen and
    string.len fields) consumes a multiple of 16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example use of the str.buf macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The str.literal macro also creates string buffers, but instead of initializing
    it with the empty string, you can specify a string literal in the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that str.literal will initialize both the string.maxlen and string.len
    fields with the actual size of the string literal you supply.
  prefs: []
  type: TYPE_NORMAL
- en: This string data type has one small issue. Although the entire structure is
    aligned on a 16-byte boundary—and the whole structure is a multiple of 16 bytes
    long, at least when you create the buffers with the str.buf and str.literal macros—the
    first character of string data is actually at an address that is not a multiple
    of 16 (though it is a multiple of 8). To process string data 16 bytes at a time,
    you must either make a special case of the first 8 bytes or add another 8 bytes
    to the beginning of the structure (some additional fields or just 8 padding bytes).
    In the next section, you’ll see a modification of these two macros that adds an
    extra field for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 Dynamic String Allocation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As long as you use only the str.buf and str.literal macros to allocate storage
    for string variables, you don’t have to worry about alignment and MMU page issues;
    your string data structures will always be allocated on a 16-byte boundary (because
    of the .align 4 statement) and will always be a multiple of 16 bytes long. However,
    if you want to dynamically allocate storage for your strings (using the C stdlib
    malloc() function, for example), you must deal with data alignment and padding
    issues yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The C stdlib malloc() function makes no promises about the storage it allocates,
    other than it will return a pointer to *at least* the amount of storage you’ve
    requested if the function succeeds. In particular, the C stdlib doesn’t make any
    guarantees about the alignment of the storage you’ve requested. Also, malloc()
    may allocate a few bytes more than you’ve requested, but you can never count on
    this. If you want your storage to be allocated on a certain byte boundary (such
    as a 16-byte boundary), you’ll have to handle this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t guarantee that malloc() returns a properly aligned block, you
    can create a str.alloc function that does this for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  On entry, add 16 to the requested storage size to make room for any needed
    padding bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Call the malloc() function with the new allocation size.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Save the pointer that malloc() returns (you will need it to free the storage
    later).
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Add 15 to the pointer and clear the LO 4 bits of the sum; then add 16 so
    the pointer contains the address of the first character position in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Set the maxlen field as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Initialize the len field to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Store a zero-terminating byte at the first character position (to create
    an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Return the pointer to the first character position as the str.malloc result.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that deallocates the string storage is much simpler: all you need
    to do is fetch the allocated pointer (saved during the str.alloc call), then call
    the C stdlib free() function to free the storage. From where do you retrieve the
    allocated pointer value? The best place to keep it is within the string object
    data structure itself, as accomplished in the following modification of the string
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The header fields now consume 16 bytes, so the string.chars field will start
    on a 16-byte aligned boundary (assuming the whole structure is on a 16-byte boundary).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before providing the code to implement str.alloc and str.free, I’ll introduce
    one other useful string constructor function that str.alloc will use: str.bufInit.
    Its purpose is similar to the str.buf macro insofar as it initializes a memory
    buffer to hold a string object, but while you use str.buf to declare a static
    object in memory during assembly, str.bufInit allows you to initialize a block
    of memory at runtime. The str.bufInit function does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjusts the pointer passed to it so that the address held in the pointer is
    16-byte aligned (adding 0 to 15 to the pointer’s value if it is not already 16-byte
    aligned).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes the string.allocPtr field to 0 (NULL) to differentiate the buffer
    from one created by str.alloc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computes the string.maxlen field value based on the buffer size passed to the
    function, subtracting any padding bytes needed to achieve 16-byte alignment, as
    well as the 16 bytes required by the header field and any additional bytes needed
    to ensure that the whole structure is a multiple of 16 bytes long.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes the string.len field to 0 and stores a zero-terminating byte at
    the beginning of the character buffer area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before presenting the implementation of these string functions, a quick sidetrack
    is necessary to present the volatile_save structure the code will use to preserve
    registers. This structure appears in the *aoaa.inc* header file and takes the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Listing 14-1 contains the str.alloc and str.free functions, as well as updates
    to the str.buf and str.literal macros (to handle the string.allocPtr field). The
    listing uses the string structure (I gave earlier in this section) that includes
    the string.allocPtr field. For strings whose storage is allocated dynamically,
    this field will contain the allocation pointer that str.free will use when deallocating
    the string’s storage. For string objects that were not created on the heap, this
    field will contain NULL (0). This structure is the first major piece of code appearing
    in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The str.buf and str.literal macros contain minor modifications (to the macros
    with the same name given earlier in this chapter) that include storage for the
    allocPtr field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that both of these macros will initialize this field to NULL (0).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of the listing is the code section, beginning with the usual
    getTitle function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the str.bufInit function initializes a memory buffer for use as a string
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function expects a pointer to the buffer in X0 along with the buffer length
    in W1\. It initializes the fields of the string object and returns a pointer to
    the string object in X0\. The code begins by clearing the HO 32 bits of X1, so
    the code can work with 64-bit values ❶. It then adjusts the pointer passed in
    X0 to make it 16-byte aligned, by adding 16 and clearing the LO 4 bits of the
    sum ❷. This adjusts X0 to point at the next higher 16-byte aligned address if
    it wasn’t already so aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code adjusts the pointer to contain the address of the first byte
    of character data in the string (so that the other fields have negative offsets
    from the pointer) ❸. It then computes the new maxlen value by subtracting out
    the padding bytes (for 16-byte alignment) and the size of the fields preceding
    the character data ❹. The function returns an error if this difference is a negative
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The code ensures that the length of the character data is a multiple of 16 bytes
    (possibly further reducing the maxlen size) by clearing the LO 4 bits of the length
    value ❺. The function returns an error if the maxlen value turns out to be 0.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code initializes the fields of the string object (producing an
    empty string) ❻. Note that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: clears the carry flag (successful return) because adding 0 to anything never
    produces an unsigned overflow (carry). Also note that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: always sets the carry flag because the carry will be set after a comparison
    if the left value is greater than or equal to (higher than or the same as) the
    right value. Of course, for unsigned values, any value will always be greater
    than or equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Two functions in Listing 14-1, str.alloc and str.free, will call the C stdlib
    malloc() and free() functions. The str.alloc and str.free functions preserve all
    registers they modify that don’t contain explicit return values. However, because
    the malloc() and free() functions follow the ARM ABI, they are allowed to overwrite
    values in the volatile register set. To preserve the register values, the str.alloc
    and str.free functions must preserve the volatile registers by using the volatile_save
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up next is the str.alloc function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The local variable declaration str_alloc.vsave (type volatile_save ❶) will
    hold the preserved values of the volatile registers. Unfortunately, this structure
    is so large that you cannot directly access fields by using the [FP, #offset]
    addressing mode. Therefore, the code computes the address of the volatile_save.x0x1
    field into X1 and stores successive registers into the block pointed at by X1
    ❷. This code must initialize X1 prior to storing anything in str_alloc.vsave,
    so it first preserves X1 in a different local variable. Because the function returns
    the result in X0 and has to save X1 in a different location, this code doesn’t
    actually use the volatile_save.x0x1 field of str_alloc.vsave.'
  prefs: []
  type: TYPE_NORMAL
- en: The code saves all the volatile registers except X0 and X1 ❸. It uses the pre-increment
    addressing mode, so it skips over the volatile_save.x0x1 field when writing the
    X2 and X3 registers to the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code computes a string allocation size by adding 16 to maxlen (to
    cover the extra fields in the string data structure) ❹; it also adjusts the allocation
    size to be a multiple of 16 (greater than or equal to the requested size plus
    16). This ensures that the character data area is a multiple of 16 bytes long,
    so string-handling code can manipulate 16 bytes at a time without worrying about
    accessing data beyond the allocated storage.
  prefs: []
  type: TYPE_NORMAL
- en: The call to malloc() ❺ allocates the storage for the string object. This code
    checks for a NULL (0) return result and returns an error if malloc() fails. On
    success, the code initializes the fields of the string object and then returns
    a pointer to the object in X0 (with the carry clear on a successful call) ❻. Finally,
    the code restores all the volatile registers (except X0, which contains the function
    result) ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code includes the str.free function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The str.free function also calls a C stdlib function and therefore must preserve
    all the volatile registers. In fact, the preservation code ❶ ❺ makes up the bulk
    of the statements in this function.
  prefs: []
  type: TYPE_NORMAL
- en: The caller passes the address of an assembly string object in the X0 register
    to this function. However, this is not the address that the code passes to the
    C stdlib free() function; instead, this code fetches the address found in the
    string.allocPtr field to pass on to free() ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Before actually calling free(), the code first checks whether this pointer value
    is NULL ❸. A NULL string.allocPtr value means that the string wasn’t originally
    allocated with a call to str.alloc. If that’s the case, str.free simply returns
    (without registering an error), allowing code to call this function on dynamically
    and statically allocated objects. This is sometimes convenient when an arbitrary
    string pointer has been passed to a function that frees the storage without knowing
    how the storage was originally created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the str.free function calls the free() function ❹ to return the storage
    to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a main program example (along with some data) that tests the functions
    appearing in Listing 14-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The asmMain function provides a few simple examples of calls to the str.alloc,
    str.free, and str.bufInit functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command for Listing 14-1 and the sample program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code properly copied the static string to the dynamically
    allocated string.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.2 String Copy Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Listing 14-1 demonstrates the lack of perhaps the most important string function
    of all: one that copies character data from one string to another. This section
    presents str.cpy, the second-most-used string function (after string length, in
    my experience), which makes a copy of the data in one string variable and stores
    that data in a second string variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The str.cpy function must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the length of the source string against the maximum length of the destination
    string and return an error if the source string will not fit in the destination
    string variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the len field from the source string to the destination string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy len + 1 characters from the source string to the destination string, which
    will also copy the zero-terminating byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 14-2 provides the implementation of this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The str.cpy function is straightforward and efficient, almost entirely because
    of the design of the string data type (in particular, the alignment and padding
    requirements of the string). The code first checks to ensure that the current
    length of the source string is less than or equal to the maximum length allowed
    for the destination string ❶. If the source string’s length is too large, control
    transfers to the end of the function and it returns. The comparison will set the
    carry flag if the source length is “higher or same” as the destination maximum
    length. Therefore, this comparison automatically sets the carry flag to indicate
    a *string overflow* error if it branches because the string.len field is higher
    than the string.maxlen field. Because the new destination string will be a copy
    of the source string, the code then sets the destination string.len field to the
    source string’s length ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The code is responsible for copying the character data from the source string
    to the destination string ❸. This is a repeat...until loop, so it always copies
    16 bytes, even if the string length is 0\. That’s okay because the string data
    type always ensures that the character storage area is a multiple of 16 bytes
    long (including space for a zero-terminating byte). This loop may end up copying
    just the zero-terminating byte and 15 bytes of garbage data, but it will not access
    memory beyond the end of the string object’s storage.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the 16 bytes the loop copies ❸, the code decrements the length counter
    (W4) by 16\. The subs instruction sets the flags exactly as a cmp instruction
    would, so the bhi instruction repeats the loop as long as the value in W4 is greater
    than 16 (prior to the subs instruction). If the string’s length is a multiple
    of 16 bytes long, this loop will terminate after copying the last 16 bytes of
    the string (when W4 decrements to 0). In this situation, the beq instruction ❹
    transfers control to the code that will append the zero-terminating byte.
  prefs: []
  type: TYPE_NORMAL
- en: If the string’s length is not an integral multiple of 16, subtracting 16 will
    produce a result greater than 0 but less than 16 (meaning some characters remain
    left to copy from the source to the destination). Therefore, the code will fall
    through to the ldr/str instructions and copy the remaining bytes of the string
    (plus some garbage bytes).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code will store a zero-terminating byte to the end of the string
    ❺ in the event the previous ldr/str instructions didn’t copy that byte along with
    the character data.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Technically, the* beq *instruction in Listing 14-2 is unnecessary. If the
    string’s length is an exact multiple of 16 bytes long, at least 1 additional byte
    must be copied: the zero-terminating byte. Therefore, the data structure is guaranteed
    to contain at least 16 additional bytes, so falling through to the next pair of
    load and store instructions won’t create a problem. As an interesting experiment,
    you might determine whether removing the* beq *instruction improves or hurts the
    algorithm’s performance.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample program output for the code in Listing
    14-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although this string is shorter than 16 characters long and doesn’t fully test
    str.cpy, I’ve run this program with different source strings to verify that it
    works for larger strings.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 14.2.3 String Comparison Function'
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying strings, comparing strings is the string function you’ll likely
    use most often. To compare two character strings, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Extract a character at corresponding indices from both strings.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Compare the two characters. If they are not equal, the comparison is complete
    and the result of the string comparison is the result of this character comparison
    (not equal, less than, or greater than). If they are equal and not zero, repeat
    step 1.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If the two characters are both 0 bytes, the comparison is finished, and
    the two strings are equal.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm works for zero-terminated strings (and, because they are also
    zero-terminated, for the assembly language string format given in this chapter).
    Note that the comparison algorithm does not use the string-length value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a naive version of this string comparison in ARM64 assembly language
    that assumes X0 and X1 point at the string data to compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you saw with the strlen() function, processing multiple bytes at once using
    64- or 128-bit registers is usually much faster. Can you improve performance by
    using vector registers? The big problem with this is that vector comparisons check
    for a specific comparison (lt, le, eq, ne, gt, or ge). They don’t set the condition
    code flags, so you can use the conditional branches, which is what most programmers
    would prefer. That being the case, comparing eight characters at a time using
    64-bit general-purpose registers is probably the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: Given the efficiency of the glibc strlen() function, you might wonder whether
    its strcmp() function is also good. Listing 14-3 presents this function, with
    its operation explained in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The majority of the complexity is due to the code being written to handle string
    data that is not aligned to an 8-byte boundary. This string-comparison code could
    be written more simply if it could assume that the source and destination strings
    were always aligned on an 8-byte boundary. Because the assembly language string
    object is, by definition, always aligned on a 16-byte boundary, it is possible
    to write a more efficient comparison function for those strings. Listing 14-4
    provides such a str.cmp function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The str.cmp function does not modify the X0 or X1 registers, but it will modify
    X2 through X7, so this code begins by preserving these register values ❶. It then
    copies the values in X0 and X1 into X2 and X3 (respectively), which it will use
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing the strings, str.cmp will compare only to the length of the shorter
    string. The code computes the minimum length of the two strings ❷, leaving the
    result in W6\. If the two strings are equal to the length of the shorter string,
    the shorter string is considered less than the longer string.
  prefs: []
  type: TYPE_NORMAL
- en: The cmp8 loop compares the characters in the string 8 bytes at a time ❸. Strings
    are intrinsically a *big-endian* data structure, meaning the lower-order bytes
    in the string have the most-significant values. Therefore, you cannot simply load
    8 successive bytes into a pair of 64-bit registers and compare those registers;
    that would produce a little-endian comparison result. To resolve this issue, the
    code executes two rev instructions to swap the bytes in the two 64-bit registers
    prior to comparing them, resulting in a big-endian comparison.
  prefs: []
  type: TYPE_NORMAL
- en: After comparing the two dwords, the code branches to the return code if those
    dwords are not equal. At that point, the ARM condition codes will hold the result
    of the comparison. If the two dwords are equal, the cmp8 loop must repeat until
    it has exhausted all the characters or finds a pair of dwords that are not equal.
    The code subtracts 8 from W6 and repeats if the value prior to the subtraction
    was greater than or equal to 8 (remember, subs and cmp set the flags the same
    way) ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Because this code subtracts 8 from W6 before comparing the corresponding characters,
    if W6 winds up with 0, eight characters still remain to compare. That’s why this
    code repeats even when subtracting 8 produces a 0 result.
  prefs: []
  type: TYPE_NORMAL
- en: If the code falls down to ❺, the W6 contains a negative result. The code adds
    8 to this value to determine the number of characters it must still process. If
    the result is 0, the strings are the same length and all characters in the string
    are equal; in that case, the code exits (with the flags already containing appropriate
    values). If the result is nonzero, the code processes the remaining characters
    in the two strings one character at a time ❻. (Four instructions per character,
    for an average of four characters per string, assuming random string lengths,
    is usually faster than attempting to zero out the excess bytes and compare 8 bytes
    at a time.)
  prefs: []
  type: TYPE_NORMAL
- en: If the code transfers or drops through to cmpLens ❼, the strings were equal
    to the length of the shorter string. At this point, the code determines the result
    of the comparison by comparing the strings’ lengths.
  prefs: []
  type: TYPE_NORMAL
- en: The main program compares several strings to test the str.cmp function. The
    prtResult function ❽ is a short utility function that prints the result of the
    comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This code would be slightly more efficient if it preserved X0 and X1 rather
    than X2 and X3, then used X0 and X1 rather than X2 and X3\. However, I left X0
    and X1 alone because during development I used* printf() *to print some debugging
    messages. Feel free to change this code to use X0/X1 rather than X2/X3 if the
    two extra instructions (those that move X0 and X1 into X2 and X3) bother you.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case for the glibc strcmp() function, the str.cmp function expects
    pointers to the two strings to compare in X0 and X1\. The *left* string is X0,
    and the *right* string is X1\. Left and right have to do with their position in
    a comparison expression. The following example demonstrates the positions of the
    two strings in an if statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The strcmp() function returns a result in X0 indicating the result of the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: If X0 is negative, the left string (X0) is less than the right string (X1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If X0 is 0, the two strings are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If X0 is positive, the left string is greater than the right string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The str.cmp function, on the other hand, returns the comparison result in the
    condition code flags, so you can use the conditional branch instructions upon
    return to test the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 14-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, str.cmp returned the proper results for the test strings.  ####
    14.2.4 Substring Function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last ASCII example I’ll provide in this chapter is the substring function
    str.substr. A typical substring function extracts a portion of the characters
    from a string, creating a new string from the substring. It typically has four
    parameters: a pointer to a source string, an index into the substring where the
    extraction is to begin, a length specifying the number of characters to copy from
    the source, and a pointer to a destination string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The substring operation has several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t assume that the source characters are aligned on a 16-byte boundary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified starting index might be beyond the length of the source string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified substring length might extend beyond the end of the source string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the substring might exceed the maximum length of the destination
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first issue is often impossible to deal with. Most of the time, either the
    source characters or the destination characters will have an unaligned address.
    The str.substr code in this section will choose to keep the destination address
    aligned on a 16-byte boundary (which it gets by default). The function must carefully
    check the length while copying data to ensure that it doesn’t read any data beyond
    the end of the source-string data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle the second issue in two ways: either return an error code without
    copying any data or simply store an empty string into the destination. This latter
    solution is often the most convenient, and I rely on it in this section’s code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, there are two ways to handle the third issue: either return an error
    code without copying any data or copy all the characters from the starting index
    to the end of the source string into the destination string. Once again, the latter
    solution is often the most convenient, and the str.substr code relies on it.'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth issue is a bit more problematic. The str.substr code could truncate
    the string it copies, but this situation usually indicates a serious error on
    the part of the application (string overflow). Therefore, str.substr will return
    a flag in the carry to indicate success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you prefer to return an error status for the second and third issues listed
    here, you can easily modify* str.substr *to accomplish this.*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-5 provides the str.substr function and a sample main program that
    tests it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The str.substr function begins by finding any special cases it must handle.
    It first checks whether the starting index value is beyond the end of the source
    string; if so, the function returns the empty string as the result ❶. Next, the
    code checks whether the starting index plus the substring length would extend
    beyond the end of the source string; if so, it adjusts the length to reach to
    the end of the source string (and no farther) ❷. Finally, if the substring length
    is greater than the maximum length of the destination string, str.substr immediately
    returns with the carry flag set to indicate an error condition ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the special cases exist, the code can successfully copy a substring
    into the destination string. str.substr begins this process by setting the length
    of the destination string to the length of the substring ❹. The code then copies
    the substring data starting at the index position, beginning by adding the value
    of the index to the string pointer ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The loop copies 16 bytes at a time using the V0 vector register (Q0) ❻, as long
    as there are 16 or more bytes left to copy. When fewer than 16 bytes are left
    to copy, the code drops down to ❼ and adds 16 to the remaining length value (because
    the loop subtracted 16 one too many times).
  prefs: []
  type: TYPE_NORMAL
- en: After adding 16, W6 will contain a value in the range 0 to 15, the number of
    bytes left to copy. The code could have executed a simple loop to copy the remaining
    bytes one at a time to the destination, but that would be somewhat slow. Instead,
    I chose to execute a (simulated) switch statement to transfer control to one of
    16 labels ❽ where the code exists to carry out a straight-line, brute-force copy
    of the necessary bytes. (To reduce code size, I’ve interleaved these sections
    as much as possible, sharing various code sequences.)
  prefs: []
  type: TYPE_NORMAL
- en: Once they copy the necessary number of bytes, all these code sequences converge
    ❾ (also the location where the switch code transfers if 0 bytes are left to copy).
    This code appends a zero-terminating byte to the end of the string, clears the
    carry flag, and returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The code handles the special case in which str.substr returns an empty string
    because the index value was greater than the length of the source string ❿. This
    code sets the length of the destination string to 0, then transfers to ❾ to zero-terminate
    the string and return success. The asmMain function calls a special helper function
    (testSubstr) to perform various tests and print the results.
  prefs: []
  type: TYPE_NORMAL
- en: It is very unlikely that the start of the substring will lie on a 16-byte boundary.
    Therefore, when the function in Listing 14-5 fetches 16 bytes at a time from the
    source string, it will probably be an unaligned memory access (which is slower).
    Without writing a lot of code, you can’t do much about this other than accept
    that execution will be slightly slower. Because the accesses may not be aligned
    on a 16-byte boundary, it is important that this code copies only the specified
    number of bytes (never reading beyond the end of the source string) to ensure
    it doesn’t access an inappropriate memory page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the build command and sample output for the program in Listing 14-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While this isn’t an exhaustive test by any means, this output is sufficient
    to show the basic operation of str.substr.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.5 More String Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, any decent string library has many additional string functions.
    A str.len function is the most obvious function missing thus far. The implementation
    of this function should be fairly obvious: just fetch the string.len field from
    the string data structure. Even ignoring this oversight, however, there are dozens
    of other string functions you might want to use (the HLA standard library, for
    example, provides over 200 string functions).'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this book doesn’t have room to describe a complete set of string
    library functions. After reading this chapter, you should possess the skills needed
    to implement any string functions you need on your own. See section 14.6, “For
    More Information,” on [page 859](chapter14.xhtml#pg_859) for further resources
    to help you do so.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 The Unicode Character Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All code examples up to this point in this book have assumed that strings in
    assembly language consist of sequences of ASCII characters, largely because Gas
    doesn’t directly support Unicode. However, Linux and macOS systems generally work
    with Unicode (though ASCII is a subset of Unicode). Now that you’ve seen how to
    implement string functions for ASCII characters, it’s time to expand on [Chapter
    2](chapter2.xhtml)’s cursory introduction to Unicode and discuss string functions
    for Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.1 Unicode History
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A few decades back, engineers at Aldus Corporation, NeXT, Sun Microsystems,
    Apple Computer, IBM, Microsoft, the Research Libraries Group, and Xerox realized
    that their new computer systems with bitmaps and user-selectable fonts could display
    far more than 256 characters at one time. At the time, *double-byte character
    sets (DBCSs)* were the most common solution.
  prefs: []
  type: TYPE_NORMAL
- en: DBCSs had a couple of issues, however. First, as they were typically variable-length
    encodings, they required special library code; common character or string algorithms
    that depended on fixed-length character encodings would not work properly with
    them. Second, no consistent standard existed; different DBCSs used the same encoding
    for different characters.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these compatibility problems, the engineers sought a different solution.
    They came up with the Unicode character set, which originally used a 2-byte character
    size. Like DBCSs, this approach still required special library code (existing
    single-byte string functions would not always work with 2-byte characters). Other
    than changing the size of a character, however, most existing string algorithms
    would still work with 2-byte characters. The Unicode definition included all the
    (known or living) character sets at the time, giving each character a unique encoding,
    to avoid the consistency problems that plagued differing DBCSs.
  prefs: []
  type: TYPE_NORMAL
- en: The original Unicode standard used a 16-bit word to represent each character.
    Therefore, Unicode supported up to 65,536 character codes—a huge advance over
    the 256 possible codes representable with an 8-bit byte. Furthermore, Unicode
    is upward compatible from ASCII. If the HO 9 bits of a Unicode character’s binary
    representation contain 0, the LO 7 bits use the standard ASCII code. (ASCII is
    a 7-bit code, so if the HO 9 bits of a 16-bit Unicode value are all 0, the remaining
    7 bits are an ASCII encoding for a character.) If the HO 9 bits contain a nonzero
    value, the 16 bits form an extended character code, above and beyond the ASCII
    character set.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why so many character codes are necessary. When Unicode
    was first being developed, certain Asian character sets contained 4,096 characters.
    The Unicode character set even provided codes you could use to create an application-defined
    character set. Approximately half of the 65,536 possible character codes have
    been defined, and the remaining character encodings are reserved for future expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Unicode is a universal character set, long replacing ASCII and older
    DBCSs. All modern OSes (including macOS, Windows, Linux, Pi OS, Android, and Unix),
    all web browsers, and most modern applications provide Unicode support. The Unicode
    Consortium, a nonprofit corporation, maintains the Unicode standard. By maintaining
    the standard, the consortium helps guarantee that a character you write on one
    system will display as you expect on a different system or application.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.2 Code Points and Code Planes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Alas, as well-thought-out as the original Unicode standard was, its creators
    couldn’t have anticipated the subsequent explosion in characters. Emojis, astrological
    symbols, arrows, pointers, and a wide variety of symbols introduced for the internet,
    mobile devices, and web browsers—along with a desire to support historic, obsolete,
    and rare scripts—have greatly expanded the Unicode symbol repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, systems engineers discovered that 65,536 symbols were insufficient.
    Rather than require 3 or 4 bytes for each Unicode character, those in charge of
    the Unicode definition gave up on trying to create a fixed-size representation
    of characters and allowed for opaque (and multiple) encodings of Unicode characters.
    Today, Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity
    originally set aside for Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: A Unicode *code point* is simply an integer value associated with a particular
    character symbol; you can think of it as the Unicode equivalent of the ASCII code
    for a character. The convention for Unicode code points is to specify the value
    in hexadecimal with a U+ prefix. For example, U+0041 is the Unicode code point
    for the letter A.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks of 65,536 characters are known as a *multilingual plane* in Unicode.
    The first multilingual plane, U+000000 to U+00FFFF, roughly corresponds to the
    original 16-bit Unicode definition; the Unicode standard calls this the *Basic
    Multilingual Plane (BMP)*. Planes 1 (U+010000 to U+01FFFF), 2 (U+020000 to U+02FFFF),
    and 14 (U+0E0000 to U+0EFFFF) are supplementary planes. Plane 3 (U+030000 to U+03FFFF)
    is the *Tertiary Ideographic Plane* (see *[https://<wbr>unicode<wbr>.org<wbr>/roadmaps<wbr>/tip<wbr>/](https://unicode.org/roadmaps/tip/)*).
    Unicode reserves planes 4 through 13 for future expansion and planes 15 and 16
    for user-defined character sets.
  prefs: []
  type: TYPE_NORMAL
- en: The Unicode standard defines code points in the range U+000000 to U+10FFFF.
    Note that 0x10ffff is 1,114,111, which is where most of the 1,112,064 characters
    in the Unicode character set come from; the remaining 2,048 values form the *surrogate
    code points*.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.3 Surrogate Code Points
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding.
    When it became apparent that 16 bits were insufficient to handle all the possible
    characters that existed at the time, an expansion was necessary. As of Unicode
    v2.0, the Unicode Consortium extended the definition of Unicode to include multiword
    characters. Now Unicode uses surrogate code points (U+D800 through U+DFFF) to
    encode values larger than U+FFFF, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: Surrogate code-point encoding for Unicode planes 1–16'
  prefs: []
  type: TYPE_NORMAL
- en: The two words, unit 1 (high surrogate) and unit 2 (low surrogate), always appear
    together. The unit 1 value with HO bits 0b110110 specifies the upper 10 bits (b10
    through b19) of the Unicode scalar, and the unit 2 value with HO bits 0b110111
    specifies the lower 10 bits (b0 through b9) of the Unicode scalar. Therefore,
    the value of bits b16 to b19 plus 1 specifies Unicode planes 1 through 16\. Bits
    b0 through b15 specify the Unicode scalar value within the plane.
  prefs: []
  type: TYPE_NORMAL
- en: Note that surrogate codes appear only in the BMP. None of the other multilingual
    planes contain surrogate codes. Bits b0 through b19 extracted from the unit 1
    and 2 values always specify a Unicode scalar value (even if the values fall in
    the range U+D800 through U+DFFF).
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.4 Glyphs, Characters, and Grapheme Clusters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each Unicode code point has a unique name. For example, U+0045 has the name
    LATIN CAPITAL LETTER A. The symbol A is *not* the name of the character. A is
    a *glyph*, a series of strokes (one horizontal and two slanted strokes) that a
    device draws in order to represent the character.
  prefs: []
  type: TYPE_NORMAL
- en: Many glyphs exist for the single Unicode character LATIN CAPITAL LETTER A. For
    example, a Times Roman A and a Times Roman Italic A have different glyphs, but
    Unicode doesn’t differentiate between them (or between the A character in any
    two different fonts). The character LATIN CAPITAL LETTER A remains U+0045 regardless
    of the font or style you use to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *character* has a simple meaning when working with ASCII. The character
    code 0x41 corresponds to the LATIN CAPITAL LETTER A, which has a consistent representation
    when it appears on a display screen; in particular, a one-to-one correspondence
    exists between ASCII character codes and the symbol a user expects to see on the
    display. The situation is dramatically more complex when working with Unicode.
    There’s a difference between what you’d normally call a character and the definition
    of a Unicode character (*scalar* in Unicode terminology). For example, consider
    the following Swift code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This section uses the Swift programming language for examples because it is
    one of the first programming languages that attempts to do Unicode right (though
    a huge performance hit results from it). Assembly, on the other hand, requires
    the programmer to handle everything manually and isn’t the best tool for many
    Unicode examples. I explain how to translate this to assembly code in section
    14.4, “Unicode in Assembly Language,” on [page 853](chapter14.xhtml#pg_853).
  prefs: []
  type: TYPE_NORMAL
- en: The Swift syntax for specifying a Unicode scalar value within a string is "\u{hex}",
    where hex is a hexadecimal value, as in "\u{301}". In this example, 301 is the
    hexadecimal code for the *combining acute accent* character. The first print()
    statement prints the character, producing é on the output, as you expect. The
    second print() statement prints the number of characters Swift determines are
    present in the string—in this case, 1. The third print() statement prints the
    number of elements (UTF-16 elements, discussed further later in this section)
    in the string. In this case, that number is 2, because the string holds 2 words
    of UTF-16 data.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, is é one character or two? Internally (assuming UTF-16 encoding),
    the computer sets aside 4 bytes of memory for this single character (two 16-bit
    Unicode scalar values). On the screen, however, the output takes only one character
    position and looks like a single character to the user. When this character appears
    within a text editor and the cursor is immediately to the right of the character,
    the user expects that pressing BACKSPACE will delete it. From the user’s perspective,
    then, this is a single character (as Swift reports when you print the count attribute
    of the string).
  prefs: []
  type: TYPE_NORMAL
- en: In Unicode, however, a *character* is largely equivalent to a code point. In
    Unicode terminology, when you talk about symbols that an application displays
    to an end user, you refer to them not as characters but as *grapheme clusters*.
    These are sequences of one or more Unicode code points that combine to form a
    single language element (that is, something that appears as a single character
    to the user on the display, such as é).
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.5 Normal Forms and Canonical Equivalence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Unicode character é actually existed on personal computers long before
    Unicode came along: it’s part of the original IBM PC character set and of the
    Latin-1 character set (used, for example, on old DEC terminals). Unicode uses
    the Latin-1 character set for the code points in the range U+00A0 to U+00FF, and
    U+00E9 just happens to correspond to the é character. Therefore, you can modify
    the earlier program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs from this program are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Ouch! You now have a couple of strings that all produce é but contain a different
    number of code points. Imagine how this complicates programming strings containing
    Unicode characters. For example, if you try to compare the following three strings
    (Swift syntax), what will the result be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To the user, both strings look the same on the screen. However, they clearly
    contain different values. If you compare them to see whether they are equal, will
    the result be true or false?
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, that depends on which string libraries you’re using. Most current
    string libraries would return false if you compared these strings for equality.
    Many languages’ string libraries simply report that both strings are unequal.
  prefs: []
  type: TYPE_NORMAL
- en: The two Unicode/Swift strings "\{E9}" and "e\{301}" should produce the same
    output on the display. Therefore, they are canonically equivalent according to
    the Unicode standard. Some string libraries won’t report any of these strings
    as being equivalent. Some, like the one accompanying Swift, will handle small
    canonical equivalences (such as "\{E9}" == "e\{301}") but not arbitrary sequences
    that should be equivalent. (This is probably a good balance of correctness versus
    efficiency; it can be computationally expensive to handle all the weird cases
    that won’t normally happen, such as "e\{301}\{301}".)
  prefs: []
  type: TYPE_NORMAL
- en: Unicode defines *normal forms* for Unicode strings. One aspect of normal form
    is to replace canonically equivalent sequences with an equivalent sequence—for
    example, replace "e\u{309}" with "\u{E9}" or vice versa (the shorter form is usually
    preferable). Some Unicode sequences allow multiple combining characters. Often,
    the order of the combining characters is irrelevant to producing the desired grapheme
    cluster. However, comparing two such characters is easier if the combining characters
    are in a specified order. Normalizing Unicode strings may also produce results
    whose combining characters always appear in a fixed order, thereby improving the
    efficiency of string comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.6 Encodings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As of Unicode 2.0, the standard supports a 21-bit character space capable of
    handling over a million characters (though most of the code points remain reserved
    for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding
    to allow the larger character set, the Unicode Consortium allows different encodings:
    UTF-32, UTF-16, and UTF-8 (*UTF* stands for *Unicode Transformation Format*).
    Each of these three encodings comes with advantages and disadvantages.'
  prefs: []
  type: TYPE_NORMAL
- en: '*UTF-32* uses 32-bit integers to hold Unicode scalars. The advantage to this
    scheme is that a 32-bit integer can represent every Unicode scalar value in only
    21 bits. Programs that require random access to characters in strings—without
    having to search for surrogate pairs—and other constant-time operations are usually
    possible when using UTF-32\. The obvious drawback to UTF-32 is that each Unicode
    scalar value requires 4 bytes of storage—twice that of the original Unicode definition
    and four times that of ASCII characters.'
  prefs: []
  type: TYPE_NORMAL
- en: It may seem that using two or four times as much storage (over ASCII and the
    original Unicode) is a small price to pay. After all, modern machines have several
    orders of magnitude more storage than they did when Unicode first appeared. However,
    that extra storage has a huge impact on performance, because those additional
    bytes quickly consume cache storage. Furthermore, modern string-processing libraries
    often operate on character strings 8 bytes at a time (on 64-bit machines). With
    ASCII characters, that means a given string function can process up to eight characters
    concurrently; with UTF-32, that same string function can operate on only two characters
    concurrently. As a result, the UTF-32 version will run four times slower than
    the ASCII version. Ultimately, even Unicode scalar values are insufficient to
    represent all Unicode characters (that is, many Unicode characters require a sequence
    of Unicode scalars), so using UTF-32 doesn’t solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, the second encoding format that Unicode supports, *UTF-16*,
    uses 16-bit (unsigned) integers to represent Unicode values. To handle scalar
    values greater than 0xFFFF, UTF-16 uses the surrogate-pair scheme to represent
    values in the range 0x010000 to 0x10FFFF. Because the vast majority of useful
    characters fit into 16 bits, most UTF-16 characters require only 2 bytes. For
    those rare cases where surrogates are necessary, UTF-16 requires two words (32
    bits) to represent the character.
  prefs: []
  type: TYPE_NORMAL
- en: The last encoding, and unquestionably the most popular, is *UTF-8*. The UTF-8
    encoding is forward-compatible from the ASCII character set. In particular, all
    ASCII characters have a single-byte representation (their original ASCII code,
    where the HO bit of the byte containing the character contains a 0 bit). If the
    UTF-8 HO bit is 1, UTF-8 requires 1 to 3 additional bytes to represent the Unicode
    code point.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 14-1](chapter14.xhtml#tab14-1) provides the UTF-8 encoding schema, where
    the *x* bits are the Unicode point bits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: UTF-8 Encoding'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bytes | Bits for code point | First code point | Last code point | Byte 1
    | Byte 2 | Byte 3 | Byte 4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 7 | U+00 | U+7F | 0xxxxxxx |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 11 | U+80 | U+7FF | 110xxxxx | 10xxxxxx |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 16 | U+800 | U+FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 21 | U+10000 | U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
  prefs: []
  type: TYPE_TB
- en: For multibyte sequences, byte 1 contains the HO bits, byte 2 contains the next
    HO bits (LO bits compared to byte 1), and so on. For example, the 2-byte sequence
    (0b11011111, 0b10000001) corresponds to the Unicode scalar 0b0000_0111_1100_0001
    (U+07C1).
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 encoding is probably the most common encoding in use, since most web pages
    use it. Most C stdlib string functions will operate on UTF-8 text without modification
    (although some can produce malformed UTF-8 strings if the programmer isn’t careful).
  prefs: []
  type: TYPE_NORMAL
- en: Different languages and OSes default to using different encodings. For example,
    macOS and Windows tend to use UTF-16 encoding, whereas most Unix systems use UTF-8\.
    Some variants of Python use UTF-32 as their native character format. By and large,
    though, most programming languages use UTF-8 because they can continue to use
    older ASCII-based character-processing libraries to process UTF-8 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3.7 Combining Characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU
    overhead and algorithmic complexities of dealing with multibyte (or multiword)
    character sets complicates their use, introducing bugs and performance issues.
    Despite the issues of wasting memory, especially in the cache, why not simply
    define characters as 32-bit entities and be done with it? This seems like it would
    simplify string-processing algorithms, improving performance and reducing the
    likelihood of defects in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this theory is that you cannot represent all possible grapheme
    clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters
    consist of several concatenated Unicode code points. Here’s an example from Chris
    Eidhof and Ole Begemann’s *Advanced Swift*, version 3.0 (CreateSpace, 2017):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these Unicode grapheme clusters produces the same output: Ò., (a character
    from the Yoruba character set). The character sequence (U+1ECD, U+300) is an o.
    followed by a combining acute. The character sequence (U+F2, U+323) is an ò followed
    by a combining dot. The character sequence (U+6F, U+323, U+300) is an o followed
    by a combining dot, followed by a combining acute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Swift string comparisons treat all four strings as equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: No single Unicode scalar value will produce this character. You must combine
    at least two Unicode scalars (or as many as three) to produce this grapheme cluster
    on the output device. Even UTF-32 encoding would still require two (32-bit) scalars
    to produce this particular output.
  prefs: []
  type: TYPE_NORMAL
- en: Emojis present another challenge that can’t be solved using UTF-32\. Consider
    the Unicode scalar U+1F471\. This prints an emoji of a person with blond hair.
    If you add a skin-color modifier, you obtain (U+1F471, U+1F3FF), which produces
    a person with a dark skin tone and blond hair. In both cases, a single character
    displays on the screen. The first example uses a single Unicode scalar value,
    but the second example requires two. There is no way to encode this with a single
    UTF-32 value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is that certain Unicode grapheme clusters require multiple
    scalars, no matter how many bits you assign to the scalar (it’s possible to combine
    30 or 40 scalars into a single grapheme cluster, for example). That means you’re
    stuck dealing with multiword sequences to represent a single “character,” regardless
    of how hard you try to avoid it. This is why UTF-32 has never really taken off:
    it doesn’t solve the problem of random access into a string of Unicode characters.
    When normalizing and combining Unicode scalars, using UTF-8 or UTF-16 encodings
    is more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, most languages and OSes today support Unicode in one form or another
    (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems with
    dealing with multibyte character sets, modern programs need to deal with Unicode
    strings rather than simple ASCII strings.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Unicode in Assembly Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in section 2.17, “Gas Support for the Unicode Character Set,” on [page
    102](chapter2.xhtml#pg_102)), Gas doesn’t provide especially good support for
    Unicode strings. If you have a text editor that allows you to enter Unicode text
    into a source file, you might be able to type non-ASCII UTF-8 characters into
    a string constant and have Gas accept them. In general, though, the safest way
    to insert non-ASCII Unicode characters into an assembly language source file is
    to use hexadecimal constants. This section describes how to output Unicode characters
    from a console application and provides a brief introduction to Unicode string
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4.1 Writing Console Applications with UTF-8 Characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To be able to print strings containing UTF-8 characters, you must ensure that
    your OS is able to accept them. This is generally accomplished by using the C
    stdlib setlocale() function. Unfortunately, the parameter list varies by locale,
    so I can’t provide a universal example that works everywhere. For US English,
    I typically use the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact string for the second parameter will vary based on the country and
    language. You can search online for a description of the setlocale() function
    for more details about calling this function (or see section 14.6, “For More Information,”
    on [page 859](chapter14.xhtml#pg_859)). The following Linux/macOS command will
    list the available locale strings for your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the strings produced by this command under macOS (on a Mac
    mini M1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See “For More Information” for an explanation of the locale string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could call setlocale() from your assembly language code, but I’ve found
    it more convenient to modify the *c.cpp* program that the *build* script uses.
    The following shows this modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Listing 14-6 presents a trivial program that demonstrates example text output
    containing UTF-8, to be compiled and linked with *c-utf8.cpp*. This example prints
    the UTF-8 sequence U+65 (lowercase e) followed by U+301 (combining acute accent
    character).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that the UTF-8 encoding for U+301 requires 2 bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: where B[11] down to B[0] is 0x301 or 0b011_0000_0001\. Therefore, the two UTF-8
    bytes are 0b1100_1100 (0xCC) and 0b10000001 (0x81).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 14-6 (assuming that
    *c-utf8.cpp* has been renamed to *c.cpp*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the character sequence e, 0xcc, 0x89 produces the accented é
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4.2 Using Unicode String Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As long as you stick with UTF-8 encoding, character string functions that operate
    on ASCII strings will *mostly* work with Unicode strings. You should be aware
    of a few issues, though:'
  prefs: []
  type: TYPE_NORMAL
- en: Unless you keep strings in a canonical form, some string comparisons may report
    that two strings are not equal when, in fact, they would appear equal to the reader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String comparison for *less than* and *greater than* will likely produce nonintuitive
    results because ASCII comparisons don’t work well in the face of Unicode scalars
    whose values consume 2 or more bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string-length calculation (when using zero-terminated or the assembly language
    string data type) will report the number of *bytes* in the string, not the number
    of characters (scalars or glyphs). Unless the string contains only ASCII characters,
    the length calculation will be wrong. The only reasonable way to count characters
    in a Unicode string is to process each glyph one at a time and count the glyphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that accept indices into a string generally require glyph indices,
    not byte indices. For example, the str.substr function given earlier could extract
    a substring containing a portion of a glyph at the beginning of the string, or
    chop a glyph in half at the end of the string, if the index and length parameters
    aren’t carefully chosen. Functions that insert glyphs into a string or delete
    characters from a string will suffer from this same problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these issues (and more), it’s dangerous to use ASCII-based string
    functions on Unicode and UTF-8 strings. It goes without saying that ASCII-based
    functions will not work on UTF-16 or UTF-32 encodings of Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Section 14.6, “For More Information,” on the next page provides links to several
    string libraries (mostly written on C/C++) that process Unicode strings. The International
    Components for Unicode (UCI) library is important to consider, since it’s the
    library provided by the Unicode Consortium. At the time of writing, this library
    (ICU74.2) claims the following support:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of the Unicode standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character set conversions with support for over 220 code pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locale data for more than 300 locales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language-sensitive text collation (sorting) and searching based on the Unicode
    Collation Algorithm (ISO 14651)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expression matching and Unicode sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformations for normalization, upper- and lowercase, script transliterations
    (50+ pairs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource bundles for storing and accessing localized information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/number/message formatting and parsing of culture-specific input/output
    formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calendar-specific date and time manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text boundary analysis for finding character, word, and sentence boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this isn’t a complete set of string functions you’d expect in a typical
    programming language, it does provide all the basic operations needed to correctly
    implement a full set of functions. Also keep in mind that Unicode string functions
    aren’t particularly fast. Unfortunately, because of the design of the Unicode
    character set (and multibyte character sets in general), you have to process each
    and every character in a string to accomplish mundane tasks. Only a few functions,
    like str.cpy, can work without scanning over every character in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered string data structures (zero-terminated and special assembly
    language strings), calling C stdlib string functions from assembly, writing assembly
    language–based string functions, and using the Unicode character set (and Unicode
    string functions).
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses managing large projects in assembly language, particularly
    how to create library modules, which will prove useful for combining several string
    functions into a single library module.
  prefs: []
  type: TYPE_NORMAL
- en: '### 14.6 For More Information'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Unicode website is the main source for information about all things
    concerning the Unicode standard. This is the closest thing to an official Unicode
    library: *[https://<wbr>icu<wbr>.unicode<wbr>.org<wbr>/home](https://icu.unicode.org/home)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU offers a Unicode string library at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libunistring<wbr>/manual<wbr>/libunistring<wbr>.html](https://www.gnu.org/software/libunistring/manual/libunistring.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the source code for the functions from the GNU C stdlib for AARCH64
    discussed in this chapter at *[https://<wbr>github<wbr>.com<wbr>/bminor<wbr>/glibc<wbr>/tree<wbr>/master<wbr>/sysdeps<wbr>/aarch64](https://github.com/bminor/glibc/tree/master/sysdeps/aarch64)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the GitHub repository containing the source code for the glibc string functions
    written in ARM assembly, see *[https://<wbr>github<wbr>.com<wbr>/ARM<wbr>-software<wbr>/optimized<wbr>-routines<wbr>/tree<wbr>/master<wbr>/string<wbr>/aarch64](https://github.com/ARM-software/optimized-routines/tree/master/string/aarch64)*.
    You can study this code to learn advanced string-handling tricks in assembly language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For help writing ARM string-handling functions in assembly language, you can
    post questions to a forum I’ve set up at *[https://<wbr>forums<wbr>.randallhyde<wbr>.com](https://forums.randallhyde.com)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a list of various Unicode string libraries, see *[https://<wbr>unicodebook<wbr>.readthedocs<wbr>.io<wbr>/libraries<wbr>.html#libunistring](https://unicodebook.readthedocs.io/libraries.html#libunistring)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia offers more detail on Unicode code points at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Unicode#General<wbr>_Category<wbr>_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My website links to information on the HLA string library (x86): *[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/HLADoc<wbr>/index<wbr>.html](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/HLADoc/index.html)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM Developer assembly language string library source code can be found at *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102620<wbr>/0100<wbr>/Optimized<wbr>-string<wbr>-routines<wbr>-<wbr>-<wbr>-libastring](https://developer.arm.com/documentation/102620/0100/Optimized-string-routines---libastring)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on the setlocale() function, see *[https://<wbr>man7<wbr>.org<wbr>/linux<wbr>/man<wbr>-pages<wbr>/man3<wbr>/setlocale<wbr>.3<wbr>.html](https://man7.org/linux/man-pages/man3/setlocale.3.html)*.
    For an explanation of the locale string format, see *[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/javase<wbr>/8<wbr>/docs<wbr>/api<wbr>/java<wbr>/util<wbr>/Locale<wbr>.html](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html)*
    (or search for **locale function**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
