- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASSESSING SECURITY
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you’ve put your security measures in place, you need to make sure they’re
    actually protecting your assets. As discussed in [Chapter 6](ch06.xhtml), complying
    with laws and regulations doesn’t actually mean you’re secure. Since that’s the
    case, how can you assess the true level of your security? You have two primary
    vehicles for doing so: vulnerability assessment and penetration testing. In this
    chapter, I’ll discuss these two methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability Assessment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *vulnerability assessment* is a process that uses a specially designed tool
    to scan for vulnerabilities. Two common vulnerability assessment tools are Qualys
    and Nessus. To create these tools, vendors must do a great deal of legwork to
    catalog vulnerabilities, determine which platforms and applications the vulnerabilities
    apply to, and classify them by severity. The vendors will also often provide additional
    information along with them about the potential impact of the vulnerabilities,
    how to fix them, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the work that goes into keeping them up-to-date, some of these tools
    can be rather expensive. Since vulnerabilities are in a constant state of flux,
    vendors need to constantly keep up with changes to the vulnerabilities, patches
    being issued for them, new variants that appear, and a dizzying array of other
    factors in flux. Without these constant updates, these tools will quickly fall
    out of usefulness and be unable to detect new vulnerabilities or provide accurate
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the results of a vulnerability assessment will give you only one
    bit of information about whether you’re secure—namely, it will tell you whether
    there are specific known vulnerabilities existing on each of your hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting a vulnerability assessment takes several steps, outlined in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mapping and Discovery*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be able to scan for vulnerabilities, you need to know what devices you have
    in your environments. Typically, you conduct scans against groups or ranges of
    hosts, which change over time. If you don’t have some method of keeping your lists
    of hosts up-to-date, you’ll get incomplete scan results, or you may scan the wrong
    hosts entirely. This can be a particular issue with hosts in the cloud, which
    I’ll come back to later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Environments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Start your vulnerability scanning efforts by creating a map of your environment
    that shows you what devices are present in your network. Most vulnerability scanning
    tools let you directly create such a map; otherwise, you can import host information
    from tools built specifically for this purpose, such as Nmap (*[https://nmap.org/](https://nmap.org/)*).
  prefs: []
  type: TYPE_NORMAL
- en: Often, tools create these maps by interrogating every single IP address in the
    network range you’re building a map for. For large network ranges, this can take
    a long time—perhaps more time than it will take for a host to appear and disappear
    again. For example, a *class A* internal network, commonly recognizable by having
    IP addresses in the 10.0.0.0 to 10.255.255.255 range, can hold more than 16 million
    IP addresses. Another common internal network scheme, a *class B* network, which
    commonly uses IPs that look like 192.168.0.0, can hold more than 65,000 hosts.
    It’s not uncommon for an environment to use a class A and several class B networks
    for segmentation purposes. Since most tools take a second or two per IP to interrogate
    each address while discovering hosts, you’ll be at it for a quite a while.
  prefs: []
  type: TYPE_NORMAL
- en: Performing these discovery scans can also be stressful to your network infrastructure
    if you’re not careful to do so slowly. While mapping a network, it’s entirely
    possible to overload network devices, such as routers and switches, to the point
    they become nonresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering New Hosts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In addition to mapping to figure out what’s there in the first place, you also
    need to keep your lists of hosts up-to-date. If you know the locations of any
    new devices on your networks, you can look in those specific places, but you may
    miss some hosts if they’re not where you expect them to be—particularly if they’ve
    been placed somewhere odd in order to hide them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can actively or passively discover new hosts. *Active* discovery involves
    a process similar to the one used to map the network in the first place: you go
    IP by IP and interrogate each to see whether anything responds. This has many
    of the same limitations mapping does, but you could restrict these updates to
    portions of the network you know to contain devices, in the interest of being
    able to get through a network range more quickly and at shorter intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use *passive* scanning techniques to discover devices on the network.
    This often involves placing a device at network choke points, such as routers
    or switches, to eavesdrop on the traffic flowing through your infrastructure.
    In this way, you’ll automatically discover devices as they talk on the network
    and can automatically add them to your lists of hosts to scan.
  prefs: []
  type: TYPE_NORMAL
- en: '*Scanning*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you know what hosts you have, you can scan them for vulnerabilities. There
    are a few different types of scans you can conduct, as well as different methods
    you can use for each.
  prefs: []
  type: TYPE_NORMAL
- en: Unauthenticated Scans
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A basic vulnerability scan of a host is typically an external and unauthenticated
    scan. These types of scans don’t require any credentials for the host you’re scanning
    or any access other than network connectivity to the host in question. This allows
    you to conduct the scan against almost any device. Depending on the settings of
    the scan, it will often show you what ports are open on the host in question,
    reveal the banner information for the services listening on those ports, and guess
    at the applications and operating systems in use, based on the other information
    gathered.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated Scans
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can also perform authenticated scans against hosts. An *authenticated scan*
    is one that is conducted using a valid set of credentials, generally administrative,
    for the system being scanned. Having credentials to log into a host will often
    let you collect internal information, such as what software is installed, the
    contents of configuration files, the permissions on files and directories, the
    vulnerability patches that the system needs but doesn’t currently have, and other
    information. This gives you a considerably more thorough view of the device and
    its potential vulnerabilities than you can see from the outside, generating a
    considerably more accurate picture of the security of the device.
  prefs: []
  type: TYPE_NORMAL
- en: However, authenticated scans require you to keep your authentication credentials
    current, both on the vulnerability scanning tool end and on the hosts themselves.
    Some of the checks will also require administrative access to the device, and
    some system owners may be reluctant to give you credentials with this broad level
    of access.
  prefs: []
  type: TYPE_NORMAL
- en: Agented Scans
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Agented scans can provide a means to get around some of the downsides of authenticated
    scans. An *agent* is a small piece of software installed on each host. The software
    runs as though it were a user on the system, so it’s authenticated, but it doesn’t
    require you to maintain a separate set of credentials on the device or in the
    vulnerability scanning tool.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of using agents is that hosts configured with them typically
    report to the management devices on their own, thus removing some of the need
    to search for the devices individually on your networks. While it doesn’t remove
    the need entirely, because some devices, such as network appliances, may not be
    able to run an agent, it should ease your burden quite a bit, as most or all the
    devices you expect to be present should identify themselves automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Application Scanning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some tools allow you to scan specific applications. For example, many well-developed
    scanners exist solely for scanning web applications. These types of scans are
    specific to web technologies and vulnerabilities and can search considerably more
    deeply in the application for issues than a scanner intended strictly for hosts
    would be able to find. You will often find web application scanners to be one
    of the more deeply developed application vulnerability scanners, and indeed there
    are many scanners that exist for this purpose alone. One common such scanner is
    Burp Suite (*[https://portswigger.net/burp/](https://portswigger.net/burp/)*),
    mentioned in [Chapter 13](ch13.xhtml), which is a highly capable tool for both
    automated and manual testing of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Technological Challenges for Vulnerability Assessment*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll likely run across a great number of technological challenges that will
    make it harder for you to instantiate and maintain vulnerability scanners. A few
    of the most common and frequent stumbling blocks are related to cloud and virtualization
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloud
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Resources in the cloud put a bit of a twist in the tasks, processes, and technologies
    discussed here. As mentioned in [Chapter 6](ch06.xhtml), cloud providers may have
    some specific rules in place for what you can and can’t do in their environments,
    and this can change from one cloud provider to the next.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to vulnerability scanning, some vendors may not want you to scan
    devices in their environments at all, particularly if they’re using certain cloud
    deployment models. In most infrastructure as a service (IaaS) models, you’ll likely
    be able to scan within certain boundaries and according to certain rules. In platform
    as a service (PaaS) environments, vendors may restrict you to scanning with agents,
    as the infrastructure itself probably won’t be visible to you. In software as
    a service (SaaS) environments, the provider probably won’t want you to scan at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration for cloud scanning is the fluctuating nature of the environment.
    Even in the case of an IaaS platform, the devices and IPs may change frequently
    behind the scenes, and you may accidentally find yourself scanning devices or
    networks no longer belonging to you. The traffic generated by external vulnerability
    scanning from an unknown entity is virtually indistinguishable from attack traffic,
    so you shouldn’t accidentally point these tools at another company’s resources
    without appropriate permission.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another common and potentially problematic feature of cloud and virtualized
    environments is the container. A *container* is an entirely self-contained and
    ready-to-run virtualized instance, specifically designed to allow easy scaling
    up and down of portions of the environment seeing variable levels of load. For
    instance, your web server farm may see little load in the middle of the night
    and scale down to a few containers, as that’s all they need to keep things running
    at that hour. In the middle of the day, the server farm may scale up to hundreds
    of instances and then scale up and down over the course of the day according to
    load.
  prefs: []
  type: TYPE_NORMAL
- en: As containers may exist one second and be gone the next, they don’t work well
    with vulnerabilities scans on a schedule of any kind. Containers often require
    specialized vulnerability scanning tools to assess them for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some people assume that vulnerability scanning is the same thing as penetration
    testing. While a penetration tester might use the results from a vulnerability
    scan, these are two different sets of activities, each with their own processes.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration testing, also referred to as *pentesting* or *ethical hacking*,
    is the process of testing a system for vulnerabilities that an attacker could
    exploit. Penetration testing is a much more in-depth process than vulnerability
    scanning, and it’s often done manually. While a vulnerability assessment may get
    you part of the way to assessing your security, it won’t get you all the way there.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of penetration testing is to find the holes in your security so you
    can fix them before attackers discover them. Penetration testers use the same
    tools and techniques as genuinely hostile hackers (called *black hat hackers*)
    do. But unlike black hat hackers, penetration testers have permission to conduct
    these activities, which means that a penetration test conducted against your own
    systems would, in every sense, be considered an act of cybercrime if directed
    against the assets of another company without their authorization.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll often see a penetration testing team referred to as a *red team*, a term
    of military origin. The red team plays the part of the attacker when evaluating
    the security of your systems as realistically as they can while keeping the test
    safe and reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Penetration Testing Process*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Penetration testing follows a relatively standard process: scoping, reconnaissance,
    discovery, exploitation, and reporting, as shown in [Figure 14-1](#ch14fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The penetration testing process*'
  prefs: []
  type: TYPE_NORMAL
- en: Although some descriptions of the penetration testing process might use slightly
    different terminology or contain more or fewer steps, the general concepts will
    almost always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before you can conduct a penetration test against anything, you need to know
    what it is you’re testing against. The scope of your penetration test may be very
    open, such as “all assets of MyCompany,” or it may list only individual IP addresses
    you can test against.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the organization might restrict your testing to test or quality assurance
    (QA) environments only to prevent impacts on production systems. While penetration
    testers generally won’t use intentionally damaging attacks, their tools and techniques
    could always have unforeseen side effects.
  prefs: []
  type: TYPE_NORMAL
- en: An organization might also provide *rules of engagement* as part of their scoping
    discussion. These rules may specify times of day in which testing must take place,
    procedures testers should follow if they uncover a severe vulnerability, and so
    on. These rules will vary greatly depending on the environment being tested and
    the specific organization.
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Reconnaissance*, or *recon*, is the research you conduct before attempting
    any attacks against a target. This can involve searching the internet for information
    about the target environment or company, looking through job listings for mentions
    of specific technologies, researching some technology you know the company to
    be using, and so on. Recon is often, but not always, a passive activity and falls
    just short of directing tools against the target environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Discovery
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The discovery phase of the penetration test begins the active testing stage.
    Here, you’d likely run your vulnerability assessment tools, if you didn’t already
    do so, and go over the results. In this step, you’d look for open ports and services
    on hosts to detect any running services that could be vulnerable to attack. Based
    on what you find here, you might conduct additional research and recon based on
    specific information you collected.
  prefs: []
  type: TYPE_NORMAL
- en: Exploitation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This phase involves attempting to exploit the vulnerabilities you detected in
    the earlier stages. This may include attacking vulnerabilities in the environment
    or even chaining multiple vulnerabilities together to penetrate deeper into the
    environment. Again, what you find here may prompt additional research and recon
    as you gain new information about the target or new targets become available.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last phase of penetration testing is reporting. Here, you carefully document
    what you discovered and what exact steps you need to reproduce the attacks you
    successfully carried out.
  prefs: []
  type: TYPE_NORMAL
- en: This step illustrates one of the key differences between vulnerability assessment
    and penetration testing. While vulnerability assessment may produce a potential
    list of vulnerabilities in the environment, the tools can’t guarantee that an
    attacker will actually be able to exploit them. In penetration testing, the tester
    will report only the issues that resulted in an actionable attack against the
    system or have a high chance of being exploited.
  prefs: []
  type: TYPE_NORMAL
- en: '*Classifying Penetration Tests*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can classify penetration tests in several different ways. When testing,
    you can approach the test with differing levels of knowledge about the environment,
    from different starting places, or with different teams conducting specific portions
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Black Box, White Box, and Gray Box
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll often see penetration tests referred to as some color or level of opacity.
    This refers to the level of information the tester is provided with regarding
    the environment being tested.
  prefs: []
  type: TYPE_NORMAL
- en: In *black-box testing*, the tester has no knowledge of the environment other
    than the testing scope. This closely simulates a real-world attack, as presumably
    an outside attacker would start from this same place.
  prefs: []
  type: TYPE_NORMAL
- en: '*White-box testing* gives the tester all the information about the environment
    available. This likely includes a list of all hosts, what software is in use,
    source code for applications and websites, and so on. While this isn’t a realistic
    attack because an attacker likely wouldn’t have access to all this information,
    it allows the tester to be considerably more thorough and potentially turn up
    issues that would have otherwise gone undiscovered.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Gray-box testing* is a hybrid of the two testing types already mentioned.
    Here, the attacker is given some inside information about the environment, but
    not as much as they’d get if they were conducting a white-box test. This is one
    of the more common types of penetration test.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal vs. External
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Penetration tests might also be called internal or external, which can have
    two different interpretations. *Internal* and *external* might refer to the kinds
    of access the tester is granted to the environment being tested. For example,
    if you give the testers access to the environment from the internet-facing portions
    of it only, you might call this an external pentest. Conversely, if the testers
    are on the same network as the environment, either physically or via a virtual
    private network (VPN) connection, you might call this an internal test. In this
    case, internal testing would probably provide a greater level of access to the
    environment because the testers would begin their tests inside some layers of
    security.
  prefs: []
  type: TYPE_NORMAL
- en: '*Internal* and *external* might also indicate what kind of person or team is
    conducting the penetration test. External testing might refer to a third-party
    testing company hired to perform the pentest, while internal testing would likely
    refer to a penetration testing team working for your organization.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Targets of Penetration Tests*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Penetration tests sometimes target specific technologies or environments, such
    as web applications, networks, or hardware. I’ll discuss these in depth in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Network Penetration Testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although the term *network penetration testing* might sound like it would apply
    to tests of specific network devices, such as routers or switches, it’s often
    used as an overarching penetration testing term for the broad testing of hosts
    for vulnerabilities, issues specific to web applications, and even employees who
    might be vulnerable to social engineering attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Network penetration tests tend to have broad scopes but often take place in
    limited time frames (also called being *time boxed*) and therefore tend to be
    a bit shallower than a specifically focused test because the testers might not
    have the time to dig into everything in the testing scope. This is one of the
    more common types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Application Penetration Testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Application penetration testing*, the other common type of testing, focuses
    directly on an application or application environment. Application testing generally
    involves a more specialized set of tools and skills on the part of the tester
    than those necessary for network penetration testing and is more focused. It can
    involve two differing approaches: static analysis and dynamic analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static analysis* involves directly analyzing the application source code and
    resources. For instance, the tester might pore through the code, looking for issues
    such as logic errors or vulnerabilities that exist due to the specific lines of
    code and libraries in use. To perform static analysis, the tester must have a
    strong development background and grasp of the languages used.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dynamic analysis* involves testing the application while it’s in operation—in
    other words, testing the compiled binary form or the running web application.
    While this doesn’t give the tester the same insight into the code that static
    analysis does, it more closely resembles real attacks against the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Web application testing is common because of how often organizations use web
    applications and how often attackers are likely to target them. Mobile and desktop
    applications are also frequent targets for specific application testing, more
    often through static analysis techniques. These applications can make particularly
    easy targets for attackers, because large portions of applications and their resources
    sit on devices that the tester can control.
  prefs: []
  type: TYPE_NORMAL
- en: Physical Penetration Testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Physical penetration testing involves directly testing physical security measures
    by, for example, picking locks or bypassing alarm systems. Like application testing,
    this kind of testing also requires a particular set of tools and skills to test
    well. It’s also one of the less common kinds of test, because many organizations
    are more concerned with hackers penetrating their systems than they are with someone
    picking the lock on their office doors.
  prefs: []
  type: TYPE_NORMAL
- en: Testers often conduct physical penetration testing in conjunction with other
    penetration testing or to aid other testing. For example, if an attacker can get
    into a facility and enter a locked network closet, they may be able to plug a
    device into the network and leave it behind, which then allows them to perform
    attacks from the network itself without needing to be present.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other type of penetration testing, you’ll generally carry out physical
    penetration testing within a particular scope and with a specific goal in mind,
    whether you aim to get access to a data center or office or to plug your hostile
    device into the network.
  prefs: []
  type: TYPE_NORMAL
- en: Social Engineering Testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Social engineering penetration testing uses the same techniques discussed in
    [Chapter 8](ch08.xhtml) and also often takes place in conjunction with other tests.
    Social engineering tests are so effective that the testers almost always succeed,
    and so many organizations refuse to allow them. To keep them from succeeding,
    the workplace generally needs careful preparation and good education (or they
    need to be paranoid).
  prefs: []
  type: TYPE_NORMAL
- en: Social engineering tests frequently involve phishing attacks, which are easy
    to set up and deliver to large numbers of employees. Impersonating employees and
    attempting to gain unauthorized access to facilities or resources are also common
    strategies. External audit teams often simply walk in the door of a secured area
    right behind someone without using a badge (remember that this is called *tailgating*).
    Once they’ve done this, they can bring a rogue piece of equipment into a building
    and leave it behind, as mentioned in the previous section. Many people won’t ask
    questions about the “IT guy” who is plugging in and setting up a computer at an
    empty desk.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hardware testing is a slightly more unusual kind of penetration test. It typically
    occurs in organizations that manufacture hardware devices, such as network gear,
    TVs, or IoT devices, which often make for fertile ground for penetration testers
    since many of their interfaces are inaccessible to common users and not terribly
    secure. In addition to testing the device, penetration testers often test the
    firmware on the device, associated mobile applications, and application program
    interfaces (APIs) the devices use to communicate with their associated servers.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll likely discover specific information about the hardware in the reconnaissance
    and discovery phases. This step might involve taking the device apart and looking
    at the markings on the components and chips inside. It’s also often possible to
    find manufacturer specifications, which will sometimes let you access the hardware
    in ways the device manufacturer didn’t intend.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware devices are typically equipped with Universal Asynchronous Receiver/Transmitter
    (UART) or Joint Test Action Group (JTAG) debug ports, which are accessible on
    the circuit boards after you open the device. These will often provide terminal
    access to the device, in many cases without any sort of authentication, and you
    can use them to manipulate the device.
  prefs: []
  type: TYPE_NORMAL
- en: The discovery phase for hardware devices can be slightly more involved as well.
    Testers may investigate the firmware of the device itself, perhaps after dumping
    a copy of it from flash storage chips internal to the device, or they may test
    a module or application controlling the device or even an associated web application.
    The software portions of these devices can be quite complex to investigate, as
    they consist of the entire operating systems and all the applications running
    the device. Some devices, such as smartphones, may even have multiple layers of
    operating systems and software.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bug Bounty Programs*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the last few years, many organizations have taken to using bug bounty programs
    as a kind of penetration testing. These follow essentially the same rules and
    process as a regular penetration test, with a slight twist.
  prefs: []
  type: TYPE_NORMAL
- en: In a *bug bounty program*, an organization offers rewards to people who discover
    vulnerabilities in their resources. The “bounties” typically vary based on the
    severity of the issues uncovered. They can range from an expression of thanks
    or a T-shirt to hundreds of thousands of dollars. As an example, in January 2018,
    Google paid a Chinese security researcher US $112,000 for a bug found in its Pixel
    smartphones.[¹](notes.xhtml#ch14fn1)
  prefs: []
  type: TYPE_NORMAL
- en: The organizations with bounty programs allow anyone to test within the scope
    they’ve set, and they pay the tester who finds a specific issue first according
    to the specified bounty. Allowing anyone in the world to hack your systems at
    any time might sound like a terrible idea, but these programs have enjoyed a high
    level of success. The risk is partly mitigated by the fact that the organizations
    are typically careful to spell out specific scopes for their programs, and they’ll
    pay bounties only for issues reported within the scope specified. As a result,
    there typically isn’t much of an incentive to conduct attacks outside of this—say,
    just for “joyriding.”
  prefs: []
  type: TYPE_NORMAL
- en: Plenty of platforms manage bug bounty programs on behalf of other companies.
    Some of the better-known bug bounty platforms are HackerOne (*[https://www.hackerone.com/](https://www.hackerone.com/)*),
    Bugcrowd (*[https://www.bugcrowd.com/](https://www.bugcrowd.com/)*), and Synack
    (*[https://www.synack.com/](https://www.synack.com/)*). These platforms also make
    it easy for those wanting to participate in the programs to see what bounties
    are out there and what the scope and rewards are for each company.
  prefs: []
  type: TYPE_NORMAL
- en: '*Technological Challenges for Penetration Testing*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like for vulnerability analysis, technical challenges exist for penetration
    tests, which face many of the same issues.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloud
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The cloud also presents issues for penetration testing. One of the larger issues
    is that cloud providers generally don’t like testers attacking their cloud infrastructure
    at will. Cloud providers run a tight ship from a resource perspective and don’t
    tend to like surprise activities that use large amounts of their resources. Cloud
    providers will often require you to formally request permission to penetration
    test and conduct the test within a specific schedule, from known IP addresses,
    if they allow testing at all. Testers willy-nilly conducting attacks against cloud
    services will likely find their traffic blocked or, worse, the authorities involved.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Skilled Testers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s also often difficult to find skilled penetration testers. The difference
    between a highly skilled and experienced tester and a novice is huge in terms
    of the results you can expect. An unskilled tester may not get much further than
    reviewing the results the vulnerability scanning tool spit out, which will likely
    contain unverified false positives and miss major issues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a report from a penetration testing team with few results is often less
    a ringing endorsement for your amazingly tight security than a reflection of the
    skill level of the team doing the testing. Penetration testing skills take time
    and experience to develop, but penetration tests are in high demand. As a consequence,
    you may encounter tests conducted by testers who have no business doing so unsupervised.
  prefs: []
  type: TYPE_NORMAL
- en: Does This Really Mean You’re Secure?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you’ve assessed your vulnerabilities, conducted your penetration tests,
    and fixed all of your resulting issues and findings, are you really secure? Will
    the evil black hat hackers scrabble at the slick icy walls of your impenetrable
    security and then slink off, tails betwixt their legs? Well, probably not. There
    are a few caveats to everything I’ve discussed, and there’s no such thing as being
    perfectly secure.
  prefs: []
  type: TYPE_NORMAL
- en: '*Realistic Testing*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get accurate results about your security, you need to perform realistic testing.
    That means you should conduct vulnerability assessments and penetration tests
    without impeding them or skewing the results. This is a taller order than it sounds
    like.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Engagement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When you set your rules of engagement for testing, they need to closely adhere
    to the conditions under which an outside attack would take place. The whole point
    of this exercise is to emulate what attackers do so you can do it first and fix
    what you find. If you set rules of engagement to artificially increase the level
    of your security, you’re not doing yourself any favors. For instance, if you set
    a rule of engagement specifying no chaining of attacks (performing multiple attacks
    one after the other to penetrate more deeply), you’ve stopped short of exactly
    what an attacker would do to gain entry to the deeper portions of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For similar reasons, it’s important to set a realistic scope. Yes, you must
    make sure that your tests don’t impact production environments or degrade levels
    of service for customers, but organizations often use factors such as these as
    excuses to set an artificially narrow scope. If you’re testing in a retail environment,
    for instance, and set the systems holding payment card data out of scope, you’ve
    just scoped out the exact thing attackers are trying to access.
  prefs: []
  type: TYPE_NORMAL
- en: In cases when you’re making scoping decisions to protect production assets,
    you may be better off setting up a specific environment mirroring your production
    environment to test with impunity.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Environment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re using a test environment for scanning or testing purposes, you should
    make sure it matches the production environment as close as possible. It is all
    too common for organizations to set up idealized, thoroughly patched, and well-secured
    environments for a penetration test, without taking any of the same measures in
    the actual production environment. Setting up a Potemkin village of an environment
    like this works counter to what you’re trying to accomplish by performing these
    kinds of assessments and tests in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, it’s often helpful to operate in a cloud environment. In
    many cases, you can exactly replicate an entire environment consisting of cloud-based
    hosts and infrastructure in its own segmented area, allowing you to test an environment
    that’s identical to the production environment and then tear it down once you
    no longer need it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Can You Detect Your Own Attacks?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way you can evaluate your level of security is to carefully watch your
    everyday security tools and alerting systems while running vulnerability tools
    and penetration tests. If you’re correctly assessing your security, these activities
    should be almost indistinguishable from actual attacks. If you don’t notice your
    testing taking place, you probably won’t see the actual attacks coming in either.
    In many cases, penetration testers won’t be as stealthy as attackers, so they
    should be even easier to catch.
  prefs: []
  type: TYPE_NORMAL
- en: The Blue Team and the Purple Team
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier in the chapter, we referred to penetration testers as the red team.
    The opposite of the red team is the *blue team*, tasked with defending the organization
    and catching the red team. The blue team should participate in the other side
    of the penetration test just as much as the red team is attacking. While you may
    not want to actively block attacks coming from the red team (interfering with
    testing is a bit of a religious discussion, as it can potentially taint the test
    results), you should definitely record and document the evidence of their activities.
    You should have evidence of every attack the red team gets through, or at least
    understand how it avoided your attention, so you can fix your security. The results
    of a penetration test make an excellent basis for requesting an additional budget
    for resources or tooling to cover these gaps.
  prefs: []
  type: TYPE_NORMAL
- en: You may also hear people talk about *purple teams*, which form the bridge between
    red teams and blue teams and help to ensure that both operate as efficiently as
    possible. In environments with small security teams, purple teams may also play
    the part of both the red team and the blue team at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To catch penetration testers in the act, you must have appropriate instrumentation
    in place. If you don’t have intrusion detection systems and firewalls you can
    use to watch for unusual traffic, anti-malware and file integrity monitoring (FIM)
    tools on systems, and so on, you’ll have no source of data to watch for these
    kinds of attacks. The exact mix of tools that are reasonable to have in place
    will vary with your environment and security budget, but you can do a lot with
    a little if you need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: At the least, you should run some of the many open source tools that function
    on minimal hardware and are possible to put in place with an extremely low expenditure.
    For example, the Security Onion distribution can get data from host intrusion
    detection, network intrusion detection, full-time packet capture, logs, session
    data, and transaction data—all on a shoestring budget.[²](notes.xhtml#ch14fn2)
  prefs: []
  type: TYPE_NORMAL
- en: '**FIM TOOLS**'
  prefs: []
  type: TYPE_NORMAL
- en: FIM tools are used to monitor the integrity of the application and operating
    system files on a particular machine. Typically, you’d use FIMs to monitor only
    sensitive files, such as those that define configurations for the operating system
    or applications or hold particularly sensitive data. Once the file changes, an
    alert might notify someone of the changes, or in some cases, the file may automatically
    be reverted to its original state. FIM tools need to be carefully tuned, as they
    can produce a great deal of alerting “noise” if improperly configured.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Also, of critical importance is proper alerting from your tools. You need to
    have good alerting so that you know when you’ve caught the testers. You don’t
    want your tools muttering to themselves in the corner, completely ignored by the
    blue team. With proper alerting, you can respond to an attack or penetration test
    in close to real time.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to be careful about the alerts you send. If you send too many
    alerts, particularly if they’re false alarms, your blue team will start to ignore
    the alerts entirely. The common phrase for this, borrowed from the healthcare
    industry, is *alert fatigue*.[³](notes.xhtml#ch14fn3) The answer to this is to
    carefully send actionable alerts (those that prompt a specific response) and to
    send as few alerts as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*Secure Today Doesn’t Mean Secure Tomorrow*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s important to understand vulnerability assessments and penetration tests
    are a snapshot from a single point in time. Secure once doesn’t mean secure always.
    You must iterate these processes regularly to maintain the usefulness of the information
    they produce.
  prefs: []
  type: TYPE_NORMAL
- en: Your Changing Attack Surface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An attack surface is the sum of all the points that an attacker can use to interact
    with your environment. It is your web servers, mail servers, hosted cloud systems,
    salespeople with laptops in hotel rooms, internal source code posted to public
    GitHub repositories, and hundreds of other similar issues. As your attack surface
    is composed of so many moving parts, it’s in a constant state of flux. Your vulnerability
    assessment from a month ago or your penetration test from last year is probably
    no longer completely accurate—hence the need to update these at some regular interval.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers Change, Too
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Attackers are constantly evolving their attacks and tools, also. There are far
    more attackers than there are defenders, and many of the attackers have a direct
    monetary incentive to update their tools and techniques. Furthermore, attack tools
    are often sold to other hackers at a handsome profit. An entire cybercrime industry
    rides on keeping their tools current, at least as much as, if not more, than the
    security tool industry depends on defenders.
  prefs: []
  type: TYPE_NORMAL
- en: Putting in a security layer and expecting it to be just as solid and effective
    as the day it was installed years later is a bad bet. To cope with attackers changing,
    you need to change also. This cat-and-mouse game has driven the security industry
    for years and will continue to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Technology Updates Under You
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make matters worse, your technology can change under you (and you may not
    even be aware of it). Many of the operating systems, mobile applications, cloud
    services, security tools, and code libraries you make use of regularly receive
    updates by those who create and maintain them. The operating system in your smart
    TV may have updated in the middle of last night, exposing you to attacks from
    the internet. It may be updated again tomorrow to fix the issue, and you probably
    won’t know it then either.
  prefs: []
  type: TYPE_NORMAL
- en: You may find some of the security issues generated by updates during testing,
    or you may never know they existed at all. The best you can do in order to fend
    off this type of issue is to put multiple layers of security controls in place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fixing Security Holes Is Expensive*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, fixing holes in your security is expensive. It’s expensive in terms
    of resources, the cost of purchasing and updating your security controls, and
    the development efforts needed to fix insecure code in your applications and websites.
    More often than you’d like to think, an organization will fail to prioritize security
    over business priorities. You might go to a great deal of effort to catalog vulnerabilities
    and write up penetration testing findings only to be told the critical issue you
    found won’t be taken care of until some other work gets done. This happens often
    in the security world, and you’ll likely find a way to put another control in
    place or fill the gap with a security tool. Things won’t always be perfect, but
    you must still do what you can to make your organization secure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed vulnerability assessments and the tools you can
    use to suss out security issues in your hosts and applications. I also talked
    about how vulnerability assessments differ from penetration tests and why you
    should conduct both.
  prefs: []
  type: TYPE_NORMAL
- en: I covered penetration testing, the process of conducting one, and several of
    the specialized subareas of penetration testing, such as web application and hardware
    testing. I also talked about the challenges inherent in conducting penetration
    testing against cloud and virtualized environments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I talked about whether you’re really secure after going through all
    of the effort of vulnerability assessment and penetration testing and what it
    means to catch yourself testing (or not). Vulnerability assessment and penetration
    testing are representations of a point in time, meaning you must keep iterating
    over these to keep your data current.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What methods can you use to detect new hosts in your environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What benefits does an agent provide when vulnerability scanning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What challenges are there in vulnerability scanning for containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is penetration testing different from vulnerability assessment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a red team different from a blue team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is scoping important for a penetration test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between static and dynamic analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a bug bounty program different than a penetration test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What impact does the environment on which you test have on your test results?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is alert fatigue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
