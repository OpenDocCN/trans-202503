["```\n$ `ulimit -c unlimited`                       *Explained in main text*\n$ `sleep 30`\n*Type Control-\\*\nQuit (core dumped)\n$ `ls -l core`                                *Shows core dump file for* *sleep(1)*\n-rw-------   1 mtk    users     57344 Nov 30 13:39 core\n```", "```\n`signals/signal.c`\n#include <signal.h>\n\ntypedef void (*sighandler_t)(int);\n\nsighandler_t\nsignal(int sig, sighandler_t handler)\n{\n    struct sigaction newDisp, prevDisp;\n\n    newDisp.sa_handler = handler;\n    sigemptyset(&newDisp.sa_mask);\n#ifdef OLD_SIGNAL\n    newDisp.sa_flags = SA_RESETHAND | SA_NODEFER;\n#else\n    newDisp.sa_flags = SA_RESTART;\n#endif\n\n    if (sigaction(sig, &newDisp, &prevDisp) == -1)\n        return SIG_ERR;\n    else\n        return prevDisp.sa_handler;\n}\n      `signals/signal.c`\n```", "```\n#define _GNU_SOURCE\n#include <signal.h>\n\nvoid ( *`sysv_signal`(int *sig*, void (**handler*)(int)) ) (int);\n```", "```\n#if SIGRTMIN+100 > SIGRTMAX             /* WRONG! */\n#error \"Not enough realtime signals\"\n#endif\n```", "```\nlim = sysconf(_SC_SIGQUEUE_MAX);\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <signal.h>\n\nint `sigqueue`(pid_t *pid*, int *sig*, const union sigval *value*);\n```", "```\n`signals/t_sigqueue.c`\n#define _POSIX_C_SOURCE 199309\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int sig, numSigs, j, sigData;\n    union sigval sv;\n\n    if (argc < 4 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pid sig-num data [num-sigs]\\n\", argv[0]);\n\n    /* Display our PID and UID, so that they can be compared with the\n       corresponding fields of the siginfo_t argument supplied to the\n       handler in the receiving process */\n\n    printf(\"%s: PID is %ld, UID is %ld\\n\", argv[0],\n            (long) getpid(), (long) getuid());\n\n    sig = getInt(argv[2], 0, \"sig-num\");\n    sigData = getInt(argv[3], GN_ANY_BASE, \"data\");\n    numSigs = (argc > 4) ? getInt(argv[4], GN_GT_0, \"num-sigs\") : 1;\n\n    for (j = 0; j < numSigs; j++) {\n        sv.sival_int = sigData + j;\n        if (sigqueue(getLong(argv[1], 0, \"pid\"), sig, sv) == -1)\n            errExit(\"sigqueue %d\", j);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `signals/t_sigqueue.c`\n```", "```\nunion sigval {\n    int   sival_int;      /* Integer value for accompanying data */\n    void *sival_ptr;      /* Pointer value for accompanying data */\n};\n```", "```\nstruct sigaction act;\n\nsigemptyset(&act.sa_mask);\nact.sa_sigaction = handler;\nact.sa_flags = SA_RESTART | SA_SIGINFO;\n\nif (sigaction(SIGRTMIN + 5, &act, NULL) == -1)\n    errExit(\"sigaction\");\n```", "```\n$ `./catch_rtsigs 60 &`\n[1] 12842\n$ ./catch_rtsigs: PID is 12842        *Shell prompt mixed with program output*\n./catch_rtsigs: signals blocked - sleeping 60 seconds\n*Press Enter to see next shell prompt*\n$ `./t_sigqueue 12842 54 100 3`         *Send signal three times*\n./t_sigqueue: PID is 12843, UID is 1000\n$ `./t_sigqueue 12842 43 200`\n./t_sigqueue: PID is 12844, UID is 1000\n$ `./t_sigqueue 12842 40 300`\n./t_sigqueue: PID is 12845, UID is 1000\n```", "```\n$ ./catch_rtsigs: sleep complete\ncaught signal 40\n    si_signo=40, si_code=-1 (SI_QUEUE), si_value=300\n    si_pid=12845, si_uid=1000\ncaught signal 43\n    si_signo=43, si_code=-1 (SI_QUEUE), si_value=200\n    si_pid=12844, si_uid=1000\n```", "```\ncaught signal 54\n    si_signo=54, si_code=-1 (SI_QUEUE), si_value=100\n    si_pid=12843, si_uid=1000\ncaught signal 54\n    si_signo=54, si_code=-1 (SI_QUEUE), si_value=101\n    si_pid=12843, si_uid=1000\ncaught signal 54\n    si_signo=54, si_code=-1 (SI_QUEUE), si_value=102\n    si_pid=12843, si_uid=1000\n```", "```\n*Press Enter to see next shell prompt*\n$ `echo $$`                             *Display PID of shell*\n12780\n$ `kill -40 12842`                      *Uses* kill(2) *to send a signal*\n$ caught signal 40\n    si_signo=40, si_code=0 (SI_USER), si_value=0\n    si_pid=12780, si_uid=1000         *PID is that of the shell*\n*Press Enter to see next shell prompt*\n$ `kill 12842`                          *Kill* catch_rtsigs *by sending* SIGTERM\nCaught 6 signals\n*Press Enter to see notification from shell about terminated background job*\n[1]+  Done                    ./catch_rtsigs 60\n```", "```\n`signals/catch_rtsigs.c`\n#define _GNU_SOURCE\n#include <string.h>\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic volatile int handlerSleepTime;\nstatic volatile int sigCnt = 0;         /* Number of signals received */\nstatic volatile int allDone = 0;\n\nstatic void             /* Handler for signals established using SA_SIGINFO */\nsiginfoHandler(int sig, siginfo_t *si, void *ucontext)\n{\n    /* UNSAFE: This handler uses non-async-signal-safe functions\n       (printf()); see Section 21.1.2) */\n\n    /* SIGINT or SIGTERM can be used to terminate program */\n\n    if (sig == SIGINT || sig == SIGTERM) {\n        allDone = 1;\n        return;\n    }\n\n    sigCnt++;\n    printf(\"caught signal %d\\n\", sig);\n\n    printf(\"    si_signo=%d, si_code=%d (%s), \", si->si_signo, si->si_code,\n            (si->si_code == SI_USER) ? \"SI_USER\" :\n            (si->si_code == SI_QUEUE) ? \"SI_QUEUE\" : \"other\");\n    printf(\"si_value=%d\\n\", si->si_value.sival_int);\n    printf(\"    si_pid=%ld, si_uid=%ld\\n\", (long) si->si_pid, (long) si->si_uid);\n\n    sleep(handlerSleepTime);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n    int sig;\n    sigset_t prevMask, blockMask;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [block-time [handler-sleep-time]]\\n\", argv[0]);\n\n    printf(\"%s: PID is %ld\\n\", argv[0], (long) getpid());\n\n    handlerSleepTime = (argc > 2) ?\n                getInt(argv[2], GN_NONNEG, \"handler-sleep-time\") : 1;\n\n    /* Establish handler for most signals. During execution of the handler,\n       mask all other signals to prevent handlers recursively interrupting\n       each other (which would make the output hard to read). */\n\n    sa.sa_sigaction = siginfoHandler;\n    sa.sa_flags = SA_SIGINFO;\n    sigfillset(&sa.sa_mask);\n\n    for (sig = 1; sig < NSIG; sig++)\n        if (sig != SIGTSTP && sig != SIGQUIT)\n            sigaction(sig, &sa, NULL);\n\n    /* Optionally block signals and sleep, allowing signals to be\n       sent to us before they are unblocked and handled */\n\n    if (argc > 1) {\n        sigfillset(&blockMask);\n        sigdelset(&blockMask, SIGINT);\n        sigdelset(&blockMask, SIGTERM);\n\n        if (sigprocmask(SIG_SETMASK, &blockMask, &prevMask) == -1)\n            errExit(\"sigprocmask\");\n\n        printf(\"%s: signals blocked - sleeping %s seconds\\n\", argv[0], argv[1]);\n        sleep(getInt(argv[1], GN_GT_0, \"block-time\"));\n        printf(\"%s: sleep complete\\n\", argv[0]);\n\n        if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)\n            errExit(\"sigprocmask\");\n    }\n\n    while (!allDone)                    /* Wait for incoming signals */\n        pause();\n}\n     `signals/catch_rtsigs.c`\n```", "```\nsigset_t prevMask, intMask;\n    struct sigaction sa;\n\n    sigemptyset(&intMask);\n    sigaddset(&intMask, SIGINT);\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = handler;\n\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    /* Block SIGINT prior to executing critical section. (At this\n       point we assume that SIGINT is not already blocked.) */\n\n    if (sigprocmask(SIG_BLOCK, &intMask, &prevMask) == -1)\n        errExit(\"sigprocmask - SIG_BLOCK\");\n\n    /* Critical section: do some work here that must not be\n       interrupted by the SIGINT handler */\n\n    /* End of critical section - restore old mask to unblock SIGINT */\n\n    if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)\n        errExit(\"sigprocmask - SIG_SETMASK\");\n\n    /* BUG: what if SIGINT arrives now... */\n\n    pause();                            /* Wait for SIGINT */\n```", "```\n#include <signal.h>\n\nint `sigsuspend`(const sigset_t **mask*);\n```", "```\nsigprocmask(SIG_SETMASK, &mask, &prevMask);     /* Assign new mask */\npause();\nsigprocmask(SIG_SETMASK, &prevMask, NULL);      /* Restore old mask */\n```", "```\n`signals/t_sigsuspend.c`\n    #define _GNU_SOURCE     /* Get strsignal() declaration from <string.h> */\n    #include <string.h>\n    #include <signal.h>\n    #include <time.h>\n    #include \"signal_functions.h\"           /* Declarations of printSigMask()\n                                               and printPendingSigs() */\n    #include \"tlpi_hdr.h\"\n\n    static volatile sig_atomic_t gotSigquit = 0;\n\n    static void\n    handler(int sig)\n    {\n        printf(\"Caught signal %d (%s)\\n\", sig, strsignal(sig));\n                                            /* UNSAFE (see Section 21.1.2) */\n        if (sig == SIGQUIT)\n            gotSigquit = 1;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        int loopNum;\n        time_t startTime;\n        sigset_t origMask, blockMask;\n        struct sigaction sa;\n\n    printSigMask(stdout, \"Initial signal mask is:\\n\");\n\n        sigemptyset(&blockMask);\n        sigaddset(&blockMask, SIGINT);\n        sigaddset(&blockMask, SIGQUIT);\n    if (sigprocmask(SIG_BLOCK, &blockMask, &origMask) == -1)\n            errExit(\"sigprocmask - SIG_BLOCK\");\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = 0;\n        sa.sa_handler = handler;\n         if (sigaction(SIGINT, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n        if (sigaction(SIGQUIT, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n     for (loopNum = 1; !gotSigquit; loopNum++) {\n            printf(\"=== LOOP %d\\n\", loopNum);\n\n            /* Simulate a critical section by delaying a few seconds */\n\n            printSigMask(stdout, \"Starting critical section, signal mask is:\\n\");\n            for (startTime = time(NULL); time(NULL) < startTime + 4; )\n                continue;                   /* Run for a few seconds elapsed time */\n\n            printPendingSigs(stdout,\n                    \"Before sigsuspend() - pending signals:\\n\");\n            if (sigsuspend(&origMask) == -1 && errno != EINTR)\n                errExit(\"sigsuspend\");\n        }\n\n     if (sigprocmask(SIG_SETMASK, &origMask, NULL) == -1)\n            errExit(\"sigprocmask - SIG_SETMASK\");\n\n     printSigMask(stdout, \"=== Exited loop\\nRestored signal mask to:\\n\");\n\n        /* Do other processing... */\n\n        exit(EXIT_SUCCESS);\n    }\n         `signals/t_sigsuspend.c`\n```", "```\n$ `./t_sigsuspend`\nInitial signal mask is:\n                <empty signal set>\n=== LOOP 1\nStarting critical section, signal mask is:\n                2 (Interrupt)\n                3 (Quit)\n*Type Control-C;* SIGINT *is generated, but remains pending because it is blocked*\nBefore sigsuspend() - pending signals:\n                2 (Interrupt)\nCaught signal 2 (Interrupt)         *sigsuspend() is called, signals are unblocked*\n```", "```\n=== LOOP 2\nStarting critical section, signal mask is:\n                2 (Interrupt)\n                3 (Quit)\n*Type Control-\\ to generate* SIGQUIT\nBefore sigsuspend() - pending signals:\n                3 (Quit)\nCaught signal 3 (Quit)              *sigsuspend() is called, signals are unblocked*\n=== Exited loop                     *Signal handler set gotSigquit*\nRestored signal mask to:\n                <empty signal set>\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <signal.h>\n\nint `sigwaitinfo`(const sigset_t **set*, siginfo_t **info*);\n```", "```\n$ `./t_sigwaitinfo 60 &`\n./t_sigwaitinfo: PID is 3837\n./t_sigwaitinfo: signals blocked\n./t_sigwaitinfo: about to delay 60 seconds\n[1] 3837\n$ `./t_sigqueue 3837 43 100`                  *Send signal 43*\n./t_sigqueue: PID is 3839, UID is 1000\n$ `./t_sigqueue 3837 42 200`                  *Send signal 42*\n./t_sigqueue: PID is 3840, UID is 1000\n```", "```\n$ ./t_sigwaitinfo: finished delay\ngot signal: 42\n    si_signo=42, si_code=-1 (SI_QUEUE), si_value=200\n    si_pid=3840, si_uid=1000\ngot signal: 43\n    si_signo=43, si_code=-1 (SI_QUEUE), si_value=100\n    si_pid=3839, si_uid=1000\n```", "```\n*Press Enter to see next shell prompt*\n$ `echo $$`                                   *Display PID of shell*\n3744\n$ `kill -USR1 3837`                           *Shell sends* SIGUSR1 *using* kill()\n$ got signal: 10                            *Delivery of SIGUSR1*\n    si_signo=10, si_code=0 (SI_USER), si_value=100\n    si_pid=3744, si_uid=1000                *3744 is PID of shell*\n*Press Enter to see next shell prompt*\n$ `kill %1`                                   *Terminate program with* SIGTERM\n$\n*Press Enter to see notification of background job termination*\n[1]+  Done                    ./t_sigwaitinfo 60\n```", "```\n`signals/t_sigwaitinfo.c`\n#define _GNU_SOURCE\n#include <string.h>\n#include <signal.h>\n#include <time.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int sig;\n    siginfo_t si;\n    sigset_t allSigs;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [delay-secs]\\n\", argv[0]);\n\n    printf(\"%s: PID is %ld\\n\", argv[0], (long) getpid());\n\n    /* Block all signals (except SIGKILL and SIGSTOP) */\n\n    sigfillset(&allSigs);\n    if (sigprocmask(SIG_SETMASK, &allSigs, NULL) == -1)\n        errExit(\"sigprocmask\");\n    printf(\"%s: signals blocked\\n\", argv[0]);\n\n    if (argc > 1) {             /* Delay so that signals can be sent to us */\n        printf(\"%s: about to delay %s seconds\\n\", argv[0], argv[1]);\n        sleep(getInt(argv[1], GN_GT_0, \"delay-secs\"));\n        printf(\"%s: finished delay\\n\", argv[0]);\n    }\n\n    for (;;) {                  /* Fetch signals until SIGINT (^C) or SIGTERM */\n        sig = sigwaitinfo(&allSigs, &si);\n        if (sig == -1)\n            errExit(\"sigwaitinfo\");\n\n        if (sig == SIGINT || sig == SIGTERM)\n            exit(EXIT_SUCCESS);\n\n        printf(\"got signal: %d (%s)\\n\", sig, strsignal(sig));\n        printf(\"    si_signo=%d, si_code=%d (%s), si_value=%d\\n\",\n                si.si_signo, si.si_code,\n                (si.si_code == SI_USER) ? \"SI_USER\" :\n                    (si.si_code == SI_QUEUE) ? \"SI_QUEUE\" : \"other\",\n                si.si_value.sival_int);\n        printf(\"    si_pid=%ld, si_uid=%ld\\n\",\n                (long) si.si_pid, (long) si.si_uid);\n    }\n}\n      `signals/t_sigwaitinfo.c`\n```", "```\n#define _POSIX_C_SOURCE 199309\n#include <signal.h>\n\nint `sigtimedwait`(const sigset_t **set*, siginfo_t **info*,\n                 const struct timespec **timeout*);\n```", "```\nstruct timespec {\n    time_t tv_sec;      /* Seconds ('time_t' is an integer type) */\n    long   tv_nsec;     /* Nanoseconds */\n};\n```", "```\n#include <sys/signalfd.h>\n\nint `signalfd`(int *fd*, const sigset_t **maskl*, int *flags*);\n```", "```\nstruct signalfd_siginfo {\n    uint32_t  ssi_signo;    /* Signal number */\n    int32_t   ssi_errno;    /* Error number (generally unused) */\n    int32_t   ssi_code;     /* Signal code */\n    uint32_t  ssi_pid;      /* Process ID of sending process */\n    uint32_t  ssi_uid;      /* Real user ID of sender */\n    int32_t   ssi_fd;       /* File descriptor (SIGPOLL/SIGIO) */\n    uint32_t  ssi_tid;      /* Kernel timer ID (POSIX timers) */\n    uint32_t  ssi_band;     /* Band event (SIGPOLL/SIGIO) */\n    uint32_t  ssi_tid;      /* (Kernel-internal) timer ID (POSIX timers) */\n    uint32_t  ssi_overrun;  /* Overrun count (POSIX timers) */\n    uint32_t  ssi_trapno;   /* Trap number */\n    int32_t   ssi_status;   /* Exit status or signal (SIGCHLD) */\n    int32_t   ssi_int;      /* Integer sent by sigqueue() */\n    uint64_t  ssi_ptr;      /* Pointer sent by sigqueue() */\n    uint64_t  ssi_utime;    /* User CPU time (SIGCHLD) */\n    uint64_t  ssi_stime;    /* System CPU time (SIGCHLD) */\n    uint64_t  ssi_addr;     /* Address that generated signal\n                               (hardware-generated signals only) */\n};\n```", "```\n`signals/signalfd_sigval.c`\n#include <sys/signalfd.h>\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    sigset_t mask;\n    int sfd, j;\n    struct signalfd_siginfo fdsi;\n    ssize_t s;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s sig-num...\\n\", argv[0]);\n\n    printf(\"%s: PID = %ld\\n\", argv[0], (long) getpid());\n\n    sigemptyset(&mask);\n    for (j = 1; j < argc; j++)\n        sigaddset(&mask, atoi(argv[j]));\n\n    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n        errExit(\"sigprocmask\");\n\n    sfd = signalfd(-1, &mask, 0);\n    if (sfd == -1)\n        errExit(\"signalfd\");\n\n    for (;;) {\n        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n        if (s != sizeof(struct signalfd_siginfo))\n            errExit(\"read\");\n\n        printf(\"%s: got signal %d\", argv[0], fdsi.ssi_signo);\n        if (fdsi.ssi_code == SI_QUEUE) {\n            printf(\"; ssi_pid = %d; \", fdsi.ssi_pid);\n            printf(\"ssi_int = %d\", fdsi.ssi_int);\n        }\n        printf(\"\\n\");\n    }\n}\n      `signals/signalfd_sigval.c`\n```", "```\n$ `./signalfd_sigval 44 &`\n./signalfd_sigval: PID = 6267\n[1] 6267\n$ `./t_sigqueue 6267 44 123`          *Send signal 44 with data 123 to PID 6267*\n./t_sigqueue: PID is 6269, UID is 1000\n./signalfd_sigval: got signal 44; ssi_pid=6269; ssi_int=123\n$ `kill %1`                           *Kill program running in background*\n```", "```\n#define _XOPEN_SOURCE 500\n#include <signal.h>\n\nvoid (*`sigset`(int *sig*, void (**handler*)(int)))(int);\n```", "```\n#define _XOPEN_SOURCE 500\n#include <signal.h>\n\nint `sighold`(int *sig*);\nint `sigrelse`(int *sig*);\nint `sigignore`(int *sig*);\n```", "```\nint `sigpause`(int *sig*);\n```", "```\n#define _BSD_SOURCE\n#include <signal.h>\n\nint `sigvec`(int *sig*, struct sigvec **vec*, struct sigvec **ovec*);\n```", "```\nstruct sigvec {\n    void (*sv_handler)();\n    int  sv_mask;\n    int  sv_flags;\n};\n```", "```\n#define _BSD_SOURCE\n#include <signal.h>\n\nint `sigblock`(int *mask*);\nint `sigsetmask`(int *mask*);\n```", "```\nint `sigpause`(int *sigmask*);\n```", "```\nint `sigmask`(*sig*);\n```", "```\nsigblock(sigmask(SIGINT) | sigmask(SIGQUIT));\n```"]