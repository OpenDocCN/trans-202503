- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating and Testing a Host-Based Firewall
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: It would be dangerous for a production server, especially one exposed to the
    internet, to not filter its network traffic. As software or DevOps engineers,
    we open up ports for services like SSH or web servers as a necessary, accepted
    risk. However, that does not mean we should ignore all other traffic destined
    for our host. To minimize risks, we need to filter all other traffic and make
    pragmatic decisions on what gets in and what gets out. Therefore, we use *firewalls*
    to monitor the incoming and outgoing packets on a network or host. Firewalls come
    in two varieties. A *network firewall* is usually an appliance through which all
    traffic flows from one network to another, while a *host-based* *firewall* controls
    the packets coming in and out of a single host.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll focus on host-based firewalls. You’ll learn how to automate
    a host-based firewall using Ansible, some provided tasks, and a software application
    called Uncomplicated Firewall (UFW). This firewall will block all inbound traffic
    except SSH connections and the Greeting web application you installed in Chapter
    4. By the end of this chapter, you’ll understand how to automate a basic host-based
    firewall and be able to audit log events from the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the Firewall Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firewall rules need to be very explicit about what traffic to permit and what
    traffic to deny. If you accidentally block a port (or worse, leave one exposed),
    the outcome will be less than desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can divide the firewall traffic flow into three default parts, called *chains*.
    Think of a chain as a door through which a packet must pass. Each door leads to
    a specific place when properly routed packets arrive. Here are brief descriptions
    of the functions of the three default chains that you have access to in UFW:'
  prefs: []
  type: TYPE_NORMAL
- en: Input chain Filters packets destined for the host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output chain Filters packets originating from the host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Forward chain Filters packets that are being routed through the host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The firewall rules you’ll create will only be for the input chain, because you’re
    focusing on the inbound traffic to your VM. The forward and output chains are
    beyond the scope of this book, as you are building a simple host-based firewall.
    If you need to block outgoing ports and forward network traffic, visit [https://ubuntu.com/server/docs/security-firewall/](https://ubuntu.com/server/docs/security-firewall/)for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: The firewall rules you’ll implement will allow incoming traffic for two known
    ports while rejecting all others. You’ll need to open port `22` for shell access
    (SSH) and Ansible provisioning; plus, you’ll open port `5000` for the web application.
    You’ll also add rate limiting to port `5000`, to protect the web server and host
    from excessive abuse. Finally, you’ll enable the firewall log so you can audit
    the network traffic that comes through the firewall on the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Automating UFW Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Uncomplicated Firewall (UFW)* is a software application that provides a thin
    wrapper around the iptables framework, which is the root of kernel-based packet
    filtering for Unix OSs. To be specific, iptables, Netfilter, connection tracking,
    and network address translation (NAT) make up the packet-filtering framework.
    UFW hides the complexity associated with using iptables. Along with Ansible, it
    makes setting up a host-based firewall simple, easy, and repeatable. Therefore,
    you’ll use Ansible tasks to create rules with UFW.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible tasks to configure the firewall are located under the *ansible/chapter5/*
    directory. These rules will go into effect once you provision the VM, so let’s
    review them before provisioning. Navigate to the *ansible/chapter5/* directory
    and open the task file named *firewall.yml* in your favorite editor. This file
    has the following five tasks in it:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn `Logging` level to low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow SSH over port `22`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow all access to port `5000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rate limit excessive abuse on port `5000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop all other traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first task at the top of the file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This task turns on `logging` for UFW and sets the log level to `low`. The Ansible
    `ufw` module creates rules and policies for the firewall on the VM. You can set
    the `logging` parameter to `off`, `low`, `medium`, `high`, or `full`. The `low`
    log level will log any blocked packets that do not match your default policy and
    any other firewall rules you have added. The `medium` level does everything the
    `low` level does, plus it logs all allowed packets that do not match the default
    policy and all new connections. The `high` log level does everything the `medium`
    does, but it also logs all packets with some rate limiting of the messages. If
    you have a lot of disk space and want to know everything possible about every
    packet on your host, set the log level to `high`. Any setting above `medium` will
    generate a lot of log data and could fill up disks fast on a busy host, so be
    careful with those log settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the second task from the top, which opens port `22` for
    SSH connections. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Ansible `ufw` module creates a `rule` that allows an incoming connection
    from any source IP address, using the TCP transport protocol to port `22` on the
    VM. You can set the `rule` parameter to `deny`, `limit`, or `reject`, depending
    on your use case. For example, if you want to stop a connection on a specific
    port but don’t mind sending a rejection reply to the remote host, you should choose
    `reject`. The rejection reply will tell the remote system that you are up and
    running but not accepting traffic on that port. On the other hand, if you want
    to drop the incoming packet on the floor without any reply to the remote host,
    choose a `deny` rule. This can make it harder for someone scanning your host to
    know if the host is up and running. (I’ll discuss the `limit` rule in detail later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task is the rule to allow remote connections on port `5000` to the
    Greeting web application. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `rule` behaves the same as the previous task, except that it permits port
    `5000` over TCP instead of port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth task in the file limits the number of connections to port `5000`
    (Greeting server) over a given time frame. This is useful when you want to automatically
    stop someone from abusing your service, whether they are legitimate or suspicious.
    It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default rate-limiting feature for UFW states it will deny any connection
    from a source if that source tries to make more than six connections in a 30-second
    time span. This is helpful if you host a public service like an API or web server.
    You could use the limit to temporarily impede users from obsessively hitting your
    service. Another example where this would be beneficial is to limit brute-force
    attempts over SSH on a *bastion host*, which is a hardened host that system administrators
    use to remotely access a private network. However, be careful with this default
    limit setting, as it may be too restrictive for a production setting. Allowing
    a remote system to connect more than six times in 30 seconds might be normal traffic
    for you. You’ll test the rate-limiting rule later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to adjust the default rate limit setting, create a new task using
    the `lineinfile` module (see Chapter 3) to locate and update the line in */etc/ufw/user.rules*
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Change the `hitcount` and `seconds` options to whatever makes sense for your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task in this file drops all traffic that has not matched any other
    rules up to this point. Remember, Ansible executes the tasks in order. The drop
    rule should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is no `rule` parameter here. This task sets the `state` of
    the `ufw` service to be enabled on the VM. It also sets the default `incoming`
    policy to `deny`, which forces you to whitelist all the services that need to
    be exposed. This also protects you if someone accidentally misconfigures a service
    and opens up a port on the host.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Ansible reads tasks from the top down, and UFW rules
    are read in the same order. If the `drop` rule were the first task in the file,
    it would set the policy to drop all traffic and then turn on the firewall. That
    `drop` rule would match all inbound packets and drop them, stopping the search
    of any other rules that possibly could match. Not only would you lose access to
    the VM, but you would also drop the connection made by Ansible over SSH. This
    means the provisioning would fail and potentially leave the machine in a bad state,
    so be sure to keep the order in mind when adding or removing rules.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run all the tasks for this chapter, you’ll need to uncomment them in the
    playbook. This is the same process as in the previous chapters and should be familiar
    by now. Open the *ansible/site.yml*file in your editor and locate the task for
    installing the `firewall`. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `#` symbol to uncomment it. The playbook should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The changes to the playbook for Chapter 5 are added on to the changes from Chapter
    4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to run the Ansible tasks using Vagrant. Navigate back to the
    *vagrant/* directory where your *Vagrantfile* is located and enter the following
    command to provision the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The total task count has increased to `26`, and `6` things on the VM have changed:
    the five new tasks from this chapter and one task that updates the timestamp on
    the empty file from Chapter 2\. Once again, make sure no actions failed before
    you continue.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Firewall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, you’ll want to test that your host-based firewall is enabled, permitting
    the two whitelisted ports, blocking all other ports, and rate-limiting the Greeting
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll need to be able to access the VM from your local host, so grab
    an IP address from your VM. In the *Vagrantfile*, you told Vagrant to create another
    interface and let VirtualBox give it an address from a range using DHCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are no longer logged in to the VM, log in as *bender*again and grab
    another 2FA token, if needed. This time, grab the third 2FA token from the top
    of the *ansible/chapter3/google_authenticator* file, which should be `52973407`.
    Once you have it, enter the following command in your terminal to log in as *bender*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `ip` command to grab the IP address from the interface you instructed
    Vagrant and VirtualBox to create. This command is primarily used to list and manipulate
    network routes and devices on a Linux host. From the VM terminal, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output above shows that the `ip` command has completed successfully. The
    `-4` flag limits the output to only IPv4 addresses. The `-br` flag prints just
    the basic interface information, like IP address and name, and the ``addr command
    tells `ip` to show the address information for the network interfaces.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
