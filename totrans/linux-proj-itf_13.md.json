["```\nwrite(fd, \"abc\", 3);\n```", "```\n#include <stdio.h>\n\nint `setvbuf`(FILE **stream*, char **buf*, int *mode*, size_t *size*);\n```", "```\n#define BUF_SIZE 1024\nstatic char buf[BUF_SIZE];\n\nif (setvbuf(stdout, buf, _IOFBF, BUF_SIZE) != 0)\n    errExit(\"setvbuf\");\n```", "```\n#include <stdio.h>\n\nvoid `setbuf`(FILE **stream*, char **buf*);\n```", "```\nsetvbuf(fp, buf, (buf != NULL) ? _IOFBF: _IONBF, BUFSIZ);\n```", "```\n#define _BSD_SOURCE\n#include <stdio.h>\n\nvoid `setbuffer`(FILE **stream*, char **buf*, size_t *size*);\n```", "```\nsetvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, size);\n```", "```\n#include <stdio.h>\n\nint `fflush`(FILE **stream*);\n```", "```\n#include <unistd.h>\n\nint `fsync`(int *fd*);\n```", "```\n#include <unistd.h>\n\nint `fdatasync`(int *fd*);\n```", "```\n#include <unistd.h>\n\nvoid `sync`(void);\n```", "```\nfd = open(pathname, O_WRONLY | O_SYNC);\n```", "```\n#include <fcntl.h>\n\nint `posix_fadvise`(int *fd*, off_t *offset*, off_t *len*, int *advice*);\n```", "```\n$ `./direct_read /test/x 512`                *Read 512 bytes at offset 0*\nRead 512 bytes                              *Succeeds*\n$ `./direct_read /test/x 256`\nERROR [EINVAL Invalid argument] read        *Length is not a multiple of 512*\n$ `./direct_read /test/x 512 1`\nERROR [EINVAL Invalid argument] read        *Offset is not a multiple of 512*\n$ `./direct_read /test/x 4096 8192 512`\nRead 4096 bytes                             *Succeeds*\n$ `./direct_read /test/x 4096 512 256`\nERROR [EINVAL Invalid argument] read        *Alignment is not a multiple of 512*\n```", "```\n`filebuff/direct_read.c`\n#define _GNU_SOURCE     /* Obtain O_DIRECT definition from <fcntl.h> */\n#include <fcntl.h>\n#include <malloc.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int fd;\n    ssize_t numRead;\n    size_t length, alignment;\n    off_t offset;\n    char *buf;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file length [offset [alignment]]\\n\", argv[0]);\n\n    length = getLong(argv[2], GN_ANY_BASE, \"length\");\n    offset = (argc > 3) ? getLong(argv[3], GN_ANY_BASE, \"offset\") : 0;\n    alignment = (argc > 4) ? getLong(argv[4], GN_ANY_BASE, \"alignment\") : 4096;\n\n    fd = open(argv[1], O_RDONLY | O_DIRECT);\n    if (fd == -1)\n        errExit(\"open\");\n\n    /* memalign() allocates a block of memory aligned on an address that\n      is a multiple of its first argument. By specifying this argument as\n      2 * 'alignment' and then adding 'alignment' to the returned pointer,\n      we ensure that 'buf' is aligned on a non-power-of-two multiple of\n      'alignment'. We do this to ensure that if, for example, we ask\n      for a 256-byte aligned buffer, we don't accidentally get a\n      buffer that is also aligned on a 512-byte boundary. */\n\n    buf = memalign(alignment * 2, length + alignment);\n    if (buf == NULL)\n        errExit(\"memalign\");\n\n    buf += alignment;\n\n    if (lseek(fd, offset, SEEK_SET) == -1)\n        errExit(\"lseek\");\n\n    numRead = read(fd, buf, length);\n    if (numRead == -1)\n        errExit(\"read\");\n    printf(\"Read %ld bytes\\n\", (long) numRead);\n\n    exit(EXIT_SUCCESS);\n}\n     `filebuff/direct_read.c`\n```", "```\n#include <stdio.h>\n\nint `fileno`(FILE **stream*);\n```", "```\nFILE *`fdopen`(int *fd*, const char **mode*);\n```", "```\nprintf(\"To man the world is twofold, \");\nwrite(STDOUT_FILENO, \"in accordance with his twofold attitude.\\n\", 41);\n```", "```\nin accordance with his twofold attitude.\nTo man the world is twofold,\n```", "```\n    fflush(fp);\n    fsync(fileno(fp));\n    ```", "```\n    printf(\"If I had more time, \\n\");\n    write(STDOUT_FILENO, \"I would have written you a shorter letter.\\n\", 43);\n    ```"]