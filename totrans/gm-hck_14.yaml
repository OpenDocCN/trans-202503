- en: '**10**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RESPONSIVE HACKS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The average gamer has a reaction time of 250 milliseconds, or a quarter of a
    second. Professional gamers average a fifth of a second, but some can react in
    a sixth of a second. These figures are based on online tests that measure players’
    reaction times to singular, predictable events. In actual games, though, players
    must react to dozens of different events, like health loss, incoming skill shots,
    abilities coming off of cooldown, enemy attacks, and many others. Only very skilled
    gamers can maintain a fourth- or fifth-of-a-second reaction time in such dynamic
    environments; the only way to be faster is to be a computer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to make bots that react faster than any player.
    First, I’ll show you some code patterns you can incorporate into a bot to detect
    when certain events happen within a game. Next, you’ll learn how to make a bot
    that moves your character, heals, or casts spells all on its own. Once you’ve
    explored those fundamental techniques, I’ll help you tie them together to implement
    some of the most common, and most powerful, responsive hacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observing Game Events**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within just a few seconds of playing a game, most people can make essential
    observations about the game environment. You can clearly see when missiles are
    flying toward your character, when your health is too low, and when abilities
    come off of cooldown. For a bot, though, these seemingly intuitive observations
    are not as easy to make. The bot must detect each event by looking for changes
    in memory, detecting visual cues, or intercepting network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '***Monitoring Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To detect simple events, such as your health bar dropping low, you can program
    a bot to periodically read your health from memory and compare it to some minimum
    acceptable value, as in [Listing 10-1](ch10.xhtml#ch10exe1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: An `if` statement that checks health*'
  prefs: []
  type: TYPE_NORMAL
- en: Given the address of your character’s health, you can check the value there
    as often as you need; every 10 milliseconds is typically a good rate. (Flip back
    to [Chapter 1](ch01.xhtml#ch01) if you need a refresher on locating values in
    memory.) Once `health` drops below a certain value, you’ll want to run some reaction
    code to cast a healing spell or drink a potion. I’ll talk about how you can do
    this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want your bot to have more granular information and the chance for a
    greater variety of responses, you can program it to react to *any* change in health,
    instead of only after a set threshold. To do so, change the code in [Listing 10-1](ch10.xhtml#ch10exe1)
    to compare your current health to the amount you had during the previous execution,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, this code uses a static variable called `previousHealth` to track the value
    of `health` on the previous iteration. If `previousHealth` and `health` differ,
    the bot not only reacts to the change in health but also reacts differently to
    health increases and decreases. This technique is the simplest, and most common,
    way to react to changes in a game state. With the proper memory addresses, you
    can use this code pattern to observe changes in health, mana, ability cooldowns,
    and other critical information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Detecting Visual Cues***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Health is relatively simple for a bot to check because it’s just a number, but
    some game elements have to be relayed to the bot differently. For example, when
    status ailments or buffs are affecting a character, the easiest way for you to
    tell is to simply look for an onscreen status indicator, and the same is true
    for bots.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading memory isn’t enough, you can detect certain events by hooking
    a game’s graphics engine and waiting for the game to render a specific model.
    (Refer back to “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175) and “[Creating a Direct3D Wallhack](ch09.xhtml#ch00lev1sec191)”
    on [page 194](ch09.xhtml#page_194) to get refreshed on Direct3D hooks. ) When
    the model is drawn, you can queue up a reaction to be executed after the frame
    is drawn, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the same model-fingerprinting trick as the wallhack code in [Chapter 9](ch09.xhtml#ch09),
    this code detects when a specific model is drawn to the screen and reacts accordingly.
    This code reacts to the event every single frame, though, and that can make your
    game unplayable. You’ll probably want some internal cooldown to avoid spamming
    a reaction. In cases where the indicator model is persistently drawn (that is,
    not blinking), you can actually track it across frames to determine when it appears
    and disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code snippet that also handles tracking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `onDrawIndexedPrimitive()` function still checks whether a certain model
    was drawn, but now, two Booleans track whether the model was drawn this frame
    or the previous frame. Then, when the frame is completely drawn, the bot can check
    these variables and react to the model either appearing or disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: This method works great for detecting visual status indicators that appear only
    when your character is affected by stuns, movement slows, snares, poisons, and
    so on. You can also use it to detect when enemies appear and disappear in MOBA
    and RTS games, as these games draw only enemies that are explicitly in the sight
    range of an allied unit or player.
  prefs: []
  type: TYPE_NORMAL
- en: '***Intercepting Network Traffic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most reliable ways to observe events is the same way the game client
    does: by waiting for the game server to tell you that they occurred. In this type
    of communication, the game server sends byte arrays called *packets* over the
    network to the client, using sockets. The packets are typically encrypted and
    contain blobs of data serialized through a proprietary format.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Typical Packet-Parsing Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To receive and process packets, a game client does something like [Listing 10-2](ch10.xhtml#ch10exe2)
    before it draws a frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: A simplified look at how a game parses packets*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact code for any particular game might look different, but the control
    flow is always the same: receive a packet, decrypt it, decide what kind of message
    it contains, and call a function that knows what to do with it. Some game hackers
    intercept raw network packets and replicate this functionality in their bots.
    This technique works, but it requires extensive knowledge of encryption, a complete
    understanding of how the game stores data inside a packet, the ability to man-in-the-middle
    the network connection, and a way to locate the decryption keys being used by
    the game client.'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the functions responsible for handling the packets after they are decrypted
    and parsed is a much better approach; in [Listing 10-2](ch10.xhtml#ch10exe2),
    those functions are the `onHealthChange()` and `onManaChange()` functions. This
    method leverages the game’s inherent ability to process packets, allowing a bot
    to remain ignorant of the various network facilities the game uses. It also gives
    you discretion over which network data you intercept, as you need to hook only
    the handlers that meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Intercepting entire packets can sometimes be advantageous—for example, in
    any game that uses Adobe AIR and communicates using RTMPS. Since RTMPS is so heavily
    documented, there’s no need to reverse engineer the format or encryption. [Chapter
    8](ch08.xhtml#ch08) explains how to hook RTMPS in detail.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few tricks you can use to easily find the parser function and, ultimately,
    the `switch()` statement that dispatches packets to their handlers. The most useful
    method I’ve found is to place a breakpoint on the function the game uses to receive
    data from the network, and then analyze the flow of the application when the breakpoint
    is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through how you might do this with OllyDbg attached to your target
    game. In Windows, `recv()` is the API function to receive data from a socket.
    From the OllyDbg command line, you can set a breakpoint on `recv()` by entering
    the `bp recv` command. When the breakpoint is hit, you can climb the call stack
    using CTRL-F9, the shortcut for execute until return, and F8, the shortcut for
    step over. This combination essentially lets the program execute until the callee
    has returned to the caller, allowing you to climb the call stack in tandem with
    the game. At each stack level, you can inspect the code of each caller until you
    find one that has a big `switch()` statement; this should be the packet parser.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Trickier Parser**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Depending on the game’s architecture, though, finding the parser function may
    not be that simple. Consider a game with a parser function that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the `parseNextPacket()` function doesn’t have a `switch()` statement,
    there’s no obvious way to identify it in memory. Unless you pay very close attention,
    you’ll likely climb right past it on the call stack. When a game has a parser
    function like this, trying to figure out what the parser function looks like might
    be pointless. If you don’t see a `switch()` statement when climbing the `recv()`
    call stack, you’ll have to note every callee on the call stack instead.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of climbing up the call stack from the breakpoint, you’d go to every
    address marked as a `RETURN` below ESP in the OllyDbg stack pane. These are the
    return addresses into each caller for each callee. At each return address, you’d
    need to find the top of the caller in OllyDbg’s disassembly pane and note the
    address. As a result, you’d have a list of every function call leading up to the
    `recv()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’d repeat the same list-making process from breakpoints placed on a
    few of the game’s handler functions. You can find a handler function by monitoring
    memory that it will inevitably use. The handler for a health change packet, for
    instance, will update your health in memory. Using OllyDbg, you can set a *memory
    on write* breakpoint to the health address. When the breakpoint gets triggered,
    it means the game updated the health value from a handler function. This should
    work the same way for most values that are controlled by the server. The server
    will control any game-critical values, such as health, mana, level, items, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve recorded the call stack from `recv()` and a few handler functions,
    you can correlate them to locate the parser function. For example, consider the
    three pseudo–call stacks in [Table 10-1](ch10.xhtml#ch10tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** Pseudo–Call Stacks for Three Packet-Related Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`recv()` stack** | **`onHealthChange()` stack** | **`onManaChange()` stack**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x40404040 | 0x50505050 | 0x60606060 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
  prefs: []
  type: TYPE_TB
- en: '| 0x30303030 | 0x30303030 | 0x30303030 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x20202020 | 0x20202020 | 0x20202020 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10101010 | 0x10101010 | 0x10101010 |'
  prefs: []
  type: TYPE_TB
- en: These stacks show what memory might look like during a call to `recv()` and
    to a game’s hypothetical `onHealthChange()` and `onManaChange()` functions. Notice
    that each function originates from a chain of four common function calls (shown
    in boldface). The deepest common address, 0xDEADBEEF, is the address of the parser.
    For a better understanding of this structure, look at the call stacks laid out
    in a tree view, as in [Figure 10-1](ch10.xhtml#ch10fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f10-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Tree view of our three call stacks*'
  prefs: []
  type: TYPE_NORMAL
- en: Each function’s call stack branches out from the function at 0xDEADBEEF, meaning
    that function is a common point of origin for all three calls. The example `parseNextPacket()`
    function is responsible for calling these functions, so it must be the most recent
    common ancestor at 0xDEADBEEF.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*These call stacks are hypothetical, and they’re simplified beyond what you’ll
    typically encounter. Real call stacks will probably have quite a few more function
    calls, and comparing them won’t be as easy.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Hybrid Parsing System**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A third variation of the parsing loop might be a hybrid of the previous two
    that uses a `switch()` statement after a function call. Here’s another hypothetical
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `processNextPacket()` function fetches a new packet and calls `dispatchPacket()`
    to handle the data. In this case, the `dispatchPacket()` function exists in the
    call stack of each handler, but not in the one for the `recv()` function. Look
    at the hypothetical stacks in [Table 10-2](ch10.xhtml#ch10tab2), for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-2:** Pseudo–Call Stacks for Three Packet-Related Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`recv()` stack** | **`onHealthChange()` stack** | **`onManaChange()` stack**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x40404040 | 0x00ABCDEF | 0x00ABCDEF |'
  prefs: []
  type: TYPE_TB
- en: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
  prefs: []
  type: TYPE_TB
- en: '| 0x30303030 | 0x30303030 | 0x30303030 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x20202020 | 0x20202020 | 0x20202020 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10101010 | 0x10101010 | 0x10101010 |'
  prefs: []
  type: TYPE_TB
- en: Although these three functions have the same first four addresses in their call
    stacks, only the two handlers have one more address in common (again shown in
    boldface). That’s 0x00ABCDEF, and it’s the address of the `dispatchPacket()` function.
    Once again, you can imagine these laid out in a tree view, as in [Figure 10-2](ch10.xhtml#ch10fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f10-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Tree view of our three call stacks*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Parser Hack**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you’ve located the function responsible for dispatching packets to their
    handlers, you’ll be able to spot every handler that can be called. You can deduce
    a handler’s purpose by placing a breakpoint on it and watching what values change
    in memory when it executes. Then, you can hook any handlers that your bot needs
    to react to. (Flip back to [Chapter 8](ch08.xhtml#ch08) if you need a refresher
    on how you might hook these functions. )
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are endless ways to implement network behavior. I can’t cover
    them all, but seeing these three common techniques should help you understand
    the methodology. No matter what game you’re dealing with, a breakpoint on `recv()`
    should be a step in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performing In-Game Actions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before a bot can react to events, you have to teach it to play the game. It
    needs to be able to cast spells, move around, and activate items. On this front,
    bots aren’t much different from people: they can just be told which buttons to
    press. Pressing buttons is simple and suffices in many cases, but in more intricate
    situations, a bot may have to communicate on the network and tell the server what
    it’s trying to do.'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with the examples in this section and explore on your own afterward,
    open the files in the *GameHackingExamples/Chapter10_ ResponsiveHacks/* folder
    in this book’s resource files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Emulating the Keyboard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common buttons you’ll press in a game are keyboard keys, and there
    are a couple of ways you can teach your bot to type.
  prefs: []
  type: TYPE_NORMAL
- en: '**The SendInput() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One common way to emulate the keyboard is with the `SendInput()` Windows API
    function. This function, which sends keyboard and mouse input to the topmost window,
    has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `inputCount`, is the number of inputs being sent. For the
    examples in this book, I’ll always use a value of `1`. The second parameter, `inputs`,
    is a pointer to a structure (or an array of structures whose length matches the
    `inputCount` value) with the predefined type `INPUT`. The final parameter is the
    size of inputs in memory, as calculated with the formula `size` = `inputCount`
    × `sizeof(INPUT)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `INPUT` structure tells the `SendInput()` function what type of input to
    send, and the following code shows how you might initialize an instance of `INPUT`
    to press the F1 key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To have your bot actually press F1, you’d need to send this input twice, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `SendInput()` presses F1, and the second releases it. The
    release happens not because the input was sent twice, but because the second call
    was made with the `KEYEVENTF_KEYUP` flag enabled in the `input` parameter’s keyboard
    flags field. Since setting up `input` for even a single key is a bit messy, it’s
    best to wrap everything inside a function. The result looks something like [Listing
    10-3](ch10.xhtml#ch10exe3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3: A wrapper for emulating keystrokes with `SendInput()`*'
  prefs: []
  type: TYPE_NORMAL
- en: This function initializes `input` with the given `key`, enables the flag `KEYEVENTF_KEYUP`
    if `up` is set, and calls the `SendInput()` function. This means `sendKeyWithSendInput()`
    must be called a second time to send the key release, even though the release
    is always required. The function is written this way because key combinations
    that involve modifiers like SHIFT, ALT, or CTRL must be sent a bit differently;
    the modifier’s press must come before the key’s press, but its release must come
    after the key’s release.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how you’d use the `sendKeyWithSendInput()` function
    to tell a bot to press SHIFT-F1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You’d have to call `sendKeyWithSendInput()` four times, but that’s still easier
    than using the code without a wrapper function.
  prefs: []
  type: TYPE_NORMAL
- en: '**The SendMessage() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An alternative method for sending keystrokes relies on the `SendMessage()`
    Windows API function. This function allows you to send input to any window, even
    if it’s minimized or hidden, by posting data directly to the target window’s message
    queue. This advantage makes it the method of choice for game hackers, because
    it enables users to do other things while their bot plays the game in the background.
    `SendMessage()` has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `window`, is a handle to the window that the input is being
    sent to. The second parameter, `message`, is the type of input being sent; for
    keyboard input, this parameter is `WM_KEYUP`, `WM_KEYDOWN`, or `WM_CHAR`. The
    third parameter, `wparam`, should be the key code. The final parameter, `lparam`,
    should be `0` when the message is `WM_KEYDOWN` and `1` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can use the `SendMessage()` function, you must obtain a handle to
    the target process’s main window. Given the title of the window, you can obtain
    a handle using the `FindWindow()` Windows API function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With a valid window handle, making a call to `SendMessage()` looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call presses the F1 key, and the second call releases it. Keep in
    mind, however, that this series of calls works only for keys that don’t input
    text, like F1, INSERT, or TAB. To have your bot press keys that input text, you
    must also send a `WM_CHAR` message between the down and up messages. To type W,
    for instance, you’d do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `key` variable so the letter key to press can be changed easily.
    Then it follows the same steps the F1 example used, just with a `WM_CHAR` message
    in between.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can actually send nothing but the* `WM_CHAR` *message and get the same
    result, but it’s best practice to send all three messages. Game developers can
    easily shut down bots by patching the game to ignore* `WM_CHAR` *messages that
    don’t follow* `WM_KEYDOWN`*, and they can even use it as a way to detect your
    bot and ban you.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As I showed with the `SendInput()` technique, you can create a wrapper around
    this functionality to make your bot code easier to work with. The wrapper looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Unlike [Listing 10-3](ch10.xhtml#ch10exe3), this wrapper actually sends both
    the press and release. This is because `SendMessage()` can’t be used to send keystrokes
    with modifiers, so there’s never any need to insert code between the two calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are multiple ways a game might check whether a modifier key is pressed,
    though. You might be able to send modifier keys to certain games by calling the*
    `SendMessage()` *function, but it depends on how those games detect modifiers.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this wrapper in a similar way as the one in [Listing 10-3](ch10.xhtml#ch10exe3).
    For example, this code sends F1 followed by W:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example, like all of the `SendMessage()` code I’ve shown so far, simply
    gets the job done. It can input text, but it doesn’t exactly send proper messages.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of small details you have to get right if you want to send 100
    percent valid messages with the `SendMessage()` function. For instance, the first
    16 bits of `lparam` should store the number of times the key has been automatically
    repeated as a result of being held down. The next 8 bits should store the *scan
    code*, a key identifier that is specific to each keyboard manufacturer. The next
    bit, number 24, should be set only if the button is on an extended part of the
    keyboard, such as the number pad. The following 4 bits are undocumented, and the
    next bit should be set only if the ALT key was down when the message originated.
    The last 2 bits are the previous state flag and the transition state flag. The
    previous state flag is set only if the key was previously down, and the transition
    state is set only if the key was previously in the state opposite its current
    position (that is, if the key is now up and was previously down, or vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the average game doesn’t consider most of these values. For that
    matter, the average piece of software doesn’t care about them either. If you have
    to fill all of these values with proper data to make your bot work, you’re moving
    in the wrong direction. There are many other ways to perform actions, the majority
    of which are simpler than trying to emulate the exact behavior of the operating
    system’s kernel-level keyboard input handler/dispatcher. In fact, there’s already
    a function that does that, and I’ve already talked about it: the `SendInput()`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also control the mouse with the `SendInput()` and `SendMessage()` functions,
    but I highly recommend avoiding it. Any mouse commands you send will affect, and
    be affected by, any legitimate mouse movements, mouse clicks, or keystrokes sent
    by the player. The same is true for keyboard input, but the complications are
    much rarer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Packets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before a game draws a frame, it checks for keyboard and mouse input. When it
    receives input that results in an action, such as moving around or casting a spell,
    it checks to make sure the action is possible and, if so, tells the game server
    that the action has been performed. The game code to check for events and alert
    the server often looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `processInput()` function is called every frame. The function iterates over
    all pending inputs and dispatches different types of inputs to their relevant
    handlers. In this case, when keyboard input is received, it’s dispatched to the
    `processKeyboardInput()` function. This handler then checks whether the key is
    either W or S, and, if so, calls `step()` to move the player in the corresponding
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: Since `step()` is used to perform an action, it is called an *actor* function.
    The invocation of an actor function is called *actuation*. You can directly call
    a game’s actor functions from your bot to perform an action while completely bypassing
    the input layer.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can call an actor, though, you must find its address. To do this,
    you can attach OllyDbg to the game, open the command line, and enter `bp send`.
    This will place a breakpoint on the `send()` function, which is used to send data
    over the network. When you play the game, every time you take a step, cast a spell,
    pick up loot, or do anything else, your breakpoint should trigger, and you can
    note each function in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The game should call* `send()` *every time you do anything while playing.
    Pay attention to what you did before each* `send()` *breakpoint is hit, as that
    will give you a rough idea of what action each call is communicating to the server,
    and, ultimately, what the actor you find is responsible for.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a few different call stacks, you can compare them to locate the
    actor functions. To see how to spot the actor functions, let’s compare the two
    annotated call stacks in [Figure 10-3](ch10.xhtml#ch10fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f10-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Tree view of call stacks to two actor functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Like these two stacks, the call stacks you find should be identical at the top,
    sharing a couple of common functions responsible for generic network transmission.
    They should also be identical on the bottom, since each call to `send()` should
    have originated from the `processInput()` function. Each stack should have some
    unique functions between these identical regions, though, and those are the actor
    functions you’re looking for. Typically, the function of interest is immediately
    beneath the common network calls. In this case, the two actors are the `step()`
    and `castSpell()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: After hacking the same game for a while, you’ll learn how far up the stack the
    actor functions are from the `send()` call. In [Figure 10-3](ch10.xhtml#ch10fig3),
    for example, the actors happen three calls before the `send()` call. Knowing this,
    you could just climb the stack in OllyDbg (CTRL-F9 followed by F8) three times
    when your `send()` breakpoint is hit and be inside the actor function that sent
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve found an actor function, you can call it from an injected DLL.
    Here’s how you might call `step()` if you found it at 0xDEADBEEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the bot won’t know the actual name for this game function, the code assigns
    the contents of memory at 0xDEADBEEF to a conveniently named variable: `stepActor`.
    Then, the code just calls `stepActor()` like any other function.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve got the right address, function prototype, and parameters, this should
    work beautifully; you’ll be able to automate actions as if you have access to
    the game’s source code. Just make sure to call the actor functions from inside
    the same thread as the game, or you can run into threading issues. The best way
    to do this is to call the actors from a hook on a major function like Direct3D’s
    `EndScene()` or the Windows API’s `PeekMessage()` function, as these functions
    will usually be called only from the game’s main thread.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING THIS TO CALL _ _THISCALL**'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to call an actor function that’s a nonstatic member of a class, the
    function will have a `_thiscall` calling convention, which means you’ll need to
    pass the instance of the class on the ECX register. (You can brush up on calling
    conventions in “[Function Calls](ch04.xhtml#ch00lev1sec98)” on [page 94](ch04.xhtml#page_94).)
    Passing the instance is straightforward, but you’ll have to locate a pointer chain
    to the class instance first.
  prefs: []
  type: TYPE_NORMAL
- en: To find the pointer chain, you can drop a breakpoint on the actor function,
    grab the class instance value from ECX when the breakpoint kicks, and throw that
    value into a Cheat Engine pointer scan. Then, to call the function, you’d walk
    the pointer chain, obtain the current instance address, and use inline assembly
    to set up ECX and make the actual function call. This process works similarly
    to the way VF hook callbacks call their original counterparts, as shown in “[Writing
    a VF Table Hook](ch08.xhtml#ch00lev1sec158)” on [page 156](ch08.xhtml#page_156).
  prefs: []
  type: TYPE_NORMAL
- en: '**Tying the Pieces Together**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you’ve created frameworks for observing events and performing actions,
    you can tie them together to create responsive hacks. Responsive hacks come in
    many flavors, but there are a few common ones.
  prefs: []
  type: TYPE_NORMAL
- en: '***Making the Perfect Healer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A favorite bot among gamers is *autohealing*, a hack that automatically uses
    a healing spell when the player’s health decreases drastically or drops below
    a certain threshold. Given a way to detect changes in health and an actor function
    to cast spells, an autohealer might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This autohealing function is pretty simple, but it works well. More advanced
    autohealers might have many more levels of healing and be able to learn as they
    go. You’ll get working example code and an in-depth explanation of advanced autohealers
    in “[Control Theory and Game Hacking](ch11.xhtml#ch00lev1sec221)” on [page 222](ch11.xhtml#page_222).
  prefs: []
  type: TYPE_NORMAL
- en: '***Resisting Enemy Crowd-Control Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Anti-crowd-control* hacks detect incoming *crowd-control attacks* and automatically
    cast spells that reduce their effects or completely negate them. Crowd-control
    attacks disable players in some way, so having enemies cast them on you can be
    a pain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a way to detect incoming or active crowd-control effects, such as by
    detecting a Direct3D model or by intercepting an incoming packet, and an actor
    function to cast spells, you could have a bot react instantly to such attacks
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An `onIncomingCrowdControl()` function might try to stop the crowd-control spell
    from ever hitting you. Failing that, the bot could call an `onReceiveCrowdControl()`
    spell to remove the effects.
  prefs: []
  type: TYPE_NORMAL
- en: '***Avoiding Wasted Mana***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Spell trainers* are also quite common among botters. Spell trainers wait until
    the player has full mana and then cast spells to increase the player’s magic level
    or stats. This allows players to quickly increase their magic skills, as they
    will never waste mana regeneration just because they have full mana.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a way to detect changes in mana and an actor function to cast spells,
    a bot might include the following pseudocode for a spell trainer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the player’s mana and the increase in that player’s mana
    (`delta`) as parameters. If the increase in mana is above a certain amount, it
    assumes the player is using potions or other items to replenish mana, and it won’t
    cast any extra spells. Otherwise, if the player has plenty of mana, the function
    fires off any old spell to get the player some experience points.
  prefs: []
  type: TYPE_NORMAL
- en: Other common responsive hacks are *autoreload* to instantly reload ammo, *autododge*
    to evade incoming projectiles, and *autocombo* to instantly attack the same target
    as a nearby ally. Really, the only limit to the number of responsive hacks you
    can add to a bot is the number of events your bot can observe in the game, multiplied
    by the number of valid and helpful responses it can send for each event.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using hooks, memory manipulation, and keyboard simulation, you can begin creating
    your first responsive hacks. These hacks are your entry point into gaming autonomy,
    but they’re only a glimpse of what’s possible. [Chapter 11](ch11.xhtml#ch11) will
    be the pinnacle of your game-hacking adventure. Using everything you’ve learned
    so far, and building on the principles of responsive hacks, you’ll learn how to
    automate advanced actions and create a truly autonomous bot.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not feeling quite ready to go deeper, I strongly recommend reviewing
    the earlier material and then getting some practice in an isolated environment
    on your own machine. Implementing bots like this is a lot easier than you might
    think, and it’s an amazingly satisfying experience. Once you’re comfortable making
    autohealers and other basic responsive hacks, you’ll be ready to start completely
    automating gameplay.
  prefs: []
  type: TYPE_NORMAL
