- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**RESPONSIVE HACKS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式黑客**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: The average gamer has a reaction time of 250 milliseconds, or a quarter of a
    second. Professional gamers average a fifth of a second, but some can react in
    a sixth of a second. These figures are based on online tests that measure players’
    reaction times to singular, predictable events. In actual games, though, players
    must react to dozens of different events, like health loss, incoming skill shots,
    abilities coming off of cooldown, enemy attacks, and many others. Only very skilled
    gamers can maintain a fourth- or fifth-of-a-second reaction time in such dynamic
    environments; the only way to be faster is to be a computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 平均玩家的反应时间为250毫秒，或者四分之一秒。职业玩家的平均反应时间为五分之一秒，但有些玩家能够在六分之一秒内做出反应。这些数据基于在线测试，测量玩家对单一、可预测事件的反应时间。然而，在实际游戏中，玩家必须对数十个不同的事件做出反应，比如失去健康、技能射击的来临、技能冷却结束、敌人攻击等。只有非常熟练的玩家才能在如此动态的环境中维持四分之一或五分之一秒的反应时间；而要想更快，唯一的方法就是使用计算机。
- en: In this chapter, you’ll learn how to make bots that react faster than any player.
    First, I’ll show you some code patterns you can incorporate into a bot to detect
    when certain events happen within a game. Next, you’ll learn how to make a bot
    that moves your character, heals, or casts spells all on its own. Once you’ve
    explored those fundamental techniques, I’ll help you tie them together to implement
    some of the most common, and most powerful, responsive hacks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习如何制作比任何玩家反应更快的机器人。首先，我会展示一些你可以在机器人中使用的代码模式，用于检测游戏中何时发生某些事件。接下来，你将学会如何让一个机器人独立移动你的角色、治疗或施放法术。一旦你掌握了这些基本技巧，我将帮助你将它们结合起来，实现一些最常见且最强大的响应式黑客。
- en: '**Observing Game Events**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**观察游戏事件**'
- en: Within just a few seconds of playing a game, most people can make essential
    observations about the game environment. You can clearly see when missiles are
    flying toward your character, when your health is too low, and when abilities
    come off of cooldown. For a bot, though, these seemingly intuitive observations
    are not as easy to make. The bot must detect each event by looking for changes
    in memory, detecting visual cues, or intercepting network traffic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏的几秒钟内，大多数人就能对游戏环境做出基本的观察。你可以清晰地看到导弹飞向你的角色，健康值过低时，或者技能冷却结束时。而对于机器人来说，这些看似直观的观察并不容易。机器人必须通过查看内存变化、检测视觉提示或截取网络流量来识别每个事件。
- en: '***Monitoring Memory***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存监控***'
- en: To detect simple events, such as your health bar dropping low, you can program
    a bot to periodically read your health from memory and compare it to some minimum
    acceptable value, as in [Listing 10-1](ch10.xhtml#ch10exe1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测简单的事件，比如你的健康条下降，你可以编程让机器人定期从内存中读取健康值，并将其与某个最小可接受值进行比较，如[清单 10-1](ch10.xhtml#ch10exe1)所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: An `if` statement that checks health*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：一个检查健康的`if`语句*'
- en: Given the address of your character’s health, you can check the value there
    as often as you need; every 10 milliseconds is typically a good rate. (Flip back
    to [Chapter 1](ch01.xhtml#ch01) if you need a refresher on locating values in
    memory.) Once `health` drops below a certain value, you’ll want to run some reaction
    code to cast a healing spell or drink a potion. I’ll talk about how you can do
    this later in the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 给定你角色的健康地址，你可以根据需要频繁检查其值；通常每10毫秒检查一次是一个好的频率。（如果需要复习如何在内存中查找值，请翻回[第1章](ch01.xhtml#ch01)。）一旦`health`值降到某个特定值以下，你就需要运行一些反应代码，比如施放治疗法术或喝药水。我将在本章后面讲解如何做到这一点。
- en: 'If you want your bot to have more granular information and the chance for a
    greater variety of responses, you can program it to react to *any* change in health,
    instead of only after a set threshold. To do so, change the code in [Listing 10-1](ch10.xhtml#ch10exe1)
    to compare your current health to the amount you had during the previous execution,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的机器人拥有更精细的信息并能够提供更多样化的反应，可以编程使其对*任何*健康变化作出反应，而不仅仅是在超过设定阈值后才反应。为此，请将[清单
    10-1](ch10.xhtml#ch10exe1)中的代码更改为比较当前的健康值和上次执行时的健康值，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, this code uses a static variable called `previousHealth` to track the value
    of `health` on the previous iteration. If `previousHealth` and `health` differ,
    the bot not only reacts to the change in health but also reacts differently to
    health increases and decreases. This technique is the simplest, and most common,
    way to react to changes in a game state. With the proper memory addresses, you
    can use this code pattern to observe changes in health, mana, ability cooldowns,
    and other critical information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码使用一个名为 `previousHealth` 的静态变量来追踪上一轮迭代中的 `health` 值。如果 `previousHealth`
    和 `health` 不同，机器人不仅会对生命值的变化作出反应，还会根据生命值的增加或减少作出不同的反应。这种技术是最简单、最常见的应对游戏状态变化的方式。通过正确的内存地址，你可以使用这种代码模式来观察生命值、魔法值、技能冷却时间以及其他关键数据的变化。
- en: '***Detecting Visual Cues***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检测视觉提示***'
- en: Health is relatively simple for a bot to check because it’s just a number, but
    some game elements have to be relayed to the bot differently. For example, when
    status ailments or buffs are affecting a character, the easiest way for you to
    tell is to simply look for an onscreen status indicator, and the same is true
    for bots.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生命值对机器人来说相对简单，因为它只是一个数字，但一些游戏元素必须以不同的方式传递给机器人。例如，当状态异常或增益效果影响角色时，最简单的方式就是通过屏幕上的状态指示器来判断，机器人也可以采用同样的方法。
- en: 'When reading memory isn’t enough, you can detect certain events by hooking
    a game’s graphics engine and waiting for the game to render a specific model.
    (Refer back to “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175) and “[Creating a Direct3D Wallhack](ch09.xhtml#ch00lev1sec191)”
    on [page 194](ch09.xhtml#page_194) to get refreshed on Direct3D hooks. ) When
    the model is drawn, you can queue up a reaction to be executed after the frame
    is drawn, like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取内存不足以满足需求时，你可以通过钩取游戏的图形引擎并等待游戏渲染特定模型来检测某些事件。（请参见 “[在Direct3D中应用跳跃钩子和VF钩子](ch08.xhtml#ch00lev1sec174)”
    第175页 和 “[创建Direct3D墙体透视](ch09.xhtml#ch00lev1sec191)” 第194页 来复习有关Direct3D钩子的内容。）当模型被绘制时，你可以排队一个反应，在帧绘制完成后执行，像这样：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the same model-fingerprinting trick as the wallhack code in [Chapter 9](ch09.xhtml#ch09),
    this code detects when a specific model is drawn to the screen and reacts accordingly.
    This code reacts to the event every single frame, though, and that can make your
    game unplayable. You’ll probably want some internal cooldown to avoid spamming
    a reaction. In cases where the indicator model is persistently drawn (that is,
    not blinking), you can actually track it across frames to determine when it appears
    and disappears.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与第9章 [墙体透视代码](ch09.xhtml#ch09) 相同的模型指纹识别技巧，这段代码可以检测特定模型何时被绘制到屏幕上，并做出相应的反应。然而，这段代码会在每一帧都做出反应，这可能会导致游戏无法正常进行。你可能希望加入一些内部冷却机制，以避免反应过度。在那些指示器模型持续绘制（即非闪烁）的情况下，你实际上可以跨帧追踪它，以确定它何时出现或消失。
- en: 'Here’s a code snippet that also handles tracking:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个也处理追踪的代码片段：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `onDrawIndexedPrimitive()` function still checks whether a certain model
    was drawn, but now, two Booleans track whether the model was drawn this frame
    or the previous frame. Then, when the frame is completely drawn, the bot can check
    these variables and react to the model either appearing or disappearing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDrawIndexedPrimitive()` 函数仍然会检查是否绘制了某个模型，但现在有两个布尔值变量追踪该模型是出现在当前帧还是上一帧。当帧完全绘制完后，机器人可以检查这些变量，并根据模型的出现或消失作出反应。'
- en: This method works great for detecting visual status indicators that appear only
    when your character is affected by stuns, movement slows, snares, poisons, and
    so on. You can also use it to detect when enemies appear and disappear in MOBA
    and RTS games, as these games draw only enemies that are explicitly in the sight
    range of an allied unit or player.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于检测只在角色受到眩晕、移动减速、束缚、毒药等影响时才会出现的视觉状态指示器非常有效。你还可以用它来检测敌人在MOBA和RTS游戏中的出现和消失，因为这些游戏只绘制处于友方单位或玩家视距范围内的敌人。
- en: '***Intercepting Network Traffic***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拦截网络流量***'
- en: 'One of the most reliable ways to observe events is the same way the game client
    does: by waiting for the game server to tell you that they occurred. In this type
    of communication, the game server sends byte arrays called *packets* over the
    network to the client, using sockets. The packets are typically encrypted and
    contain blobs of data serialized through a proprietary format.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 观察事件最可靠的方法之一与游戏客户端的做法相同：等待游戏服务器告诉你事件已经发生。在这种通信方式中，游戏服务器通过套接字将称为 *数据包* 的字节数组发送到客户端。数据包通常是加密的，包含通过专有格式序列化的数据块。
- en: '**A Typical Packet-Parsing Function**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**典型的数据包解析函数**'
- en: To receive and process packets, a game client does something like [Listing 10-2](ch10.xhtml#ch10exe2)
    before it draws a frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收和处理数据包，游戏客户端在绘制帧之前执行类似于[清单 10-2](ch10.xhtml#ch10exe2)的操作。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: A simplified look at how a game parses packets*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：游戏如何解析数据包的简化示例*'
- en: 'The exact code for any particular game might look different, but the control
    flow is always the same: receive a packet, decrypt it, decide what kind of message
    it contains, and call a function that knows what to do with it. Some game hackers
    intercept raw network packets and replicate this functionality in their bots.
    This technique works, but it requires extensive knowledge of encryption, a complete
    understanding of how the game stores data inside a packet, the ability to man-in-the-middle
    the network connection, and a way to locate the decryption keys being used by
    the game client.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定游戏的具体代码可能看起来有所不同，但控制流始终相同：接收数据包，解密它，决定它包含什么类型的消息，然后调用一个知道如何处理它的函数。一些游戏黑客拦截原始网络数据包并在他们的机器人中复制这种功能。这种技术是有效的，但需要广泛的加密知识、对游戏如何在数据包中存储数据的全面理解、能够进行中间人攻击的能力，并且需要能够定位游戏客户端使用的解密密钥。
- en: Hooking the functions responsible for handling the packets after they are decrypted
    and parsed is a much better approach; in [Listing 10-2](ch10.xhtml#ch10exe2),
    those functions are the `onHealthChange()` and `onManaChange()` functions. This
    method leverages the game’s inherent ability to process packets, allowing a bot
    to remain ignorant of the various network facilities the game uses. It also gives
    you discretion over which network data you intercept, as you need to hook only
    the handlers that meet your needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包被解密和解析后，挂钩负责处理数据包的函数是一个更好的方法；在[清单 10-2](ch10.xhtml#ch10exe2)中，这些函数是 `onHealthChange()`
    和 `onManaChange()` 函数。这种方法利用了游戏本身处理数据包的能力，使机器人无需了解游戏使用的各种网络设施。它还使你可以自行决定拦截哪些网络数据，因为你只需要挂钩那些满足你需求的处理程序。
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Intercepting entire packets can sometimes be advantageous—for example, in
    any game that uses Adobe AIR and communicates using RTMPS. Since RTMPS is so heavily
    documented, there’s no need to reverse engineer the format or encryption. [Chapter
    8](ch08.xhtml#ch08) explains how to hook RTMPS in detail.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*拦截整个数据包有时是有利的——例如，在任何使用 Adobe AIR 并通过 RTMPS 通信的游戏中。由于 RTMPS 已被广泛记录，因此无需逆向工程格式或加密。[第8章](ch08.xhtml#ch08)详细解释了如何挂钩
    RTMPS。*'
- en: There are a few tricks you can use to easily find the parser function and, ultimately,
    the `switch()` statement that dispatches packets to their handlers. The most useful
    method I’ve found is to place a breakpoint on the function the game uses to receive
    data from the network, and then analyze the flow of the application when the breakpoint
    is hit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技巧可以帮助你轻松找到解析函数，并最终定位到处理数据包的 `switch()` 语句。我发现最有用的方法是将断点放在游戏用于接收网络数据的函数上，然后在断点触发时分析应用程序的流程。
- en: Let’s walk through how you might do this with OllyDbg attached to your target
    game. In Windows, `recv()` is the API function to receive data from a socket.
    From the OllyDbg command line, you can set a breakpoint on `recv()` by entering
    the `bp recv` command. When the breakpoint is hit, you can climb the call stack
    using CTRL-F9, the shortcut for execute until return, and F8, the shortcut for
    step over. This combination essentially lets the program execute until the callee
    has returned to the caller, allowing you to climb the call stack in tandem with
    the game. At each stack level, you can inspect the code of each caller until you
    find one that has a big `switch()` statement; this should be the packet parser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起走一遍在 OllyDbg 中附加到目标游戏时如何进行操作的过程。在 Windows 中，`recv()` 是接收来自套接字数据的 API 函数。在
    OllyDbg 命令行中，你可以通过输入 `bp recv` 命令来设置一个 `recv()` 的断点。当断点触发时，你可以使用 CTRL-F9（执行直到返回的快捷键）和
    F8（单步跳过的快捷键）来爬取调用堆栈。这个组合实际上让程序执行直到被调用者返回给调用者，从而让你和游戏同步地爬取调用堆栈。在每个堆栈级别，你可以检查每个调用者的代码，直到找到包含一个大型
    `switch()` 语句的调用者；这应该就是数据包解析器。
- en: '**A Trickier Parser**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更复杂的解析器**'
- en: 'Depending on the game’s architecture, though, finding the parser function may
    not be that simple. Consider a game with a parser function that looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据游戏的架构，找到解析函数可能并不像想象中那么简单。考虑一个有如下解析函数的游戏：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the `parseNextPacket()` function doesn’t have a `switch()` statement,
    there’s no obvious way to identify it in memory. Unless you pay very close attention,
    you’ll likely climb right past it on the call stack. When a game has a parser
    function like this, trying to figure out what the parser function looks like might
    be pointless. If you don’t see a `switch()` statement when climbing the `recv()`
    call stack, you’ll have to note every callee on the call stack instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `parseNextPacket()` 函数没有 `switch()` 语句，因此没有明显的方法在内存中识别它。除非你特别小心，否则很可能会在调用堆栈中跳过它。当一个游戏有像这样的解析函数时，试图弄清楚解析函数的样子可能是没有意义的。如果在爬取
    `recv()` 调用堆栈时没有看到 `switch()` 语句，你将不得不记录堆栈中的每个被调用者。
- en: Instead of climbing up the call stack from the breakpoint, you’d go to every
    address marked as a `RETURN` below ESP in the OllyDbg stack pane. These are the
    return addresses into each caller for each callee. At each return address, you’d
    need to find the top of the caller in OllyDbg’s disassembly pane and note the
    address. As a result, you’d have a list of every function call leading up to the
    `recv()` call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与其从断点开始爬取调用堆栈，不如去查看 OllyDbg 堆栈窗格中 ESP 以下标记为 `RETURN` 的每个地址。这些是每个被调用者返回到每个调用者的返回地址。在每个返回地址处，你需要在
    OllyDbg 的反汇编窗格中找到调用者的顶部并记下地址。这样，你就可以得到一份所有函数调用的列表，直到 `recv()` 调用。
- en: Next, you’d repeat the same list-making process from breakpoints placed on a
    few of the game’s handler functions. You can find a handler function by monitoring
    memory that it will inevitably use. The handler for a health change packet, for
    instance, will update your health in memory. Using OllyDbg, you can set a *memory
    on write* breakpoint to the health address. When the breakpoint gets triggered,
    it means the game updated the health value from a handler function. This should
    work the same way for most values that are controlled by the server. The server
    will control any game-critical values, such as health, mana, level, items, and
    so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要重复相同的列表制作过程，设置断点到一些游戏的处理函数上。你可以通过监控这些函数必然会使用的内存来找到一个处理函数。例如，健康变化的数据包的处理函数将会更新内存中的健康值。通过
    OllyDbg，你可以将一个 *内存写入* 断点设置到健康地址。当断点被触发时，意味着游戏从处理函数更新了健康值。这应该对于大多数由服务器控制的值同样适用。服务器会控制任何游戏关键的值，如健康、魔法、等级、物品等等。
- en: Once you’ve recorded the call stack from `recv()` and a few handler functions,
    you can correlate them to locate the parser function. For example, consider the
    three pseudo–call stacks in [Table 10-1](ch10.xhtml#ch10tab1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你记录了 `recv()` 和一些处理函数的调用堆栈，你就可以将它们关联起来，找到解析函数。例如，考虑 [表 10-1](ch10.xhtml#ch10tab1)
    中的三个伪调用堆栈。
- en: '**Table 10-1:** Pseudo–Call Stacks for Three Packet-Related Functions'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** 三个与数据包相关的函数的伪调用堆栈'
- en: '| **`recv()` stack** | **`onHealthChange()` stack** | **`onManaChange()` stack**
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **`recv()` 堆栈** | **`onHealthChange()` 堆栈** | **`onManaChange()` 堆栈** |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
- en: '| 0x40404040 | 0x50505050 | 0x60606060 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0x40404040 | 0x50505050 | 0x60606060 |'
- en: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
- en: '| 0x30303030 | 0x30303030 | 0x30303030 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 0x30303030 | 0x30303030 | 0x30303030 |'
- en: '| 0x20202020 | 0x20202020 | 0x20202020 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 0x20202020 | 0x20202020 | 0x20202020 |'
- en: '| 0x10101010 | 0x10101010 | 0x10101010 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 0x10101010 | 0x10101010 | 0x10101010 |'
- en: These stacks show what memory might look like during a call to `recv()` and
    to a game’s hypothetical `onHealthChange()` and `onManaChange()` functions. Notice
    that each function originates from a chain of four common function calls (shown
    in boldface). The deepest common address, 0xDEADBEEF, is the address of the parser.
    For a better understanding of this structure, look at the call stacks laid out
    in a tree view, as in [Figure 10-1](ch10.xhtml#ch10fig1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些栈显示了在调用 `recv()` 和游戏的假设 `onHealthChange()` 和 `onManaChange()` 函数时内存的可能状态。请注意，每个函数都起源于一链四个共同的函数调用（以粗体显示）。最深的共同地址
    0xDEADBEEF 是解析器的地址。为了更好地理解这种结构，可以查看以树形结构展示的调用栈，如 [图 10-1](ch10.xhtml#ch10fig1)
    所示。
- en: '![image](../images/f10-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-01.jpg)'
- en: '*Figure 10-1: Tree view of our three call stacks*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：我们三个调用栈的树形视图*'
- en: Each function’s call stack branches out from the function at 0xDEADBEEF, meaning
    that function is a common point of origin for all three calls. The example `parseNextPacket()`
    function is responsible for calling these functions, so it must be the most recent
    common ancestor at 0xDEADBEEF.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的调用栈都从地址 0xDEADBEEF 处分支，这意味着该函数是三个调用的共同起点。示例中的 `parseNextPacket()` 函数负责调用这些函数，因此它必须是
    0xDEADBEEF 处的最新共同祖先。
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*These call stacks are hypothetical, and they’re simplified beyond what you’ll
    typically encounter. Real call stacks will probably have quite a few more function
    calls, and comparing them won’t be as easy.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些调用栈是假设的，它们简化得比你通常遇到的情况要多。实际的调用栈可能会有更多的函数调用，比较它们的难度也会更大。*'
- en: '**A Hybrid Parsing System**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个混合解析系统**'
- en: 'A third variation of the parsing loop might be a hybrid of the previous two
    that uses a `switch()` statement after a function call. Here’s another hypothetical
    function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解析循环的第三种变体可能是前两者的混合，它在函数调用后使用 `switch()` 语句。这里是另一个假设的函数：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `processNextPacket()` function fetches a new packet and calls `dispatchPacket()`
    to handle the data. In this case, the `dispatchPacket()` function exists in the
    call stack of each handler, but not in the one for the `recv()` function. Look
    at the hypothetical stacks in [Table 10-2](ch10.xhtml#ch10tab2), for example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`processNextPacket()` 函数获取一个新的数据包，并调用 `dispatchPacket()` 来处理数据。在这种情况下，`dispatchPacket()`
    函数出现在每个处理函数的调用栈中，但不在 `recv()` 函数的调用栈中。例如，可以查看 [表 10-2](ch10.xhtml#ch10tab2) 中的假设栈。'
- en: '**Table 10-2:** Pseudo–Call Stacks for Three Packet-Related Functions'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** 三个与数据包相关的函数的伪调用栈'
- en: '| **`recv()` stack** | **`onHealthChange()` stack** | **`onManaChange()` stack**
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **`recv()` 栈** | **`onHealthChange()` 栈** | **`onManaChange()` 栈** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0x0BADF00D | 0x101E1337 | 0x14141414 |'
- en: '| 0x40404040 | 0x00ABCDEF | 0x00ABCDEF |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0x40404040 | 0x00ABCDEF | 0x00ABCDEF |'
- en: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0xDEADBEEF | 0xDEADBEEF | 0xDEADBEEF |'
- en: '| 0x30303030 | 0x30303030 | 0x30303030 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 0x30303030 | 0x30303030 | 0x30303030 |'
- en: '| 0x20202020 | 0x20202020 | 0x20202020 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0x20202020 | 0x20202020 | 0x20202020 |'
- en: '| 0x10101010 | 0x10101010 | 0x10101010 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 0x10101010 | 0x10101010 | 0x10101010 |'
- en: Although these three functions have the same first four addresses in their call
    stacks, only the two handlers have one more address in common (again shown in
    boldface). That’s 0x00ABCDEF, and it’s the address of the `dispatchPacket()` function.
    Once again, you can imagine these laid out in a tree view, as in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三个函数的调用栈中的前四个地址相同，只有两个处理程序有一个额外的共同地址（再次以粗体显示）。那个地址是 0x00ABCDEF，它是 `dispatchPacket()`
    函数的地址。你可以再次想象这些栈以树形结构展现，如 [图 10-2](ch10.xhtml#ch10fig2) 所示。
- en: '![image](../images/f10-02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-02.jpg)'
- en: '*Figure 10-2: Tree view of our three call stacks*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：我们三个调用栈的树形视图*'
- en: '**A Parser Hack**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个解析器破解**'
- en: Once you’ve located the function responsible for dispatching packets to their
    handlers, you’ll be able to spot every handler that can be called. You can deduce
    a handler’s purpose by placing a breakpoint on it and watching what values change
    in memory when it executes. Then, you can hook any handlers that your bot needs
    to react to. (Flip back to [Chapter 8](ch08.xhtml#ch08) if you need a refresher
    on how you might hook these functions. )
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了负责将数据包分发到处理函数的函数，你就能识别出可以被调用的每个处理程序。你可以通过在某个处理程序上设置断点，观察它执行时内存中变化的值，从而推断该处理程序的功能。然后，你可以挂钩你需要响应的任何处理程序。（如果你需要复习如何挂钩这些函数，可以翻回
    [第 8 章](ch08.xhtml#ch08)。）
- en: Of course, there are endless ways to implement network behavior. I can’t cover
    them all, but seeing these three common techniques should help you understand
    the methodology. No matter what game you’re dealing with, a breakpoint on `recv()`
    should be a step in the right direction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实现网络行为的方法是无穷无尽的。我无法覆盖所有方法，但看到这三种常见技巧应该能帮助你理解这种方法论。无论你处理的是哪个游戏，在`recv()`上设置一个断点应该是朝着正确方向迈出的第一步。
- en: '**Performing In-Game Actions**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行游戏内操作**'
- en: 'Before a bot can react to events, you have to teach it to play the game. It
    needs to be able to cast spells, move around, and activate items. On this front,
    bots aren’t much different from people: they can just be told which buttons to
    press. Pressing buttons is simple and suffices in many cases, but in more intricate
    situations, a bot may have to communicate on the network and tell the server what
    it’s trying to do.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人能够响应事件之前，你需要教会它如何玩游戏。它需要能够施放法术、四处移动和激活物品。在这一方面，机器人与人类并没有太大区别：它们只需被告知按下哪些按钮。按按钮很简单，许多情况下也足够用，但在更复杂的情况下，机器人可能需要通过网络与服务器进行通信，告诉服务器它正在做什么。
- en: To follow along with the examples in this section and explore on your own afterward,
    open the files in the *GameHackingExamples/Chapter10_ ResponsiveHacks/* folder
    in this book’s resource files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本节的示例并在之后自行探索，请打开本书资源文件中的*GameHackingExamples/Chapter10_ResponsiveHacks/*文件夹。
- en: '***Emulating the Keyboard***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟键盘***'
- en: The most common buttons you’ll press in a game are keyboard keys, and there
    are a couple of ways you can teach your bot to type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你最常按下的按钮是键盘按键，有几种方法可以教你的机器人进行输入。
- en: '**The SendInput() Function**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SendInput()函数**'
- en: 'One common way to emulate the keyboard is with the `SendInput()` Windows API
    function. This function, which sends keyboard and mouse input to the topmost window,
    has the following prototype:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的模拟键盘的方法是使用`SendInput()` Windows API函数。这个函数将键盘和鼠标输入发送到最上层的窗口，它的原型如下：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter, `inputCount`, is the number of inputs being sent. For the
    examples in this book, I’ll always use a value of `1`. The second parameter, `inputs`,
    is a pointer to a structure (or an array of structures whose length matches the
    `inputCount` value) with the predefined type `INPUT`. The final parameter is the
    size of inputs in memory, as calculated with the formula `size` = `inputCount`
    × `sizeof(INPUT)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`inputCount`，是发送的输入数量。对于本书中的示例，我将始终使用`1`作为值。第二个参数，`inputs`，是指向一个结构体（或者一个结构体数组，其长度与`inputCount`值匹配）的指针，该结构体类型为预定义的`INPUT`类型。最后一个参数是输入在内存中的大小，通过公式`size`
    = `inputCount` × `sizeof(INPUT)`来计算。
- en: 'The `INPUT` structure tells the `SendInput()` function what type of input to
    send, and the following code shows how you might initialize an instance of `INPUT`
    to press the F1 key:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`INPUT`结构体告诉`SendInput()`函数要发送什么类型的输入，以下代码展示了如何初始化`INPUT`实例来按下F1键：'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To have your bot actually press F1, you’d need to send this input twice, like
    so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要让你的机器人真正按下F1键，你需要像这样发送两次这个输入：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first call to `SendInput()` presses F1, and the second releases it. The
    release happens not because the input was sent twice, but because the second call
    was made with the `KEYEVENTF_KEYUP` flag enabled in the `input` parameter’s keyboard
    flags field. Since setting up `input` for even a single key is a bit messy, it’s
    best to wrap everything inside a function. The result looks something like [Listing
    10-3](ch10.xhtml#ch10exe3).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`SendInput()`按下F1键，第二次释放它。释放操作并非因为输入被发送了两次，而是因为第二次调用时，在`input`参数的键盘标志字段中启用了`KEYEVENTF_KEYUP`标志。由于即使是设置一个单一的按键输入也有些繁琐，因此最好将所有内容包装在一个函数中。结果看起来像[清单10-3](ch10.xhtml#ch10exe3)。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-3: A wrapper for emulating keystrokes with `SendInput()`*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-3：一个包装器，用于通过`SendInput()`模拟按键*'
- en: This function initializes `input` with the given `key`, enables the flag `KEYEVENTF_KEYUP`
    if `up` is set, and calls the `SendInput()` function. This means `sendKeyWithSendInput()`
    must be called a second time to send the key release, even though the release
    is always required. The function is written this way because key combinations
    that involve modifiers like SHIFT, ALT, or CTRL must be sent a bit differently;
    the modifier’s press must come before the key’s press, but its release must come
    after the key’s release.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用给定的`key`初始化`input`，如果`up`被设置，则启用`KEYEVENTF_KEYUP`标志，并调用`SendInput()`函数。这意味着即使释放键是必须的，`sendKeyWithSendInput()`仍然需要被调用第二次来发送按键释放。这样编写的原因是，因为涉及到修改键（如SHIFT、ALT或CTRL）的组合键必须以稍有不同的方式发送；修改键的按下必须在主键按下之前，释放则必须在主键释放之后。
- en: 'The following code shows how you’d use the `sendKeyWithSendInput()` function
    to tell a bot to press SHIFT-F1:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用`sendKeyWithSendInput()`函数告诉机器人按下SHIFT-F1：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’d have to call `sendKeyWithSendInput()` four times, but that’s still easier
    than using the code without a wrapper function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要调用`sendKeyWithSendInput()`四次，但这比直接使用没有包装函数的代码要简单。
- en: '**The SendMessage() Function**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SendMessage()函数**'
- en: 'An alternative method for sending keystrokes relies on the `SendMessage()`
    Windows API function. This function allows you to send input to any window, even
    if it’s minimized or hidden, by posting data directly to the target window’s message
    queue. This advantage makes it the method of choice for game hackers, because
    it enables users to do other things while their bot plays the game in the background.
    `SendMessage()` has the following prototype:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发送按键的另一种方法依赖于`SendMessage()`Windows API函数。这个函数允许你将输入发送到任何窗口，即使它被最小化或隐藏，通过直接将数据发送到目标窗口的消息队列。这一优点使其成为游戏黑客的首选方法，因为它使得用户可以在机器人在后台运行游戏的同时进行其他操作。`SendMessage()`的原型如下：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first parameter, `window`, is a handle to the window that the input is being
    sent to. The second parameter, `message`, is the type of input being sent; for
    keyboard input, this parameter is `WM_KEYUP`, `WM_KEYDOWN`, or `WM_CHAR`. The
    third parameter, `wparam`, should be the key code. The final parameter, `lparam`,
    should be `0` when the message is `WM_KEYDOWN` and `1` otherwise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`window`是输入将要发送到的窗口句柄。第二个参数`message`是发送的输入类型；对于键盘输入，此参数是`WM_KEYUP`、`WM_KEYDOWN`或`WM_CHAR`。第三个参数`wparam`应该是键码。最后一个参数`lparam`在`WM_KEYDOWN`消息时应为`0`，否则为`1`。
- en: 'Before you can use the `SendMessage()` function, you must obtain a handle to
    the target process’s main window. Given the title of the window, you can obtain
    a handle using the `FindWindow()` Windows API function, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`SendMessage()`函数之前，你必须获取目标进程主窗口的句柄。根据窗口的标题，你可以使用`FindWindow()`Windows API函数来获取句柄，如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With a valid window handle, making a call to `SendMessage()` looks something
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有有效窗口句柄的情况下，调用`SendMessage()`大致如下：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first call presses the F1 key, and the second call releases it. Keep in
    mind, however, that this series of calls works only for keys that don’t input
    text, like F1, INSERT, or TAB. To have your bot press keys that input text, you
    must also send a `WM_CHAR` message between the down and up messages. To type W,
    for instance, you’d do something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用按下F1键，第二个调用释放它。然而，请记住，这一系列调用只对不输入文本的按键有效，比如F1、INSERT或TAB。若要让你的机器人按下会输入文本的按键，你还必须在按下和释放消息之间发送`WM_CHAR`消息。例如，要输入W，你可以像这样操作：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This creates a `key` variable so the letter key to press can be changed easily.
    Then it follows the same steps the F1 example used, just with a `WM_CHAR` message
    in between.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个`key`变量，以便可以轻松更改要按下的字母键。然后，它遵循与F1示例相同的步骤，只是在中间加上了`WM_CHAR`消息。
- en: '**NOTE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can actually send nothing but the* `WM_CHAR` *message and get the same
    result, but it’s best practice to send all three messages. Game developers can
    easily shut down bots by patching the game to ignore* `WM_CHAR` *messages that
    don’t follow* `WM_KEYDOWN`*, and they can even use it as a way to detect your
    bot and ban you.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*你实际上可以只发送`WM_CHAR`消息也能得到相同的结果，但最好是发送所有三个消息。游戏开发者可以通过修补游戏来忽略那些没有跟随`WM_KEYDOWN`的`WM_CHAR`消息，从而轻松关闭机器人，甚至可以用它来检测你的机器人并封禁你。*'
- en: 'As I showed with the `SendInput()` technique, you can create a wrapper around
    this functionality to make your bot code easier to work with. The wrapper looks
    something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我通过`SendInput()`技术所展示的，你可以围绕这个功能创建一个包装器，使得你的机器人代码更容易操作。这个包装器看起来像这样：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unlike [Listing 10-3](ch10.xhtml#ch10exe3), this wrapper actually sends both
    the press and release. This is because `SendMessage()` can’t be used to send keystrokes
    with modifiers, so there’s never any need to insert code between the two calls.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单 10-3](ch10.xhtml#ch10exe3)不同，这个包装器实际上同时发送按下和释放操作。这是因为`SendMessage()`不能用于发送带有修改键的按键输入，因此不需要在两个调用之间插入代码。
- en: '**NOTE**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are multiple ways a game might check whether a modifier key is pressed,
    though. You might be able to send modifier keys to certain games by calling the*
    `SendMessage()` *function, but it depends on how those games detect modifiers.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*不过，游戏可能通过多种方式检查是否按下了修改键。您可能能够通过调用*`SendMessage()`*函数向某些游戏发送修改键，但这取决于这些游戏如何检测修改键。*'
- en: 'You can use this wrapper in a similar way as the one in [Listing 10-3](ch10.xhtml#ch10exe3).
    For example, this code sends F1 followed by W:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像在[清单 10-3](ch10.xhtml#ch10exe3)中一样使用这个包装器。例如，这段代码发送F1键，后跟W键：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example, like all of the `SendMessage()` code I’ve shown so far, simply
    gets the job done. It can input text, but it doesn’t exactly send proper messages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例，就像我之前展示的所有`SendMessage()`代码一样，简单地完成了任务。它可以输入文本，但并没有准确地发送正确的消息。
- en: There are a lot of small details you have to get right if you want to send 100
    percent valid messages with the `SendMessage()` function. For instance, the first
    16 bits of `lparam` should store the number of times the key has been automatically
    repeated as a result of being held down. The next 8 bits should store the *scan
    code*, a key identifier that is specific to each keyboard manufacturer. The next
    bit, number 24, should be set only if the button is on an extended part of the
    keyboard, such as the number pad. The following 4 bits are undocumented, and the
    next bit should be set only if the ALT key was down when the message originated.
    The last 2 bits are the previous state flag and the transition state flag. The
    previous state flag is set only if the key was previously down, and the transition
    state is set only if the key was previously in the state opposite its current
    position (that is, if the key is now up and was previously down, or vice versa).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用`SendMessage()`函数发送100%有效的消息，您需要确保处理很多小细节。例如，`lparam`的前16位应该存储由于按住键而自动重复的次数。接下来的8位应该存储*扫描码*，这是一个特定于每个键盘制造商的键标识符。接下来的第24位仅在按钮位于键盘扩展部分（例如数字键盘）时设置。接下来的4位是未记录的，接下来的1位仅在消息来源时ALT键按下时设置。最后2位是上一个状态标志和转换状态标志。上一个状态标志仅在键先前按下时设置，而转换状态仅在键的当前状态与其之前的状态相反时设置（即，如果键现在是松开的而之前是按下的，或反之）。
- en: 'Thankfully, the average game doesn’t consider most of these values. For that
    matter, the average piece of software doesn’t care about them either. If you have
    to fill all of these values with proper data to make your bot work, you’re moving
    in the wrong direction. There are many other ways to perform actions, the majority
    of which are simpler than trying to emulate the exact behavior of the operating
    system’s kernel-level keyboard input handler/dispatcher. In fact, there’s already
    a function that does that, and I’ve already talked about it: the `SendInput()`
    function.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数游戏并不在意这些值。事实上，大多数软件也不关心它们。如果您必须为这些值填充正确的数据才能让您的机器人正常工作，那么您正在朝错误的方向前进。还有许多其他更简单的方式来执行操作，其中大多数比尝试模拟操作系统内核级别的键盘输入处理器/分发器的精确行为要简单得多。事实上，已经有一个函数可以做到这一点，我之前已经提到过：`SendInput()`函数。
- en: You can also control the mouse with the `SendInput()` and `SendMessage()` functions,
    but I highly recommend avoiding it. Any mouse commands you send will affect, and
    be affected by, any legitimate mouse movements, mouse clicks, or keystrokes sent
    by the player. The same is true for keyboard input, but the complications are
    much rarer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`SendInput()`和`SendMessage()`函数来控制鼠标，但我强烈建议避免这样做。您发送的任何鼠标命令都会受到玩家发送的任何合法鼠标移动、鼠标点击或按键输入的影响，反之亦然。键盘输入也是如此，不过这种复杂性要少得多。
- en: '***Sending Packets***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送数据包***'
- en: 'Before a game draws a frame, it checks for keyboard and mouse input. When it
    receives input that results in an action, such as moving around or casting a spell,
    it checks to make sure the action is possible and, if so, tells the game server
    that the action has been performed. The game code to check for events and alert
    the server often looks something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏绘制一帧之前，它会检查键盘和鼠标输入。当它接收到导致动作的输入（例如移动或施放魔法）时，它会检查动作是否可能，如果可以，它会告诉游戏服务器该动作已经执行。检查事件并提醒服务器的游戏代码通常类似于以下内容：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `processInput()` function is called every frame. The function iterates over
    all pending inputs and dispatches different types of inputs to their relevant
    handlers. In this case, when keyboard input is received, it’s dispatched to the
    `processKeyboardInput()` function. This handler then checks whether the key is
    either W or S, and, if so, calls `step()` to move the player in the corresponding
    direction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`processInput()`函数在每一帧被调用。该函数遍历所有待处理的输入，并将不同类型的输入分派到相应的处理程序。在这个例子中，当接收到键盘输入时，它会将输入分派给`processKeyboardInput()`函数。然后，这个处理程序检查按键是否为W或S，如果是，它会调用`step()`将玩家移到相应的方向。'
- en: Since `step()` is used to perform an action, it is called an *actor* function.
    The invocation of an actor function is called *actuation*. You can directly call
    a game’s actor functions from your bot to perform an action while completely bypassing
    the input layer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`step()`用于执行动作，因此它被称为*演员*函数。调用演员函数的过程被称为*执行*。你可以直接从你的机器人调用游戏的演员函数来执行一个动作，而完全绕过输入层。
- en: Before you can call an actor, though, you must find its address. To do this,
    you can attach OllyDbg to the game, open the command line, and enter `bp send`.
    This will place a breakpoint on the `send()` function, which is used to send data
    over the network. When you play the game, every time you take a step, cast a spell,
    pick up loot, or do anything else, your breakpoint should trigger, and you can
    note each function in the call stack.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你能够调用一个演员函数之前，必须先找到它的地址。为此，你可以将OllyDbg附加到游戏上，打开命令行并输入`bp send`。这将在`send()`函数上设置一个断点，该函数用于通过网络发送数据。当你玩游戏时，每次你采取步骤、施放魔法、拾取战利品或做任何其他事情时，断点应该会触发，你可以记录下调用堆栈中的每个函数。
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The game should call* `send()` *every time you do anything while playing.
    Pay attention to what you did before each* `send()` *breakpoint is hit, as that
    will give you a rough idea of what action each call is communicating to the server,
    and, ultimately, what the actor you find is responsible for.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏应该在你玩游戏的每个动作后都调用* `send()` *。注意每次`send()`断点被触发之前你做了什么，这将给你一个大概的思路，了解每个调用传达给服务器的是什么动作，最终帮助你了解你找到的演员函数的职责。*'
- en: Once you have a few different call stacks, you can compare them to locate the
    actor functions. To see how to spot the actor functions, let’s compare the two
    annotated call stacks in [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了几个不同的调用堆栈，你可以比较它们来定位演员函数。为了了解如何识别演员函数，我们来看一下[图 10-3](ch10.xhtml#ch10fig3)中标注的两个调用堆栈。
- en: '![image](../images/f10-03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-03.jpg)'
- en: '*Figure 10-3: Tree view of call stacks to two actor functions*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：两个演员函数的调用堆栈树状视图*'
- en: Like these two stacks, the call stacks you find should be identical at the top,
    sharing a couple of common functions responsible for generic network transmission.
    They should also be identical on the bottom, since each call to `send()` should
    have originated from the `processInput()` function. Each stack should have some
    unique functions between these identical regions, though, and those are the actor
    functions you’re looking for. Typically, the function of interest is immediately
    beneath the common network calls. In this case, the two actors are the `step()`
    and `castSpell()` functions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这两个堆栈一样，你找到的调用堆栈应该在顶部是相同的，共享几个负责通用网络传输的公共函数。它们在底部也应该是相同的，因为每次调用`send()`都应该来自`processInput()`函数。尽管如此，每个堆栈在这些相同区域之间应该有一些独特的函数，这些就是你要寻找的演员函数。通常，感兴趣的函数紧跟在公共网络调用之后。在这个例子中，两个演员函数是`step()`和`castSpell()`函数。
- en: After hacking the same game for a while, you’ll learn how far up the stack the
    actor functions are from the `send()` call. In [Figure 10-3](ch10.xhtml#ch10fig3),
    for example, the actors happen three calls before the `send()` call. Knowing this,
    you could just climb the stack in OllyDbg (CTRL-F9 followed by F8) three times
    when your `send()` breakpoint is hit and be inside the actor function that sent
    the data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个游戏中黑客攻击一段时间后，你会了解到演员函数距离`send()`调用的栈深度。例如，在[图 10-3](ch10.xhtml#ch10fig3)中，演员函数是在`send()`调用前的三次调用。知道这一点后，当你的`send()`断点被触发时，你可以在OllyDbg中爬升栈（按CTRL-F9后再按F8）三次，并进入发送数据的演员函数。
- en: 'Once you’ve found an actor function, you can call it from an injected DLL.
    Here’s how you might call `step()` if you found it at 0xDEADBEEF:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了一个演员函数，你可以从注入的DLL中调用它。假设你在地址0xDEADBEEF处找到了`step()`，以下是如何调用它的示例：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the bot won’t know the actual name for this game function, the code assigns
    the contents of memory at 0xDEADBEEF to a conveniently named variable: `stepActor`.
    Then, the code just calls `stepActor()` like any other function.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于机器人并不知道该游戏函数的实际名称，因此代码将内存中0xDEADBEEF地址的内容赋值给一个方便命名的变量：`stepActor`。然后，代码就像调用任何其他函数一样调用`stepActor()`。
- en: If you’ve got the right address, function prototype, and parameters, this should
    work beautifully; you’ll be able to automate actions as if you have access to
    the game’s source code. Just make sure to call the actor functions from inside
    the same thread as the game, or you can run into threading issues. The best way
    to do this is to call the actors from a hook on a major function like Direct3D’s
    `EndScene()` or the Windows API’s `PeekMessage()` function, as these functions
    will usually be called only from the game’s main thread.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有正确的地址、函数原型和参数，这应该能完美地工作；你将能够像访问游戏源代码一样自动化操作。只要确保从与游戏相同的线程内调用演员函数，否则你可能会遇到线程问题。最好的做法是从一个主要函数的钩子中调用演员函数，比如Direct3D的`EndScene()`或Windows
    API的`PeekMessage()`函数，因为这些函数通常只会从游戏的主线程中调用。
- en: '**USING THIS TO CALL _ _THISCALL**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用此方法调用 _ _THISCALL**'
- en: If you try to call an actor function that’s a nonstatic member of a class, the
    function will have a `_thiscall` calling convention, which means you’ll need to
    pass the instance of the class on the ECX register. (You can brush up on calling
    conventions in “[Function Calls](ch04.xhtml#ch00lev1sec98)” on [page 94](ch04.xhtml#page_94).)
    Passing the instance is straightforward, but you’ll have to locate a pointer chain
    to the class instance first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试调用一个属于类的非静态成员的演员函数，该函数将采用`_thiscall`调用约定，这意味着你需要将类的实例传递到ECX寄存器中。（你可以在“[函数调用](ch04.xhtml#ch00lev1sec98)”中复习调用约定，见[第94页](ch04.xhtml#page_94)）。传递实例是直接的，但你首先需要定位到指向类实例的指针链。
- en: To find the pointer chain, you can drop a breakpoint on the actor function,
    grab the class instance value from ECX when the breakpoint kicks, and throw that
    value into a Cheat Engine pointer scan. Then, to call the function, you’d walk
    the pointer chain, obtain the current instance address, and use inline assembly
    to set up ECX and make the actual function call. This process works similarly
    to the way VF hook callbacks call their original counterparts, as shown in “[Writing
    a VF Table Hook](ch08.xhtml#ch00lev1sec158)” on [page 156](ch08.xhtml#page_156).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到指针链，你可以在演员函数上设置断点，在断点触发时从ECX中获取类实例的值，并将该值放入Cheat Engine的指针扫描中。然后，为了调用该函数，你需要遍历指针链，获取当前实例的地址，并使用内联汇编设置ECX，执行实际的函数调用。这个过程与VF钩子回调调用其原始函数的方式类似，如在“[编写VF表钩子](ch08.xhtml#ch00lev1sec158)”的[第156页](ch08.xhtml#page_156)所示。
- en: '**Tying the Pieces Together**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将各个部分结合起来**'
- en: After you’ve created frameworks for observing events and performing actions,
    you can tie them together to create responsive hacks. Responsive hacks come in
    many flavors, but there are a few common ones.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了用于观察事件和执行动作的框架之后，你可以将它们结合起来创建响应式黑客程序。响应式黑客程序有很多种类型，但有一些是常见的。
- en: '***Making the Perfect Healer***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打造完美治疗者***'
- en: 'A favorite bot among gamers is *autohealing*, a hack that automatically uses
    a healing spell when the player’s health decreases drastically or drops below
    a certain threshold. Given a way to detect changes in health and an actor function
    to cast spells, an autohealer might look something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩家中最受欢迎的机器人是*自动治疗*，这是一种在玩家的生命值急剧下降或低于某个阈值时自动使用治疗法术的黑客程序。给定一种检测生命值变化的方法和一个施放法术的演员函数，一个自动治疗器可能如下所示：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This autohealing function is pretty simple, but it works well. More advanced
    autohealers might have many more levels of healing and be able to learn as they
    go. You’ll get working example code and an in-depth explanation of advanced autohealers
    in “[Control Theory and Game Hacking](ch11.xhtml#ch00lev1sec221)” on [page 222](ch11.xhtml#page_222).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动治疗函数相当简单，但效果很好。更高级的自动治疗器可能会有更多的治疗层级，并且能够随着时间的推移不断学习。在《[控制理论与游戏黑客](ch11.xhtml#ch00lev1sec221)》一章中，你将看到实际的示例代码，并且对高级自动治疗器有更深入的解释，[第222页](ch11.xhtml#page_222)会讲解具体内容。
- en: '***Resisting Enemy Crowd-Control Attacks***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***抵抗敌人的人群控制攻击***'
- en: '*Anti-crowd-control* hacks detect incoming *crowd-control attacks* and automatically
    cast spells that reduce their effects or completely negate them. Crowd-control
    attacks disable players in some way, so having enemies cast them on you can be
    a pain.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*反人群控制*黑客会检测到即将到来的*人群控制攻击*，并自动施放减少效果或完全消除效果的法术。人群控制攻击会以某种方式禁用玩家，所以敌人对你施放这些攻击会让人很头疼。'
- en: 'Given a way to detect incoming or active crowd-control effects, such as by
    detecting a Direct3D model or by intercepting an incoming packet, and an actor
    function to cast spells, you could have a bot react instantly to such attacks
    like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有办法检测到即将到来的或已激活的人群控制效果，例如通过检测Direct3D模型或拦截即将到来的数据包，并且有一个角色函数来施放法术，那么你就可以让机器人即时反应，例如：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An `onIncomingCrowdControl()` function might try to stop the crowd-control spell
    from ever hitting you. Failing that, the bot could call an `onReceiveCrowdControl()`
    spell to remove the effects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`onIncomingCrowdControl()`函数可能会尝试阻止人群控制法术击中你。如果失败，机器人可以调用`onReceiveCrowdControl()`法术来移除效果。'
- en: '***Avoiding Wasted Mana***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***避免浪费法力***'
- en: '*Spell trainers* are also quite common among botters. Spell trainers wait until
    the player has full mana and then cast spells to increase the player’s magic level
    or stats. This allows players to quickly increase their magic skills, as they
    will never waste mana regeneration just because they have full mana.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*法术训练师*在机器人玩家中也相当常见。法术训练师会等到玩家的法力值满了，然后施放法术来提高玩家的魔法等级或属性。这使得玩家可以快速提升魔法技能，因为他们永远不会浪费法力恢复，即使法力已经满了。'
- en: 'Given a way to detect changes in mana and an actor function to cast spells,
    a bot might include the following pseudocode for a spell trainer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有办法检测到法力的变化，并且有一个角色函数来施放法术，那么一个机器人可能会包含以下伪代码来作为法术训练师：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function takes the player’s mana and the increase in that player’s mana
    (`delta`) as parameters. If the increase in mana is above a certain amount, it
    assumes the player is using potions or other items to replenish mana, and it won’t
    cast any extra spells. Otherwise, if the player has plenty of mana, the function
    fires off any old spell to get the player some experience points.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将玩家的法力和玩家法力的增量（`delta`）作为参数。如果法力的增量超过一定值，函数假设玩家正在使用药水或其他物品来补充法力，并且不会施放任何额外的法术。否则，如果玩家有充足的法力，函数会施放任何旧的法术来为玩家获取一些经验值。
- en: Other common responsive hacks are *autoreload* to instantly reload ammo, *autododge*
    to evade incoming projectiles, and *autocombo* to instantly attack the same target
    as a nearby ally. Really, the only limit to the number of responsive hacks you
    can add to a bot is the number of events your bot can observe in the game, multiplied
    by the number of valid and helpful responses it can send for each event.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的响应式黑客包括*自动重装*来立即重新装填弹药，*自动闪避*来躲避来袭的飞弹，以及*自动连招*来立即攻击与附近盟友相同的目标。实际上，你可以为机器人添加的响应式黑客的数量，唯一的限制是你的机器人能够观察到的游戏事件数量，再乘以它能为每个事件发送的有效和有帮助的响应数量。
- en: '**Closing Thoughts**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结语**'
- en: Using hooks, memory manipulation, and keyboard simulation, you can begin creating
    your first responsive hacks. These hacks are your entry point into gaming autonomy,
    but they’re only a glimpse of what’s possible. [Chapter 11](ch11.xhtml#ch11) will
    be the pinnacle of your game-hacking adventure. Using everything you’ve learned
    so far, and building on the principles of responsive hacks, you’ll learn how to
    automate advanced actions and create a truly autonomous bot.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用钩子、内存操控和键盘模拟，你可以开始创建你的第一个响应式黑客。这些黑客是你进入游戏自主性的大门，但它们只是你所能做到的一小部分。《[第11章](ch11.xhtml#ch11)》将是你游戏黑客冒险的巅峰。利用你迄今为止学到的所有知识，并基于响应式黑客的原则，你将学会如何自动化高级动作，并创建一个真正自主的机器人。
- en: If you’re not feeling quite ready to go deeper, I strongly recommend reviewing
    the earlier material and then getting some practice in an isolated environment
    on your own machine. Implementing bots like this is a lot easier than you might
    think, and it’s an amazingly satisfying experience. Once you’re comfortable making
    autohealers and other basic responsive hacks, you’ll be ready to start completely
    automating gameplay.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有准备好深入学习，我强烈建议你复习一下之前的内容，然后在自己电脑上的隔离环境中进行一些实践。实现像这样的机器人比你想象的要简单，而且这是一个非常令人满足的体验。一旦你熟悉了制作自动治疗机器人和其他基本的响应式黑客，你就准备好开始完全自动化游戏玩法了。
