- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTAINERIZATION
    WITH DOCKER</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Professional full-stack developers frequently work with Docker and, more broadly,
    containers. *Docker,* an open source containerization platform, solves three common
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: First, it lets us run a particular version of some software, such as Node.js,
    for each of our projects. Second, it decouples the development environment from
    our local machine and creates a reproducible way to run the application. Third,
    unlike traditional virtual machines, Docker containers run on a shared host. Therefore,
    they are smaller in size and consume less memory than classic virtual machines,
    which emulate a complete system and are often hardware specific. As a result,
    container-based applications are lightweight and easy to scale. These advantages
    have made Docker the most appreciated development platform in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the fundamentals of Docker. We first walk through the steps
    required to containerize our Next.js application by creating a Docker container
    running the latest Node.js version and serving the application from inside the
    container. Then we explore the concept of a microservice architecture and create
    two microservices using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Containerization Architecture</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In their daily lives, developers must regularly switch between applications
    that require different versions of the same library. For example, a JavaScript-focused
    developer might need a different Node.js or TypeScript version for each of their
    projects. Of course, they could switch the installed Node.js version on their
    local machine with tools such as nvm whenever they need to work on a different
    project. But instead of resorting to crude hacks, they could choose a more elegant
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker, we can separate our application or its services into independent
    containers, each of which provides a service-specific environment. These containers
    run on an operating system of our choosing (often Debian, Ubuntu, or Alpine),
    with only the dependencies necessary to this particular application. Containers
    are isolated from one another and communicate through defined APIs.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a Docker container during the development process, we facilitate
    the application’s later deployment. After all, the container provides a location-independent
    version of our application that is platform agnostic. Therefore, we already know
    that our application works with the installed dependencies and that no conflicts
    or additional installation steps are necessary. Instead of setting up a remote
    server with the required software and then deploying and testing our application
    afterward, we can simply move our Docker container to the server and spin it up
    there.
  prefs: []
  type: TYPE_NORMAL
- en: In situations when we need to move to a different server, scale our application,
    add additional database servers, or distribute instances across several locations,
    Docker lets us deploy our application by using the same straightforward process.
    Instead of managing different hosts and configurations, we can effectively build
    a platform-agnostic application and run the same containers everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installing Docker</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check whether you already have Docker installed, open the command line and
    run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker -v</samp>. If you see
    a version number higher than 20, you should be able to follow along with the examples
    in this chapter. Otherwise, you’ll need to install the most recent version of
    Docker from Docker Inc. Go to [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/).
    Then choose the Docker desktop installer for your operating system and download
    it. Execute the application and check the Docker version number on the command
    line. It should match the one you downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Docker Container</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker has several components. The physical or virtual machine on which the
    Docker daemon runs is the *host system*. While you’re developing your application
    locally, the host is your physical machine, and when you deploy your container,
    the host is the server that runs the application.
  prefs: []
  type: TYPE_NORMAL
- en: We use the *Docker daemon service* on the host system to interact with all components
    of the Docker platform. The daemon provides Docker’s functionality through APIs
    and is the actual Docker application installed on our machine. Access the daemon
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command
    from the command line. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    --help</samp> to display all possible interactions.
  prefs: []
  type: TYPE_NORMAL
- en: We use Docker *containers* to run our containerized applications. These containers
    are running instances of a particular Docker image, which is the artifact that
    contains the application. Each Docker image relies on a Dockerfile, which defines
    the configuration and the content of the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Dockerfile</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *Dockerfile* is a text file containing the information we need to set up a
    Docker image. It commonly builds upon some existing base image, such as a bare-bones
    Linux machine on which we’ve installed additional software or a pre-provisioned
    environment. For example, we might use a Linux image with Node.js, MongoDB, and
    all relevant dependencies installed.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we can build upon an official image. For example, [Listing 10-1](chapter10.xhtml#Lis10-1)
    shows the basic Dockerfile we use to containerize our refactored Next.js application.
    Dockerfiles contain keywords followed by commands, and we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">FROM</samp>
    keyword here to select the official Node.js Docker image. Create a file called
    *Dockerfile* in your project’s root directory, next to the *package.json* file,
    and add the code in [Listing 10-1](chapter10.xhtml#Lis10-1) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: A simple Dockerfile for a typical Node.js-based application'
  prefs: []
  type: TYPE_NORMAL
- en: The image we’ve selected contains a preconfigured Node.js system running on
    Debian. The version tag <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    gives you the most recent Node.js version; alternatively, we could provide a particular
    version number here. Hence, if you need to lock any application to a specific
    Node.js version, this is the line to do so. You could also use the slimmer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node:current-slim</samp> image, a lightweight
    Debian distribution that contains only the software packages necessary to run
    Node.js. However, we need MongoDB’s in-memory server, so we’ll choose the regular
    image. You can see a list of the available images at [*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com).
    Other images you’ll probably use in your career include those for WordPress, MySQL,
    Redis, Apache, and NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WORKDIR</samp>
    keyword to set the working directory inside the Docker image to the user’s home
    directory. All future commands will now execute in this directory. We use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">COPY</samp> keyword to add the *package
    .json* and *package-lock.json* files to the working directory. A Node.js application
    runs on port 3000 by default, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPORT</samp>
    keyword to choose port 3000 for TCP connections. This connection will provide
    access to the application from outside the container.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Docker
    Image</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a Docker image from the Dockerfile, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image build</samp> command. During the build process, the Docker daemon reads
    the Dockerfile and executes the commands defined there to download and install
    software, copy local files into the image, and configure the environment. Run
    the following next to your Dockerfile to build the image from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">--tag</samp> flag gives the
    image the name <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp> and
    sets its version to <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>.
    Now we can easily refer to this specific image at a later time. We use a period
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) at the end of the command
    to set the build context, limiting the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    build</samp> command’s file access to the current directory. In the output, the
    Docker daemon indicates that it successfully built the tagged image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to verify that we have access to the image, run the following. This command
    lists all locally available Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As expected, our newly created image has a random ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">98b28358e19a</samp>),
    is tagged as <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>, and
    is available in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>
    version. The Docker daemon may also display additional information, such as the
    size and age of the image, which aren’t relevant to us for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker provides additional commands for managing local and remote images. You
    can view a list of all available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image --help</samp>. For example, to remove an existing image from your local
    machine, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image rm</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After a while, you’ll find that you’ve collected unused or outdated versions
    of your images, so deleting them to free up space on your machine with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image prune</samp> is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Serving the Application
    from the Docker Container</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker containers are running instances of Docker images. You could use the
    same Docker image to spin up multiple containers, each with a unique name or ID.
    Once the container is running, you can synchronize local files to it. It listens
    on an exposed TCP or UDP port, so you can connect to it and execute commands inside
    it using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s containerize our application. We’ll spin up the Docker container from
    our image, map the local Next.js files to the working directory, publish the exposed
    port, and finally start the Next.js development server. We can do all of this
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container run</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this command might look complicated, but once we take a closer
    look at it, you’ll easily understand what it is doing. We pass it several flags,
    starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>
    flag, which assigns a unique name to the running container. We’ll use this name
    to identify the container later.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp>
    flag to create a Docker volume. *Volumes* are a simple way to share data between
    containers. Docker itself manages them, and they let us synchronize our application
    files to the *home/node/* directory inside the container. We use the format <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp> to
    define a volume, and depending on your file structure, you might need to adjust
    the absolute path to this folder. In this example, we map */nextjs_refactored/*
    from the user’s home folder into the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> flag
    publishes all exported ports and assigns them to random ports on the host system.
    We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    later to view the ports for our application. The last two arguments are intuitive:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> points to the
    Docker image we want to use for the container, and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> starts the Next.js development server as usual. The console output
    shows that the Node.js app inside the container is running and listening on port
    3000.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locating the Exposed
    Docker Port</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unfortunately, as soon as we try to access our Next.js application on port 3000,
    the browser notifies us that it isn’t accessible; no application is listening
    there. The problem is that we didn’t map the exposed Docker port 3000 to the host’s
    port 3000\. Instead, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp>
    flag and assigned a random port to the exposed Docker port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    to see details about all running Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Search for the name we assigned to our container, *nextjs_container*, and notice
    that port 55000 on the host maps to the Docker port 3000\. Hence, we can access
    our application at *http://localhost:55000*. Open this URL in your browser. You
    should see the Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: If you glance at the URL bar, you’ll notice that the port we use to access the
    application is different from the one used in previous chapters because it is
    now running inside the Docker container. Try to access all of the pages and APIs
    we created previously before moving to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    the Container</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can view a list of all Docker commands for interacting with containers
    by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container --help</samp>.
    In most contexts, though, you’ll find it sufficient to know just a few of these.
    For example, use <samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to
    execute commands inside an already running Docker container. We could use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to connect to a shell inside
    the container by passing it the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    flag and the path to the shell, such as */bin/sh*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    flag is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>,
    whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> runs a pseudoterminal.
    The interactive option lets us interact with the container, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp>
    pseudoterminal keeps the Docker container running so that we can actually interact
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">kill</samp> command stops
    a running Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can select the container by name or by using the container ID shown in the
    list of local running containers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Microservices with Docker Compose</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker provides us with a way to break up an application into small, autonomous
    units, called *microservices*. A microservice-driven architecture splits an application
    into a collection of self-contained services that communicate through well-defined
    APIs. It’s a relatively new architectural concept that gained traction around
    the late 2000s to early 2010s, when Docker and other tools that allowed for easier
    partitioning and orchestration of server resources became available. These tools
    form the technical foundation of a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices have several advantages. First, each independent service has a
    single purpose, which reduces its complexity. Therefore, it is more testable and
    maintainable. We can also deploy the microservices separately, spin up multiple
    instances of a single microservice to improve its performance, or swap it out
    altogether without affecting the whole application. Contrast these features with
    a traditional monolithic application whose user interface, middleware, and data
    storage exist in one single program built from a single code base. Even if a monolith
    uses a more modular approach, the code base couples them tightly, and you can’t
    swap out the elements easily.
  prefs: []
  type: TYPE_NORMAL
- en: Another characteristic feature of microservices is that dedicated teams can
    own just a single service and its code base. This means that they can select the
    appropriate tools, frameworks, and programming languages on a per-service basis.
    On the other hand, you’d typically use a single core language to write a monolithic
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create a single container from scratch, we’ll practice
    creating multiple containers; each will serve one part of an application. One
    way to use microservices is to create one service for the frontend and a second
    for the backend. The Food Finder application we’ll create in [Part II](part2.xhtml)
    will use this structure. The main benefit of this approach is that it lets us
    use a preconfigured MongoDB image for the database. For the example in this chapter,
    we’ll create a second service that watches our weather service and reruns its
    test suite as soon as the file changes. To do so, we’ll use the Docker Compose
    interface and define our microservice architecture in a *docker-compose.yml* file.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the docker-compose.yml
    File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define all services in *docker-compose.yml*, a text file in the YAML format.
    This file also sets the properties, dependencies, and volumes for each service.
    Most properties are similar to the command line flags you specify when creating
    Docker images and containers. Create the file in the root folder of your application
    and add the code from [Listing 10-2](chapter10.xhtml#Lis10-2) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: A basic docker-compose.yml file that defines the application
    and Jest services'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every *docker-compose.yml* file starts by setting the version of the Docker
    Compose specification used. Depending on the version, we can use different properties
    and values. We then define each service as a single property under <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp>.
    As discussed, we want to have two services: our Next.js application running on
    port 3000 and the Jest service, which watches the *services .test.ts* file we
    created in [Chapter 8](chapter8.xhtml) and reruns the tests as soon as we change
    a file. We limit the watch command to retest only the services. This limits the
    scope of the exercises, but of course, you can rerun all tests if you’d like.'
  prefs: []
  type: TYPE_NORMAL
- en: Each service follows roughly the same structure. First we define the image from
    which Docker Compose should create each container. This can be an official distribution
    or a locally built one. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>
    image in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp> version
    for both services. Then, instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</samp>
    flag, we map the <samp class="SANS_TheSansMonoCd_W5Regular_11">ports</samp> directly
    from 3000 to 3000\. By doing so, we can connect to the application’s port 3000
    from the host’s port 3000.
  prefs: []
  type: TYPE_NORMAL
- en: With the <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> property,
    we synchronize the files and paths from the host system into the container. This
    is similar to the mapping we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> command, but instead of supplying an absolute path, we can use relative
    paths for the source. Here we map the whole local directory *./* into the container’s
    working directory */home/node*. As before, we can edit the TypeScript files locally,
    and the application inside the container always uses the latest version of the
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, these properties have matched the command line arguments we used
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command.
    Now we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> property,
    which specifies the command that each container executes on startup. For the application
    service, we’ll start Next.js with the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> command, whereas the Jest service should call Jest directly through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>. Providing the path to
    the test file and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--watchAll</samp>
    flag causes Jest to rerun the tests when the source code changes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Containers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start the multi-container app with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> command. The output should look similar to what is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Docker daemon spins up all services. As soon as the application is ready,
    we see the status message from the Express.js server and can connect to it on
    the exposed port 3000\. At the same time, the Jest container runs the tests for
    the weather services and reports that all are successful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rerunning the Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve started the Docker environment, let’s verify that the command
    to look for changes in the code and rerun tests is working as intended. To do
    so, we need to modify the source code to trigger Jest. Therefore, we open the
    *mongoose/weather/service.ts* file and modify the contents by adding a blank line
    and then saving the file. Jest should rerun the test inside the container, as
    you can see from the output in [Listing 10-3](chapter10.xhtml#Lis10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: Rerunning the tests on files changed with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">jest
    --watchAll</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: All tests continue to pass. Connect to *http://localhost:3000* and verify that
    your browser can still render the application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    Docker Compose</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker Compose provides a complete interface for managing microservice applications.
    You can see a list of available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose --help</samp>. The following are the most essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose ls</samp>
    to get a list of all locally running Docker applications defined in *docker-compose.yml*
    files. The command returns the name and status of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To shut down all running services defined in the *docker-compose.yml* file
    in the current directory, run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose kill</samp>, which sends a <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</samp>
    command to the primary process inside each container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To kill the services with a more graceful <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGTERM</samp>
    command, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instead of forcing a shutdown, this command gracefully removes all processes,
    containers, networks, and volumes created by <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the Docker containerization platform makes it easy to deploy applications
    and use a microservice architecture. This chapter covered the building blocks
    of the Docker ecosystem: the host, the Docker daemon, Dockerfiles, images, and
    containers. Using Docker Compose and Docker volumes, you split your application
    into single, self-contained services.'
  prefs: []
  type: TYPE_NORMAL
- en: To unleash the full potential of Docker, read the official tutorials at [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/get<wbr>-started<wbr>/*](https://docs.docker.com/get-started/)
    or those at [*https://<wbr>docker<wbr>-curriculum<wbr>.com*](https://docker-curriculum.com).
    In the next chapter, you’ll start to build the Food Finder application. This full-stack
    web application will build upon the knowledge you’ve gained in all previous chapters.
  prefs: []
  type: TYPE_NORMAL
