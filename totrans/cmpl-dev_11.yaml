- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTAINERIZATION
    WITH DOCKER</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: Professional full-stack developers frequently work with Docker and, more broadly,
    containers. *Docker,* an open source containerization platform, solves three common
    problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: First, it lets us run a particular version of some software, such as Node.js,
    for each of our projects. Second, it decouples the development environment from
    our local machine and creates a reproducible way to run the application. Third,
    unlike traditional virtual machines, Docker containers run on a shared host. Therefore,
    they are smaller in size and consume less memory than classic virtual machines,
    which emulate a complete system and are often hardware specific. As a result,
    container-based applications are lightweight and easy to scale. These advantages
    have made Docker the most appreciated development platform in recent years.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the fundamentals of Docker. We first walk through the steps
    required to containerize our Next.js application by creating a Docker container
    running the latest Node.js version and serving the application from inside the
    container. Then we explore the concept of a microservice architecture and create
    two microservices using Docker.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Containerization Architecture</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In their daily lives, developers must regularly switch between applications
    that require different versions of the same library. For example, a JavaScript-focused
    developer might need a different Node.js or TypeScript version for each of their
    projects. Of course, they could switch the installed Node.js version on their
    local machine with tools such as nvm whenever they need to work on a different
    project. But instead of resorting to crude hacks, they could choose a more elegant
    solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker, we can separate our application or its services into independent
    containers, each of which provides a service-specific environment. These containers
    run on an operating system of our choosing (often Debian, Ubuntu, or Alpine),
    with only the dependencies necessary to this particular application. Containers
    are isolated from one another and communicate through defined APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: When we use a Docker container during the development process, we facilitate
    the application’s later deployment. After all, the container provides a location-independent
    version of our application that is platform agnostic. Therefore, we already know
    that our application works with the installed dependencies and that no conflicts
    or additional installation steps are necessary. Instead of setting up a remote
    server with the required software and then deploying and testing our application
    afterward, we can simply move our Docker container to the server and spin it up
    there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In situations when we need to move to a different server, scale our application,
    add additional database servers, or distribute instances across several locations,
    Docker lets us deploy our application by using the same straightforward process.
    Instead of managing different hosts and configurations, we can effectively build
    a platform-agnostic application and run the same containers everywhere.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installing Docker</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check whether you already have Docker installed, open the command line and
    run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker -v</samp>. If you see
    a version number higher than 20, you should be able to follow along with the examples
    in this chapter. Otherwise, you’ll need to install the most recent version of
    Docker from Docker Inc. Go to [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/).
    Then choose the Docker desktop installer for your operating system and download
    it. Execute the application and check the Docker version number on the command
    line. It should match the one you downloaded.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a Docker Container</samp>
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker has several components. The physical or virtual machine on which the
    Docker daemon runs is the *host system*. While you’re developing your application
    locally, the host is your physical machine, and when you deploy your container,
    the host is the server that runs the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We use the *Docker daemon service* on the host system to interact with all components
    of the Docker platform. The daemon provides Docker’s functionality through APIs
    and is the actual Docker application installed on our machine. Access the daemon
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command
    from the command line. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    --help</samp> to display all possible interactions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We use Docker *containers* to run our containerized applications. These containers
    are running instances of a particular Docker image, which is the artifact that
    contains the application. Each Docker image relies on a Dockerfile, which defines
    the configuration and the content of the Docker image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Dockerfile</samp>
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *Dockerfile* is a text file containing the information we need to set up a
    Docker image. It commonly builds upon some existing base image, such as a bare-bones
    Linux machine on which we’ve installed additional software or a pre-provisioned
    environment. For example, we might use a Linux image with Node.js, MongoDB, and
    all relevant dependencies installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Often, we can build upon an official image. For example, [Listing 10-1](chapter10.xhtml#Lis10-1)
    shows the basic Dockerfile we use to containerize our refactored Next.js application.
    Dockerfiles contain keywords followed by commands, and we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">FROM</samp>
    keyword here to select the official Node.js Docker image. Create a file called
    *Dockerfile* in your project’s root directory, next to the *package.json* file,
    and add the code in [Listing 10-1](chapter10.xhtml#Lis10-1) to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: A simple Dockerfile for a typical Node.js-based application'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The image we’ve selected contains a preconfigured Node.js system running on
    Debian. The version tag <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    gives you the most recent Node.js version; alternatively, we could provide a particular
    version number here. Hence, if you need to lock any application to a specific
    Node.js version, this is the line to do so. You could also use the slimmer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node:current-slim</samp> image, a lightweight
    Debian distribution that contains only the software packages necessary to run
    Node.js. However, we need MongoDB’s in-memory server, so we’ll choose the regular
    image. You can see a list of the available images at [*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com).
    Other images you’ll probably use in your career include those for WordPress, MySQL,
    Redis, Apache, and NGINX.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WORKDIR</samp>
    keyword to set the working directory inside the Docker image to the user’s home
    directory. All future commands will now execute in this directory. We use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">COPY</samp> keyword to add the *package
    .json* and *package-lock.json* files to the working directory. A Node.js application
    runs on port 3000 by default, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPORT</samp>
    keyword to choose port 3000 for TCP connections. This connection will provide
    access to the application from outside the container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Docker
    Image</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a Docker image from the Dockerfile, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image build</samp> command. During the build process, the Docker daemon reads
    the Dockerfile and executes the commands defined there to download and install
    software, copy local files into the image, and configure the environment. Run
    the following next to your Dockerfile to build the image from it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">--tag</samp> flag gives the
    image the name <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp> and
    sets its version to <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>.
    Now we can easily refer to this specific image at a later time. We use a period
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) at the end of the command
    to set the build context, limiting the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    build</samp> command’s file access to the current directory. In the output, the
    Docker daemon indicates that it successfully built the tagged image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to verify that we have access to the image, run the following. This command
    lists all locally available Docker images:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As expected, our newly created image has a random ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">98b28358e19a</samp>),
    is tagged as <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>, and
    is available in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>
    version. The Docker daemon may also display additional information, such as the
    size and age of the image, which aren’t relevant to us for now.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker provides additional commands for managing local and remote images. You
    can view a list of all available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image --help</samp>. For example, to remove an existing image from your local
    machine, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image rm</samp>:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After a while, you’ll find that you’ve collected unused or outdated versions
    of your images, so deleting them to free up space on your machine with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    image prune</samp> is a good practice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Serving the Application
    from the Docker Container</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker containers are running instances of Docker images. You could use the
    same Docker image to spin up multiple containers, each with a unique name or ID.
    Once the container is running, you can synchronize local files to it. It listens
    on an exposed TCP or UDP port, so you can connect to it and execute commands inside
    it using SSH.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s containerize our application. We’ll spin up the Docker container from
    our image, map the local Next.js files to the working directory, publish the exposed
    port, and finally start the Next.js development server. We can do all of this
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container run</samp>:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At first glance, this command might look complicated, but once we take a closer
    look at it, you’ll easily understand what it is doing. We pass it several flags,
    starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>
    flag, which assigns a unique name to the running container. We’ll use this name
    to identify the container later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp>
    flag to create a Docker volume. *Volumes* are a simple way to share data between
    containers. Docker itself manages them, and they let us synchronize our application
    files to the *home/node/* directory inside the container. We use the format <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp> to
    define a volume, and depending on your file structure, you might need to adjust
    the absolute path to this folder. In this example, we map */nextjs_refactored/*
    from the user’s home folder into the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp> 标志来创建一个
    Docker 卷。*卷*是容器之间共享数据的一种简单方式。Docker 本身管理它们，它们让我们将应用程序文件同步到容器内的 *home/node/* 目录。我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp>
    格式来定义卷，并根据你的文件结构，可能需要调整该文件夹的绝对路径。在这个例子中，我们将 */nextjs_refactored/* 从用户的主文件夹映射到容器内。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> flag
    publishes all exported ports and assigns them to random ports on the host system.
    We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    later to view the ports for our application. The last two arguments are intuitive:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> points to the
    Docker image we want to use for the container, and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> starts the Next.js development server as usual. The console output
    shows that the Node.js app inside the container is running and listening on port
    3000.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> 标志发布所有导出的端口，并将它们分配给主机系统上的随机端口。我们稍后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp> 查看我们应用程序的端口。最后两个参数是直观的：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> 指向我们希望用于容器的 Docker
    镜像，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> 启动 Next.js
    开发服务器，像往常一样运行。控制台输出显示容器内部的 Node.js 应用程序正在运行并监听端口 3000。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locating the Exposed
    Docker Port</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定位暴露的 Docker 端口</samp>
- en: Unfortunately, as soon as we try to access our Next.js application on port 3000,
    the browser notifies us that it isn’t accessible; no application is listening
    there. The problem is that we didn’t map the exposed Docker port 3000 to the host’s
    port 3000\. Instead, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp>
    flag and assigned a random port to the exposed Docker port.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一旦我们尝试通过端口 3000 访问 Next.js 应用程序，浏览器会通知我们该端口不可访问；没有应用程序在该端口监听。问题是我们没有将暴露的
    Docker 端口 3000 映射到主机的端口 3000。相反，我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp>
    标志，并将暴露的 Docker 端口分配给了一个随机端口。
- en: 'Let’s run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    to see details about all running Docker containers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp>
    查看所有运行中 Docker 容器的详细信息：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Search for the name we assigned to our container, *nextjs_container*, and notice
    that port 55000 on the host maps to the Docker port 3000\. Hence, we can access
    our application at *http://localhost:55000*. Open this URL in your browser. You
    should see the Next.js application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索我们为容器指定的名称，*nextjs_container*，并注意主机上的端口 55000 映射到 Docker 端口 3000。因此，我们可以在
    *http://localhost:55000* 访问我们的应用程序。在浏览器中打开此 URL，你应该能看到 Next.js 应用程序。
- en: If you glance at the URL bar, you’ll notice that the port we use to access the
    application is different from the one used in previous chapters because it is
    now running inside the Docker container. Try to access all of the pages and APIs
    we created previously before moving to the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下 URL 地址栏，你会注意到我们用来访问应用程序的端口与前几章中使用的不同，因为它现在运行在 Docker 容器内部。尝试访问我们在之前章节中创建的所有页面和
    API，然后再继续下一部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    the Container</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与容器交互</samp>
- en: 'You can view a list of all Docker commands for interacting with containers
    by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container --help</samp>.
    In most contexts, though, you’ll find it sufficient to know just a few of these.
    For example, use <samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to
    execute commands inside an already running Docker container. We could use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to connect to a shell inside
    the container by passing it the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    flag and the path to the shell, such as */bin/sh*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    flag is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>,
    whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> runs a pseudoterminal.
    The interactive option lets us interact with the container, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp>
    pseudoterminal keeps the Docker container running so that we can actually interact
    with it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">kill</samp> command stops
    a running Docker container:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can select the container by name or by using the container ID shown in the
    list of local running containers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Microservices with Docker Compose</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker provides us with a way to break up an application into small, autonomous
    units, called *microservices*. A microservice-driven architecture splits an application
    into a collection of self-contained services that communicate through well-defined
    APIs. It’s a relatively new architectural concept that gained traction around
    the late 2000s to early 2010s, when Docker and other tools that allowed for easier
    partitioning and orchestration of server resources became available. These tools
    form the technical foundation of a microservice architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Microservices have several advantages. First, each independent service has a
    single purpose, which reduces its complexity. Therefore, it is more testable and
    maintainable. We can also deploy the microservices separately, spin up multiple
    instances of a single microservice to improve its performance, or swap it out
    altogether without affecting the whole application. Contrast these features with
    a traditional monolithic application whose user interface, middleware, and data
    storage exist in one single program built from a single code base. Even if a monolith
    uses a more modular approach, the code base couples them tightly, and you can’t
    swap out the elements easily.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Another characteristic feature of microservices is that dedicated teams can
    own just a single service and its code base. This means that they can select the
    appropriate tools, frameworks, and programming languages on a per-service basis.
    On the other hand, you’d typically use a single core language to write a monolithic
    application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create a single container from scratch, we’ll practice
    creating multiple containers; each will serve one part of an application. One
    way to use microservices is to create one service for the frontend and a second
    for the backend. The Food Finder application we’ll create in [Part II](part2.xhtml)
    will use this structure. The main benefit of this approach is that it lets us
    use a preconfigured MongoDB image for the database. For the example in this chapter,
    we’ll create a second service that watches our weather service and reruns its
    test suite as soon as the file changes. To do so, we’ll use the Docker Compose
    interface and define our microservice architecture in a *docker-compose.yml* file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何从零开始创建一个单一容器，我们将练习创建多个容器；每个容器将服务于应用程序的一个部分。使用微服务的一种方法是为前端创建一个服务，为后端创建另一个服务。我们将在[第二部分](part2.xhtml)中创建的Food
    Finder应用程序将使用这种结构。此方法的主要好处是它允许我们使用预配置的MongoDB镜像作为数据库。对于本章中的示例，我们将创建第二个服务来监视我们的天气服务，并在文件更改时立即重新运行其测试套件。为此，我们将使用Docker
    Compose接口，并在*docker-compose.yml*文件中定义我们的微服务架构。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the docker-compose.yml
    File</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写docker-compose.yml文件</samp>
- en: We define all services in *docker-compose.yml*, a text file in the YAML format.
    This file also sets the properties, dependencies, and volumes for each service.
    Most properties are similar to the command line flags you specify when creating
    Docker images and containers. Create the file in the root folder of your application
    and add the code from [Listing 10-2](chapter10.xhtml#Lis10-2) to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*docker-compose.yml*中定义所有服务，这是一个YAML格式的文本文件。该文件还为每个服务设置属性、依赖关系和卷。大多数属性类似于你在创建Docker镜像和容器时指定的命令行标志。创建文件并将[清单10-2](chapter10.xhtml#Lis10-2)中的代码添加到应用程序的根文件夹中。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-2: A basic docker-compose.yml file that defines the application
    and Jest services'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-2：定义应用程序和Jest服务的基本docker-compose.yml文件
- en: 'Every *docker-compose.yml* file starts by setting the version of the Docker
    Compose specification used. Depending on the version, we can use different properties
    and values. We then define each service as a single property under <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp>.
    As discussed, we want to have two services: our Next.js application running on
    port 3000 and the Jest service, which watches the *services .test.ts* file we
    created in [Chapter 8](chapter8.xhtml) and reruns the tests as soon as we change
    a file. We limit the watch command to retest only the services. This limits the
    scope of the exercises, but of course, you can rerun all tests if you’d like.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*docker-compose.yml*文件首先通过设置所使用的Docker Compose规范的版本来开始。根据版本的不同，我们可以使用不同的属性和值。然后，我们在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">services</samp>下定义每个服务作为单独的属性。如前所述，我们希望有两个服务：我们的Next.js应用程序运行在3000端口，和Jest服务，它监视我们在[第8章](chapter8.xhtml)中创建的*services
    .test.ts*文件，并在我们更改文件时立即重新运行测试。我们将watch命令限制为仅重新测试services。这限制了练习的范围，但当然，如果你愿意，也可以重新运行所有测试。
- en: Each service follows roughly the same structure. First we define the image from
    which Docker Compose should create each container. This can be an official distribution
    or a locally built one. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>
    image in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp> version
    for both services. Then, instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</samp>
    flag, we map the <samp class="SANS_TheSansMonoCd_W5Regular_11">ports</samp> directly
    from 3000 to 3000\. By doing so, we can connect to the application’s port 3000
    from the host’s port 3000.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务的结构大致相同。首先，我们定义Docker Compose应从哪个镜像创建每个容器。这可以是官方发行版，也可以是本地构建的镜像。我们为两个服务都使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">nextjs</sup>镜像的<sup class="SANS_TheSansMonoCd_W5Regular_11">latest</sup>版本。然后，我们不使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</sup>标志，而是直接将<sup class="SANS_TheSansMonoCd_W5Regular_11">ports</sup>从3000映射到3000。这样，我们就可以从主机的3000端口连接到应用程序的3000端口。
- en: With the <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> property,
    we synchronize the files and paths from the host system into the container. This
    is similar to the mapping we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> command, but instead of supplying an absolute path, we can use relative
    paths for the source. Here we map the whole local directory *./* into the container’s
    working directory */home/node*. As before, we can edit the TypeScript files locally,
    and the application inside the container always uses the latest version of the
    files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Until now, these properties have matched the command line arguments we used
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command.
    Now we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> property,
    which specifies the command that each container executes on startup. For the application
    service, we’ll start Next.js with the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> command, whereas the Jest service should call Jest directly through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>. Providing the path to
    the test file and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--watchAll</samp>
    flag causes Jest to rerun the tests when the source code changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Containers</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start the multi-container app with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> command. The output should look similar to what is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Docker daemon spins up all services. As soon as the application is ready,
    we see the status message from the Express.js server and can connect to it on
    the exposed port 3000\. At the same time, the Jest container runs the tests for
    the weather services and reports that all are successful.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rerunning the Tests</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve started the Docker environment, let’s verify that the command
    to look for changes in the code and rerun tests is working as intended. To do
    so, we need to modify the source code to trigger Jest. Therefore, we open the
    *mongoose/weather/service.ts* file and modify the contents by adding a blank line
    and then saving the file. Jest should rerun the test inside the container, as
    you can see from the output in [Listing 10-3](chapter10.xhtml#Lis10-3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-3: Rerunning the tests on files changed with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">jest
    --watchAll</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: All tests continue to pass. Connect to *http://localhost:3000* and verify that
    your browser can still render the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with
    Docker Compose</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker Compose provides a complete interface for managing microservice applications.
    You can see a list of available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose --help</samp>. The following are the most essential.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose ls</samp>
    to get a list of all locally running Docker applications defined in *docker-compose.yml*
    files. The command returns the name and status of the application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To shut down all running services defined in the *docker-compose.yml* file
    in the current directory, run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose kill</samp>, which sends a <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</samp>
    command to the primary process inside each container:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To kill the services with a more graceful <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGTERM</samp>
    command, use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of forcing a shutdown, this command gracefully removes all processes,
    containers, networks, and volumes created by <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the Docker containerization platform makes it easy to deploy applications
    and use a microservice architecture. This chapter covered the building blocks
    of the Docker ecosystem: the host, the Docker daemon, Dockerfiles, images, and
    containers. Using Docker Compose and Docker volumes, you split your application
    into single, self-contained services.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To unleash the full potential of Docker, read the official tutorials at [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/get<wbr>-started<wbr>/*](https://docs.docker.com/get-started/)
    or those at [*https://<wbr>docker<wbr>-curriculum<wbr>.com*](https://docker-curriculum.com).
    In the next chapter, you’ll start to build the Food Finder application. This full-stack
    web application will build upon the knowledge you’ve gained in all previous chapters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
