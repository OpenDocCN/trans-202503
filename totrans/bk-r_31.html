<html><head></head><body>
<h2 class="h2" id="ch26"><span epub:type="pagebreak" id="page_691"/><span class="big"><strong>26</strong></span><br/><strong>INTERACTIVE 3D PLOTS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">When it comes to 3D plots, it’s important to be able to view them from different angles to interpret the function or surface that’s been displayed. The <code>rgl</code> package by Adler et al. (<a href="ref.xhtml#ref01">2015</a>) offers some fantastic, simple-to-use R functions that allow you to rotate and zoom in on three-dimensional plots with your mouse. In this chapter, you’ll look at a few examples that show off the possibilities of <code>rgl</code>.</p>&#13;
<p class="indent">Under the hood, <code>rgl</code> utilizes OpenGL—a standard application programming interface—to render the graphics on your computer screen. Install <code>rgl</code> (for example, by calling <code>install.packages("rgl")</code> at the prompt) and then call <code>library("rgl")</code> to load it.</p>&#13;
<h3 class="h3" id="ch26lev1sec92"><strong>26.1 Point Clouds</strong></h3>&#13;
<p class="noindent">Let’s begin with the most basic of 3D plots—<em>point clouds</em>. In statistics, this tool is typically used to provide scatterplots of three continuous variables, as you saw when you created static 3D scatterplots.</p>&#13;
<h4 class="h4" id="ch26lev2sec261"><span epub:type="pagebreak" id="page_692"/><strong><em>26.1.1 Basic 3D Cloud</em></strong></h4>&#13;
<p class="noindent">Return to the built-in <code>iris</code> data, composed of four measurements taken on three species of flower. Create the following four vectors in your workspace for accessibility, as you did in <a href="ch25.xhtml#ch25lev2sec249">Section 25.2.1</a>:</p>&#13;
<pre>R&gt; pwid &lt;- iris$Petal.Width<br/>R&gt; plen &lt;- iris$Petal.Length<br/>R&gt; swid &lt;- iris$Sepal.Width<br/>R&gt; slen &lt;- iris$Sepal.Length</pre>&#13;
<p class="indent">You use the <code>plot3d</code> function of <code>rgl</code> to display an interactive 3D cloud of points. It’s called in the way familiar for scatterplots—by supplying the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinates to the <code>x</code>, <code>y</code>, and <code>z</code> arguments, respectively. The following line opens an RGL device and produces a scatterplot of petal width, length, and sepal width from the <code>iris</code> data:</p>&#13;
<pre>R&gt; plot3d(x=pwid,y=plen,z=swid)</pre>&#13;
<p class="indent">You’ll probably want to increase the size of the device with your mouse to see the data better. Then, by left-clicking the plot and holding the button down, you can move the mouse to rotate the plot in any direction you like. If you right-click the plot and hold, you control the zoom. Specifically, rightclicking and holding while moving the mouse upward will zoom out, and right-clicking and holding while moving the mouse downward will zoom in. The axis tick marks and labels automatically appear on different sides based on your viewing angle. <a href="ch26.xhtml#ch26fig1">Figure 26-1</a> shows this plot.</p>&#13;
<div class="image"><img src="../images/f26-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig1"/>Figure 26-1: An interactive 3D scatterplot of the</em> <code>iris</code> <em>data using the</em> <code>plot3d</code> <em>function of</em> <code>rgl</code><em>. This is the default appearance of plotting the petal width, petal length, and sepal width.</em></p>&#13;
<h4 class="h4" id="ch26lev2sec262"><span epub:type="pagebreak" id="page_693"/><strong><em>26.1.2 Visual Enhancements and Legends</em></strong></h4>&#13;
<p class="noindent">You can alter the appearance of a <code>plot3d</code> scatterplot in new ways as well as some familiar ways. For example, the optional <code>type</code> argument, defaulting to <code>"p"</code> for “points,” plots the points as dots as in the most recent scatterplot. To draw points as visible 3D spheres, use <code>type="s"</code>. You can control the size of any plotted points or spheres by using <code>size</code>, and you can control the color (or colors) by using <code>col</code>. The <code>legend3d</code> function is the <code>rgl</code> analog of <code>legend</code> and is also useful; it works by changing the background image upon which the interactive plot sits.</p>&#13;
<p class="indent">To illustrate these modifications, let’s replot the same <code>iris</code> observations. First, close any currently open RGL graphics devices. Then, execute the following:</p>&#13;
<pre>R&gt; plot3d(x=pwid,y=plen,z=swid,size=1.5,type="s",<br/>          col=c(1,2,3)[as.numeric(iris$Species)])</pre>&#13;
<p class="indent">This will start a new RGL device, coloring spheres according to flower species. As usual, you pass the <code>col</code> argument a vector of the same length as the plotted coordinates, and it will assign the color to the corresponding point in an element-wise fashion. You specify the <code>size</code> parameter on a slightly different scale than the traditional R graphics parameter <code>cex</code>, and it changes according to the value of <code>type</code>—inspect the help file <code>?plot3d</code> for details. With a little experimentation, it’s not difficult to find a size value that suits the plot.</p>&#13;
<p class="indent">To add a legend, first resize the RGL device with your mouse to your preferred display size and then execute the following line:</p>&#13;
<pre>R&gt; legend3d("topright",col=1:3,legend=levels(iris$Species),pch=16,cex=2)</pre>&#13;
<p class="indent">This inserts a static, unmovable legend referencing the plotted species by color. The <code>legend3d</code> function actually calls the base R <code>legend</code> function, so they are conveniently used in the same way. With the static legend in place, the scatterplot remains fully interactive, and you can continue to rotate and zoom. <a href="ch26.xhtml#ch26fig2">Figure 26-2</a> shows all this.</p>&#13;
<p class="indent">The <code>legend3d</code> function changes the background canvas, which is why you have to open a new device and resize it manually before you add the legend. If you now produced a new <code>rgl</code> plot in the same device without closing it first or resetting the background, the flower species legend would still be there. If you’re making multiple <code>rgl</code> plots, you can reset the background to its default white canvas at any time by calling the following:</p>&#13;
<pre>R&gt; bg3d(color="white")</pre>&#13;
<p class="indent">If you try that with the most recent plot still active, you’ll see that the flower species legend disappears and the scatterplot remains. Alternatively, you can just close your RGL device when you’re done so that a new device will be used for any subsequent plot.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_694"/><img src="../images/f26-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig2"/>Figure 26-2: Replotting the</em> <code>iris</code> <em>petal width, length, and sepal width data with</em> <code>plot3d</code><em>. Observations are plotted as spheres, increased in size, and colored according to species type; a legend is added via</em> <code>legend3d</code>.</p>&#13;
<h4 class="h4" id="ch26lev2sec263"><strong><em>26.1.3 Adding Further 3D Components</em></strong></h4>&#13;
<p class="noindent">You can also add new observations and lines to a current 3D plot. The <code>rgl</code> package includes the functions <code>points3d</code>, <code>lines3d</code>, and <code>segments3d</code>, reminiscent of <code>points</code>, <code>lines</code>, and <code>segments</code> from base R graphics. As an example, in <a href="ch25.xhtml#ch25lev2sec250">Section 25.2.2</a>, you used an optional argument to add vertical lines from the base of the <em>x</em>-<em>y</em> plane to each plotted point in <code>scatterplot3d</code>. In a <code>plot3d</code> scatterplot, you would use <code>segments3d</code> to the same effect. In addition, you can add the grid that’s drawn by default on the same plane in a <code>scatterplot3d</code> plot by using the <code>grid3d</code> function for <code>rgl</code> graphics.</p>&#13;
<p class="indent">Let’s put that into practice. Take a look back at <a href="ch25.xhtml#ch25fig8">Figure 25-8</a> on <a href="ch25.xhtml#page_652">page 652</a>. To create a similar plot using <code>rgl</code> functionality, where color is used to reference the fourth continuous variable, sepal length, first re-create the palette and set up the colors for each observation. This is done here with a categorization of 50 colors (see <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>).</p>&#13;
<pre>R&gt; slen.pal &lt;- colorRampPalette(c("purple","yellow2","blue"))<br/>R&gt; cols &lt;- slen.pal(50)<br/>R&gt; slen.cols &lt;- cut(slen,breaks=seq(min(slen),max(slen),length=51),<br/>                    include.lowest=TRUE)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_695"/>Then, either close any currently active RGL devices or clear the background of the one in focus. A call to <code>plot3d</code> starts the plot with appropriately colored spheres.</p>&#13;
<pre>R&gt; plot3d(x=pwid,y=plen,z=swid,type="s",size=1.5,col=cols[slen.cols],<br/>          aspect=c(1,1.75,1),xlab="Petal width",ylab="Petal length",<br/>          zlab="Sepal width")</pre>&#13;
<p class="indent">You supply a vector of length 3 to the <code>aspect</code> argument, describing the relative lengths of the <em>x</em>-, <em>y</em>-, and <em>z</em>-axes, in that order. By changing the second entry to <code>1.75</code>, you’re lengthening the <em>y</em>-axis by that multiplicative factor relative to the others. This creates the stretched-out effect along the <em>y</em>-axis. The colors are assigned by vector indexing using the <code>slen.cols</code> factor vector, and <code>xlab</code>, <code>ylab</code>, and <code>zlab</code> are used to tidy up the axis titles.</p>&#13;
<p class="indent">Now, to add a vertical line from the <em>x</em>-<em>y</em> plane to each observation, you need to understand how to use the <code>segments3d</code> function. Unlike its base R counterpart, <code>segments3d</code> doesn’t separate the “from” and “to” coordinates into different arguments (recall the use of <code>x0</code>, <code>y0</code>, <code>x1</code>, and <code>y1</code> in <code>segments</code> and <code>arrows</code>). Instead, it takes each sequential pair of observations provided to the <code>x</code>, <code>y</code>, and <code>z</code> arguments to be the beginning and end of each line segment, in that order.</p>&#13;
<p class="indent">So, to draw the vertical lines on the existing RGL device, you first need to set up these vectors containing a “from” location and a “to” location in the 3D space. Consider the following code:</p>&#13;
<pre>R&gt; xfromto &lt;- rep(pwid,each=2)<br/>R&gt; yfromto &lt;- rep(plen,each=2)<br/>R&gt; zfromto &lt;- rep(min(swid),times=2*nrow(iris))<br/>R&gt; zfromto[seq(2,length(zfromto),2)] &lt;- swid</pre>&#13;
<p class="indent">The first two lines set up the vectors for the <em>x</em>- and <em>y</em>-components, <code>xfromto</code> and <code>yfromto</code>, respectively, by simply replicating each observation twice. These are easy, since the “from–to” values don’t change in these coordinate directions. The <em>z</em>-component does change, however. You first create the <code>zfromto</code> vector by replicating the smallest sepal width value, <code>min(swid)</code>, by two times the size of the data set, so you have a vector that matches <code>xfromto</code> and <code>yfromto</code> in length. Then, every second position of <code>zfromto</code> is overwritten using the elements of the sepal width vector. This gives you “from” <em>z</em> values for all observations, namely <code>min(swid)</code>, matched (in the pairwise fashion as required for <code>segments3d</code>) with the “to” <em>z</em> values in <code>swid</code> itself. Together with <code>xfromto</code> and <code>yfromto</code>, you’ll therefore end up with lines that go from the bottom <em>x</em>-<em>y</em> plane of the plot (the vertical position of which is automatically level at <code>min(swid)</code>) up to the actual <code>swid</code> value (which is of course the corresponding <em>z</em> value of each sphere).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_696"/>To help understand the way they’ve been set up, print the coordinate vectors to your console screen so you can see what they hold. Then a call to <code>segments3d</code> places the lines on the plot.</p>&#13;
<pre>R&gt; segments3d(x=xfromto,y=yfromto,z=zfromto,col=rep(cols[slen.cols],each=2))</pre>&#13;
<p class="indent">To ensure the color of each line matches its corresponding sphere, you also need to replicate each entry of the vector-indexed collection of colors provided by <code>cols[slen.cols]</code> twice, which implies a constant “from–to” color.</p>&#13;
<p class="indent">Then, executing the following line places a reference grid over the lower <em>x</em>-<em>y</em> plane:</p>&#13;
<pre>R&gt; grid3d(side="z-")</pre>&#13;
<p class="indent">To the <code>side</code> argument you specify the axis you want held constant (in this case, <em>z</em>) and at which end to place the grid (in this case, because you want the grid at the lower end of the <em>z</em>-axis, you specify with a minus symbol). To place the grid at the upper end of the vertical axis, which is on the top side of the rectangular prism, you would specify <code>side="z+"</code>.</p>&#13;
<p class="indent">Lastly, you can add a custom, continuous-color legend to the plot to reference the sepal length. The <code>bgplot3d</code> function is a more general version of <code>legend3d</code>; it allows you to specify any plotting commands you like to define the RGL device background. Let’s do so using the <code>colorlegend</code> function of the <code>shape</code> package, first explored in <a href="ch25.xhtml#ch25lev2sec246">Section 25.1.5</a>. Make sure you have the <code>shape</code> package loaded and that your RGL device of the scatterplot is sized to your liking. On my machine, I execute the following:</p>&#13;
<pre>R&gt; bgplot3d({plot.new();colorlegend(slen.pal(50),zlim=range(slen),<br/>                                    zval=seq(4.5,7.5,0.5),digit=1,<br/>                                    posx=c(0.91,0.93),posy=c(0.1,0.9),<br/>                                    main="Sepal length")})</pre>&#13;
<p class="indent">The <code>bgplot3d</code> function can take multiple plotting commands, which you need to provide as a code chunk within braces, <code>{}</code>, with each command separated by a semicolon (<code>;</code>). In this example, the initial call to <code>plot.new()</code> silently initializes the background of the RGL device so that you can add the continuous-color legend. Without that call, <code>colorlegend</code> will still work, but a warning will be issued. <a href="ch26.xhtml#ch26fig3">Figure 26-3</a> shows the final result, with the scatterplot still spinnable and zoomable with your mouse.</p>&#13;
<p class="indent">The ability to rotate a 3D scatterplot and any of the plots you’ll see over the next few sections with simple mouse commands is especially handy when you’re exploring visuals of higher-dimensional data. You’re not restricted to a single viewpoint, and you don’t need to manually decide on a viewing angle before actually producing the plot. The <code>rgl</code> functionality also makes it easy to add extra elements to an existing plot—something that’s harder <span epub:type="pagebreak" id="page_697"/>to do with <code>scatterplot3d</code> or <code>persp</code> plots. That said, certain features you might take for granted in more traditional plotting can be difficult to mirror in interactive plots. For example, no equivalent of the <code>pch</code> graphical parameter is readily available in <code>rgl</code>. To plot different symbols, you would need to design, render, and place new 3D shapes.</p>&#13;
<div class="image"><img src="../images/f26-03.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig3"/>Figure 26-3: This demonstrates the addition of lines and a plane grid to a</em> <code>plot3d</code> <em>3D scatterplot of the</em> <code>iris</code> <em>data to mimic the earlier</em> <code>scatterplot3d</code> <em>example of the same data.</em></p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch26exc1"/><strong>Exercise 26.1</strong></p>&#13;
<p class="noindentz">Turn back to the <code>survey</code> data frame in the <code>MASS</code> package, checking the description of the present variables in the help file <code>?survey</code> if you need to. Create a copy of <code>survey</code> containing only the writing handspan, nonwriting handspan, left- or right-handedness, sex, and height columns. Then use <code>na.omit</code> to remove any rows of this subsetted data frame that contain missing values.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Produce a basic interactive 3D point cloud of student height on the <em>z</em>-axis, writing handspan on the <em>x</em>-axis, and nonwriting handspan on the <em>y</em>-axis.</p></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_698"/>Create a more informative version of the scatterplot in (a) that uses color to distinguish between sexes and uses point size to distinguish between left- and right-handed individuals, following these guidelines:</p>&#13;
<p class="dash">– Start by plotting only those points that correspond to right-handed individuals. Set the color via vector indexing using the numeric version of sex for right-handed individuals—females should be black, males red.</p>&#13;
<p class="dash">– Set the plotted point size as 4 for the right-handed individuals and ensure tidy axis labels.</p>&#13;
<p class="dash">– Using <code>points3d</code>, add the points for left-handed individuals to the existing plot. Colors are to be assigned according to sex in the same way as for the right-handed students, but this time, the point size should be set at 10.</p>&#13;
<p class="dash">– Resize the RGL device to your liking and add a legend to the top-left corner that references the four types of points: <code>"Male RH"</code>, <code>"Female RH"</code>, <code>"Male LH"</code>, and <code>"Female LH"</code>. In setting the legend, use a <code>pch</code> value of <code>19</code> and use <code>pt.cex</code> values of <code>0.8</code> and <code>1.5</code> for right- and left-handed individuals, respectively.</p>&#13;
<p class="indenti">For reference, my version of the rotatable 3D scatterplot is shown here:</p>&#13;
<div class="imagec"><img src="../images/f0698-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
<p class="noindentz">In <a href="ch25.xhtml#ch25exc2">Exercise 25.2</a> on <a href="ch25.xhtml#page_652">page 652</a>, you looked at a static 3D scatterplot of the built-in <code>airquality</code> data. Again, create a copy of the data frame, omitting any rows with <code>NA</code> entries.</p>&#13;
<ol type="a" start="3">&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_699"/>Create a similar version of the plot from the earlier exercise using <code>rgl</code> functionality, displaying wind speed, solar radiation, and temperature on the <em>x</em>-, <em>y</em>-, and <em>z</em>-axes, respectively, according to the following guidelines:</p>&#13;
<p class="dash">– Set up 50 colors from the built-in <code>topo.colors</code> palette. Set up the appropriate color index vector for the ozone values, based on the categorization approach.</p>&#13;
<p class="dash">– Plot the observations as size 1 spheres, colored as before, and modify the aspect ratio so that the <em>y</em>-axis is 1.5 times the length of the other two axes. Provide neat axis titles.</p>&#13;
<p class="dash">– Add correspondingly colored lines, one for each observation, stretching vertically upward from the <em>x</em>-<em>y</em> plane to meet the plotted spheres. Also, place a grid on the lower <em>x</em>-<em>y</em> plane.</p>&#13;
<p class="dash">– Modify the background of the RGL device to include a color legend referencing the ozone level; use a sequence of values between 60 and 95, in steps of 5, to label it. Here’s my result:</p></li>&#13;
</ol>&#13;
<div class="imagec"><img src="../images/f0699-01.jpg" alt="image"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch26lev1sec93"><strong>26.2 Bivariate Surfaces</strong></h3>&#13;
<p class="noindent">Next you’ll look at plotting bivariate surfaces—a continuous surface calculated with respect to a 2D <em>x</em>-<em>y</em> evaluation grid—with <code>rgl</code>. In <a href="ch25.xhtml#ch25">Chapter 25</a>, you plotted these using <code>contour</code>, <code>filled.contour</code>, <code>image</code>, and <code>persp</code> in base R graphics. Anything that you’re able to plot using those functions can also be plotted as an interactive perspective plot with the <code>persp3d</code> function of <code>rgl</code>.</p>&#13;
<h4 class="h4" id="ch26lev2sec264"><span epub:type="pagebreak" id="page_700"/><strong><em>26.2.1 Basic Perspective Surface</em></strong></h4>&#13;
<p class="noindent">Take the <code>mtcars</code> response surface of mean MPG as a function of horsepower and weight (first used in <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>) as an easy initial example. In <a href="ch25.xhtml#ch25lev2sec258">Section 25.6.1</a>, you plotted static, base R perspective plots of this surface. The next few lines will refit the multiple linear regression model and re-create the 20 × 20 evaluation grid <em>x</em>- and <em>y</em>-sequences:</p>&#13;
<pre>R&gt; car.fit &lt;- lm(mpg~hp*wt,data=mtcars)<br/>R&gt; len &lt;- 20<br/>R&gt; hp.seq &lt;- seq(min(mtcars$hp),max(mtcars$hp),length=len)<br/>R&gt; wt.seq &lt;- seq(min(mtcars$wt),max(mtcars$wt),length=len)<br/>R&gt; hp.wt &lt;- expand.grid(hp=hp.seq,wt=wt.seq)</pre>&#13;
<p class="indent">To create the surface, predict using the evaluation grid in <code>hp.wt</code> as you’ve done previously, but this time, include the calculation of a prediction interval for the raw observations.</p>&#13;
<pre>R&gt; car.pred &lt;- predict(car.fit,newdata=hp.wt,interval="prediction",level=0.99)</pre>&#13;
<p class="indent">(You’ll use the interval in a later example.) Then, construct the <em>z</em>-matrix and draw a green <code>persp3d</code> surface with the following two lines:</p>&#13;
<pre>R&gt; car.pred.mat &lt;- matrix(car.pred[,1],nrow=len,ncol=len)<br/>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.mat,col="green")</pre>&#13;
<p class="indent">The result is shown on the left of <a href="ch26.xhtml#ch26fig4">Figure 26-4</a>. If you compare it to <a href="ch25.xhtml#ch25fig19">Figure 25-19</a> on <a href="ch25.xhtml#page_681">page 681</a>, you can see that it shows the same surface. The default lighting and shadowing effect produced by the <code>persp3d</code> surface helps with depth perception, similar to the <code>shade</code> argument to <code>persp</code>. The main benefit of this version is the mouse-based rotation and zoom interactivity.</p>&#13;
<div class="image"><img src="../images/f26-04.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig4"/>Figure 26-4: Two interactive</em> <code>persp3d</code> <em>versions of the</em> <code>mtcars</code> <em>response surface. Left: Default appearance in green. Right: Red, 70 percent opacity surface, with original data superimposed in the 3D space. Both plots can be rotated and zoomed with the mouse.</em></p>&#13;
<h4 class="h4" id="ch26lev2sec265"><span epub:type="pagebreak" id="page_701"/><strong><em>26.2.2 Additional Components</em></strong></h4>&#13;
<p class="noindent">Another useful attribute of a <code>persp3d</code> plotted surface is the ability to add further components easily—something that’s nowhere near as straightforward in base R functionality. You’ll continue using the objects just created for the <code>mtcars</code> response surface.</p>&#13;
<h5 class="h5" id="ch26lev3sec116"><strong>Adding Points</strong></h5>&#13;
<p class="noindent">As this response surface is based on a model fitted to data on the three variables of horsepower, weight, and MPG, it would be useful to view the raw observations alongside the fitted model. For this, you can use <code>points3d</code>, which works just like <code>points</code> in base R graphics. Execute the following:</p>&#13;
<pre>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.mat,col="red",alpha=0.7,<br/>           xlab="Horsepower",ylab="Weight",zlab="mean MPG")<br/>R&gt; points3d(mtcars$hp,mtcars$wt,mtcars$mpg,col="green3",size=10)</pre>&#13;
<p class="indent">Resize the RGL device to your liking and keep the device open. These two commands plotted the predicted mean MPG response surface, this time in red at 70 percent opacity using the optional <code>alpha</code> argument, and then added the raw observations to the same image in green, slightly enlarged from their default size. You can see this plot on the right of <a href="ch26.xhtml#ch26fig4">Figure 26-4</a>; you can now compare the fit of the response surface to the raw data and view it from any angle.</p>&#13;
<h5 class="h5" id="ch26lev3sec117"><strong>Adding Surfaces</strong></h5>&#13;
<p class="noindent">You can also add more perspective surfaces! Let’s continue to add to the current plot using the <code>car.pred</code> object you created for <a href="ch26.xhtml#ch26fig4">Figure 26-4</a>. The response surface is stored as the first column in <code>car.pred</code>; the corresponding lower and upper prediction limits are stored as the second and third columns—flip back to <a href="ch20.xhtml#ch20lev2sec182">Section 20.4.2</a> for a discussion of <code>predict</code> for linear regression models. To add these prediction bounds to the response surface displayed on the right of <a href="ch26.xhtml#ch26fig4">Figure 26-4</a>, you first need to store each bounding surface as a <em>z</em>-matrix corresponding to the <em>x</em>-<em>y</em> evaluation grid.</p>&#13;
<pre>R&gt; car.pred.lo &lt;- matrix(car.pred[,2],nrow=len,ncol=len)<br/>R&gt; car.pred.up &lt;- matrix(car.pred[,3],nrow=len,ncol=len)</pre>&#13;
<p class="indent">Then, simply call <code>persp3d</code> for each of these <em>z</em>-matrices and use the optional <code>add</code> argument set to <code>TRUE</code>—this instructs the <code>persp3d</code> function to add to the existing graphic without refreshing the plot.</p>&#13;
<pre>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.up,col="cyan",add=TRUE,alpha=0.5)<br/>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.lo,col="cyan",add=TRUE,alpha=0.5)</pre>&#13;
<p class="indent">Here you’ve also set the color for each additional surface to cyan and set the opacity at 50 percent. You can see the result on the left of <a href="ch26.xhtml#ch26fig5">Figure 26-5</a>. <span epub:type="pagebreak" id="page_702"/>After rotating it with your mouse, you’ll be able to see that the observations all fall between the 3D 99 percent prediction interval bounds for this particular model.</p>&#13;
<div class="image"><img src="../images/f26-05.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig5"/>Figure 26-5: Adding further surfaces denoting the 99 percent prediction interval to an existing</em> <code>persp3d</code> <em>plot of the fitted</em> <code>mtcars</code> <em>model. Left: Green points make up the raw observations. Right: Raw observations are labeled with added text, and corresponding line segments mark the corresponding residuals.</em></p>&#13;
<p class="indent">Alternatively, you could label raw observations with the row names attribute of the original <code>mtcars</code> data frame as added text so that you could identify which car is which in the plot. In this case, the names are obtained as a vector of character strings using the built-in <code>rownames</code> function. To add text to an existing 3D graphic, <code>rgl</code> has its own analog of the traditional <code>text</code> function, <code>text3d</code>. Executing the following four lines replots the translucent red response surface, adds the appropriate text at the (<em>x</em>, <em>y</em>, <em>z</em>) coordinates corresponding to that car, and again adds the cyan prediction interval:</p>&#13;
<pre>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.mat,col="red",alpha=0.7,<br/>           xlab="Horsepower",ylab="Weight",zlab="mean MPG")<br/>R&gt; text3d(x=mtcars$hp,y=mtcars$wt,z=mtcars$mpg,texts=rownames(mtcars),cex=0.75)<br/>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.up,col="cyan",add=TRUE,alpha=0.5)<br/>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.lo,col="cyan",add=TRUE,alpha=0.5)</pre>&#13;
<p class="indent">The text is harder to visually locate than the green dots, so it makes sense to point their locations out on the fitted surface—and what better way to do so than using the fitted model residuals? The <code>segments3d</code> function is ideal for this purpose, as you know from the 3D scatterplots of the <code>iris</code> data. First, you need to set up the “from–to” vectors in the three coordinates (refer to <a href="ch26.xhtml#ch26lev1sec92">Section 26.1</a> for an explanation of <code>segments3d</code>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_703"/>R&gt; xfromto &lt;- rep(mtcars$hp,each=2)<br/>R&gt; yfromto &lt;- rep(mtcars$wt,each=2)<br/>R&gt; zfromto &lt;- rep(car.fit$fitted.values,each=2)<br/>R&gt; zfromto[seq(2,2*nrow(mtcars),2)] &lt;- mtcars$mpg</pre>&#13;
<p class="indent">Here, again, the <em>x</em>- and <em>y</em>-axis values don’t change when moving from the “from” location to the “to” location, so these are simply double-replicates of each horsepower and weight entry of the original data frame. You need to instruct the <em>z</em>-axis “from” values to remain as the fitted values of the model (in other words, the actual vertical location of the response surface), and the “to” values are the raw data <em>z</em> values. Then, a final call to <code>segments3d</code> draws on the residuals, as standard black line segments, for each <code>text3d</code>-labeled car.</p>&#13;
<pre>R&gt; segments3d(x=xfromto,y=yfromto,z=zfromto)</pre>&#13;
<p class="indent">Take a moment to interact with the final product, shown on the right of <a href="ch26.xhtml#ch26fig5">Figure 26-5</a>.</p>&#13;
<h4 class="h4" id="ch26lev2sec266"><strong><em>26.2.3 Coloring by z Value</em></strong></h4>&#13;
<p class="noindent">One advantage of <code>persp3d</code> plots is that you can color the surface according to the <em>z</em> values without needing to do anything special. Recall that if you were using the base R <code>persp</code> function, coloring by <em>z</em> value would require a minor workaround, because you’d need to calculate the relevant vertical position as the average of four adjacent <em>z</em>-matrix entries that make up each facet (see <a href="ch25.xhtml#ch25lev2sec259">Section 25.6.2</a>).</p>&#13;
<p class="indent">Fortunately, this isn’t necessary with <code>persp3d</code>. Continuing one last time with the <code>mtcars</code> response surface, you can set up your desired color palette and assign colors to the entries of the <em>z</em>-matrix themselves without having to average out each set of four adjacent values first.</p>&#13;
<pre>R&gt; blues &lt;- colorRampPalette(c("cyan","navyblue"))<br/>R&gt; blues200 &lt;- blues(200)<br/>R&gt; zm &lt;- car.pred.mat<br/>R&gt; zm.breaks &lt;- seq(min(zm),max(zm),length=201)<br/>R&gt; zm.colors &lt;- cut(zm,breaks=zm.breaks,include.lowest=TRUE)</pre>&#13;
<p class="indent">Then, using categorization to assign color to values on a continuum, you just need to index <code>blues200</code> by <code>zm.colors</code> when specifying the <code>col</code> value in <code>persp3d</code>.</p>&#13;
<pre>R&gt; persp3d(x=hp.seq,y=wt.seq,z=car.pred.mat,col=blues200[zm.colors],<br/>           alpha=0.6,xlab="Horsepower",ylab="Weight",zlab="mean MPG")</pre>&#13;
<p class="indent"><a href="ch26.xhtml#ch26fig6">Figure 26-6</a> shows the result.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_704"/><img src="../images/f26-06.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig6"/>Figure 26-6: Showing a result of direct color assignment corresponding to the</em> z<em>-matrix value in use of</em> <code>persp3d</code> <em>for the</em> <code>mtcars</code> <em>response surface</em></p>&#13;
<h4 class="h4" id="ch26lev2sec267"><strong><em>26.2.4 Dealing with the Aspect Ratio</em></strong></h4>&#13;
<p class="noindent">Taking a break from the <code>mtcars</code> model, you’ll now return to the bivariate kernel density estimate of the Chorley-Ribble data, used in <a href="ch25.xhtml#ch25lev2sec257">Sections 25.5.2</a> and <a href="ch25.xhtml#ch25lev2sec259">25.6.2</a>. Load the <code>spatstat</code> package to access the <code>chorley</code> data and use the <code>MASS</code> package to access the <code>kde2D</code> function. Repeated from earlier for convenience, the following code calculates the KDE surface using <code>kde2D</code>, stored as the <code>$z</code> component of the <code>chor.dens.WIN</code> object:</p>&#13;
<pre>R&gt; chor.WIN &lt;- chorley$window<br/>R&gt; chor.dens.WIN &lt;- kde2d(chorley$x,chorley$y,n=256,<br/>                          lims=c(chor.WIN$xrange,chor.WIN$yrange))<br/>R&gt; chor.xy &lt;- expand.grid(chor.dens.WIN$x,chor.dens.WIN$y)<br/>R&gt; chor.out.mat &lt;- matrix(!inside.owin(x=chor.xy[,1],y=chor.xy[,2],<br/>                                       w=chor.WIN),<br/>                          256,256)<br/>R&gt; chor.dens.WIN$z[chor.out.mat] &lt;- NA</pre>&#13;
<p class="indent">It also truncates the surface to fall within the polygon that represents the geographical study region by setting all elements of the <em>z</em>-matrix outside that polygon to <code>NA</code> (you studied in detail how to do this in <a href="ch25.xhtml#ch25lev2sec257">Section 25.5.2</a>).</p>&#13;
<p class="indent">Then, executing the next few lines of code generates 200 colors from the built-in <code>rainbow</code> palette that you’ve used previously for this KDE plot and categorizes the entries of the truncated <em>z</em>-matrix appropriately:</p>&#13;
<pre>R&gt; zm &lt;- chor.dens.WIN$z<br/>R&gt; rbow &lt;- rainbow(200,start=0,end=5/6)<br/><span epub:type="pagebreak" id="page_705"/>R&gt; zm.breaks &lt;- seq(min(zm,na.rm=TRUE),max(zm,na.rm=TRUE),length=201)<br/>R&gt; zm.colors &lt;- cut(zm,breaks=zm.breaks,include.lowest=TRUE)</pre>&#13;
<p class="indent">Note again that the difference here is you don’t need to calculate facet averages as you did in <a href="ch25.xhtml#ch25lev2sec259">Section 25.6.2</a>—<code>cut</code> is applied directly to <code>zm</code>.</p>&#13;
<p class="indent">Before calling <code>persp3d</code>, it’s worth remembering that since you’re dealing with a geographical area, you should consider the aspect ratio in the <em>x</em>- and <em>y</em>-coordinate directions. As you saw in <a href="ch26.xhtml#ch26lev1sec92">Section 26.1</a>, the <code>aspect</code> argument in <code>rgl</code> functions operates a little differently than the <code>asp</code> argument in <code>image</code> or the <code>scale</code>/<code>expand</code> arguments in <code>persp</code>. In <code>rgl</code> plots, including <code>persp3d</code>, <code>aspect</code> requests a numeric vector of length 3, which defines the relative scale of the <em>x</em>-, <em>y</em>-, and <em>z</em>-axes, in that order.</p>&#13;
<p class="indent">To determine the appropriate relative scales for the Chorley-Ribble data, you need to calculate the total <em>x</em>-axis and <em>y</em>-axis widths that the study region is defined upon and find their ratio.</p>&#13;
<pre>R&gt; xd &lt;- chor.WIN$xrange[2]-chor.WIN$xrange[1]<br/>R&gt; xd<br/>[1] 23<br/>R&gt; yd &lt;- chor.WIN$yrange[2]-chor.WIN$yrange[1]<br/>R&gt; yd<br/>[1] 21.38<br/>R&gt; xd/yd<br/>[1] 1.075772</pre>&#13;
<p class="indent">This was done using the <code>$xrange</code> and <code>$yrange</code> components of the <code>spatstat</code> polygon, subtracting the lower limit from the upper in each case. The final ratio of <code>xd/yd</code> reveals that you almost have a one-to-one scale, though technically the region is physically wider in the <em>x</em>-axis, by a factor of around 1.076, than it is in the <em>y</em>-axis.</p>&#13;
<p class="indent">Factoring that in, you can call <code>persp3d</code> to plot the KDE surface correctly.</p>&#13;
<pre>R&gt; persp3d(chor.dens.WIN$x,chor.dens.WIN$y,chor.dens.WIN$z,<br/>           col=rbow[zm.colors],aspect=c(xd/yd,1,0.75),<br/>           xlab="Eastings (km)",ylab="Northings (km)",<br/>           zlab="Kernel estimate")</pre>&#13;
<p class="indent">You use <code>aspect</code> to stipulate that the <em>x</em>-axis should be scaled according to a factor of <code>xd/yd</code> relative to the <em>y</em>-axis, that the <em>y</em>-axis is taken as the reference scale of 1, and that the <em>z</em>-axis should be squashed by a factor of 0.75 relative to the <em>y</em>-axis. This is arbitrarily set so that the graphic is similar to the original <code>persp</code> plot in <a href="ch25.xhtml#ch25fig21">Figure 25-21</a> on <a href="ch25.xhtml#page_685">page 685</a>.</p>&#13;
<p class="indent">Let’s finish off the plot by adding a color legend. Ensure you have the <code>shape</code> package loaded, resize your RGL device containing the result of the most recent call to <code>persp3d</code>, and execute the following command:</p>&#13;
<pre>bgplot3d({plot.new();<br/>          colorlegend(col=rbow,zlim=range(chor.dens.WIN$z,na.rm=TRUE),<br/><span epub:type="pagebreak" id="page_706"/>                     zval=seq(0,0.02,0.0025),main="KDE",digit=4,<br/>                     posx=c(0.87,0.9),posy=c(0.2,0.8))})</pre>&#13;
<p class="indent">Remember that <code>bgplot3d</code> must be used to change the background of the current RGL device—refer to the end of <a href="ch26.xhtml#ch26lev1sec92">Section 26.1</a>. You might want to experiment a little with <code>posx</code> and <code>posy</code> to find your preferred placement of the color legend. <a href="ch26.xhtml#ch26fig7">Figure 26-7</a> shows the result on my machine.</p>&#13;
<div class="image"><img src="../images/f26-07.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig7"/>Figure 26-7: An interactive</em> <code>persp3d</code> <em>representation of the Chorley-Ribble kernel density estimate, colored according to</em> z<em>-axis values, with a static color legend</em></p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch26exc2"/><strong>Exercise 26.2</strong></p>&#13;
<p class="noindentz">Return to the measurements in the built-in <code>airquality</code> data frame. Create a copy of the data frame containing the variables pertaining to temperature, wind speed, ozone level, and month; delete all rows with any missing values. You’re now going to experiment with an <code>rgl</code> visualization of an earlier regression model for mean temperature.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Refit the multiple linear model from <a href="ch25.xhtml#ch25exc4">Exercise 25.4</a> on <a href="ch25.xhtml#page_676">page 676</a>, which regressed temperature against the main effects and an interactive effect of wind speed and ozone. Use <code>expand.grid</code> and <code>predict</code> to construct a <em>z</em>-matrix of the response surface; include the estimation of a 95 percent confidence interval for the fitted mean. Then, use <code>rgl</code> functionality to produce an interactive 3D plot of the response surface and color it yellow.</p></li>&#13;
<li><p class="noindents">Using the built-in <code>topo.colors</code> palette, replot the response surface, assigning the colors according to the <em>z</em> value and setting the <span epub:type="pagebreak" id="page_707"/>opacity at 80 percent. Tidy up the axis titles, resize the RGL device, and leave the plot open.</p></li>&#13;
<li><p class="noindents">Enhance the plot from (b) as follows:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Generate exactly five colors from a custom palette that goes from <code>"red4"</code> to <code>"pink"</code> and add the raw wind, ozone, and temperature observations as points to the plot of the response surface. The points should be colored according to month (May through September) using these five colors in order. Set the size of the added points to <code>10</code>.</p></li>&#13;
<li><p class="noindents">Add vertical lines that denote the residuals of the fitted model to the plot; in other words, each observation should have a vertical line connecting it to the corresponding fitted value of the response surface. These added lines should use the custom palette from earlier to match the color of each data point.</p></li>&#13;
<li><p class="noindents">Add the upper and lower 95 percent confidence limits you stored as part of the model prediction in (a). The added surfaces should both be gray with 50 percent opacity.</p></li>&#13;
<li><p class="noindents">Add a legend to the top-right corner of the interactive plot referencing the five colors of points/lines according to month. Use a <code>pch</code> value of <code>19</code> and a <code>cex</code> value of <code>2</code>.</p>&#13;
<p class="noindent">The result should look like this:</p>&#13;
<div class="imagec"><img src="../images/f0707-01.jpg" alt="image"/></div></li>&#13;
</ol></li>&#13;
</ol>&#13;
<p class="noindentz">Next, load the <code>spatstat</code> package and revisit the <code>clmfires</code> data set. Execute the following lines to restrict attention to only the intentionally lit fires and to obtain the geographical study region:</p>&#13;
<p class="programs-b1">R&gt; fire &lt;- split(clmfires)$intentional<br/>R&gt; firewin &lt;- clmfires$window</p>&#13;
<ol type="a" start="4">&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_708"/>Reproduce the static perspective plot from <a href="ch25.xhtml#ch25exc5">Exercise 25.5</a> (e) on <a href="ch25.xhtml#page_689">page 689</a> as an interactive perspective plot, based on the following guidelines. Then keep the plot open.</p>&#13;
<p class="dash">– Calculate the KDE surface of the <code>$x</code>- and <code>$y</code>-coordinates of <code>fire</code>, truncated to the study region in <code>firewin</code>, using a 256 × 256 evaluation grid.</p>&#13;
<p class="dash">– Use the built-in color palette <code>heat.colors</code> to color the surface according to the <em>z</em> value. Set the opacity to 70 percent.</p>&#13;
<p class="dash">– Ensure the <em>x</em>-<em>y</em> axes have the correct ratio. Then reduce the vertical aspect ratio to be 0.6 relative to the <em>y</em>-axis.</p>&#13;
<p class="dash">– Suppress the <em>z</em>-axis title but add neat <code>"X"</code> and <code>"Y"</code> titles to the other two axes.</p></li>&#13;
<li><p class="noindents">Make the following enhancements to the plot:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Add the raw observations so they lie underneath the surface itself. To do this, set a constant <em>z</em> value for each data point as the minimum (and non-<code>NA</code>) value of the <em>z</em>-matrix.</p></li>&#13;
<li><p class="noindents">You can obtain the vectors of the <em>x</em>- and <em>y</em>-coordinates of the irregular polygon that forms the study region by using the <code>vertices</code> function of <code>spatstat</code> as follows:</p>&#13;
<p class="programs-e">R&gt; firepoly &lt;- vertices(firewin)<br/>R&gt; fwx &lt;- firepoly$x<br/>R&gt; fwy &lt;- firepoly$y</p>&#13;
<p class="indent">By supplying these two vectors to the appropriate <code>x</code> and <code>y</code> arguments of the <code>lines3d</code> function, add the study region to surround the superimposed observations lying flush to the <em>x</em>-<em>y</em> plane underneath the plotted surface. Again, you’ll need to specify the <em>z</em> value as the minimum <em>z</em>-matrix value for all drawn lines. Set <code>lwd=2</code> for a slightly thicker line than the one drawn by default.</p>&#13;
<p class="noindentt">Your production should look something like this:</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
<div class="imagec"><img src="../images/f0708-01.jpg" alt="image"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch26lev1sec94"><span epub:type="pagebreak" id="page_709"/><strong>26.3 Trivariate Surfaces</strong></h3>&#13;
<p class="noindent">So far you’ve looked at bivariate functions of the form <em>z</em> = <em>f</em> (<em>x</em>, <em>y</em>), where your evaluation grid is two-dimensional. In other words, you evaluate the function <em>f</em> from an <em>x</em> value and a <em>y</em> value; the <em>x</em> and <em>y</em> values are plotted on the first two axes, and the values of <em>f</em> are used to plot a third dimension. Next you’ll plot <em>trivariate</em> functions, which can be thought of as <em>w</em> = <em>f</em> (<em>x</em>, <em>y</em>, <em>z</em>). That is, the evaluation grid is itself three-dimensional, and <em>f</em> gives you a fourth value, <em>w</em>, to use for plotting the surface.</p>&#13;
<h4 class="h4" id="ch26lev2sec268"><strong><em>26.3.1 Evaluation Coordinates in 3D</em></strong></h4>&#13;
<p class="noindent">When dealing with a trivariate mathematical function, you need an <em>x</em>, a <em>y</em>, and a <em>z</em> value to evaluate the result. Rather than a flat evaluation grid, you’ll have an evaluation <em>lattice</em> that sits in a cube or some other 3D prism.</p>&#13;
<p class="indent">As a perfect first example of a trivariate function, you’ll create a “color cube” of RGB colors, where each point is the result of three values in red, green, and blue—refer to <a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a> for details. You’ll use the three physical axes to reflect the evaluation lattice in the red, green, and blue values, and the result will be a point plotted with that color in that position in the 3D space.</p>&#13;
<p class="indent">The following code sets up the evaluation lattice in the three coordinate directions:</p>&#13;
<pre>R&gt; reds &lt;- seq(0,255,25)<br/>R&gt; reds<br/> [1]   0  25  50  75 100 125 150 175 200 225 250<br/>R&gt; greens &lt;- seq(0,255,25)<br/>R&gt; blues &lt;- seq(0,255,25)<br/>R&gt; full.rgb &lt;- expand.grid(reds,greens,blues)<br/>R&gt; nrow(full.rgb)<br/>[1] 1331</pre>&#13;
<p class="indent">The first four lines generate equally spaced increasing sequences in the three colors spanning the standard 0 to 255 RGB integer range. Then you use the built-in <code>expand.grid</code> function to generate the data frame of all unique color triplets according to these three sequences, resulting in an evaluation lattice of exactly 11<sup>3</sup> = 1331 specific coordinates. Note that <code>expand.grid</code> works in the same way for higher-dimensional evaluation grids as it does for bivariate <em>x</em>-<em>y</em> grids (refer to <a href="ch25.xhtml#ch25lev2sec251">Section 25.3.1</a>).</p>&#13;
<p class="indent">Finally, a call to <code>plot3d</code> places spheres at each 3D evaluation coordinate (recall the use of the <code>rgb</code> command from <a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a>):</p>&#13;
<pre>R&gt; plot3d(x=full.rgb[,1],y=full.rgb[,2],z=full.rgb[,3],<br/>          col=rgb(full.rgb,maxColorValue=255),type="s",<br/>          size=1.5,xlab="Red",ylab="Green",zlab="Blue")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_710"/><a href="ch26.xhtml#ch26fig8">Figure 26-8</a> shows the result from two different angles so you can see how the intensities of the red, green, and blue components of an RGB triplet control the color of each point.</p>&#13;
<div class="image"><img src="../images/f26-08.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig8"/>Figure 26-8: The</em> <code>rgl</code> <em>“color cube,” created as spheres whose fourth-dimension result (color itself) is the product of evaluating the trivariate RGB function.</em></p>&#13;
<h4 class="h4" id="ch26lev2sec269"><strong><em>26.3.2 Isosurfaces</em></strong></h4>&#13;
<p class="noindent">One of the problems with plotting the individual spheres of points at each 3D evaluation coordinate is revealed by <a href="ch26.xhtml#ch26fig8">Figure 26-8</a>—it’s difficult to see spheres “inside” the 3D prism. This same issue complicates the more general case of visualizing a continuous trivariate function.</p>&#13;
<p class="indent">To remedy this, you could instead produce an <em>isosurface</em>, which can be thought of as a kind of trivariate analog of a contour plot.</p>&#13;
<p class="indent">With an isosurface, you select a certain level of the values <em>w</em> = <em>f</em> (<em>x</em>, <em>y</em>, <em>z</em>) and join up all the entries of <em>w</em> at that level inside the 3D space to form a shape or “blob.” These blobs show where in the 3D space the trivariate function takes on the chosen value. If you then plot these blobs at various levels, you get a 3D version of the contour plots you created in <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>, showing which levels hold the highest densities of observations.</p>&#13;
<h5 class="h5" id="ch26lev3sec118"><strong>Higher-Dimensional Probability Densities</strong></h5>&#13;
<p class="noindent">Cast your mind back to the univariate normal probability density function detailed in <a href="ch16.xhtml#ch16lev2sec142">Section 16.2.2</a>. First, I’ll introduce the idea of higherdimensional density functions with the bivariate version of the normal distribution, and then I’ll go one step further and use the trivariate version to illustrate isosurface plotting.</p>&#13;
<p class="indent">To work with multivariate normal distributions, you can use the <code>mvtnorm</code> package, installed with a call to <code>install.packages("mvtnorm")</code>. Just like the <code>rnorm</code> function for the univariate normal, the <code>rmvnorm</code> function is used to generate <span epub:type="pagebreak" id="page_711"/>random variates from a specified multivariate normal. Once you’ve installed <code>mvtnorm</code>, execute the following code:</p>&#13;
<pre>R&gt; library("mvtnorm")<br/>R&gt; rand2d.norm &lt;- rmvnorm(n=500,mean=c(0,0))<br/>R&gt; plot(rand2d.norm,xlab="x",ylab="y")</pre>&#13;
<p class="indent">This produces the plot on the left of <a href="ch26.xhtml#ch26fig9">Figure 26-9</a>. The <code>rmvnorm</code> function is used to generate 500 independent variates from the standard bivariate normal distribution. You center the variates around the coordinate (0,0) by passing a numeric vector to <code>mean</code>. By default, independent standard deviation components of 1 are used in both <em>x</em>-<em>y</em> coordinate directions.</p>&#13;
<div class="image"><img src="../images/f26-09.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig9"/>Figure 26-9: Viewing randomly generated data, and the standard bivariate normal density they came from, using</em> <code>mvtnorm</code> <em>functionality</em></p>&#13;
<p class="indent">To actually view the bivariate density function, you need to decide on the <em>x</em>-<em>y</em> evaluation grid and construct the <em>z</em>-matrix as usual using <code>expand.grid</code>. The following code sets up an evenly spaced sequence to use in both coordinate directions and uses the <code>dmvnorm</code> function (this is the multivariate version of <code>dnorm</code> and gives you the density function value at specified coordinates) to fill the <em>z</em>-matrix:</p>&#13;
<pre>R&gt; vals &lt;- seq(-3,3,length=50)<br/>R&gt; xy &lt;- expand.grid(vals,vals)<br/>R&gt; z &lt;- matrix(dmvnorm(xy),50,50)</pre>&#13;
<p class="indent">Then, you can use <code>contour</code> (or <code>persp</code> or <code>persp3d</code>) to view the density from which the data in <code>rand2d.norm</code> were generated for comparison (truncated to the limits −3 to 3 in both axes). The following line produces the plot on the right of <a href="ch26.xhtml#ch26fig9">Figure 26-9</a>:</p>&#13;
<pre>R&gt; contour(vals,vals,z,xlab="x",ylab="y")</pre>&#13;
<h5 class="h5" id="ch26lev3sec119"><span epub:type="pagebreak" id="page_712"/><strong>Basic One-Level Isosurface</strong></h5>&#13;
<p class="noindent">Now let’s increase the dimension once more—what does a <em>trivariate</em> normal density function look like?</p>&#13;
<p class="indent">First, let’s take a look at some data generated from this density. The following code generates 500 random variates again:</p>&#13;
<pre>R&gt; rand3d.norm &lt;- rmvnorm(n=500,mean=c(0,0,0))<br/>R&gt; plot3d(rand3d.norm,xlab="x",ylab="y",zlab="z")</pre>&#13;
<p class="indent">However, since you supplied a vector of length 3 as the <code>mean</code> argument to <code>rmvnorm</code>, the function knows you have three dimensions to work with. You’re telling it that you want the data to come from a trivariate normal, with means of 0, 0, and 0 in each coordinate direction. You can see the <code>rgl</code> point cloud of the data produced via <code>plot3d</code> on the left of <a href="ch26.xhtml#ch26fig10">Figure 26-10</a>.</p>&#13;
<p class="indent">To calculate and display the actual trivariate density function that generated these data, you’ll need a 3D evaluation lattice, as noted at the beginning of <a href="ch26.xhtml#ch26lev1sec94">Section 26.3</a>.</p>&#13;
<div class="image"><img src="../images/f26-10.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig10"/>Figure 26-10: Left: Viewing data randomly generated from the standard trivariate normal distribution. Right: Concept of the 3D evaluation lattice upon which the trivariate density function itself will be plotted.</em></p>&#13;
<p class="indent">Take a look at the plot on the right of <a href="ch26.xhtml#ch26fig10">Figure 26-10</a>. It shows a 3D 11 × 11 × 11 evaluation lattice based on sequences spanning [−3,3] in <em>x</em>, <em>y</em>, and <em>z</em>. This should give you a clear idea of how increasing the dimension of a continuous function works. Each intersection in the 11 × 11 × 11 grid is the 3D equivalent of each intersection of the solid lines in the 2D 6 × 4 evaluation grid in <a href="ch25.xhtml#ch25fig9">Figure 25-9</a> on <a href="ch25.xhtml#page_656">page 656</a>, and each of the 10<sup>3</sup> mini-3D cubes in this 3D lattice is the 3D equivalent of a 2D facet, as noted in the discussion of <a href="ch25.xhtml#ch25fig20">Figure 25-20</a> on <a href="ch25.xhtml#page_683">page 683</a>. (As with <a href="ch25.xhtml#ch25fig9">Figure 25-9</a>, you can find the code to plot this 3D lattice on the book’s website.)</p>&#13;
<p class="indent">To plot the result of the trivariate function, you need the unique evaluation coordinates of the evaluation lattice. Using <code>vals</code>, the sequence of values between −3 and 3 created earlier, the following code produces a data frame of all 50<sup>3</sup> = 125,000 unique 3D evaluation lattice coordinates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_713"/>R&gt; xyz &lt;- expand.grid(vals,vals,vals)<br/>R&gt; nrow(xyz)<br/>[1] 125000</pre>&#13;
<p class="indent">Then you use <code>dmvnorm</code> to get the numeric value of the standard trivariate normal just as you did in the bivariate setting. The function automatically knows you’re requesting the trivariate density because your data argument <code>xyz</code> has three columns.</p>&#13;
<pre>w &lt;- array(dmvnorm(xyz),c(50,50,50))</pre>&#13;
<p class="indent">Note that the result is stored appropriately as a 50 × 50 × 50 3D array—refer to <a href="ch03.xhtml#ch03lev1sec15">Section 3.4</a> for details on <code>array</code>. Look at the conceptual diagram of a 3D array (<a href="ch03.xhtml#ch3fig3">Figure 3-3</a> on <a href="ch03.xhtml#page_53">page 53</a>) and compare it to the 3D lattice on the right of <a href="ch26.xhtml#ch26fig10">Figure 26-10</a>. The trivariate normal values in the object <code>w</code> are clearly represented by a 3D block of numbers sitting at each corresponding unique evaluation coordinate in the defined 3D space.</p>&#13;
<p class="indent">An isosurface can be produced using the <code>contour3d</code> function, part of the <code>misc3d</code> package (<a href="ref.xhtml#ref22">Feng and Tierney, 2008</a>), which works closely with <code>rgl</code>. To use it, you need to decide on the level (or levels) at which to plot the surface. For densities, you typically make this choice with respect to what’s called the <em>α</em>-level contours; for more details, see the authoritative text on the theory of multivariate densities by Scott (<a href="ref.xhtml#ref60">1992</a>). In brief, for some density <em>f</em>, these levels delineate the (1 − <em>α</em>) × 100 percent “most dense” observations by setting the isosurface to be drawn at positions in the multivariate evaluation lattice that correspond to the density value given by <em>α</em> × max(<em>f</em>).</p>&#13;
<p class="indent">For the trivariate standard normal, the maximum value of the density is located at the mean at the coordinate (0,0,0).</p>&#13;
<pre>R&gt; max3d.norm &lt;- dmvnorm(c(0,0,0),mean=c(0,0,0))<br/>R&gt; max3d.norm<br/>[1] 0.06349364</pre>&#13;
<p class="indent">You’ll use this when producing the next couple of plots. Next, install <code>misc3d</code>, load it with <code>library("misc3d")</code>, and then call <code>contour3d</code>.</p>&#13;
<pre>R&gt; contour3d(x=vals,y=vals,z=vals,f=w,level=0.05*max3d.norm)</pre>&#13;
<p class="indent">This produces an isosurface in an RGL device that you can rotate and zoom as you desire; you can see the result on the left of <a href="ch26.xhtml#ch26fig11">Figure 26-11</a>. You supply <code>contour3d</code> with the arguments <code>x</code>, <code>y</code>, and <code>z</code> as evenly spaced sequences in the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinate directions, respectively (all are defined by the vector <code>vals</code> in this case). You supply the corresponding 3D array, defining the entire result of the trivariate function to <code>f</code>, and pass the level (or levels) at which you want to draw the isosurface itself to <code>level</code>. Here, I’ve chosen the <em>α</em>-level to leave only 5 percent of the probability in the tails of the distribution, meaning that 95 percent of the total mass is held within the “blob.”</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_714"/><img src="../images/f26-11.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig11"/>Figure 26-11: An isosurface of the trivariate standard normal density function produced using</em> <code>contour3d</code> <em>of the</em> <code>misc3d</code> <em>package. Left: Stand-alone plot drawn at an <em>α</em> level of 0.05. Right: Adding the same surface to an existing</em> <code>rgl</code> <em>plot of randomly generated trivariate normal observations, at 50 percent opacity.</em></p>&#13;
<p class="indent">The plot matches what you might expect—the shape of the trivariate density is relatively clear based on the plot of the randomly generated data you produced earlier. However, without scale, it’s little more than a statistical golf ball. It’s often more helpful to view the data alongside the density from which they came, which is also easy to do. The following code replots the data in <code>rand3d.norm</code> using <code>plot3d</code> and calls <code>contour3d</code> again to draw at the <em>α</em> level of 0.05:</p>&#13;
<pre>R&gt; plot3d(rand3d.norm,xlab="x",ylab="y",zlab="z")<br/>R&gt; contour3d(x=vals,y=vals,z=vals,f=w,level=0.05*max3d.norm,add=TRUE,alpha=0.5)</pre>&#13;
<p class="indent">Just as with the traditional R <code>contour</code> function, if you want to use <code>contour3d</code> to add to an existing <code>rgl</code> plot (as is the case here), you need to explicitly specify <code>add=TRUE</code>. You can also use the optional <code>alpha</code> argument to adjust opacity, reduced to 50 percent in this example, to “see inside” the density isosurface.</p>&#13;
<h5 class="h5" id="ch26lev3sec120"><strong>Controlling Multiple Levels with Color and Opacity</strong></h5>&#13;
<p class="noindent">Playing with opacity is especially useful when you want to plot the isosurface at multiple <em>α</em> levels at once. Color is also useful in this way, as a variable that can represent a fourth dimension without adding an additional physical axis to the graph.</p>&#13;
<p class="indent">To view the trivariate normal density at multiple levels, consider the plot produced by executing the following code:</p>&#13;
<pre>R&gt; plot3d(rand3d.norm,xlab="x",ylab="y",zlab="z")<br/>R&gt; contour3d(x=vals,y=vals,z=vals,f=w,<br/>             level=c(0.05,0.2,0.6,0.95)*max3d.norm,<br/><span epub:type="pagebreak" id="page_715"/>             color=c("pink","green","blue","red"),<br/>             alpha=c(0.1,0.2,0.4,0.9),add=TRUE)</pre>&#13;
<p class="indent"><a href="ch26.xhtml#ch26fig12">Figure 26-12</a> shows the result. Here, you replot the 500 randomly generated trivariate normal observations, and another call to <code>contour3d</code> now draws contours at four specific <em>α</em>-levels of the trivariate density—0.05, 0.2, 0.6, and 0.95. You use the optional <code>color</code> argument to render these inpink, green, blue, and red, respectively, and progressively increase the opacity of each level with the <code>alpha</code> argument.</p>&#13;
<div class="image"><img src="../images/f26-12.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig12"/>Figure 26-12: An isosurface of the trivariate normal density plotted at four levels, over the randomly generated observations. Color and opacity are used to distinguish among the different numeric levels of the plotted function.</em></p>&#13;
<p class="indent">You should be able to see that you can gauge the increase in the denseness of the points in the 3D space for this distribution in a similar way as you’d use standard 2D contours to appraise the distribution of bivariate observations.</p>&#13;
<h4 class="h4" id="ch26lev2sec270"><strong><em>26.3.3 Example: Nonparametric Trivariate Density</em></strong></h4>&#13;
<p class="noindent">For an extended example using real data, look once more at the built-in <code>quakes</code> data frame, which includes the spatial location, magnitude, and depth of 1000 seismic events.</p>&#13;
<p class="indent">In <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>, you constructed bivariate kernel density estimates of the 2D longitude-latitude spatial coordinates, using the <code>MASS</code> function <code>kde2D</code>. As noted there, KDE extends naturally to higher dimensions. The goal now <span epub:type="pagebreak" id="page_716"/>is to calculate and visualize a density estimate of the same spatial earthquake data, but this time to do so based on the trivariate coordinates of longitude, latitude, <em>and</em> depth, in 3D space.</p>&#13;
<h5 class="h5" id="ch26lev3sec121"><strong>Raw Data</strong></h5>&#13;
<p class="noindent">First, let’s look at the raw observations. The following code creates a copy of the <code>quakes</code> data, extracting those three variables and rendering <code>depth</code> negative. I dothis so that, when plotted, earthquake depth corresponds to moving <em>down</em> the vertical axis to give the impression of depth below sea level.</p>&#13;
<pre>R&gt; quak &lt;- quakes[,c("long","lat","depth")]<br/>R&gt; quak$depth &lt;- -quak$depth</pre>&#13;
<p class="indent">In the usual <code>rgl</code> fashion, you create a point cloud of the raw data with the following:</p>&#13;
<pre>R&gt; plot3d(x=quak$long,y=quak$lat,z=quak$depth,<br/>          xlab="Longitude",ylab="Latitude",zlab="Depth")</pre>&#13;
<p class="indent"><a href="ch26.xhtml#ch26fig13">Figure 26-13</a> shows the result. If you spin the plot so that you’re looking down directly from the top with a bird’s-eye view, you’ll recognize the 2D spatial patterning that you’ve plotted already; see, for example, <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> (<a href="ch13.xhtml#page_265">page 265</a>), <a href="ch23.xhtml#ch23fig1">Figure 23-1</a> (<a href="ch23.xhtml#page_578">page 578</a>), or <a href="ch25.xhtml#ch25fig12">Figure 25-12</a> (<a href="ch25.xhtml#page_662">page 662</a>).</p>&#13;
<div class="image"><img src="../images/f26-13.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig13"/>Figure 26-13: Viewing the 3D spatial dispersion of the earthquake occurrences—latitude, longitude, and depth</em></p>&#13;
<h5 class="h5" id="ch26lev3sec122"><span epub:type="pagebreak" id="page_717"/><strong>Calculating the 3D Estimate</strong></h5>&#13;
<p class="noindent">The evaluation lattice for this kernel estimate will be defined by the entire 3D space in which the longitude-latitude-depth data reside, exactly as illustrated in <a href="ch26.xhtml#ch26lev2sec269">Section 26.3.2</a>.</p>&#13;
<p class="indent">To actually calculate the 3D KDE surface for the <code>quak</code> data, you’ll use the impressive functionality of the contributed package <code>ks</code> (<a href="ref.xhtml#ref20">Duong, 2007</a>). Install the package and load it with a call to <code>library("ks")</code>. The <code>kde</code> function within the <code>ks</code> package allows you to use kernel smoothing to estimate the probability density of 1D through 6D data.</p>&#13;
<p class="indent">The first argument you supply to <code>kde</code> is your data, in the form of a matrix or data frame, with the tag <code>x</code>. Note that the order of the columns in your data object matters when using <code>kde</code>. When called as follows with <code>quak</code>, and taking into account the extraction order of the three variables in the earlier code that created <code>quak</code>, the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinate axes in the resulting 3D kernel estimate will correspond to longitude, latitude, and depth, respectively.</p>&#13;
<pre>R&gt; quak.dens3d &lt;- kde(x=quak,gridsize=c(64,64,64),compute.cont=TRUE)</pre>&#13;
<p class="indent">This matches the way the data are displayed in <a href="ch26.xhtml#ch26fig13">Figure 26-13</a>. The <code>gridsize</code> argument specifies the lattice resolution in each axis. In this example, I’ve settled on a 64 × 64 × 64 lattice; by default, <code>kde</code> chooses the range of evaluation in each coordinate direction so that it’s slightly wider than the observed data. Finally, to plot the result, it’s useful to also specify the argument <code>compute.cont=TRUE</code>; I’ll go into the reason for this in a moment.</p>&#13;
<p class="indent">The returned object has several components. The 3D estimate is provided as an appropriately sized array as the <code>$estimate</code> member; if you want to check, execution of the following line confirms it matches the desired lattice resolution:</p>&#13;
<pre>R&gt; dim(quak.dens3d$estimate)<br/>[1] 64 64 64</pre>&#13;
<p class="indent">The <code>$eval.points</code> component holds a list whose members are the specific evaluation coordinates, which are equally spaced sequences in each of the three axes. The number of members reflects the dimension of the problem, and their order corresponds to the specific axis. You can extract them with the following lines:</p>&#13;
<pre>R&gt; x.latt &lt;- quak.dens3d$eval.points[[1]]<br/>R&gt; y.latt &lt;- quak.dens3d$eval.points[[2]]<br/>R&gt; z.latt &lt;- quak.dens3d$eval.points[[3]]</pre>&#13;
<p class="indent">If you print these vectors to your console screen, you’ll see that each is a vector of length 64, with <code>x.latt</code>, <code>y.latt</code>, and <code>z.latt</code> corresponding to the variables matching the order of the columns in the data frame <code>quak</code>.</p>&#13;
<h5 class="h5" id="ch26lev3sec123"><span epub:type="pagebreak" id="page_718"/><strong>Isosurface Level Selection</strong></h5>&#13;
<p class="noindent">The selection of the level to display depends on the range of values that make up the result of the trivariate function itself. When you choose <code>compute.cont=TRUE</code> in the call to <code>kde</code>, you’re automatically provided with a collection of appropriate levels. These are returned in the component <code>$cont</code> as a numeric vector with a length of exactly 99, representing each integer between 1 percent and 99 percent.</p>&#13;
<p class="indent">Internally, these levels are calculated by working out the result of the trivariate function at the location of each of the originally observed data points and then using <code>quantile</code> to obtain all the integer-valued percentiles (from 99 percent to 1 percent) of these density values (for a refresher on quantiles, refer to <a href="ch13.xhtml#ch13lev2sec118">Section 13.2.3</a>). These are returned in decreasing order; in other words, <code>quak.dens3d$cont[1]</code> corresponds to the 99th percentile, and <code>quak.dens3d$cont[99]</code> is the 1st percentile.</p>&#13;
<p class="indent">Though these values are obtained in a different way from the <em>α</em>-levels you experimented with when plotting the trivariate normal density, you essentially end up with same interpretation when visualizing the result—these values allow you to draw the isosurfaces at the level of estimated observation “denseness” that you want. For example, the lower quartile (aka the 25th percentile) is extracted with the following:</p>&#13;
<pre>R&gt; quak.dens3d$cont[75]<br/>         25%<br/>2.002741e-05</pre>&#13;
<p class="indent">This provides the value of the KDE trivariate function that is estimated to separate the most spatially diffuse 25 percent of the observations from the rest (in other words, so that the resulting blobs encapsulate the most spatially dense 75 percent of the data).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At the time of writing, both the</em> <code><span class="codeitalic">rgl</code></span> <em>and</em> <code><span class="codeitalic">misc3d</code></span> <em>packages are dependencies of</em> <code><span class="codeitalic">ks</code></span>. <em>This means they are loaded automatically when you load</em> <code><span class="codeitalic">ks</code></span><em>, so you don’t need to call</em> <code><span class="codeitalic">library("rgl")</code></span> <em>or</em> <code><span class="codeitalic">library("misc3d")</code></span> <em>explicitly in this case, and</em> <code><span class="codeitalic">plot3d</code></span> <em>and</em> <code><span class="codeitalic">contour3d</code></span> <em>are already available to you. This may change as the developers update their packages over time.</em></p>&#13;
</div>&#13;
<p class="indent">When you execute the following code, it first replots the <code>quak</code> data that the density estimate is based on and then adds the corresponding isosurface using the lower point-wise density quartile as the desired level. You can see the result on the left of <a href="ch26.xhtml#ch26fig14">Figure 26-14</a>.</p>&#13;
<pre>R&gt; plot3d(x=quak$long,y=quak$lat,z=quak$depth,<br/>          xlab="Longitude",ylab="Latitude",zlab="Depth")<br/>R&gt; contour3d(x=x.latt,y=y.latt,z=z.latt,f=quak.dens3d$estimate,<br/>             color="blue",level=quak.dens3d$cont[75],add=TRUE)</pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_719"/><img src="../images/f26-14.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig14"/>Figure 26-14: Isosurfaces (3D contour plots) of a trivariate kernel density estimate drawn at point-specific density quantiles, based on use of the contributed</em> <code>kde</code> <em>and</em> <code>contour3d</code> <em>functions. Left: Solid blue delineation of the lower quartile—the 25 percent most diffuse points. Right: Green delineation of the median—the 50 percent most diffuse from the 50 percent most dense—with opacity reduced by half.</em></p>&#13;
<p class="indent">Looking at the image, the blue blobs representing the 3D contour at the specified level are clear to see. Higher levels of the trivariate function, that is, more densely grouped points, are “inside” these blobs. In other words, the blue shapes encapsulate the observations associated with the highest 75 percent of estimated density with respect to latitude, longitude, and depth. To see inside the isosurfaces, you can adjust the opacity with <code>alpha</code>.</p>&#13;
<p class="indent">Let’s take the level that delineates the observations associated with the lower and upper 50 percent of estimated density values.</p>&#13;
<pre>R&gt; quak.dens3d$cont[50]<br/>         50%<br/>3.649565e-05</pre>&#13;
<p class="indent">Then, rerun the call to <code>plot3d</code> to replot the raw <code>quak</code> data. After that, a call to <code>contour3d</code> produces the result on the right of <a href="ch26.xhtml#ch26fig14">Figure 26-14</a>, allowing you to see through the green blobs.</p>&#13;
<pre>R&gt; contour3d(x=x.latt,y=y.latt,z=z.latt,f=quak.dens3d$estimate,<br/>             color="green",level=quak.dens3d$cont[50],add=TRUE,alpha=0.5)</pre>&#13;
<p class="indent">Lastly, you’ll highlight the top 80 percent of the mostly densely clustered observations using multiple levels. Execute the following:</p>&#13;
<pre>R&gt; qlevels &lt;- quak.dens3d$cont[c(80,60,40,20)]<br/>R&gt; qlevels<br/>         20%          40%          60%          80%<br/>1.771214e-05 2.964305e-05 4.249407e-05 9.543976e-05</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_720"/>This obtains four levels—the quantiles above which the 80 percent, 60 percent, 40 percent, and 20 percent most densely clustered observations are identified. Then set up a couple of vectors to control the color and opacity of each increasing level of denseness accordingly.</p>&#13;
<pre>R&gt; qcols &lt;- c("yellow","orange","red","red4")<br/>R&gt; qalpha &lt;- c(0.2,0.3,0.4,0.5)</pre>&#13;
<p class="indent">The range of colors and alpha levels means the isosurface will darken in color and become more opaque as the density increases.</p>&#13;
<p class="indent">One final time, replot the raw <code>quak</code> data using <code>plot3d</code> as earlier. Then it’s simply a matter of supplying your vectors of length 4 to each appropriate argument in <code>contour3d</code>.</p>&#13;
<pre>R&gt; contour3d(x=x.latt,y=y.latt,z=z.latt,f=quak.dens3d$estimate,<br/>             color=qcols,level=qlevels,add=TRUE,alpha=qalpha)</pre>&#13;
<p class="indent"><a href="ch26.xhtml#ch26fig15">Figure 26-15</a> shows the results. You can see that the tightest grouping of earthquakes occurs quite deep and toward the eastern edge of the 3D spatial prism (the visible “three-chamber” density blob is a well-known feature of these particular data).</p>&#13;
<h3 class="h3" id="ch26lev1sec95"><strong>26.4 Handling Parametric Equations</strong></h3>&#13;
<p class="noindent">In most of the examples in the chapter so far, the surfaces are directly defined by the coordinates of a regular evaluation grid or lattice, but there are situations where the final axis you want to visualize is <em>not</em> a function of some evaluation grid. This occurs quite naturally when you simply want to draw familiar geometric shapes but also extends to more complicated situations in mathematics.</p>&#13;
<p class="indent">In this section, you’ll plot from a collection of parametric equations, which together define the shape or surface of interest. This section will assume you’re familiar with the fundamental trigonometric functions <em>sine</em> and <em>cosine</em>, as well as the conversion of angles from <em>degrees</em> to <em>radians</em>, since by default R deals exclusively with the latter. That said, I’ll walk you through the relevant calculations and R code as needed.</p>&#13;
<h4 class="h4" id="ch26lev2sec271"><strong><em>26.4.1 Simple Loci</em></strong></h4>&#13;
<p class="noindent">Using mathematical terminology, a <em>locus</em> (plural <em>loci</em>) is a set of points that satisfy, and are defined by, a particular set of parametric equations. In R, these equations govern how individual numeric elements of the resulting objects are calculated, which you can then easily plot using familiar functions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When discussing loci, any reference to 2D or 3D space refers to</em> Euclidian space<em>, which is the standard way in which you’ve dealt with coordinates in the</em> x<em>-,</em> y<em>-, and</em> z<em>-axes so far.</em></p>&#13;
</div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_721"/><img src="../images/f26-15.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig15"/>Figure 26-15: Three screenshots of the trivariate kernel density estimate of the earthquake observations, taken from varying angles and with different levels of zoom. Increasing levels of denseness are reflected by isosurfaces of darkening yellow-to-red color and increased opacity.</em></p>&#13;
<h5 class="h5" id="ch26lev3sec124"><strong>2D Circle</strong></h5>&#13;
<p class="noindent">Let’s start with a simple example. One of the most immediately recognizable shapes defined in this way is a 2D circle. To find any point on a circle, you need to know the circle’s center and its radius, and you need to provide a specific angle at which to look (typically taken to be relative to a perfectly horizontal line). Any planar 2D point (<em>x</em>,<em>y</em>) that lies on a circle can be expressed with the following equations if you take the center to be at the coordinate (<em>a</em>, <em>b</em>), with a fixed radius of <em>r</em> &gt; 0 and looking at the angle <em>θ</em>:</p>&#13;
<div class="imagec"><a id="ch26eq1"/><img src="../images/e26-1.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_722"/>If you’re working in degrees, then technically 0 ≤ <em>θ</em> &lt; 360; to convert to radians, you must multiply by <em>π</em>/180 such that 0 ≤ <em>θ</em> &lt; 2<em>π</em>.</p>&#13;
<p class="indent">To draw a circle based on the equations in (26.1), first decide on a radius, then decide on a center point, and then generate the corresponding values of <em>x</em> and <em>y</em>. Consider the following code:</p>&#13;
<pre>R&gt; radius &lt;- 3<br/>R&gt; a &lt;- 1<br/>R&gt; b &lt;- -4.4<br/>R&gt; angle &lt;- 0:360*(pi/180)<br/>R&gt; x &lt;- a+radius*cos(angle)<br/>R&gt; y &lt;- b+radius*sin(angle)<br/>R&gt; plot(x,y,ann=FALSE)<br/>R&gt; abline(v=a)<br/>R&gt; abline(h=b)</pre>&#13;
<p class="indent">The circle will have a radius of 3 and be centered at (1,−4.4). Given the sequence defined as <code>angle</code>, note the plot will place a point at each integer angle from 0 to 360 degrees—I’ve allowed the upper limit to be equal to exactly 360 to fully complete the rotation—after which you convert to radians (with multiplication by <em>π</em>/180) in order to use the built-in R functions <code>cos</code> and <code>sin</code>. The geometric value of pi (<em>π</em> = 3.1415...) is held within the ready-to-use R object <code>pi</code> (see the help file <code>?Constants</code>). The last three lines execute the plot, shown in <a href="ch26.xhtml#ch26fig16">Figure 26-16</a>.</p>&#13;
<div class="image"><img src="../images/f26-16.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig16"/>Figure 26-16: Drawing a 2D circle in R with center (1,</em>−<em>4.4) and radius 3, following the relevant parametric equations of the locus</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_723"/>The key takeaway here is that <em>y</em> isn’t calculated as a direct result of <em>x</em> in the same way as you might obtain a fine, evenly spaced increasing sequence in <em>x</em> and then evaluate <em>y</em> when plotting, for example, a linear regression model. Rather, the equations in (26.1) jointly define the rules of the locus in the 2D space.</p>&#13;
<h5 class="h5" id="ch26lev3sec125"><strong>3D Cylinder</strong></h5>&#13;
<p class="noindent">Plotting surfaces with three dimensions is done in much the same way, only now your equations set up the rules for all satisfying points in the <em>x</em>-, <em>y</em>-, and <em>z</em>-axes.</p>&#13;
<p class="indent">For example, points lying on a hollow cylinder can be defined by the following equations:</p>&#13;
<div class="imagec"><a id="ch26eq2"/><img src="../images/e26-2.jpg" alt="image"/></div>&#13;
<p class="indent">To actually plot points that satisfy these rules, you need to decide on a fixed radius <em>r</em>, recognize that 0 ≤ <em>θ</em> &lt; 360 (in degrees), and define a fixed maximum height <em>h</em> so that you can ensure 0 ≤ <em>z</em> ≤ <em>h</em>. With that information, to generate vectors for <em>x</em>, <em>y</em>, and <em>z</em>, you need to first set up numeric sequences spanning the possible values of <em>θ</em> and <em>z</em>. Consider the following code:</p>&#13;
<pre>R&gt; r &lt;- 3<br/>R&gt; h &lt;- 10<br/>R&gt; zseq &lt;- 0:h<br/>R&gt; theta &lt;- 0:360*(pi/180)</pre>&#13;
<p class="indent">These lines show a radius of 3 set as <code>r</code> and a maximum height of 10 as <code>h</code>. The sequence in <em>z</em> is set up as the 11 integer values from 0 to 10 in <code>zseq</code>—this will allow you to place points on the locus at each of these defined <em>z</em> values. The sequence for <em>θ</em> is set up as 0 ≤ <em>θ</em> &lt; 2<em>π</em> in <code>theta</code> (note the necessary conversion to radians). Then, you need all unique combinations of these parameter values to get all relevant (<em>x</em>, <em>y</em>, <em>z</em>) coordinates for plotting. You know how to do that from <a href="ch25.xhtml#ch25lev2sec251">Section 25.3.1</a>, using <code>expand.grid</code>.</p>&#13;
<pre>R&gt; ztheta &lt;- expand.grid(zseq,theta)<br/>R&gt; nrow(ztheta)<br/>[1] 3971</pre>&#13;
<p class="indent">Calling <code>nrow</code> on the result shows that you now have 11 × 361 = 3971 unique height-angle values. Now you’re able to generate the values for <em>x</em>, <em>y</em>, and <em>z</em> as defined by (26.2). You could use a <code>for</code> loop (<a href="ch10.xhtml#ch10lev2sec92">Section 10.2.1</a>), cycling through each row of <code>ztheta</code>, but a neater way would be to use implicit looping in <code>apply</code> (refer to <a href="ch10.xhtml#ch10lev2sec94">Section 10.2.3</a> for details).</p>&#13;
<pre>R&gt; x &lt;- apply(ztheta,1,function(vec) r*cos(vec[2]))<br/>R&gt; y &lt;- apply(ztheta,1,function(vec) r*sin(vec[2]))<br/>R&gt; z &lt;- apply(ztheta,1,function(vec) vec[1])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_724"/>Note that disposable functions (see <a href="ch11.xhtml#ch11lev2sec104">Section 11.3.2</a>) are used to operate on the two-element height-angle (in that order) vectors that make up each row of <code>ztheta</code>.</p>&#13;
<p class="indent">You can use <code>persp3d</code> from <code>rgl</code> to plot this kind of parametrically defined surface, but in a slightly different way than in earlier sections of this chapter. The calculated <code>x</code>, <code>y</code>, and <code>z</code> coordinates must now <em>all</em> be supplied as identically sized, appropriately arranged matrices. This is because there’s no longer an evenly spaced evaluation grid in the <em>x</em>- and <em>y</em>-coordinate directions—along with the <em>z</em> values, the <em>x</em> and <em>y</em> values have all been defined through an application of (26.2). In these types of plots, you effectively have a <em>latent</em> evaluation grid defined by the unique combinations of parameter values (height and angle in this case).</p>&#13;
<p class="indent">The matrices in all of the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinates are given by the three 11 × 361 matrices filled with <code>x</code>, <code>y</code>, and <code>z</code> in the typical column-wise fashion.</p>&#13;
<pre>R&gt; xm &lt;- matrix(x,length(zseq),length(theta))<br/>R&gt; ym &lt;- matrix(y,length(zseq),length(theta))<br/>R&gt; zm &lt;- matrix(z,length(zseq),length(theta))</pre>&#13;
<p class="indent">At this point, it’s worth introducing the built-in <code>outer</code> function, which takes a sequence of values in two variables and produces all unique combinations of values, computes the result at each combination, and then returns the results as a matrix—doing the three tasks just done by <code>expand.grid</code>, <code>apply</code>, and <code>matrix</code> in one go. With this approach, you could create <code>xm</code>, <code>ym</code>, and <code>zm</code> indentically by simply calling the following:</p>&#13;
<pre>R&gt; xm &lt;- outer(zseq,theta,function(z,t) r*cos(t))<br/>R&gt; ym &lt;- outer(zseq,theta,function(z,t) r*sin(t))<br/>R&gt; zm &lt;- outer(zseq,theta,function(z,t) z)</pre>&#13;
<p class="indent">The only difference here is that the anonymous function provided as the third argument must be explicitly defined in terms of two separate arguments that represent the values of the necessary height and angle parameters.</p>&#13;
<p class="indent">However you obtain <code>xm</code>, <code>ym</code>, and <code>zm</code>, it’s now just a matter of calling <code>persp3d</code> with these coordinate matrices. Make an additional call to <code>points3d</code> to emphasize the precise evaluation points that are returned in those matrices. The result of the next two lines is shown on the left of <a href="ch26.xhtml#ch26fig17">Figure 26-17</a>.</p>&#13;
<pre>R&gt; persp3d(x=xm,y=ym,z=zm,col="red")<br/>R&gt; points3d(x=xm,y=ym,z=zm)</pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_725"/><img src="../images/f26-17.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig17"/>Figure 26-17: Drawing a cylinder and a cone using</em> <code>persp3d</code><em>, with matrix arguments in all three coordinate directions. The loci are defined by the corresponding parametric equations. The black rings visible on the cylinder represent the actual evaluation points stored in the required matrices</em> <code>xm</code>, <code>ym</code><em>, and</em> <code>zm</code>.</p>&#13;
<h5 class="h5" id="ch26lev3sec126"><strong>3D Cone</strong></h5>&#13;
<p class="noindent">This next example will show that once you understand the procedure involved with setting up the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinate matrices, you can display virtually any 3D shape or surface with ease. Taking <em>r</em>, <em>h</em>, and <em>θ</em> to be the base radius, maximum height, and angle, respectively, a cone follows these equations:</p>&#13;
<div class="imagec"><a id="ch26eq3"/><img src="../images/e26-3.jpg" alt="image"/></div>&#13;
<p class="indent">Using the same objects <code>r</code>, <code>h</code>, <code>zseq</code>, and <code>theta</code> from earlier, the following code alters the disposable functions in <code>outer</code> to reflect (26.3). The right of <a href="ch26.xhtml#ch26fig17">Figure 26-17</a> shows the result.</p>&#13;
<pre>R&gt; xm &lt;- outer(zseq,theta,function(z,t) (h-z)/h*r*cos(t))<br/>R&gt; ym &lt;- outer(zseq,theta,function(z,t) (h-z)/h*r*sin(t))<br/>R&gt; zm &lt;- outer(zseq,theta,function(z,t) z)<br/>R&gt; persp3d(x=xm,y=ym,z=zm,col="green")</pre>&#13;
<h4 class="h4" id="ch26lev2sec272"><strong><em>26.4.2 Mathematical Abstractions</em></strong></h4>&#13;
<p class="noindent">Many areas of mathematics, applied mathematical modeling, and statistics utilize high-dimensional shapes. To round off this chapter, and indeed the book, let’s employ <code>rgl</code> to take a look at a couple of famous abstractions using skills from <a href="ch26.xhtml#ch26lev2sec271">Section 26.4.1</a>.</p>&#13;
<h5 class="h5" id="ch26lev3sec127"><span epub:type="pagebreak" id="page_726"/><strong>Möbius Strip</strong></h5>&#13;
<p class="noindent">A classic example is the <em>Möbius strip</em>—a continuous surface that has only one side and one edge. It can be expressed using the parametric equations</p>&#13;
<div class="imagec"><a id="ch26eq4"/><img src="../images/e26-4.jpg" alt="image"/></div>&#13;
<p class="noindent">where</p>&#13;
<div class="imagec"><img src="../images/f0726-01.jpg" alt="image"/></div>&#13;
<p class="noindent">with −1 ≤ <em>v</em> ≤ 1 and 0 ≤ <em>θ</em> &lt; 2<em>π</em> (assuming angles measured in radians). The parameter <em>v</em> controls the position of the point along the width of the strip, and <em>θ</em> controls the rotation angle.</p>&#13;
<p class="indent">You can draw the strip in the same way as the cylinder and cone from earlier. First, set up the sequences over the possible values of <em>v</em> and <em>θ</em>, done here at a resolution of 200 each:</p>&#13;
<pre>R&gt; res &lt;- 200<br/>R&gt; vseq &lt;- seq(-1,1,length=res)<br/>R&gt; theta &lt;- seq(0,2*pi,length=res)</pre>&#13;
<p class="indent">Next, use <code>outer</code> to obtain the 200 × 200 matrices in each of the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinates as per (26.4).</p>&#13;
<pre>R&gt; xm &lt;- outer(vseq,theta,function(v,t) (1+v/2*cos(t/2))*cos(t))<br/>R&gt; ym &lt;- outer(vseq,theta,function(v,t) (1+v/2*cos(t/2))*sin(t))<br/>R&gt; zm &lt;- outer(vseq,theta,function(v,t) v/2*sin(t/2))</pre>&#13;
<p class="indent">Then, a quick call to <code>plot3d</code> from the <code>rgl</code> package will show you the 40,000 locations, based on the defined <code>vseq</code> and <code>theta</code> sequences, that lie on the Möbius strip. The result of the following line is shown on the left of <a href="ch26.xhtml#ch26fig18">Figure 26-18</a>:</p>&#13;
<pre>R&gt; plot3d(x=xm,y=ym,z=zm)</pre>&#13;
<p class="indent">Let’s display the strip as a continuous surface using <code>persp3d</code> to fully appreciate the one-side/one-edge phenomenon. The image on the right of <a href="ch26.xhtml#ch26fig18">Figure 26-18</a> shows the result of the following code:</p>&#13;
<pre>R&gt; persp3d(x=xm,y=ym,z=zm,col="orange",axes=FALSE,xlab="",ylab="",zlab="")</pre>&#13;
<p class="indent">Note the use of <code>axes</code> to suppress the default box and axes and the use of empty strings to remove the default axis titles denoting <code>xm</code>, <code>ym</code>, and <code>zm</code>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_727"/><img src="../images/f26-18.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig18"/>Figure 26-18: Drawing a Möbius strip in R. Left: Specifically calculated points on the strip, visualized with</em> <code>plot3d</code><em>. Right: Surface formed by joining up the points on the left via</em> <code>persp3d</code>.</p>&#13;
<p class="indent">You could also use color in a more interesting way to emphasize the wraparound nature of a Möbius strip. Taking inspiration from a similar collection of colors defined in <a href="ch25.xhtml#ch25lev2sec244">Section 25.1.3</a>, create the following custom palette:</p>&#13;
<pre>R&gt; patriot.colors &lt;- colorRampPalette(c("red4","red","white","blue",<br/>                                        "white","red","red4"))</pre>&#13;
<p class="indent">This palette has been specifically generated to go from a dark red to white to blue but also to wrap around from the blue back to white and the dark red. This is needed for the way in which colors from <code>patriot.colors</code> will be assigned, in a point-wise fashion, to the plotted strip.</p>&#13;
<p class="indent">The color vector for plotting the surface will need to be of length 200<sup>2</sup> = 40,000 given the preset value of <code>res</code> (governing the length of both <code>vseq</code> and <code>theta</code>). To fill the vector, execute the following:</p>&#13;
<pre>R&gt; patcols &lt;- patriot.colors(2*res-1)<br/>R&gt; stripcols &lt;- rep(NA,res^2)<br/>R&gt; for(i in 0:(res-1)){<br/>+  stripcols[1:res+res*i] &lt;- patcols[1:res+i]<br/>+ }</pre>&#13;
<p class="indent">The first line generates exactly 399 colors from <code>patriot.colors</code>, and the second sets up a vector of the required length, which will store the assigned <span epub:type="pagebreak" id="page_728"/>colors (<code>stripcols</code>). The <code>for</code> loop ensures that at the first iteration, the elements <code>1</code> through <code>200</code> in <code>stripcols</code> will be assigned colors <code>1</code> through <code>200</code> from <code>patcols</code>; at the second iteration, the elements <code>201</code> through <code>400</code> will be assigned colors <code>2</code> through <code>201</code> from <code>patcols</code>, and so on. This gives the colors their wraparound appearance.</p>&#13;
<p class="indent">To properly understand the <code>for</code> loop, first look at the order of the arguments as supplied to the calls to <code>outer</code>. Having <code>vseq</code> first and <code>theta</code> second implies that each column of 200 in the resulting matrices corresponds to a span from −1 to 1 in <em>v</em>, which refers to moving from one end of one of the lines of points to the other, that is, along the width of the strip. By using an index variable <code>i</code> from <code>0</code> to <code>199</code> (inclusive), the loop assigns each consecutive block of 200 elements in <code>stripcols</code> (increased at every iteration via <code>+res*i</code>) the 200 elements from the 399 <code>patcols</code> by collectively moving forward exactly one element (increased at every iteration via <code>+i</code>). What that does is change the color from red to white to blue in the plotted lines of points in the early stages of the loop, but as it progresses, working its way around the strip, the specific span of that palette is incrementally shifted until it goes from blue to white to red as you rotate around to the last few plotted lines of points. The effect is a smooth change in color as you alter both <em>v</em> and <em>θ</em>. You can see the result of the following in <a href="ch26.xhtml#ch26fig19">Figure 26-19</a>:</p>&#13;
<pre>R&gt; persp3d(x=xm,y=ym,z=zm,col=stripcols,aspect=c(2,2.5,1.5),axes=FALSE,<br/>           xlab="",ylab="",zlab="")</pre>&#13;
<div class="image"><img src="../images/f26-19.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig19"/>Figure 26-19: A patriotic Möbius strip, created with the careful construction of an appropriate color vector.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_729"/>The plot can still be rotated and zoomed as usual on your computer. You can experiment with <code>aspect</code> to alter the specific axis aspect ratios purely to enhance the appearance of the final product; here I’ve widened both the <em>x</em>- and <em>y</em>-axes relative to the <em>z</em>-axis.</p>&#13;
<h5 class="h5" id="ch26lev3sec128"><strong>Torus</strong></h5>&#13;
<p class="noindent">Another shape often expressed in 3D space is a <em>ring torus</em> (plural <em>tori</em>). This is the classic topological “shape with one hole” and resembles, for lack of a better word, a doughnut. The mathematical properties of tori are quite useful in many fields.</p>&#13;
<p class="indent">Parameterization of a torus may be achieved with these equations:</p>&#13;
<div class="imagec"><a id="ch26eq5"/><img src="../images/e26-5.jpg" alt="image"/></div>&#13;
<p class="noindent">where</p>&#13;
<p class="center"><em>F</em>(<em>θ</em><sub>2</sub>; <em>α</em>, <em>β</em>) = <em>β</em> + <em>α</em> cos <em>θ</em><sub>2</sub></p>&#13;
<p class="noindent">with 0 ≤ <em>θ</em><sub>1</sub> &lt; 2<em>π</em> and the same for <em>θ</em><sub>2</sub> (assuming angles measured in radians). The fixed values <em>α</em> and <em>β</em> control the radius of the “tube” (in other words, the relative thickness of the doughnut) and the overall size of the torus in terms of distance from the middle of the hole to the middle of the tube. Provided <em>α</em> &lt; <em>β</em>, the equations in (26.5) give you the classic ring torus shape; you can get different kinds of tori by relaxing that condition on <em>α</em> and <em>β</em>.</p>&#13;
<p class="indent">Setting <em>α</em> = 1 and <em>β</em> = 2, the following code uses the <code>theta</code> object defined earlier for the Möbius strip to compute the matrices in the <em>x</em>-, <em>y</em>-, and <em>z-</em>coordinate directions as per (26.5):</p>&#13;
<pre>R&gt; alpha &lt;- 1<br/>R&gt; beta &lt;- 2<br/>R&gt; xm &lt;- outer(theta,theta,function(t1,t2) (beta+alpha*cos(t2))*cos(t1))<br/>R&gt; ym &lt;- outer(theta,theta,function(t1,t2) (beta+alpha*cos(t2))*sin(t1))<br/>R&gt; zm &lt;- outer(theta,theta,function(t1,t2) alpha*sin(t2))</pre>&#13;
<p class="indent">Refer to <a href="ch26.xhtml#ch26lev2sec271">Section 26.4.1</a> to remind yourself of the usage of <code>outer</code> if you need to do so.</p>&#13;
<p class="indent">Then, this line reveals the calculated points of the torus:</p>&#13;
<pre>R&gt; plot3d(x=xm,y=ym,z=zm)</pre>&#13;
<p class="indent">And this gives you the final appearance of the continuous surface:</p>&#13;
<pre>R&gt; persp3d(x=xm,y=ym,z=zm,col="seagreen4",axes=FALSE,xlab="",ylab="",zlab="")</pre>&#13;
<p class="indent"><a href="ch26.xhtml#ch26fig20">Figure 26-20</a> shows the results of both.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_730"/><img src="../images/f26-20.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig20"/>Figure 26-20: Drawing a ring torus in R. Left: Specifically calculated points on the surface, visualized with</em> <code>plot3d</code><em>. Right: Shape formed by joining up the points on the left using</em> <code>persp3d</code>.</p>&#13;
<p class="indent">Earlier, you used a specifically constructed color vector to color the Möbius strip, but you can assign color on any such surface by identifying the specific points in the defined matrices that you want to exert control over. Since it’s the last example in the book, let’s have a little fun with the current mathematical doughnut to illustrate this point-wise indexing.</p>&#13;
<p class="indent">First, the dough needs to look authentic. The following line sets up the vector of length 200<sup>2</sup> = 40,000 to store the colors you’re going to use. Initially, every element is set as a dough-colored tan.</p>&#13;
<pre>R&gt; donutcols &lt;- rep("tan",res^2)</pre>&#13;
<p class="indent">Next, add some icing. If you look at the distribution of the points, displayed in the plot on the left of <a href="ch26.xhtml#ch26fig20">Figure 26-20</a>, you can see that the “top half” of plotted locations on the surface of this torus are at <em>z</em>-coordinates greater than zero. With this, you can overwrite the relevant elements of <code>donutcols</code> with the following line:</p>&#13;
<pre>R&gt; donutcols[as.vector(zm)&gt;0] &lt;- "pink"</pre>&#13;
<p class="indent">Lastly, any premium doughnut should have sprinkles. You need a mechanism to identify random locations on the top half of the surface and color them appropriately. To do this, you can use the built-in <code>sample</code> function to randomly select a subset of elements from an existing vector. If you have the <span epub:type="pagebreak" id="page_731"/>integers 1 through 10, for example, and you want to randomly select four, you can execute the following:</p>&#13;
<pre>R&gt; sample(x=1:10,size=4)<br/>[1] 8 9 2 6</pre>&#13;
<p class="indent">The argument <code>x</code> takes the vector from which to select a sample, and <code>size</code> takes the number of elements you want to draw from that vector. Note that you’re likely to get a different set of four random numbers when executing this line.</p>&#13;
<p class="indent">With that knowledge, you can use this code to make sprinkles:</p>&#13;
<pre>R&gt; sprinkles &lt;- c("blue","green","red","violet","yellow")<br/>R&gt; donutcols[sample(x=which(as.vector(zm)&gt;0),size=300)] &lt;- sprinkles</pre>&#13;
<p class="indent">This sets up five distinct sprinkle colors; then randomly selects 300 locations, strictly from locations on the iced surface area; and finally assigns to them the five colors. The nature of vector recycling means there will be exactly 60 of each color sprinkle, randomly placed on the top half of the torus. You can add more sprinkles by increasing <code>size</code>, though given the number of colors, you should ensure <code>size</code> remains evenly divisible by 5.</p>&#13;
<p class="indent">The following call completes the visual treat, shown in <a href="ch26.xhtml#ch26fig21">Figure 26-21</a>:</p>&#13;
<pre>R&gt; persp3d(xm,ym,zm,col=donutcols,aspect=c(1,1,0.4),axes=FALSE,<br/>           xlab="",ylab="",zlab="")</pre>&#13;
<div class="image"><img src="../images/f26-21.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch26fig21"/>Figure 26-21: A delicious mathematical doughnut. Coloring of the torus surface is achieved by identification of corresponding positions in a color vector and subsequent element replacement.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_732"/>You can find a more serious (and technical) visualization of a ring torus, in its role as a convenient computational structure used for generating specially defined high-dimensional random normal variates, in Davies and Bryant (<a href="ref.xhtml#ref15">2013</a>).</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch26exc3"/><strong>Exercise 26.3</strong></p>&#13;
<p class="noindentz">Ensure you have the functionality of the <code>mvtnorm</code>, <code>rgl</code>, <code>misc3d</code>, and <code>ks</code> packages available in your current R session. By specifying different <em>covariance matrices</em>, you can control how the different components of a multivariate normal random variable relate to one another, which affects the appearance of the distribution itself. In the standard trivariate normal density, for example, the three elements (<em>x</em>, <em>y</em>, <em>z</em>) are independent of one another. Executing the following code will generate 1000 observations from a nonstandard trivariate normal distribution where the three elements are related to one another in a specific way:</p>&#13;
<p class="programs-e1">R&gt; covmat &lt;- matrix(c(1,0.8,0.4,0.8,1,0.6,0.4,0.6,1),3,3)<br/>R&gt; rand3d.norm &lt;- rmvnorm(1000,mean=c(0,0,0),sigma=covmat)</p>&#13;
<p class="indentz">Note that the covariance matrix <code>covmat</code> is supplied to the optional <code>sigma</code> and that the mean of this collection of points remains centered at (0,0,0).</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Plot the generated data as an interactive 3D point cloud, with simple axis titles <code>"x"</code>, <code>"y"</code>, and <code>"z"</code>. You should see how the points form an elliptical shape, in contrast to the spherical shape in the standard trivariate normal in <a href="ch26.xhtml#ch26fig11">Figures 26-11</a> and <a href="ch26.xhtml#ch26fig12">26-12</a>. Keep the plot open.</p></li>&#13;
<li><p class="noindents">Using a 50 × 50 × 50 evaluation lattice between −3 and 3 in each of the three axes, calculate this particular trivariate normal density function using <code>dmvnorm</code> and store it as an appropriately sized array. Note that you’ll also need to set <code>sigma=covmat</code> in any use of <code>dmvnorm</code>. Calculate the maximum value of the density and use this to superimpose upon the point cloud isosurfaces at three specific <em>α</em> levels—0.1, 0.5, and 0.9. Color the three isosurfaces <code>"yellow"</code>, <code>"seagreen4"</code>, and <code>"navyblue"</code> and set them at 20 percent, 40 percent, and 60 percent opacity, respectively.</p></li>&#13;
<li><p class="noindents">Now, use <code>ks</code> functionality to calculate a 3D kernel estimate of the density based on the 1000 generated observations. Ensure that the returned object contains the vector of 99 sensible contour levels. Replot the point cloud of (a) in a new RGL device and then make two separate calls to <code>contour3d</code> as follows.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_733"/>The first should superimpose the theoretical contour at an <em>α</em> level of 0.5 from (b) only. Use the same color and opacity as you did in (b).</p></li>&#13;
<li><p class="noindents">The second should draw the isosurface at the 50th percentile as estimated from the point-specific KDE surface. Make it red and reduce the opacity to 20 percent.</p></li>&#13;
</ol>&#13;
<p class="indent">Here are my results from (b) on the left and (c) on the right. Note that the appearance of your KDE isosurface will vary because of the random generation of the 1000 data points, which dictate the final estimate.</p></li>&#13;
</ol>&#13;
<div class="imagec"><img src="../images/f0733-01.jpg" alt="image"/></div>&#13;
<p class="noindentz">The <code>MASS</code> package has another data set you’ve not yet met. The <code>Boston</code> data frame object contains a number of descriptive observations concerning house prices in suburbs of Boston, Massachusetts, in the 1970s (<a href="ref.xhtml#ref31">Harrison and Rubinfeld, 1978</a>). Load the <code>MASS</code> package and inspect the help file <code>?Boston</code> to learn about the present variables.</p>&#13;
<ol type="a" start="4">&#13;
<li><p class="noindents">Focus on the variables for average number of rooms, percentage of lower-socioeconomic-status dwellings, and median value—you’re going to experiment with the visualization of a 3D scatter-plot as follows:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Use <code>rgl</code> functionality to plot the three variables, with rooms, status, and value on the <em>x</em>-, <em>y</em>-, and <em>z</em>-axes, respectively; supply tidy axis titles. The data points should be plotted as gray spheres, with a size of 0.5. Keep the plot open.</p></li>&#13;
<li><p class="noindents">Use <code>ks</code> functionality to estimate the trivariate density function of these data. Base the estimate on a 64 × 64 × 64 evaluation lattice; ensure the 99 integer percentiles of the observation-specific density levels are returned. Superimpose isosurface contours delineating the 75 percent, 50 percent, and 10 percent “most dense” observations using green, yellow, and blue. Set the opacity at 10 percent, 40 percent, and 50 percent, respectively.</p></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_734"/>Finally, add reference grids along the three planes identified at the lower <em>z</em>-, upper <em>x</em>-, and upper <em>y</em>-axis locations.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Interpret the final plot from (d). For example, what values of the present variables tend to characterize the most common types of houses in Boston’s suburbs?</p>&#13;
<p class="noindentt">Here’s the result:</p>&#13;
<div class="imagec"><img src="../images/f0734-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
<p class="noindentz">The <em>umbilic torus</em> is another interesting 3D shape in mathematics and can be defined by the following parametric equations:</p>&#13;
<p class="noindent_t"><em>x</em> = sin(<em>θ</em>)<em>F</em>(<em>θ</em>, <em>φ</em>)</p>&#13;
<p class="noindent_t"><em>y</em> = cos(<em>θ</em>)<em>F</em>(<em>θ</em>, <em>φ</em>)</p>&#13;
<p class="noindent_t"><em>z</em> = sin(<em>θ</em>/3 − 2<em>φ</em>) + 2sin(<em>θ</em>/3 + <em>φ</em>)</p>&#13;
<p class="indent">In these equations, <em>F</em>(<em>θ</em>, <em>φ</em>) = 7 + cos(<em>θ</em>/3 − 2<em>φ</em>) + 2 cos(<em>θ</em>/3 + <em>φ</em>), and you allow for both −<em>π</em> ≤ <em>θ</em> ≤ <em>π</em> and −<em>π</em> ≤ <em>φ</em> ≤ <em>π</em>.</p>&#13;
<ol type="a" start="6">&#13;
<li><p class="noindents">Using a sequence of length 1000 for both <em>θ</em> and <em>φ</em>, as well as 1000 colors generated from the built-in <code>rainbow</code> palette assigned directly to the <code>col</code> argument, produce an interactive 3D plot of the umbilic torus. Suppress the box, axes, and axis titles. In viewing the object from different perspectives, note that, much like the Möbius strip you plotted earlier, this shape has only one edge.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_735"/>Here’s the result:</p>&#13;
<div class="imagec"><img src="../images/f0735-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch26lev3sec129"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>plot3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Interactive 3D point cloud</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec261">Section 26.1.1</a>, <a href="ch26.xhtml#page_692">p. 692</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>legend3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add RGL device legend</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec262">Section 26.1.2</a>, <a href="ch26.xhtml#page_693">p. 693</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>bg3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Reset RGL device background</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec262">Section 26.1.2</a>, <a href="ch26.xhtml#page_693">p. 693</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>segments3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add 3D line segments</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec263">Section 26.1.3</a>, <a href="ch26.xhtml#page_696">p. 696</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>grid3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add plane grid</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec263">Section 26.1.3</a>, <a href="ch26.xhtml#page_696">p. 696</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>bgplot3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Alter/replot RGL device background</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec263">Section 26.1.3</a>, <a href="ch26.xhtml#page_696">p. 696</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>persp3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Interactive 3D perspective surface</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec264">Section 26.2.1</a>, <a href="ch26.xhtml#page_700">p. 700</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>points3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add 3D points</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec265">Section 26.2.2</a>, <a href="ch26.xhtml#page_701">p. 701</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>text3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Add 3D text</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec265">Section 26.2.2</a>, <a href="ch26.xhtml#page_702">p. 702</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rmvnorm</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Random multivariate normal variates</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec269">Section 26.3.2</a>, <a href="ch26.xhtml#page_711">p. 711</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>dmvnorm</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Multivariate normal density</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec269">Section 26.3.2</a>, <a href="ch26.xhtml#page_711">p. 711</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>contour3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Draw isosurface</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec269">Section 26.3.2</a>, <a href="ch26.xhtml#page_713">p. 713</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>kde</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Multivariate kernel estimation</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec270">Section 26.3.3</a>, <a href="ch26.xhtml#page_717">p. 717</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>pi</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Geometric value <em>π</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec271">Section 26.4.1</a>, <a href="ch26.xhtml#page_722">p. 722</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sin</code>, <code>cos</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Sine and cosine</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec271">Section 26.4.1</a>, <a href="ch26.xhtml#page_722">p. 722</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>outer</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Outer array product</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec271">Section 26.4.1</a>, <a href="ch26.xhtml#page_724">p. 724</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sample</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Random sample from vector</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch26.xhtml#ch26lev2sec272">Section 26.4.2</a>, <a href="ch26.xhtml#page_731">p. 731</a><span epub:type="pagebreak" id="page_736"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>