- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 5 CUSTOM FUNCTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to declare and use your own *functions*, which
    are named, self-contained sequences of code that accomplish a particular task.
    You’ll see how functions promote code reusability, since putting code in a function
    is much more efficient than having to rewrite the same sequence of code every
    time you need to perform that function’s task. Functions also let you write programs
    that achieve a lot with a small number of statements, since each statement can
    invoke the complex logic hidden within one of your functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Custom functions are typically declared in a separate file from the main program
    statements that an application will execute. This stems from the *PHP Standards
    Recommendations (PSRs)*, a list of guidelines and best practices for PHP programming.
    According to PSR-1, a file should either declare symbols (such as functions) or
    cause side effects, but not both. A *side effect* is a concrete outcome of executing
    a piece of code, such as outputting text, updating a global variable, changing
    the contents of a file, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: While functions themselves can cause side effects such as these, *declaring*
    a function (defining what the function will do) isn’t the same as *calling* the
    function (having the function actually do that thing). Therefore, functions should
    be declared in one file and called in another. To adhere to this guideline, this
    chapter first touches on the basics of how to work with code spread across multiple
    files before we turn our attention to functions. We’ll revisit the topic of working
    with files in more detail in [Chapter 9](chapter9.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Separating Code into Multiple Files
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we set aside the best practice of declaring functions in a separate
    file, it’s still standard to break up an application’s code across multiple files.
    Consider that a sophisticated application might consist of tens of thousands of
    lines of code. If all that code were in a single large text file, navigating that
    file and locating a particular section of code to work on would be difficult.
    Organizing code into different files makes a project much more manageable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple files also promotes code reusability. Once you start writing
    your own functions, you’ll see how declaring those functions in separate files
    makes it easy to reuse the function in different parts of a project or in different
    projects altogether. To give another example, multipage web applications often
    include the same elements, such as HTML headers, footers, and navigation lists
    on many pages. Rather than repeating that code for each page that needs it, the
    common code can be written once in its own file. This way, if you need to change
    something about it (for example, updating the image reference for a web logo),
    you need to make the change in only one place instead of tracking down and updating
    every instance of the repeated code. Software engineers call this the *don’t repeat
    yourself (DRY)* principle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Once you start spreading an application’s code across multiple files, you need
    a way to access one file’s code from within another file. In this section, we’ll
    look at some PHP language features that make this possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Reading in and Executing Another Script
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PHP’s require_once command reads the code in another file and executes it. To
    see how this command works, we’ll create two scripts. One, the main script, will
    use require_once to access the code from the other script. First, create a *main.php*
    file containing the code shown in [Listing 5-1](#lis5-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: A main script to read in and execute code from a different script'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, we print out two messages indicating that we’re in the main
    application file. In between, we use the require_once command to read in and execute
    the contents of the *file2.php* script. The filename is specified as a string
    immediately after the command. Since we haven’t specified a directory path along
    with the filename (for example, *Users/matt/file2.php*), it’s understood that
    the file is in the same folder as this current script. This is known as a *relative
    path*: the file’s location is determined relative to the location of the current
    script.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Now create *file2.php* containing the code shown in [Listing 5-2](#lis5-2).
    Be sure to save this file in the same location as *main.php*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: The contents of file2.php to be read in and executed from another
    script'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This script has two print statements, printing out messages saying they’re from
    *file2.php*. Notice that each message begins with a tab escape character (\t).
    This way, these messages will be indented, whereas the messages printed from our
    main script won’t be, a visual clue that the messages are coming from separate
    scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter php main.php at the command line to run the main script. Here’s the
    output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see the first message from the main script, followed by the two indented
    messages from *file2.php*. This confirms that the contents of *file2.php* were
    read in and executed thanks to the require_once statement in our main script.
    Finally, the program flow of control returns back to the main script after the
    require_once statement, and we see the final printed message from the main script.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Besides* require_once*, PHP provides three other commands for reading in and
    executing code declared in a separate file:* require*,* include*, and* include_once*.
    They all work similarly; you can read about the differences in the PHP documentation.
    In 99.99 percent of the web applications I write, I use* require_once*.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Creating Absolute Filepaths
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The constant __DIR__ will always refer to the *absolute filepath* to the script
    currently being executed, meaning the complete filepath, starting from the root
    directory. This is one of PHP’s *magic constants*, built-in constants whose value
    changes depending on the context. In the case of __DIR__, the value varies based
    on the location of the file in which __DIR__ is being evaluated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s best to use __DIR__ whenever possible when writing require_once statements:
    simply concatenate the value of __DIR__ with any remaining relative path information
    to access the file you’re trying to read in and execute. This avoids any confusion
    as to whether the path relates to the current script (the one calling the require_once
    command) or to a script that might have required the current script. Consider
    that you might have a chain of scripts, with one script requiring another, and
    that script also requiring another. If these scripts were in different directories,
    using the __DIR__ magic constant ensures that wherever you write a require_once
    statement, you’ll know the path will be correct to the files you wish to read
    in and execute.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To try using __DIR__, update your *main.php* file as shown in [Listing 5-3](#lis5-3).
    The changes are shown in black text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-3: A main script using __DIR__ to read in and execute code in a different
    script'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign the $callingScriptPath variable the value of the __DIR__ magic constant
    and print a message containing this variable. Then we use __DIR__ after the require_once
    command to make it explicit that the *file2.php* script resides in the same directory
    as this main script ❶. Notice that we use the string concatenation operator (.)
    to combine the value of __DIR__ with the string ''/file2.php'', building an absolute
    path to the other file. Here’s the output of running the main script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As before, the first message from *main.php* prints out. Then we see the path
    to the main script (the value of __DIR__) printed out ❶. For me, it is */Users/matt/magic*,
    the path to the directory on my computer for this example project. The rest of
    the output is the same as before, featuring the messages from *file2.php* followed
    by the final printed message from the main script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Calling a Function
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s turn our attention to declaring and using our first custom function.
    The function will determine which of two numbers is smaller. In keeping with best
    practices, we’ll declare the function in one file, *my_functions.php*, and then
    call it from a separate file, *main.php*. Start a new project and create *my_functions.php*
    containing the code shown in [Listing 5-4](#lis5-4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-4: Declaring a function in my_functions.php'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare a function named which_is_smaller(). We begin with the keyword
    function, followed by the function name. By convention, function names are written
    in snake case, in all lowercase letters and with underscores to join multiple
    words. This enables you to write meaningful, easy-to-read function names (although,
    unfortunately, not all of PHP’s built-in functions follow this naming convention
    because of choices made in the language’s early design).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: After the function name comes a set of parentheses containing a comma-separated
    list of the function’s *parameters*. These are inputs that the function needs
    to do its job. In this case, we have two parameters, $n1 and $n2, representing
    the two numbers we want the function to compare. Each parameter name is preceded
    by its data type to ensure that the correct form of data enters the function.
    Here, for example, int $n1 indicates that parameter $n1 should be an integer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If a function doesn’t need any parameters, you still have to include an empty
    set of parentheses after the function name.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: After the parentheses comes a colon (:), followed by the function’s return type.
    Most functions do some work and produce a value as a result, which the function
    then *returns*, or provides, to the script that called the function. The *return
    type* specifies the data type of this value. In this case, the function will return
    the integer $n1 or $n2, whichever is smaller, so we set the return type to int.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The code we’ve written so far has defined the function’s *signature*, a combination
    of its name, parameters (and their types), and return type. The PHP engine uses
    a function’s signature to uniquely identify the function, recognize when we’re
    calling it, validate that appropriate data is being passed to the function’s parameters,
    and ensure that the function is returning an appropriate value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the *body* of the function, a statement group enclosed within curly
    brackets and containing the code that will execute each time the function is called.
    The body of our which_is_smaller() function consists of an if...else statement
    that tests whether integer $n1 is smaller than integer $n2. If $n1 is smaller,
    the return $n1; statement will be executed. Otherwise (if $n2 is smaller or the
    same as $n1), return $n2; will be executed. In both cases, we use the return keyword
    to make the function provide a value (either $n1 or $n2) to the script that called
    it. As soon as a function reaches a return statement, the function stops executing
    and gives control back to the calling script. Even if the function body includes
    additional statements after the return statement, they won’t execute after the
    function has returned a value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared a function, let’s use it. Create *main.php* in the same
    location as *my_functions.php* and enter the code shown in [Listing 5-5](#lis5-5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-5: Calling the which_is_smaller() function from main.php'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We use require_once to read in the declaration of our function from *my_functions.php*.
    This doesn’t call the function; it simply makes the function available for use
    in our *main.php* script. Next, we call our function by writing the function name,
    followed in parentheses by the values we want the function to compare, 5 and 2.
    These values are known as *arguments*; they fill in the values of the function’s
    parameters. Notice that we call the function as part of an assignment statement
    for the $result1 variable. This way, the function’s return value will be stored
    in $result1 for later use (in this case, in the next line of code, where it’s
    printed out in a message). When a function has a return value, it’s common to
    follow this pattern of calling a function and assigning the result to a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We conclude the script by calling the function again, this time using 5 and
    22 as arguments. This is the beauty of functions: you can call them as many times
    as you want, with different input values each time. We store the return value
    of the second function call in the $result2 variable and again print out a message
    showing the result. Here’s the output of running the *main.php* script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that our function is working correctly. It returns 2 as the smaller
    of 5 and 2, and 5 as the smaller of 5 and 22.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Parameters vs. Arguments
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The terms *parameter* and *argument* are closely related and often mistaken
    for each other. When you *declare* a function, the parameters are variables that
    stand in for the inputs the function will work with. As you saw in [Listing 5-4](#lis5-4),
    you list the parameters in the parentheses after the function name. In our which_is_smaller()
    function, the parameters were $n1 and $n2. Each parameter is a temporary variable,
    local to the function code itself, that will be assigned a value when the function
    is called. These variables exist only while the function is being executed. Once
    the function has finished executing, the local parameter variables are discarded
    from the computer’s memory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数*和*实参*这两个术语密切相关，经常互相混淆。当你*声明*一个函数时，参数是代表函数将要处理的输入的变量。如你在[清单 5-4](#lis5-4)中所见，参数会列在函数名称后的括号内。在我们的
    which_is_smaller() 函数中，参数是 $n1 和 $n2。每个参数都是一个临时变量，仅在函数内部可见，在函数被调用时会被赋予一个值。这些变量只在函数执行期间存在。一旦函数执行完毕，局部参数变量会从计算机的内存中被丢弃。'
- en: The technical term for how long a variable “lives” in a software system is *scope*.
    The scope of any variable declared in a function, including a parameter, is local
    to the function itself. As such, you can’t expect to access a function’s variables
    from any code outside the function declaration. In our example, we can’t use the
    variables $n1 and $n2 in *main.php*. Instead, the way to get a value out of a
    function is with a return statement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在软件系统中“存在”的时间长度被称为*作用域*。在函数中声明的任何变量，包括参数，其作用域是局部的，仅限于函数本身。因此，你不能期望从函数声明外的任何代码访问函数的变量。在我们的例子中，我们不能在
    *main.php* 中使用变量 $n1 和 $n2。相反，获取函数返回值的方法是使用返回语句。
- en: 'When we *call* a function, the arguments are the specific values we pass to
    the function in the parentheses after the function name. These arguments supply
    the values for the function’s parameters. When we call which_is_smaller(5, 22),
    for example, the argument 5 is assigned as the value of parameter $n1, and the
    argument 22 is assigned as the value of parameter $n2. The order of arguments
    matches the order of parameters. In this case, the arguments are literals, but
    arguments can also be variables, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们*调用*一个函数时，实参是我们在函数名称后的括号中传递给函数的具体值。这些实参为函数的参数提供值。例如，当我们调用 which_is_smaller(5,
    22) 时，实参 5 被赋值给参数 $n1，实参 22 被赋值给参数 $n2。实参的顺序与参数的顺序相匹配。在这个例子中，实参是字面量，但实参也可以是变量，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s all there is to it. Arguments are the values passed when executing a
    function, and parameters are the local variables created when the function executes,
    populated by the arguments received. Each argument passed to a function will therefore
    have a corresponding local (temporary) parameter variable while that function
    is executing. (One exception is the special case of pass-by-reference parameters,
    which we’ll cover later this chapter.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。实参是在执行函数时传递的值，参数是在函数执行时创建的局部变量，由接收到的实参填充。因此，在函数执行期间，每个传递给函数的实参都会有一个对应的局部（临时）参数变量。（有一个例外是通过引用传递参数的特殊情况，我们将在本章后面讨论。）
- en: Errors from Incorrect Function Calls
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误来源于不正确的函数调用
- en: 'In two common cases, you’ll get an error when calling a function: if you don’t
    pass the correct number of arguments, or if you pass arguments of the wrong data
    type. (See “Errors, Warnings, and Notices” on [page 88](#pg_88) for information
    on errors and other kinds of alerts generated about your code.) Consider this
    call to our custom which_is_smaller() function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种常见情况下，调用函数时会发生错误：如果你没有传递正确数量的实参，或者传递了错误数据类型的实参。（有关错误及其他类型警告的信息，请参见[第88页](#pg_88)的“错误、警告和通知”。）考虑调用我们自定义的
    which_is_smaller() 函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function requires two integer arguments, but we’re providing only one.
    If you try to execute this expression, the application will halt and you’ll see
    a fatal error similar to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要两个整数类型的实参，但我们只提供了一个。如果你尝试执行这个表达式，应用程序将停止运行，你会看到类似以下的致命错误：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You’ll also get a fatal error if you pass arguments of the wrong data type
    (that is, values that can’t be type-juggled into the parameter data types specified
    in the function declaration). Consider this expression, where we pass non-numeric
    strings to our which_is_smaller() function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了错误数据类型的实参（即不能转换为函数声明中指定的参数数据类型的值），你也会遇到致命错误。考虑下面这个表达式，我们将非数字的字符串传递给 which_is_smaller()
    函数：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Trying to execute this statement will produce an error message like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A fatal TypeError has occurred because our function requires two integer arguments
    but we’ve provided strings instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '#### Type Juggling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a TypeError like the one we just saw when arguments of the wrong type
    are provided, the PHP engine attempts to juggle those arguments into the expected
    data type. (For a refresher on type juggling, see [Chapter 2](chapter2.xhtml).)
    [Listing 5-6](#lis5-6) shows some examples where we provide non-integer arguments
    to our which_is_smaller() function. Update your *main.php* file to match the listing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-6: Updating the main.php script to demonstrate type juggling'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We call which_is_smaller() three times and print the results. None of these
    function calls will trigger an error, since the arguments can all be juggled to
    integers. First, we call the function with float 3.5 and integer 2. The float
    will be juggled to integer 3. Next, we use integer 3 and string ''55'' as arguments.
    This time, the string will be converted to integer 55. Finally, we pass Boolean
    false and integer -8 as arguments. The false will be converted to integer 0. Here’s
    the output of running the script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run the script, the first thing you should see printed out is a deprecation
    message informing you that you’re losing precision when float 3.5 is juggled into
    integer 3. This message indicates that at some point in the future (possibly PHP
    9), PHP will stop automatically juggling floats with fractional components into
    integers, so the code will someday stop working and trigger an error. After this
    message, you should see the results of the three print statements, indicating
    that the three function calls occurred without issue, thanks to PHP’s automatic
    type juggling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When you encounter a deprecation message, reading a discussion about the upcoming
    change can be informative. For example, the request for comments (RFC) document
    explaining the deprecation message output from [Listing 5-6](#lis5-6) is available
    online at* [https://wiki.php.net/rfc/implicit-float-int-deprecate](https://wiki.php.net/rfc/implicit-float-int-deprecate)*.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: These function calls worked despite the incorrect argument data types, but well-written
    programs should avoid relying on type juggling altogether. Take note of deprecation
    warnings like the one we just encountered, and look for ways to revise your code
    to cope with different kinds of values without warnings or errors. In this particular
    case, we could refactor the function to use union types (discussed in “Union Types”
    on [page 98](#pg_98)), which would allow both integers and floats as arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Functions Without Explicit Return Values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every function has to explicitly return a value. For example, you could
    write a function that simply prints out a message without returning anything to
    the calling script. When a function doesn’t have an explicit return value, declare
    its return type as void.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, we’ll declare a function that prints out a given number of stars,
    padded on both sides with another spacer character to achieve a fixed line length.
    We’ll be able to use the function to create ASCII art, images formed by arranging
    characters of text. Start a new project and create *my_functions.php* containing
    the code shown in [Listing 5-7](#lis5-7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将声明一个函数，该函数打印出给定数量的星号，并在两侧用另一个填充字符进行填充，以实现固定的行长度。我们可以使用该函数创建 ASCII 艺术图像，即通过排列字符文本来形成的图像。启动一个新项目，并创建包含
    [列表 5-7](#lis5-7) 中代码的 *my_functions.php* 文件。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-7: Declaring the print_stars() function in my_functions.php'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：在 my_functions.php 中声明 print_stars() 函数
- en: 'Here we declare a function named print_stars(). The function requires two parameters:
    $numStars and $spacer. The integer $numStars is the number of stars (* characters)
    to be printed out. The string $spacer is the character to use as padding on both
    sides of the stars. After the parentheses, we use : void to indicate that this
    function won’t explicitly return any value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们声明了一个名为 print_stars() 的函数。该函数需要两个参数：$numStars 和 $spacer。整数 $numStars
    是要打印的星号（*字符）数量。字符串 $spacer 是在星号两边作为填充的字符。在括号后面，我们使用 : void 来指示该函数不会显式返回任何值。'
- en: Inside the function body, we set the length of the line to be printed to 20
    characters. (Since this value is *hardcoded* into the function, it will be the
    same each time the function is called; a more flexible alternative could be to
    set $lineLength as a parameter.) Then we generate a string ($starsString) containing
    the number of asterisks specified by the $numStars parameter. Next, we use the
    built-in str_pad() function (discussed in [Chapter 3](chapter3.xhtml)) to create
    a string 20 characters long, with $starsString centered and padded symmetrically
    on the left and right with whatever string is in the $spacer parameter. If $numStars
    is 10 and $spacer is '.', for example, this will produce the string '.....**********.....',
    10 asterisks with 5 periods on each side, giving a total length of 20\. Finally,
    we print out the result, followed by a newline character.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们将要打印的行长度设置为 20 个字符。（由于这个值是*硬编码*在函数中的，所以每次调用该函数时，它的值都将相同；一个更灵活的替代方法是将
    $lineLength 设置为一个参数。）然后，我们生成一个包含由 $numStars 参数指定数量的星号的字符串（$starsString）。接着，我们使用内置的
    str_pad() 函数（在[第 3 章](chapter3.xhtml)中讨论）来创建一个 20 个字符长的字符串，$starsString 在其中居中，并且两侧对称地用
    $spacer 参数中的字符进行填充。例如，如果 $numStars 为 10，$spacer 为 '.'，则会生成字符串 '.....**********.....'，即
    10 个星号，两侧各有 5 个句点，总长度为 20。最后，我们打印出结果，并输出一个换行符。
- en: Notice that we haven’t included a return statement in the function body. There’s
    no need, since all the function is doing is constructing and printing a string.
    If we were to try to return a value from this function, it would trigger a fatal
    error, since we declared the function as void.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在函数体内包含 return 语句。因为没有必要，函数的作用仅仅是构造并打印一个字符串。如果我们尝试从该函数返回一个值，会触发一个致命错误，因为我们将该函数声明为
    void。
- en: Now let’s use our function to generate an ASCII art image of a tree. Create
    *main.php* containing the code shown in [Listing 5-8](#lis5-8).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的函数生成一个树的 ASCII 艺术图像。创建 *main.php* 文件，包含 [列表 5-8](#lis5-8) 中的代码。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-8: A script in main.php to generate a tree shape with the print_stars()
    function'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：在 main.php 中使用 print_stars() 函数生成树形图案的脚本
- en: 'After reading in the function declaration with require_once, we set the spacer
    character to be a forward slash (/) ❶. Then we call our print_stars() function
    six times, printing a tree shape made up of lines with 1, 5, 9, and 13 stars,
    plus two more lines with just 1 star for the trunk. Here’s the output of running
    the *main.php* script at the terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 require_once 引入函数声明后，我们将填充字符设置为正斜杠 (/) ❶。然后我们调用 print_stars() 函数六次，打印出由
    1、5、9 和 13 个星号组成的树形图案，并且再加上两行只有 1 个星号的树干。以下是在终端运行 *main.php* 脚本的输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve created a tree during a heavy rainstorm!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在暴风雨中创建了一棵树！
- en: Returning NULL
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回 NULL
- en: 'Even when a function is declared as void, it still technically has a return
    value: NULL. If a function finishes executing without returning a value, the function
    returns NULL by default. To prove it, let’s try calling our print_stars() function
    again and assigning the result to a variable, as we would with a function that
    has a return value. Update your *main.php* file to match [Listing 5-9](#lis5-9).
    The changes are shown in black text.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-9: Updating main.php to store and print the print_tree() function’s
    NULL return value'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We make the same calls to the print_stars() function as before, but this time
    we store the return value of the last function call in the $result variable. We
    then use var_dump() to see the contents of $result. Since print_stars() doesn’t
    have an explicit return value, $result should contain NULL. Here’s the output
    of running the *main.php* script:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see the ASCII tree again, followed by NULL from the call to var_dump().
    This confirms that the function has returned NULL by default, despite being declared
    as void.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Exiting a Function Early
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A function declared as void can still use a return statement, as long as the
    statement doesn’t include a value. As mentioned earlier, a function stops executing
    as soon as it encounters a return statement, so writing return without a value
    provides a mechanism for exiting a function early. This can be useful, for example,
    if a problem occurs with one of the function’s parameters. You can add validation
    logic to check the parameters at the start of the function, and use return to
    halt the function execution and resume the main calling script if one or more
    argument values aren’t as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The str_pad() function we’ve been using to create centered lines of stars will
    trigger a fatal error if the padding string is empty. Rather than let that crash
    our program, let’s update our print_stars() function to first check whether the
    $spacer string parameter is empty. If it is, we’ll use return to exit the function
    early. Modify *my_functions.php* to match [Listing 5-10](#lis5-10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 5-10: Adding a return statement to exit the print_stars() function
    early'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We add an if statement to the start of the function body, using the built-in
    empty() function to test whether $spacer is an empty string. If so, we use return
    without any value to end function execution early and return program control to
    the calling script. If the function execution gets past this if statement, then
    we know that $spacer isn’t empty, so our call to str_pad() should work fine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: To see whether the return statement is working, update the *main.php* script
    as shown in [Listing 5-11](#lis5-11).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-11: Updating main.php to call print_tree() with an empty spacer string'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We set $spacer to an empty string rather than a slash before making our calls
    to print_stars(). The output of running the main script should now simply be NULL.
    The print_stars() function returns early each time it is called because $spacer
    is an empty string, so we no longer see our ASCII tree. Then again, we don’t see
    a fatal error either, because our return statement prevents us from calling str_pad()
    with an invalid argument. We still see NULL in the output, the result of the var_dump()
    call. This indicates that when a function encounters a return statement without
    a value, it returns NULL, just as it would if it didn’t have a return statement
    at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions from Within Functions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s perfectly reasonable to call one function from within the body of another
    function. In fact, we’ve done it several times already, calling built-in PHP functions
    like str_repeat() and str_pad() inside our print_stars() function. It’s also possible,
    and in fact, quite common, to call your own custom functions from within other
    custom functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of the power of programming comes from breaking problems into smaller
    tasks. You write basic functions to tackle those small tasks and then write higher-level
    functions that combine the tasks to solve the larger problem. In the end, your
    main application script looks quite simple: you just call one or two functions.
    The trick is that those functions themselves call several other functions, and
    so on.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It took us six calls to our print_stars() function to generate an ASCII tree.
    Let’s move those six calls into another function, print_tree(). That way, every
    time we want to print a tree, all we need is one function call in our main script.
    Add the new print_tree() function to *my_functions.php* as shown in [Listing 5-12](#lis5-12).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-12: Adding the print_tree() function to my_functions.php'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We declare the print_tree() function after our previously declared print_stars()
    function. It requires a string parameter called $spacer. In the function body,
    we write our six original calls to print_stars(). Notice that $spacer, the parameter
    of the print_tree() function, is also acting as an argument when we call print_stars().
    This way, we can easily print trees with different padding characters around the
    asterisks just by changing the string we pass in when we call print_tree().
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: With this new function, we can now greatly simplify our main script. Update
    *main.php* as shown in [Listing 5-13](#lis5-13).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 5-13: Simplifying the main.php script with the print_tree() function'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the function declaration file, we call print_tree() twice
    to generate two trees. The first time we use a forward slash as the spacer, as
    before, and the second time we use a space character. Here’s the result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our main script has accomplished with 2 calls to print_tree() what would have
    previously taken 12 calls to print_stars(). Of course, those calls to print_stars()
    are still happening, but we’ve hidden them inside the print_tree() definition,
    making our main script much tidier. You can begin to see the power of functions
    to organize code and promote reusability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Functions with Multiple Return and Parameter Types
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For straightforward situations, you can usually write a function that does something
    and returns a value of a single type or that returns no value. Other times, however,
    you’ll want to make a function more reusable by allowing it to return values of
    different data types depending on the situation. Likewise, you might want a function’s
    parameters to accept values of different data types to ensure that your code can
    cope with input validation issues. *Nullable types* and *union types* offer elegant
    ways to permit multiple types, both for a function’s return value and its parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Types
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s quite common to write functions that normally return one kind of value,
    such as a string or a number, but that sometimes return NULL instead. For example,
    a function that typically performs a calculation might return NULL if it receives
    invalid inputs, or a function that retrieves information from a database might
    return NULL if it’s unable to establish a database connection (we’ll see this
    in [Part VI](part6.xhtml) when we discuss databases). To allow for this, declare
    the function’s return type to be *nullable* by adding a question mark (?) immediately
    before the return type. For instance, placing : ?int at the end of the first line
    of a function declaration means that the function will return either NULL or an
    integer.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action with a function that attempts to return the integer
    value of a spelled-out number (such as 1 instead of 'one'). If the function doesn’t
    recognize the input string, it will return NULL instead. Start a new project and
    create *my_functions.php* containing the contents of [Listing 5-14](#lis5-14).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-14: A function that returns an integer or NULL'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We declare the string_to_int() function, using the nullable type ?int to indicate
    that the function will return either NULL or an integer ❶. The function takes
    in the string parameter $numberString. Its body is a single return statement that
    chooses a value to return by using a match expression. This is possible because
    match expressions evaluate to a single value. The expression has five clauses
    matching the strings 'one' through 'five' to the corresponding integer. A sixth
    clause sets the default case ❷, returning NULL if any other string is provided.
    In this way, the match expression returns an integer or NULL, just as the function’s
    nullable return type indicates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll write a *main.php* file with a script that calls our function. When
    you call a function with a nullable return type, it’s important to test the return
    value, in case it’s NULL. [Listing 5-15](#lis5-15) shows how.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 5-15: A main.php script calling the nullable-type string_to_int() function'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign string ''three'' as the value of the $text1 variable, then pass that
    variable to our string_to_int() function, storing the return value in $number1
    ❶. Next, we use an if...else statement to test whether the value in $number1 is
    empty (NULL) ❷. If so, we print a message stating that the string couldn’t be
    converted to an integer. Otherwise, we print a message showing the string and
    its corresponding integer. We then repeat the process with string ''onee''. Here’s
    the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that the function returns the integer 3 when the argument is the
    string 'three', but it returns NULL when the argument is the misspelled string
    'onee'. Declaring our string_to_int() function with a nullable return type gives
    us the flexibility to respond to this problematic input in a meaningful way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Just as functions can have nullable return types, you can use the same question
    mark syntax to declare function parameters as nullable, meaning the parameter
    can be NULL or some other type. For example, the parameter list (?string $name)
    means that a function accepts a $name parameter that is either NULL or a string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having to duplicate the if...else statement in our *main.php* script
    each time we call our string_to_int() function, as we did in [Listing 5-15](#lis5-15),
    we might take the function’s NULL or integer return value and pass it as an argument
    to another function to generate an appropriate message. That function therefore
    needs to be able to accept a parameter that may be NULL or an integer. [Listing
    5-16](#lis5-16) shows such a function named int_to_message(). Add the function
    to the end of your *my_functions.php* file*.*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-16: A function with a nullable type for the $number parameter'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The signature for this function includes a single parameter called $number of
    nullable type ?int. This means that the argument provided to the function can
    be either NULL or an integer. The function body uses the if...else statement we
    had in our *main.php* script to return an appropriate message depending on which
    data type is passed in.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We can now greatly simplify our main script by removing the duplicated if...else
    statements and calling our new function instead. [Listing 5-17](#lis5-17) shows
    the updated script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-17: Simplifying main.php with the int_to_message() function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that our main script is much simpler now that the logic for generating
    the message has been moved to a function. For each input, we follow a pattern
    of three basic statements: declaring a string ❶, storing the integer (or NULL)
    returned from calling string_to_int() with that string ❷, and printing the string
    returned by passing this integer or NULL value to the int_to_message() function
    ❸.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If we really want to make our code even more succinct, we can put all three
    of those statements into a single line ❹, calling the string_to_int()function
    inside the parentheses when we call the int_to_message() function. This way, the
    former’s return value is passed directly as an argument to the latter, without
    the need for an intermediary variable. This choice is a matter of programming
    style. Personally, I prefer to use intermediate variables to prevent a single
    line of code from becoming too complex.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Union Types
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want a function to be able to return a range of data types, declare its
    return value by using a *union type*. This is a list of the value’s possible data
    types, separated by vertical bars. For example, int|float indicates that a value
    could be an integer or a float. Union types can apply to function parameters as
    well as return values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Nullable types are essentially a special category of union types, and their
    question mark syntax provides a convenient shorthand when one of the possible
    data types is NULL. The union type string|NULL is the same as the more concise
    nullable type ?string, for example. Union types are most useful when your code
    has multiple non-NULL types, like int|float, or when there are multiple non-NULL
    types plus NULL, like string|int|NULL, indicating the data type could be a string,
    an integer, or NULL. This couldn’t be expressed with nullable-type syntax, since
    you can’t mix a nullable type with others in a union by writing something like
    ?string|int. You also can’t include void as one of the types in the union.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate union types, let’s modify our string_to_int() function into a
    string_to_number() function that can return an integer, a float, or NULL, depending
    on the string passed in. We’ll also update our int_to_message() function into
    a number_to_message() function that can take in an integer, a float, or NULL as
    a parameter. Update *my_functions.php* to match [Listing 5-18](#lis5-18).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 5-18: Using union types as function return values and parameters'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare string_to_number(), a revised version of our string_to_int()
    function. We use the union type int|float|null to indicate that the function will
    return an integer, a float, or NULL ❶. Just like string_to_int() previously, this
    function takes in a single string parameter. We add a new clause to the match
    statement in the function body, matching the string 'half' to the float value
    0.5 ❷, hence the need for the union type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare number_to_message(), a revised version of int_to_message()
    that returns a string. This function takes in two parameters. The first, the string
    $text, will be the same as the string passed to our string_to_number() function.
    The second, $number, will be that function’s return value, and so it might be
    an integer, a float, or NULL. We therefore use the same int|float|NULL union type
    for the parameter ❸.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we first test whether $number contains an integer value
    ❹, in which case we return a message stating that $text is an integer. Next, we
    test whether $number contains a float value ❺, returning an appropriate message
    if it does. Finally, we return a message stating that $text couldn’t be converted
    to a number ❻. Execution wouldn’t get this far if either of the previous return
    statements was executed, so we know at this point that $number is neither an integer
    nor a float. We therefore don’t need to place this final return statement inside
    an else clause or another if statement, although we could.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: This choice is a matter of personal programming style. I like to end functions
    like this with an unconditional return statement, so I can clearly see the default
    to be returned. However, some programmers prefer to end the last if statement
    with an else clause as a way to communicate the default. The execution is the
    same either way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s test our functions. Update your *main.php* script to match [Listing
    5-19](#lis5-19).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 5-19: Calling functions with union type parameters and return values
    in main.php'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We call our string_to_number() function, passing in the string 'three', and
    store the result in the $number1 variable. Then we pass $number1 along to our
    number_to_message() function and print the message that it returns. This code
    should output the message 'three' as an integer = 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Optional Parameters
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the value of a parameter will usually be the same each time you call a function,
    you can set a default value for that parameter when you declare the function.
    In effect, this makes the parameter optional. You’ll need to include an argument
    corresponding to that parameter only when you know you’ll want the value to be
    something other than the default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of PHP’s built-in functions have optional parameters with default values.
    For example, PHP’s number_format() function, which takes in a float and converts
    it into a string, has several optional parameters controlling how the string will
    be formatted. Enter php -a at the command line to try out the following code in
    interactive mode:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The number_format() function’s first parameter is not optional; it’s the float
    that we want to format. By default, calling the function with just one argument
    ❶ returns a string version of the number with the decimal portion removed. When
    we add an integer as an optional second argument ❷, the function uses that integer
    to set the number of decimal places to include. We’ve used the value 2 to preserve
    two decimal places. By default, the decimal separator is represented with a period,
    but if we add a string as an optional third argument ❸, the function will use
    that string as the decimal separator instead. In this case, we’re using a comma,
    a common decimal separator in continental Europe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-20](#lis5-20) shows the signature for the number_format() function,
    taken from the PHP online documentation, to illustrate how the default values
    for the parameters are declared.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 5-20: The built-in number_format() function, including optional parameters
    with default values'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: First, notice that when you have a long list of parameters, you can spread them
    over several lines to make the code more readable. The function takes up to four
    parameters, but the second, third, and fourth all have default values assigned
    with the assignment operator (=) after the parameter name. For example, the second
    parameter, $decimals, has a default value of 0, so when we call number_format(1.2345)
    without providing a second argument, the function executes with the default value
    for $decimals and formats the number to include zero decimal places. Likewise,
    the $decimal_separator parameter has a period as its default value, and the $thousands_separator
    parameter has a comma.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The order in which the parameters are declared is important. All mandatory parameters
    (those without default values) must be listed first, followed by the optional
    parameters. This is because the order of arguments when you call a function must
    match the order of the parameters. If you had an optional parameter followed by
    a mandatory one, and you omitted the optional parameter, there’d be no way to
    know that your first argument was meant to correspond to the second parameter.
    The only exception to this rule is if you use named arguments, as we’ll discuss
    later in the chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how optional parameters work, let’s add one to a custom
    function. We’ll revisit our which_is_smaller() function from earlier in the chapter
    and add an optional parameter controlling how the function behaves if the values
    passed in for comparison are the same. Return to the *my_functions.php* file for
    that project and update the script to match [Listing 5-21](#lis5-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-21: Updating the which_is_smaller() function to include an optional
    parameter'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We add a third parameter to our function, the Boolean $nullIfSame, and give
    it a default value of false ❶. Thanks to this default value, the function will
    typically return $n1 if $n1 and $n2 are found to be the same ❸. However, if the
    user overrides this default by passing true as the third argument when calling
    the function, NULL is returned instead ❷. To account for this possibility, we
    use the nullable type ?int to set the function’s return type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of if and return statements matters here. The code will get to
    if ($nullIfSame) ❷ only if $n1 and $n2 are equal. Since $nullIfSame is false by
    default, this condition will typically fail, so the final return $n1; will execute
    ❸. It’s only if the user has set $nullIfSame to true that the function returns
    NULL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Update the project’s *main.php* file as shown in [Listing 5-22](#lis5-22) to
    test the function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-22: Calling which_is_smaller() from main.php, with and without the
    optional parameter'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We call out which_is_smaller() twice, using var_dump() to show the results.
    The first time we pass in 1 and 1 and leave out the optional argument, so $nullIfSame
    will be false by default. The second time, we add true as a third argument, overriding
    the default. Here’s the output of running the main script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first line indicates that the function followed the default behavior of
    returning 1 (the value of the first argument) when we omitted the optional argument.
    When we used the third argument to set $nullIfSame to true, however, the function
    returned NULL.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Positional vs. Named Arguments
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you call a function, the PHP engine by default interprets the arguments
    *positionally*, matching them to the function’s parameters based on their order.
    However, you can also call a function by using *named arguments*: you explicitly
    pair an argument’s value with the name of the corresponding parameter. In this
    case, the order of arguments no longer matters. Named arguments are especially
    useful when a function has optional parameters.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To use named rather than positional arguments, you don’t have to change the
    function declaration in any way, although it becomes even more important to have
    meaningful parameter names. Instead, all you have to do is include the parameter
    name (minus the dollar sign) inside the parentheses when you call a function,
    followed by a colon (:) and the desired argument value. For example, to use a
    named argument to pass true as the value of the $nullIfSame parameter when calling
    our which_is_smaller() function, you would include nullIfSame: true in the argument
    list. The convention is to add a space after the colon.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-23](#lis5-23) shows an updated *main.php* file, adding an extra
    call to which_is_smaller() using named arguments.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-23: Calling which_is_smaller() by using positional and named arguments'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The new call to which_is_smaller() ❶ is functionally equivalent to the previous
    call, but we use named arguments. As such, we’re able to list the arguments in
    a different order from the way the parameters were declared: first $nullIfSame,
    then $n1, then $n2. Here’s the result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last two lines of output are both NULL, indicating the last two function
    calls achieved the same result using positional and named arguments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each function call used all positional or all named arguments,
    but you can also mix both styles of arguments in the same function call. In that
    case, the positional arguments must come first, in the same sequence as the function
    declaration, followed by the named arguments in whatever sequence you wish. Consider
    this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here the first argument, 5, doesn’t have a name. PHP will therefore treat it
    positionally and match it to the first parameter declared, which is $n1. The remaining
    arguments are named and so can appear in any order. By contrast, here’s another
    call to the function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time we’ve started with a named argument for $nullIfSame. Then we have
    an unnamed argument, 5, presumably intended for the $n1 parameter. The PHP engine
    will have no way of knowing this, however, since we started with a named argument,
    and so this function call will trigger an error.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Skipped Parameters
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a function has multiple optional parameters, you can use named arguments
    to set just the optional parameters that you want while skipping the rest. This
    works because the named arguments free you from adhering to the order of the parameters.
    Any parameters you skip will take on their default values. To illustrate, let’s
    create a function that prints customizable greetings. Start a new project and
    create *my_functions.php* to match [Listing 5-24](#lis5-24).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-24: A greet() function with two optional parameters'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: We declare the greet() function as void, since it prints out a message without
    returning a value. The function has a required string parameter $name, as well
    as two optional parameters with default values, $greeting and $hasPhD. The body
    of the function is an if statement that outputs the values of $greeting and $name,
    inserting the title Dr. in between if parameter $hasPhD is true ❶.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll look at a few ways to call the greet() function. Create *main.php*
    containing the code shown in [Listing 5-25](#lis5-25).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 5-25: A main script calling greet() with skipped parameters'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call greet(), we pass just the string 'Matt' as an argument.
    We don’t use named arguments, so this will be matched positionally to the $name
    parameter. The other parameters will use their default values, resulting in the
    message Good morning, Matt.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time we call greet(), we use the positional argument ''Matt'' and
    the named argument hasPhD: true. Notice that $hasPhD is the third parameter in
    the function declaration; we’ve skipped over the second parameter! This is perfectly
    fine. The parameter we skipped, $message, has a default value, and thanks to our
    use of a named argument, the PHP engine will know unambiguously which provided
    arguments match which function parameters. We should get the message Good morning,
    Dr. Matt as a result.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of running the *main.php* script:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output is just as we expect. Thanks to the combination of default parameter
    values and named arguments, we are able to skip the $message parameter without
    issue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Pass-by-Value vs. Pass-by-Reference
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, PHP functions match arguments to parameters by using a *pass-by-value*
    approach: the values of the arguments are copied and assigned (passed) to the
    appropriate parameters, which are created as temporary variables limited to the
    scope of the function. In this way, if the values of any parameters are manipulated
    while the function is executing, those changes will have no effect on any values
    outside the function itself. After all, the function is working with copies of
    the original values.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is *pass-by-reference*: instead of receiving copies, the function
    parameters are passed references to the original variables themselves. In this
    way, if a variable is passed as an argument to a function, the function can permanently
    change the value of that variable. To indicate a pass-by-reference parameter,
    place an ampersand (&) immediately before the parameter name when you’re declaring
    the function.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: I don’t typically recommend using pass-by-reference parameters; in fact, I can’t
    think of a single one I’ve written in the last 20 years. Allowing functions to
    change the variables passed to them makes programs more complex and therefore
    harder to understand, test, and debug. Still, it’s important to be familiar with
    the concept, since you might encounter pass-by-reference parameters in other people’s
    code, including in third-party libraries you might want to use for your own projects.
    Calling a function with pass-by-reference parameters without knowing how they
    work could lead to unintended results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*In some programming languages, programmers use several pass-by-reference parameters
    as a way for a function to “return” multiple values without the need for* return
    *statements. There are better ways to do this in modern PHP, however, such as
    returning an array (see [Chapter 7](chapter7.xhtml)) or an object (see [Part V](part5.xhtml)).*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the difference between pass-by-value and pass-by-reference parameters,
    and to show why the latter are often best avoided, we’ll create two versions of
    a function that calculates someone’s future age. Start a new project and create
    *my_functions.php* with the contents of [Listing 5-26](#lis5-26).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 5-26: A pass-by-value version of future_age()'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare a function named future_age(). It features an integer parameter
    $age declared in the usual way, so this will be a normal pass-by-value parameter.
    The function is declared void since no value is to be returned. In the body of
    the function, we add 1 to $age and print out a message containing the result.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Now create a main script in *main.php* containing the code shown in [Listing
    5-27](#lis5-27).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-27: Testing the pass-by-value version of future_age()'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign the $currentAge variable an integer value of 20. Then we print out
    a message showing the value of this variable. Next, we call our future_age() function,
    passing $currentAge as an argument. We then print out another message showing
    the value of the variable. This gives us a look at the value of $currentAge before
    and after the function call. Here’s the result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first and last lines of output are the same, indicating that calling future_age()
    has no effect on the value of the $currentAge variable. In fact, when the function
    is called, a local variable $age is created within the scope of the function,
    and the value of $currentAge is copied into it. This way, when the function adds
    1 to $age, it does so without changing the value of $currentAge. That’s how pass-by-value
    parameters work: they don’t have any influence outside the scope of the function
    itself.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s modify our future_age() function to use a pass-by-reference parameter
    and see what difference that makes. Update your *my_functions.php* file as shown
    in [Listing 5-28](#lis5-28).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-28: A pass-by-reference version of future_age()'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change here is adding an ampersand (&) before the parameter name,
    indicating $age is a pass-by-reference parameter. As a result, $age will no longer
    be a local variable containing a copy of the value in the variable passed as an
    argument when the function is called. Rather, $age will be a reference to that
    variable, so any changes made to $age will also be made to that variable. To prove
    it, run your *main.php* script again. This time you should see the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that adding 1 to the $age parameter within the function also adds 1
    to the $currentAge variable outside the function. Unless the user’s birthday occurred
    in the instant between the function call and the final print statement, this probably
    isn’t what we want. This illustrates the danger of using pass-by-reference parameters:
    they can change the value of variables that are normally outside the scope of
    a function.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored how to promote code reusability by declaring
    and calling functions, named sequences of code that accomplish a particular task.
    You practiced declaring functions in a separate.p*hp* file and then loading them
    into your main application file with require_once, allowing you to write concise,
    well-organized scripts. You saw how return statements allow functions to send
    values back to the calling script while also providing a mechanism to terminate
    a function early, and you explored how nullable and union types give functions
    the flexibility to take in or output values of various data types.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the difference between parameters (the variables used within
    a function) and arguments (the values passed to those variables when you call
    a function). You saw how to make parameters optional by giving them a default
    value, and how to use named arguments to pass in values in any order or even skip
    parameters. Finally, you learned about the difference between pass-by-value and
    pass-by-reference parameters, in the rare event you want a function to be able
    to update variables outside its own scope.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create a project with separate *main.php* and *file2.php* scripts. The
    *file2.php* script should print out the string '456'. In your *main.php* script,
    first print out '123', then read in and execute *file2.php*, then print out '789'.
    The overall output should be 123456789, but the middle 456 has been printed from
    *file2.php*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Write a project declaring a which_is_larger() function that returns the
    larger of two integers. Your *main.php* script should read in and execute the
    file declaring your function, and then print out the results of calling the function
    with the following arguments:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 4 and 5
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 21 and 19
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 3 and 3
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: What happens in the last case, where the parameters are the same?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Modify your which_is_larger() function to accept either integers or floats,
    and to return an integer, a float, or NULL if both numbers are the same.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Create a file *my_functions.php* that declares a void function to print
    out the first letter of your name in ASCII art style. This function should have
    two parameters, one ($character) a string setting the character to use for making
    the art, and the second ($spacer) a string setting the character to fill in the
    gaps. Assign suitable default values to each parameter. For example, since the
    first character of my name is M, my function might be capital_m(string $character
    = ''M'', string $spacer = '' ''), and it might provide the following output when
    called with no arguments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, write a *main.php* script to call your function with no arguments (using
    both default values). Then use named arguments to call the function two more times,
    once providing just the main character, and then providing just the spacer character.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
