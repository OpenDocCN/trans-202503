- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 5 CUSTOM FUNCTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to declare and use your own *functions*, which
    are named, self-contained sequences of code that accomplish a particular task.
    You’ll see how functions promote code reusability, since putting code in a function
    is much more efficient than having to rewrite the same sequence of code every
    time you need to perform that function’s task. Functions also let you write programs
    that achieve a lot with a small number of statements, since each statement can
    invoke the complex logic hidden within one of your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom functions are typically declared in a separate file from the main program
    statements that an application will execute. This stems from the *PHP Standards
    Recommendations (PSRs)*, a list of guidelines and best practices for PHP programming.
    According to PSR-1, a file should either declare symbols (such as functions) or
    cause side effects, but not both. A *side effect* is a concrete outcome of executing
    a piece of code, such as outputting text, updating a global variable, changing
    the contents of a file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While functions themselves can cause side effects such as these, *declaring*
    a function (defining what the function will do) isn’t the same as *calling* the
    function (having the function actually do that thing). Therefore, functions should
    be declared in one file and called in another. To adhere to this guideline, this
    chapter first touches on the basics of how to work with code spread across multiple
    files before we turn our attention to functions. We’ll revisit the topic of working
    with files in more detail in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Separating Code into Multiple Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we set aside the best practice of declaring functions in a separate
    file, it’s still standard to break up an application’s code across multiple files.
    Consider that a sophisticated application might consist of tens of thousands of
    lines of code. If all that code were in a single large text file, navigating that
    file and locating a particular section of code to work on would be difficult.
    Organizing code into different files makes a project much more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple files also promotes code reusability. Once you start writing
    your own functions, you’ll see how declaring those functions in separate files
    makes it easy to reuse the function in different parts of a project or in different
    projects altogether. To give another example, multipage web applications often
    include the same elements, such as HTML headers, footers, and navigation lists
    on many pages. Rather than repeating that code for each page that needs it, the
    common code can be written once in its own file. This way, if you need to change
    something about it (for example, updating the image reference for a web logo),
    you need to make the change in only one place instead of tracking down and updating
    every instance of the repeated code. Software engineers call this the *don’t repeat
    yourself (DRY)* principle.
  prefs: []
  type: TYPE_NORMAL
- en: Once you start spreading an application’s code across multiple files, you need
    a way to access one file’s code from within another file. In this section, we’ll
    look at some PHP language features that make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in and Executing Another Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PHP’s require_once command reads the code in another file and executes it. To
    see how this command works, we’ll create two scripts. One, the main script, will
    use require_once to access the code from the other script. First, create a *main.php*
    file containing the code shown in [Listing 5-1](#lis5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: A main script to read in and execute code from a different script'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, we print out two messages indicating that we’re in the main
    application file. In between, we use the require_once command to read in and execute
    the contents of the *file2.php* script. The filename is specified as a string
    immediately after the command. Since we haven’t specified a directory path along
    with the filename (for example, *Users/matt/file2.php*), it’s understood that
    the file is in the same folder as this current script. This is known as a *relative
    path*: the file’s location is determined relative to the location of the current
    script.'
  prefs: []
  type: TYPE_NORMAL
- en: Now create *file2.php* containing the code shown in [Listing 5-2](#lis5-2).
    Be sure to save this file in the same location as *main.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: The contents of file2.php to be read in and executed from another
    script'
  prefs: []
  type: TYPE_NORMAL
- en: This script has two print statements, printing out messages saying they’re from
    *file2.php*. Notice that each message begins with a tab escape character (\t).
    This way, these messages will be indented, whereas the messages printed from our
    main script won’t be, a visual clue that the messages are coming from separate
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now enter php main.php at the command line to run the main script. Here’s the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We see the first message from the main script, followed by the two indented
    messages from *file2.php*. This confirms that the contents of *file2.php* were
    read in and executed thanks to the require_once statement in our main script.
    Finally, the program flow of control returns back to the main script after the
    require_once statement, and we see the final printed message from the main script.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Besides* require_once*, PHP provides three other commands for reading in and
    executing code declared in a separate file:* require*,* include*, and* include_once*.
    They all work similarly; you can read about the differences in the PHP documentation.
    In 99.99 percent of the web applications I write, I use* require_once*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Absolute Filepaths
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The constant __DIR__ will always refer to the *absolute filepath* to the script
    currently being executed, meaning the complete filepath, starting from the root
    directory. This is one of PHP’s *magic constants*, built-in constants whose value
    changes depending on the context. In the case of __DIR__, the value varies based
    on the location of the file in which __DIR__ is being evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s best to use __DIR__ whenever possible when writing require_once statements:
    simply concatenate the value of __DIR__ with any remaining relative path information
    to access the file you’re trying to read in and execute. This avoids any confusion
    as to whether the path relates to the current script (the one calling the require_once
    command) or to a script that might have required the current script. Consider
    that you might have a chain of scripts, with one script requiring another, and
    that script also requiring another. If these scripts were in different directories,
    using the __DIR__ magic constant ensures that wherever you write a require_once
    statement, you’ll know the path will be correct to the files you wish to read
    in and execute.'
  prefs: []
  type: TYPE_NORMAL
- en: To try using __DIR__, update your *main.php* file as shown in [Listing 5-3](#lis5-3).
    The changes are shown in black text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: A main script using __DIR__ to read in and execute code in a different
    script'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign the $callingScriptPath variable the value of the __DIR__ magic constant
    and print a message containing this variable. Then we use __DIR__ after the require_once
    command to make it explicit that the *file2.php* script resides in the same directory
    as this main script ❶. Notice that we use the string concatenation operator (.)
    to combine the value of __DIR__ with the string ''/file2.php'', building an absolute
    path to the other file. Here’s the output of running the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As before, the first message from *main.php* prints out. Then we see the path
    to the main script (the value of __DIR__) printed out ❶. For me, it is */Users/matt/magic*,
    the path to the directory on my computer for this example project. The rest of
    the output is the same as before, featuring the messages from *file2.php* followed
    by the final printed message from the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Calling a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s turn our attention to declaring and using our first custom function.
    The function will determine which of two numbers is smaller. In keeping with best
    practices, we’ll declare the function in one file, *my_functions.php*, and then
    call it from a separate file, *main.php*. Start a new project and create *my_functions.php*
    containing the code shown in [Listing 5-4](#lis5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: Declaring a function in my_functions.php'
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare a function named which_is_smaller(). We begin with the keyword
    function, followed by the function name. By convention, function names are written
    in snake case, in all lowercase letters and with underscores to join multiple
    words. This enables you to write meaningful, easy-to-read function names (although,
    unfortunately, not all of PHP’s built-in functions follow this naming convention
    because of choices made in the language’s early design).
  prefs: []
  type: TYPE_NORMAL
- en: After the function name comes a set of parentheses containing a comma-separated
    list of the function’s *parameters*. These are inputs that the function needs
    to do its job. In this case, we have two parameters, $n1 and $n2, representing
    the two numbers we want the function to compare. Each parameter name is preceded
    by its data type to ensure that the correct form of data enters the function.
    Here, for example, int $n1 indicates that parameter $n1 should be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If a function doesn’t need any parameters, you still have to include an empty
    set of parentheses after the function name.*'
  prefs: []
  type: TYPE_NORMAL
- en: After the parentheses comes a colon (:), followed by the function’s return type.
    Most functions do some work and produce a value as a result, which the function
    then *returns*, or provides, to the script that called the function. The *return
    type* specifies the data type of this value. In this case, the function will return
    the integer $n1 or $n2, whichever is smaller, so we set the return type to int.
  prefs: []
  type: TYPE_NORMAL
- en: The code we’ve written so far has defined the function’s *signature*, a combination
    of its name, parameters (and their types), and return type. The PHP engine uses
    a function’s signature to uniquely identify the function, recognize when we’re
    calling it, validate that appropriate data is being passed to the function’s parameters,
    and ensure that the function is returning an appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the *body* of the function, a statement group enclosed within curly
    brackets and containing the code that will execute each time the function is called.
    The body of our which_is_smaller() function consists of an if...else statement
    that tests whether integer $n1 is smaller than integer $n2. If $n1 is smaller,
    the return $n1; statement will be executed. Otherwise (if $n2 is smaller or the
    same as $n1), return $n2; will be executed. In both cases, we use the return keyword
    to make the function provide a value (either $n1 or $n2) to the script that called
    it. As soon as a function reaches a return statement, the function stops executing
    and gives control back to the calling script. Even if the function body includes
    additional statements after the return statement, they won’t execute after the
    function has returned a value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared a function, let’s use it. Create *main.php* in the same
    location as *my_functions.php* and enter the code shown in [Listing 5-5](#lis5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Calling the which_is_smaller() function from main.php'
  prefs: []
  type: TYPE_NORMAL
- en: We use require_once to read in the declaration of our function from *my_functions.php*.
    This doesn’t call the function; it simply makes the function available for use
    in our *main.php* script. Next, we call our function by writing the function name,
    followed in parentheses by the values we want the function to compare, 5 and 2.
    These values are known as *arguments*; they fill in the values of the function’s
    parameters. Notice that we call the function as part of an assignment statement
    for the $result1 variable. This way, the function’s return value will be stored
    in $result1 for later use (in this case, in the next line of code, where it’s
    printed out in a message). When a function has a return value, it’s common to
    follow this pattern of calling a function and assigning the result to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We conclude the script by calling the function again, this time using 5 and
    22 as arguments. This is the beauty of functions: you can call them as many times
    as you want, with different input values each time. We store the return value
    of the second function call in the $result2 variable and again print out a message
    showing the result. Here’s the output of running the *main.php* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our function is working correctly. It returns 2 as the smaller
    of 5 and 2, and 5 as the smaller of 5 and 22.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters vs. Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The terms *parameter* and *argument* are closely related and often mistaken
    for each other. When you *declare* a function, the parameters are variables that
    stand in for the inputs the function will work with. As you saw in [Listing 5-4](#lis5-4),
    you list the parameters in the parentheses after the function name. In our which_is_smaller()
    function, the parameters were $n1 and $n2. Each parameter is a temporary variable,
    local to the function code itself, that will be assigned a value when the function
    is called. These variables exist only while the function is being executed. Once
    the function has finished executing, the local parameter variables are discarded
    from the computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: The technical term for how long a variable “lives” in a software system is *scope*.
    The scope of any variable declared in a function, including a parameter, is local
    to the function itself. As such, you can’t expect to access a function’s variables
    from any code outside the function declaration. In our example, we can’t use the
    variables $n1 and $n2 in *main.php*. Instead, the way to get a value out of a
    function is with a return statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we *call* a function, the arguments are the specific values we pass to
    the function in the parentheses after the function name. These arguments supply
    the values for the function’s parameters. When we call which_is_smaller(5, 22),
    for example, the argument 5 is assigned as the value of parameter $n1, and the
    argument 22 is assigned as the value of parameter $n2. The order of arguments
    matches the order of parameters. In this case, the arguments are literals, but
    arguments can also be variables, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it. Arguments are the values passed when executing a
    function, and parameters are the local variables created when the function executes,
    populated by the arguments received. Each argument passed to a function will therefore
    have a corresponding local (temporary) parameter variable while that function
    is executing. (One exception is the special case of pass-by-reference parameters,
    which we’ll cover later this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Errors from Incorrect Function Calls
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In two common cases, you’ll get an error when calling a function: if you don’t
    pass the correct number of arguments, or if you pass arguments of the wrong data
    type. (See “Errors, Warnings, and Notices” on [page 88](#pg_88) for information
    on errors and other kinds of alerts generated about your code.) Consider this
    call to our custom which_is_smaller() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function requires two integer arguments, but we’re providing only one.
    If you try to execute this expression, the application will halt and you’ll see
    a fatal error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll also get a fatal error if you pass arguments of the wrong data type
    (that is, values that can’t be type-juggled into the parameter data types specified
    in the function declaration). Consider this expression, where we pass non-numeric
    strings to our which_is_smaller() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to execute this statement will produce an error message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A fatal TypeError has occurred because our function requires two integer arguments
    but we’ve provided strings instead.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Type Juggling'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a TypeError like the one we just saw when arguments of the wrong type
    are provided, the PHP engine attempts to juggle those arguments into the expected
    data type. (For a refresher on type juggling, see [Chapter 2](chapter2.xhtml).)
    [Listing 5-6](#lis5-6) shows some examples where we provide non-integer arguments
    to our which_is_smaller() function. Update your *main.php* file to match the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: Updating the main.php script to demonstrate type juggling'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call which_is_smaller() three times and print the results. None of these
    function calls will trigger an error, since the arguments can all be juggled to
    integers. First, we call the function with float 3.5 and integer 2. The float
    will be juggled to integer 3. Next, we use integer 3 and string ''55'' as arguments.
    This time, the string will be converted to integer 55. Finally, we pass Boolean
    false and integer -8 as arguments. The false will be converted to integer 0. Here’s
    the output of running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script, the first thing you should see printed out is a deprecation
    message informing you that you’re losing precision when float 3.5 is juggled into
    integer 3. This message indicates that at some point in the future (possibly PHP
    9), PHP will stop automatically juggling floats with fractional components into
    integers, so the code will someday stop working and trigger an error. After this
    message, you should see the results of the three print statements, indicating
    that the three function calls occurred without issue, thanks to PHP’s automatic
    type juggling.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When you encounter a deprecation message, reading a discussion about the upcoming
    change can be informative. For example, the request for comments (RFC) document
    explaining the deprecation message output from [Listing 5-6](#lis5-6) is available
    online at* [https://wiki.php.net/rfc/implicit-float-int-deprecate](https://wiki.php.net/rfc/implicit-float-int-deprecate)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: These function calls worked despite the incorrect argument data types, but well-written
    programs should avoid relying on type juggling altogether. Take note of deprecation
    warnings like the one we just encountered, and look for ways to revise your code
    to cope with different kinds of values without warnings or errors. In this particular
    case, we could refactor the function to use union types (discussed in “Union Types”
    on [page 98](#pg_98)), which would allow both integers and floats as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Without Explicit Return Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every function has to explicitly return a value. For example, you could
    write a function that simply prints out a message without returning anything to
    the calling script. When a function doesn’t have an explicit return value, declare
    its return type as void.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, we’ll declare a function that prints out a given number of stars,
    padded on both sides with another spacer character to achieve a fixed line length.
    We’ll be able to use the function to create ASCII art, images formed by arranging
    characters of text. Start a new project and create *my_functions.php* containing
    the code shown in [Listing 5-7](#lis5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Declaring the print_stars() function in my_functions.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we declare a function named print_stars(). The function requires two parameters:
    $numStars and $spacer. The integer $numStars is the number of stars (* characters)
    to be printed out. The string $spacer is the character to use as padding on both
    sides of the stars. After the parentheses, we use : void to indicate that this
    function won’t explicitly return any value.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function body, we set the length of the line to be printed to 20
    characters. (Since this value is *hardcoded* into the function, it will be the
    same each time the function is called; a more flexible alternative could be to
    set $lineLength as a parameter.) Then we generate a string ($starsString) containing
    the number of asterisks specified by the $numStars parameter. Next, we use the
    built-in str_pad() function (discussed in [Chapter 3](chapter3.xhtml)) to create
    a string 20 characters long, with $starsString centered and padded symmetrically
    on the left and right with whatever string is in the $spacer parameter. If $numStars
    is 10 and $spacer is '.', for example, this will produce the string '.....**********.....',
    10 asterisks with 5 periods on each side, giving a total length of 20\. Finally,
    we print out the result, followed by a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we haven’t included a return statement in the function body. There’s
    no need, since all the function is doing is constructing and printing a string.
    If we were to try to return a value from this function, it would trigger a fatal
    error, since we declared the function as void.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s use our function to generate an ASCII art image of a tree. Create
    *main.php* containing the code shown in [Listing 5-8](#lis5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: A script in main.php to generate a tree shape with the print_stars()
    function'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the function declaration with require_once, we set the spacer
    character to be a forward slash (/) ❶. Then we call our print_stars() function
    six times, printing a tree shape made up of lines with 1, 5, 9, and 13 stars,
    plus two more lines with just 1 star for the trunk. Here’s the output of running
    the *main.php* script at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created a tree during a heavy rainstorm!
  prefs: []
  type: TYPE_NORMAL
- en: Returning NULL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even when a function is declared as void, it still technically has a return
    value: NULL. If a function finishes executing without returning a value, the function
    returns NULL by default. To prove it, let’s try calling our print_stars() function
    again and assigning the result to a variable, as we would with a function that
    has a return value. Update your *main.php* file to match [Listing 5-9](#lis5-9).
    The changes are shown in black text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: Updating main.php to store and print the print_tree() function’s
    NULL return value'
  prefs: []
  type: TYPE_NORMAL
- en: 'We make the same calls to the print_stars() function as before, but this time
    we store the return value of the last function call in the $result variable. We
    then use var_dump() to see the contents of $result. Since print_stars() doesn’t
    have an explicit return value, $result should contain NULL. Here’s the output
    of running the *main.php* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can see the ASCII tree again, followed by NULL from the call to var_dump().
    This confirms that the function has returned NULL by default, despite being declared
    as void.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting a Function Early
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A function declared as void can still use a return statement, as long as the
    statement doesn’t include a value. As mentioned earlier, a function stops executing
    as soon as it encounters a return statement, so writing return without a value
    provides a mechanism for exiting a function early. This can be useful, for example,
    if a problem occurs with one of the function’s parameters. You can add validation
    logic to check the parameters at the start of the function, and use return to
    halt the function execution and resume the main calling script if one or more
    argument values aren’t as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The str_pad() function we’ve been using to create centered lines of stars will
    trigger a fatal error if the padding string is empty. Rather than let that crash
    our program, let’s update our print_stars() function to first check whether the
    $spacer string parameter is empty. If it is, we’ll use return to exit the function
    early. Modify *my_functions.php* to match [Listing 5-10](#lis5-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: Adding a return statement to exit the print_stars() function
    early'
  prefs: []
  type: TYPE_NORMAL
- en: We add an if statement to the start of the function body, using the built-in
    empty() function to test whether $spacer is an empty string. If so, we use return
    without any value to end function execution early and return program control to
    the calling script. If the function execution gets past this if statement, then
    we know that $spacer isn’t empty, so our call to str_pad() should work fine.
  prefs: []
  type: TYPE_NORMAL
- en: To see whether the return statement is working, update the *main.php* script
    as shown in [Listing 5-11](#lis5-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: Updating main.php to call print_tree() with an empty spacer string'
  prefs: []
  type: TYPE_NORMAL
- en: We set $spacer to an empty string rather than a slash before making our calls
    to print_stars(). The output of running the main script should now simply be NULL.
    The print_stars() function returns early each time it is called because $spacer
    is an empty string, so we no longer see our ASCII tree. Then again, we don’t see
    a fatal error either, because our return statement prevents us from calling str_pad()
    with an invalid argument. We still see NULL in the output, the result of the var_dump()
    call. This indicates that when a function encounters a return statement without
    a value, it returns NULL, just as it would if it didn’t have a return statement
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions from Within Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s perfectly reasonable to call one function from within the body of another
    function. In fact, we’ve done it several times already, calling built-in PHP functions
    like str_repeat() and str_pad() inside our print_stars() function. It’s also possible,
    and in fact, quite common, to call your own custom functions from within other
    custom functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of the power of programming comes from breaking problems into smaller
    tasks. You write basic functions to tackle those small tasks and then write higher-level
    functions that combine the tasks to solve the larger problem. In the end, your
    main application script looks quite simple: you just call one or two functions.
    The trick is that those functions themselves call several other functions, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: It took us six calls to our print_stars() function to generate an ASCII tree.
    Let’s move those six calls into another function, print_tree(). That way, every
    time we want to print a tree, all we need is one function call in our main script.
    Add the new print_tree() function to *my_functions.php* as shown in [Listing 5-12](#lis5-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: Adding the print_tree() function to my_functions.php'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the print_tree() function after our previously declared print_stars()
    function. It requires a string parameter called $spacer. In the function body,
    we write our six original calls to print_stars(). Notice that $spacer, the parameter
    of the print_tree() function, is also acting as an argument when we call print_stars().
    This way, we can easily print trees with different padding characters around the
    asterisks just by changing the string we pass in when we call print_tree().
  prefs: []
  type: TYPE_NORMAL
- en: With this new function, we can now greatly simplify our main script. Update
    *main.php* as shown in [Listing 5-13](#lis5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: Simplifying the main.php script with the print_tree() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the function declaration file, we call print_tree() twice
    to generate two trees. The first time we use a forward slash as the spacer, as
    before, and the second time we use a space character. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our main script has accomplished with 2 calls to print_tree() what would have
    previously taken 12 calls to print_stars(). Of course, those calls to print_stars()
    are still happening, but we’ve hidden them inside the print_tree() definition,
    making our main script much tidier. You can begin to see the power of functions
    to organize code and promote reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with Multiple Return and Parameter Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For straightforward situations, you can usually write a function that does something
    and returns a value of a single type or that returns no value. Other times, however,
    you’ll want to make a function more reusable by allowing it to return values of
    different data types depending on the situation. Likewise, you might want a function’s
    parameters to accept values of different data types to ensure that your code can
    cope with input validation issues. *Nullable types* and *union types* offer elegant
    ways to permit multiple types, both for a function’s return value and its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s quite common to write functions that normally return one kind of value,
    such as a string or a number, but that sometimes return NULL instead. For example,
    a function that typically performs a calculation might return NULL if it receives
    invalid inputs, or a function that retrieves information from a database might
    return NULL if it’s unable to establish a database connection (we’ll see this
    in [Part VI](part6.xhtml) when we discuss databases). To allow for this, declare
    the function’s return type to be *nullable* by adding a question mark (?) immediately
    before the return type. For instance, placing : ?int at the end of the first line
    of a function declaration means that the function will return either NULL or an
    integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action with a function that attempts to return the integer
    value of a spelled-out number (such as 1 instead of 'one'). If the function doesn’t
    recognize the input string, it will return NULL instead. Start a new project and
    create *my_functions.php* containing the contents of [Listing 5-14](#lis5-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: A function that returns an integer or NULL'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the string_to_int() function, using the nullable type ?int to indicate
    that the function will return either NULL or an integer ❶. The function takes
    in the string parameter $numberString. Its body is a single return statement that
    chooses a value to return by using a match expression. This is possible because
    match expressions evaluate to a single value. The expression has five clauses
    matching the strings 'one' through 'five' to the corresponding integer. A sixth
    clause sets the default case ❷, returning NULL if any other string is provided.
    In this way, the match expression returns an integer or NULL, just as the function’s
    nullable return type indicates.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll write a *main.php* file with a script that calls our function. When
    you call a function with a nullable return type, it’s important to test the return
    value, in case it’s NULL. [Listing 5-15](#lis5-15) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: A main.php script calling the nullable-type string_to_int() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign string ''three'' as the value of the $text1 variable, then pass that
    variable to our string_to_int() function, storing the return value in $number1
    ❶. Next, we use an if...else statement to test whether the value in $number1 is
    empty (NULL) ❷. If so, we print a message stating that the string couldn’t be
    converted to an integer. Otherwise, we print a message showing the string and
    its corresponding integer. We then repeat the process with string ''onee''. Here’s
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the function returns the integer 3 when the argument is the
    string 'three', but it returns NULL when the argument is the misspelled string
    'onee'. Declaring our string_to_int() function with a nullable return type gives
    us the flexibility to respond to this problematic input in a meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: Just as functions can have nullable return types, you can use the same question
    mark syntax to declare function parameters as nullable, meaning the parameter
    can be NULL or some other type. For example, the parameter list (?string $name)
    means that a function accepts a $name parameter that is either NULL or a string.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having to duplicate the if...else statement in our *main.php* script
    each time we call our string_to_int() function, as we did in [Listing 5-15](#lis5-15),
    we might take the function’s NULL or integer return value and pass it as an argument
    to another function to generate an appropriate message. That function therefore
    needs to be able to accept a parameter that may be NULL or an integer. [Listing
    5-16](#lis5-16) shows such a function named int_to_message(). Add the function
    to the end of your *my_functions.php* file*.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-16: A function with a nullable type for the $number parameter'
  prefs: []
  type: TYPE_NORMAL
- en: The signature for this function includes a single parameter called $number of
    nullable type ?int. This means that the argument provided to the function can
    be either NULL or an integer. The function body uses the if...else statement we
    had in our *main.php* script to return an appropriate message depending on which
    data type is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: We can now greatly simplify our main script by removing the duplicated if...else
    statements and calling our new function instead. [Listing 5-17](#lis5-17) shows
    the updated script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-17: Simplifying main.php with the int_to_message() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that our main script is much simpler now that the logic for generating
    the message has been moved to a function. For each input, we follow a pattern
    of three basic statements: declaring a string ❶, storing the integer (or NULL)
    returned from calling string_to_int() with that string ❷, and printing the string
    returned by passing this integer or NULL value to the int_to_message() function
    ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: If we really want to make our code even more succinct, we can put all three
    of those statements into a single line ❹, calling the string_to_int()function
    inside the parentheses when we call the int_to_message() function. This way, the
    former’s return value is passed directly as an argument to the latter, without
    the need for an intermediary variable. This choice is a matter of programming
    style. Personally, I prefer to use intermediate variables to prevent a single
    line of code from becoming too complex.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want a function to be able to return a range of data types, declare its
    return value by using a *union type*. This is a list of the value’s possible data
    types, separated by vertical bars. For example, int|float indicates that a value
    could be an integer or a float. Union types can apply to function parameters as
    well as return values.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable types are essentially a special category of union types, and their
    question mark syntax provides a convenient shorthand when one of the possible
    data types is NULL. The union type string|NULL is the same as the more concise
    nullable type ?string, for example. Union types are most useful when your code
    has multiple non-NULL types, like int|float, or when there are multiple non-NULL
    types plus NULL, like string|int|NULL, indicating the data type could be a string,
    an integer, or NULL. This couldn’t be expressed with nullable-type syntax, since
    you can’t mix a nullable type with others in a union by writing something like
    ?string|int. You also can’t include void as one of the types in the union.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate union types, let’s modify our string_to_int() function into a
    string_to_number() function that can return an integer, a float, or NULL, depending
    on the string passed in. We’ll also update our int_to_message() function into
    a number_to_message() function that can take in an integer, a float, or NULL as
    a parameter. Update *my_functions.php* to match [Listing 5-18](#lis5-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-18: Using union types as function return values and parameters'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare string_to_number(), a revised version of our string_to_int()
    function. We use the union type int|float|null to indicate that the function will
    return an integer, a float, or NULL ❶. Just like string_to_int() previously, this
    function takes in a single string parameter. We add a new clause to the match
    statement in the function body, matching the string 'half' to the float value
    0.5 ❷, hence the need for the union type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare number_to_message(), a revised version of int_to_message()
    that returns a string. This function takes in two parameters. The first, the string
    $text, will be the same as the string passed to our string_to_number() function.
    The second, $number, will be that function’s return value, and so it might be
    an integer, a float, or NULL. We therefore use the same int|float|NULL union type
    for the parameter ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we first test whether $number contains an integer value
    ❹, in which case we return a message stating that $text is an integer. Next, we
    test whether $number contains a float value ❺, returning an appropriate message
    if it does. Finally, we return a message stating that $text couldn’t be converted
    to a number ❻. Execution wouldn’t get this far if either of the previous return
    statements was executed, so we know at this point that $number is neither an integer
    nor a float. We therefore don’t need to place this final return statement inside
    an else clause or another if statement, although we could.
  prefs: []
  type: TYPE_NORMAL
- en: This choice is a matter of personal programming style. I like to end functions
    like this with an unconditional return statement, so I can clearly see the default
    to be returned. However, some programmers prefer to end the last if statement
    with an else clause as a way to communicate the default. The execution is the
    same either way.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s test our functions. Update your *main.php* script to match [Listing
    5-19](#lis5-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-19: Calling functions with union type parameters and return values
    in main.php'
  prefs: []
  type: TYPE_NORMAL
- en: We call our string_to_number() function, passing in the string 'three', and
    store the result in the $number1 variable. Then we pass $number1 along to our
    number_to_message() function and print the message that it returns. This code
    should output the message 'three' as an integer = 3.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the value of a parameter will usually be the same each time you call a function,
    you can set a default value for that parameter when you declare the function.
    In effect, this makes the parameter optional. You’ll need to include an argument
    corresponding to that parameter only when you know you’ll want the value to be
    something other than the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of PHP’s built-in functions have optional parameters with default values.
    For example, PHP’s number_format() function, which takes in a float and converts
    it into a string, has several optional parameters controlling how the string will
    be formatted. Enter php -a at the command line to try out the following code in
    interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The number_format() function’s first parameter is not optional; it’s the float
    that we want to format. By default, calling the function with just one argument
    ❶ returns a string version of the number with the decimal portion removed. When
    we add an integer as an optional second argument ❷, the function uses that integer
    to set the number of decimal places to include. We’ve used the value 2 to preserve
    two decimal places. By default, the decimal separator is represented with a period,
    but if we add a string as an optional third argument ❸, the function will use
    that string as the decimal separator instead. In this case, we’re using a comma,
    a common decimal separator in continental Europe.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-20](#lis5-20) shows the signature for the number_format() function,
    taken from the PHP online documentation, to illustrate how the default values
    for the parameters are declared.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-20: The built-in number_format() function, including optional parameters
    with default values'
  prefs: []
  type: TYPE_NORMAL
- en: First, notice that when you have a long list of parameters, you can spread them
    over several lines to make the code more readable. The function takes up to four
    parameters, but the second, third, and fourth all have default values assigned
    with the assignment operator (=) after the parameter name. For example, the second
    parameter, $decimals, has a default value of 0, so when we call number_format(1.2345)
    without providing a second argument, the function executes with the default value
    for $decimals and formats the number to include zero decimal places. Likewise,
    the $decimal_separator parameter has a period as its default value, and the $thousands_separator
    parameter has a comma.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which the parameters are declared is important. All mandatory parameters
    (those without default values) must be listed first, followed by the optional
    parameters. This is because the order of arguments when you call a function must
    match the order of the parameters. If you had an optional parameter followed by
    a mandatory one, and you omitted the optional parameter, there’d be no way to
    know that your first argument was meant to correspond to the second parameter.
    The only exception to this rule is if you use named arguments, as we’ll discuss
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how optional parameters work, let’s add one to a custom
    function. We’ll revisit our which_is_smaller() function from earlier in the chapter
    and add an optional parameter controlling how the function behaves if the values
    passed in for comparison are the same. Return to the *my_functions.php* file for
    that project and update the script to match [Listing 5-21](#lis5-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-21: Updating the which_is_smaller() function to include an optional
    parameter'
  prefs: []
  type: TYPE_NORMAL
- en: We add a third parameter to our function, the Boolean $nullIfSame, and give
    it a default value of false ❶. Thanks to this default value, the function will
    typically return $n1 if $n1 and $n2 are found to be the same ❸. However, if the
    user overrides this default by passing true as the third argument when calling
    the function, NULL is returned instead ❷. To account for this possibility, we
    use the nullable type ?int to set the function’s return type.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of if and return statements matters here. The code will get to
    if ($nullIfSame) ❷ only if $n1 and $n2 are equal. Since $nullIfSame is false by
    default, this condition will typically fail, so the final return $n1; will execute
    ❸. It’s only if the user has set $nullIfSame to true that the function returns
    NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Update the project’s *main.php* file as shown in [Listing 5-22](#lis5-22) to
    test the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-22: Calling which_is_smaller() from main.php, with and without the
    optional parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call out which_is_smaller() twice, using var_dump() to show the results.
    The first time we pass in 1 and 1 and leave out the optional argument, so $nullIfSame
    will be false by default. The second time, we add true as a third argument, overriding
    the default. Here’s the output of running the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first line indicates that the function followed the default behavior of
    returning 1 (the value of the first argument) when we omitted the optional argument.
    When we used the third argument to set $nullIfSame to true, however, the function
    returned NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Positional vs. Named Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you call a function, the PHP engine by default interprets the arguments
    *positionally*, matching them to the function’s parameters based on their order.
    However, you can also call a function by using *named arguments*: you explicitly
    pair an argument’s value with the name of the corresponding parameter. In this
    case, the order of arguments no longer matters. Named arguments are especially
    useful when a function has optional parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use named rather than positional arguments, you don’t have to change the
    function declaration in any way, although it becomes even more important to have
    meaningful parameter names. Instead, all you have to do is include the parameter
    name (minus the dollar sign) inside the parentheses when you call a function,
    followed by a colon (:) and the desired argument value. For example, to use a
    named argument to pass true as the value of the $nullIfSame parameter when calling
    our which_is_smaller() function, you would include nullIfSame: true in the argument
    list. The convention is to add a space after the colon.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-23](#lis5-23) shows an updated *main.php* file, adding an extra
    call to which_is_smaller() using named arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-23: Calling which_is_smaller() by using positional and named arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new call to which_is_smaller() ❶ is functionally equivalent to the previous
    call, but we use named arguments. As such, we’re able to list the arguments in
    a different order from the way the parameters were declared: first $nullIfSame,
    then $n1, then $n2. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines of output are both NULL, indicating the last two function
    calls achieved the same result using positional and named arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each function call used all positional or all named arguments,
    but you can also mix both styles of arguments in the same function call. In that
    case, the positional arguments must come first, in the same sequence as the function
    declaration, followed by the named arguments in whatever sequence you wish. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the first argument, 5, doesn’t have a name. PHP will therefore treat it
    positionally and match it to the first parameter declared, which is $n1. The remaining
    arguments are named and so can appear in any order. By contrast, here’s another
    call to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This time we’ve started with a named argument for $nullIfSame. Then we have
    an unnamed argument, 5, presumably intended for the $n1 parameter. The PHP engine
    will have no way of knowing this, however, since we started with a named argument,
    and so this function call will trigger an error.
  prefs: []
  type: TYPE_NORMAL
- en: Skipped Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a function has multiple optional parameters, you can use named arguments
    to set just the optional parameters that you want while skipping the rest. This
    works because the named arguments free you from adhering to the order of the parameters.
    Any parameters you skip will take on their default values. To illustrate, let’s
    create a function that prints customizable greetings. Start a new project and
    create *my_functions.php* to match [Listing 5-24](#lis5-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-24: A greet() function with two optional parameters'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the greet() function as void, since it prints out a message without
    returning a value. The function has a required string parameter $name, as well
    as two optional parameters with default values, $greeting and $hasPhD. The body
    of the function is an if statement that outputs the values of $greeting and $name,
    inserting the title Dr. in between if parameter $hasPhD is true ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll look at a few ways to call the greet() function. Create *main.php*
    containing the code shown in [Listing 5-25](#lis5-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-25: A main script calling greet() with skipped parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call greet(), we pass just the string 'Matt' as an argument.
    We don’t use named arguments, so this will be matched positionally to the $name
    parameter. The other parameters will use their default values, resulting in the
    message Good morning, Matt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time we call greet(), we use the positional argument ''Matt'' and
    the named argument hasPhD: true. Notice that $hasPhD is the third parameter in
    the function declaration; we’ve skipped over the second parameter! This is perfectly
    fine. The parameter we skipped, $message, has a default value, and thanks to our
    use of a named argument, the PHP engine will know unambiguously which provided
    arguments match which function parameters. We should get the message Good morning,
    Dr. Matt as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of running the *main.php* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output is just as we expect. Thanks to the combination of default parameter
    values and named arguments, we are able to skip the $message parameter without
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-by-Value vs. Pass-by-Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, PHP functions match arguments to parameters by using a *pass-by-value*
    approach: the values of the arguments are copied and assigned (passed) to the
    appropriate parameters, which are created as temporary variables limited to the
    scope of the function. In this way, if the values of any parameters are manipulated
    while the function is executing, those changes will have no effect on any values
    outside the function itself. After all, the function is working with copies of
    the original values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is *pass-by-reference*: instead of receiving copies, the function
    parameters are passed references to the original variables themselves. In this
    way, if a variable is passed as an argument to a function, the function can permanently
    change the value of that variable. To indicate a pass-by-reference parameter,
    place an ampersand (&) immediately before the parameter name when you’re declaring
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t typically recommend using pass-by-reference parameters; in fact, I can’t
    think of a single one I’ve written in the last 20 years. Allowing functions to
    change the variables passed to them makes programs more complex and therefore
    harder to understand, test, and debug. Still, it’s important to be familiar with
    the concept, since you might encounter pass-by-reference parameters in other people’s
    code, including in third-party libraries you might want to use for your own projects.
    Calling a function with pass-by-reference parameters without knowing how they
    work could lead to unintended results.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*In some programming languages, programmers use several pass-by-reference parameters
    as a way for a function to “return” multiple values without the need for* return
    *statements. There are better ways to do this in modern PHP, however, such as
    returning an array (see [Chapter 7](chapter7.xhtml)) or an object (see [Part V](part5.xhtml)).*'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the difference between pass-by-value and pass-by-reference parameters,
    and to show why the latter are often best avoided, we’ll create two versions of
    a function that calculates someone’s future age. Start a new project and create
    *my_functions.php* with the contents of [Listing 5-26](#lis5-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-26: A pass-by-value version of future_age()'
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare a function named future_age(). It features an integer parameter
    $age declared in the usual way, so this will be a normal pass-by-value parameter.
    The function is declared void since no value is to be returned. In the body of
    the function, we add 1 to $age and print out a message containing the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a main script in *main.php* containing the code shown in [Listing
    5-27](#lis5-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-27: Testing the pass-by-value version of future_age()'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign the $currentAge variable an integer value of 20. Then we print out
    a message showing the value of this variable. Next, we call our future_age() function,
    passing $currentAge as an argument. We then print out another message showing
    the value of the variable. This gives us a look at the value of $currentAge before
    and after the function call. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and last lines of output are the same, indicating that calling future_age()
    has no effect on the value of the $currentAge variable. In fact, when the function
    is called, a local variable $age is created within the scope of the function,
    and the value of $currentAge is copied into it. This way, when the function adds
    1 to $age, it does so without changing the value of $currentAge. That’s how pass-by-value
    parameters work: they don’t have any influence outside the scope of the function
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s modify our future_age() function to use a pass-by-reference parameter
    and see what difference that makes. Update your *my_functions.php* file as shown
    in [Listing 5-28](#lis5-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-28: A pass-by-reference version of future_age()'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change here is adding an ampersand (&) before the parameter name,
    indicating $age is a pass-by-reference parameter. As a result, $age will no longer
    be a local variable containing a copy of the value in the variable passed as an
    argument when the function is called. Rather, $age will be a reference to that
    variable, so any changes made to $age will also be made to that variable. To prove
    it, run your *main.php* script again. This time you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that adding 1 to the $age parameter within the function also adds 1
    to the $currentAge variable outside the function. Unless the user’s birthday occurred
    in the instant between the function call and the final print statement, this probably
    isn’t what we want. This illustrates the danger of using pass-by-reference parameters:
    they can change the value of variables that are normally outside the scope of
    a function.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored how to promote code reusability by declaring
    and calling functions, named sequences of code that accomplish a particular task.
    You practiced declaring functions in a separate.p*hp* file and then loading them
    into your main application file with require_once, allowing you to write concise,
    well-organized scripts. You saw how return statements allow functions to send
    values back to the calling script while also providing a mechanism to terminate
    a function early, and you explored how nullable and union types give functions
    the flexibility to take in or output values of various data types.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the difference between parameters (the variables used within
    a function) and arguments (the values passed to those variables when you call
    a function). You saw how to make parameters optional by giving them a default
    value, and how to use named arguments to pass in values in any order or even skip
    parameters. Finally, you learned about the difference between pass-by-value and
    pass-by-reference parameters, in the rare event you want a function to be able
    to update variables outside its own scope.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create a project with separate *main.php* and *file2.php* scripts. The
    *file2.php* script should print out the string '456'. In your *main.php* script,
    first print out '123', then read in and execute *file2.php*, then print out '789'.
    The overall output should be 123456789, but the middle 456 has been printed from
    *file2.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Write a project declaring a which_is_larger() function that returns the
    larger of two integers. Your *main.php* script should read in and execute the
    file declaring your function, and then print out the results of calling the function
    with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 and 5
  prefs: []
  type: TYPE_NORMAL
- en: 21 and 19
  prefs: []
  type: TYPE_NORMAL
- en: 3 and 3
  prefs: []
  type: TYPE_NORMAL
- en: What happens in the last case, where the parameters are the same?
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Modify your which_is_larger() function to accept either integers or floats,
    and to return an integer, a float, or NULL if both numbers are the same.
  prefs: []
  type: TYPE_NORMAL
- en: '4.   Create a file *my_functions.php* that declares a void function to print
    out the first letter of your name in ASCII art style. This function should have
    two parameters, one ($character) a string setting the character to use for making
    the art, and the second ($spacer) a string setting the character to fill in the
    gaps. Assign suitable default values to each parameter. For example, since the
    first character of my name is M, my function might be capital_m(string $character
    = ''M'', string $spacer = '' ''), and it might provide the following output when
    called with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Next, write a *main.php* script to call your function with no arguments (using
    both default values). Then use named arguments to call the function two more times,
    once providing just the main character, and then providing just the spacer character.
  prefs: []
  type: TYPE_NORMAL
