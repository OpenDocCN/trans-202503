- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 5 CUSTOM FUNCTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 自定义函数
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn how to declare and use your own *functions*, which
    are named, self-contained sequences of code that accomplish a particular task.
    You’ll see how functions promote code reusability, since putting code in a function
    is much more efficient than having to rewrite the same sequence of code every
    time you need to perform that function’s task. Functions also let you write programs
    that achieve a lot with a small number of statements, since each statement can
    invoke the complex logic hidden within one of your functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何声明和使用你自己的*函数*，这些函数是命名的、独立的代码序列，旨在完成特定任务。你将看到函数如何促进代码的重用，因为将代码放入函数中要比每次执行该任务时都重新编写相同的代码序列更高效。函数还可以让你编写通过少量语句就能完成大量工作的程序，因为每个语句都可以调用隐藏在你函数中的复杂逻辑。
- en: Custom functions are typically declared in a separate file from the main program
    statements that an application will execute. This stems from the *PHP Standards
    Recommendations (PSRs)*, a list of guidelines and best practices for PHP programming.
    According to PSR-1, a file should either declare symbols (such as functions) or
    cause side effects, but not both. A *side effect* is a concrete outcome of executing
    a piece of code, such as outputting text, updating a global variable, changing
    the contents of a file, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数通常会在与应用程序主程序语句不同的文件中声明。这源于*PHP标准推荐（PSRs）*，它是一系列关于PHP编程的指南和最佳实践。根据PSR-1，文件应该要么声明符号（例如函数），要么产生副作用，但不能两者兼具。*副作用*是执行一段代码的具体结果，例如输出文本、更新全局变量、修改文件内容等等。
- en: While functions themselves can cause side effects such as these, *declaring*
    a function (defining what the function will do) isn’t the same as *calling* the
    function (having the function actually do that thing). Therefore, functions should
    be declared in one file and called in another. To adhere to this guideline, this
    chapter first touches on the basics of how to work with code spread across multiple
    files before we turn our attention to functions. We’ll revisit the topic of working
    with files in more detail in [Chapter 9](chapter9.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数本身可以产生这样的副作用，但*声明*一个函数（定义函数将做什么）与*调用*一个函数（让函数实际执行那个任务）是不同的。因此，函数应该在一个文件中声明，并在另一个文件中调用。为了遵循这一准则，本章首先介绍如何处理跨多个文件的代码基础知识，然后再转到函数部分。在[第9章](chapter9.xhtml)中，我们将更详细地讨论如何处理文件。
- en: Separating Code into Multiple Files
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码分成多个文件
- en: Even if we set aside the best practice of declaring functions in a separate
    file, it’s still standard to break up an application’s code across multiple files.
    Consider that a sophisticated application might consist of tens of thousands of
    lines of code. If all that code were in a single large text file, navigating that
    file and locating a particular section of code to work on would be difficult.
    Organizing code into different files makes a project much more manageable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不考虑将函数声明放在单独文件中的最佳实践，仍然有必要将应用程序的代码拆分到多个文件中。考虑到一个复杂的应用程序可能包含成千上万行代码，如果所有代码都在一个庞大的文本文件中，那么浏览该文件并找到需要处理的特定代码段将非常困难。将代码组织成不同的文件使得项目更易于管理。
- en: Using multiple files also promotes code reusability. Once you start writing
    your own functions, you’ll see how declaring those functions in separate files
    makes it easy to reuse the function in different parts of a project or in different
    projects altogether. To give another example, multipage web applications often
    include the same elements, such as HTML headers, footers, and navigation lists
    on many pages. Rather than repeating that code for each page that needs it, the
    common code can be written once in its own file. This way, if you need to change
    something about it (for example, updating the image reference for a web logo),
    you need to make the change in only one place instead of tracking down and updating
    every instance of the repeated code. Software engineers call this the *don’t repeat
    yourself (DRY)* principle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个文件还促进了代码的重用性。一旦你开始编写自己的函数，你会发现将这些函数声明在不同的文件中，可以轻松地在项目的不同部分或完全不同的项目中重用这些函数。再举个例子，多个页面的网页应用程序通常在许多页面中包含相同的元素，例如
    HTML 头部、底部和导航列表。与其为每个需要这些元素的页面重复写这些代码，不如将通用代码写在一个文件中。这样，如果需要对其进行更改（例如，更新网页徽标的图片引用），你只需在一个地方进行更改，而不是追踪并更新每个重复代码的实例。软件工程师称这一做法为*不要重复自己（DRY）*原则。
- en: Once you start spreading an application’s code across multiple files, you need
    a way to access one file’s code from within another file. In this section, we’ll
    look at some PHP language features that make this possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始将应用程序的代码分布到多个文件中，就需要一种方法从一个文件中访问另一个文件的代码。在本节中，我们将探讨一些使这成为可能的 PHP 语言特性。
- en: Reading in and Executing Another Script
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取并执行另一个脚本
- en: PHP’s require_once command reads the code in another file and executes it. To
    see how this command works, we’ll create two scripts. One, the main script, will
    use require_once to access the code from the other script. First, create a *main.php*
    file containing the code shown in [Listing 5-1](#lis5-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 require_once 命令可以读取另一个文件的代码并执行它。为了了解这个命令是如何工作的，我们将创建两个脚本。其中一个是主脚本，它将使用
    require_once 来访问另一个脚本中的代码。首先，创建一个名为*main.php*的文件，包含 [Listing 5-1](#lis5-1) 中的代码。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: A main script to read in and execute code from a different script'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-1: 读取并执行来自不同脚本的代码的主脚本'
- en: 'In this script, we print out two messages indicating that we’re in the main
    application file. In between, we use the require_once command to read in and execute
    the contents of the *file2.php* script. The filename is specified as a string
    immediately after the command. Since we haven’t specified a directory path along
    with the filename (for example, *Users/matt/file2.php*), it’s understood that
    the file is in the same folder as this current script. This is known as a *relative
    path*: the file’s location is determined relative to the location of the current
    script.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们打印出两条消息，指示我们正在主应用程序文件中。在两条消息之间，我们使用 require_once 命令来读取并执行 *file2.php*
    脚本的内容。文件名作为字符串立即出现在命令后面。由于我们没有指定与文件名一起的目录路径（例如，*Users/matt/file2.php*），因此默认理解该文件与当前脚本位于同一文件夹中。这被称为*相对路径*：文件的位置是相对于当前脚本的位置确定的。
- en: Now create *file2.php* containing the code shown in [Listing 5-2](#lis5-2).
    Be sure to save this file in the same location as *main.php*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为*file2.php*的文件，包含 [Listing 5-2](#lis5-2) 中的代码。确保将此文件保存在与*main.php*相同的位置。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: The contents of file2.php to be read in and executed from another
    script'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-2: 从另一个脚本读取并执行的 file2.php 内容'
- en: This script has two print statements, printing out messages saying they’re from
    *file2.php*. Notice that each message begins with a tab escape character (\t).
    This way, these messages will be indented, whereas the messages printed from our
    main script won’t be, a visual clue that the messages are coming from separate
    scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本包含两个打印语句，打印出消息，表示它们来自*file2.php*。请注意，每条消息的开头都有一个制表符转义字符（\t）。这样，这些消息就会缩进，而我们主脚本中打印的消息则不会，这是一个视觉提示，表明这些消息来自不同的脚本。
- en: 'Now enter php main.php at the command line to run the main script. Here’s the
    output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在命令行中输入 php main.php 来运行主脚本。以下是输出结果：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see the first message from the main script, followed by the two indented
    messages from *file2.php*. This confirms that the contents of *file2.php* were
    read in and executed thanks to the require_once statement in our main script.
    Finally, the program flow of control returns back to the main script after the
    require_once statement, and we see the final printed message from the main script.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到主脚本的第一条消息，接着是来自 *file2.php* 的两条缩进消息。这确认了由于主脚本中的 require_once 语句，*file2.php*
    的内容已被读取并执行。最后，程序控制流返回主脚本，经过 require_once 语句后，我们看到了主脚本打印的最终消息。
- en: NOTE
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Besides* require_once*, PHP provides three other commands for reading in and
    executing code declared in a separate file:* require*,* include*, and* include_once*.
    They all work similarly; you can read about the differences in the PHP documentation.
    In 99.99 percent of the web applications I write, I use* require_once*.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了* require_once*，PHP 还提供了另外三个命令，用于读取和执行声明在独立文件中的代码：* require*，* include*
    和 *include_once*。它们的工作方式类似；你可以在 PHP 文档中阅读它们的区别。在我编写的 99.99% 的 Web 应用程序中，我使用 *require_once*。*'
- en: Creating Absolute Filepaths
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建绝对文件路径
- en: The constant __DIR__ will always refer to the *absolute filepath* to the script
    currently being executed, meaning the complete filepath, starting from the root
    directory. This is one of PHP’s *magic constants*, built-in constants whose value
    changes depending on the context. In the case of __DIR__, the value varies based
    on the location of the file in which __DIR__ is being evaluated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 __DIR__ 始终指向当前执行脚本的 *绝对文件路径*，即从根目录开始的完整文件路径。这是 PHP 的 *魔术常量* 之一，内置常量，其值根据上下文而变化。对于
    __DIR__ 来说，值取决于 __DIR__ 被评估时所在文件的位置。
- en: 'It’s best to use __DIR__ whenever possible when writing require_once statements:
    simply concatenate the value of __DIR__ with any remaining relative path information
    to access the file you’re trying to read in and execute. This avoids any confusion
    as to whether the path relates to the current script (the one calling the require_once
    command) or to a script that might have required the current script. Consider
    that you might have a chain of scripts, with one script requiring another, and
    that script also requiring another. If these scripts were in different directories,
    using the __DIR__ magic constant ensures that wherever you write a require_once
    statement, you’ll know the path will be correct to the files you wish to read
    in and execute.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 require_once 语句时，最好尽可能使用 __DIR__：只需将 __DIR__ 的值与任何剩余的相对路径信息连接起来，即可访问你试图读取和执行的文件。这可以避免混淆路径是与当前脚本（调用
    require_once 命令的脚本）相关，还是与可能已经要求当前脚本的脚本相关。假设你有一系列的脚本，其中一个脚本要求另一个脚本，而那个脚本也要求另一个脚本。如果这些脚本位于不同的目录中，使用
    __DIR__ 魔术常量可以确保无论你在何处写 require_once 语句，你都能知道路径正确指向你希望读取和执行的文件。
- en: To try using __DIR__, update your *main.php* file as shown in [Listing 5-3](#lis5-3).
    The changes are shown in black text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试使用 __DIR__，请按 [列表 5-3](#lis5-3) 所示更新你的 *main.php* 文件。更改部分以黑色文字显示。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-3: A main script using __DIR__ to read in and execute code in a different
    script'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-3：使用 __DIR__ 读取和执行不同脚本中的代码的主脚本
- en: 'We assign the $callingScriptPath variable the value of the __DIR__ magic constant
    and print a message containing this variable. Then we use __DIR__ after the require_once
    command to make it explicit that the *file2.php* script resides in the same directory
    as this main script ❶. Notice that we use the string concatenation operator (.)
    to combine the value of __DIR__ with the string ''/file2.php'', building an absolute
    path to the other file. Here’s the output of running the main script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 $callingScriptPath 变量赋值为 __DIR__ 魔术常量的值，并打印包含该变量的消息。然后在 require_once 命令之后使用
    __DIR__，明确表示 *file2.php* 脚本与此主脚本位于同一目录❶。请注意，我们使用字符串连接运算符（.）将 __DIR__ 的值与字符串 '/file2.php'
    结合，构建到另一个文件的绝对路径。以下是运行主脚本后的输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As before, the first message from *main.php* prints out. Then we see the path
    to the main script (the value of __DIR__) printed out ❶. For me, it is */Users/matt/magic*,
    the path to the directory on my computer for this example project. The rest of
    the output is the same as before, featuring the messages from *file2.php* followed
    by the final printed message from the main script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，首先打印出来自 *main.php* 的消息。然后我们看到打印出的主脚本路径（__DIR__ 的值）❶。对我来说，这是 */Users/matt/magic*，即我电脑上该示例项目所在目录的路径。其余输出与之前相同，包含来自
    *file2.php* 的消息，最后是主脚本打印的最终消息。
- en: Declaring and Calling a Function
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明和调用一个函数
- en: Now let’s turn our attention to declaring and using our first custom function.
    The function will determine which of two numbers is smaller. In keeping with best
    practices, we’ll declare the function in one file, *my_functions.php*, and then
    call it from a separate file, *main.php*. Start a new project and create *my_functions.php*
    containing the code shown in [Listing 5-4](#lis5-4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注如何声明和使用我们的第一个自定义函数。这个函数将确定两个数字中哪个较小。按照最佳实践，我们将函数声明在一个文件中，*my_functions.php*，然后从另一个文件中调用它，*main.php*。开始一个新项目并创建包含[列表
    5-4](#lis5-4)代码的 *my_functions.php*。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-4: Declaring a function in my_functions.php'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-4：在 my_functions.php 中声明函数
- en: Here we declare a function named which_is_smaller(). We begin with the keyword
    function, followed by the function name. By convention, function names are written
    in snake case, in all lowercase letters and with underscores to join multiple
    words. This enables you to write meaningful, easy-to-read function names (although,
    unfortunately, not all of PHP’s built-in functions follow this naming convention
    because of choices made in the language’s early design).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们声明了一个名为 which_is_smaller() 的函数。我们从关键字 function 开始，后跟函数名称。按照约定，函数名使用蛇形命名法，全部小写字母并用下划线连接多个单词。这使得你可以编写有意义、易读的函数名（尽管遗憾的是，由于语言早期设计时的选择，并不是所有PHP内置函数都遵循这种命名约定）。
- en: After the function name comes a set of parentheses containing a comma-separated
    list of the function’s *parameters*. These are inputs that the function needs
    to do its job. In this case, we have two parameters, $n1 and $n2, representing
    the two numbers we want the function to compare. Each parameter name is preceded
    by its data type to ensure that the correct form of data enters the function.
    Here, for example, int $n1 indicates that parameter $n1 should be an integer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名后面跟着一对括号，括号内是函数的*参数*，它们是函数完成工作的输入。在这个例子中，我们有两个参数，$n1 和 $n2，代表我们希望函数比较的两个数字。每个参数名前面都有数据类型，以确保正确的数据类型传递给函数。例如，int
    $n1 表示参数 $n1 应该是一个整数。
- en: NOTE
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If a function doesn’t need any parameters, you still have to include an empty
    set of parentheses after the function name.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果一个函数不需要任何参数，你仍然需要在函数名称后面包括一对空括号。*'
- en: After the parentheses comes a colon (:), followed by the function’s return type.
    Most functions do some work and produce a value as a result, which the function
    then *returns*, or provides, to the script that called the function. The *return
    type* specifies the data type of this value. In this case, the function will return
    the integer $n1 or $n2, whichever is smaller, so we set the return type to int.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 括号后面跟着一个冒号（:），然后是函数的返回类型。大多数函数会执行一些操作并产生一个结果值，然后该函数将这个值*返回*给调用它的脚本。*返回类型*指定了该值的数据类型。在这个例子中，函数将返回整数
    $n1 或 $n2 中较小的一个，因此我们将返回类型设置为 int。
- en: The code we’ve written so far has defined the function’s *signature*, a combination
    of its name, parameters (and their types), and return type. The PHP engine uses
    a function’s signature to uniquely identify the function, recognize when we’re
    calling it, validate that appropriate data is being passed to the function’s parameters,
    and ensure that the function is returning an appropriate value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们写的代码已经定义了函数的*签名*，它是函数的名称、参数（及其类型）和返回类型的组合。PHP引擎使用函数的签名来唯一标识该函数，识别我们何时调用它，验证传递给函数参数的数据是否合适，并确保函数返回一个合适的值。
- en: Next comes the *body* of the function, a statement group enclosed within curly
    brackets and containing the code that will execute each time the function is called.
    The body of our which_is_smaller() function consists of an if...else statement
    that tests whether integer $n1 is smaller than integer $n2. If $n1 is smaller,
    the return $n1; statement will be executed. Otherwise (if $n2 is smaller or the
    same as $n1), return $n2; will be executed. In both cases, we use the return keyword
    to make the function provide a value (either $n1 or $n2) to the script that called
    it. As soon as a function reaches a return statement, the function stops executing
    and gives control back to the calling script. Even if the function body includes
    additional statements after the return statement, they won’t execute after the
    function has returned a value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是函数的*主体*，它是一个被大括号括起来的语句组，包含每次调用函数时会执行的代码。我们which_is_smaller()函数的主体由一个if...else语句组成，测试整数$n1是否小于整数$n2。如果$n1较小，则执行return
    $n1;语句。否则（如果$n2较小或等于$n1），则执行return $n2;语句。在这两种情况下，我们使用return关键字将值（$n1或$n2）传递给调用它的脚本。一旦函数到达return语句，函数会停止执行并将控制权交还给调用脚本。即使函数体内在return语句之后有其他语句，它们也不会在函数返回值后执行。
- en: Now that we’ve declared a function, let’s use it. Create *main.php* in the same
    location as *my_functions.php* and enter the code shown in [Listing 5-5](#lis5-5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了一个函数，接下来让我们使用它。创建与*my_functions.php*位于同一位置的*main.php*文件，并输入[清单5-5](#lis5-5)中显示的代码。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-5: Calling the which_is_smaller() function from main.php'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-5：从main.php调用which_is_smaller()函数
- en: We use require_once to read in the declaration of our function from *my_functions.php*.
    This doesn’t call the function; it simply makes the function available for use
    in our *main.php* script. Next, we call our function by writing the function name,
    followed in parentheses by the values we want the function to compare, 5 and 2.
    These values are known as *arguments*; they fill in the values of the function’s
    parameters. Notice that we call the function as part of an assignment statement
    for the $result1 variable. This way, the function’s return value will be stored
    in $result1 for later use (in this case, in the next line of code, where it’s
    printed out in a message). When a function has a return value, it’s common to
    follow this pattern of calling a function and assigning the result to a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用require_once从*my_functions.php*文件中读取函数声明。这并不会调用函数，它只是使函数在*main.php*脚本中可用。接下来，我们通过编写函数名并在括号中跟上我们希望函数比较的值（5和2）来调用函数。这些值被称为*参数*；它们填充函数的参数值。注意，我们将函数调用作为$results1变量赋值语句的一部分进行调用。这样，函数的返回值将存储在$results1中，以供以后使用（在这种情况下，是在下一行代码中，那里会将其打印出来）。当一个函数有返回值时，通常会遵循这种调用函数并将结果赋值给变量的模式。
- en: 'We conclude the script by calling the function again, this time using 5 and
    22 as arguments. This is the beauty of functions: you can call them as many times
    as you want, with different input values each time. We store the return value
    of the second function call in the $result2 variable and again print out a message
    showing the result. Here’s the output of running the *main.php* script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过再次调用该函数来结束脚本，这次使用5和22作为参数。这就是函数的魅力：你可以根据需要调用它们多次，每次使用不同的输入值。我们将第二次函数调用的返回值存储在$result2变量中，并再次打印出显示结果的消息。下面是运行*main.php*脚本的输出：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that our function is working correctly. It returns 2 as the smaller
    of 5 and 2, and 5 as the smaller of 5 and 22.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的函数工作正常。它返回5和2中的较小值2，以及5和22中的较小值5。
- en: Parameters vs. Arguments
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数与实参
- en: The terms *parameter* and *argument* are closely related and often mistaken
    for each other. When you *declare* a function, the parameters are variables that
    stand in for the inputs the function will work with. As you saw in [Listing 5-4](#lis5-4),
    you list the parameters in the parentheses after the function name. In our which_is_smaller()
    function, the parameters were $n1 and $n2. Each parameter is a temporary variable,
    local to the function code itself, that will be assigned a value when the function
    is called. These variables exist only while the function is being executed. Once
    the function has finished executing, the local parameter variables are discarded
    from the computer’s memory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数*和*实参*这两个术语密切相关，经常互相混淆。当你*声明*一个函数时，参数是代表函数将要处理的输入的变量。如你在[清单 5-4](#lis5-4)中所见，参数会列在函数名称后的括号内。在我们的
    which_is_smaller() 函数中，参数是 $n1 和 $n2。每个参数都是一个临时变量，仅在函数内部可见，在函数被调用时会被赋予一个值。这些变量只在函数执行期间存在。一旦函数执行完毕，局部参数变量会从计算机的内存中被丢弃。'
- en: The technical term for how long a variable “lives” in a software system is *scope*.
    The scope of any variable declared in a function, including a parameter, is local
    to the function itself. As such, you can’t expect to access a function’s variables
    from any code outside the function declaration. In our example, we can’t use the
    variables $n1 and $n2 in *main.php*. Instead, the way to get a value out of a
    function is with a return statement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在软件系统中“存在”的时间长度被称为*作用域*。在函数中声明的任何变量，包括参数，其作用域是局部的，仅限于函数本身。因此，你不能期望从函数声明外的任何代码访问函数的变量。在我们的例子中，我们不能在
    *main.php* 中使用变量 $n1 和 $n2。相反，获取函数返回值的方法是使用返回语句。
- en: 'When we *call* a function, the arguments are the specific values we pass to
    the function in the parentheses after the function name. These arguments supply
    the values for the function’s parameters. When we call which_is_smaller(5, 22),
    for example, the argument 5 is assigned as the value of parameter $n1, and the
    argument 22 is assigned as the value of parameter $n2. The order of arguments
    matches the order of parameters. In this case, the arguments are literals, but
    arguments can also be variables, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们*调用*一个函数时，实参是我们在函数名称后的括号中传递给函数的具体值。这些实参为函数的参数提供值。例如，当我们调用 which_is_smaller(5,
    22) 时，实参 5 被赋值给参数 $n1，实参 22 被赋值给参数 $n2。实参的顺序与参数的顺序相匹配。在这个例子中，实参是字面量，但实参也可以是变量，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s all there is to it. Arguments are the values passed when executing a
    function, and parameters are the local variables created when the function executes,
    populated by the arguments received. Each argument passed to a function will therefore
    have a corresponding local (temporary) parameter variable while that function
    is executing. (One exception is the special case of pass-by-reference parameters,
    which we’ll cover later this chapter.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。实参是在执行函数时传递的值，参数是在函数执行时创建的局部变量，由接收到的实参填充。因此，在函数执行期间，每个传递给函数的实参都会有一个对应的局部（临时）参数变量。（有一个例外是通过引用传递参数的特殊情况，我们将在本章后面讨论。）
- en: Errors from Incorrect Function Calls
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误来源于不正确的函数调用
- en: 'In two common cases, you’ll get an error when calling a function: if you don’t
    pass the correct number of arguments, or if you pass arguments of the wrong data
    type. (See “Errors, Warnings, and Notices” on [page 88](#pg_88) for information
    on errors and other kinds of alerts generated about your code.) Consider this
    call to our custom which_is_smaller() function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种常见情况下，调用函数时会发生错误：如果你没有传递正确数量的实参，或者传递了错误数据类型的实参。（有关错误及其他类型警告的信息，请参见[第88页](#pg_88)的“错误、警告和通知”。）考虑调用我们自定义的
    which_is_smaller() 函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function requires two integer arguments, but we’re providing only one.
    If you try to execute this expression, the application will halt and you’ll see
    a fatal error similar to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要两个整数类型的实参，但我们只提供了一个。如果你尝试执行这个表达式，应用程序将停止运行，你会看到类似以下的致命错误：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You’ll also get a fatal error if you pass arguments of the wrong data type
    (that is, values that can’t be type-juggled into the parameter data types specified
    in the function declaration). Consider this expression, where we pass non-numeric
    strings to our which_is_smaller() function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了错误数据类型的实参（即不能转换为函数声明中指定的参数数据类型的值），你也会遇到致命错误。考虑下面这个表达式，我们将非数字的字符串传递给 which_is_smaller()
    函数：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Trying to execute this statement will produce an error message like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行该语句会产生类似于以下的错误消息：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A fatal TypeError has occurred because our function requires two integer arguments
    but we’ve provided strings instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了一个致命的类型错误（TypeError），因为我们的函数需要两个整数参数，但我们提供了字符串类型的参数。
- en: '#### Type Juggling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 类型转换'
- en: To avoid a TypeError like the one we just saw when arguments of the wrong type
    are provided, the PHP engine attempts to juggle those arguments into the expected
    data type. (For a refresher on type juggling, see [Chapter 2](chapter2.xhtml).)
    [Listing 5-6](#lis5-6) shows some examples where we provide non-integer arguments
    to our which_is_smaller() function. Update your *main.php* file to match the listing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免我们刚刚看到的那种类型错误（TypeError），当传入错误类型的参数时，PHP引擎会尝试将这些参数转换成期望的数据类型。（有关类型转换的回顾，请参阅[第2章](chapter2.xhtml)。）[清单
    5-6](#lis5-6)展示了在我们向`which_is_smaller()`函数传入非整数类型参数时的一些示例。更新你的*main.php*文件，使其与清单一致。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-6: Updating the main.php script to demonstrate type juggling'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-6：更新main.php脚本以演示类型转换
- en: 'We call which_is_smaller() three times and print the results. None of these
    function calls will trigger an error, since the arguments can all be juggled to
    integers. First, we call the function with float 3.5 and integer 2. The float
    will be juggled to integer 3. Next, we use integer 3 and string ''55'' as arguments.
    This time, the string will be converted to integer 55. Finally, we pass Boolean
    false and integer -8 as arguments. The false will be converted to integer 0. Here’s
    the output of running the script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`which_is_smaller()`函数三次并打印结果。由于所有参数都可以转换为整数，因此这些函数调用都不会触发错误。首先，我们使用浮动类型3.5和整数2调用函数。浮动类型将转换为整数3。接下来，我们使用整数3和字符串'55'作为参数。这一次，字符串将转换为整数55。最后，我们传递布尔值false和整数-8作为参数。false将转换为整数0。以下是运行脚本后的输出结果：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run the script, the first thing you should see printed out is a deprecation
    message informing you that you’re losing precision when float 3.5 is juggled into
    integer 3. This message indicates that at some point in the future (possibly PHP
    9), PHP will stop automatically juggling floats with fractional components into
    integers, so the code will someday stop working and trigger an error. After this
    message, you should see the results of the three print statements, indicating
    that the three function calls occurred without issue, thanks to PHP’s automatic
    type juggling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，首先打印出来的应该是一个废弃警告消息，告知你当浮动类型3.5转换为整数3时，精度会丢失。此消息表示，在未来的某个时刻（可能是PHP 9），PHP将停止自动将带有小数部分的浮动类型转换为整数，因此代码有朝一日将停止工作并触发错误。在该消息之后，你应该能看到三次打印语句的结果，表明由于PHP的自动类型转换，这三次函数调用都正常执行了。
- en: NOTE
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*When you encounter a deprecation message, reading a discussion about the upcoming
    change can be informative. For example, the request for comments (RFC) document
    explaining the deprecation message output from [Listing 5-6](#lis5-6) is available
    online at* [https://wiki.php.net/rfc/implicit-float-int-deprecate](https://wiki.php.net/rfc/implicit-float-int-deprecate)*.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你遇到废弃警告消息时，阅读有关即将更改的讨论可能会很有帮助。例如，解释[清单 5-6](#lis5-6)中废弃消息输出的请求评论（RFC）文档可以在线查看，链接为*
    [https://wiki.php.net/rfc/implicit-float-int-deprecate](https://wiki.php.net/rfc/implicit-float-int-deprecate)*。*'
- en: These function calls worked despite the incorrect argument data types, but well-written
    programs should avoid relying on type juggling altogether. Take note of deprecation
    warnings like the one we just encountered, and look for ways to revise your code
    to cope with different kinds of values without warnings or errors. In this particular
    case, we could refactor the function to use union types (discussed in “Union Types”
    on [page 98](#pg_98)), which would allow both integers and floats as arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些函数调用在参数类型不正确的情况下仍然成功，但编写良好的程序应尽量避免依赖类型转换。注意类似我们刚刚遇到的废弃警告，并寻找方法修改代码，以便在没有警告或错误的情况下处理不同类型的值。在这种情况下，我们可以重构该函数，使用联合类型（在[第98页](#pg_98)的《联合类型》中讨论），这样就可以同时接受整数和浮动类型作为参数。
- en: Functions Without Explicit Return Values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有显式返回值的函数
- en: Not every function has to explicitly return a value. For example, you could
    write a function that simply prints out a message without returning anything to
    the calling script. When a function doesn’t have an explicit return value, declare
    its return type as void.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个函数都必须显式返回一个值。例如，你可以编写一个函数，仅仅打印一条消息而不返回任何内容给调用脚本。当一个函数没有显式的返回值时，应将其返回类型声明为void。
- en: To demonstrate, we’ll declare a function that prints out a given number of stars,
    padded on both sides with another spacer character to achieve a fixed line length.
    We’ll be able to use the function to create ASCII art, images formed by arranging
    characters of text. Start a new project and create *my_functions.php* containing
    the code shown in [Listing 5-7](#lis5-7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将声明一个函数，该函数打印出给定数量的星号，并在两侧用另一个填充字符进行填充，以实现固定的行长度。我们可以使用该函数创建 ASCII 艺术图像，即通过排列字符文本来形成的图像。启动一个新项目，并创建包含
    [列表 5-7](#lis5-7) 中代码的 *my_functions.php* 文件。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-7: Declaring the print_stars() function in my_functions.php'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：在 my_functions.php 中声明 print_stars() 函数
- en: 'Here we declare a function named print_stars(). The function requires two parameters:
    $numStars and $spacer. The integer $numStars is the number of stars (* characters)
    to be printed out. The string $spacer is the character to use as padding on both
    sides of the stars. After the parentheses, we use : void to indicate that this
    function won’t explicitly return any value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们声明了一个名为 print_stars() 的函数。该函数需要两个参数：$numStars 和 $spacer。整数 $numStars
    是要打印的星号（*字符）数量。字符串 $spacer 是在星号两边作为填充的字符。在括号后面，我们使用 : void 来指示该函数不会显式返回任何值。'
- en: Inside the function body, we set the length of the line to be printed to 20
    characters. (Since this value is *hardcoded* into the function, it will be the
    same each time the function is called; a more flexible alternative could be to
    set $lineLength as a parameter.) Then we generate a string ($starsString) containing
    the number of asterisks specified by the $numStars parameter. Next, we use the
    built-in str_pad() function (discussed in [Chapter 3](chapter3.xhtml)) to create
    a string 20 characters long, with $starsString centered and padded symmetrically
    on the left and right with whatever string is in the $spacer parameter. If $numStars
    is 10 and $spacer is '.', for example, this will produce the string '.....**********.....',
    10 asterisks with 5 periods on each side, giving a total length of 20\. Finally,
    we print out the result, followed by a newline character.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们将要打印的行长度设置为 20 个字符。（由于这个值是*硬编码*在函数中的，所以每次调用该函数时，它的值都将相同；一个更灵活的替代方法是将
    $lineLength 设置为一个参数。）然后，我们生成一个包含由 $numStars 参数指定数量的星号的字符串（$starsString）。接着，我们使用内置的
    str_pad() 函数（在[第 3 章](chapter3.xhtml)中讨论）来创建一个 20 个字符长的字符串，$starsString 在其中居中，并且两侧对称地用
    $spacer 参数中的字符进行填充。例如，如果 $numStars 为 10，$spacer 为 '.'，则会生成字符串 '.....**********.....'，即
    10 个星号，两侧各有 5 个句点，总长度为 20。最后，我们打印出结果，并输出一个换行符。
- en: Notice that we haven’t included a return statement in the function body. There’s
    no need, since all the function is doing is constructing and printing a string.
    If we were to try to return a value from this function, it would trigger a fatal
    error, since we declared the function as void.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在函数体内包含 return 语句。因为没有必要，函数的作用仅仅是构造并打印一个字符串。如果我们尝试从该函数返回一个值，会触发一个致命错误，因为我们将该函数声明为
    void。
- en: Now let’s use our function to generate an ASCII art image of a tree. Create
    *main.php* containing the code shown in [Listing 5-8](#lis5-8).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的函数生成一个树的 ASCII 艺术图像。创建 *main.php* 文件，包含 [列表 5-8](#lis5-8) 中的代码。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-8: A script in main.php to generate a tree shape with the print_stars()
    function'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-8：在 main.php 中使用 print_stars() 函数生成树形图案的脚本
- en: 'After reading in the function declaration with require_once, we set the spacer
    character to be a forward slash (/) ❶. Then we call our print_stars() function
    six times, printing a tree shape made up of lines with 1, 5, 9, and 13 stars,
    plus two more lines with just 1 star for the trunk. Here’s the output of running
    the *main.php* script at the terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 require_once 引入函数声明后，我们将填充字符设置为正斜杠 (/) ❶。然后我们调用 print_stars() 函数六次，打印出由
    1、5、9 和 13 个星号组成的树形图案，并且再加上两行只有 1 个星号的树干。以下是在终端运行 *main.php* 脚本的输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve created a tree during a heavy rainstorm!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在暴风雨中创建了一棵树！
- en: Returning NULL
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回 NULL
- en: 'Even when a function is declared as void, it still technically has a return
    value: NULL. If a function finishes executing without returning a value, the function
    returns NULL by default. To prove it, let’s try calling our print_stars() function
    again and assigning the result to a variable, as we would with a function that
    has a return value. Update your *main.php* file to match [Listing 5-9](#lis5-9).
    The changes are shown in black text.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 即使函数声明为 `void`，它在技术上仍然有一个返回值：NULL。如果一个函数执行完毕没有返回值，函数会默认返回 NULL。为了证明这一点，我们可以再次调用
    `print_stars()` 函数，并像处理有返回值的函数一样，将结果赋给一个变量。更新你的 *main.php* 文件以匹配 [Listing 5-9](#lis5-9)。更改部分用黑色文本显示。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-9: Updating main.php to store and print the print_tree() function’s
    NULL return value'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-9: 更新 *main.php* 来存储并打印 `print_tree()` 函数的 NULL 返回值'
- en: 'We make the same calls to the print_stars() function as before, but this time
    we store the return value of the last function call in the $result variable. We
    then use var_dump() to see the contents of $result. Since print_stars() doesn’t
    have an explicit return value, $result should contain NULL. Here’s the output
    of running the *main.php* script:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样调用 `print_stars()` 函数，但这次我们将最后一次函数调用的返回值存储在 `$result` 变量中。然后使用 `var_dump()`
    查看 `$result` 的内容。由于 `print_stars()` 没有显式的返回值，因此 `$result` 应该包含 NULL。以下是运行 *main.php*
    脚本的输出：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see the ASCII tree again, followed by NULL from the call to var_dump().
    This confirms that the function has returned NULL by default, despite being declared
    as void.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次看到 ASCII 树，随后是从调用 `var_dump()` 得到的 NULL。这证明了尽管函数声明为 `void`，它仍然默认返回 NULL。
- en: Exiting a Function Early
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提前退出函数
- en: A function declared as void can still use a return statement, as long as the
    statement doesn’t include a value. As mentioned earlier, a function stops executing
    as soon as it encounters a return statement, so writing return without a value
    provides a mechanism for exiting a function early. This can be useful, for example,
    if a problem occurs with one of the function’s parameters. You can add validation
    logic to check the parameters at the start of the function, and use return to
    halt the function execution and resume the main calling script if one or more
    argument values aren’t as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为 `void` 的函数仍然可以使用 `return` 语句，只要该语句不包含值。如前所述，函数在遇到 `return` 语句时会立即停止执行，因此不带值的
    `return` 提供了一种提前退出函数的机制。这在例如函数的某个参数出现问题时非常有用。你可以在函数开始时添加验证逻辑来检查参数，并使用 `return`
    来提前停止函数的执行，如果一个或多个参数值不符合预期，则会恢复主调用脚本的执行。
- en: The str_pad() function we’ve been using to create centered lines of stars will
    trigger a fatal error if the padding string is empty. Rather than let that crash
    our program, let’s update our print_stars() function to first check whether the
    $spacer string parameter is empty. If it is, we’ll use return to exit the function
    early. Modify *my_functions.php* to match [Listing 5-10](#lis5-10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的 `str_pad()` 函数，如果填充字符串为空，会触发致命错误。为了避免程序崩溃，我们将更新 `print_stars()` 函数，首先检查
    `$spacer` 字符串参数是否为空。如果为空，我们将使用 `return` 提前退出函数。修改 *my_functions.php* 以匹配 [Listing
    5-10](#lis5-10)。
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 5-10: Adding a return statement to exit the print_stars() function
    early'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-10: 向 `print_stars()` 函数中添加 `return` 语句以提前退出'
- en: We add an if statement to the start of the function body, using the built-in
    empty() function to test whether $spacer is an empty string. If so, we use return
    without any value to end function execution early and return program control to
    the calling script. If the function execution gets past this if statement, then
    we know that $spacer isn’t empty, so our call to str_pad() should work fine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数体开始时添加了一个 `if` 语句，使用内建的 `empty()` 函数来检查 `$spacer` 是否为空字符串。如果为空，我们使用不带值的
    `return` 来提前结束函数执行，并将程序控制返回给调用脚本。如果函数执行通过了这个 `if` 语句，则表示 `$spacer` 不为空，这样我们的 `str_pad()`
    调用应该能正常工作。
- en: To see whether the return statement is working, update the *main.php* script
    as shown in [Listing 5-11](#lis5-11).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 `return` 语句是否有效，更新 *main.php* 脚本，如 [Listing 5-11](#lis5-11) 所示。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-11: Updating main.php to call print_tree() with an empty spacer string'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-11: 更新 *main.php* 来调用 `print_tree()` 并传入一个空的填充字符串'
- en: We set $spacer to an empty string rather than a slash before making our calls
    to print_stars(). The output of running the main script should now simply be NULL.
    The print_stars() function returns early each time it is called because $spacer
    is an empty string, so we no longer see our ASCII tree. Then again, we don’t see
    a fatal error either, because our return statement prevents us from calling str_pad()
    with an invalid argument. We still see NULL in the output, the result of the var_dump()
    call. This indicates that when a function encounters a return statement without
    a value, it returns NULL, just as it would if it didn’t have a return statement
    at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Calling Functions from Within Functions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s perfectly reasonable to call one function from within the body of another
    function. In fact, we’ve done it several times already, calling built-in PHP functions
    like str_repeat() and str_pad() inside our print_stars() function. It’s also possible,
    and in fact, quite common, to call your own custom functions from within other
    custom functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of the power of programming comes from breaking problems into smaller
    tasks. You write basic functions to tackle those small tasks and then write higher-level
    functions that combine the tasks to solve the larger problem. In the end, your
    main application script looks quite simple: you just call one or two functions.
    The trick is that those functions themselves call several other functions, and
    so on.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It took us six calls to our print_stars() function to generate an ASCII tree.
    Let’s move those six calls into another function, print_tree(). That way, every
    time we want to print a tree, all we need is one function call in our main script.
    Add the new print_tree() function to *my_functions.php* as shown in [Listing 5-12](#lis5-12).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-12: Adding the print_tree() function to my_functions.php'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We declare the print_tree() function after our previously declared print_stars()
    function. It requires a string parameter called $spacer. In the function body,
    we write our six original calls to print_stars(). Notice that $spacer, the parameter
    of the print_tree() function, is also acting as an argument when we call print_stars().
    This way, we can easily print trees with different padding characters around the
    asterisks just by changing the string we pass in when we call print_tree().
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: With this new function, we can now greatly simplify our main script. Update
    *main.php* as shown in [Listing 5-13](#lis5-13).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 5-13: Simplifying the main.php script with the print_tree() function'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading in the function declaration file, we call print_tree() twice
    to generate two trees. The first time we use a forward slash as the spacer, as
    before, and the second time we use a space character. Here’s the result:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our main script has accomplished with 2 calls to print_tree() what would have
    previously taken 12 calls to print_stars(). Of course, those calls to print_stars()
    are still happening, but we’ve hidden them inside the print_tree() definition,
    making our main script much tidier. You can begin to see the power of functions
    to organize code and promote reusability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主脚本通过调用两次`print_tree()`，完成了原本需要调用12次`print_stars()`的任务。当然，那些`print_stars()`的调用仍然存在，但我们将它们隐藏在`print_tree()`的定义中，使我们的主脚本变得更加简洁。你可以开始看到函数在组织代码和促进可重用性方面的强大作用。
- en: Functions with Multiple Return and Parameter Types
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回多个值和参数类型的函数
- en: For straightforward situations, you can usually write a function that does something
    and returns a value of a single type or that returns no value. Other times, however,
    you’ll want to make a function more reusable by allowing it to return values of
    different data types depending on the situation. Likewise, you might want a function’s
    parameters to accept values of different data types to ensure that your code can
    cope with input validation issues. *Nullable types* and *union types* offer elegant
    ways to permit multiple types, both for a function’s return value and its parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况，你通常可以编写一个执行某项任务并返回单一类型值或不返回任何值的函数。然而，其他时候，你可能希望通过允许函数根据情况返回不同数据类型的值来提高其可重用性。同样，你可能希望函数的参数能够接受不同数据类型的值，以确保代码能够应对输入验证问题。*可空类型*和*联合类型*提供了优雅的方法来允许多种类型，既适用于函数的返回值，也适用于函数的参数。
- en: Nullable Types
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可空类型
- en: 'It’s quite common to write functions that normally return one kind of value,
    such as a string or a number, but that sometimes return NULL instead. For example,
    a function that typically performs a calculation might return NULL if it receives
    invalid inputs, or a function that retrieves information from a database might
    return NULL if it’s unable to establish a database connection (we’ll see this
    in [Part VI](part6.xhtml) when we discuss databases). To allow for this, declare
    the function’s return type to be *nullable* by adding a question mark (?) immediately
    before the return type. For instance, placing : ?int at the end of the first line
    of a function declaration means that the function will return either NULL or an
    integer.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '编写通常返回一种类型值（如字符串或数字），但有时返回`NULL`的函数是非常常见的。例如，一个通常执行计算的函数，如果接收到无效输入，可能会返回`NULL`；或者一个从数据库中检索信息的函数，如果无法建立数据库连接，也可能返回`NULL`（我们将在[第六部分](part6.xhtml)讨论数据库时看到这一点）。为了实现这一点，可以通过在返回类型前立即添加问号（?）来声明函数的返回类型为*可空*。例如，在函数声明的第一行末尾添加`:
    ?int`意味着该函数将返回`NULL`或整数。'
- en: Let’s see this in action with a function that attempts to return the integer
    value of a spelled-out number (such as 1 instead of 'one'). If the function doesn’t
    recognize the input string, it will return NULL instead. Start a new project and
    create *my_functions.php* containing the contents of [Listing 5-14](#lis5-14).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个尝试返回拼写出来的数字的整数值的函数来看看它是如何工作的（例如返回1而不是'one'）。如果函数无法识别输入的字符串，它将返回`NULL`。开始一个新项目，创建包含[列表5-14](#lis5-14)内容的`my_functions.php`文件。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-14: A function that returns an integer or NULL'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-14：一个返回整数或`NULL`的函数
- en: We declare the string_to_int() function, using the nullable type ?int to indicate
    that the function will return either NULL or an integer ❶. The function takes
    in the string parameter $numberString. Its body is a single return statement that
    chooses a value to return by using a match expression. This is possible because
    match expressions evaluate to a single value. The expression has five clauses
    matching the strings 'one' through 'five' to the corresponding integer. A sixth
    clause sets the default case ❷, returning NULL if any other string is provided.
    In this way, the match expression returns an integer or NULL, just as the function’s
    nullable return type indicates.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了`string_to_int()`函数，使用可空类型`?int`来表示该函数将返回`NULL`或整数 ❶。该函数接收字符串参数`$numberString`。它的主体是一个单一的返回语句，通过使用`match`表达式选择要返回的值。这是可能的，因为`match`表达式的值总是一个单一的结果。该表达式有五个子句，将字符串'one'到'five'分别匹配到相应的整数。第六个子句设置了默认情况
    ❷，如果提供任何其他字符串，则返回`NULL`。通过这种方式，`match`表达式返回一个整数或`NULL`，就如同函数的可空返回类型所指示的那样。
- en: Now we’ll write a *main.php* file with a script that calls our function. When
    you call a function with a nullable return type, it’s important to test the return
    value, in case it’s NULL. [Listing 5-15](#lis5-15) shows how.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个 *main.php* 文件，其中包含一个调用我们函数的脚本。当你调用具有可空返回类型的函数时，测试返回值是否为 NULL 是很重要的。[清单
    5-15](#lis5-15) 显示了如何操作。
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 5-15: A main.php script calling the nullable-type string_to_int() function'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-15：一个调用可空类型 string_to_int() 函数的 main.php 脚本
- en: 'We assign string ''three'' as the value of the $text1 variable, then pass that
    variable to our string_to_int() function, storing the return value in $number1
    ❶. Next, we use an if...else statement to test whether the value in $number1 is
    empty (NULL) ❷. If so, we print a message stating that the string couldn’t be
    converted to an integer. Otherwise, we print a message showing the string and
    its corresponding integer. We then repeat the process with string ''onee''. Here’s
    the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字符串 'three' 赋值给变量 $text1，然后将该变量传递给 string_to_int() 函数，将返回值存储在 $number1 ❶
    中。接下来，我们使用 if...else 语句测试 $number1 中的值是否为空（NULL） ❷。如果是，我们打印一条消息，说明该字符串无法转换为整数。否则，我们打印一条显示字符串及其对应整数的消息。然后，我们重复这个过程，使用字符串
    'onee'。以下是输出：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that the function returns the integer 3 when the argument is the
    string 'three', but it returns NULL when the argument is the misspelled string
    'onee'. Declaring our string_to_int() function with a nullable return type gives
    us the flexibility to respond to this problematic input in a meaningful way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当参数是字符串 'three' 时，函数返回整数 3，但当参数是拼写错误的字符串 'onee' 时，它返回 NULL。通过将 string_to_int()
    函数声明为可空返回类型，我们可以灵活地以有意义的方式应对这种问题输入。
- en: Just as functions can have nullable return types, you can use the same question
    mark syntax to declare function parameters as nullable, meaning the parameter
    can be NULL or some other type. For example, the parameter list (?string $name)
    means that a function accepts a $name parameter that is either NULL or a string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数可以有可空返回类型一样，你也可以使用相同的问号语法来声明函数参数为可空类型，这意味着参数可以是 NULL 或其他类型。例如，参数列表 (?string
    $name) 意味着该函数接受一个 $name 参数，该参数可以是 NULL 或字符串。
- en: Rather than having to duplicate the if...else statement in our *main.php* script
    each time we call our string_to_int() function, as we did in [Listing 5-15](#lis5-15),
    we might take the function’s NULL or integer return value and pass it as an argument
    to another function to generate an appropriate message. That function therefore
    needs to be able to accept a parameter that may be NULL or an integer. [Listing
    5-16](#lis5-16) shows such a function named int_to_message(). Add the function
    to the end of your *my_functions.php* file*.*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要像在 [清单 5-15](#lis5-15) 中那样，每次调用 string_to_int() 函数时都重复编写 if...else 语句。我们可以将函数的
    NULL 或整数返回值作为参数传递给另一个函数，以生成适当的消息。因此，该函数需要能够接受一个可能为 NULL 或整数的参数。[清单 5-16](#lis5-16)
    显示了这样一个名为 int_to_message() 的函数。将该函数添加到你的 *my_functions.php* 文件的末尾。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-16: A function with a nullable type for the $number parameter'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-16：一个具有可空类型的 $number 参数的函数
- en: The signature for this function includes a single parameter called $number of
    nullable type ?int. This means that the argument provided to the function can
    be either NULL or an integer. The function body uses the if...else statement we
    had in our *main.php* script to return an appropriate message depending on which
    data type is passed in.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的签名包含一个名为 $number 的单一参数，其类型为可空的 ?int。这意味着传递给该函数的参数可以是 NULL 或整数。函数体使用了我们在
    *main.php* 脚本中写的 if...else 语句，根据传递的数据类型返回相应的消息。
- en: We can now greatly simplify our main script by removing the duplicated if...else
    statements and calling our new function instead. [Listing 5-17](#lis5-17) shows
    the updated script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过移除重复的 if...else 语句并改为调用我们的新函数，我们可以大大简化主脚本。[清单 5-17](#lis5-17) 显示了更新后的脚本。
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-17: Simplifying main.php with the int_to_message() function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-17：使用 int_to_message() 函数简化 main.php
- en: 'Notice that our main script is much simpler now that the logic for generating
    the message has been moved to a function. For each input, we follow a pattern
    of three basic statements: declaring a string ❶, storing the integer (or NULL)
    returned from calling string_to_int() with that string ❷, and printing the string
    returned by passing this integer or NULL value to the int_to_message() function
    ❸.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于生成消息的逻辑已经移到函数中，我们的主脚本现在变得更简洁了。对于每个输入，我们遵循三个基本语句的模式：声明一个字符串❶，存储调用`string_to_int()`函数时返回的整数（或NULL）❷，并打印通过将该整数或NULL值传递给`int_to_message()`函数而返回的字符串❸。
- en: If we really want to make our code even more succinct, we can put all three
    of those statements into a single line ❹, calling the string_to_int()function
    inside the parentheses when we call the int_to_message() function. This way, the
    former’s return value is passed directly as an argument to the latter, without
    the need for an intermediary variable. This choice is a matter of programming
    style. Personally, I prefer to use intermediate variables to prevent a single
    line of code from becoming too complex.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想让代码更加简洁，可以将这三条语句合并成一行❹，在调用`int_to_message()`函数时，将`string_to_int()`函数放在括号内。这样，前者的返回值就会直接作为参数传递给后者，而无需使用中介变量。这种做法属于编程风格的选择。就我个人而言，我更倾向于使用中介变量，以防止一行代码过于复杂。
- en: Union Types
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 联合类型
- en: If you want a function to be able to return a range of data types, declare its
    return value by using a *union type*. This is a list of the value’s possible data
    types, separated by vertical bars. For example, int|float indicates that a value
    could be an integer or a float. Union types can apply to function parameters as
    well as return values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望一个函数能够返回多种数据类型，可以使用*联合类型*来声明其返回值。这是一个值的可能数据类型的列表，类型之间用竖线分隔。例如，`int|float`表示一个值可以是整数或浮动值。联合类型既可以应用于函数参数，也可以应用于返回值。
- en: Nullable types are essentially a special category of union types, and their
    question mark syntax provides a convenient shorthand when one of the possible
    data types is NULL. The union type string|NULL is the same as the more concise
    nullable type ?string, for example. Union types are most useful when your code
    has multiple non-NULL types, like int|float, or when there are multiple non-NULL
    types plus NULL, like string|int|NULL, indicating the data type could be a string,
    an integer, or NULL. This couldn’t be expressed with nullable-type syntax, since
    you can’t mix a nullable type with others in a union by writing something like
    ?string|int. You also can’t include void as one of the types in the union.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型本质上是联合类型的一种特殊类别，其问号语法提供了当某种可能的数据类型为NULL时的简便写法。例如，联合类型`string|NULL`与更简洁的可空类型`?string`相同。联合类型在代码中有多个非NULL类型时特别有用，比如`int|float`，或者有多个非NULL类型加上NULL时，比如`string|int|NULL`，表示数据类型可能是字符串、整数或NULL。使用可空类型语法无法表达这种情况，因为你不能像写`?string|int`那样在联合类型中混合可空类型。你也不能在联合类型中包含`void`类型。
- en: To demonstrate union types, let’s modify our string_to_int() function into a
    string_to_number() function that can return an integer, a float, or NULL, depending
    on the string passed in. We’ll also update our int_to_message() function into
    a number_to_message() function that can take in an integer, a float, or NULL as
    a parameter. Update *my_functions.php* to match [Listing 5-18](#lis5-18).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示联合类型，我们将`string_to_int()`函数修改为`string_to_number()`函数，该函数根据传入的字符串返回整数、浮动值或NULL。我们还将`int_to_message()`函数更新为`number_to_message()`，该函数可以接受整数、浮动值或NULL作为参数。更新*my_functions.php*以匹配[示例
    5-18](#lis5-18)。
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 5-18: Using union types as function return values and parameters'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-18：使用联合类型作为函数的返回值和参数
- en: First, we declare string_to_number(), a revised version of our string_to_int()
    function. We use the union type int|float|null to indicate that the function will
    return an integer, a float, or NULL ❶. Just like string_to_int() previously, this
    function takes in a single string parameter. We add a new clause to the match
    statement in the function body, matching the string 'half' to the float value
    0.5 ❷, hence the need for the union type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明`string_to_number()`，它是我们`string_to_int()`函数的修订版。我们使用联合类型`int|float|null`来表示该函数将返回一个整数、浮动值或NULL❶。就像以前的`string_to_int()`一样，这个函数接受一个字符串参数。我们在函数体的`match`语句中增加了一个新的条件，将字符串'half'匹配为浮动值0.5❷，因此需要使用联合类型。
- en: Next, we declare number_to_message(), a revised version of int_to_message()
    that returns a string. This function takes in two parameters. The first, the string
    $text, will be the same as the string passed to our string_to_number() function.
    The second, $number, will be that function’s return value, and so it might be
    an integer, a float, or NULL. We therefore use the same int|float|NULL union type
    for the parameter ❸.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明 number_to_message()，它是 int_to_message() 的修订版本，返回一个字符串。这个函数接受两个参数。第一个参数，字符串
    $text，将与传递给我们的 string_to_number() 函数的字符串相同。第二个参数，$number，将是该函数的返回值，因此它可能是一个整数、一个浮点数或
    NULL。因此，我们对参数 ❸ 使用相同的 int|float|NULL 联合类型。
- en: In the function body, we first test whether $number contains an integer value
    ❹, in which case we return a message stating that $text is an integer. Next, we
    test whether $number contains a float value ❺, returning an appropriate message
    if it does. Finally, we return a message stating that $text couldn’t be converted
    to a number ❻. Execution wouldn’t get this far if either of the previous return
    statements was executed, so we know at this point that $number is neither an integer
    nor a float. We therefore don’t need to place this final return statement inside
    an else clause or another if statement, although we could.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们首先测试 $number 是否包含一个整数值 ❹，如果是，我们返回一条消息，说明 $text 是一个整数。接下来，我们测试 $number
    是否包含一个浮点数值 ❺，如果是，则返回一条适当的消息。最后，我们返回一条消息，说明 $text 无法转换为数字 ❻。如果之前的任何一个 return 语句被执行，执行就不会到达这一步，所以我们知道此时
    $number 既不是整数也不是浮点数。因此，我们不需要将这个最终的 return 语句放在一个 else 子句或另一个 if 语句中，尽管我们可以这样做。
- en: This choice is a matter of personal programming style. I like to end functions
    like this with an unconditional return statement, so I can clearly see the default
    to be returned. However, some programmers prefer to end the last if statement
    with an else clause as a way to communicate the default. The execution is the
    same either way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择是个人的编程风格问题。我喜欢像这样用一个无条件的 return 语句来结束函数，这样我可以清楚地看到要返回的默认值。然而，一些程序员更喜欢用一个
    else 子句来结束最后一个 if 语句，以此来传达默认值。无论哪种方式，执行结果都是一样的。
- en: Now let’s test our functions. Update your *main.php* script to match [Listing
    5-19](#lis5-19).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试一下我们的函数。更新你的 *main.php* 脚本以匹配 [清单 5-19](#lis5-19)。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 5-19: Calling functions with union type parameters and return values
    in main.php'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-19：在 main.php 中使用联合类型参数和返回值调用函数
- en: We call our string_to_number() function, passing in the string 'three', and
    store the result in the $number1 variable. Then we pass $number1 along to our
    number_to_message() function and print the message that it returns. This code
    should output the message 'three' as an integer = 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 string_to_number() 函数，传入字符串 'three'，并将结果存储在 $number1 变量中。然后我们将 $number1
    传递给我们的 number_to_message() 函数，并打印它返回的消息。这段代码应该输出消息 'three' as an integer = 3。
- en: Optional Parameters
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: If the value of a parameter will usually be the same each time you call a function,
    you can set a default value for that parameter when you declare the function.
    In effect, this makes the parameter optional. You’ll need to include an argument
    corresponding to that parameter only when you know you’ll want the value to be
    something other than the default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个参数的值在每次调用函数时通常都是相同的，你可以在声明函数时为该参数设置一个默认值。实际上，这使得该参数成为可选的。只有当你知道你希望该值与默认值不同时，你才需要包含一个与该参数对应的参数。
- en: 'Many of PHP’s built-in functions have optional parameters with default values.
    For example, PHP’s number_format() function, which takes in a float and converts
    it into a string, has several optional parameters controlling how the string will
    be formatted. Enter php -a at the command line to try out the following code in
    interactive mode:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的许多内置函数都有带有默认值的可选参数。例如，PHP 的 number_format() 函数，它接受一个浮点数并将其转换为字符串，有几个可选参数控制字符串的格式。在命令行输入
    php -a 以在交互模式下尝试以下代码：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The number_format() function’s first parameter is not optional; it’s the float
    that we want to format. By default, calling the function with just one argument
    ❶ returns a string version of the number with the decimal portion removed. When
    we add an integer as an optional second argument ❷, the function uses that integer
    to set the number of decimal places to include. We’ve used the value 2 to preserve
    two decimal places. By default, the decimal separator is represented with a period,
    but if we add a string as an optional third argument ❸, the function will use
    that string as the decimal separator instead. In this case, we’re using a comma,
    a common decimal separator in continental Europe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: number_format()函数的第一个参数是必需的，它是我们想要格式化的浮动数值。默认情况下，仅传递一个参数❶时，函数会返回去掉小数部分的数字字符串。当我们添加一个整数作为可选的第二个参数❷时，函数使用该整数来设置保留的小数位数。我们使用了2这个值来保留两位小数。默认情况下，小数分隔符使用句点，但如果我们添加一个字符串作为可选的第三个参数❸，则函数会使用该字符串作为小数分隔符。在这种情况下，我们使用逗号，这是欧洲大陆常见的小数分隔符。
- en: '[Listing 5-20](#lis5-20) shows the signature for the number_format() function,
    taken from the PHP online documentation, to illustrate how the default values
    for the parameters are declared.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-20](#lis5-20)显示了number_format()函数的签名，取自PHP在线文档，用于说明如何声明参数的默认值。'
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 5-20: The built-in number_format() function, including optional parameters
    with default values'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-20: 内置的number_format()函数，包括具有默认值的可选参数'
- en: First, notice that when you have a long list of parameters, you can spread them
    over several lines to make the code more readable. The function takes up to four
    parameters, but the second, third, and fourth all have default values assigned
    with the assignment operator (=) after the parameter name. For example, the second
    parameter, $decimals, has a default value of 0, so when we call number_format(1.2345)
    without providing a second argument, the function executes with the default value
    for $decimals and formats the number to include zero decimal places. Likewise,
    the $decimal_separator parameter has a period as its default value, and the $thousands_separator
    parameter has a comma.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，当你有一个长参数列表时，可以将它们分散在多行中，以使代码更具可读性。该函数最多接受四个参数，但第二、第三和第四个参数都使用赋值运算符（=）在参数名后面赋予了默认值。例如，第二个参数$decimals的默认值为0，因此当我们调用number_format(1.2345)而没有提供第二个参数时，函数将使用$decimals的默认值，并将数字格式化为没有小数位。同样，$decimal_separator参数的默认值为句点，而$thousands_separator参数的默认值为逗号。
- en: The order in which the parameters are declared is important. All mandatory parameters
    (those without default values) must be listed first, followed by the optional
    parameters. This is because the order of arguments when you call a function must
    match the order of the parameters. If you had an optional parameter followed by
    a mandatory one, and you omitted the optional parameter, there’d be no way to
    know that your first argument was meant to correspond to the second parameter.
    The only exception to this rule is if you use named arguments, as we’ll discuss
    later in the chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 参数声明的顺序很重要。所有必填参数（没有默认值的参数）必须先列出，后跟可选参数。这是因为调用函数时，参数的顺序必须与声明的顺序匹配。如果可选参数在必填参数之前，而你又省略了可选参数，那么就无法知道你的第一个参数是对应于第二个参数的。此规则的唯一例外是当你使用命名参数时，正如我们稍后在本章讨论的那样。
- en: Now that we’ve seen how optional parameters work, let’s add one to a custom
    function. We’ll revisit our which_is_smaller() function from earlier in the chapter
    and add an optional parameter controlling how the function behaves if the values
    passed in for comparison are the same. Return to the *my_functions.php* file for
    that project and update the script to match [Listing 5-21](#lis5-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可选参数的工作方式，让我们为一个自定义函数添加一个可选参数。我们将重新回顾本章前面提到的which_is_smaller()函数，并添加一个可选参数，用于控制当传入的比较值相等时函数的行为。返回到该项目的*my_functions.php*文件，并更新脚本以匹配[Listing
    5-21](#lis5-21)。
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-21: Updating the which_is_smaller() function to include an optional
    parameter'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-21: 更新which_is_smaller()函数以包含一个可选参数'
- en: We add a third parameter to our function, the Boolean $nullIfSame, and give
    it a default value of false ❶. Thanks to this default value, the function will
    typically return $n1 if $n1 and $n2 are found to be the same ❸. However, if the
    user overrides this default by passing true as the third argument when calling
    the function, NULL is returned instead ❷. To account for this possibility, we
    use the nullable type ?int to set the function’s return type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向函数中添加了第三个参数，布尔值$nullIfSame，并给它设置了默认值false ❶。由于这个默认值，当$n1和$n2被发现相等时，函数通常会返回$n1
    ❸。然而，如果用户在调用函数时传递true作为第三个参数来覆盖这个默认值，则会返回NULL ❷。为了考虑这种情况，我们使用可空类型?int来设置函数的返回类型。
- en: The sequence of if and return statements matters here. The code will get to
    if ($nullIfSame) ❷ only if $n1 and $n2 are equal. Since $nullIfSame is false by
    default, this condition will typically fail, so the final return $n1; will execute
    ❸. It’s only if the user has set $nullIfSame to true that the function returns
    NULL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里if和return语句的顺序非常重要。只有当$n1和$n2相等时，代码才会进入if ($nullIfSame) ❷。由于$nullIfSame默认是false，因此这个条件通常会失败，所以最终会执行return
    $n1; ❸。只有当用户将$nullIfSame设置为true时，函数才会返回NULL。
- en: Update the project’s *main.php* file as shown in [Listing 5-22](#lis5-22) to
    test the function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更新项目的*main.php*文件，如[清单5-22](#lis5-22)所示，以测试该功能。
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-22: Calling which_is_smaller() from main.php, with and without the
    optional parameter'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-22：在main.php中调用which_is_smaller()，带有和不带有可选参数
- en: 'We call out which_is_smaller() twice, using var_dump() to show the results.
    The first time we pass in 1 and 1 and leave out the optional argument, so $nullIfSame
    will be false by default. The second time, we add true as a third argument, overriding
    the default. Here’s the output of running the main script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用which_is_smaller()两次，使用var_dump()显示结果。第一次我们传入1和1，并省略可选参数，因此$nullIfSame将默认是false。第二次，我们添加了true作为第三个参数，覆盖了默认值。以下是运行主脚本时的输出：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first line indicates that the function followed the default behavior of
    returning 1 (the value of the first argument) when we omitted the optional argument.
    When we used the third argument to set $nullIfSame to true, however, the function
    returned NULL.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示函数遵循了默认行为，当我们省略可选参数时，返回1（第一个参数的值）。然而，当我们使用第三个参数将$nullIfSame设置为true时，函数返回NULL。
- en: Positional vs. Named Arguments
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位置参数与命名参数
- en: 'When you call a function, the PHP engine by default interprets the arguments
    *positionally*, matching them to the function’s parameters based on their order.
    However, you can also call a function by using *named arguments*: you explicitly
    pair an argument’s value with the name of the corresponding parameter. In this
    case, the order of arguments no longer matters. Named arguments are especially
    useful when a function has optional parameters.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，PHP引擎默认会*按位置*解释参数，依据它们的顺序将其与函数的参数匹配。然而，你也可以通过使用*命名参数*来调用函数：你显式地将参数的值与相应参数的名称配对。在这种情况下，参数的顺序就不再重要。命名参数在函数有可选参数时特别有用。
- en: 'To use named rather than positional arguments, you don’t have to change the
    function declaration in any way, although it becomes even more important to have
    meaningful parameter names. Instead, all you have to do is include the parameter
    name (minus the dollar sign) inside the parentheses when you call a function,
    followed by a colon (:) and the desired argument value. For example, to use a
    named argument to pass true as the value of the $nullIfSame parameter when calling
    our which_is_smaller() function, you would include nullIfSame: true in the argument
    list. The convention is to add a space after the colon.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用命名参数而非位置参数，你不需要以任何方式修改函数声明，尽管此时函数参数的名称变得更加重要。你需要做的只是，在调用函数时，在括号内包含参数名称（去掉美元符号），然后加上冒号(:)和所需的参数值。例如，要在调用which_is_smaller()函数时使用命名参数将true作为$nullIfSame参数的值传入，你应在参数列表中加入nullIfSame:
    true。约定是在冒号后加一个空格。'
- en: '[Listing 5-23](#lis5-23) shows an updated *main.php* file, adding an extra
    call to which_is_smaller() using named arguments.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单5-23](#lis5-23)显示了更新后的*main.php*文件，增加了一个使用命名参数调用which_is_smaller()的额外实例。'
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-23: Calling which_is_smaller() by using positional and named arguments'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-23：使用位置参数和命名参数调用which_is_smaller()
- en: 'The new call to which_is_smaller() ❶ is functionally equivalent to the previous
    call, but we use named arguments. As such, we’re able to list the arguments in
    a different order from the way the parameters were declared: first $nullIfSame,
    then $n1, then $n2. Here’s the result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 新的which_is_smaller() ❶调用在功能上与之前的调用等效，但我们使用了命名参数。因此，我们能够按不同于参数声明顺序的顺序列出参数：首先是$nullIfSame，然后是$n1，最后是$n2。以下是结果：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last two lines of output are both NULL, indicating the last two function
    calls achieved the same result using positional and named arguments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后两行都是NULL，表示最后两个函数调用通过位置参数和命名参数达成了相同的结果。
- en: 'In this example, each function call used all positional or all named arguments,
    but you can also mix both styles of arguments in the same function call. In that
    case, the positional arguments must come first, in the same sequence as the function
    declaration, followed by the named arguments in whatever sequence you wish. Consider
    this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个函数调用要么完全使用位置参数，要么完全使用命名参数，但你也可以在同一次函数调用中混合使用两种参数方式。在这种情况下，位置参数必须排在前面，顺序与函数声明中的顺序一致，然后是你选择的顺序排列的命名参数。考虑以下例子：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here the first argument, 5, doesn’t have a name. PHP will therefore treat it
    positionally and match it to the first parameter declared, which is $n1. The remaining
    arguments are named and so can appear in any order. By contrast, here’s another
    call to the function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个参数5没有名称。因此，PHP会按照位置来处理它，并将其匹配到声明的第一个参数$n1。剩下的参数是有名称的，因此可以按任意顺序出现。相比之下，这是另一个调用该函数的例子：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time we’ve started with a named argument for $nullIfSame. Then we have
    an unnamed argument, 5, presumably intended for the $n1 parameter. The PHP engine
    will have no way of knowing this, however, since we started with a named argument,
    and so this function call will trigger an error.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们首先用了命名参数$nullIfSame。然后我们使用了一个没有名称的参数5，可能是用来传递$n1参数的。然而，由于我们一开始就用了命名参数，PHP引擎无法识别这一点，因此这个函数调用会触发一个错误。
- en: Skipped Parameters
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳过的参数
- en: When a function has multiple optional parameters, you can use named arguments
    to set just the optional parameters that you want while skipping the rest. This
    works because the named arguments free you from adhering to the order of the parameters.
    Any parameters you skip will take on their default values. To illustrate, let’s
    create a function that prints customizable greetings. Start a new project and
    create *my_functions.php* to match [Listing 5-24](#lis5-24).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个可选参数时，你可以使用命名参数仅设置你想要的可选参数，同时跳过其余的参数。这之所以有效，是因为命名参数让你不必遵循参数的顺序。任何跳过的参数将使用默认值。为了说明这一点，我们来创建一个打印自定义问候语的函数。创建一个新项目，并创建*my_functions.php*，使其符合[列表
    5-24](#lis5-24)。
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-24: A greet() function with two optional parameters'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-24：一个带有两个可选参数的greet()函数
- en: We declare the greet() function as void, since it prints out a message without
    returning a value. The function has a required string parameter $name, as well
    as two optional parameters with default values, $greeting and $hasPhD. The body
    of the function is an if statement that outputs the values of $greeting and $name,
    inserting the title Dr. in between if parameter $hasPhD is true ❶.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将greet()函数声明为void，因为它输出一条消息，但不返回任何值。该函数有一个必需的字符串参数$name，以及两个带默认值的可选参数$greeting和$hasPhD。函数体是一个if语句，它输出$greeting和$name的值，如果$hasPhD参数为真，则在两者之间插入标题Dr.
    ❶。
- en: Now we’ll look at a few ways to call the greet() function. Create *main.php*
    containing the code shown in [Listing 5-25](#lis5-25).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看几种调用greet()函数的方法。创建一个包含[列表 5-25](#lis5-25)中代码的*main.php*。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 5-25: A main script calling greet() with skipped parameters'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-25：一个主脚本调用greet()，并跳过参数
- en: The first time we call greet(), we pass just the string 'Matt' as an argument.
    We don’t use named arguments, so this will be matched positionally to the $name
    parameter. The other parameters will use their default values, resulting in the
    message Good morning, Matt.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用greet()时，我们只传递字符串'Matt'作为参数。我们没有使用命名参数，因此这个参数会按位置匹配到$name参数。其他参数会使用默认值，结果输出的消息是“Good
    morning, Matt”。
- en: 'The second time we call greet(), we use the positional argument ''Matt'' and
    the named argument hasPhD: true. Notice that $hasPhD is the third parameter in
    the function declaration; we’ve skipped over the second parameter! This is perfectly
    fine. The parameter we skipped, $message, has a default value, and thanks to our
    use of a named argument, the PHP engine will know unambiguously which provided
    arguments match which function parameters. We should get the message Good morning,
    Dr. Matt as a result.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '第二次调用greet()时，我们使用位置参数''Matt''和命名参数hasPhD: true。请注意，`$hasPhD`是函数声明中的第三个参数；我们跳过了第二个参数！这是完全没问题的。我们跳过的参数`$message`有一个默认值，感谢我们使用命名参数，PHP引擎会清楚地知道哪些提供的参数与哪些函数参数匹配。最终我们应该得到消息：Good
    morning, Dr. Matt。'
- en: 'Here’s the output of running the *main.php* script:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行*main.php*脚本的输出：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output is just as we expect. Thanks to the combination of default parameter
    values and named arguments, we are able to skip the $message parameter without
    issue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出正如我们所预期的那样。由于默认参数值和命名参数的结合，我们能够顺利跳过`$message`参数。
- en: Pass-by-Value vs. Pass-by-Reference
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值传递与引用传递
- en: 'By default, PHP functions match arguments to parameters by using a *pass-by-value*
    approach: the values of the arguments are copied and assigned (passed) to the
    appropriate parameters, which are created as temporary variables limited to the
    scope of the function. In this way, if the values of any parameters are manipulated
    while the function is executing, those changes will have no effect on any values
    outside the function itself. After all, the function is working with copies of
    the original values.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP函数使用*值传递*的方法将参数与参数匹配：参数的值会被复制并赋值（传递）给适当的参数，这些参数在函数的作用域内作为临时变量存在。通过这种方式，如果在函数执行过程中修改了任何参数的值，这些更改将不会对函数外部的任何值产生影响。毕竟，函数是处理原始值的副本。
- en: 'Another approach is *pass-by-reference*: instead of receiving copies, the function
    parameters are passed references to the original variables themselves. In this
    way, if a variable is passed as an argument to a function, the function can permanently
    change the value of that variable. To indicate a pass-by-reference parameter,
    place an ampersand (&) immediately before the parameter name when you’re declaring
    the function.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是*引用传递*：函数参数传递的是指向原始变量本身的引用，而不是副本。通过这种方式，如果一个变量作为参数传递给函数，函数可以永久改变该变量的值。为了指示引用传递参数，在声明函数时，请在参数名之前立即放置一个“&”符号。
- en: I don’t typically recommend using pass-by-reference parameters; in fact, I can’t
    think of a single one I’ve written in the last 20 years. Allowing functions to
    change the variables passed to them makes programs more complex and therefore
    harder to understand, test, and debug. Still, it’s important to be familiar with
    the concept, since you might encounter pass-by-reference parameters in other people’s
    code, including in third-party libraries you might want to use for your own projects.
    Calling a function with pass-by-reference parameters without knowing how they
    work could lead to unintended results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不推荐使用引用传递参数；事实上，在过去20年里，我无法想到任何我写过的引用传递参数。允许函数修改传递给它们的变量会使程序变得更加复杂，从而更难理解、测试和调试。尽管如此，熟悉这一概念仍然很重要，因为你可能会在别人编写的代码中遇到引用传递参数，包括在你可能希望在自己项目中使用的第三方库中。不了解如何使用引用传递参数就调用函数，可能会导致意外的结果。
- en: '> NOTE'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*In some programming languages, programmers use several pass-by-reference parameters
    as a way for a function to “return” multiple values without the need for* return
    *statements. There are better ways to do this in modern PHP, however, such as
    returning an array (see [Chapter 7](chapter7.xhtml)) or an object (see [Part V](part5.xhtml)).*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些编程语言中，程序员使用多个引用传递参数，作为函数“返回”多个值的一种方式，而无需使用*return*语句。然而，在现代PHP中有更好的方法，例如返回一个数组（参见[第7章](chapter7.xhtml)）或一个对象（参见[第V部分](part5.xhtml)）。*'
- en: To illustrate the difference between pass-by-value and pass-by-reference parameters,
    and to show why the latter are often best avoided, we’ll create two versions of
    a function that calculates someone’s future age. Start a new project and create
    *my_functions.php* with the contents of [Listing 5-26](#lis5-26).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明值传递和引用传递参数之间的区别，并展示为什么后者通常最好避免，我们将创建一个计算某人未来年龄的函数的两个版本。开始一个新项目并创建包含[清单5-26](#lis5-26)内容的*my_functions.php*。
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 5-26: A pass-by-value version of future_age()'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-26：按值传递的future_age()版本
- en: Here we declare a function named future_age(). It features an integer parameter
    $age declared in the usual way, so this will be a normal pass-by-value parameter.
    The function is declared void since no value is to be returned. In the body of
    the function, we add 1 to $age and print out a message containing the result.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为future_age()的函数。它具有一个整数参数$age，按通常方式声明，因此这是一个正常的值传递参数。由于不需要返回任何值，函数被声明为void。在函数体内，我们将$age加1，并打印出包含结果的消息。
- en: Now create a main script in *main.php* containing the code shown in [Listing
    5-27](#lis5-27).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在*main.php*中创建一个主脚本，包含[清单 5-27](#lis5-27)中显示的代码。
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-27: Testing the pass-by-value version of future_age()'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-27：测试按值传递的future_age()版本
- en: 'We assign the $currentAge variable an integer value of 20. Then we print out
    a message showing the value of this variable. Next, we call our future_age() function,
    passing $currentAge as an argument. We then print out another message showing
    the value of the variable. This gives us a look at the value of $currentAge before
    and after the function call. Here’s the result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为$currentAge变量赋值为整数20。然后我们打印出显示该变量值的消息。接着，我们调用我们的future_age()函数，并将$currentAge作为参数传递。然后我们再打印出另一条消息，显示变量的值。这让我们可以查看函数调用前后$currentAge的值。以下是结果：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first and last lines of output are the same, indicating that calling future_age()
    has no effect on the value of the $currentAge variable. In fact, when the function
    is called, a local variable $age is created within the scope of the function,
    and the value of $currentAge is copied into it. This way, when the function adds
    1 to $age, it does so without changing the value of $currentAge. That’s how pass-by-value
    parameters work: they don’t have any influence outside the scope of the function
    itself.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行和最后一行是相同的，表明调用future_age()对$currentAge变量的值没有影响。实际上，当函数被调用时，会在函数的作用域内创建一个局部变量$age，并将$currentAge的值复制到其中。这样，当函数将$age加1时，它是在不改变$currentAge值的情况下进行的。这就是值传递参数的工作方式：它们不会对函数外部的作用域产生任何影响。
- en: Now let’s modify our future_age() function to use a pass-by-reference parameter
    and see what difference that makes. Update your *my_functions.php* file as shown
    in [Listing 5-28](#lis5-28).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的future_age()函数，改为使用按引用传递的参数，看看这会有什么不同。更新你的*my_functions.php*文件，如[清单
    5-28](#lis5-28)所示。
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-28: A pass-by-reference version of future_age()'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-28：按引用传递的future_age()版本
- en: 'The only change here is adding an ampersand (&) before the parameter name,
    indicating $age is a pass-by-reference parameter. As a result, $age will no longer
    be a local variable containing a copy of the value in the variable passed as an
    argument when the function is called. Rather, $age will be a reference to that
    variable, so any changes made to $age will also be made to that variable. To prove
    it, run your *main.php* script again. This time you should see the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的变化是，在参数名称前加上了一个&符号，表示$age是按引用传递的参数。因此，$age将不再是一个局部变量，包含调用函数时传入参数的值的副本。相反，$age将成为该变量的引用，因此对$age所做的任何更改也将反映到该变量上。为了验证这一点，再次运行你的*main.php*脚本。这次你应该会看到以下输出：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that adding 1 to the $age parameter within the function also adds 1
    to the $currentAge variable outside the function. Unless the user’s birthday occurred
    in the instant between the function call and the final print statement, this probably
    isn’t what we want. This illustrates the danger of using pass-by-reference parameters:
    they can change the value of variables that are normally outside the scope of
    a function.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在函数内部对$age参数加1也会使得函数外部的$currentAge变量加1。除非用户的生日发生在函数调用和最终打印语句之间的那一瞬间，否则这可能不是我们想要的。这说明了使用按引用传递参数的危险：它们可能会改变通常在函数作用域之外的变量值。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve explored how to promote code reusability by declaring
    and calling functions, named sequences of code that accomplish a particular task.
    You practiced declaring functions in a separate.p*hp* file and then loading them
    into your main application file with require_once, allowing you to write concise,
    well-organized scripts. You saw how return statements allow functions to send
    values back to the calling script while also providing a mechanism to terminate
    a function early, and you explored how nullable and union types give functions
    the flexibility to take in or output values of various data types.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过声明和调用函数来促进代码的可重用性，函数是完成特定任务的一系列命名代码。你练习了在独立的.p*hp*文件中声明函数，然后通过
    require_once 将其加载到主应用程序文件中，从而编写简洁、结构良好的脚本。你看到返回语句如何允许函数将值返回给调用脚本，同时也提供了一种提前终止函数的机制，并且你探索了如何通过可空和联合类型使函数能够灵活地接受或输出各种数据类型的值。
- en: You learned about the difference between parameters (the variables used within
    a function) and arguments (the values passed to those variables when you call
    a function). You saw how to make parameters optional by giving them a default
    value, and how to use named arguments to pass in values in any order or even skip
    parameters. Finally, you learned about the difference between pass-by-value and
    pass-by-reference parameters, in the rare event you want a function to be able
    to update variables outside its own scope.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了参数（函数内使用的变量）和实参（调用函数时传递给这些变量的值）之间的区别。你看到如何通过为参数设置默认值使其变为可选参数，以及如何使用命名参数按照任意顺序传入值，甚至可以跳过某些参数。最后，你了解了值传递和引用传递参数之间的区别，在你希望函数能够更新其作用域外的变量时，这是一个罕见的情况。
- en: Exercises
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create a project with separate *main.php* and *file2.php* scripts. The
    *file2.php* script should print out the string '456'. In your *main.php* script,
    first print out '123', then read in and execute *file2.php*, then print out '789'.
    The overall output should be 123456789, but the middle 456 has been printed from
    *file2.php*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个项目，其中包含独立的*main.php*和*file2.php*脚本。*file2.php*脚本应该打印出字符串 '456'。在你的*main.php*脚本中，首先打印出
    '123'，然后读取并执行 *file2.php*，接着打印出 '789'。最终输出应该是 123456789，但中间的 456 是从 *file2.php*
    打印出来的。
- en: '2.   Write a project declaring a which_is_larger() function that returns the
    larger of two integers. Your *main.php* script should read in and execute the
    file declaring your function, and then print out the results of calling the function
    with the following arguments:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   编写一个项目，声明一个 which_is_larger() 函数，该函数返回两个整数中的较大者。你的*main.php*脚本应当读取并执行声明该函数的文件，然后打印出以下参数传入函数的结果：
- en: 4 and 5
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 4 和 5
- en: 21 and 19
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 21 和 19
- en: 3 and 3
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 3 和 3
- en: What happens in the last case, where the parameters are the same?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况发生了什么，当参数相同时？
- en: 3.   Modify your which_is_larger() function to accept either integers or floats,
    and to return an integer, a float, or NULL if both numbers are the same.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   修改你的 which_is_larger() 函数，使其能够接受整数或浮点数，并在两个数字相同的情况下返回整数、浮点数或 NULL。
- en: '4.   Create a file *my_functions.php* that declares a void function to print
    out the first letter of your name in ASCII art style. This function should have
    two parameters, one ($character) a string setting the character to use for making
    the art, and the second ($spacer) a string setting the character to fill in the
    gaps. Assign suitable default values to each parameter. For example, since the
    first character of my name is M, my function might be capital_m(string $character
    = ''M'', string $spacer = '' ''), and it might provide the following output when
    called with no arguments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   创建一个 *my_functions.php* 文件，声明一个无返回值的函数，用于打印出你名字的首字母的 ASCII 艺术风格。此函数应有两个参数，一个（$character）为字符串，设置用于制作艺术作品的字符，另一个（$spacer）为字符串，设置用于填充空白的字符。为每个参数指定合适的默认值。例如，由于我名字的第一个字母是
    M，我的函数可能是 capital_m(string $character = 'M', string $spacer = ' ')，如果没有传入任何参数，它可能会提供如下输出：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, write a *main.php* script to call your function with no arguments (using
    both default values). Then use named arguments to call the function two more times,
    once providing just the main character, and then providing just the spacer character.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个 *main.php* 脚本，调用你的函数且不传入任何参数（使用默认值）。然后使用命名参数再次调用该函数两次，一次只传入主字符，另一次只传入填充字符。
