- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SETTING
    UP THE DOCKER ENVIRONMENT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this part of the book, you’ll build a full-stack application from scratch
    by using the knowledge you’ve acquired so far. While previous chapters explained
    parts of the technology stack, the remaining chapters focus on the code in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the application you’ll build and walks you through configuring
    the environment using Docker. While I recommend reading previous chapters before
    you start writing code, the only real requirement is that you have Docker installed
    and running before moving on. Consult [Chapter 10](chapter10.xhtml) for instructions
    on doing so.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download the complete source code for the Food Finder application
    at* [http://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/downloads<wbr>/food<wbr>-finder](http://www.usemodernfullstack.dev/downloads/food-finder)
    *and a ZIP file with only the required assets from* [http://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/downloads<wbr>/assets](http://www.usemodernfullstack.dev/downloads/assets)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Food Finder Application</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Food Finder application shows a list of restaurants and their locations.
    The user can click these to see additional details about each location. In addition,
    they can log in to the app with their GitHub accounts by using OAuth so that they
    can maintain a wish list of locations.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, we’ll write this simple single-page application in TypeScript.
    After setting up the local environment, we’ll build the backend and middleware
    with Next.js, Mongoose, and MongoDB, which we’ll seed with initial data. Then
    we’ll add GraphQL to expose an API layer through which we can access a user’s
    wish list. To build the frontend, we’ll use our knowledge of React components,
    Next.js pages, and routing. We’ll also add an OAuth authorization flow with *next-auth*
    to let users log in with GitHub. Finally, we’ll write automated tests with Jest
    to verify the integrity and stability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Building the Local Environment with
    Docker</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker decouples the development environment from our local machine. We’ll use
    it to create self-contained services for each part of our application. In the
    *docker-compose* file, we’ll add one service for the backend, which provides the
    MongoDB database, and a second to run the Next.js application hosting the frontend
    and the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: To start the development, create a new empty folder, *code*. This folder will
    serve as the application’s root and contain all the code for the Food Finder application.
    Later in this chapter, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp>
    helper command to add files to it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create an empty *docker-compose.yml* file and a *.docker* folder in this
    root folder. In the file, we will define the two services for our environment
    and store the seed data we need to create the container.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Backend Container</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The backend container provides nothing but the app’s MongoDB instance. For this
    reason, we can use the official MongoDB image, which Docker can download automatically,
    from the Docker registry without creating a custom Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Seeding the Database</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We want MongoDB to begin with a prefilled database that contains a valid set
    of initial datasets. This process is called seeding the database, and we can automate
    it by copying the seeding script *seed-mongodb.js* into the container’s */docker-entrypoint-initdb.d/*
    directory on startup. The MongoDB image executes the scripts in this folder against
    the database defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_INITDB_DATABASE</samp>
    environment variable if there is no data in the container’s */data/db* directory
    on startup.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder, *foodfinder-backend*, in the *.docker* folder, and then
    copy into the newly created folder the *seed-mongodb.js* file from the *assets.zip*
    file you downloaded earlier. The seed file’s content should look similar to [Listing
    11-1](chapter11.xhtml#Lis11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: The seed-mongodb.js file'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the script interacts directly with a collection in the MongoDB
    instance that we’ll set up in the next section. We use MongoDB’s <samp class="SANS_TheSansMonoCd_W5Regular_11">insert</samp>
    method to fill the database’s <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    collection with the documents. Note that we are working with the *native* MongoDB
    driver to insert the documents instead of using Mongoose. We do so because Mongoose
    is not installed on the default MongoDB Docker image, and inserting the documents
    is a relatively simple task. Although we do not use Mongoose for seeding the database,
    the documents we insert need to match the schema we define with Mongoose later.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Backend Service</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can now define the backend service in the Docker setup. Add the code from
    [Listing 11-2](chapter11.xhtml#Lis11-2) into the empty *docker-compose.yml* file
    we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: The docker-compose.yml file with the backend service'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the container’s name so that we can easily reference it later.
    As discussed earlier, we use the latest version of the official MongoDB image
    and specify that this container should always be restarted if it stops. Next,
    we use the environment variables to define the collections we’ll use with MongoDB.
    We define two of those: <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_NAME</samp>
    points to the collection we’ll use with Mongoose, and <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_INITDB_DATABASE</samp>
    points to the seed script. The scripts in */docker-entrypoint-initdb.d/* use this
    latter collection by default.'
  prefs: []
  type: TYPE_NORMAL
- en: We want the script to populate our application’s database, so we set both variables
    to the same name, <samp class="SANS_TheSansMonoCd_W5Regular_11">foodfinder</samp>,
    and thus we have a prefilled database for our Mongoose model.
  prefs: []
  type: TYPE_NORMAL
- en: Then we map and expose the container’s internal port 27017 to the host’s port
    27017 so that the MongoDB instance is accessible to the application at *mongodb://backend:27017/foodfinder*.
    Notice that the connection string contains the service name, the port, and the
    database. Later, we store this connection string in the environment variables
    and use it to connect to the database from the middleware. Finally, we map and
    copy the seed script to the setup location and save the database data from */data/db*
    into the Docker volume *mongodb_data_container*. Because we want to split the
    string across two lines, we need to wrap it in double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>)
    according to the YAML conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now complete the Docker setup with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output shows us that the Docker daemon successfully created the <samp class="SANS_TheSansMonoCd_W5Regular_11">foodfinder-backend</samp>
    container and that the seeding script was executed during startup. Instead of
    going through the hassle of installing and maintaining MongoDB locally or finding
    a free or low-cost cloud instance, we’ve added MongoDB to our project with just
    a few lines of code in the *docker -compose* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the container with CRTL-C and remove it with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose down</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add the frontend container.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Frontend Container</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll create the containerized infrastructure for the frontend and middleware.
    Our approach will involve using <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp>
    to scaffold the Next.js application, as we did in [Chapter 5](chapter5.xhtml),
    relying on the official Node.js Docker image to decouple the application from
    any local Node.js installation.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll execute all Node.js-related commands inside this container, we technically
    don’t even need Node.js installed on our local machine; nor must we make sure
    the Node.js versions we use comply with Next.js’s requirements. Also, npm might
    install packages that are optimized for the operating system on which it is running,
    so by using npm inside the container, we ensure that npm installs the correct
    versions for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, we’ll want Docker to synchronize the Node.js *modules* folder to
    our local system. This will allow our IDE to automatically use the installed dependencies,
    such as the TypeScript compiler and ESLint. Let’s start by creating a minimal
    Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Application Service</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We add the combined frontend and middleware service to our Docker setup by placing
    the code from [Listing 11-3](chapter11.xhtml#Lis11-3) into the <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp>
    property of the project’s *docker-compose.yml* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: The docker-compose.yml file with the backend and application
    service'
  prefs: []
  type: TYPE_NORMAL
- en: The service for the Food Finder application follows the same structure as the
    service for the backend. First we set the container’s name. Then we define the
    image to be used for this particular service. While the backend service used the
    official MongoDB image, we now use the official Node.js image with the current
    LTS version running on Alpine Linux, a lightweight Linux distribution that requires
    significantly less memory than a Debian-based image.
  prefs: []
  type: TYPE_NORMAL
- en: We then expose and map port 3000, making the application available on *http://localhost:3000*,
    and map the local application’s code directory into the container. Next, we set
    the working directory to the *code* directory. We specify that our container requires
    a running backend service, because the Next.js application will need a working
    connection to the MongoDB instance. In addition, we add environment variables.
    In particular, <samp class="SANS_TheSansMonoCd_W5Regular_11">chokidar</samp> supports
    hot-reloading for the Next.js code. Finally, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> makes the
    container provide an interactive shell instead of shutting down. We’ll need the
    shell to execute commands inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Installing Next.js</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With both services in place, we can now install Next.js inside the container.
    To do so, we need to start the container with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Compare this command line output with the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> output. You should see that the application container started
    successfully and that it runs a Node.js interactive shell.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker exec</samp>
    to execute commands inside the running container. Doing so has two main advantages.
    First, we don’t need any particular version of Node.js (or any version at all)
    on our local machine. Second, we run the Node.js application and npm commands
    on the Node.js Linux Alpine image so that the dependencies will be optimized for
    Alpine instead of for our host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run npm commands inside the container, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    exec -it foodfinder-application</samp> followed by the command to run. The Docker
    daemon connects to the terminal inside the container and executes the provided
    command in the application container’s working directory, */home/node/code*, which
    we set previously. Let’s install the Next.js application there using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> command discussed in [Chapter
    5](chapter5.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We set the project name to *foodfinder-application* and accept the defaults.
    The rest of the output should look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the scaffolding is done, we can start the Next.js application with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>. If you visit
    *http://localhost:3000* in your browser, you should see the familiar Next.js splash
    screen. The *foodfinder-application* folder should be mapped into the local *code*
    folder, so we can edit the Next.js-related files locally.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adjusting the Application
    Service for Restarts</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Currently, connecting to the application container requires running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    exec</samp> after each restart through <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> and then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> manually. Let’s make two minor adjustments in our application service
    to allow for a more convenient setup. Modify the file to match [Listing 11-4](chapter11.xhtml#Lis11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: The docker-compose.yml file to start Next.js automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change the <samp class="SANS_TheSansMonoCd_W5Regular_11">working_dir</samp>
    property. Because we’re working with Next.js, we set it to the Next.js application’s
    root folder, */home/node/code/foodfinder-application*, which contains the *package.json*
    file. Then we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp>
    property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run
    dev</samp>. With these two modifications, each <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> call should instantly start the Next.js application. Try starting
    the containers with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose
    up</samp>; the console output should show that Next.js runs and that it’s available
    at *http://localhost:3000*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you visit *http://localhost:3000* in your browser, you should see the Next.js
    splash screen without having to start the Next.js application manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, if you’re using Linux or macOS without being the administrator or
    root user, you’ll need to adjust the application service and the startup command.
    Because the Docker daemon runs as a root user by default, all files it creates
    require root privileges. Your regular user doesn’t have those and cannot access
    those files. To avoid these possible issues, modify your setup so that the Docker
    daemon transfers the ownership to your user. Start by adding the code in [Listing
    11-5](chapter11.xhtml#Lis11-5) to the application service in the *docker-compose*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: The docker-compose.yml file with the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp>
    property'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> property
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">application</samp> service
    and use the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MY_USER</samp>
    as the property’s value. Then we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose</samp> commands so that, on startup, we add the current user’s user ID
    and group ID to this environment variable. Instead of a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose up</samp> call, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> helper program
    to save the user ID and group ID in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">userid:groupid</samp>
    to our environment variable, which the *docker-compose* file then picks up. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-u</samp> flag returns the user
    ID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> flag returns
    the group ID.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve set up our local development environment with Docker containers. With
    the *docker-compose.yml* file we created in this chapter, we decoupled the application
    development from our local host system. Now we can switch our host systems and,
    at the same time, ensure that the Food Finder application always runs with the
    same Node.js version. In addition, we added a container running our MongoDB server,
    to which we’ll connect in the next chapter when we implement our application’s
    middleware.
  prefs: []
  type: TYPE_NORMAL
