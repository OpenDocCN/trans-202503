- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TypeScript is a programming language that adds static typing to the dynamically
    typed JavaScript language. It’s a strict syntactic superset of JavaScript, which
    means that all existing JavaScript is valid TypeScript. By contrast, TypeScript
    is not valid JavaScript, because it supplies additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to the pitfalls of working with JavaScript’s
    dynamic types and explain how TypeScript’s static typing helps catch errors early,
    increasing the stability of your code. Full-stack developers have embraced TypeScript:
    it was the runner-up in the *most wanted* category of a recent Stack Overflow
    Developer Survey, and 78 percent of participants in a *State of JS* survey reported
    using it. According to [*https://<wbr>builtwith<wbr>.com*](https://builtwith.com),
    TypeScript underlies 7 percent of the top 10,000 sites.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the essential and advanced TypeScript concepts necessary for building
    full-stack applications. Along the way, you’ll get to know the language’s most
    common configuration options, its most important types, and how and when to use
    TypeScript’s static typing features.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Benefits of TypeScript</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript makes working with JavaScript’s type system less error prone, as
    its compiler helps us see type errors instantly. Because JavaScript is *dynamically*
    typed, you don’t need to specify a variable’s type when declaring it. As soon
    as the runtime executes the script, it checks these types based on usage. However,
    this means that errors resulting from invalid types (for example, calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> on a variable that holds
    a number instead of an array) won’t be discovered until runtime, at which point
    the complete program fails.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being dynamically typed, JavaScript is also *weakly* typed, which
    means it implicitly converts variables to their most plausible values. [Listing
    3-1](chapter3.xhtml#Lis3-1) shows an implicit conversion from a number to a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: Implicit conversion from a number to a string in JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: We declare three variables, assigning the first a string, the second a numeric
    value, and the third the result of using the arithmetic plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator to add the number to itself. We then log the result of this sum operation
    and its type to the console. If you executed this code, you would see that the
    value is numeric and that the runtime assigned a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>
    to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the same operator again, but instead of adding a numeric value
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> variable, we
    add a string to it. You should see that the logged value is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, as you might have
    expected. Moreover, the variable’s assigned type has changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    This happens because the runtime environment needs to handle an impossible task:
    adding a number and a string. It solves this issue by implicitly converting the
    number to a string, then using the plus operator to concatenate the two strings.
    Without TypeScript, we notice this conversion only when we run the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Another common problem caused by untyped variables relates to function and API
    *contracts*, or the agreements about what the code accepts and returns. When a
    function takes a parameter, it implicitly expects a parameter of a specific type.
    But without TypeScript, there is no way to ensure that the parameter type is correct.
    The same problem exists for the function’s return value. To illustrate this, [Listing
    3-2](chapter3.xhtml#Lis3-2) changes the code from [Listing 3-1](chapter3.xhtml#Lis3-1)
    so that it uses a function to calculate the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: A function that could return an invalid type due to implicit type
    conversion'
  prefs: []
  type: TYPE_NORMAL
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function
    takes two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and as before, adds the
    two values. Like in [Listing 3-1](chapter3.xhtml#Lis3-1), as soon as we pass a
    number and a string as parameters, the function returns a string instead of a
    number. Our function might expect both parameters to be numbers, but we can’t
    verify this without manually checking the type by using logic similar to that
    in [Listing 3-3](chapter3.xhtml#Lis3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: The refactored type-safe function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp>
    function of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp> object
    to verify that the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are integers. The first
    call of the function, in which we pass it two integers, should calculate the result
    as expected. The second call, in which we pass the function an integer and a string,
    looks fine in the editor. However, when we run the code, the runtime environment
    should throw the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid type:
    a parameter is not an integer</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two main concerns with manually checking the types. First, it adds
    a lot of noise to our code, as we need to check for all possible types every time
    we work with function or API contracts, such as when we accept a parameter or
    return a value. Second, we’re not notified of issues during development. To see
    the errors in dynamically typed languages, we need to execute the code so that
    the interpreter can inform us about errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike dynamically typed languages, *statically* typed languages perform type
    checks on the code compilation, before runtime. The TypeScript Compiler (TSC)
    handles this chore; it can run in the background of our code editor or IDE and
    instantly report all errors based on invalid type usage. Therefore, you can catch
    errors and see each variable’s assigned types and data structures early.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t set up instant feedback like that, running your code through
    TSC is necessary before it can be used, which ensures that these kinds of errors
    are caught earlier than they otherwise would be. The ability to check for these
    errors is one of the most important benefits of using TypeScript over JavaScript.
    We will discuss how to benefit from type annotations and when to use them in “Type
    Annotations” on page 38.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up TypeScript</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript’s syntax isn’t valid JavaScript, so a regular JavaScript runtime
    environment can’t execute it. To run TypeScript in Node.js or a browser, we first
    need to use TSC to convert it to regular, backward-compatible JavaScript. We then
    execute the resulting JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being called a compiler, TSC doesn’t actually compile TypeScript into
    JavaScript. Instead, it *transpiles* it. The difference lies in the level of abstraction.
    A compiler creates low-level code, while a transpiler is a source-to-source compiler
    that produces equivalent source code in a language of roughly the same abstraction.
    For example, you could transpile ES.Next to legacy JavaScript or Python 2 to Python
    3\. (That said, the terms *transpiling* and *compiling* are often used interchangeably.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to converting TypeScript to JavaScript, TSC checks your code for
    type errors and verifies the contracts between your functions. The transpiling
    and type-checking happen independently, and the TSC produces JavaScript regardless
    of the types you defined. TypeScript errors are merely warnings emitted during
    the build. They won’t stop the transpiling step as long as the JavaScript itself
    doesn’t produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: The use of TypeScript won’t affect your code’s performance. The compiler removes
    types and type operations during the transpilation step, essentially stripping
    all TypeScript syntax from the actual JavaScript code. Therefore, they can’t affect
    the runtime or the size of the final code. TypeScript is consequently no slower
    than JavaScript, although the transpilation can take some time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installation in Node.js</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re using Node.js, you should define TypeScript and all type definitions
    as development dependencies with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> flag in your project’s
    *package.json* file. There is no need to install TypeScript globally. Just add
    TypeScript directly to your project with this npm command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript files use the extension *.ts*, and because TypeScript is a superset
    of JavaScript, all valid JavaScript code is automatically valid TypeScript code.
    Therefore, you can rename your *.js* files to *.ts* and instantly use the static
    type checker with your existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *tsconfig.json* file defines TSC configuration options. We’ll cover the most
    important ones in the next section. For now, run the following command to generate
    a new file with the default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: TSC looks for this file in the current path and all parent directories. The
    optional <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> flag points the
    TypeScript compiler directly to the file. TSC then reads configuration information
    from this file and treats its folder as TypeScript’s root directory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you want to follow this chapter’s examples without creating a dedicated
    project, you can run code in the online playground at* [https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/play](https://www.typescriptlang.org/play)
    *instead of installing TypeScript locally.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The tsconfig.json
    File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Take a look at the basic structure of a *tsconfig.json* file. The content of
    the generated file depends on your installed TypeScript version, and there are
    around 100 configuration properties, but for most projects, only the following
    few are relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> option is a
    string that configures the path to another similar configuration file. Usually,
    this property extends a preset you used as a template with minor, project-specific
    tweaks. It works similarly to class-based inheritance in object-oriented programming.
    The preset overrides the base configuration, and the configuration’s key-value
    pairs overwrite the preset. The example shown here uses the recommended configuration
    file for TypeScript to override the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> field
    configures the transpiling step. We list its options in [Appendix A](appendix-A.xhtml).
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> is
    an array of strings that specifies the patterns or filenames to include for transpiling.
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">exclude</samp> is
    an array of strings that specifies patterns or filenames to exclude. Keep in mind
    that TSC applies these patterns on the list of files found with the included pattern.
    Usually, we don’t need to include or exclude files, as our whole project will
    consist of TypeScript code. Hence, we can leave the arrays empty.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Feedback
    with TypeScript</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most modern code editors have support for TypeScript, and they show us the errors
    generated by TSC directly inside the code. Remember the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function we used to explain how TypeScript verifies function contracts? [Figure
    3-1](chapter3.xhtml#fig3-1) is a screenshot from Visual Studio Code highlighting
    the type error and hinting at the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-1: Working with TypeScript
    in Visual Studio Code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use any code editor or IDE you’d like to write your TypeScript code,
    though one that shows dynamic feedback like this is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Annotations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A type annotation is an optional way to explicitly tell the runtime environment
    which types to expect. You add them following this schema: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable:
    type</samp>. The following example shows a version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function in which we type both parameters as numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Some developers tend to add types to everything in their code, and by doing
    so, they add noise that makes the code less readable. This antipattern, called
    *over-typing*, stems from a false understanding of how type annotations should
    work. The TypeScript compiler infers types from usage. Therefore, you don’t need
    to explicitly type everything. Instead, the code editor runs TSC in the background
    and leverages the results to display the inferred type information and compiler
    errors as you saw in the “Dynamic Feedback with TypeScript” section.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, type annotations are a way to ensure that code honors the API contracts.
    There are three scenarios in which you’ll want to verify the contract, and only
    one of them is especially important. The first scenario, upon a variable’s declaration,
    is usually not recommended. The second, annotating the return value of a function,
    is optional, whereas the third scenario, annotating a function’s parameters, is
    essential. We’ll now take a look at all three of these cases in detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Variable</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most obvious place to type a variable is upon an assignment or declaration.
    [Listing 3-4](chapter3.xhtml#Lis3-4) demonstrates this by explicitly typing the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> as a string
    and then assigning it a string value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: Over-typing during the variable’s declaration'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, however, this is a form of over-typing, as you could instead
    leverage the compiler’s type inference. [Listing 3-5](chapter3.xhtml#Lis3-5) shows
    the alternative pattern of using type inference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-5: Inferring the variable’s type based on its value'
  prefs: []
  type: TYPE_NORMAL
- en: Because TSC automatically infers the type of this variable, the code editor
    should show the type information when you hover over the variable. Without the
    explicit annotation, we have a much cleaner syntax and avoid the noise that the
    redundant type declaration adds to the code. This improves code readability, which
    is why this kind of over-typing is usually to be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Return
    Value</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although TypeScript can infer a function’s return type, you’ll usually want
    to annotate it explicitly. This code pattern ensures that the function’s contract
    is honored, as the compiler shows implementation errors where the function is
    defined instead of where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use type annotations in this situation is that, as a programmer,
    you must explicitly define what a function does. By clarifying the function’s
    input and output types, you’ll gain a better understanding of what you actually
    want the function to do. [Listing 3-6](chapter3.xhtml#Lis3-6) shows you how to
    declare a function’s return type upon declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: Typing a function’s return value upon declaration'
  prefs: []
  type: TYPE_NORMAL
- en: We create a function that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable we declared earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable has the inferred string type. Hence, the function returns a string. Our
    type definition explicitly sets the function’s return type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Function’s
    Parameters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s essential to annotate the parameters of a function, because TypeScript
    doesn’t have enough information to infer function parameters in most cases. By
    typing these parameters, you’re telling the compiler to check the types when you
    call the function and pass it arguments. Take a look at [Listing 3-7](chapter3.xhtml#Lis3-7)
    to see this pattern in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: Typing a function’s parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of declaring the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable as a constant inside the function, we want the returned value to be dynamic.
    Therefore, we modify the function to accept a parameter and return it immediately.
    We then call the function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    constant as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Good TypeScript code avoids noise and relies on inferring type annotations.
    It always annotates a function’s parameters and opts for annotated return values
    but never annotates local variables.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can use TypeScript and its annotations, you need to know what types
    are available to you. One of TypeScript’s main benefits is that it enables you
    to declare any of JavaScript’s primitive types explicitly. In addition, TypeScript
    adds its own types, the most important of which are <samp class="SANS_TheSansMonoCd_W5Regular_11">unions</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tuples</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. You can also define
    custom types and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Primitive JavaScript
    Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has five primitive types: strings, numbers, Booleans, undefined,
    and null. Everything else in the language is considered an object. [Listing 3-8](chapter3.xhtml#Lis3-8)
    shows the syntax for defining variables of these primitive JavaScript types with
    additional TypeScript type annotations. (Remember that, most of the time, you
    can just rely on the compiler’s type inference in this situation.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-8: JavaScript’s primitive types with TypeScript’s type annotations'
  prefs: []
  type: TYPE_NORMAL
- en: First we define a string variable and a Boolean with the TypeScript annotations.
    These are identical to strings and Booleans in JavaScript. Then we define two
    numbers. Like JavaScript, TypeScript uses a single generic type for numbers, without
    differentiating between integers and floating points. Finally, we look at TypeScript’s
    null and undefined types. These behave the same as JavaScript’s primitive types
    of the same name. *Null* refers to a value that either is empty or doesn’t exist,
    and it indicates the intentional absence of a value. In contrast, *undefined*
    indicates the unintentional absence of a value. We did not assign a value in [Listing
    3-5](chapter3.xhtml#Lis3-5) for the undefined type, because we don’t know it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The union Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few additional types you should know about, because the more precise
    your type annotations are, the more helpful you’ll find TSC to be. TypeScript
    introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type
    to the JavaScript ecosystem. *Unions* are variables or parameters that can have
    more than one data type. [Listing 3-9](chapter3.xhtml#Lis3-9) shows an example
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type that can
    be a string or a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-9: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">union</samp>
    type'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-type
    variable that can contain either a string or a number, but nothing else. As soon
    as we assign a Boolean variable, TSC throws an error, and the IDE shows the message
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type 'boolean' is not assignable
    to type 'string | number'</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: While you might find <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    types useful for annotating function parameters and arrays that can contain different
    types, you should use them sparingly and avoid them whenever possible. This is
    because, before working with <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-typed
    items, you need to perform additional manual type checks; otherwise, they could
    cause errors. For example, if you iterated over an array of strings or numbers
    and then added all items, you would first need to convert all strings to numbers.
    Otherwise, JavaScript would implicitly convert the numbers to strings, as shown
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The array Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript provides a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    type that offers array functions similar to JavaScript’s array. However, take
    a close look at the syntax for typing the array, shown in [Listing 3-10](chapter3.xhtml#Lis3-10).
    You’ll notice that the type of the array depends on the type of the array items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-10: Typed arrays'
  prefs: []
  type: TYPE_NORMAL
- en: First we define an array without specifying the type of its items. Unfortunately,
    what seems to be a definition of a generic array leads to issues down the road.
    As soon as we try to add a value, TSC throws the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument
    of type 'number' is not assignable to parameter of type 'never'</samp>, because
    the array is not typed.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need to type the items in the array. Therefore, we create an array,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">numberArray</samp>, in which each
    item has the type of number. Now we can add numeric values to the array without
    running into errors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The object Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    type is the same as JavaScript’s object. Although you can define the properties’
    types for TSC to type-check, the compiler can’t ensure the order of the properties.
    Nonetheless, it typechecks them, as shown in [Listing 3-11](chapter3.xhtml#Lis3-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-11: Typed objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we define an object with three properties: two that take a string and
    another that takes a number. Then we try to assign a number to the property <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> annotated as a string.
    Now TSC notifies us with an error explaining that we assigned a value of the wrong
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, usually, you should avoid typing objects inline, as in this example.
    Instead, it is a best practice to create a custom type, which is reusable and
    avoids cluttering our code, enhancing its readability. We discuss how to create
    and use them in “Custom Types and Interfaces” on page 44.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tuple</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another common type that TypeScript adds to JavaScript is the <samp class="SANS_TheSansMonoCd_W5Regular_11">tuple</samp>
    type. Shown in [Listing 3-12](chapter3.xhtml#Lis3-12), *tuples* are arrays with
    a specified number of typed items. TypeScript’s tuples are similar to those you
    might have encountered in programming languages such as Python and C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-12: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tuple</samp>
    type'
  prefs: []
  type: TYPE_NORMAL
- en: We define two tuples. In both, the first array item is a string, and the second
    is a number. If the type, order, or number of items added to the tuple differs
    from the tuple’s declaration, TSC throws an error. Here the first assignment is
    acceptable, whereas the second one throws two errors indicating a mismatch in
    types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">any</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type is
    generic, meaning it can take any value, and you should avoid using it. As you
    can see in [Listing 3-13](chapter3.xhtml#Lis3-13), it accepts all values without
    throwing an error, which defeats the purpose of static typing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-13: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  prefs: []
  type: TYPE_NORMAL
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> might seem like
    an easy choice, and it is tempting to rely on it as an escape hatch. Avoid this
    at all costs. When you pass <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    as a value to, say, a function, you break the contract you specified in the function
    declaration, and when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    to define the contract, there effectively isn’t one.
  prefs: []
  type: TYPE_NORMAL
- en: To view a scenario in which using the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type causes problems, take a look at [Listing 3-14](chapter3.xhtml#Lis3-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-14: Problems caused by the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function, which adds two numbers. When we pass two numeric values, we receive
    the expected output of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
    In a previous example, we typed the parameters as numbers, thus preventing the
    use of invalid types as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    instead of a number and pass a string to the function, TSC doesn’t throw an error.
    JavaScript implicitly converts the number to a string and returns an unexpected
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>. We saw this
    behavior at the beginning of the chapter, in the untyped version of the function.
    As you can see, using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    is the same as using no types at all.
  prefs: []
  type: TYPE_NORMAL
- en: While convenient, the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type masks your bugs during programming and hides your type designs, rendering
    type-checking useless. It also prevents your IDE from displaying errors and invalid
    types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type
    is the opposite of <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>: it
    indicates no type at all. Its only use case is to annotate the return value of
    a function that shouldn’t have one, as shown in [Listing 3-15](chapter3.xhtml#Lis3-15).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-15: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">void</samp>
    type'
  prefs: []
  type: TYPE_NORMAL
- en: The custom log function we define here passes a parameter to the console. It
    doesn’t return anything, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the return type.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about TypeScript types and other important details of the language,
    take a look at *The TypeScript Handbook* at [*https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/docs<wbr>/handbook<wbr>/intro<wbr>.html*](https://www.typescriptlang.org/docs/handbook/intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Custom Types and Interfaces</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous sections introduced you to enough TypeScript to begin using the
    language. However, you’ll find it helpful to know a few more advanced concepts.
    This section shows you how to create custom types and use untyped third-party
    libraries in your TypeScript code. You’ll also learn when to create a new type
    and use a custom interface.
  prefs: []
  type: TYPE_NORMAL
- en: While working with TypeScript, remember that a TypeScript file *without* top-level
    imports or exports is not a module; therefore, it runs in the *global* scope.
    Consequently, all of its declarations are accessible in other modules. By contrast,
    a TypeScript file *with* top-level imports or exports is its own module, and all
    declarations are limited to the *module* scope, meaning they’re available in the
    scope of this module only.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript lets you define custom types by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    keyword. Custom types are a great way to simplify your code. To see how, take
    a second look at the code shown back in [Listing 3-8](chapter3.xhtml#Lis3-8),
    when you created a typed object. Now consider [Listing 3-16](chapter3.xhtml#Lis3-16),
    which optimizes the code with a custom type definition. You should find it much
    cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-16: Custom types for typed objects with TypeScript'
  prefs: []
  type: TYPE_NORMAL
- en: We create a custom type, <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> keyword. Note
    that the overall syntax is similar to that used to define an object; we use the
    equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) to assign
    the definition to the custom type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom type has two required properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>. In addition,
    it has an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> property,
    as indicated by the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>).
    Now when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">getWeatherDetail</samp>
    function, we can annotate the parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetail</samp>,
    as an object with a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>.
    Using this technique, we avoid using inline annotations and can reuse our custom
    type later, such as to annotate the return type of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Interfaces</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to types, TypeScript has interfaces. However, the difference between
    a type and an interface is blurry. You can freely decide which one to use, so
    long as you follow a convention in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we consider a *type* definition to answer the question, “Which type
    is this data?” A possible answer might be a union or a tuple. An *interface* is
    a way to describe the shape of some data, such as the properties of an object.
    It answers the question, “Which properties does this object have?” The most practical
    difference is that, unlike an interface, we cannot directly modify a type after
    we’ve declared it. For an in-depth look at the distinction, consult *The TypeScript
    Handbook*.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, use an interface to define a new object or the method of
    an object. More generally, consider using interfaces over types, as they provide
    more precise error messages. A classic React use case for interfaces is to define
    the properties of a specific component. [Listing 3-17](chapter3.xhtml#Lis3-17)
    shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to create a new interface to replace the type in [Listing 3-16](chapter3.xhtml#Lis3-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-17: Custom interfaces for TypeScript functions'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to define a new interface. Unlike a custom type’s definition, an interface
    definition does not use the equal sign to assign the interface’s properties to
    its name. We then use the custom interface to type the properties object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherComponent</samp>,
    which returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Type Declaration
    Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use custom types universally, you can define them in *type declaration files*,
    which have the *.d.ts* extension. Unlike regular TypeScript files with the *.ts*
    or *.tsx* extension, type declaration files shouldn’t contain any implementation
    code. Instead, TSC uses these type definitions to understand custom types and
    perform type checks. They aren’t transpiled to JavaScript and are never part of
    the executed script.
  prefs: []
  type: TYPE_NORMAL
- en: Type declaration files prove useful when you find yourself working with external
    code bases. Often, third-party libraries aren’t written in TypeScript. Therefore,
    they don’t provide type declaration files for their code bases. Luckily, the DefinitelyTyped
    repository at [*http://<wbr>definitelytyped<wbr>.github<wbr>.io*](http://definitelytyped.github.io)
    provides type declaration files for more than 7,000 libraries. Use these files
    to add TypeScript support to these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Type declaration files are collected under the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope in npm. This scope holds all the declarations from DefinitelyTyped. Hence,
    they are easy to find and are grouped next to each other in your *package.json*
    file. All type declaration files from the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope should be considered development dependencies of your project. Hence, we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--save-dev</samp> flag on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install</samp> command to
    add them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-18](chapter3.xhtml#Lis3-18) shows a minimal example of a type declaration
    file that exports a type and interface for an API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-18: Defining custom types and interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: Save these definitions in a file called *custom.d.ts* in your root directory.
    TSC should automatically load these definitions. You can now use the types and
    interfaces from the file in your TypeScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3: Extend Express.js with
    TypeScript</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use your new knowledge of TypeScript to rewrite the Express.js server
    you created in Exercises 1 and 2\. In addition to adding type annotations, we’ll
    add a new route to the server by using custom types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Begin by adding TypeScript to the project following the steps described in
    “Setting Up TypeScript” on page 36. Next, because Express.js isn’t typed, add
    type definitions from DefinitelyTyped to your project by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Your *package.json* file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you can create configuration and type declaration files for the project.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the tsconfig.json
    File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Either create a new *tsconfig.json* file in the *sample-express* folder, next
    to the *index.ts* file, or open the one you created earlier. Then add or replace
    its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We configure TypeScript for our simple Express.js server, which requires only
    a few settings. We use ES.Next modules for our TypeScript code, and because we
    want to keep them after transpiling the TypeScript to JavaScript, we set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">module</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>. The *express* package
    is a CommonJS module. Therefore, we need to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">esModuleInterop</samp>
    option and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">moduleResolution</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>. Finally, we use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">noImplicitAny</samp> option
    to disallow the implicit use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type and require explicit typing. [Appendix A](appendix-A.xhtml) describes these
    configuration options in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our server, we’ll follow a simple rule of thumb: every time we use an object,
    we should consider adding a custom type or interface to our project. If the object
    is a function parameter, we’ll create a custom interface. If we use this particular
    object more than once, we’ll create a custom type.'
  prefs: []
  type: TYPE_NORMAL
- en: To define the custom types for this sample project, we create a file *custom.d.ts*
    next to the *index.ts* file in the *sample-express* folder and add the code from
    [Listing 3-19](chapter3.xhtml#Lis3-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-19: The custom.d.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We create two custom types and an interface. One defines the response items
    of the asynchronous API call. The other type and the interface are similar to
    examples shown earlier in this chapter. They are necessary for the new weather
    route we will create shortly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the routes.ts File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we must add type annotations to our server code. Rename the *routes.js*
    file in the *sample-express* folder to *routes.ts* to enable the TSC for this
    file. You should instantly see the errors and warnings appear in your editor.
    Take some time to look at these and then adjust the contents to match the code
    in [Listing 3-20](chapter3.xhtml#Lis3-20). We’ve bolded all type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-20: The typed routes.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: Following the principle discussed in “Type Annotations” on page 38, we annotate
    only a function’s parameters and return types. We also annotate local variables
    only when their types cannot be inferred, as when converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    response to JSON. Here we need to explicitly type the variable with our custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> and cast
    the conversion’s return value as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>s.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the listing, we create the functions for the additional weather
    route. We use the custom interface for typing both functions’ parameters and the
    custom type for their return types. In this basic example, the query function
    returns mostly static data, except the ZIP code, which it takes from the passed
    parameters. A regular implementation would query a database with the ZIP code
    and retrieve actual data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the new route for the weather endpoint to the <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp>
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the index.ts File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rename the file *index.js* in the *sample-express* folder to *index.ts* and
    adjust the code to match [Listing 3-20](chapter3.xhtml#Lis3-20). In addition to
    the necessary type annotations, create a new endpoint and follow the TypeScript
    convention to prefix unused parameters with an underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>),
    shown in [Listing 3-21](chapter3.xhtml#Lis3-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-21: The typed index.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: First we import the new weather route from the available routes and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    types from the *express* package. These are all named exports. Thus, we use curly
    brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: Then, following best practices, we add code annotations and, at the same time,
    prefix the unused <samp class="SANS_TheSansMonoCd_W5Regular_11">req</samp> parameters
    with an underscore. TSC will follow the convention of functional programming languages
    by ignoring these parameters. The *api/names* entry point is marked as an async
    function, so it needs to return a value wrapped in a promise. Hence, nothing is
    returned, and we return <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the promise’s value.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines of code, we create an additional route for a new */api/weather/:zipcode*
    endpoint. The colon (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>) creates
    a parameter on the request’s <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>
    object. We retrieve the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params .zipcode</samp>
    and pass it down to the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeWeather</samp>
    function. Note that there is no underscore on the request parameter this time.
    Finally, we use the same function as before to start the Express.js server and
    listen to port 3000.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transpiling and Running
    the Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To transpile the code with the TypeScript compiler to JavaScript, run TSC with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'TSC generates two new files, *index.js* and *routes.js*, from the TypeScript
    files. Start the server from your command line with the regular Node.js call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now visit *http://localhost:3000/api/weather/12345* in your browser. You should
    see the weather details with the ZIP code 12345, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-2: Browser response
    from the Node.js web server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Success! You wrote your first TypeScript application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter taught you what you need to know about TypeScript to create a full-stack
    application. We set up TypeScript and TSC in a new project, then discussed its
    most important configuration options. Next, you learned to use TypeScript efficiently,
    leveraging type-annotation inference to avoid over-typing.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed primitive and advanced built-in types and how to create custom
    types and interfaces. Finally, you used your new knowledge to add TypeScript to
    the Express.js server built in previous exercises and refactored the code with
    type annotations, custom types, and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to become a TypeScript expert, I recommend *The TypeScript Handbook*
    and the tutorials at [*https://<wbr>www<wbr>.typescripttutorial<wbr>.net*](https://www.typescripttutorial.net).
    In the next chapter, you’ll get to know React, a declarative JavaScript library
    for building user interfaces.
  prefs: []
  type: TYPE_NORMAL
