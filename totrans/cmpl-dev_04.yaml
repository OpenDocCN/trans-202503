- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: TypeScript is a programming language that adds static typing to the dynamically
    typed JavaScript language. It’s a strict syntactic superset of JavaScript, which
    means that all existing JavaScript is valid TypeScript. By contrast, TypeScript
    is not valid JavaScript, because it supplies additional features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一种为动态类型的 JavaScript 语言添加静态类型的编程语言。它是 JavaScript 的严格语法超集，这意味着所有现有的
    JavaScript 都是有效的 TypeScript。相比之下，TypeScript 不是有效的 JavaScript，因为它提供了额外的功能。
- en: 'This chapter will introduce you to the pitfalls of working with JavaScript’s
    dynamic types and explain how TypeScript’s static typing helps catch errors early,
    increasing the stability of your code. Full-stack developers have embraced TypeScript:
    it was the runner-up in the *most wanted* category of a recent Stack Overflow
    Developer Survey, and 78 percent of participants in a *State of JS* survey reported
    using it. According to [*https://<wbr>builtwith<wbr>.com*](https://builtwith.com),
    TypeScript underlies 7 percent of the top 10,000 sites.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用 JavaScript 动态类型时可能遇到的陷阱，并解释 TypeScript 的静态类型如何帮助尽早捕捉错误，从而提高代码的稳定性。全栈开发者已广泛采用
    TypeScript：它在最近的 Stack Overflow 开发者调查中获得了 *最受欢迎* 类别的亚军，并且在 *State of JS* 调查中有
    78% 的参与者报告使用它。根据 [*https://<wbr>builtwith<wbr>.com*](https://builtwith.com)，TypeScript
    是 7% 的前 10,000 个网站的基础。
- en: We’ll cover the essential and advanced TypeScript concepts necessary for building
    full-stack applications. Along the way, you’ll get to know the language’s most
    common configuration options, its most important types, and how and when to use
    TypeScript’s static typing features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖构建全栈应用程序所需的基础和高级 TypeScript 概念。在此过程中，你将了解语言中最常见的配置选项、最重要的类型，以及如何以及何时使用
    TypeScript 的静态类型特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Benefits of TypeScript</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TypeScript 的优势</samp>
- en: TypeScript makes working with JavaScript’s type system less error prone, as
    its compiler helps us see type errors instantly. Because JavaScript is *dynamically*
    typed, you don’t need to specify a variable’s type when declaring it. As soon
    as the runtime executes the script, it checks these types based on usage. However,
    this means that errors resulting from invalid types (for example, calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> on a variable that holds
    a number instead of an array) won’t be discovered until runtime, at which point
    the complete program fails.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 使得使用 JavaScript 的类型系统时更少出错，因为它的编译器帮助我们立即看到类型错误。由于 JavaScript 是 *动态类型*，你在声明变量时不需要指定类型。只要运行时执行脚本，它就会根据使用情况检查这些类型。然而，这也意味着由于无效类型（例如，在一个存储数字而不是数组的变量上调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>）导致的错误，直到运行时才会被发现，而此时整个程序将失败。
- en: In addition to being dynamically typed, JavaScript is also *weakly* typed, which
    means it implicitly converts variables to their most plausible values. [Listing
    3-1](chapter3.xhtml#Lis3-1) shows an implicit conversion from a number to a string.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是动态类型的，JavaScript 还是 *弱类型*，这意味着它会隐式地将变量转换为最合理的值。[列表 3-1](chapter3.xhtml#Lis3-1)
    显示了从数字到字符串的隐式转换。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Implicit conversion from a number to a string in JavaScript'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：JavaScript 中的隐式数字到字符串的转换
- en: We declare three variables, assigning the first a string, the second a numeric
    value, and the third the result of using the arithmetic plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator to add the number to itself. We then log the result of this sum operation
    and its type to the console. If you executed this code, you would see that the
    value is numeric and that the runtime assigned a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>
    to the variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了三个变量，首先为第一个变量赋值一个字符串，第二个变量赋值一个数字，第三个变量则是使用算术加法（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）运算符将数字与自身相加的结果。然后，我们将这个加法运算的结果及其类型输出到控制台。如果你执行了这段代码，你会看到值是数字类型，并且运行时将类型指定为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>。
- en: 'Next, we use the same operator again, but instead of adding a numeric value
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> variable, we
    add a string to it. You should see that the logged value is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, as you might have
    expected. Moreover, the variable’s assigned type has changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    This happens because the runtime environment needs to handle an impossible task:
    adding a number and a string. It solves this issue by implicitly converting the
    number to a string, then using the plus operator to concatenate the two strings.
    Without TypeScript, we notice this conversion only when we run the code.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用相同的运算符，但这次我们不是将数值添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>变量中，而是将一个字符串添加到它上面。你应该看到日志中的值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">11</samp>，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，这是你可能预期的结果。此外，变量的赋值类型已变为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。这发生是因为运行时环境需要处理一个不可能完成的任务：将数字与字符串相加。它通过隐式将数字转换为字符串，然后使用加号运算符将两个字符串连接起来，来解决这个问题。如果没有
    TypeScript，我们只有在运行代码时才会注意到这种转换。
- en: Another common problem caused by untyped variables relates to function and API
    *contracts*, or the agreements about what the code accepts and returns. When a
    function takes a parameter, it implicitly expects a parameter of a specific type.
    But without TypeScript, there is no way to ensure that the parameter type is correct.
    The same problem exists for the function’s return value. To illustrate this, [Listing
    3-2](chapter3.xhtml#Lis3-2) changes the code from [Listing 3-1](chapter3.xhtml#Lis3-1)
    so that it uses a function to calculate the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个由未指定类型的变量引起的常见问题与函数和 API *契约*（即代码接受和返回内容的约定）有关。当函数接受一个参数时，它隐式地期望该参数是特定类型的。但是没有
    TypeScript，就无法确保参数类型正确。函数返回值也存在相同的问题。为了说明这一点，[列表 3-2](chapter3.xhtml#Lis3-2)将[列表
    3-1](chapter3.xhtml#Lis3-1)中的代码进行了修改，使其使用一个函数来计算<sup class="SANS_TheSansMonoCd_W5Regular_11">result</sup>变量的值。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: A function that could return an invalid type due to implicit type
    conversion'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-2：由于隐式类型转换可能返回无效类型的函数
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function
    takes two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and as before, adds the
    two values. Like in [Listing 3-1](chapter3.xhtml#Lis3-1), as soon as we pass a
    number and a string as parameters, the function returns a string instead of a
    number. Our function might expect both parameters to be numbers, but we can’t
    verify this without manually checking the type by using logic similar to that
    in [Listing 3-3](chapter3.xhtml#Lis3-3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 新的<samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>函数接受两个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，并像之前一样将两个值相加。就像在[列表
    3-1](chapter3.xhtml#Lis3-1)中一样，一旦我们将一个数字和一个字符串作为参数传递，函数就会返回一个字符串而不是数字。我们的函数可能期望两个参数都是数字，但在没有
    TypeScript 的情况下，我们无法在不手动检查类型的情况下验证这一点，检查逻辑类似于[列表 3-3](chapter3.xhtml#Lis3-3)中的代码。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: The refactored type-safe function'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-3：重构后的类型安全函数
- en: 'Here we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp>
    function of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp> object
    to verify that the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are integers. The first
    call of the function, in which we pass it two integers, should calculate the result
    as expected. The second call, in which we pass the function an integer and a string,
    looks fine in the editor. However, when we run the code, the runtime environment
    should throw the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid type:
    a parameter is not an integer</samp>.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们使用原生的<samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp>函数来验证参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>是否为整数。第一次调用该函数时，我们传递两个整数，应该能按预期计算出结果。第二次调用时，我们传递了一个整数和一个字符串，在编辑器中看起来没问题。然而，当我们运行代码时，运行时环境应抛出错误<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Invalid type: a parameter is not an integer</samp>。'
- en: There are two main concerns with manually checking the types. First, it adds
    a lot of noise to our code, as we need to check for all possible types every time
    we work with function or API contracts, such as when we accept a parameter or
    return a value. Second, we’re not notified of issues during development. To see
    the errors in dynamically typed languages, we need to execute the code so that
    the interpreter can inform us about errors at runtime.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 手动检查类型有两个主要问题。首先，它会为我们的代码添加大量噪音，因为每次处理函数或 API 契约时，我们都需要检查所有可能的类型，例如在接收参数或返回值时。其次，我们在开发过程中无法收到问题的通知。为了查看动态类型语言中的错误，我们需要执行代码，以便解释器在运行时通知我们错误。
- en: Unlike dynamically typed languages, *statically* typed languages perform type
    checks on the code compilation, before runtime. The TypeScript Compiler (TSC)
    handles this chore; it can run in the background of our code editor or IDE and
    instantly report all errors based on invalid type usage. Therefore, you can catch
    errors and see each variable’s assigned types and data structures early.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态类型语言不同，*静态*类型语言在代码编译时进行类型检查，而不是在运行时。TypeScript 编译器（TSC）负责这个任务；它可以在我们的代码编辑器或集成开发环境（IDE）的后台运行，并根据无效的类型使用即时报告所有错误。因此，你可以提前捕获错误，并查看每个变量的赋值类型和数据结构。
- en: Even if you don’t set up instant feedback like that, running your code through
    TSC is necessary before it can be used, which ensures that these kinds of errors
    are caught earlier than they otherwise would be. The ability to check for these
    errors is one of the most important benefits of using TypeScript over JavaScript.
    We will discuss how to benefit from type annotations and when to use them in “Type
    Annotations” on page 38.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有设置即时反馈，在将代码投入使用之前运行 TSC 也是必要的，这样可以确保这些类型错误在它们可能出现之前就被捕获。检查这些错误的能力是使用 TypeScript
    相较于 JavaScript 的最大优势之一。我们将在第 38 页的“类型注解”中讨论如何利用类型注解以及何时使用它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up TypeScript</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置 TypeScript</samp>
- en: TypeScript’s syntax isn’t valid JavaScript, so a regular JavaScript runtime
    environment can’t execute it. To run TypeScript in Node.js or a browser, we first
    need to use TSC to convert it to regular, backward-compatible JavaScript. We then
    execute the resulting JavaScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的语法不是有效的 JavaScript，因此常规的 JavaScript 运行时环境无法执行它。要在 Node.js 或浏览器中运行
    TypeScript，我们需要首先使用 TSC 将其转换为常规的、向后兼容的 JavaScript。然后，我们可以执行生成的 JavaScript。
- en: Despite being called a compiler, TSC doesn’t actually compile TypeScript into
    JavaScript. Instead, it *transpiles* it. The difference lies in the level of abstraction.
    A compiler creates low-level code, while a transpiler is a source-to-source compiler
    that produces equivalent source code in a language of roughly the same abstraction.
    For example, you could transpile ES.Next to legacy JavaScript or Python 2 to Python
    3\. (That said, the terms *transpiling* and *compiling* are often used interchangeably.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被称为编译器，TSC 实际上并不会将 TypeScript 编译成 JavaScript。相反，它会将其*转译*。二者的区别在于抽象级别。编译器创建低级代码，而转译器是源代码到源代码的编译器，它生成的是大致相同抽象级别的语言的等效源代码。例如，你可以将
    ES.Next 转译为传统的 JavaScript，或将 Python 2 转译为 Python 3。（话虽如此，*转译*和*编译*这两个术语经常被交替使用。）
- en: In addition to converting TypeScript to JavaScript, TSC checks your code for
    type errors and verifies the contracts between your functions. The transpiling
    and type-checking happen independently, and the TSC produces JavaScript regardless
    of the types you defined. TypeScript errors are merely warnings emitted during
    the build. They won’t stop the transpiling step as long as the JavaScript itself
    doesn’t produce an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将 TypeScript 转换为 JavaScript，TSC 还会检查你的代码是否存在类型错误，并验证函数之间的契约。转换和类型检查是独立进行的，TSC
    会生成 JavaScript，无论你定义了什么类型。TypeScript 错误只是构建过程中发出的警告，它们不会阻止转换步骤，只要生成的 JavaScript
    本身没有错误。
- en: The use of TypeScript won’t affect your code’s performance. The compiler removes
    types and type operations during the transpilation step, essentially stripping
    all TypeScript syntax from the actual JavaScript code. Therefore, they can’t affect
    the runtime or the size of the final code. TypeScript is consequently no slower
    than JavaScript, although the transpilation can take some time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 不会影响你的代码性能。编译器会在转译步骤中移除类型和类型操作，本质上将所有 TypeScript 语法从实际的 JavaScript
    代码中剥离。因此，它们不会影响运行时或最终代码的大小。尽管转译过程可能需要一些时间，但 TypeScript 的运行速度不会慢于 JavaScript。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installation in Node.js</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 Node.js 中安装</samp>
- en: 'If you’re using Node.js, you should define TypeScript and all type definitions
    as development dependencies with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> flag in your project’s
    *package.json* file. There is no need to install TypeScript globally. Just add
    TypeScript directly to your project with this npm command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Node.js，应该在项目的 *package.json* 文件中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> 标志将 TypeScript 和所有类型定义定义为开发依赖。无需全局安装
    TypeScript。只需通过以下 npm 命令将 TypeScript 直接添加到你的项目中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: TypeScript files use the extension *.ts*, and because TypeScript is a superset
    of JavaScript, all valid JavaScript code is automatically valid TypeScript code.
    Therefore, you can rename your *.js* files to *.ts* and instantly use the static
    type checker with your existing code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 文件使用扩展名 *.ts*，因为 TypeScript 是 JavaScript 的超集，所有有效的 JavaScript 代码也自动是有效的
    TypeScript 代码。因此，你可以将 *.js* 文件重命名为 *.ts*，并立即在现有代码中使用静态类型检查器。
- en: 'A *tsconfig.json* file defines TSC configuration options. We’ll cover the most
    important ones in the next section. For now, run the following command to generate
    a new file with the default configuration:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*tsconfig.json* 文件定义了 TSC 配置选项。我们将在下一部分介绍最重要的选项。目前，运行以下命令以使用默认配置生成一个新的文件：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: TSC looks for this file in the current path and all parent directories. The
    optional <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> flag points the
    TypeScript compiler directly to the file. TSC then reads configuration information
    from this file and treats its folder as TypeScript’s root directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 会在当前路径和所有父目录中查找这个文件。可选的 <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    标志将 TypeScript 编译器直接指向该文件。然后，TSC 从该文件读取配置信息，并将其文件夹视为 TypeScript 的根目录。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you want to follow this chapter’s examples without creating a dedicated
    project, you can run code in the online playground at* [https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/play](https://www.typescriptlang.org/play)
    *instead of installing TypeScript locally.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想在没有创建专用项目的情况下跟随本章示例，你可以在在线 playground 上运行代码，访问链接：* [https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/play](https://www.typescriptlang.org/play)
    *，而不是在本地安装 TypeScript。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The tsconfig.json
    File</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tsconfig.json 文件</samp>
- en: 'Take a look at the basic structure of a *tsconfig.json* file. The content of
    the generated file depends on your installed TypeScript version, and there are
    around 100 configuration properties, but for most projects, only the following
    few are relevant:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 *tsconfig.json* 文件的基本结构。生成的文件内容取决于你安装的 TypeScript 版本，配置项大约有 100 个，但对于大多数项目，只有以下几个是相关的：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> option is a
    string that configures the path to another similar configuration file. Usually,
    this property extends a preset you used as a template with minor, project-specific
    tweaks. It works similarly to class-based inheritance in object-oriented programming.
    The preset overrides the base configuration, and the configuration’s key-value
    pairs overwrite the preset. The example shown here uses the recommended configuration
    file for TypeScript to override the default settings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> 选项是一个字符串，用于配置指向另一个类似配置文件的路径。通常，此属性会扩展你用作模板的预设，并做一些小的、特定于项目的调整。它的工作方式类似于面向对象编程中的基于类的继承。预设会覆盖基础配置，而配置中的键值对会覆盖预设。这里的示例使用了推荐的
    TypeScript 配置文件来覆盖默认设置。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> field
    configures the transpiling step. We list its options in [Appendix A](appendix-A.xhtml).
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> is
    an array of strings that specifies the patterns or filenames to include for transpiling.
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">exclude</samp> is
    an array of strings that specifies patterns or filenames to exclude. Keep in mind
    that TSC applies these patterns on the list of files found with the included pattern.
    Usually, we don’t need to include or exclude files, as our whole project will
    consist of TypeScript code. Hence, we can leave the arrays empty.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> 字段配置了转译步骤。我们在
    [附录 A](appendix-A.xhtml) 中列出了其选项。<samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp>
    的值是一个字符串数组，指定了要包含在转译中的模式或文件名。<samp class="SANS_TheSansMonoCd_W5Regular_11">exclude</samp>
    的值是一个字符串数组，指定了要排除的模式或文件名。请记住，TSC 会将这些模式应用于通过包含的模式找到的文件列表。通常，我们不需要包含或排除文件，因为整个项目将由
    TypeScript 代码组成。因此，我们可以将这些数组留空。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Feedback
    with TypeScript</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 TypeScript 进行动态反馈</samp>
- en: Most modern code editors have support for TypeScript, and they show us the errors
    generated by TSC directly inside the code. Remember the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function we used to explain how TypeScript verifies function contracts? [Figure
    3-1](chapter3.xhtml#fig3-1) is a screenshot from Visual Studio Code highlighting
    the type error and hinting at the solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代代码编辑器都支持 TypeScript，并且它们可以直接在代码中显示由 TSC 生成的错误。还记得我们用来解释 TypeScript 如何验证函数契约的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> 函数吗？[图 3-1](chapter3.xhtml#fig3-1)
    是来自 Visual Studio Code 的截图，突出了类型错误并提示了解决方案。
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-1: Working with TypeScript
    in Visual Studio Code</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 3-1：在 Visual Studio Code
    中使用 TypeScript</samp>
- en: You can use any code editor or IDE you’d like to write your TypeScript code,
    though one that shows dynamic feedback like this is recommended.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何代码编辑器或 IDE 来编写 TypeScript 代码，尽管建议使用像这样的能够提供动态反馈的编辑器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Annotations</samp>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型注解</samp>
- en: 'A type annotation is an optional way to explicitly tell the runtime environment
    which types to expect. You add them following this schema: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable:
    type</samp>. The following example shows a version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function in which we type both parameters as numbers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '类型注解是一种可选的方式，用于明确告诉运行时环境应该期待哪些类型。你可以按照以下模式添加它们：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">变量:
    类型</samp>。以下示例展示了一个版本的 <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    函数，在其中我们将两个参数的类型都标注为数字：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some developers tend to add types to everything in their code, and by doing
    so, they add noise that makes the code less readable. This antipattern, called
    *over-typing*, stems from a false understanding of how type annotations should
    work. The TypeScript compiler infers types from usage. Therefore, you don’t need
    to explicitly type everything. Instead, the code editor runs TSC in the background
    and leverages the results to display the inferred type information and compiler
    errors as you saw in the “Dynamic Feedback with TypeScript” section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者倾向于在代码中的每一部分都添加类型，结果是增加了噪音，导致代码可读性降低。这种反模式被称为 *过度类型化*，源于对类型注解如何工作的错误理解。TypeScript
    编译器会根据使用情况推断类型。因此，你不需要明确地为每个元素添加类型。相反，代码编辑器会在后台运行 TSC，并利用其结果显示推断出的类型信息和编译器错误，正如你在“使用
    TypeScript 进行动态反馈”部分看到的那样。
- en: Rather, type annotations are a way to ensure that code honors the API contracts.
    There are three scenarios in which you’ll want to verify the contract, and only
    one of them is especially important. The first scenario, upon a variable’s declaration,
    is usually not recommended. The second, annotating the return value of a function,
    is optional, whereas the third scenario, annotating a function’s parameters, is
    essential. We’ll now take a look at all three of these cases in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解的目的是确保代码遵守 API 契约。你会遇到三种需要验证契约的情况，其中只有一种特别重要。第一种情况是在声明变量时，通常不推荐使用；第二种情况是注解函数的返回值，这是可选的；而第三种情况是注解函数的参数，这是至关重要的。接下来我们将详细探讨这三种情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Variable</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明变量</samp>
- en: The most obvious place to type a variable is upon an assignment or declaration.
    [Listing 3-4](chapter3.xhtml#Lis3-4) demonstrates this by explicitly typing the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> as a string
    and then assigning it a string value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化变量的最直接方法是赋值或声明时。[清单 3-4](chapter3.xhtml#Lis3-4)通过显式地将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    类型化为字符串，并将其赋值为字符串值来展示这一点。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-4: Over-typing during the variable’s declaration'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-4：在变量声明时进行过度类型化
- en: In most cases, however, this is a form of over-typing, as you could instead
    leverage the compiler’s type inference. [Listing 3-5](chapter3.xhtml#Lis3-5) shows
    the alternative pattern of using type inference.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，这是一种过度类型声明，因为你可以利用编译器的类型推断。[清单 3-5](chapter3.xhtml#Lis3-5)展示了使用类型推断的替代模式。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-5: Inferring the variable’s type based on its value'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-5：根据变量的值推断类型
- en: Because TSC automatically infers the type of this variable, the code editor
    should show the type information when you hover over the variable. Without the
    explicit annotation, we have a much cleaner syntax and avoid the noise that the
    redundant type declaration adds to the code. This improves code readability, which
    is why this kind of over-typing is usually to be avoided.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TSC 会自动推断该变量的类型，代码编辑器应该在你悬停在变量上时显示类型信息。如果没有显式注解，我们将拥有更简洁的语法，并避免冗余的类型声明给代码带来的杂音。这提高了代码的可读性，这也是为什么通常应该避免这种过度类型化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Return
    Value</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明返回值</samp>
- en: Although TypeScript can infer a function’s return type, you’ll usually want
    to annotate it explicitly. This code pattern ensures that the function’s contract
    is honored, as the compiler shows implementation errors where the function is
    defined instead of where it is used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 可以推断函数的返回类型，但你通常会希望显式地注解它。这种代码模式确保函数契约得到遵守，因为编译器会在函数定义的位置而不是使用位置显示实现错误。
- en: Another reason to use type annotations in this situation is that, as a programmer,
    you must explicitly define what a function does. By clarifying the function’s
    input and output types, you’ll gain a better understanding of what you actually
    want the function to do. [Listing 3-6](chapter3.xhtml#Lis3-6) shows you how to
    declare a function’s return type upon declaration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用类型注解的另一个原因是，作为程序员，你必须明确地定义函数的作用。通过澄清函数的输入和输出类型，你将更好地理解你实际上希望函数执行什么。[清单
    3-6](chapter3.xhtml#Lis3-6)展示了如何在声明时声明函数的返回类型。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-6: Typing a function’s return value upon declaration'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-6：在声明时类型化函数的返回值
- en: We create a function that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable we declared earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable has the inferred string type. Hence, the function returns a string. Our
    type definition explicitly sets the function’s return type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个返回先前声明的 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 变量的函数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 变量具有推断出的字符串类型。因此，函数返回一个字符串。我们的类型定义显式地设置了函数的返回类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Function’s
    Parameters</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明函数的参数</samp>
- en: It’s essential to annotate the parameters of a function, because TypeScript
    doesn’t have enough information to infer function parameters in most cases. By
    typing these parameters, you’re telling the compiler to check the types when you
    call the function and pass it arguments. Take a look at [Listing 3-7](chapter3.xhtml#Lis3-7)
    to see this pattern in action.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注解函数的参数是至关重要的，因为 TypeScript 在大多数情况下没有足够的信息来推断函数参数。通过类型化这些参数，你告诉编译器在调用函数并传递参数时检查类型。请查看
    [清单 3-7](chapter3.xhtml#Lis3-7) 以查看此模式的实际应用。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-7: Typing a function’s parameters'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-7：类型化函数的参数
- en: Instead of declaring the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable as a constant inside the function, we want the returned value to be dynamic.
    Therefore, we modify the function to accept a parameter and return it immediately.
    We then call the function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    constant as a parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 变量声明为函数内部的常量，而是希望返回值动态变化。因此，我们修改函数以接受一个参数并立即返回它。然后，我们用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 常量作为参数来调用该函数。
- en: Good TypeScript code avoids noise and relies on inferring type annotations.
    It always annotates a function’s parameters and opts for annotated return values
    but never annotates local variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 TypeScript 代码避免冗余，并依赖于类型推断注解。它始终对函数的参数进行注解，并选择注解返回值，但从不注解局部变量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Types</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内建类型</samp>
- en: Before you can use TypeScript and its annotations, you need to know what types
    are available to you. One of TypeScript’s main benefits is that it enables you
    to declare any of JavaScript’s primitive types explicitly. In addition, TypeScript
    adds its own types, the most important of which are <samp class="SANS_TheSansMonoCd_W5Regular_11">unions</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tuples</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. You can also define
    custom types and interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 TypeScript 及其注解之前，你需要了解可用的类型。TypeScript 的主要优点之一是，它允许你显式声明 JavaScript 的任何原始类型。此外，TypeScript
    还添加了自己的类型，其中最重要的包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">联合类型</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">元组</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。你还可以定义自定义类型和接口。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Primitive JavaScript
    Types</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">原始 JavaScript 类型</samp>
- en: 'JavaScript has five primitive types: strings, numbers, Booleans, undefined,
    and null. Everything else in the language is considered an object. [Listing 3-8](chapter3.xhtml#Lis3-8)
    shows the syntax for defining variables of these primitive JavaScript types with
    additional TypeScript type annotations. (Remember that, most of the time, you
    can just rely on the compiler’s type inference in this situation.)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有五种原始类型：字符串、数字、布尔值、undefined 和 null。语言中的其他所有内容都被视为对象。[列表 3-8](chapter3.xhtml#Lis3-8)
    展示了使用额外的 TypeScript 类型注解定义这些原始 JavaScript 类型的语法。（记住，大多数时候，你可以依赖编译器的类型推断来处理这种情况。）
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-8: JavaScript’s primitive types with TypeScript’s type annotations'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：带有 TypeScript 类型注解的 JavaScript 原始类型
- en: First we define a string variable and a Boolean with the TypeScript annotations.
    These are identical to strings and Booleans in JavaScript. Then we define two
    numbers. Like JavaScript, TypeScript uses a single generic type for numbers, without
    differentiating between integers and floating points. Finally, we look at TypeScript’s
    null and undefined types. These behave the same as JavaScript’s primitive types
    of the same name. *Null* refers to a value that either is empty or doesn’t exist,
    and it indicates the intentional absence of a value. In contrast, *undefined*
    indicates the unintentional absence of a value. We did not assign a value in [Listing
    3-5](chapter3.xhtml#Lis3-5) for the undefined type, because we don’t know it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个字符串变量和一个布尔值，并使用 TypeScript 注解。这些类型与 JavaScript 中的字符串和布尔值相同。然后，我们定义两个数字。像
    JavaScript 一样，TypeScript 使用一个通用类型来表示数字，不区分整数和浮点数。最后，我们来看 TypeScript 的 null 和 undefined
    类型。它们的行为与 JavaScript 中同名的原始类型相同。*Null* 表示一个为空或不存在的值，表示故意缺少一个值。相比之下，*undefined*
    表示一个值的无意缺失。在 [列表 3-5](chapter3.xhtml#Lis3-5) 中，我们没有为 undefined 类型赋值，因为我们并不知道它的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The union Type</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">联合类型</samp>
- en: There are a few additional types you should know about, because the more precise
    your type annotations are, the more helpful you’ll find TSC to be. TypeScript
    introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type
    to the JavaScript ecosystem. *Unions* are variables or parameters that can have
    more than one data type. [Listing 3-9](chapter3.xhtml#Lis3-9) shows an example
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type that can
    be a string or a number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解一些额外的类型，因为类型注解越精确，TSC 越能提供更多帮助。TypeScript 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    类型引入了 JavaScript 生态系统。*联合类型*是可以拥有多种数据类型的变量或参数。[列表 3-9](chapter3.xhtml#Lis3-9)
    展示了一个示例，说明了一个可以是字符串或数字的 <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    类型。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-9: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">union</samp>
    type'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">union</samp>
    类型
- en: We declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-type
    variable that can contain either a string or a number, but nothing else. As soon
    as we assign a Boolean variable, TSC throws an error, and the IDE shows the message
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type 'boolean' is not assignable
    to type 'string | number'</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> 类型的变量，该变量可以包含一个字符串或一个数字，但不能包含其他类型。只要我们赋值一个布尔变量，TSC
    就会抛出错误，IDE 会显示消息 <samp class="SANS_TheSansMonoCd_W5Regular_11">Type 'boolean'
    is not assignable to type 'string | number'</samp>。
- en: While you might find <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    types useful for annotating function parameters and arrays that can contain different
    types, you should use them sparingly and avoid them whenever possible. This is
    because, before working with <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-typed
    items, you need to perform additional manual type checks; otherwise, they could
    cause errors. For example, if you iterated over an array of strings or numbers
    and then added all items, you would first need to convert all strings to numbers.
    Otherwise, JavaScript would implicitly convert the numbers to strings, as shown
    earlier in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能会发现 <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> 类型在标注可以包含不同类型的函数参数和数组时很有用，但你应该谨慎使用它们，并尽量避免使用。这是因为，在处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> 类型的项之前，你需要进行额外的手动类型检查，否则它们可能会导致错误。例如，如果你遍历一个字符串或数字数组并尝试对所有项求和，你首先需要将所有字符串转换为数字。否则，JavaScript
    会隐式地将数字转换为字符串，就像本章前面所示的那样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The array Type</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组类型</samp>
- en: TypeScript provides a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    type that offers array functions similar to JavaScript’s array. However, take
    a close look at the syntax for typing the array, shown in [Listing 3-10](chapter3.xhtml#Lis3-10).
    You’ll notice that the type of the array depends on the type of the array items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 提供了一个通用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    类型，提供类似 JavaScript 数组的数组函数。然而，仔细查看数组类型注解的语法，见[列表 3-10](chapter3.xhtml#Lis3-10)。你会注意到，数组的类型取决于数组项的类型。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-10: Typed arrays'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-10：已标注类型的数组
- en: First we define an array without specifying the type of its items. Unfortunately,
    what seems to be a definition of a generic array leads to issues down the road.
    As soon as we try to add a value, TSC throws the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument
    of type 'number' is not assignable to parameter of type 'never'</samp>, because
    the array is not typed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个没有指定项类型的数组。不幸的是，看似通用数组的定义，实际上会在后续出现问题。只要我们尝试添加一个值，TSC 就会抛出错误 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Argument of type 'number' is not assignable
    to parameter of type 'never'</samp>，因为该数组没有类型标注。
- en: Hence, we need to type the items in the array. Therefore, we create an array,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">numberArray</samp>, in which each
    item has the type of number. Now we can add numeric values to the array without
    running into errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为数组中的项指定类型。因此，我们创建了一个数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">numberArray</samp>，其中每个项的类型都是数字。现在，我们可以向数组中添加数值，而不会遇到错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The object Type</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象类型</samp>
- en: TypeScript’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    type is the same as JavaScript’s object. Although you can define the properties’
    types for TSC to type-check, the compiler can’t ensure the order of the properties.
    Nonetheless, it typechecks them, as shown in [Listing 3-11](chapter3.xhtml#Lis3-11).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的内置 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 类型与
    JavaScript 的 object 类型相同。尽管可以为 TSC 定义属性类型以进行类型检查，但编译器无法确保属性的顺序。尽管如此，它仍然会对它们进行类型检查，如
    [列表 3-11](chapter3.xhtml#Lis3-11) 所示。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-11: Typed objects'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-11：已类型化的对象
- en: 'Here we define an object with three properties: two that take a string and
    another that takes a number. Then we try to assign a number to the property <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> annotated as a string.
    Now TSC notifies us with an error explaining that we assigned a value of the wrong
    type.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个包含三个属性的对象：两个属性为字符串类型，另一个属性为数字类型。然后我们尝试将一个数字赋值给被注解为字符串类型的属性 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>。现在
    TSC 会提示我们错误，解释说我们赋值的类型不正确。
- en: Note that, usually, you should avoid typing objects inline, as in this example.
    Instead, it is a best practice to create a custom type, which is reusable and
    avoids cluttering our code, enhancing its readability. We discuss how to create
    and use them in “Custom Types and Interfaces” on page 44.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常应避免像这个例子中那样内联为对象指定类型。相反，最好创建一个自定义类型，它是可重用的，能够避免代码混乱，从而提高代码的可读性。我们在第 44
    页的“自定义类型和接口”中讨论如何创建和使用它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tuple</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tuple</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
- en: Another common type that TypeScript adds to JavaScript is the <samp class="SANS_TheSansMonoCd_W5Regular_11">tuple</samp>
    type. Shown in [Listing 3-12](chapter3.xhtml#Lis3-12), *tuples* are arrays with
    a specified number of typed items. TypeScript’s tuples are similar to those you
    might have encountered in programming languages such as Python and C#.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 JavaScript 添加的另一个常见类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">tuple</samp>
    类型。如 [列表 3-12](chapter3.xhtml#Lis3-12) 所示，*元组* 是具有指定类型项数量的数组。TypeScript 的元组与您可能在
    Python 和 C# 等编程语言中遇到的类似。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-12: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tuple</samp>
    type'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-12：TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tuple</samp>
    类型
- en: We define two tuples. In both, the first array item is a string, and the second
    is a number. If the type, order, or number of items added to the tuple differs
    from the tuple’s declaration, TSC throws an error. Here the first assignment is
    acceptable, whereas the second one throws two errors indicating a mismatch in
    types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个元组。在这两个元组中，第一个数组项是一个字符串，第二个是一个数字。如果添加到元组中的类型、顺序或项数与元组声明不符，TSC 会抛出错误。这里，第一个赋值是可以接受的，而第二个赋值会抛出两个错误，表明类型不匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">any</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">any</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
- en: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type is
    generic, meaning it can take any value, and you should avoid using it. As you
    can see in [Listing 3-13](chapter3.xhtml#Lis3-13), it accepts all values without
    throwing an error, which defeats the purpose of static typing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型是通用的，这意味着它可以接受任何值，因此应避免使用它。正如在
    [列表 3-13](chapter3.xhtml#Lis3-13) 中所示，它接受所有值而不抛出错误，这违背了静态类型检查的目的。
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-13: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-13：TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    类型
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> might seem like
    an easy choice, and it is tempting to rely on it as an escape hatch. Avoid this
    at all costs. When you pass <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    as a value to, say, a function, you break the contract you specified in the function
    declaration, and when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    to define the contract, there effectively isn’t one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 可能看起来是一个简单的选择，且它确实很诱人作为一种逃生路径。但必须避免这样做。当你将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 作为值传递给某个函数时，你打破了函数声明中所指定的契约，而当你使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 来定义契约时，实际上根本没有契约。
- en: To view a scenario in which using the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type causes problems, take a look at [Listing 3-14](chapter3.xhtml#Lis3-14).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型导致问题的场景，请参见
    [Listing 3-14](chapter3.xhtml#Lis3-14)。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-14: Problems caused by the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-14：使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    类型带来的问题
- en: We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function, which adds two numbers. When we pass two numeric values, we receive
    the expected output of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
    In a previous example, we typed the parameters as numbers, thus preventing the
    use of invalid types as arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们复用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> 函数，它用于加法运算。当我们传递两个数字值时，我们得到了预期的输出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。在之前的示例中，我们将参数类型指定为数字，从而避免了使用无效类型作为参数。
- en: However, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    instead of a number and pass a string to the function, TSC doesn’t throw an error.
    JavaScript implicitly converts the number to a string and returns an unexpected
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>. We saw this
    behavior at the beginning of the chapter, in the untyped version of the function.
    As you can see, using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    is the same as using no types at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 替代数字并传递一个字符串给函数时，TSC
    并不会抛出错误。JavaScript 会隐式地将数字转换为字符串并返回一个意外的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>。我们在本章开始时的无类型版本函数中看到了这种行为。如你所见，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 就等同于根本没有使用任何类型。
- en: While convenient, the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type masks your bugs during programming and hides your type designs, rendering
    type-checking useless. It also prevents your IDE from displaying errors and invalid
    types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型很方便，但它会在编程时掩盖错误，隐藏你的类型设计，使得类型检查失去意义。它还会阻止你的
    IDE 显示错误和无效类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
- en: 'TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type
    is the opposite of <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>: it
    indicates no type at all. Its only use case is to annotate the return value of
    a function that shouldn’t have one, as shown in [Listing 3-15](chapter3.xhtml#Lis3-15).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型相反：它表示没有类型。它唯一的使用场景是注释那些不应返回值的函数的返回值，如
    [Listing 3-15](chapter3.xhtml#Lis3-15) 所示。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-15: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">void</samp>
    type'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-15：TypeScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">void</samp>
    类型
- en: The custom log function we define here passes a parameter to the console. It
    doesn’t return anything, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the return type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的自定义日志函数向控制台传递一个参数。它没有返回任何值，因此我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    作为返回类型。
- en: To learn more about TypeScript types and other important details of the language,
    take a look at *The TypeScript Handbook* at [*https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/docs<wbr>/handbook<wbr>/intro<wbr>.html*](https://www.typescriptlang.org/docs/handbook/intro.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多 TypeScript 类型和其他语言的重要细节，请查看 *TypeScript 手册*，访问 [*https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/docs<wbr>/handbook<wbr>/intro<wbr>.html*](https://www.typescriptlang.org/docs/handbook/intro.html)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Custom Types and Interfaces</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自定义类型和接口</samp>
- en: The previous sections introduced you to enough TypeScript to begin using the
    language. However, you’ll find it helpful to know a few more advanced concepts.
    This section shows you how to create custom types and use untyped third-party
    libraries in your TypeScript code. You’ll also learn when to create a new type
    and use a custom interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节已经介绍了足够的 TypeScript 内容，可以开始使用该语言。然而，了解一些更高级的概念会对你有帮助。本节将向你展示如何在 TypeScript
    代码中创建自定义类型和使用未类型化的第三方库。你还将学习何时创建新类型以及何时使用自定义接口。
- en: While working with TypeScript, remember that a TypeScript file *without* top-level
    imports or exports is not a module; therefore, it runs in the *global* scope.
    Consequently, all of its declarations are accessible in other modules. By contrast,
    a TypeScript file *with* top-level imports or exports is its own module, and all
    declarations are limited to the *module* scope, meaning they’re available in the
    scope of this module only.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 TypeScript 时，请记住，*没有*顶级导入或导出的 TypeScript 文件不是一个模块；因此，它在 *全局* 范围内运行。因此，它的所有声明在其他模块中都可以访问。相比之下，*有*顶级导入或导出的
    TypeScript 文件是其自己的模块，所有声明都限制在 *模块* 范围内，意味着它们只在此模块的范围内可用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义自定义类型</samp>
- en: TypeScript lets you define custom types by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    keyword. Custom types are a great way to simplify your code. To see how, take
    a second look at the code shown back in [Listing 3-8](chapter3.xhtml#Lis3-8),
    when you created a typed object. Now consider [Listing 3-16](chapter3.xhtml#Lis3-16),
    which optimizes the code with a custom type definition. You should find it much
    cleaner and easier to read.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 关键字定义自定义类型。自定义类型是简化代码的好方法。为了了解如何简化代码，可以再次查看
    [列表 3-8](chapter3.xhtml#Lis3-8) 中的代码，在那里你创建了一个类型化对象。现在看看 [列表 3-16](chapter3.xhtml#Lis3-16)，它通过自定义类型定义优化了代码。你应该会发现它更简洁、更易读。
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-16: Custom types for typed objects with TypeScript'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-16：使用 TypeScript 定义的类型化对象的自定义类型
- en: We create a custom type, <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> keyword. Note
    that the overall syntax is similar to that used to define an object; we use the
    equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) to assign
    the definition to the custom type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 关键字创建了一个自定义类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>。请注意，整体语法类似于定义一个对象；我们使用等号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）将定义赋值给自定义类型。
- en: 'The custom type has two required properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>. In addition,
    it has an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> property,
    as indicated by the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>).
    Now when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">getWeatherDetail</samp>
    function, we can annotate the parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetail</samp>,
    as an object with a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>.
    Using this technique, we avoid using inline annotations and can reuse our custom
    type later, such as to annotate the return type of a function.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型有两个必需的属性：<samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>。此外，它还有一个可选的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> 属性，如问号（<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>）所示。现在，当我们创建
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getWeatherDetail</samp> 函数时，我们可以将参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetail</samp> 注解为类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp> 的对象。使用这种技巧，我们避免了使用内联注解，并且可以在以后重用我们的自定义类型，例如注解函数的返回类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Interfaces</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义接口</samp>
- en: In addition to types, TypeScript has interfaces. However, the difference between
    a type and an interface is blurry. You can freely decide which one to use, so
    long as you follow a convention in your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型，TypeScript 还有接口。然而，类型和接口之间的区别并不明确。只要你在代码中遵循一种约定，可以自由选择使用其中之一。
- en: In general, we consider a *type* definition to answer the question, “Which type
    is this data?” A possible answer might be a union or a tuple. An *interface* is
    a way to describe the shape of some data, such as the properties of an object.
    It answers the question, “Which properties does this object have?” The most practical
    difference is that, unlike an interface, we cannot directly modify a type after
    we’ve declared it. For an in-depth look at the distinction, consult *The TypeScript
    Handbook*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们认为 *类型* 定义回答了这样一个问题：“这个数据是什么类型？”一个可能的答案是联合类型或元组。*接口* 是一种描述某些数据形状的方式，比如一个对象的属性。它回答了这样一个问题：“这个对象有哪些属性？”最实际的区别是，与接口不同，类型在声明后不能直接修改。有关这一区别的深入了解，请参考
    *TypeScript 手册*。
- en: As a rule of thumb, use an interface to define a new object or the method of
    an object. More generally, consider using interfaces over types, as they provide
    more precise error messages. A classic React use case for interfaces is to define
    the properties of a specific component. [Listing 3-17](chapter3.xhtml#Lis3-17)
    shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to create a new interface to replace the type in [Listing 3-16](chapter3.xhtml#Lis3-16).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种经验法则，使用接口来定义一个新对象或对象的方法。更一般来说，考虑使用接口而不是类型，因为接口提供了更精确的错误信息。一个经典的 React 接口用例是定义特定组件的属性。[列表
    3-17](chapter3.xhtml#Lis3-17) 展示了如何使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>`
    关键字创建一个新接口，替代 [列表 3-16](chapter3.xhtml#Lis3-16) 中的类型。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-17: Custom interfaces for TypeScript functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-17：TypeScript 函数的自定义接口
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to define a new interface. Unlike a custom type’s definition, an interface
    definition does not use the equal sign to assign the interface’s properties to
    its name. We then use the custom interface to type the properties object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherComponent</samp>,
    which returns a string.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>` 关键字来定义一个新的接口。与自定义类型的定义不同，接口定义不会使用等号将接口的属性分配给其名称。然后，我们使用自定义接口来类型化
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">weatherComponent</samp>` 的属性对象
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>`，它返回一个字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Type Declaration
    Files</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用类型声明文件</samp>
- en: To use custom types universally, you can define them in *type declaration files*,
    which have the *.d.ts* extension. Unlike regular TypeScript files with the *.ts*
    or *.tsx* extension, type declaration files shouldn’t contain any implementation
    code. Instead, TSC uses these type definitions to understand custom types and
    perform type checks. They aren’t transpiled to JavaScript and are never part of
    the executed script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要普遍使用自定义类型，你可以将它们定义在 *类型声明文件* 中，这些文件的扩展名是 *.d.ts*。与常规的 TypeScript 文件（*.ts* 或
    *.tsx* 扩展名）不同，类型声明文件不应包含任何实现代码。相反，TSC 使用这些类型定义来理解自定义类型并进行类型检查。它们不会被转译为 JavaScript，也永远不会成为执行脚本的一部分。
- en: Type declaration files prove useful when you find yourself working with external
    code bases. Often, third-party libraries aren’t written in TypeScript. Therefore,
    they don’t provide type declaration files for their code bases. Luckily, the DefinitelyTyped
    repository at [*http://<wbr>definitelytyped<wbr>.github<wbr>.io*](http://definitelytyped.github.io)
    provides type declaration files for more than 7,000 libraries. Use these files
    to add TypeScript support to these libraries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与外部代码库合作时，类型声明文件非常有用。通常，第三方库不是用 TypeScript 编写的，因此它们没有为其代码库提供类型声明文件。幸运的是，DefinitelyTyped
    仓库在 [*http://<wbr>definitelytyped<wbr>.github<wbr>.io*](http://definitelytyped.github.io)
    提供了超过 7,000 个库的类型声明文件。使用这些文件，你可以为这些库添加 TypeScript 支持。
- en: Type declaration files are collected under the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope in npm. This scope holds all the declarations from DefinitelyTyped. Hence,
    they are easy to find and are grouped next to each other in your *package.json*
    file. All type declaration files from the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope should be considered development dependencies of your project. Hence, we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--save-dev</samp> flag on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install</samp> command to
    add them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型声明文件被集中在 npm 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    范围内。这个范围包含了来自 DefinitelyTyped 的所有声明。因此，它们易于查找，并且在你的 *package.json* 文件中被分组在一起。所有来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp> 范围的类型声明文件应视为项目的开发依赖。因此，我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install</samp> 命令中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--save-dev</samp>
    标志来添加它们。
- en: '[Listing 3-18](chapter3.xhtml#Lis3-18) shows a minimal example of a type declaration
    file that exports a type and interface for an API.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-18](chapter3.xhtml#Lis3-18) 显示了一个最小化的类型声明文件示例，该文件导出了一个 API 的类型和接口。'
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-18: Defining custom types and interfaces'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-18：定义自定义类型和接口
- en: Save these definitions in a file called *custom.d.ts* in your root directory.
    TSC should automatically load these definitions. You can now use the types and
    interfaces from the file in your TypeScript modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些定义保存在名为 *custom.d.ts* 的文件中，放在你的根目录下。TSC 应该会自动加载这些定义。现在，你可以在 TypeScript 模块中使用来自该文件的类型和接口。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3: Extend Express.js with
    TypeScript</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 3：使用 TypeScript 扩展 Express.js</samp>
- en: Let’s use your new knowledge of TypeScript to rewrite the Express.js server
    you created in Exercises 1 and 2\. In addition to adding type annotations, we’ll
    add a new route to the server by using custom types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用你对 TypeScript 的新知识，重写你在练习 1 和 2 中创建的 Express.js 服务器。除了添加类型注解，我们还将通过使用自定义类型向服务器添加一个新路由。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置</samp>
- en: 'Begin by adding TypeScript to the project following the steps described in
    “Setting Up TypeScript” on page 36. Next, because Express.js isn’t typed, add
    type definitions from DefinitelyTyped to your project by running the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按照第 36 页“设置 TypeScript”中描述的步骤将 TypeScript 添加到项目中。接着，因为 Express.js 没有类型定义，运行以下命令从
    DefinitelyTyped 向项目中添加类型定义：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Your *package.json* file should now look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 *package.json* 文件现在应该如下所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you can create configuration and type declaration files for the project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以为项目创建配置文件和类型声明文件了。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the tsconfig.json
    File</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 tsconfig.json
    文件</samp>
- en: 'Either create a new *tsconfig.json* file in the *sample-express* folder, next
    to the *index.ts* file, or open the one you created earlier. Then add or replace
    its content with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *sample-express* 文件夹中创建一个新的 *tsconfig.json* 文件，紧挨着 *index.ts* 文件，或者打开你之前创建的文件。然后将其内容添加或替换为以下代码：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We configure TypeScript for our simple Express.js server, which requires only
    a few settings. We use ES.Next modules for our TypeScript code, and because we
    want to keep them after transpiling the TypeScript to JavaScript, we set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">module</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>. The *express* package
    is a CommonJS module. Therefore, we need to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">esModuleInterop</samp>
    option and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">moduleResolution</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>. Finally, we use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">noImplicitAny</samp> option
    to disallow the implicit use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type and require explicit typing. [Appendix A](appendix-A.xhtml) describes these
    configuration options in more detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的简单 Express.js 服务器配置 TypeScript，这只需要一些设置。我们为 TypeScript 代码使用 ES.Next 模块，并且因为我们希望在将
    TypeScript 转换为 JavaScript 后仍然保留这些模块，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>。*express*
    包是一个 CommonJS 模块。因此，我们需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">esModuleInterop</samp>
    选项，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">moduleResolution</samp> 设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>。最后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">noImplicitAny</samp>
    选项，禁止隐式使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> 类型，并要求显式指定类型。[附录
    A](appendix-A.xhtml) 更详细地描述了这些配置选项。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义自定义类型</samp>
- en: 'For our server, we’ll follow a simple rule of thumb: every time we use an object,
    we should consider adding a custom type or interface to our project. If the object
    is a function parameter, we’ll create a custom interface. If we use this particular
    object more than once, we’ll create a custom type.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的服务器，我们将遵循一个简单的经验法则：每次使用一个对象时，我们应该考虑向项目中添加自定义类型或接口。如果对象是函数参数，我们将创建一个自定义接口。如果我们多次使用这个特定的对象，我们将创建一个自定义类型。
- en: To define the custom types for this sample project, we create a file *custom.d.ts*
    next to the *index.ts* file in the *sample-express* folder and add the code from
    [Listing 3-19](chapter3.xhtml#Lis3-19).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为这个示例项目定义自定义类型，我们在 *sample-express* 文件夹中创建一个名为 *custom.d.ts* 的文件，并添加来自 [Listing
    3-19](chapter3.xhtml#Lis3-19) 的代码。
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-19: The custom.d.ts file'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-19：custom.d.ts 文件
- en: We create two custom types and an interface. One defines the response items
    of the asynchronous API call. The other type and the interface are similar to
    examples shown earlier in this chapter. They are necessary for the new weather
    route we will create shortly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个自定义类型和一个接口。一个定义了异步 API 调用的响应项。另一个类型和接口类似于本章前面显示的示例。它们对于我们即将创建的新天气路由是必要的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the routes.ts File</samp>
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">向 routes.ts 文件添加类型注解</samp>
- en: Next, we must add type annotations to our server code. Rename the *routes.js*
    file in the *sample-express* folder to *routes.ts* to enable the TSC for this
    file. You should instantly see the errors and warnings appear in your editor.
    Take some time to look at these and then adjust the contents to match the code
    in [Listing 3-20](chapter3.xhtml#Lis3-20). We’ve bolded all type annotations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须向服务器代码添加类型注解。将 *sample-express* 文件夹中的 *routes.js* 文件重命名为 *routes.ts*，以便为该文件启用
    TSC。你应该立即看到错误和警告出现在编辑器中。花些时间查看这些错误，然后调整内容以匹配 [Listing 3-20](chapter3.xhtml#Lis3-20)
    中的代码。我们已将所有类型注解加粗。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-20: The typed routes.ts file'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-20：typed routes.ts 文件
- en: Following the principle discussed in “Type Annotations” on page 38, we annotate
    only a function’s parameters and return types. We also annotate local variables
    only when their types cannot be inferred, as when converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    response to JSON. Here we need to explicitly type the variable with our custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> and cast
    the conversion’s return value as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>s.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第38页“类型注解”部分讨论的原则，我们只注解函数的参数和返回类型。当局部变量的类型无法推断时，我们才对其进行注解，例如在将<samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>响应转换为JSON时。在这里，我们需要显式地为变量指定自定义类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>，并将转换的返回值强制转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>数组。
- en: In the rest of the listing, we create the functions for the additional weather
    route. We use the custom interface for typing both functions’ parameters and the
    custom type for their return types. In this basic example, the query function
    returns mostly static data, except the ZIP code, which it takes from the passed
    parameters. A regular implementation would query a database with the ZIP code
    and retrieve actual data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单的其余部分，我们为额外的天气路由创建函数。我们使用自定义接口为两个函数的参数类型注解，并使用自定义类型为它们的返回类型注解。在这个基本示例中，查询函数返回大多数静态数据，唯一不同的是邮政编码，它是从传递的参数中获取的。常规实现会使用邮政编码查询数据库并检索实际数据。
- en: Finally, we add the new route for the weather endpoint to the <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp>
    statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的天气端点路由添加到<sup class="SANS_TheSansMonoCd_W5Regular_11">export</sup>语句中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the index.ts File</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为 index.ts 文件添加类型注解</samp>
- en: Rename the file *index.js* in the *sample-express* folder to *index.ts* and
    adjust the code to match [Listing 3-20](chapter3.xhtml#Lis3-20). In addition to
    the necessary type annotations, create a new endpoint and follow the TypeScript
    convention to prefix unused parameters with an underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>),
    shown in [Listing 3-21](chapter3.xhtml#Lis3-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将*sample-express*文件夹中的文件*index.js*重命名为*index.ts*，并调整代码以匹配[清单 3-20](chapter3.xhtml#Lis3-20)。除了必要的类型注解，还需要创建一个新的端点，并按照TypeScript约定，为未使用的参数加上下划线前缀（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_</samp>），如[清单 3-21](chapter3.xhtml#Lis3-21)所示。
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-21: The typed index.ts file'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-21：带有类型注解的 index.ts 文件
- en: First we import the new weather route from the available routes and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    types from the *express* package. These are all named exports. Thus, we use curly
    brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从可用的路由中导入新的天气路由，并从*express*包中导入<Request>和<Response>类型。这些都是具名导出。因此，我们使用花括号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>）。
- en: Then, following best practices, we add code annotations and, at the same time,
    prefix the unused <samp class="SANS_TheSansMonoCd_W5Regular_11">req</samp> parameters
    with an underscore. TSC will follow the convention of functional programming languages
    by ignoring these parameters. The *api/names* entry point is marked as an async
    function, so it needs to return a value wrapped in a promise. Hence, nothing is
    returned, and we return <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the promise’s value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照最佳实践，我们添加代码注解，并同时为未使用的<sup class="SANS_TheSansMonoCd_W5Regular_11">req</sup>参数加上下划线前缀。TSC会遵循函数式编程语言的约定，忽略这些参数。*api/names*入口点被标记为异步函数，因此它需要返回一个包裹在Promise中的值。因此，什么也不返回，我们将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">void</sup>作为Promise的值返回。
- en: In the following lines of code, we create an additional route for a new */api/weather/:zipcode*
    endpoint. The colon (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>) creates
    a parameter on the request’s <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>
    object. We retrieve the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params .zipcode</samp>
    and pass it down to the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeWeather</samp>
    function. Note that there is no underscore on the request parameter this time.
    Finally, we use the same function as before to start the Express.js server and
    listen to port 3000.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们为新的 */api/weather/:zipcode* 端点创建了一个额外的路由。冒号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>)
    在请求的 <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> 对象上创建了一个参数。我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params.zipcode</samp> 获取 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> 的值，并将其传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">routeWeather</samp>
    函数。请注意，这次请求参数中没有下划线。最后，我们使用与之前相同的函数启动 Express.js 服务器并监听 3000 端口。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transpiling and Running
    the Code</samp>
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转译并运行代码</samp>
- en: 'To transpile the code with the TypeScript compiler to JavaScript, run TSC with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 TypeScript 编译器将代码转译为 JavaScript，请在命令行中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>
    运行 TSC：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'TSC generates two new files, *index.js* and *routes.js*, from the TypeScript
    files. Start the server from your command line with the regular Node.js call:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 从 TypeScript 文件生成了两个新文件，*index.js* 和 *routes.js*。通过命令行使用常规的 Node.js 调用启动服务器：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now visit *http://localhost:3000/api/weather/12345* in your browser. You should
    see the weather details with the ZIP code 12345, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中访问 *http://localhost:3000/api/weather/12345*。你应该能看到 ZIP 代码 12345 的天气详情，如[图
    3-2](chapter3.xhtml#fig3-2)所示。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-2: Browser response
    from the Node.js web server</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 3-2：来自 Node.js Web 服务器的浏览器响应</samp>
- en: Success! You wrote your first TypeScript application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你写出了你的第一个 TypeScript 应用程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter taught you what you need to know about TypeScript to create a full-stack
    application. We set up TypeScript and TSC in a new project, then discussed its
    most important configuration options. Next, you learned to use TypeScript efficiently,
    leveraging type-annotation inference to avoid over-typing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了你需要了解的关于 TypeScript 的知识，以便创建一个全栈应用程序。我们在一个新项目中设置了 TypeScript 和 TSC，然后讨论了其最重要的配置选项。接下来，你学习了如何高效使用
    TypeScript，利用类型注解推断来避免过度输入。
- en: We also discussed primitive and advanced built-in types and how to create custom
    types and interfaces. Finally, you used your new knowledge to add TypeScript to
    the Express.js server built in previous exercises and refactored the code with
    type annotations, custom types, and interfaces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了原始类型和高级内置类型，并讲解了如何创建自定义类型和接口。最后，你利用新学到的知识将 TypeScript 添加到之前练习中构建的 Express.js
    服务器，并使用类型注解、自定义类型和接口重构了代码。
- en: If you want to become a TypeScript expert, I recommend *The TypeScript Handbook*
    and the tutorials at [*https://<wbr>www<wbr>.typescripttutorial<wbr>.net*](https://www.typescripttutorial.net).
    In the next chapter, you’ll get to know React, a declarative JavaScript library
    for building user interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为 TypeScript 专家，我推荐阅读 *TypeScript 手册* 和 [*https://<wbr>www<wbr>.typescripttutorial<wbr>.net*](https://www.typescripttutorial.net)
    上的教程。在下一章，你将了解 React，这是一种用于构建用户界面的声明式 JavaScript 库。
