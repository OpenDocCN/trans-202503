- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: TypeScript is a programming language that adds static typing to the dynamically
    typed JavaScript language. It’s a strict syntactic superset of JavaScript, which
    means that all existing JavaScript is valid TypeScript. By contrast, TypeScript
    is not valid JavaScript, because it supplies additional features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to the pitfalls of working with JavaScript’s
    dynamic types and explain how TypeScript’s static typing helps catch errors early,
    increasing the stability of your code. Full-stack developers have embraced TypeScript:
    it was the runner-up in the *most wanted* category of a recent Stack Overflow
    Developer Survey, and 78 percent of participants in a *State of JS* survey reported
    using it. According to [*https://<wbr>builtwith<wbr>.com*](https://builtwith.com),
    TypeScript underlies 7 percent of the top 10,000 sites.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the essential and advanced TypeScript concepts necessary for building
    full-stack applications. Along the way, you’ll get to know the language’s most
    common configuration options, its most important types, and how and when to use
    TypeScript’s static typing features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Benefits of TypeScript</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript makes working with JavaScript’s type system less error prone, as
    its compiler helps us see type errors instantly. Because JavaScript is *dynamically*
    typed, you don’t need to specify a variable’s type when declaring it. As soon
    as the runtime executes the script, it checks these types based on usage. However,
    this means that errors resulting from invalid types (for example, calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> on a variable that holds
    a number instead of an array) won’t be discovered until runtime, at which point
    the complete program fails.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being dynamically typed, JavaScript is also *weakly* typed, which
    means it implicitly converts variables to their most plausible values. [Listing
    3-1](chapter3.xhtml#Lis3-1) shows an implicit conversion from a number to a string.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Implicit conversion from a number to a string in JavaScript'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We declare three variables, assigning the first a string, the second a numeric
    value, and the third the result of using the arithmetic plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator to add the number to itself. We then log the result of this sum operation
    and its type to the console. If you executed this code, you would see that the
    value is numeric and that the runtime assigned a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>
    to the variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the same operator again, but instead of adding a numeric value
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> variable, we
    add a string to it. You should see that the logged value is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>,
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, as you might have
    expected. Moreover, the variable’s assigned type has changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    This happens because the runtime environment needs to handle an impossible task:
    adding a number and a string. It solves this issue by implicitly converting the
    number to a string, then using the plus operator to concatenate the two strings.
    Without TypeScript, we notice this conversion only when we run the code.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用相同的运算符，但这次我们不是将数值添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>变量中，而是将一个字符串添加到它上面。你应该看到日志中的值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">11</samp>，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，这是你可能预期的结果。此外，变量的赋值类型已变为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。这发生是因为运行时环境需要处理一个不可能完成的任务：将数字与字符串相加。它通过隐式将数字转换为字符串，然后使用加号运算符将两个字符串连接起来，来解决这个问题。如果没有
    TypeScript，我们只有在运行代码时才会注意到这种转换。
- en: Another common problem caused by untyped variables relates to function and API
    *contracts*, or the agreements about what the code accepts and returns. When a
    function takes a parameter, it implicitly expects a parameter of a specific type.
    But without TypeScript, there is no way to ensure that the parameter type is correct.
    The same problem exists for the function’s return value. To illustrate this, [Listing
    3-2](chapter3.xhtml#Lis3-2) changes the code from [Listing 3-1](chapter3.xhtml#Lis3-1)
    so that it uses a function to calculate the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个由未指定类型的变量引起的常见问题与函数和 API *契约*（即代码接受和返回内容的约定）有关。当函数接受一个参数时，它隐式地期望该参数是特定类型的。但是没有
    TypeScript，就无法确保参数类型正确。函数返回值也存在相同的问题。为了说明这一点，[列表 3-2](chapter3.xhtml#Lis3-2)将[列表
    3-1](chapter3.xhtml#Lis3-1)中的代码进行了修改，使其使用一个函数来计算<sup class="SANS_TheSansMonoCd_W5Regular_11">result</sup>变量的值。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: A function that could return an invalid type due to implicit type
    conversion'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-2：由于隐式类型转换可能返回无效类型的函数
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp> function
    takes two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and as before, adds the
    two values. Like in [Listing 3-1](chapter3.xhtml#Lis3-1), as soon as we pass a
    number and a string as parameters, the function returns a string instead of a
    number. Our function might expect both parameters to be numbers, but we can’t
    verify this without manually checking the type by using logic similar to that
    in [Listing 3-3](chapter3.xhtml#Lis3-3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 新的<samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>函数接受两个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，并像之前一样将两个值相加。就像在[列表
    3-1](chapter3.xhtml#Lis3-1)中一样，一旦我们将一个数字和一个字符串作为参数传递，函数就会返回一个字符串而不是数字。我们的函数可能期望两个参数都是数字，但在没有
    TypeScript 的情况下，我们无法在不手动检查类型的情况下验证这一点，检查逻辑类似于[列表 3-3](chapter3.xhtml#Lis3-3)中的代码。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: The refactored type-safe function'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-3：重构后的类型安全函数
- en: 'Here we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp>
    function of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp> object
    to verify that the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are integers. The first
    call of the function, in which we pass it two integers, should calculate the result
    as expected. The second call, in which we pass the function an integer and a string,
    looks fine in the editor. However, when we run the code, the runtime environment
    should throw the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid type:
    a parameter is not an integer</samp>.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们使用原生的<samp class="SANS_TheSansMonoCd_W5Regular_11">isInteger</samp>函数来验证参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>是否为整数。第一次调用该函数时，我们传递两个整数，应该能按预期计算出结果。第二次调用时，我们传递了一个整数和一个字符串，在编辑器中看起来没问题。然而，当我们运行代码时，运行时环境应抛出错误<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Invalid type: a parameter is not an integer</samp>。'
- en: There are two main concerns with manually checking the types. First, it adds
    a lot of noise to our code, as we need to check for all possible types every time
    we work with function or API contracts, such as when we accept a parameter or
    return a value. Second, we’re not notified of issues during development. To see
    the errors in dynamically typed languages, we need to execute the code so that
    the interpreter can inform us about errors at runtime.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Unlike dynamically typed languages, *statically* typed languages perform type
    checks on the code compilation, before runtime. The TypeScript Compiler (TSC)
    handles this chore; it can run in the background of our code editor or IDE and
    instantly report all errors based on invalid type usage. Therefore, you can catch
    errors and see each variable’s assigned types and data structures early.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don’t set up instant feedback like that, running your code through
    TSC is necessary before it can be used, which ensures that these kinds of errors
    are caught earlier than they otherwise would be. The ability to check for these
    errors is one of the most important benefits of using TypeScript over JavaScript.
    We will discuss how to benefit from type annotations and when to use them in “Type
    Annotations” on page 38.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up TypeScript</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript’s syntax isn’t valid JavaScript, so a regular JavaScript runtime
    environment can’t execute it. To run TypeScript in Node.js or a browser, we first
    need to use TSC to convert it to regular, backward-compatible JavaScript. We then
    execute the resulting JavaScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Despite being called a compiler, TSC doesn’t actually compile TypeScript into
    JavaScript. Instead, it *transpiles* it. The difference lies in the level of abstraction.
    A compiler creates low-level code, while a transpiler is a source-to-source compiler
    that produces equivalent source code in a language of roughly the same abstraction.
    For example, you could transpile ES.Next to legacy JavaScript or Python 2 to Python
    3\. (That said, the terms *transpiling* and *compiling* are often used interchangeably.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In addition to converting TypeScript to JavaScript, TSC checks your code for
    type errors and verifies the contracts between your functions. The transpiling
    and type-checking happen independently, and the TSC produces JavaScript regardless
    of the types you defined. TypeScript errors are merely warnings emitted during
    the build. They won’t stop the transpiling step as long as the JavaScript itself
    doesn’t produce an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The use of TypeScript won’t affect your code’s performance. The compiler removes
    types and type operations during the transpilation step, essentially stripping
    all TypeScript syntax from the actual JavaScript code. Therefore, they can’t affect
    the runtime or the size of the final code. TypeScript is consequently no slower
    than JavaScript, although the transpilation can take some time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installation in Node.js</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 Node.js 中安装</samp>
- en: 'If you’re using Node.js, you should define TypeScript and all type definitions
    as development dependencies with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> flag in your project’s
    *package.json* file. There is no need to install TypeScript globally. Just add
    TypeScript directly to your project with this npm command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Node.js，应该在项目的 *package.json* 文件中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-save-dev</samp> 标志将 TypeScript 和所有类型定义定义为开发依赖。无需全局安装
    TypeScript。只需通过以下 npm 命令将 TypeScript 直接添加到你的项目中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: TypeScript files use the extension *.ts*, and because TypeScript is a superset
    of JavaScript, all valid JavaScript code is automatically valid TypeScript code.
    Therefore, you can rename your *.js* files to *.ts* and instantly use the static
    type checker with your existing code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 文件使用扩展名 *.ts*，因为 TypeScript 是 JavaScript 的超集，所有有效的 JavaScript 代码也自动是有效的
    TypeScript 代码。因此，你可以将 *.js* 文件重命名为 *.ts*，并立即在现有代码中使用静态类型检查器。
- en: 'A *tsconfig.json* file defines TSC configuration options. We’ll cover the most
    important ones in the next section. For now, run the following command to generate
    a new file with the default configuration:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*tsconfig.json* 文件定义了 TSC 配置选项。我们将在下一部分介绍最重要的选项。目前，运行以下命令以使用默认配置生成一个新的文件：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: TSC looks for this file in the current path and all parent directories. The
    optional <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> flag points the
    TypeScript compiler directly to the file. TSC then reads configuration information
    from this file and treats its folder as TypeScript’s root directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 会在当前路径和所有父目录中查找这个文件。可选的 <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    标志将 TypeScript 编译器直接指向该文件。然后，TSC 从该文件读取配置信息，并将其文件夹视为 TypeScript 的根目录。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you want to follow this chapter’s examples without creating a dedicated
    project, you can run code in the online playground at* [https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/play](https://www.typescriptlang.org/play)
    *instead of installing TypeScript locally.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想在没有创建专用项目的情况下跟随本章示例，你可以在在线 playground 上运行代码，访问链接：* [https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/play](https://www.typescriptlang.org/play)
    *，而不是在本地安装 TypeScript。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The tsconfig.json
    File</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tsconfig.json 文件</samp>
- en: 'Take a look at the basic structure of a *tsconfig.json* file. The content of
    the generated file depends on your installed TypeScript version, and there are
    around 100 configuration properties, but for most projects, only the following
    few are relevant:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 *tsconfig.json* 文件的基本结构。生成的文件内容取决于你安装的 TypeScript 版本，配置项大约有 100 个，但对于大多数项目，只有以下几个是相关的：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> option is a
    string that configures the path to another similar configuration file. Usually,
    this property extends a preset you used as a template with minor, project-specific
    tweaks. It works similarly to class-based inheritance in object-oriented programming.
    The preset overrides the base configuration, and the configuration’s key-value
    pairs overwrite the preset. The example shown here uses the recommended configuration
    file for TypeScript to override the default settings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">extends</samp> 选项是一个字符串，用于配置指向另一个类似配置文件的路径。通常，此属性会扩展你用作模板的预设，并做一些小的、特定于项目的调整。它的工作方式类似于面向对象编程中的基于类的继承。预设会覆盖基础配置，而配置中的键值对会覆盖预设。这里的示例使用了推荐的
    TypeScript 配置文件来覆盖默认设置。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> field
    configures the transpiling step. We list its options in [Appendix A](appendix-A.xhtml).
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> is
    an array of strings that specifies the patterns or filenames to include for transpiling.
    The value for <samp class="SANS_TheSansMonoCd_W5Regular_11">exclude</samp> is
    an array of strings that specifies patterns or filenames to exclude. Keep in mind
    that TSC applies these patterns on the list of files found with the included pattern.
    Usually, we don’t need to include or exclude files, as our whole project will
    consist of TypeScript code. Hence, we can leave the arrays empty.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Feedback
    with TypeScript</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most modern code editors have support for TypeScript, and they show us the errors
    generated by TSC directly inside the code. Remember the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function we used to explain how TypeScript verifies function contracts? [Figure
    3-1](chapter3.xhtml#fig3-1) is a screenshot from Visual Studio Code highlighting
    the type error and hinting at the solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-1: Working with TypeScript
    in Visual Studio Code</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: You can use any code editor or IDE you’d like to write your TypeScript code,
    though one that shows dynamic feedback like this is recommended.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Annotations</samp>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A type annotation is an optional way to explicitly tell the runtime environment
    which types to expect. You add them following this schema: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable:
    type</samp>. The following example shows a version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function in which we type both parameters as numbers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some developers tend to add types to everything in their code, and by doing
    so, they add noise that makes the code less readable. This antipattern, called
    *over-typing*, stems from a false understanding of how type annotations should
    work. The TypeScript compiler infers types from usage. Therefore, you don’t need
    to explicitly type everything. Instead, the code editor runs TSC in the background
    and leverages the results to display the inferred type information and compiler
    errors as you saw in the “Dynamic Feedback with TypeScript” section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Rather, type annotations are a way to ensure that code honors the API contracts.
    There are three scenarios in which you’ll want to verify the contract, and only
    one of them is especially important. The first scenario, upon a variable’s declaration,
    is usually not recommended. The second, annotating the return value of a function,
    is optional, whereas the third scenario, annotating a function’s parameters, is
    essential. We’ll now take a look at all three of these cases in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Variable</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most obvious place to type a variable is upon an assignment or declaration.
    [Listing 3-4](chapter3.xhtml#Lis3-4) demonstrates this by explicitly typing the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> as a string
    and then assigning it a string value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-4: Over-typing during the variable’s declaration'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, however, this is a form of over-typing, as you could instead
    leverage the compiler’s type inference. [Listing 3-5](chapter3.xhtml#Lis3-5) shows
    the alternative pattern of using type inference.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-5: Inferring the variable’s type based on its value'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Because TSC automatically infers the type of this variable, the code editor
    should show the type information when you hover over the variable. Without the
    explicit annotation, we have a much cleaner syntax and avoid the noise that the
    redundant type declaration adds to the code. This improves code readability, which
    is why this kind of over-typing is usually to be avoided.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Return
    Value</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although TypeScript can infer a function’s return type, you’ll usually want
    to annotate it explicitly. This code pattern ensures that the function’s contract
    is honored, as the compiler shows implementation errors where the function is
    defined instead of where it is used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use type annotations in this situation is that, as a programmer,
    you must explicitly define what a function does. By clarifying the function’s
    input and output types, you’ll gain a better understanding of what you actually
    want the function to do. [Listing 3-6](chapter3.xhtml#Lis3-6) shows you how to
    declare a function’s return type upon declaration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-6: Typing a function’s return value upon declaration'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We create a function that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable we declared earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable has the inferred string type. Hence, the function returns a string. Our
    type definition explicitly sets the function’s return type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declaring a Function’s
    Parameters</samp>
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s essential to annotate the parameters of a function, because TypeScript
    doesn’t have enough information to infer function parameters in most cases. By
    typing these parameters, you’re telling the compiler to check the types when you
    call the function and pass it arguments. Take a look at [Listing 3-7](chapter3.xhtml#Lis3-7)
    to see this pattern in action.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-7: Typing a function’s parameters'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Instead of declaring the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    variable as a constant inside the function, we want the returned value to be dynamic.
    Therefore, we modify the function to accept a parameter and return it immediately.
    We then call the function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    constant as a parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Good TypeScript code avoids noise and relies on inferring type annotations.
    It always annotates a function’s parameters and opts for annotated return values
    but never annotates local variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Types</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can use TypeScript and its annotations, you need to know what types
    are available to you. One of TypeScript’s main benefits is that it enables you
    to declare any of JavaScript’s primitive types explicitly. In addition, TypeScript
    adds its own types, the most important of which are <samp class="SANS_TheSansMonoCd_W5Regular_11">unions</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tuples</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. You can also define
    custom types and interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Primitive JavaScript
    Types</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript has five primitive types: strings, numbers, Booleans, undefined,
    and null. Everything else in the language is considered an object. [Listing 3-8](chapter3.xhtml#Lis3-8)
    shows the syntax for defining variables of these primitive JavaScript types with
    additional TypeScript type annotations. (Remember that, most of the time, you
    can just rely on the compiler’s type inference in this situation.)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-8: JavaScript’s primitive types with TypeScript’s type annotations'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: First we define a string variable and a Boolean with the TypeScript annotations.
    These are identical to strings and Booleans in JavaScript. Then we define two
    numbers. Like JavaScript, TypeScript uses a single generic type for numbers, without
    differentiating between integers and floating points. Finally, we look at TypeScript’s
    null and undefined types. These behave the same as JavaScript’s primitive types
    of the same name. *Null* refers to a value that either is empty or doesn’t exist,
    and it indicates the intentional absence of a value. In contrast, *undefined*
    indicates the unintentional absence of a value. We did not assign a value in [Listing
    3-5](chapter3.xhtml#Lis3-5) for the undefined type, because we don’t know it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The union Type</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few additional types you should know about, because the more precise
    your type annotations are, the more helpful you’ll find TSC to be. TypeScript
    introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type
    to the JavaScript ecosystem. *Unions* are variables or parameters that can have
    more than one data type. [Listing 3-9](chapter3.xhtml#Lis3-9) shows an example
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> type that can
    be a string or a number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-9: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">union</samp>
    type'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: We declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-type
    variable that can contain either a string or a number, but nothing else. As soon
    as we assign a Boolean variable, TSC throws an error, and the IDE shows the message
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type 'boolean' is not assignable
    to type 'string | number'</samp>.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: While you might find <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>
    types useful for annotating function parameters and arrays that can contain different
    types, you should use them sparingly and avoid them whenever possible. This is
    because, before working with <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>-typed
    items, you need to perform additional manual type checks; otherwise, they could
    cause errors. For example, if you iterated over an array of strings or numbers
    and then added all items, you would first need to convert all strings to numbers.
    Otherwise, JavaScript would implicitly convert the numbers to strings, as shown
    earlier in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The array Type</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript provides a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    type that offers array functions similar to JavaScript’s array. However, take
    a close look at the syntax for typing the array, shown in [Listing 3-10](chapter3.xhtml#Lis3-10).
    You’ll notice that the type of the array depends on the type of the array items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-10: Typed arrays'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: First we define an array without specifying the type of its items. Unfortunately,
    what seems to be a definition of a generic array leads to issues down the road.
    As soon as we try to add a value, TSC throws the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Argument
    of type 'number' is not assignable to parameter of type 'never'</samp>, because
    the array is not typed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need to type the items in the array. Therefore, we create an array,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">numberArray</samp>, in which each
    item has the type of number. Now we can add numeric values to the array without
    running into errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The object Type</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    type is the same as JavaScript’s object. Although you can define the properties’
    types for TSC to type-check, the compiler can’t ensure the order of the properties.
    Nonetheless, it typechecks them, as shown in [Listing 3-11](chapter3.xhtml#Lis3-11).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-11: Typed objects'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we define an object with three properties: two that take a string and
    another that takes a number. Then we try to assign a number to the property <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> annotated as a string.
    Now TSC notifies us with an error explaining that we assigned a value of the wrong
    type.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Note that, usually, you should avoid typing objects inline, as in this example.
    Instead, it is a best practice to create a custom type, which is reusable and
    avoids cluttering our code, enhancing its readability. We discuss how to create
    and use them in “Custom Types and Interfaces” on page 44.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">tuple</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another common type that TypeScript adds to JavaScript is the <samp class="SANS_TheSansMonoCd_W5Regular_11">tuple</samp>
    type. Shown in [Listing 3-12](chapter3.xhtml#Lis3-12), *tuples* are arrays with
    a specified number of typed items. TypeScript’s tuples are similar to those you
    might have encountered in programming languages such as Python and C#.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-12: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tuple</samp>
    type'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We define two tuples. In both, the first array item is a string, and the second
    is a number. If the type, order, or number of items added to the tuple differs
    from the tuple’s declaration, TSC throws an error. Here the first assignment is
    acceptable, whereas the second one throws two errors indicating a mismatch in
    types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">any</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> type is
    generic, meaning it can take any value, and you should avoid using it. As you
    can see in [Listing 3-13](chapter3.xhtml#Lis3-13), it accepts all values without
    throwing an error, which defeats the purpose of static typing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-13: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp> might seem like
    an easy choice, and it is tempting to rely on it as an escape hatch. Avoid this
    at all costs. When you pass <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    as a value to, say, a function, you break the contract you specified in the function
    declaration, and when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    to define the contract, there effectively isn’t one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To view a scenario in which using the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type causes problems, take a look at [Listing 3-14](chapter3.xhtml#Lis3-14).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-14: Problems caused by the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">any</samp>
    type'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">calculate</samp>
    function, which adds two numbers. When we pass two numeric values, we receive
    the expected output of <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
    In a previous example, we typed the parameters as numbers, thus preventing the
    use of invalid types as arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: However, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    instead of a number and pass a string to the function, TSC doesn’t throw an error.
    JavaScript implicitly converts the number to a string and returns an unexpected
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>. We saw this
    behavior at the beginning of the chapter, in the untyped version of the function.
    As you can see, using <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    is the same as using no types at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: While convenient, the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type masks your bugs during programming and hides your type designs, rendering
    type-checking useless. It also prevents your IDE from displaying errors and invalid
    types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type</samp>
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type
    is the opposite of <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>: it
    indicates no type at all. Its only use case is to annotate the return value of
    a function that shouldn’t have one, as shown in [Listing 3-15](chapter3.xhtml#Lis3-15).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-15: TypeScript’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">void</samp>
    type'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The custom log function we define here passes a parameter to the console. It
    doesn’t return anything, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the return type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about TypeScript types and other important details of the language,
    take a look at *The TypeScript Handbook* at [*https://<wbr>www<wbr>.typescriptlang<wbr>.org<wbr>/docs<wbr>/handbook<wbr>/intro<wbr>.html*](https://www.typescriptlang.org/docs/handbook/intro.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Custom Types and Interfaces</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous sections introduced you to enough TypeScript to begin using the
    language. However, you’ll find it helpful to know a few more advanced concepts.
    This section shows you how to create custom types and use untyped third-party
    libraries in your TypeScript code. You’ll also learn when to create a new type
    and use a custom interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: While working with TypeScript, remember that a TypeScript file *without* top-level
    imports or exports is not a module; therefore, it runs in the *global* scope.
    Consequently, all of its declarations are accessible in other modules. By contrast,
    a TypeScript file *with* top-level imports or exports is its own module, and all
    declarations are limited to the *module* scope, meaning they’re available in the
    scope of this module only.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TypeScript lets you define custom types by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    keyword. Custom types are a great way to simplify your code. To see how, take
    a second look at the code shown back in [Listing 3-8](chapter3.xhtml#Lis3-8),
    when you created a typed object. Now consider [Listing 3-16](chapter3.xhtml#Lis3-16),
    which optimizes the code with a custom type definition. You should find it much
    cleaner and easier to read.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-16: Custom types for typed objects with TypeScript'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: We create a custom type, <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>,
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> keyword. Note
    that the overall syntax is similar to that used to define an object; we use the
    equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) to assign
    the definition to the custom type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom type has two required properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>. In addition,
    it has an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> property,
    as indicated by the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>).
    Now when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">getWeatherDetail</samp>
    function, we can annotate the parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherDetail</samp>,
    as an object with a type of <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>.
    Using this technique, we avoid using inline annotations and can reuse our custom
    type later, such as to annotate the return type of a function.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Interfaces</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to types, TypeScript has interfaces. However, the difference between
    a type and an interface is blurry. You can freely decide which one to use, so
    long as you follow a convention in your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In general, we consider a *type* definition to answer the question, “Which type
    is this data?” A possible answer might be a union or a tuple. An *interface* is
    a way to describe the shape of some data, such as the properties of an object.
    It answers the question, “Which properties does this object have?” The most practical
    difference is that, unlike an interface, we cannot directly modify a type after
    we’ve declared it. For an in-depth look at the distinction, consult *The TypeScript
    Handbook*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, use an interface to define a new object or the method of
    an object. More generally, consider using interfaces over types, as they provide
    more precise error messages. A classic React use case for interfaces is to define
    the properties of a specific component. [Listing 3-17](chapter3.xhtml#Lis3-17)
    shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to create a new interface to replace the type in [Listing 3-16](chapter3.xhtml#Lis3-16).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-17: Custom interfaces for TypeScript functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword to define a new interface. Unlike a custom type’s definition, an interface
    definition does not use the equal sign to assign the interface’s properties to
    its name. We then use the custom interface to type the properties object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">props</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">weatherComponent</samp>,
    which returns a string.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Type Declaration
    Files</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use custom types universally, you can define them in *type declaration files*,
    which have the *.d.ts* extension. Unlike regular TypeScript files with the *.ts*
    or *.tsx* extension, type declaration files shouldn’t contain any implementation
    code. Instead, TSC uses these type definitions to understand custom types and
    perform type checks. They aren’t transpiled to JavaScript and are never part of
    the executed script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Type declaration files prove useful when you find yourself working with external
    code bases. Often, third-party libraries aren’t written in TypeScript. Therefore,
    they don’t provide type declaration files for their code bases. Luckily, the DefinitelyTyped
    repository at [*http://<wbr>definitelytyped<wbr>.github<wbr>.io*](http://definitelytyped.github.io)
    provides type declaration files for more than 7,000 libraries. Use these files
    to add TypeScript support to these libraries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Type declaration files are collected under the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope in npm. This scope holds all the declarations from DefinitelyTyped. Hence,
    they are easy to find and are grouped next to each other in your *package.json*
    file. All type declaration files from the <samp class="SANS_TheSansMonoCd_W5Regular_11">@types</samp>
    scope should be considered development dependencies of your project. Hence, we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--save-dev</samp> flag on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install</samp> command to
    add them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-18](chapter3.xhtml#Lis3-18) shows a minimal example of a type declaration
    file that exports a type and interface for an API.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-18: Defining custom types and interfaces'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Save these definitions in a file called *custom.d.ts* in your root directory.
    TSC should automatically load these definitions. You can now use the types and
    interfaces from the file in your TypeScript modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3: Extend Express.js with
    TypeScript</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use your new knowledge of TypeScript to rewrite the Express.js server
    you created in Exercises 1 and 2\. In addition to adding type annotations, we’ll
    add a new route to the server by using custom types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Begin by adding TypeScript to the project following the steps described in
    “Setting Up TypeScript” on page 36. Next, because Express.js isn’t typed, add
    type definitions from DefinitelyTyped to your project by running the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Your *package.json* file should now look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you can create configuration and type declaration files for the project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the tsconfig.json
    File</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Either create a new *tsconfig.json* file in the *sample-express* folder, next
    to the *index.ts* file, or open the one you created earlier. Then add or replace
    its content with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We configure TypeScript for our simple Express.js server, which requires only
    a few settings. We use ES.Next modules for our TypeScript code, and because we
    want to keep them after transpiling the TypeScript to JavaScript, we set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">module</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>. The *express* package
    is a CommonJS module. Therefore, we need to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">esModuleInterop</samp>
    option and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">moduleResolution</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>. Finally, we use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">noImplicitAny</samp> option
    to disallow the implicit use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">any</samp>
    type and require explicit typing. [Appendix A](appendix-A.xhtml) describes these
    configuration options in more detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Custom Types</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our server, we’ll follow a simple rule of thumb: every time we use an object,
    we should consider adding a custom type or interface to our project. If the object
    is a function parameter, we’ll create a custom interface. If we use this particular
    object more than once, we’ll create a custom type.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: To define the custom types for this sample project, we create a file *custom.d.ts*
    next to the *index.ts* file in the *sample-express* folder and add the code from
    [Listing 3-19](chapter3.xhtml#Lis3-19).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-19: The custom.d.ts file'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We create two custom types and an interface. One defines the response items
    of the asynchronous API call. The other type and the interface are similar to
    examples shown earlier in this chapter. They are necessary for the new weather
    route we will create shortly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the routes.ts File</samp>
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we must add type annotations to our server code. Rename the *routes.js*
    file in the *sample-express* folder to *routes.ts* to enable the TSC for this
    file. You should instantly see the errors and warnings appear in your editor.
    Take some time to look at these and then adjust the contents to match the code
    in [Listing 3-20](chapter3.xhtml#Lis3-20). We’ve bolded all type annotations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-20: The typed routes.ts file'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Following the principle discussed in “Type Annotations” on page 38, we annotate
    only a function’s parameters and return types. We also annotate local variables
    only when their types cannot be inferred, as when converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    response to JSON. Here we need to explicitly type the variable with our custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> and cast
    the conversion’s return value as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp>s.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the listing, we create the functions for the additional weather
    route. We use the custom interface for typing both functions’ parameters and the
    custom type for their return types. In this basic example, the query function
    returns mostly static data, except the ZIP code, which it takes from the passed
    parameters. A regular implementation would query a database with the ZIP code
    and retrieve actual data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the new route for the weather endpoint to the <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp>
    statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Annotations
    to the index.ts File</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rename the file *index.js* in the *sample-express* folder to *index.ts* and
    adjust the code to match [Listing 3-20](chapter3.xhtml#Lis3-20). In addition to
    the necessary type annotations, create a new endpoint and follow the TypeScript
    convention to prefix unused parameters with an underscore (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>),
    shown in [Listing 3-21](chapter3.xhtml#Lis3-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-21: The typed index.ts file'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: First we import the new weather route from the available routes and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Request</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Response</samp>
    types from the *express* package. These are all named exports. Thus, we use curly
    brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Then, following best practices, we add code annotations and, at the same time,
    prefix the unused <samp class="SANS_TheSansMonoCd_W5Regular_11">req</samp> parameters
    with an underscore. TSC will follow the convention of functional programming languages
    by ignoring these parameters. The *api/names* entry point is marked as an async
    function, so it needs to return a value wrapped in a promise. Hence, nothing is
    returned, and we return <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    as the promise’s value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines of code, we create an additional route for a new */api/weather/:zipcode*
    endpoint. The colon (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>) creates
    a parameter on the request’s <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>
    object. We retrieve the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params .zipcode</samp>
    and pass it down to the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeWeather</samp>
    function. Note that there is no underscore on the request parameter this time.
    Finally, we use the same function as before to start the Express.js server and
    listen to port 3000.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transpiling and Running
    the Code</samp>
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To transpile the code with the TypeScript compiler to JavaScript, run TSC with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> on the command line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'TSC generates two new files, *index.js* and *routes.js*, from the TypeScript
    files. Start the server from your command line with the regular Node.js call:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now visit *http://localhost:3000/api/weather/12345* in your browser. You should
    see the weather details with the ZIP code 12345, as shown in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 3-2: Browser response
    from the Node.js web server</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Success! You wrote your first TypeScript application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter taught you what you need to know about TypeScript to create a full-stack
    application. We set up TypeScript and TSC in a new project, then discussed its
    most important configuration options. Next, you learned to use TypeScript efficiently,
    leveraging type-annotation inference to avoid over-typing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed primitive and advanced built-in types and how to create custom
    types and interfaces. Finally, you used your new knowledge to add TypeScript to
    the Express.js server built in previous exercises and refactored the code with
    type annotations, custom types, and interfaces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: If you want to become a TypeScript expert, I recommend *The TypeScript Handbook*
    and the tutorials at [*https://<wbr>www<wbr>.typescripttutorial<wbr>.net*](https://www.typescripttutorial.net).
    In the next chapter, you’ll get to know React, a declarative JavaScript library
    for building user interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
