<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_340"/><span epub:type="pagebreak" id="page_341"/><strong><span class="big">11</span><br/>SMART POINTERS</strong></h2>&#13;
<p class="quote"><em>If you want to do a few small things right, do them yourself. If you want to do great things and make a big impact, learn to delegate.<br/>—John C. Maxwell</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="indent">In this chapter, you’ll explore stdlib and Boost libraries. These libraries contain a collection of smart pointers, which manage dynamic objects with the RAII paradigm you learned in <a href="ch04.xhtml#ch04">Chapter 4</a>. They also facilitate the most powerful resource management model in any programming language. Because some smart pointers use <em>allocators</em> to customize dynamic memory allocation, the chapter also outlines how to provide a user-defined allocator.</p>&#13;
<h3 class="h3" id="ch11lev1sec1"><strong>Smart Pointers</strong></h3>&#13;
<p class="noindent">Dynamic objects have the most flexible lifetimes. With great flexibility comes great responsibility, so you must make sure each dynamic object gets destructed <em>exactly</em> once. This might not look daunting with small programs, but looks can be deceiving. Just consider how exceptions factor <span epub:type="pagebreak" id="page_342"/>into dynamic memory management. Each time an error or an exception could occur, you need to keep track of which allocations you’ve made successfully and be sure to release them in the correct order.</p>&#13;
<p class="indent">Fortunately, you can use RAII to handle such tedium. By acquiring dynamic storage in the constructor of the RAII object and releasing dynamic storage in the destructor, it’s relatively difficult to leak (or double free) dynamic memory. This enables you to manage dynamic object lifetimes using move and copy semantics.</p>&#13;
<p class="indent">You could write these RAII objects yourself, but you can also use some excellent prewritten implementations called <em>smart pointers</em>. Smart pointers are class templates that behave like pointers and implement RAII for dynamic objects.</p>&#13;
<p class="indent">This section delves into five available options included in stdlib and Boost: scoped, unique, shared, weak, and intrusive pointers. Their ownership models differentiate these five smart pointer categories.</p>&#13;
<h3 class="h3" id="ch11lev1sec2"><strong>Smart Pointer Ownership</strong></h3>&#13;
<p class="noindent">Every smart pointer has an <em>ownership</em> model that specifies its relationship with a dynamically allocated object. When a smart pointer owns an object, the smart pointer’s lifetime is guaranteed to be at least as long as the object’s. Put another way, when you use a smart pointer, you can rest assured that the pointed-to object is alive and that the pointed-to object won’t leak. The smart pointer manages the object it owns, so you can’t forget to destroy it thanks to RAII.</p>&#13;
<p class="indent">When considering which smart pointer to use, your ownership requirements drive your choice.</p>&#13;
<h3 class="h3" id="ch11lev1sec3"><strong>Scoped Pointers</strong></h3>&#13;
<p class="noindent">A <em>scoped pointer</em> expresses <em>non-transferable</em>, <em>exclusive ownership</em> over a single dynamic object. Non-transferable means that the scoped pointers cannot be moved from one scope to another. Exclusive ownership means that they can’t be copied, so no other smart pointers can have ownership of a scoped pointer’s dynamic object. (Recall from “Memory Management” on <a href="ch04.xhtml#page_90">page 90</a> that an object’s scope is where it’s visible to the program.)</p>&#13;
<p class="indent">The <code>boost::scoped_ptr</code> is defined in the <code>&lt;boost/smart_ptr/scoped_ptr.hpp&gt;</code> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is no stdlib scoped pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec1"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <code>boost::scoped_ptr</code> takes a single template parameter corresponding to the pointed-to type, as in <code>boost::scoped_ptr&lt;int&gt;</code> for a “scoped pointer to <code>int</code>” type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_343"/>All smart pointers, including scoped pointers, have two modes: <em>empty</em> and <em>full</em>. An empty smart pointer owns no object and is roughly analogous to a <code>nullptr</code>. When a smart pointer is default constructed, it begins life empty.</p>&#13;
<p class="indent">The scoped pointer provides a constructor taking a raw pointer. (The pointed-to type must match the template parameter.) This creates a full-scoped pointer. The usual idiom is to create a dynamic object with <code>new</code> and pass the result to the constructor, like this:</p>&#13;
<pre>boost::scoped_ptr&lt;PointedToType&gt; my_ptr{ new PointedToType };</pre>&#13;
<p class="indent">This line dynamically allocates a <code>PointedToType</code> and passes its pointer to the scoped pointer constructor.</p>&#13;
<h4 class="h4" id="ch11lev2sec2"><strong><em>Bring in the Oath Breakers</em></strong></h4>&#13;
<p class="noindent">To explore scoped pointers, let’s create a Catch unit-test suite and a <code>DeadMenOfDunharrow</code> class that keeps track of how many objects are alive, as shown in <a href="ch11.xhtml#ch11ex01">Listing 11-1</a>.</p>&#13;
<pre>#define CATCH_CONFIG_MAIN <span class="ent">➊</span>&#13;
#include "catch.hpp" <span class="ent">➋</span>&#13;
#include &lt;boost/smart_ptr/scoped_ptr.hpp&gt; <span class="ent">➌</span>&#13;
&#13;
struct DeadMenOfDunharrow { <span class="ent">➍</span>&#13;
  DeadMenOfDunharrow(const char* m="") <span class="ent">➎</span>&#13;
    : message{ m } {&#13;
    oaths_to_fulfill++; <span class="ent">➏</span>&#13;
  }&#13;
  ~DeadMenOfDunharrow() {&#13;
    oaths_to_fulfill--; <span class="ent">➐</span>&#13;
  }&#13;
  const char* message;&#13;
  static int oaths_to_fulfill;&#13;
};&#13;
int DeadMenOfDunharrow::oaths_to_fulfill{};&#13;
using ScopedOathbreakers = boost::scoped_ptr&lt;DeadMenOfDunharrow&gt;; <span class="ent">➑</span></pre>&#13;
<p class="listing"><a id="ch11ex01"/><em>Listing 11-1: Setting up a Catch unit-test suite with a <code>DeadMenOfDunharrow</code> class to investigate scoped pointers</em></p>&#13;
<p class="indent">First, you declare <code>CATCH_CONFIG_MAIN</code> so Catch will provide an entry point <span class="ent">➊</span> and include the Catch header <span class="ent">➋</span> and then the Boost scoped pointer’s header <span class="ent">➌</span>. Next, you declare the <code>DeadMenOfDunharrow</code> class <span class="ent">➍</span>,which takes an optional null-terminated string that you save into the <code>message</code> field <span class="ent">➎</span>. The <code>static int</code> field called <code>oaths_to_fulfill</code> tracks how many <code>DeadMenOfDunharrow</code> objects have been constructed. Accordingly, you increment in the constructor <span class="ent">➏</span>, and you decrement in the destructor <span class="ent">➐</span>. Finally, you declare the <code>ScopedOathbreakers</code> type alias for convenience <span class="ent">➑</span>.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_344"/><strong>CATCH LISTINGS</strong></p>&#13;
<p class="noindent">You’ll use Catch unit tests in most listings from now on. For conciseness, the listings omit the following Catch ceremony:</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"</pre>&#13;
<p class="indent">All listings containing <code>TEST_CASE</code> require this preamble.</p>&#13;
<p class="indent">Also, every test case in each listing passes unless a comment indicates otherwise. Again, for conciseness, the listings omit the All tests pass output from the listings.</p>&#13;
<p class="indent">Finally, tests that employ user-defined types, functions, and variables from a previous listing will omit them for brevity.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec3"><strong><em>Implicit bool Conversion Based on Ownership</em></strong></h4>&#13;
<p class="noindent">Sometimes you need to determine whether a scoped pointer owns an object or whether it’s empty. Conveniently, <code>scoped_ptr</code> casts implicitly to <code>bool</code> depending on its ownership status: <code>true</code> if it owns an object; <code>false</code> otherwise. <a href="ch11.xhtml#ch11ex02">Listing 11-2</a> illustrates how this implicit casting behavior works.</p>&#13;
<pre>TEST_CASE("ScopedPtr evaluates to") {&#13;
  SECTION("true when full") {&#13;
    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➊</span>&#13;
    REQUIRE(aragorn); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("false when empty") {&#13;
    ScopedOathbreakers aragorn; <span class="ent">➌</span>&#13;
    REQUIRE_FALSE(aragorn); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex02"/><em>Listing 11-2: The boost::scoped_ptr casts implicitly to <code>bool</code>.</em></p>&#13;
<p class="indent">When you use the constructor taking a pointer <span class="ent">➊</span>, the <code>scoped_ptr</code> converts to <code>true</code> <span class="ent">➋</span>. When you use the default constructor <span class="ent">➌</span>, the <code>scoped_ptr</code> converts to <code>false<span class="ent">➍</code>.</span></p>&#13;
<h4 class="h4" id="ch11lev2sec4"><strong><em>RAII Wrapper</em></strong></h4>&#13;
<p class="noindent">When a <code>scoped_ptr</code> owns a dynamic object, it ensures proper dynamic object management. In the <code>scoped_ptr</code> destructor, it checks whether it owns an object. If it does, the <code>scoped_ptr</code> destructor deletes the dynamic object.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex03">Listing 11-3</a> illustrates this behavior by investigating the static <code>oaths_to_fulfill</code> variable between scoped pointer initializations.</p>&#13;
<pre><span epub:type="pagebreak" id="page_345"/>TEST_CASE("ScopedPtr is an RAII wrapper.") {&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); <span class="ent">➊</span>&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➋</span>&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➌</span>&#13;
  {&#13;
    ScopedOathbreakers legolas{ new DeadMenOfDunharrow{} }; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
  } <span class="ent">➏</span>&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex03"/><em>Listing 11-3: The <code>boost::scoped_ptr</code> is an RAII wrapper.</em></p>&#13;
<p class="indent">At the beginning of the test, <code>oaths_to_fulfill</code> is 0 because you haven’t constructed any <code>DeadMenOfDunharrow</code> yet <span class="ent">➊</span>. You construct the scoped pointer <code>aragorn</code> and pass in a pointer to the dynamic <code>DeadMenOfDunharrow</code> object <span class="ent">➋</span>. This increments the <code>oaths_to_fulfill</code> to 1 <span class="ent">➌</span>. Within a nested scope, you declare another scoped pointer <code>legolas</code> <span class="ent">➍</span>. Because <code>aragorn</code> is still alive, <code>oaths_to_fulfill</code> is now 2 <span class="ent">➎</span>. Once the inner scope closes, <code>legolas</code> falls out of scope and destructs, taking a <code>DeadMenOfDunharrow</code> with it <span class="ent">➏</span>. This decrements <code>DeadMenOfDunharrow</code> to 1 <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec5"><strong><em>Pointer Semantics</em></strong></h4>&#13;
<p class="noindent">For convenience, <code>scoped_ptr</code> implements the dereference <code>operator*</code> and the member dereference <code>operator-&gt;</code>, which simply delegate the calls to the owned dynamic object. You can even extract a raw pointer from a <code>scoped_ptr</code> with the <code>get</code> method, as demonstrated in <a href="ch11.xhtml#ch11ex04">Listing 11-4</a>.</p>&#13;
<pre>TEST_CASE("ScopedPtr supports pointer semantics, like") {&#13;
  auto message = "The way is shut";&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{ message } }; <span class="ent">➊</span>&#13;
  SECTION("operator*") {&#13;
    REQUIRE((*aragorn).message == message); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("operator-&gt;") {&#13;
    REQUIRE(aragorn-&gt;message == message); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("get(), which returns a raw pointer") {&#13;
    REQUIRE(aragorn.get() != nullptr); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex04"/><em>Listing 11-4: The boost::scoped_ptr supports pointer semantics.</em></p>&#13;
<p class="indent">You construct the scoped pointer <code>aragorn</code> with a <code>message</code> of <code>The way is</code> <code>shut</code> <span class="ent">➊</span>, which you use in three separate scenarios to test pointer semantics. First, you can use <code>operator*</code> to dereference the underlying, pointed-to dynamic object. In the example, you dereference <code>aragorn</code> and extract the <code>message</code> to verify that it matches <span class="ent">➋</span>. You can also use <code>operator-&gt;</code> to perform member dereference <span class="ent">➌</span>. Finally, if you want a raw pointer to the dynamic object, you can use the <code>get</code> method to extract it <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec6"><span epub:type="pagebreak" id="page_346"/><strong><em>Comparison with nullptr</em></strong></h4>&#13;
<p class="noindent">The <code>scoped_ptr</code> class template implements the comparison operators <code>operator==</code> and <code>operator!=</code>, which are only defined when comparing a <code>scoped_ptr</code> with a <code>nullptr</code>. Functionally, this is essentially identical to implicit <code>bool</code> conversion, as <a href="ch11.xhtml#ch11ex05">Listing 11-5</a> illustrates.</p>&#13;
<pre>TEST_CASE("ScopedPtr supports comparison with nullptr") {&#13;
  SECTION("operator==") {&#13;
    ScopedOathbreakers legolas{};&#13;
    REQUIRE(legolas == nullptr); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("operator!=") {&#13;
    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} };&#13;
    REQUIRE(aragorn != nullptr); <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex05"/><em>Listing 11-5: The <code>boost::scoped_ptr</code> supports comparison with <code>nullptr</code>.</em></p>&#13;
<p class="indent">An empty scoped pointer equals (<code>==</code>) <code>nullptr</code> <span class="ent">➊</span>, whereas a full scoped pointer doesn’t equal (<code>!=</code>) <code>nullptr</code> <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec7"><strong><em>Swapping</em></strong></h4>&#13;
<p class="noindent">Sometimes you want to switch the dynamic object owned by a <code>scoped_ptr</code> with the dynamic object owned by another <code>scoped_ptr</code>. This is called an <em>object swap</em>, and <code>scoped_ptr</code> contains a <code>swap</code> method that implements this behavior, as shown in <a href="ch11.xhtml#ch11ex06">Listing 11-6.</a></p>&#13;
<pre>TEST_CASE("ScopedPtr supports swap") {&#13;
  auto message1 = "The way is shut.";&#13;
  auto message2 = "Until the time comes.";&#13;
  ScopedOathbreakers aragorn {&#13;
    new DeadMenOfDunharrow{ message1 } <span class="ent">➊</span>&#13;
  };&#13;
  ScopedOathbreakers legolas {&#13;
    new DeadMenOfDunharrow{ message2 } <span class="ent">➋</span>&#13;
  };&#13;
  aragorn.swap(legolas); <span class="ent">➌</span>&#13;
  REQUIRE(legolas-&gt;message == message1); <span class="ent">➍</span>&#13;
  REQUIRE(aragorn-&gt;message == message2); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex06"/><em>Listing 11-6: The boost::scoped_ptr supports <code>swap</code>.</em></p>&#13;
<p class="indent">You construct two <code>scoped_ptr</code> objects, <code>aragorn</code> <span class="ent">➊</span> and <code>legolas</code> <span class="ent">➋</span>, each with a different message. After you perform a swap between <code>aragorn</code> and <code>legolas</code> <span class="ent">➌</span>, they exchange dynamic objects. When you pull out their messages after the swap, you find that they’ve switched <span class="ent">➍</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec8"><span epub:type="pagebreak" id="page_347"/><strong><em>Resetting and Replacing a scoped_ptr</em></strong></h4>&#13;
<p class="noindent">Rarely do you want to destruct an object owned by <code>scoped_ptr</code> before the <code>scoped_ptr</code> dies. For example, you might want to replace its owned object with a new dynamic object. You can handle both of these tasks with the overloaded <code>reset</code> method of <code>scoped_ptr</code>.</p>&#13;
<p class="indent">If you provide no argument, <code>reset</code> simply destroys the owned object.</p>&#13;
<p class="indent">If you instead provide a new dynamic object as a parameter, <code>reset</code> will first destroy the currently owned object and then gain ownership of the parameter. <a href="ch11.xhtml#ch11ex07">Listing 11-7</a> illustrates such behavior with one test for each scenario.</p>&#13;
<pre>TEST_CASE("ScopedPtr reset") {&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➊</span>&#13;
  SECTION("destructs owned object.") {&#13;
    aragorn.reset(); <span class="ent">➋</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("can replace an owned object.") {&#13;
    auto message = "It was made by those who are Dead.";&#13;
    auto new_dead_men = new DeadMenOfDunharrow{ message }; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
    aragorn.reset(new_dead_men); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
    REQUIRE(aragorn-&gt;message == new_dead_men-&gt;message); <span class="ent">➑</span>&#13;
    REQUIRE(aragorn.get() == new_dead_men); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex07"/><em>Listing 11-7: The boost::scoped_ptr supports <code>reset</code>.</em></p>&#13;
<p class="indent">The first step in both tests is to construct the scoped pointer <code>aragorn</code> owning a <code>DeadMenOfDunharrow</code> <span class="ent">➊</span>. In the first test, you call <code>reset</code> without an argument <span class="ent">➋</span>. This causes the scoped pointer to destruct its owned object, and <code>oaths_to_fulfill</code> decrements to 0 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second test, you create the new, dynamically allocated <code>new_dead_men</code> with a custom <code>message</code> <span class="ent">➍</span>. This increases the <code>oaths_to_fill</code> to 2, because <code>ara</code><code>gorn</code> is also still alive <span class="ent">➎</span>. Next, you invoke <code>reset</code> with <code>new_dead_men</code> as the argument <span class="ent">➏</span>, which does two things:</p>&#13;
<ul>&#13;
<li class="noindent">It causes the original <code>DeadMenOfDunharrow</code> owned by <code>aragorn</code> to get destructed, which decrements <code>oaths_to_fulfill</code> to 1 <span class="ent">➐</span>.</li>&#13;
<li class="noindent">It emplaces <code>new_dead_men</code> as the dynamically allocated object owned by <code>aragorn</code>. When you dereference the <code>message</code> field, notice that it matches the <code>message</code> held by <code>new_dead_men</code> <span class="ent">➑</span>. (Equivalently, <code>aragorn.get()</code> yields <code>new_dead_men</code> <span class="ent">➒</span>.)</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch11lev2sec9"><span epub:type="pagebreak" id="page_348"/><strong><em>Non-transferability</em></strong></h4>&#13;
<p class="indent">You cannot move or copy a <code>scoped_ptr</code>, making it non-transferable. <a href="ch11.xhtml#ch11ex08">Listing 11-8</a> illustrates how attempting to move or copy a <code>scoped_ptr</code> results in an invalid program.</p>&#13;
<pre>void by_ref(const ScopedOathbreakers&amp;) { } <span class="ent">➊</span>&#13;
void by_val(ScopedOathbreakers) { } <span class="ent">➋</span>&#13;
&#13;
TEST_CASE("ScopedPtr can") {&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow };&#13;
  SECTION("be passed by reference") {&#13;
    by_ref(aragorn); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("not be copied") {&#13;
    // DOES NOT COMPILE:&#13;
    by_val(aragorn); <span class="ent">➍</span>&#13;
    auto son_of_arathorn = aragorn; <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("not be moved") {&#13;
    // DOES NOT COMPILE:&#13;
    by_val(std::move(aragorn)); <span class="ent">➏</span>&#13;
    auto son_of_arathorn = std::move(aragorn); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex08"/><em>Listing 11-8: The <code>boost::scoped_ptr</code> is non-transferable. (This code doesn’t compile.)</em></p>&#13;
<p class="indent">First, you declare dummy functions that take a <code>scoped_ptr</code> by reference <span class="ent">➊</span> and by value <span class="ent">➋</span>. You can still pass a <code>scoped_ptr</code> by reference <span class="ent">➌</span>, but attempting to pass one by value will fail to compile <span class="ent">➍</span>. Also, attempting to use the <code>scoped_ptr</code> copy constructor or a copy assignment operator <span class="ent">➎</span> will fail to compile. In addition, if you try to move a <code>scoped_ptr</code> with <code>std::move</code>, your code won’t compile <span class="ent">➏</span><span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Generally, using a <span class="codeitalic">boost::scoped_ptr</span> incurs no overhead compared with using a raw pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec10"><strong><em>boost::scoped_array</em></strong></h4>&#13;
<p class="noindent">The <code>boost::scoped_array</code> is a scoped pointer for dynamic arrays. It supports the same usages as a <code>boost::scoped_ptr</code>, but it also implements an <code>operator[]</code> so you can interact with elements of the scoped array in the same way as you can with a raw array. <a href="ch11.xhtml#ch11ex09">Listing 11-9</a> illustrates this additional feature.</p>&#13;
<pre>TEST_CASE("ScopedArray supports operator[]") {&#13;
  boost::scoped_array&lt;int<span class="ent">➊</span>&gt; squares{&#13;
    new int<span class="ent">➋</span>[5] { 0, 4, 9, 16, 25 }&#13;
  };&#13;
  squares[0] = 1; <span class="ent">➌</span>&#13;
  REQUIRE(squares[0] == 1); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_349"/>  REQUIRE(squares[1] == 4);&#13;
  REQUIRE(squares[2] == 9);&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex09"/><em>Listing 11-9: The <code>boost::scoped_array</code> implements <code>operator[]</code>.</em></p>&#13;
<p class="indent">You declare a <code>scoped_array</code> the same way you declare a <code>scoped_ptr</code>, by using a single template parameter <span class="ent">➊</span>. In the case of <code>scoped_array</code>, the template parameter is the type contained by the array <span class="ent">➋</span>, not the type of the array. You pass in a dynamic array to the constructor of <code>squares</code>, making the dynamic array <code>squares</code> the array’s owner. You can use <code>operator[]</code> to write <span class="ent">➌</span> and read <span class="ent">➍</span> elements.</p>&#13;
<h4 class="h4" id="ch11lev2sec11"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent">So far, you’ve learned about the major features of scoped pointers. For reference, <a href="ch11.xhtml#ch11tab01">Table 11-1</a> enumerates all the operators discussed, plus a few that haven’t been covered yet. In the table, <code>ptr</code> is a raw pointer and <code>s_ptr</code> is a scoped pointer. See the Boost documentation for more information.</p>&#13;
<p class="tabcap"><a id="ch11tab01"/><strong>Table 11-1:</strong> All of the Supported <code>boost::scoped_ptr</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>scoped_ptr&lt;...&gt;{ }</code> or <code>scoped_ptr &lt;...&gt;{ nullptr }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty scoped pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>scoped_ptr &lt;...&gt;{</code> <span class="codestrong">ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a scoped pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~scoped_ptr&lt;...&gt;()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls <code>delete</code> on the owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr1</span><code>.swap(</code><span class="codestrong">s_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges owned objects between <span class="codestrong">s_ptr1</span> and <span class="codestrong">s_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>swap(</code><span class="codestrong">s_ptr1, s_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A free function identical to the <code>swap</code> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr</span><code>.reset()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If full, calls <code>delete</code> on object owned by <span class="codestrong">s_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s_ptr</span><code>.reset(</code><span class="codestrong">ptr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deletes currently owned object and then takes ownership of <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ptr</span> <code>=</code> <span class="codestrong">s_ptr</span><code>.get()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the raw pointer <code>ptr</code>; <code>s_ptr</code> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">s_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr</span><code>-&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member dereferences operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>bool{</code> <span class="codestrong">s_ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>bool</code> conversion: <code>true</code> if full, <code>false</code> if empty.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec4"><strong>Unique Pointers</strong></h3>&#13;
<p class="indent">A <em>unique pointer</em> has transferable, exclusive ownership over a single dynamic object. You <em>can</em> move unique pointers, which makes them transferable. They also have exclusive ownership, so they <em>cannot</em> be copied. The stdlib has a <code>unique_ptr</code> available in the <code>&lt;memory&gt;</code> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost doesn’t offer a unique pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec12"><strong><em><span epub:type="pagebreak" id="page_350"/>Constructing</em></strong></h4>&#13;
<p class="noindent">The <code>std::unique_ptr</code> takes a single template parameter corresponding to the pointed-to type, as in <code>std::unique_ptr&lt;int&gt;</code> for a “unique pointer to <code>int</code>” type.</p>&#13;
<p class="indent">As with a scoped pointer, the unique pointer has a default constructor that initializes the unique pointer to empty. It also provides a constructor taking a raw pointer that takes ownership of the pointed-to dynamic object. One construction method is to create a dynamic object with <code>new</code> and pass the result to the constructor, like this:</p>&#13;
<pre>std::unique_ptr&lt;int&gt; my_ptr{ new int{ 808 } };</pre>&#13;
<p class="indent">Another method is to use the <code>std::make_unique</code> function. The <code>make_unique</code> function is a template that takes all the arguments and forwards them to the appropriate constructor of the template parameter. This obviates the need for <code>new</code>. Using <code>std::make_unique</code>, you could rewrite the preceding object initialization as:</p>&#13;
<pre>auto my_ptr = make_unique&lt;int&gt;(808);</pre>&#13;
<p class="indent">The <code>make_unique</code> function was created to avoid some devilishly subtle memory leaks that used to occur when you used <code>new</code> with previous versions of C++. However, in the latest version of C++, these memory leaks no longer occur. Which constructor you use mainly depends on your preference.</p>&#13;
<h4 class="h4" id="ch11lev2sec13"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="indent">The <code>std::unique_ptr</code> function supports every operation that <code>boost::scoped_ptr</code> supports. For example, you can use the following type alias as a drop-in replacement for <code>ScopedOathbreakers</code> in <a href="ch11.xhtml#ch11ex01">Listings 11-1</a> to <a href="ch11.xhtml#ch11ex07">11-7</a>:</p>&#13;
<pre>using UniqueOathbreakers = std::unique_ptr&lt;DeadMenOfDunharrow&gt;;</pre>&#13;
<p class="indent">One of the major differences between unique and scoped pointers is that you can move unique pointers because they’re <em>transferable</em>.</p>&#13;
<h4 class="h4" id="ch11lev2sec14"><strong><em>Transferable, Exclusive Ownership</em></strong></h4>&#13;
<p class="noindent">Not only are unique pointers transferable, but they have exclusive ownership (you <em>cannot</em> copy them). <a href="ch11.xhtml#ch11ex10">Listing 11-10</a> illustrates how you can use the move semantics of <code>unique_ptr</code>.</p>&#13;
<pre>TEST_CASE("UniquePtr can be used in move") {&#13;
  auto aragorn = std::make_unique&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➊</span>&#13;
  SECTION("construction") {&#13;
    auto son_of_arathorn{ std::move(aragorn) }; <span class="ent">➋</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("assignment") {&#13;
    auto son_of_arathorn = std::make_unique&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_351"/>    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
    son_of_arathorn = std::move(aragorn); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex10"/><em>Listing 11-10: The <code>std::unique_ptr</code> supports move semantics for transferring ownership.</em></p>&#13;
<p class="indent">This listing creates a <code>unique_ptr</code> called <code>aragorn</code> <span class="ent">➊</span> that you use in two separate tests.</p>&#13;
<p class="indent">In the first test, you move <code>aragorn</code> with <code>std::move</code> into the move constructor of <code>son_of_arathorn</code> <span class="ent">➋</span>. Because <code>aragorn</code> transfers ownership of its <code>DeadMenOfDunharrow</code> to <code>son_of_arathorn</code>, the <code>oaths_to_fulfill</code> object still only has value 1 <span class="ent">➌</span>.</p>&#13;
<p class="indent">The second test constructs <code>son_of_arathorn</code> via <code>make_unique</code> <span class="ent">➍</span>, which pushes the <code>oaths_to_fulfill</code> to 2 <span class="ent">➎</span>. Next, you use the move assignment operator to move <code>aragorn</code> into <code>son_of_arathorn</code> <span class="ent">➏</span>. Again, <code>aragorn</code> transfers ownership to <code>son_of_aragorn</code>. Because <code>son_of_aragorn</code> can own only one dynamic object at a time, the move assignment operator destroys the currently owned object before emptying the dynamic object of <code>aragorn</code>. This results in <code>oaths_to_fulfill</code> decrementing to 1 <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec15"><strong><em>Unique Arrays</em></strong></h4>&#13;
<p class="noindent">Unlike <code>boost::scoped_ptr</code>, <code>std::unique_ptr</code> has built-in dynamic array support. You just use the array type as the template parameter in the unique pointer’s type, as in <code>std::unique_ptr&lt;int[]&gt;</code>.</p>&#13;
<p class="indent">It’s <em>very important</em> that you don’t initialize a <code>std::unique_ptr&lt;T&gt;</code> with a dynamic array <code>T[]</code>. Doing so will cause undefined behavior, because you’ll be causing a <code>delete</code> of an array (rather than <code>delete[]</code>). The compiler cannot save you, because <code>operator new[]</code> returns a pointer that is indistinguishable from the kind returned by <code>operator new</code>.</p>&#13;
<p class="indent">Like <code>scoped_array</code>, a <code>unique_ptr</code> to array type offers <code>operator[]</code> for accessing elements. <a href="ch11.xhtml#ch11ex11">Listing 11-11</a> demonstrates this concept.</p>&#13;
<pre>TEST_CASE("UniquePtr to array supports operator[]") {&#13;
  std::unique_ptr&lt;int[]<span class="ent">➊</span>&gt; squares{&#13;
    new int[5]{ 1, 4, 9, 16, 25 } <span class="ent">➋</span>&#13;
  };&#13;
  squares[0] = 1; <span class="ent">➌</span>&#13;
  REQUIRE(squares[0] == 1); <span class="ent">➍</span>&#13;
  REQUIRE(squares[1] == 4);&#13;
  REQUIRE(squares[2] == 9);&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex11"/><em>Listing 11-11: The <code>std::unique_ptr</code> to an array type supports <code>operator[]</code>.</em></p>&#13;
<p class="indent">The template parameter <code>int[]</code> <span class="ent">➊</span> indicates to <code>std::unique_ptr</code> that it owns a dynamic array. You pass in a newly minted dynamic array <span class="ent">➋</span> and then use <code>operator[]</code> to set the first element <span class="ent">➌</span>; then you use <code>operator[]</code> to retrieve elements <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec16"><span epub:type="pagebreak" id="page_352"/><strong><em>Deleters</em></strong></h4>&#13;
<p class="indent">The <code>std::unique_ptr</code> has a second, optional template parameter called its deleter type. A unique pointer’s <em>deleter</em> is what gets called when the unique pointer needs to destroy its owned object.</p>&#13;
<p class="indent">A <code>unique_ptr</code> instantiation contains the following template parameters:</p>&#13;
<pre>std::unique_ptr&lt;T, Deleter=std::default_delete&lt;T&gt;&gt;</pre>&#13;
<p class="indent">The two template parameters are <code>T</code>, the type of the owned dynamic object, and <code>Deleter</code>, the type of the object responsible for freeing an owned object. By default, <code>Deleter</code> is <code>std::default_delete&lt;T&gt;</code>, which calls <code>delete</code> or <code>delete[]</code> on the dynamic object.</p>&#13;
<p class="indent">To write a custom deleter, all you need is a function-like object that is invokable with a <code>T*</code>. (The unique pointer will ignore the deleter’s return value.) You pass this deleter as the second parameter to the unique pointer’s constructor, as shown in <a href="ch11.xhtml#ch11ex12">Listing 11-12</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
auto my_deleter = [](int* x) { <span class="ent">➊</span>&#13;
  printf("Deleting an int at %p.", x);&#13;
  delete x;&#13;
};&#13;
std::unique_ptr&lt;int<span class="ent">➋</span>, decltype(my_deleter)<span class="ent">➌</span>&gt; my_up{&#13;
  new int,&#13;
  my_deleter&#13;
};</pre>&#13;
<p class="listing"><a id="ch11ex12"/><em>Listing 11-12: Passing a custom deleter to a unique pointer</em></p>&#13;
<p class="indent">The owned object type is <code>int</code> <span class="ent">➋</span>, so you declare a <code>my_deleter</code> function object that takes an <code>int*</code> <span class="ent">➊</span>. You use <code>decltype</code> to set the deleter template parameter <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec17"><strong><em>Custom Deleters and System Programming</em></strong></h4>&#13;
<p class="noindent">You use a custom deleter whenever <code>delete</code> doesn’t provide the resource-releasing behavior you require. In some settings, you’ll never need a custom deleter. In others, like system programming, you might find them quite useful. Consider a simple example where you manage a file using the low-level APIs <code>fopen</code>, <code>fprintf</code>, and <code>fclose</code> in the <code>&lt;cstdio&gt;</code> header.</p>&#13;
<p>The <code>fopen</code> function opens a file and has the following signature:</p>&#13;
<pre>FILE*<span class="ent">➊</span> fopen(const char *filename<span class="ent">➋</span>, const char *mode<span class="ent">➌</span>);</pre>&#13;
<p class="indent">On success, <code>fopen</code> returns a non-<code>nullptr</code>-valued <code>FILE*</code> <span class="ent">➊</span>. On failure, <code>fopen</code> returns <code>nullptr</code> and it sets the static <code>int</code> variable <code>errno</code> equal to an error code, like access denied (<code>EACCES</code> <code>= 13</code>) or no such file (<code>ENOENT</code> <code>= 2</code>).</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_353"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See the <span class="codeitalic">errno.h</span> header for a listing of all error conditions and their corresponding <span class="codeitalic">int</span> values.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>FILE*</code> file handle    is a reference to a file the operating system manages. A <em>handle</em> is an opaque, abstract reference to some resource in an operating system. The <code>fopen</code> function takes two arguments: <code>filename</code> <span class="ent">➋</span> is the path to the file you want to open, and <code>mode</code> <span class="ent">➌</span> is one of the six options shown in <a href="ch11.xhtml#ch11tab02">Table 11-2</a>.</p>&#13;
<p class="tabcap"><a id="ch11tab02"/><strong>Table 11-2:</strong> All Six <code>mode</code> Options for <code>fopen</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>String</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operations</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File exists:</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File doesn’t exist:</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>r</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>fopen</code> fails</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>w</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Overwrite</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If the file exists, all contents are discarded.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>a</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Append</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Always write to the end of the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>r+</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>fopen</code> fails</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>w+</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Overwrite</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If the file exists, all contents are discarded.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>a+</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Always write to the end of the file.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You must close the file manually with <code>fclose</code> once you’re done using it. Failure to close file handles is a common source of resource leakages, like so:</p>&#13;
<pre>void fclose(FILE* file);</pre>&#13;
<p class="indent">To write to a file, you can use the <code>fprintf</code> function, which is like a <code>printf</code> that prints to a file instead of the console. The <code>fprintf</code> function has identical usage to <code>printf</code> except you provide a file handle as the first argument before the format string:</p>&#13;
<pre>int<span class="ent">➊</span> fprintf(FILE* file<span class="ent">➋</span>, const char* format_string<span class="ent">➌</span>, ...<span class="ent">➍</span>);</pre>&#13;
<p class="indent">On success, <code>fprintf</code> returns the number of characters <span class="ent">➊</span> written to the open file <span class="ent">➋</span>. The <code>format_string</code> is the same as the format string for <code>printf</code> <span class="ent">➌</span>, as are the variadic arguments <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can use a <code>std::unique_ptr</code> to a <code>FILE</code>. Obviously, you don’t want to call <code>delete</code> on the <code>FILE*</code> file handle when you’re ready to close the file. Instead, you need to close with <code>fclose</code>. Because <code>fclose</code> is a function-like object accepting a <code>FILE*</code>, it’s a suitable deleter.</p>&#13;
<p class="indent">The program in <a href="ch11.xhtml#ch11ex13">Listing 11-13</a> writes the string <code>HELLO, DAVE.</code> to the file <code>HAL9000</code> and uses a unique pointer to perform resource management over the open file.</p>&#13;
<pre><span epub:type="pagebreak" id="page_354"/>#include &lt;cstdio&gt;&#13;
#include &lt;memory&gt;&#13;
&#13;
using FileGuard = std::unique_ptr&lt;FILE, int(*)(FILE*)&gt;; <span class="ent">➊</span>&#13;
&#13;
void say_hello(FileGuard file<span class="ent">➋</span>) {&#13;
  fprintf(file.get(), "HELLO DAVE"); <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  auto file = fopen("HAL9000", "w"); <span class="ent">➍</span>&#13;
  if (!file) return errno; <span class="ent">➎</span>&#13;
  FileGuard file_guard{ file, fclose }; <span class="ent">➏</span>&#13;
  // File open here&#13;
  say_hello(std::move(file_guard)); <span class="ent">➐</span>&#13;
  // File closed here&#13;
  return 0;&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex13"/><em>Listing 11-13: A program using a <code>std::unique_ptr</code> and a custom deleter to manage a file handle</em></p>&#13;
<p class="indent">This listing makes the <code>FileGuard</code> type alias <span class="ent">➊</span> for brevity. (Notice the deleter type matches the type of <code>fclose</code>.) Next is a <code>say_hello</code> function that takes a <code>FileGuard</code> by value <span class="ent">➋</span>. Within <code>say_hello</code>, you <code>fprintf HELLO DAVE</code> to the <code>file</code> <span class="ent">➌</span>. Because the lifetime of <code>file</code> is bound to <code>say_hello</code>, the file gets closed once <code>say_hello</code> returns. Within <code>main</code>, you open the file <code>HAL9000</code> in <code>w</code> mode, which will create or overwrite the file, and you save the raw <code>FILE*</code> file handle into <code>file</code> <span class="ent">➍</span>. You check whether <code>file</code> is <code>nullptr</code>, indicating an error occurred, and return with <code>errno</code> if <code>HAL9000</code> couldn’t be opened <span class="ent">➎</span>. Next, you construct a <code>FileGuard</code> by passing the file handle <code>file</code> and the custom deleter <code>fclose</code> <span class="ent">➏</span>. At this point, the file is open, and thanks to its custom deleter, <code>file_guard</code> manages the file’s lifetime automatically.</p>&#13;
<p class="indent">To call <code>say_hello</code>, you need to transfer ownership into that function (because it takes a <code>FileGuard</code> by value) <span class="ent">➐</span>. Recall from “Value Categories” on <a href="ch04.xhtml#page_124">page 124</a> that variables like <code>file_guard</code> are lvalues. This means you must move it into <code>say_hello</code> with <code>std::move</code>, which writes <code>HELLO DAVE</code> to the file. If you omit <code>std::move</code>, the compiler would attempt to copy it into <code>say_hello</code>. Because <code>unique_ptr</code> has a deleted copy constructor, this would generate a compiler error.</p>&#13;
<p class="indent">When <code>say_hello</code> returns, its <code>FileGuard</code> argument destructs and the custom deleter calls <code>fclose</code> on the file handle. Basically, it’s impossible to leak the file handle. You’ve tied it to the lifetime of <code>FileGuard</code>.</p>&#13;
<h4 class="h4" id="ch11lev2sec18"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab03">Table 11-3</a> enumerates all the supported <code>std::unique_ptr</code> operations. In this table, <code>ptr</code> is a raw pointer, <code>u_ptr</code> is a unique pointer, and <code>del</code> is a deleter.</p>&#13;
<p class="tabcap"><a id="ch11tab03"/><span epub:type="pagebreak" id="page_355"/><strong>Table 11-3:</strong> All of the Supported <code>std::unique_ptr</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>unique_ptr&lt;...&gt;{ }</code> or <code>unique_ptr&lt;...&gt;{ nullptr }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty unique pointer with a <code>std::default_delete&lt;...&gt;</code> deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>unique_ptr&lt;...&gt;{</code> <span class="codestrong">ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses a <code>std::default_delete&lt;...&gt;</code> deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>unique_ptr&lt;...&gt;{</code> <span class="codestrong">ptr, del</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses <span class="codestrong">del</span> as deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>unique_ptr&lt;...&gt;{ move(</code><span class="codestrong">u_ptr</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by the unique pointer <span class="codestrong">u_ptr</span>. Transfers ownership from <span class="codestrong">u_ptr</span> to the newly created unique pointer. Also moves the deleter of <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~unique_ptr&lt;...&gt;()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls deleter on the owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr1</span> <code>= move(</code><span class="codestrong">u_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">u_ptr2</span> to <span class="codestrong">u_ptr1</span>. Destroys currently owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr1.</span><code>swap(</code><span class="codestrong">u_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges owned objects and deleters between <span class="codestrong">u_ptr1</span> and <span class="codestrong">u_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>swap(</code><span class="codestrong">u_ptr1</span><code>,</code> <span class="codestrong">u_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A free function identical to the <code>swap</code> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr</span><code>.reset()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If full, calls deleter on object owned by <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr</span><code>.reset(</code><span class="codestrong">ptr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deletes currently owned object; then takes ownership of <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ptr</span> <code>=</code> <span class="codestrong">u_ptr</span><code>.release()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">u_ptr</span> becomes empty. Deleter <em>is not</em> called.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ptr</span> <code>=</code> <span class="codestrong">u_ptr</span><code>.get()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">u_ptr</span> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">u_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr</span><code>-&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr</span><code>[</code><span class="codestrong">index</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">References the element at <span class="codestrong">index</span> (arrays only).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>bool{</code> <span class="codestrong">u_ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>bool</code> conversion: <code>true</code> if full, <code>false</code> if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr1</span> <code>==</code> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <code>!=</code> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <code>&gt;</code> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <code>&gt;=</code> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <code>&lt;</code> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <code>&lt;=</code> <span class="codestrong">u_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Comparison operators; equivalent to evaluating comparison operators on raw pointers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">u_ptr</span><code>.get_deleter()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a reference to the deleter.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec5"><strong>Shared Pointers</strong></h3>&#13;
<p class="indent">A <em>shared pointer</em> has transferable, non-exclusive ownership over a single dynamic object. You can move shared pointers, which makes them transferable, and you <em>can</em> copy them, which makes their ownership non-exclusive.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_356"/>Non-exclusive ownership means that a <code>shared_ptr</code> checks whether any other <code>shared_ptr</code> objects also own the object before destroying it. This way, the last owner is the one to release the owned object.</p>&#13;
<p class="indent">The stdlib has a <code>std::shared_ptr</code> available in the <code>&lt;memory&gt;</code> header, and Boost has a <code>boost::shared_ptr</code> available in the <code>&lt;boost/smart_ptr/shared_ptr.hpp&gt;</code> header. You’ll use the stdlib version here.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Both the stdlib and Boost <code>shared_ptr</code> are essentially identical, with the notable exception that Boost’s shared pointer doesn’t support arrays and requires you to use the <code>boost::shared_array</code> class in <code>&lt;boost/smart_ptr/shared_array.hpp&gt;</code>. Boost offers a shared pointer for legacy reasons, but you should use the stdlib shared pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec19"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <code>std::shared_ptr</code> pointer supports all the same constructors as <code>std::unique_ptr</code>. The default constructor yields an empty shared pointer. To instead establish ownership over a dynamic object, you can pass a pointer to the <code>shared_ptr</code> constructor, like so:</p>&#13;
<pre>std::shared_ptr&lt;int&gt; my_ptr{ new int{ 808 } };</pre>&#13;
<p class="indent">You also have a corollary <code>std::make_shared</code> template function that forwards arguments to the pointed-to type’s constructor:</p>&#13;
<pre>auto my_ptr = std::make_shared&lt;int&gt;(808);</pre>&#13;
<p class="indent">You should generally use <code>make_shared</code>. Shared pointers require a <em>control block</em>, which keeps track of several quantities, including the number of shared owners. When you use <code>make_shared</code>, you can allocate the control block and the owned dynamic object simultaneously. If you first use <code>operator new</code> and then allocate a shared pointer, you’re making two allocations instead of one.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Sometimes you might want to avoid using <code>make_shared</code>. For example, if you’ll be using a <code>weak_ptr</code>, you’ll still need the control block even if you can deallocate the object. In such a situation, you might prefer to have two allocations.</em></p>&#13;
</div>&#13;
<p class="indent">Because a control block is a dynamic object, <code>shared_ptr</code> objects sometimes need to allocate dynamic objects. If you wanted to take control over how <code>shared_ptr</code> allocates, you could override <code>operator new</code>. But this is shooting a sparrow with a cannon. A more tailored approach is to provide an optional template parameter called an <em>allocator type</em>.</p>&#13;
<h4 class="h4" id="ch11lev2sec20"><strong><em>Specifying an Allocator</em></strong></h4>&#13;
<p class="noindent">The allocator is responsible for allocating, creating, destroying, and deallocating objects. The default allocator, <code>std::allocator</code>, is a template class defined in the <code>&lt;memory&gt;</code> header. The default allocator allocates memory from dynamic storage and takes a template parameter. (You’ll learn about <span epub:type="pagebreak" id="page_357"/>customizing this behavior with a user-defined allocator in “Allocators” on <a href="ch11.xhtml#page_365">page 365</a>).</p>&#13;
<p class="indent">Both the <code>shared_ptr</code> constructor and <code>make_shared</code> have an allocator type template parameter, making three total template parameters: the pointed-to type, the deleter type, and the allocator type. For complicated reasons, you only ever need to declare the <em>pointed-to type</em> parameter. You can think of the other parameter types as being deduced from the pointed-to type.</p>&#13;
<p class="indent">For example, here’s a fully adorned <code>make_shared</code> invocation including a constructor argument, a custom deleter, and an explicit <code>std::allocator</code>:</p>&#13;
<pre>std::shared_ptr&lt;int<span class="ent">➊</span>&gt; sh_ptr{&#13;
  new int{ 10 }<span class="ent">➋</span>,&#13;
  [](int* x) { delete x; } <span class="ent">➌</span>,&#13;
  std::allocator&lt;int&gt;{} <span class="ent">➍</span>&#13;
};</pre>&#13;
<p class="indent">Here, you specify a single template parameter, <code>int</code>, for the pointed-to type <span class="ent">➊</span>. In the first argument, you allocate and initialize an <code>int</code> <span class="ent">➋</span>. Next is a custom deleter <span class="ent">➌</span>, and as a third argument you pass a <code>std::allocator</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">For technical reasons, you can’t use a custom deleter or custom allocator with <code>make_shared</code>. If you want a custom allocator, you can use the sister function of <code>make_shared</code>, which is <code>std::allocate_shared</code>. The <code>std::allocate _</code><code>shared</code> function takes an allocator as the first argument and forwards the remainder of the arguments to the owned object’s constructor:</p>&#13;
<pre>auto sh_ptr = std::allocate_shared&lt;int<span class="ent">➊</span>&gt;(std::allocator&lt;int&gt;{}<span class="ent">➋</span>, 10<span class="ent">➌</span>);</pre>&#13;
<p class="indent">As with <code>make_shared</code>, you specify the owned type as a template parameter <span class="ent">➊</span>, but you pass an allocator as the first argument <span class="ent">➋</span>. The rest of the arguments forward to the constructor of <code>int</code> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the curious, here are two reasons why you can’t use a custom deleter with <code>make_</code><code>shared</code>. First, <code>make_shared</code> uses <code>new</code> to allocate space for the owned object and the control block. The appropriate deleter for <code>new</code> is <code>delete</code>, so generally a custom deleter wouldn’t be appropriate. Second, the custom deleter can’t generally know how to deal with the control block, only with the owned object.</em></p>&#13;
</div>&#13;
<p class="indent">It isn’t possible to specify a custom deleter with either <code>make_shared</code> or <code>allocate_shared</code>. If you want to use a custom deleter with shared pointers, you must use one of the appropriate <code>shared_ptr</code> constructors directly.</p>&#13;
<h4 class="h4" id="ch11lev2sec21"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="noindent">The <code>std::shared_ptr</code> supports every operation that <code>std::unique_ptr</code> and <code>boost::scoped_ptr</code> support. You could use the following type alias as a drop-in replacement for <code>ScopedOathbreakers</code> in <a href="ch11.xhtml#ch11ex01">Listings 11-1</a> to <a href="ch11.xhtml#ch11ex07">11-7</a> and <code>UniqueOathbreakers</code> from <a href="ch11.xhtml#ch11ex10">Listings 11-10</a> to <a href="ch11.xhtml#ch11ex13">11-13</a>:</p>&#13;
<pre>using SharedOathbreakers = std::shared_ptr&lt;DeadMenOfDunharrow&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_358"/>The major functional difference between a shared pointer and a unique pointer is that you can copy shared pointers.</p>&#13;
<h4 class="h4" id="ch11lev2sec22"><strong><em>Transferable, Non-Exclusive Ownership</em></strong></h4>&#13;
<p class="noindent">Shared pointers are transferable (you <em>can</em> move them), and they have non-exclusive ownership (you <em>can</em> copy them). <a href="ch11.xhtml#ch11ex10">Listing 11-10</a>, which illustrates a unique pointer’s move semantics, works the same for a shared pointer. <a href="ch11.xhtml#ch11ex14">Listing 11-14</a> demonstrates that shared pointers also support copy semantics.</p>&#13;
<pre>TEST_CASE("SharedPtr can be used in copy") {&#13;
  auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;();&#13;
  SECTION("construction") {&#13;
    auto son_of_arathorn{ aragorn }; <span class="ent">➊</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("assignment") {&#13;
    SharedOathbreakers son_of_arathorn; <span class="ent">➌</span>&#13;
    son_of_arathorn = aragorn; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("assignment, and original gets discarded") {&#13;
    auto son_of_arathorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2);<span class="ent">➐</span>&#13;
    son_of_arathorn = aragorn; <span class="ent">➑</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex14"/><em>Listing 11-14: The <code>std::shared_ptr</code> supports copy.</em></p>&#13;
<p class="indent">After constructing the shared pointer <code>aragorn</code>, you have three tests. The first test illustrates that the copy constructor that you use to build <code>son_</code><code>of_arathorn</code> <span class="ent">➊</span> shares ownership over the same <code>DeadMenOfDunharrow</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">In the second test, you construct an empty shared pointer <code>son_of _ara</code><code>thorn</code> <span class="ent">➌</span> and then show that copy assignment <span class="ent">➍</span> also doesn’t change the number of <code>DeadMenOfDunharrow</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">The third test illustrates that when you construct the full shared pointer <code>son_of_arathorn</code> <span class="ent">➏</span>, the number of <code>DeadMenOfDunharrow</code> increases to 2 <span class="ent">➐</span>. When you copy assign <code>aragorn</code> to <code>son_of_arathorn</code> <span class="ent">➑</span>, the <code>son_of_arathorn</code> deletes its <code>DeadMenOfDunharrow</code> because it has sole ownership. It then increments the reference count of the <code>DeadMenOfDunharrow</code> owned by <code>aragorn</code>. Because both shared pointers own the same <code>DeadMenOfDunharrow</code>, the <code>oaths_to_fulfill</code> decrements from 2 to 1 <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec23"><strong><em>Shared Arrays</em></strong></h4>&#13;
<p class="noindent">A <code>shared array</code> is a shared pointer that owns a dynamic array and supports <code>operator[]</code>. It works just like a unique array except it has non-exclusive ownership.</p>&#13;
<h4 class="h4" id="ch11lev2sec24"><span epub:type="pagebreak" id="page_359"/><strong><em>Deleters</em></strong></h4>&#13;
<p class="indent">Deleters work the same way for shared pointers as they do for unique pointers except you don’t need to provide a template parameter with the deleter’s type. Simply pass the deleter as the second constructor argument. For example, to convert <a href="ch11.xhtml#ch11ex12">Listing 11-12</a> to use a shared pointer, you simply drop in the following type alias:</p>&#13;
<pre>using FileGuard = std::shared_ptr&lt;FILE&gt;;</pre>&#13;
<p class="indent">Now, you’re managing <code>FILE*</code> file handles with shared ownership.</p>&#13;
<h4 class="h4" id="ch11lev2sec25"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab04">Table 11-4</a> provides a mostly complete listing of the supported constructors of <code>shared_ptr</code>. In this table, <code>ptr</code> is a raw pointer, <code>sh_ptr</code> is a shared pointer, <code>u_ptr</code> is a unique pointer, <code>del</code> is a deleter, and <code>alc</code> is an allocator.</p>&#13;
<p class="tabcap"><a id="ch11tab04"/><strong>Table 11-4:</strong> All of the Supported <code>std::shared_ptr</code> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>shared_ptr&lt;...&gt;{ }</code> or <code>shared_ptr&lt;...&gt;{ nullptr }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty shared pointer with a <code>std::default_delete&lt;T&gt;</code> and a <code>std::allocator&lt;T&gt;</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>shared_ptr&lt;...&gt;{</code> <span class="codestrong">ptr</span><span class="codestrong">,</span> <span class="codestrong">[del]</span><span class="codestrong">,</span> <span class="codestrong">[alc]</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses a <code>std::default_delete&lt;T&gt;</code> and a <code>std::allocator&lt;T&gt;</code> by default; otherwise, <span class="codestrong">del</span> as deleter, <span class="codestrong">alc</span> as allocator if supplied.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>shared_ptr&lt;...&gt;{</code> <span class="codestrong">sh_ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the shared pointer <span class="codestrong">sh_ptr</span>. Copies ownership from <span class="codestrong">sh_ptr</span> to the newly created shared pointer. Also copies the deleter and allocator of <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>shared_ptr&lt;...&gt;{</code> <span class="codestrong">sh_ptr</span> <span class="codestrong">,</span> <span class="codestrong">ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An <em>aliasing constructor</em>: the resulting shared pointer holds an unmanaged reference to <span class="codestrong">ptr</span> but participates in <span class="codestrong">sh_ptr</span> reference counting.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>shared_ptr&lt;...&gt;{ move(</code><span class="codestrong">sh_ptr</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the shared pointer <span class="codestrong">sh_ptr</span>. Transfers ownership from <span class="codestrong">sh_ptr</span> to the newly created shared pointer. Also moves the deleter of <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>shared_ptr&lt;...&gt;{ move(</code><span class="codestrong">u_ptr</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the unique pointer <span class="codestrong">u_ptr</span>. Transfers ownership from <span class="codestrong">u_ptr</span> to the newly created shared pointer. Also moves the deleter of <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch11.xhtml#ch11tab05">Table 11-5</a> provides a listing of most of the supported operations of <code>std::shared_ptr</code>. In this table, <code>ptr</code> is a raw pointer, <code>sh_ptr</code> is a shared pointer, <code>u_ptr</code> is a unique pointer, <code>del</code> is a deleter, and <code>alc</code> is an allocator.</p>&#13;
<p class="tabcap"><a id="ch11tab05"/><span epub:type="pagebreak" id="page_360"/><strong>Table 11-5:</strong> Most of the Supported <code>std::shared_ptr</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>~shared_ptr&lt;...&gt;()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls deleter on the owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr1</span> <code>=</code> <span class="codestrong">sh_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copies ownership of owned object and deleter from <span class="codestrong">sh_ptr2</span> to <span class="codestrong">sh_ptr1</span>. Increments number of owners by 1. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span> <code>= move(</code><span class="codestrong">u_ptr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">u_ptr</span> to <span class="codestrong">sh_ptr</span>. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr1</span> <code>= move(</code><span class="codestrong">sh_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">sh_ptr2</span> to <span class="codestrong">sh_ptr1</span>. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr1</span><code>.swap(</code><span class="codestrong">sh_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges owned objects and deleters between <span class="codestrong">sh_ptr1</span> and <span class="codestrong">sh_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>swap(</code><span class="codestrong">sh_ptr1</span><code>,</code> <span class="codestrong">sh_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A free function identical to the <code>swap</code> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><code>.reset()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If full, calls deleter on object owned by <span class="codestrong">sh_ptr</span> if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr</span><code>.reset(</code><span class="codestrong">ptr</span><code>,</code> <span class="codestrong">[del]</span><code>,</code> <span class="codestrong">[alc]</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deletes currently owned object if no other owners exist; then takes ownership of <span class="codestrong">ptr</span>. Can optionally provide deleter <span class="codestrong">del</span> and allocator <span class="codestrong">alc</span>. These default to <code>std::default_delete&lt;T&gt;</code> and <code>std::allocator&lt;T&gt;</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ptr</span> <code>=</code> <span class="codestrong">sh_ptr</span><code>.get()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">sh_ptr</span> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>*</code><span class="codestrong">sh_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><code>-&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Member dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr</span><code>.use_count()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">References the total number of shared pointers owning the owned object; zero if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><code>[</code><span class="codestrong">index</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the element at <span class="codestrong">index</span> (arrays only).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>bool{</code> <span class="codestrong">sh_ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>bool</code> conversion: <code>true</code> if full, <code>false</code> if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr1</span> <code>==</code> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <code>!=</code> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <code>&gt;</code> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <code>&gt;=</code> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <code>&lt;</code> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <code>&lt;=</code> <span class="codestrong">sh_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Comparison operators; equivalent to evaluating comparison operators on raw pointers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">sh_ptr</span><code>.get_deleter()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a reference to the deleter.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec6"><strong>Weak Pointers</strong></h3>&#13;
<p class="indent">A <em>weak pointer</em> is a special kind of smart pointer that has no ownership over the object to which it refers. Weak pointers allow you to track an object and to convert the weak pointer into a shared pointer <em>only if the tracked object still <span epub:type="pagebreak" id="page_361"/>exists</em>. This allows you to generate temporary ownership over an object. Like shared pointers, weak pointers are movable and copyable.</p>&#13;
<p class="indent">A common usage for weak pointers is <em>caches</em>. In software engineering, a cache is a data structure that stores data temporarily so it can be retrieved faster. A cache could keep weak pointers to objects so they destruct once all other owners release them. Periodically, the cache can scan its stored weak pointers and trim those with no other owners.</p>&#13;
<p class="indent">The stdlib has a <code>std::weak_ptr</code>, and Boost has a <code>boost::weak_ptr</code>. These are essentially identical and are only meant to be used with their respective shared pointers, <code>std::shared_ptr</code> and <code>boost::shared_ptr</code>.</p>&#13;
<h4 class="h4" id="ch11lev2sec26"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">Weak pointer constructors are completely different from scoped, unique, and shared pointers because weak pointers don’t directly own dynamic objects. The default constructor constructs an empty weak pointer. To construct a weak pointer that tracks a dynamic object, you must construct it using either a shared pointer or another weak pointer.</p>&#13;
<p class="indent">For example, the following passes a shared pointer into the weak pointer’s&#13;
constructor:</p>&#13;
<pre>auto sp = std::make_shared&lt;int&gt;(808);&#13;
std::weak_ptr&lt;int&gt; wp{ sp };</pre>&#13;
<p class="indent">Now the weak pointer <code>wp</code> will track the object owned by the shared pointer <code>sp</code>.</p>&#13;
<h4 class="h4" id="ch11lev2sec27"><strong><em>Obtaining Temporary Ownership</em></strong></h4>&#13;
<p class="noindent">Weak pointers invoke their <code>lock</code> method to get temporary ownership of their tracked object. The lock method always creates a shared pointer. If the tracked object is alive, the returned shared pointer owns the tracked object. If the tracked object is no longer alive, the returned shared pointer is empty. Consider the example in <a href="ch11.xhtml#ch11ex15">Listing 11-15</a>.</p>&#13;
<pre>TEST_CASE("WeakPtr lock() yields") {&#13;
  auto message = "The way is shut.";&#13;
  SECTION("a shared pointer when tracked object is alive") {&#13;
    auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(message); <span class="ent">➊</span>&#13;
    std::weak_ptr&lt;DeadMenOfDunharrow&gt; legolas{ aragorn }; <span class="ent">➋</span>&#13;
    auto sh_ptr = legolas.lock(); <span class="ent">➌</span>&#13;
    REQUIRE(sh_ptr-&gt;message == message); <span class="ent">➍</span>&#13;
    REQUIRE(sh_ptr.use_count() == 2); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("empty when shared pointer empty") {&#13;
    std::weak_ptr&lt;DeadMenOfDunharrow&gt; legolas;&#13;
    {&#13;
      auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(message); <span class="ent">➏</span>&#13;
      legolas = aragorn; <span class="ent">➐</span>&#13;
    }&#13;
<span epub:type="pagebreak" id="page_362"/>    auto sh_ptr = legolas.lock(); <span class="ent">➑</span>&#13;
    REQUIRE(nullptr == sh_ptr); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex15"/><em>Listing 11-15: The <code>std::weak_ptr</code> exposes a <code>lock</code> method for obtaining temporary ownership.</em></p>&#13;
<p class="indent">In the first test, you create the shared pointer <code>aragorn</code> <span class="ent">➊</span> with a message. Next, you construct a weak pointer <code>legolas</code> using <code>aragorn</code> <span class="ent">➋</span>. This sets up <code>legolas</code> to track the dynamic object owned by <code>aragorn</code>. When you call <code>lock</code> on the weak pointer <span class="ent">➌</span>, <code>aragorn</code> is still alive, so you obtain the shared pointer <code>sh_ptr</code>, which also owns the same <code>DeadMenOfDunharrow</code>. You confirm this by asserting that the <code>message</code> is the same <span class="ent">➍</span> and that the <em>use count</em> is 2 <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second test, you also create an <code>aragorn</code> shared pointer <span class="ent">➏</span>, but this time you use the assignment operator <span class="ent">➐</span>, so the previously empty weak pointer <code>legolas</code> now tracks the dynamic object owned by <code>aragorn</code>. Next, <code>ara</code><code>gorn</code> falls out of block scope and dies. This leaves <code>legolas</code> tracking a dead object. When you call <code>lock</code> at this point <span class="ent">➑</span>, you obtain an empty shared pointer <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec28"><strong><em>Advanced Patterns</em></strong></h4>&#13;
<p class="noindent">In some advanced usages of shared pointers, you might want to create a class that allows instances to create shared pointers referring to themselves. The <code>std::enable_shared_from_this</code> class template implements this behavior. All that’s required from a user perspective is to inherit from <code>enable_shared _</code><code>from_this</code> in the class definition. This exposes the <code>shared_from_this</code> and <code>weak_from_this</code> methods, which produce either a <code>shared_ptr</code> or a <code>weak_ptr</code> referring to the current object. This is a niche case, but if you want to see more details, refer to [util.smartptr.enab].</p>&#13;
<h4 class="h4" id="ch11lev2sec29"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab06">Table 11-6</a> lists most of the supported weak pointer operations. In this table, <code>w_ptr</code> is a weak pointer, and <code>sh_ptr</code> is a shared pointer.</p>&#13;
<p class="tabcap"><a id="ch11tab06"/><strong>Table 11-6:</strong> Most of the Supported <code>std::shared_ptr</code> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>weak_ptr&lt;...&gt;{ }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty weak pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>weak_ptr&lt;...&gt;{</code> <span class="codestrong">w_ptr</span> <code>}</code> or <code>weak_ptr&lt;...&gt;{</code> <span class="codestrong">sh_ptr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Tracks the object referred to by weak pointer <span class="codestrong">w_ptr</span> or shared pointer <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>weak_ptr&lt;...&gt;{ move(</code><span class="codestrong">w_ptr</span><code>) }</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Tracks the object referred to by <span class="codestrong">w_ptr</span>; then empties <span class="codestrong">w_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>~weak_ptr&lt;...&gt;()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Has no effect on the tracked object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">w_ptr1</span> <code>=</code> <span class="codestrong">sh_ptr</span> or <span class="codestrong">w_ptr1</span> <code>=</code> <span class="codestrong">w_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces currently tracked object with the object owned by <span class="codestrong">sh_ptr</span> or tracked by <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr1</span> <code>= move(</code><span class="codestrong">w_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces currently tracked object with object tracked by <span class="codestrong">w_ptr2</span>. Empties <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_363"/><span class="codestrong">sh_ptr</span> <code>=</code> <span class="codestrong">w_ptr.</span><code>lock()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates the shared pointer <span class="codestrong">sh_ptr</span> owning the object tracked by <span class="codestrong">w_ptr</span>. If the tracked object has expired, <span class="codestrong">sh_ptr</span> is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr1</span><code>.swap(</code><span class="codestrong">w_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges tracked objects between <span class="codestrong">w_ptr1</span> and <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>swap(</code><span class="codestrong">w_ptr1</span><code>,</code> <span class="codestrong">w_ptr2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A free function identical to the <code>swap</code> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr</span><code>.reset()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Empties the weak pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">w_ptr</span><code>.use_count()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of shared pointers owning the tracked object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr</span><code>.expired()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <code>true</code> if the tracked object has expired, <code>false</code> if it hasn’t.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">sh_ptr</span><code>.use_count()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the total number of shared pointers owning the owned object; zero if empty.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec7"><strong>Intrusive Pointers</strong></h3>&#13;
<p class="indent">An <em>intrusive pointer</em> is a shared pointer to an object with an embedded reference count. Because shared pointers usually keep reference counts, they’re not suitable for owning such objects. Boost provides an implementation called <code>boost::intrusive_ptr</code> in the <code>&lt;boost/smart_ptr/intrusive_ptr.hpp&gt;</code> header.</p>&#13;
<p class="indent">It’s rare that a situation calls for an intrusive pointer. But sometimes you’ll use an operating system or a framework that contains embedded references. For example, in Windows COM programming an intrusive pointer can be very useful: COM objects that inherit from the <code>IUnknown</code> interface have an <code>AddRef</code> and a <code>Release</code> method, which increment and decrement an embedded reference count (respectively).</p>&#13;
<p class="indent">Each time an <code>intrusive_ptr</code> is created, it calls the function <code>intrusive_ptr_add_ref</code>. When an <code>intrusive_ptr</code> is destroyed, it calls the <code>intrusive_ptr_release</code> free function. You’re responsible for freeing appropriate resources in <code>intrusive_ptr_release</code> when the reference count falls to zero. To use <code>intrusive_ptr</code>, you must provide a suitable implementation of these functions.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex16">Listing 11-16</a> demonstrates intrusive pointers using the <code>DeadMenOfDunharrow</code> class. Consider the implementations of <code>intrusive_ptr_add_ref</code> and <code>intrusive_ptr_release</code> in this listing.</p>&#13;
<pre>#include &lt;boost/smart_ptr/intrusive_ptr.hpp&gt;&#13;
&#13;
using IntrusivePtr = boost::intrusive_ptr&lt;DeadMenOfDunharrow&gt;; <span class="ent">➊</span>&#13;
size_t ref_count{}; <span class="ent">➋</span>&#13;
&#13;
void intrusive_ptr_add_ref(DeadMenOfDunharrow* d) {&#13;
  ref_count++; <span class="ent">➌</span>&#13;
}&#13;
&#13;
void intrusive_ptr_release(DeadMenOfDunharrow* d) {&#13;
<span epub:type="pagebreak" id="page_364"/>  ref_count--; <span class="ent">➍</span>&#13;
  if (ref_count == 0) delete d; <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex16"/><em>Listing 11-16: Implementations of <code>intrusive_ptr_add_ref</code> and <code>intrusive_ptr_release</code></em></p>&#13;
<p class="indent">Using the type alias <code>IntrusivePtr</code> saves some typing <span class="ent">➊</span>. Next, you declare a <code>ref_count</code> with static storage duration <span class="ent">➋</span>. This variable keeps track of the number of living intrusive pointers. In <code>intrusive_ptr_add_ref</code>, you increment <code>ref_count</code> <span class="ent">➌</span>. In <code>intrusive_ptr_release</code>, you decrement <code>ref_count</code> <span class="ent">➍</span>. When <code>ref _count</code> drops to zero, you delete the <code>DeadMenOfDunharrow</code> argument <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It’s absolutely critical that you use only a single <code>DeadMenOfDunharrow</code> dynamic object with intrusive pointers when using the setup in <a href="ch11.xhtml#ch11ex16">Listing 11-16</a>. The <code>ref_count</code> approach will correctly track only a single object. If you have multiple dynamic objects owned by different intrusive pointers, the <code>ref_count</code> will become invalid, and you’ll get incorrect <code>delete</code> behavior <span class="ent">➎</span>.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex17">Listing 11-17</a> shows how to use the setup in <a href="ch11.xhtml#ch11ex16">Listing 11-16</a> with intrusive pointers.</p>&#13;
<pre>TEST_CASE("IntrusivePtr uses an embedded reference counter.") {&#13;
  REQUIRE(ref_count == 0); <span class="ent">➊</span>&#13;
  IntrusivePtr aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➋</span>&#13;
  REQUIRE(ref_count == 1); <span class="ent">➌</span>&#13;
  {&#13;
    IntrusivePtr legolas{ aragorn }; <span class="ent">➍</span>&#13;
    REQUIRE(ref_count == 2); <span class="ent">➎</span>&#13;
  }&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex17"/><em>Listing 11-17: Using a <code>boost::intrusive_ptr</code></em></p>&#13;
<p class="indent">This test begins by checking that <code>ref_count</code> is zero <span class="ent">➊</span>. Next, you construct an intrusive pointer by passing a dynamically allocated <code>DeadMenOfDunharrow</code> <span class="ent">➋</span>. This increases <code>ref_count</code> to 1, because creating an intrusive pointer invokes <code>intrusive_ptr_add_ref</code> <span class="ent">➌</span>. Within a block scope, you construct another intrusive pointer <code>legolas</code> that shares ownership&#13;
with <code>aragorn</code> <span class="ent">➍</span>. This increases the <code>ref_count</code> to 2 <span class="ent">➎</span>, because creating an intrusive pointer invokes <code>intrusive_ptr_add_ref</code>. When <code>legolas</code> falls out of block scope, it destructs, causing <code>intrusive_ptr_release</code> to invoke. This decrements <code>ref_</code><code>count</code> to 1 but doesn’t cause the owned object to delete <span class="ent">➏</span>.</p>&#13;
<h3 class="h3" id="ch11lev1sec8"><strong>Summary of Smart Pointer Options</strong></h3>&#13;
<p class="indent"><a href="ch11.xhtml#ch11tab07">Table 11-7</a> summarizes all the smart pointer options available to use in stdlib and Boost.</p>&#13;
<p class="tabcap"><a id="ch11tab07"/><span epub:type="pagebreak" id="page_365"/><strong>Table 11-7:</strong> Smart Pointers in stdlib and Boost</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>stdlib header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Boost header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Movable/transferable ownership</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Copyable/non-exclusive ownership</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>scoped_ptr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;boost/smart_ptr/scoped_ptr.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>scoped_array</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;boost/smart_ptr/scoped_array.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>unique_ptr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;memory&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>shared_ptr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;memory&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;boost/smart_ptr/shared_ptr.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>shared_array</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>&lt;boost/smart_ptr/shared_array.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>weak_ptr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;memory&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>&lt;boost/smart_ptr/weak_ptr.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>intrusive_ptr</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>&lt;boost/smart_ptr/intrusive_ptr.hpp&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">✓</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec9"><strong>Allocators</strong></h3>&#13;
<p class="noindent">Allocators are low-level objects that service requests for memory. The stdlib and Boost libraries enable you to provide allocators to customize how a library allocates dynamic memory.</p>&#13;
<p class="indent">In the majority of cases, the default allocator <code>std::allocate</code> is totally sufficient. It allocates memory using <code>operator new(size_t)</code>, which allocates raw memory from the free store, also known as the heap. It deallocates memory using <code>operator delete(void*)</code>, which deallocates the raw memory from the free store. (Recall from “Overloading Operator <code>new</code>” on <a href="ch07.xhtml#page_189">page 189</a> that <code>operator new</code> and <code>operator delete</code> are defined in the <code>&lt;new&gt;</code> header.)</p>&#13;
<p class="indent">In some settings, such as gaming, high-frequency trading, scientific analyses, and embedded applications, the memory and computational overhead associated with the default free store operations is unacceptable. In such settings, it’s relatively easy to implement your own allocator. Note that you really shouldn’t implement a custom allocator unless you’ve conducted some performance testing that indicates that the default allocator is a bottleneck. The idea behind a custom allocator is that you know a lot more about your specific program than the designers of the default allocator model, so you can make improvements that will increase allocation performance.</p>&#13;
<p class="indent">At a minimum, you need to provide a template class with the following characteristics for it to work as an allocator:</p>&#13;
<ul>&#13;
<li class="noindent">An appropriate default constructor</li>&#13;
<li class="noindent">A <code>value_type</code> member corresponding to the template parameter</li>&#13;
<li class="noindent">A template constructor that can copy an allocator’s internal state while dealing with a change in <code>value_type</code></li>&#13;
<li class="noindent">An <code>allocate</code> method</li>&#13;
<li class="noindent">A <code>deallocate</code> method</li>&#13;
<li class="noindent">An <code>operator==</code> and an <code>operator!=</code></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>The <code>MyAllocator</code> class in <a href="ch11.xhtml#ch11ex18">Listing 11-18</a> implements a simple, pedagogical variant of <code>std::allocate</code> that keeps track of how many allocations and deallocations you’ve made.</p>&#13;
<pre>#include &lt;new&gt;&#13;
&#13;
static size_t n_allocated, n_deallocated;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct MyAllocator {&#13;
  using value_type = T; <span class="ent">➊</span>&#13;
  MyAllocator() noexcept{ } <span class="ent">➋</span>&#13;
  template &lt;typename U&gt;&#13;
  MyAllocator(const MyAllocator&lt;U&gt;&amp;) noexcept { } <span class="ent">➌</span>&#13;
  T* allocate(size_t n) { <span class="ent">➍</span>&#13;
    auto p = operator new(sizeof(T) * n);&#13;
    ++n_allocated;&#13;
    return static_cast&lt;T*&gt;(p);&#13;
  }&#13;
  void deallocate(T* p, size_t n) { <span class="ent">➎</span>&#13;
    operator delete(p);&#13;
    ++n_deallocated;&#13;
  }&#13;
};&#13;
&#13;
template &lt;typename T1, typename T2&gt;&#13;
bool operator==(const MyAllocator&lt;T1&gt;&amp;, const MyAllocator&lt;T2&gt;&amp;) {&#13;
  return true; <span class="ent">➏</span>&#13;
}&#13;
template &lt;typename T1, typename T2&gt;&#13;
bool operator!=(const MyAllocator&lt;T1&gt;&amp;, const MyAllocator&lt;T2&gt;&amp;) {&#13;
  return false; <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex18"/><em>Listing 11-18: A <code>MyAllocator</code> class modeled after <code>std::allocate</code></em></p>&#13;
<p class="indent">First, you declare the <code>value_type</code> type alias for <code>T</code>, one of the requirements for implementing an allocator <span class="ent">➊</span>. Next is a default constructor <span class="ent">➋</span> and a template constructor <span class="ent">➌</span>. Both of these are empty because the allocator doesn’t have state to pass on.</p>&#13;
<p class="indent">The <code>allocate</code> method <span class="ent">➍</span> models <code>std::allocate</code> by allocating the requisite number of bytes, <code>sizeof(T) * n</code>, using <code>operator new</code>. Next, it increments the static variable <code>n_allocated</code> so you can keep track of the number of allocations for testing purposes. The <code>allocate</code> method then returns a pointer to the newly allocated memory after casting <code>void*</code> to the relevant pointer type.</p>&#13;
<p class="indent">The <code>deallocate</code> method <span class="ent">➎</span> also models <code>std::allocate</code> by calling <code>operator</code> <code>delete</code>. As an analogy to <code>allocate</code>, it increments the <code>n_deallocated</code> static variable for testing and returns.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_367"/>The final task is to implement an <code>operator==</code> and an <code>operator!=</code> taking the new class template. Because the allocator has no state, any instance is the same as any other instance, so <code>operator==</code> returns <code>true</code> <span class="ent">➏</span> and <code>operator!</code><code>=</code> returns <code>true</code> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch11.xhtml#ch11ex18">Listing 11-18</a> is a teaching tool and doesn’t actually make allocations any more efficient. It simply wraps the call to <code>new</code> and <code>delete</code></em>.</p>&#13;
</div>&#13;
<p class="indent">So far, the only class you know about that uses an allocator is <code>std::shared _ptr</code>. Consider how <a href="ch11.xhtml#ch11ex19">Listing 11-19</a> uses <code>MyAllocator</code> with <code>std::allocate</code> shared.</p>&#13;
<pre>TEST_CASE("Allocator") {&#13;
  auto message = "The way is shut.";&#13;
  MyAllocator&lt;DeadMenOfDunharrow&gt; alloc; <span class="ent">➊</span>&#13;
  {&#13;
    auto aragorn = std::allocate_shared&lt;DeadMenOfDunharrow&gt;(alloc<span class="ent">➋</span>, message<span class="ent">➌</span>);&#13;
    REQUIRE(aragorn-&gt;message == message); <span class="ent">➍</span>&#13;
    REQUIRE(n_allocated == 1); <span class="ent">➎</span>&#13;
    REQUIRE(n_deallocated == 0); <span class="ent">➏</span>&#13;
  }&#13;
  REQUIRE(n_allocated == 1); <span class="ent">➐</span>&#13;
  REQUIRE(n_deallocated == 1); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex19"/><em>Listing 11-19: Using <code>MyAllocator</code> with <code>std::shared_ptr</code></em></p>&#13;
<p class="indent">You create a <code>MyAllocator</code> instance called <code>alloc</code> <span class="ent">➊</span>. Within a block, you pass <code>alloc</code> as the first argument to <code>allocate_shared</code> <span class="ent">➋</span>, which creates the shared pointer <code>aragorn</code> containing a custom <code>message</code> <span class="ent">➌</span>. Next, you confirm that <code>aragorn</code> contains the correct <code>message</code> <span class="ent">➍</span>, <code>n_allocated</code> is 1 <span class="ent">➎</span>, and <code>n_deallocated</code> is 0 <span class="ent">➏</span>.</p>&#13;
<p class="indent">After <code>aragorn</code> falls out of block scope and destructs, you verify that <code>n_allocated</code> is still 1 <span class="ent">➐</span> and <code>n_deallocated</code> is now 1 <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because allocators handle low-level details, you can really get down into the weeds when specifying their behavior. See [allocator.requirements] in the ISO C++ 17 Standard for a thorough treatment.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec10"><strong>Summary</strong></h3>&#13;
<p class="indent">Smart pointers manage dynamic objects via RAII, and you can provide allocators to customize dynamic memory allocation. Depending on which smart pointer you choose, you can encode different ownership patterns onto the dynamic object.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_368"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>11-1.</strong> Reimplement <a href="ch11.xhtml#ch11ex12">Listing 11-13</a> to use a <code>std::shared_ptr</code> rather than a <code>std::unique_ptr</code>. Notice that although you’ve relaxed the ownership requirements from exclusive to non-exclusive, you’re still transferring ownership to the <code>say_hello</code> function.</p>&#13;
<p class="noindent"><strong>11-2.</strong> Remove the <code>std::move</code> from the call to <code>say_hello</code>. Then make an additional call to <code>say_hello</code>. Notice that the ownership of <code>file_guard</code> is no longer <code>transferred</code> to <code>say_hello</code>. This permits multiple calls.</p>&#13;
<p class="noindent"><strong>11-3.</strong> Implement a <code>Hal</code> class that accepts a <code>std::shared_ptr&lt;FILE&gt;</code> in its constructor. In Hal’s destructor, write the phrase <code>Stop, Dave.</code> to the file handle held by your shared pointer. Implement a <code>write_status</code> function that writes the phrase <code>I'm completely operational.</code> to the file handle. Here’s a class declaration you can work from:</p>&#13;
<pre>struct Hal {&#13;
  Hal(std::shared_ptr&lt;FILE&gt; file);&#13;
  ~Hal();&#13;
  void write_status();&#13;
  std::shared_ptr&lt;FILE&gt; file;&#13;
};</pre>&#13;
<p class="noindent"><strong>11-4.</strong> Create several <code>Hal</code> instances and invoke <code>write_status</code> on them. Notice that you don’t need to keep track of how many <code>Hal</code> instances are open: file management gets handled via the shared pointer’s shared ownership model.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>