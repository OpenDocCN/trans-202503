<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_340"/><span epub:type="pagebreak" id="page_341"/><strong><span class="big">11</span><br/>SMART POINTERS</strong></h2>&#13;
<p class="quote"><em>If you want to do a few small things right, do them yourself. If you want to do great things and make a big impact, learn to delegate.<br/>—John C. Maxwell</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="indent">In this chapter, you’ll explore stdlib and Boost libraries. These libraries contain a collection of smart pointers, which manage dynamic objects with the RAII paradigm you learned in <a href="ch04.xhtml#ch04">Chapter 4</a>. They also facilitate the most powerful resource management model in any programming language. Because some smart pointers use <em>allocators</em> to customize dynamic memory allocation, the chapter also outlines how to provide a user-defined allocator.</p>&#13;
<h3 class="h3" id="ch11lev1sec1"><strong>Smart Pointers</strong></h3>&#13;
<p class="noindent">Dynamic objects have the most flexible lifetimes. With great flexibility comes great responsibility, so you must make sure each dynamic object gets destructed <em>exactly</em> once. This might not look daunting with small programs, but looks can be deceiving. Just consider how exceptions factor <span epub:type="pagebreak" id="page_342"/>into dynamic memory management. Each time an error or an exception could occur, you need to keep track of which allocations you’ve made successfully and be sure to release them in the correct order.</p>&#13;
<p class="indent">Fortunately, you can use RAII to handle such tedium. By acquiring dynamic storage in the constructor of the RAII object and releasing dynamic storage in the destructor, it’s relatively difficult to leak (or double free) dynamic memory. This enables you to manage dynamic object lifetimes using move and copy semantics.</p>&#13;
<p class="indent">You could write these RAII objects yourself, but you can also use some excellent prewritten implementations called <em>smart pointers</em>. Smart pointers are class templates that behave like pointers and implement RAII for dynamic objects.</p>&#13;
<p class="indent">This section delves into five available options included in stdlib and Boost: scoped, unique, shared, weak, and intrusive pointers. Their ownership models differentiate these five smart pointer categories.</p>&#13;
<h3 class="h3" id="ch11lev1sec2"><strong>Smart Pointer Ownership</strong></h3>&#13;
<p class="noindent">Every smart pointer has an <em>ownership</em> model that specifies its relationship with a dynamically allocated object. When a smart pointer owns an object, the smart pointer’s lifetime is guaranteed to be at least as long as the object’s. Put another way, when you use a smart pointer, you can rest assured that the pointed-to object is alive and that the pointed-to object won’t leak. The smart pointer manages the object it owns, so you can’t forget to destroy it thanks to RAII.</p>&#13;
<p class="indent">When considering which smart pointer to use, your ownership requirements drive your choice.</p>&#13;
<h3 class="h3" id="ch11lev1sec3"><strong>Scoped Pointers</strong></h3>&#13;
<p class="noindent">A <em>scoped pointer</em> expresses <em>non-transferable</em>, <em>exclusive ownership</em> over a single dynamic object. Non-transferable means that the scoped pointers cannot be moved from one scope to another. Exclusive ownership means that they can’t be copied, so no other smart pointers can have ownership of a scoped pointer’s dynamic object. (Recall from “Memory Management” on <a href="ch04.xhtml#page_90">page 90</a> that an object’s scope is where it’s visible to the program.)</p>&#13;
<p class="indent">The <span class="literal">boost::scoped_ptr</span> is defined in the <span class="literal">&lt;boost/smart_ptr/scoped_ptr.hpp&gt;</span> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is no stdlib scoped pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec1"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">boost::scoped_ptr</span> takes a single template parameter corresponding to the pointed-to type, as in <span class="literal">boost::scoped_ptr&lt;int&gt;</span> for a “scoped pointer to <span class="literal">int</span>” type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_343"/>All smart pointers, including scoped pointers, have two modes: <em>empty</em> and <em>full</em>. An empty smart pointer owns no object and is roughly analogous to a <span class="literal">nullptr</span>. When a smart pointer is default constructed, it begins life empty.</p>&#13;
<p class="indent">The scoped pointer provides a constructor taking a raw pointer. (The pointed-to type must match the template parameter.) This creates a full-scoped pointer. The usual idiom is to create a dynamic object with <span class="literal">new</span> and pass the result to the constructor, like this:</p>&#13;
<pre>boost::scoped_ptr&lt;PointedToType&gt; my_ptr{ new PointedToType };</pre>&#13;
<p class="indent">This line dynamically allocates a <span class="literal">PointedToType</span> and passes its pointer to the scoped pointer constructor.</p>&#13;
<h4 class="h4" id="ch11lev2sec2"><strong><em>Bring in the Oath Breakers</em></strong></h4>&#13;
<p class="noindent">To explore scoped pointers, let’s create a Catch unit-test suite and a <span class="literal">DeadMenOfDunharrow</span> class that keeps track of how many objects are alive, as shown in <a href="ch11.xhtml#ch11ex01">Listing 11-1</a>.</p>&#13;
<pre>#define CATCH_CONFIG_MAIN <span class="ent">➊</span>&#13;
#include "catch.hpp" <span class="ent">➋</span>&#13;
#include &lt;boost/smart_ptr/scoped_ptr.hpp&gt; <span class="ent">➌</span>&#13;
&#13;
struct DeadMenOfDunharrow { <span class="ent">➍</span>&#13;
  DeadMenOfDunharrow(const char* m="") <span class="ent">➎</span>&#13;
    : message{ m } {&#13;
    oaths_to_fulfill++; <span class="ent">➏</span>&#13;
  }&#13;
  ~DeadMenOfDunharrow() {&#13;
    oaths_to_fulfill--; <span class="ent">➐</span>&#13;
  }&#13;
  const char* message;&#13;
  static int oaths_to_fulfill;&#13;
};&#13;
int DeadMenOfDunharrow::oaths_to_fulfill{};&#13;
using ScopedOathbreakers = boost::scoped_ptr&lt;DeadMenOfDunharrow&gt;; <span class="ent">➑</span></pre>&#13;
<p class="listing"><a id="ch11ex01"/><em>Listing 11-1: Setting up a Catch unit-test suite with a <span class="literal">DeadMenOfDunharrow</span> class to investigate scoped pointers</em></p>&#13;
<p class="indent">First, you declare <span class="literal">CATCH_CONFIG_MAIN</span> so Catch will provide an entry point <span class="ent">➊</span> and include the Catch header <span class="ent">➋</span> and then the Boost scoped pointer’s header <span class="ent">➌</span>. Next, you declare the <span class="literal">DeadMenOfDunharrow</span> class <span class="ent">➍</span>,which takes an optional null-terminated string that you save into the <span class="literal">message</span> field <span class="ent">➎</span>. The <span class="literal">static int</span> field called <span class="literal">oaths_to_fulfill</span> tracks how many <span class="literal">DeadMenOfDunharrow</span> objects have been constructed. Accordingly, you increment in the constructor <span class="ent">➏</span>, and you decrement in the destructor <span class="ent">➐</span>. Finally, you declare the <span class="literal">ScopedOathbreakers</span> type alias for convenience <span class="ent">➑</span>.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_344"/><strong>CATCH LISTINGS</strong></p>&#13;
<p class="noindent">You’ll use Catch unit tests in most listings from now on. For conciseness, the listings omit the following Catch ceremony:</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"</pre>&#13;
<p class="indent">All listings containing <span class="literal">TEST_CASE</span> require this preamble.</p>&#13;
<p class="indent">Also, every test case in each listing passes unless a comment indicates otherwise. Again, for conciseness, the listings omit the All tests pass output from the listings.</p>&#13;
<p class="indent">Finally, tests that employ user-defined types, functions, and variables from a previous listing will omit them for brevity.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec3"><strong><em>Implicit bool Conversion Based on Ownership</em></strong></h4>&#13;
<p class="noindent">Sometimes you need to determine whether a scoped pointer owns an object or whether it’s empty. Conveniently, <span class="literal">scoped_ptr</span> casts implicitly to <span class="literal">bool</span> depending on its ownership status: <span class="literal">true</span> if it owns an object; <span class="literal">false</span> otherwise. <a href="ch11.xhtml#ch11ex02">Listing 11-2</a> illustrates how this implicit casting behavior works.</p>&#13;
<pre>TEST_CASE("ScopedPtr evaluates to") {&#13;
  SECTION("true when full") {&#13;
    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➊</span>&#13;
    REQUIRE(aragorn); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("false when empty") {&#13;
    ScopedOathbreakers aragorn; <span class="ent">➌</span>&#13;
    REQUIRE_FALSE(aragorn); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex02"/><em>Listing 11-2: The boost::scoped_ptr casts implicitly to <span class="literal">bool</span>.</em></p>&#13;
<p class="indent">When you use the constructor taking a pointer <span class="ent">➊</span>, the <span class="literal">scoped_ptr</span> converts to <span class="literal">true</span> <span class="ent">➋</span>. When you use the default constructor <span class="ent">➌</span>, the <span class="literal">scoped_ptr</span> converts to <span class="literal">false<span class="ent">➍</span>.</span></p>&#13;
<h4 class="h4" id="ch11lev2sec4"><strong><em>RAII Wrapper</em></strong></h4>&#13;
<p class="noindent">When a <span class="literal">scoped_ptr</span> owns a dynamic object, it ensures proper dynamic object management. In the <span class="literal">scoped_ptr</span> destructor, it checks whether it owns an object. If it does, the <span class="literal">scoped_ptr</span> destructor deletes the dynamic object.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex03">Listing 11-3</a> illustrates this behavior by investigating the static <span class="literal">oaths_to_fulfill</span> variable between scoped pointer initializations.</p>&#13;
<pre><span epub:type="pagebreak" id="page_345"/>TEST_CASE("ScopedPtr is an RAII wrapper.") {&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); <span class="ent">➊</span>&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➋</span>&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➌</span>&#13;
  {&#13;
    ScopedOathbreakers legolas{ new DeadMenOfDunharrow{} }; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
  } <span class="ent">➏</span>&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex03"/><em>Listing 11-3: The <span class="literal">boost::scoped_ptr</span> is an RAII wrapper.</em></p>&#13;
<p class="indent">At the beginning of the test, <span class="literal">oaths_to_fulfill</span> is 0 because you haven’t constructed any <span class="literal">DeadMenOfDunharrow</span> yet <span class="ent">➊</span>. You construct the scoped pointer <span class="literal">aragorn</span> and pass in a pointer to the dynamic <span class="literal">DeadMenOfDunharrow</span> object <span class="ent">➋</span>. This increments the <span class="literal">oaths_to_fulfill</span> to 1 <span class="ent">➌</span>. Within a nested scope, you declare another scoped pointer <span class="literal">legolas</span> <span class="ent">➍</span>. Because <span class="literal">aragorn</span> is still alive, <span class="literal">oaths_to_fulfill</span> is now 2 <span class="ent">➎</span>. Once the inner scope closes, <span class="literal">legolas</span> falls out of scope and destructs, taking a <span class="literal">DeadMenOfDunharrow</span> with it <span class="ent">➏</span>. This decrements <span class="literal">DeadMenOfDunharrow</span> to 1 <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec5"><strong><em>Pointer Semantics</em></strong></h4>&#13;
<p class="noindent">For convenience, <span class="literal">scoped_ptr</span> implements the dereference <span class="literal">operator*</span> and the member dereference <span class="literal">operator-&gt;</span>, which simply delegate the calls to the owned dynamic object. You can even extract a raw pointer from a <span class="literal">scoped_ptr</span> with the <span class="literal">get</span> method, as demonstrated in <a href="ch11.xhtml#ch11ex04">Listing 11-4</a>.</p>&#13;
<pre>TEST_CASE("ScopedPtr supports pointer semantics, like") {&#13;
  auto message = "The way is shut";&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{ message } }; <span class="ent">➊</span>&#13;
  SECTION("operator*") {&#13;
    REQUIRE((*aragorn).message == message); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("operator-&gt;") {&#13;
    REQUIRE(aragorn-&gt;message == message); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("get(), which returns a raw pointer") {&#13;
    REQUIRE(aragorn.get() != nullptr); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex04"/><em>Listing 11-4: The boost::scoped_ptr supports pointer semantics.</em></p>&#13;
<p class="indent">You construct the scoped pointer <span class="literal">aragorn</span> with a <span class="literal">message</span> of <span class="literal">The way is</span> <span class="literal">shut</span> <span class="ent">➊</span>, which you use in three separate scenarios to test pointer semantics. First, you can use <span class="literal">operator*</span> to dereference the underlying, pointed-to dynamic object. In the example, you dereference <span class="literal">aragorn</span> and extract the <span class="literal">message</span> to verify that it matches <span class="ent">➋</span>. You can also use <span class="literal">operator-&gt;</span> to perform member dereference <span class="ent">➌</span>. Finally, if you want a raw pointer to the dynamic object, you can use the <span class="literal">get</span> method to extract it <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec6"><span epub:type="pagebreak" id="page_346"/><strong><em>Comparison with nullptr</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">scoped_ptr</span> class template implements the comparison operators <span class="literal">operator==</span> and <span class="literal">operator!=</span>, which are only defined when comparing a <span class="literal">scoped_ptr</span> with a <span class="literal">nullptr</span>. Functionally, this is essentially identical to implicit <span class="literal">bool</span> conversion, as <a href="ch11.xhtml#ch11ex05">Listing 11-5</a> illustrates.</p>&#13;
<pre>TEST_CASE("ScopedPtr supports comparison with nullptr") {&#13;
  SECTION("operator==") {&#13;
    ScopedOathbreakers legolas{};&#13;
    REQUIRE(legolas == nullptr); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("operator!=") {&#13;
    ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} };&#13;
    REQUIRE(aragorn != nullptr); <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex05"/><em>Listing 11-5: The <span class="literal">boost::scoped_ptr</span> supports comparison with <span class="literal">nullptr</span>.</em></p>&#13;
<p class="indent">An empty scoped pointer equals (<span class="literal">==</span>) <span class="literal">nullptr</span> <span class="ent">➊</span>, whereas a full scoped pointer doesn’t equal (<span class="literal">!=</span>) <span class="literal">nullptr</span> <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec7"><strong><em>Swapping</em></strong></h4>&#13;
<p class="noindent">Sometimes you want to switch the dynamic object owned by a <span class="literal">scoped_ptr</span> with the dynamic object owned by another <span class="literal">scoped_ptr</span>. This is called an <em>object swap</em>, and <span class="literal">scoped_ptr</span> contains a <span class="literal">swap</span> method that implements this behavior, as shown in <a href="ch11.xhtml#ch11ex06">Listing 11-6.</a></p>&#13;
<pre>TEST_CASE("ScopedPtr supports swap") {&#13;
  auto message1 = "The way is shut.";&#13;
  auto message2 = "Until the time comes.";&#13;
  ScopedOathbreakers aragorn {&#13;
    new DeadMenOfDunharrow{ message1 } <span class="ent">➊</span>&#13;
  };&#13;
  ScopedOathbreakers legolas {&#13;
    new DeadMenOfDunharrow{ message2 } <span class="ent">➋</span>&#13;
  };&#13;
  aragorn.swap(legolas); <span class="ent">➌</span>&#13;
  REQUIRE(legolas-&gt;message == message1); <span class="ent">➍</span>&#13;
  REQUIRE(aragorn-&gt;message == message2); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex06"/><em>Listing 11-6: The boost::scoped_ptr supports <span class="literal">swap</span>.</em></p>&#13;
<p class="indent">You construct two <span class="literal">scoped_ptr</span> objects, <span class="literal">aragorn</span> <span class="ent">➊</span> and <span class="literal">legolas</span> <span class="ent">➋</span>, each with a different message. After you perform a swap between <span class="literal">aragorn</span> and <span class="literal">legolas</span> <span class="ent">➌</span>, they exchange dynamic objects. When you pull out their messages after the swap, you find that they’ve switched <span class="ent">➍</span> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec8"><span epub:type="pagebreak" id="page_347"/><strong><em>Resetting and Replacing a scoped_ptr</em></strong></h4>&#13;
<p class="noindent">Rarely do you want to destruct an object owned by <span class="literal">scoped_ptr</span> before the <span class="literal">scoped_ptr</span> dies. For example, you might want to replace its owned object with a new dynamic object. You can handle both of these tasks with the overloaded <span class="literal">reset</span> method of <span class="literal">scoped_ptr</span>.</p>&#13;
<p class="indent">If you provide no argument, <span class="literal">reset</span> simply destroys the owned object.</p>&#13;
<p class="indent">If you instead provide a new dynamic object as a parameter, <span class="literal">reset</span> will first destroy the currently owned object and then gain ownership of the parameter. <a href="ch11.xhtml#ch11ex07">Listing 11-7</a> illustrates such behavior with one test for each scenario.</p>&#13;
<pre>TEST_CASE("ScopedPtr reset") {&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➊</span>&#13;
  SECTION("destructs owned object.") {&#13;
    aragorn.reset(); <span class="ent">➋</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 0); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("can replace an owned object.") {&#13;
    auto message = "It was made by those who are Dead.";&#13;
    auto new_dead_men = new DeadMenOfDunharrow{ message }; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
    aragorn.reset(new_dead_men); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
    REQUIRE(aragorn-&gt;message == new_dead_men-&gt;message); <span class="ent">➑</span>&#13;
    REQUIRE(aragorn.get() == new_dead_men); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex07"/><em>Listing 11-7: The boost::scoped_ptr supports <span class="literal">reset</span>.</em></p>&#13;
<p class="indent">The first step in both tests is to construct the scoped pointer <span class="literal">aragorn</span> owning a <span class="literal">DeadMenOfDunharrow</span> <span class="ent">➊</span>. In the first test, you call <span class="literal">reset</span> without an argument <span class="ent">➋</span>. This causes the scoped pointer to destruct its owned object, and <span class="literal">oaths_to_fulfill</span> decrements to 0 <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the second test, you create the new, dynamically allocated <span class="literal">new_dead_men</span> with a custom <span class="literal">message</span> <span class="ent">➍</span>. This increases the <span class="literal">oaths_to_fill</span> to 2, because <span class="literal">ara</span><span class="literal">gorn</span> is also still alive <span class="ent">➎</span>. Next, you invoke <span class="literal">reset</span> with <span class="literal">new_dead_men</span> as the argument <span class="ent">➏</span>, which does two things:</p>&#13;
<ul>&#13;
<li class="noindent">It causes the original <span class="literal">DeadMenOfDunharrow</span> owned by <span class="literal">aragorn</span> to get destructed, which decrements <span class="literal">oaths_to_fulfill</span> to 1 <span class="ent">➐</span>.</li>&#13;
<li class="noindent">It emplaces <span class="literal">new_dead_men</span> as the dynamically allocated object owned by <span class="literal">aragorn</span>. When you dereference the <span class="literal">message</span> field, notice that it matches the <span class="literal">message</span> held by <span class="literal">new_dead_men</span> <span class="ent">➑</span>. (Equivalently, <span class="literal">aragorn.get()</span> yields <span class="literal">new_dead_men</span> <span class="ent">➒</span>.)</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch11lev2sec9"><span epub:type="pagebreak" id="page_348"/><strong><em>Non-transferability</em></strong></h4>&#13;
<p class="indent">You cannot move or copy a <span class="literal">scoped_ptr</span>, making it non-transferable. <a href="ch11.xhtml#ch11ex08">Listing 11-8</a> illustrates how attempting to move or copy a <span class="literal">scoped_ptr</span> results in an invalid program.</p>&#13;
<pre>void by_ref(const ScopedOathbreakers&amp;) { } <span class="ent">➊</span>&#13;
void by_val(ScopedOathbreakers) { } <span class="ent">➋</span>&#13;
&#13;
TEST_CASE("ScopedPtr can") {&#13;
  ScopedOathbreakers aragorn{ new DeadMenOfDunharrow };&#13;
  SECTION("be passed by reference") {&#13;
    by_ref(aragorn); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("not be copied") {&#13;
    // DOES NOT COMPILE:&#13;
    by_val(aragorn); <span class="ent">➍</span>&#13;
    auto son_of_arathorn = aragorn; <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("not be moved") {&#13;
    // DOES NOT COMPILE:&#13;
    by_val(std::move(aragorn)); <span class="ent">➏</span>&#13;
    auto son_of_arathorn = std::move(aragorn); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex08"/><em>Listing 11-8: The <span class="literal">boost::scoped_ptr</span> is non-transferable. (This code doesn’t compile.)</em></p>&#13;
<p class="indent">First, you declare dummy functions that take a <span class="literal">scoped_ptr</span> by reference <span class="ent">➊</span> and by value <span class="ent">➋</span>. You can still pass a <span class="literal">scoped_ptr</span> by reference <span class="ent">➌</span>, but attempting to pass one by value will fail to compile <span class="ent">➍</span>. Also, attempting to use the <span class="literal">scoped_ptr</span> copy constructor or a copy assignment operator <span class="ent">➎</span> will fail to compile. In addition, if you try to move a <span class="literal">scoped_ptr</span> with <span class="literal">std::move</span>, your code won’t compile <span class="ent">➏</span><span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Generally, using a <span class="codeitalic">boost::scoped_ptr</span> incurs no overhead compared with using a raw pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec10"><strong><em>boost::scoped_array</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">boost::scoped_array</span> is a scoped pointer for dynamic arrays. It supports the same usages as a <span class="literal">boost::scoped_ptr</span>, but it also implements an <span class="literal">operator[]</span> so you can interact with elements of the scoped array in the same way as you can with a raw array. <a href="ch11.xhtml#ch11ex09">Listing 11-9</a> illustrates this additional feature.</p>&#13;
<pre>TEST_CASE("ScopedArray supports operator[]") {&#13;
  boost::scoped_array&lt;int<span class="ent">➊</span>&gt; squares{&#13;
    new int<span class="ent">➋</span>[5] { 0, 4, 9, 16, 25 }&#13;
  };&#13;
  squares[0] = 1; <span class="ent">➌</span>&#13;
  REQUIRE(squares[0] == 1); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_349"/>  REQUIRE(squares[1] == 4);&#13;
  REQUIRE(squares[2] == 9);&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex09"/><em>Listing 11-9: The <span class="literal">boost::scoped_array</span> implements <span class="literal">operator[]</span>.</em></p>&#13;
<p class="indent">You declare a <span class="literal">scoped_array</span> the same way you declare a <span class="literal">scoped_ptr</span>, by using a single template parameter <span class="ent">➊</span>. In the case of <span class="literal">scoped_array</span>, the template parameter is the type contained by the array <span class="ent">➋</span>, not the type of the array. You pass in a dynamic array to the constructor of <span class="literal">squares</span>, making the dynamic array <span class="literal">squares</span> the array’s owner. You can use <span class="literal">operator[]</span> to write <span class="ent">➌</span> and read <span class="ent">➍</span> elements.</p>&#13;
<h4 class="h4" id="ch11lev2sec11"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent">So far, you’ve learned about the major features of scoped pointers. For reference, <a href="ch11.xhtml#ch11tab01">Table 11-1</a> enumerates all the operators discussed, plus a few that haven’t been covered yet. In the table, <span class="literal">ptr</span> is a raw pointer and <span class="literal">s_ptr</span> is a scoped pointer. See the Boost documentation for more information.</p>&#13;
<p class="tabcap"><a id="ch11tab01"/><strong>Table 11-1:</strong> All of the Supported <span class="literal">boost::scoped_ptr</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">scoped_ptr&lt;...&gt;{ }</span> or <span class="literal">scoped_ptr &lt;...&gt;{ nullptr }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty scoped pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">scoped_ptr &lt;...&gt;{</span> <span class="codestrong">ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a scoped pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~scoped_ptr&lt;...&gt;()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls <span class="literal">delete</span> on the owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr1</span><span class="literal">.swap(</span><span class="codestrong">s_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges owned objects between <span class="codestrong">s_ptr1</span> and <span class="codestrong">s_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">swap(</span><span class="codestrong">s_ptr1, s_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A free function identical to the <span class="literal">swap</span> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr</span><span class="literal">.reset()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If full, calls <span class="literal">delete</span> on object owned by <span class="codestrong">s_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s_ptr</span><span class="literal">.reset(</span><span class="codestrong">ptr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Deletes currently owned object and then takes ownership of <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ptr</span> <span class="literal">=</span> <span class="codestrong">s_ptr</span><span class="literal">.get()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the raw pointer <span class="literal">ptr</span>; <span class="literal">s_ptr</span> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">*</span><span class="codestrong">s_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s_ptr</span><span class="literal">-&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member dereferences operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">bool{</span> <span class="codestrong">s_ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">bool</span> conversion: <span class="literal">true</span> if full, <span class="literal">false</span> if empty.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec4"><strong>Unique Pointers</strong></h3>&#13;
<p class="indent">A <em>unique pointer</em> has transferable, exclusive ownership over a single dynamic object. You <em>can</em> move unique pointers, which makes them transferable. They also have exclusive ownership, so they <em>cannot</em> be copied. The stdlib has a <span class="literal">unique_ptr</span> available in the <span class="literal">&lt;memory&gt;</span> header.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost doesn’t offer a unique pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec12"><strong><em><span epub:type="pagebreak" id="page_350"/>Constructing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::unique_ptr</span> takes a single template parameter corresponding to the pointed-to type, as in <span class="literal">std::unique_ptr&lt;int&gt;</span> for a “unique pointer to <span class="literal">int</span>” type.</p>&#13;
<p class="indent">As with a scoped pointer, the unique pointer has a default constructor that initializes the unique pointer to empty. It also provides a constructor taking a raw pointer that takes ownership of the pointed-to dynamic object. One construction method is to create a dynamic object with <span class="literal">new</span> and pass the result to the constructor, like this:</p>&#13;
<pre>std::unique_ptr&lt;int&gt; my_ptr{ new int{ 808 } };</pre>&#13;
<p class="indent">Another method is to use the <span class="literal">std::make_unique</span> function. The <span class="literal">make_unique</span> function is a template that takes all the arguments and forwards them to the appropriate constructor of the template parameter. This obviates the need for <span class="literal">new</span>. Using <span class="literal">std::make_unique</span>, you could rewrite the preceding object initialization as:</p>&#13;
<pre>auto my_ptr = make_unique&lt;int&gt;(808);</pre>&#13;
<p class="indent">The <span class="literal">make_unique</span> function was created to avoid some devilishly subtle memory leaks that used to occur when you used <span class="literal">new</span> with previous versions of C++. However, in the latest version of C++, these memory leaks no longer occur. Which constructor you use mainly depends on your preference.</p>&#13;
<h4 class="h4" id="ch11lev2sec13"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="indent">The <span class="literal">std::unique_ptr</span> function supports every operation that <span class="literal">boost::scoped_ptr</span> supports. For example, you can use the following type alias as a drop-in replacement for <span class="literal">ScopedOathbreakers</span> in <a href="ch11.xhtml#ch11ex01">Listings 11-1</a> to <a href="ch11.xhtml#ch11ex07">11-7</a>:</p>&#13;
<pre>using UniqueOathbreakers = std::unique_ptr&lt;DeadMenOfDunharrow&gt;;</pre>&#13;
<p class="indent">One of the major differences between unique and scoped pointers is that you can move unique pointers because they’re <em>transferable</em>.</p>&#13;
<h4 class="h4" id="ch11lev2sec14"><strong><em>Transferable, Exclusive Ownership</em></strong></h4>&#13;
<p class="noindent">Not only are unique pointers transferable, but they have exclusive ownership (you <em>cannot</em> copy them). <a href="ch11.xhtml#ch11ex10">Listing 11-10</a> illustrates how you can use the move semantics of <span class="literal">unique_ptr</span>.</p>&#13;
<pre>TEST_CASE("UniquePtr can be used in move") {&#13;
  auto aragorn = std::make_unique&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➊</span>&#13;
  SECTION("construction") {&#13;
    auto son_of_arathorn{ std::move(aragorn) }; <span class="ent">➋</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("assignment") {&#13;
    auto son_of_arathorn = std::make_unique&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_351"/>    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2); <span class="ent">➎</span>&#13;
    son_of_arathorn = std::move(aragorn); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➐</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex10"/><em>Listing 11-10: The <span class="literal">std::unique_ptr</span> supports move semantics for transferring ownership.</em></p>&#13;
<p class="indent">This listing creates a <span class="literal">unique_ptr</span> called <span class="literal">aragorn</span> <span class="ent">➊</span> that you use in two separate tests.</p>&#13;
<p class="indent">In the first test, you move <span class="literal">aragorn</span> with <span class="literal">std::move</span> into the move constructor of <span class="literal">son_of_arathorn</span> <span class="ent">➋</span>. Because <span class="literal">aragorn</span> transfers ownership of its <span class="literal">DeadMenOfDunharrow</span> to <span class="literal">son_of_arathorn</span>, the <span class="literal">oaths_to_fulfill</span> object still only has value 1 <span class="ent">➌</span>.</p>&#13;
<p class="indent">The second test constructs <span class="literal">son_of_arathorn</span> via <span class="literal">make_unique</span> <span class="ent">➍</span>, which pushes the <span class="literal">oaths_to_fulfill</span> to 2 <span class="ent">➎</span>. Next, you use the move assignment operator to move <span class="literal">aragorn</span> into <span class="literal">son_of_arathorn</span> <span class="ent">➏</span>. Again, <span class="literal">aragorn</span> transfers ownership to <span class="literal">son_of_aragorn</span>. Because <span class="literal">son_of_aragorn</span> can own only one dynamic object at a time, the move assignment operator destroys the currently owned object before emptying the dynamic object of <span class="literal">aragorn</span>. This results in <span class="literal">oaths_to_fulfill</span> decrementing to 1 <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec15"><strong><em>Unique Arrays</em></strong></h4>&#13;
<p class="noindent">Unlike <span class="literal">boost::scoped_ptr</span>, <span class="literal">std::unique_ptr</span> has built-in dynamic array support. You just use the array type as the template parameter in the unique pointer’s type, as in <span class="literal">std::unique_ptr&lt;int[]&gt;</span>.</p>&#13;
<p class="indent">It’s <em>very important</em> that you don’t initialize a <span class="literal">std::unique_ptr&lt;T&gt;</span> with a dynamic array <span class="literal">T[]</span>. Doing so will cause undefined behavior, because you’ll be causing a <span class="literal">delete</span> of an array (rather than <span class="literal">delete[]</span>). The compiler cannot save you, because <span class="literal">operator new[]</span> returns a pointer that is indistinguishable from the kind returned by <span class="literal">operator new</span>.</p>&#13;
<p class="indent">Like <span class="literal">scoped_array</span>, a <span class="literal">unique_ptr</span> to array type offers <span class="literal">operator[]</span> for accessing elements. <a href="ch11.xhtml#ch11ex11">Listing 11-11</a> demonstrates this concept.</p>&#13;
<pre>TEST_CASE("UniquePtr to array supports operator[]") {&#13;
  std::unique_ptr&lt;int[]<span class="ent">➊</span>&gt; squares{&#13;
    new int[5]{ 1, 4, 9, 16, 25 } <span class="ent">➋</span>&#13;
  };&#13;
  squares[0] = 1; <span class="ent">➌</span>&#13;
  REQUIRE(squares[0] == 1); <span class="ent">➍</span>&#13;
  REQUIRE(squares[1] == 4);&#13;
  REQUIRE(squares[2] == 9);&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex11"/><em>Listing 11-11: The <span class="literal">std::unique_ptr</span> to an array type supports <span class="literal">operator[]</span>.</em></p>&#13;
<p class="indent">The template parameter <span class="literal">int[]</span> <span class="ent">➊</span> indicates to <span class="literal">std::unique_ptr</span> that it owns a dynamic array. You pass in a newly minted dynamic array <span class="ent">➋</span> and then use <span class="literal">operator[]</span> to set the first element <span class="ent">➌</span>; then you use <span class="literal">operator[]</span> to retrieve elements <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec16"><span epub:type="pagebreak" id="page_352"/><strong><em>Deleters</em></strong></h4>&#13;
<p class="indent">The <span class="literal">std::unique_ptr</span> has a second, optional template parameter called its deleter type. A unique pointer’s <em>deleter</em> is what gets called when the unique pointer needs to destroy its owned object.</p>&#13;
<p class="indent">A <span class="literal">unique_ptr</span> instantiation contains the following template parameters:</p>&#13;
<pre>std::unique_ptr&lt;T, Deleter=std::default_delete&lt;T&gt;&gt;</pre>&#13;
<p class="indent">The two template parameters are <span class="literal">T</span>, the type of the owned dynamic object, and <span class="literal">Deleter</span>, the type of the object responsible for freeing an owned object. By default, <span class="literal">Deleter</span> is <span class="literal">std::default_delete&lt;T&gt;</span>, which calls <span class="literal">delete</span> or <span class="literal">delete[]</span> on the dynamic object.</p>&#13;
<p class="indent">To write a custom deleter, all you need is a function-like object that is invokable with a <span class="literal">T*</span>. (The unique pointer will ignore the deleter’s return value.) You pass this deleter as the second parameter to the unique pointer’s constructor, as shown in <a href="ch11.xhtml#ch11ex12">Listing 11-12</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
auto my_deleter = [](int* x) { <span class="ent">➊</span>&#13;
  printf("Deleting an int at %p.", x);&#13;
  delete x;&#13;
};&#13;
std::unique_ptr&lt;int<span class="ent">➋</span>, decltype(my_deleter)<span class="ent">➌</span>&gt; my_up{&#13;
  new int,&#13;
  my_deleter&#13;
};</pre>&#13;
<p class="listing"><a id="ch11ex12"/><em>Listing 11-12: Passing a custom deleter to a unique pointer</em></p>&#13;
<p class="indent">The owned object type is <span class="literal">int</span> <span class="ent">➋</span>, so you declare a <span class="literal">my_deleter</span> function object that takes an <span class="literal">int*</span> <span class="ent">➊</span>. You use <span class="literal">decltype</span> to set the deleter template parameter <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec17"><strong><em>Custom Deleters and System Programming</em></strong></h4>&#13;
<p class="noindent">You use a custom deleter whenever <span class="literal">delete</span> doesn’t provide the resource-releasing behavior you require. In some settings, you’ll never need a custom deleter. In others, like system programming, you might find them quite useful. Consider a simple example where you manage a file using the low-level APIs <span class="literal">fopen</span>, <span class="literal">fprintf</span>, and <span class="literal">fclose</span> in the <span class="literal">&lt;cstdio&gt;</span> header.</p>&#13;
<p>The <span class="literal">fopen</span> function opens a file and has the following signature:</p>&#13;
<pre>FILE*<span class="ent">➊</span> fopen(const char *filename<span class="ent">➋</span>, const char *mode<span class="ent">➌</span>);</pre>&#13;
<p class="indent">On success, <span class="literal">fopen</span> returns a non-<span class="literal">nullptr</span>-valued <span class="literal">FILE*</span> <span class="ent">➊</span>. On failure, <span class="literal">fopen</span> returns <span class="literal">nullptr</span> and it sets the static <span class="literal">int</span> variable <span class="literal">errno</span> equal to an error code, like access denied (<span class="literal">EACCES</span> <span class="literal">= 13</span>) or no such file (<span class="literal">ENOENT</span> <span class="literal">= 2</span>).</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_353"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See the <span class="codeitalic">errno.h</span> header for a listing of all error conditions and their corresponding <span class="codeitalic">int</span> values.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">FILE*</span> file handle    is a reference to a file the operating system manages. A <em>handle</em> is an opaque, abstract reference to some resource in an operating system. The <span class="literal">fopen</span> function takes two arguments: <span class="literal">filename</span> <span class="ent">➋</span> is the path to the file you want to open, and <span class="literal">mode</span> <span class="ent">➌</span> is one of the six options shown in <a href="ch11.xhtml#ch11tab02">Table 11-2</a>.</p>&#13;
<p class="tabcap"><a id="ch11tab02"/><strong>Table 11-2:</strong> All Six <span class="literal">mode</span> Options for <span class="literal">fopen</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>String</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operations</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File exists:</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>File doesn’t exist:</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">r</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">fopen</span> fails</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">w</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Overwrite</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">If the file exists, all contents are discarded.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">a</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Append</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Always write to the end of the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">r+</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">fopen</span> fails</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">w+</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Overwrite</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If the file exists, all contents are discarded.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">a+</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Read/Write</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Create it</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Always write to the end of the file.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You must close the file manually with <span class="literal">fclose</span> once you’re done using it. Failure to close file handles is a common source of resource leakages, like so:</p>&#13;
<pre>void fclose(FILE* file);</pre>&#13;
<p class="indent">To write to a file, you can use the <span class="literal">fprintf</span> function, which is like a <span class="literal">printf</span> that prints to a file instead of the console. The <span class="literal">fprintf</span> function has identical usage to <span class="literal">printf</span> except you provide a file handle as the first argument before the format string:</p>&#13;
<pre>int<span class="ent">➊</span> fprintf(FILE* file<span class="ent">➋</span>, const char* format_string<span class="ent">➌</span>, ...<span class="ent">➍</span>);</pre>&#13;
<p class="indent">On success, <span class="literal">fprintf</span> returns the number of characters <span class="ent">➊</span> written to the open file <span class="ent">➋</span>. The <span class="literal">format_string</span> is the same as the format string for <span class="literal">printf</span> <span class="ent">➌</span>, as are the variadic arguments <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can use a <span class="literal">std::unique_ptr</span> to a <span class="literal">FILE</span>. Obviously, you don’t want to call <span class="literal">delete</span> on the <span class="literal">FILE*</span> file handle when you’re ready to close the file. Instead, you need to close with <span class="literal">fclose</span>. Because <span class="literal">fclose</span> is a function-like object accepting a <span class="literal">FILE*</span>, it’s a suitable deleter.</p>&#13;
<p class="indent">The program in <a href="ch11.xhtml#ch11ex13">Listing 11-13</a> writes the string <span class="literal">HELLO, DAVE.</span> to the file <span class="literal">HAL9000</span> and uses a unique pointer to perform resource management over the open file.</p>&#13;
<pre><span epub:type="pagebreak" id="page_354"/>#include &lt;cstdio&gt;&#13;
#include &lt;memory&gt;&#13;
&#13;
using FileGuard = std::unique_ptr&lt;FILE, int(*)(FILE*)&gt;; <span class="ent">➊</span>&#13;
&#13;
void say_hello(FileGuard file<span class="ent">➋</span>) {&#13;
  fprintf(file.get(), "HELLO DAVE"); <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  auto file = fopen("HAL9000", "w"); <span class="ent">➍</span>&#13;
  if (!file) return errno; <span class="ent">➎</span>&#13;
  FileGuard file_guard{ file, fclose }; <span class="ent">➏</span>&#13;
  // File open here&#13;
  say_hello(std::move(file_guard)); <span class="ent">➐</span>&#13;
  // File closed here&#13;
  return 0;&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex13"/><em>Listing 11-13: A program using a <span class="literal">std::unique_ptr</span> and a custom deleter to manage a file handle</em></p>&#13;
<p class="indent">This listing makes the <span class="literal">FileGuard</span> type alias <span class="ent">➊</span> for brevity. (Notice the deleter type matches the type of <span class="literal">fclose</span>.) Next is a <span class="literal">say_hello</span> function that takes a <span class="literal">FileGuard</span> by value <span class="ent">➋</span>. Within <span class="literal">say_hello</span>, you <span class="literal">fprintf HELLO DAVE</span> to the <span class="literal">file</span> <span class="ent">➌</span>. Because the lifetime of <span class="literal">file</span> is bound to <span class="literal">say_hello</span>, the file gets closed once <span class="literal">say_hello</span> returns. Within <span class="literal">main</span>, you open the file <span class="literal">HAL9000</span> in <span class="literal">w</span> mode, which will create or overwrite the file, and you save the raw <span class="literal">FILE*</span> file handle into <span class="literal">file</span> <span class="ent">➍</span>. You check whether <span class="literal">file</span> is <span class="literal">nullptr</span>, indicating an error occurred, and return with <span class="literal">errno</span> if <span class="literal">HAL9000</span> couldn’t be opened <span class="ent">➎</span>. Next, you construct a <span class="literal">FileGuard</span> by passing the file handle <span class="literal">file</span> and the custom deleter <span class="literal">fclose</span> <span class="ent">➏</span>. At this point, the file is open, and thanks to its custom deleter, <span class="literal">file_guard</span> manages the file’s lifetime automatically.</p>&#13;
<p class="indent">To call <span class="literal">say_hello</span>, you need to transfer ownership into that function (because it takes a <span class="literal">FileGuard</span> by value) <span class="ent">➐</span>. Recall from “Value Categories” on <a href="ch04.xhtml#page_124">page 124</a> that variables like <span class="literal">file_guard</span> are lvalues. This means you must move it into <span class="literal">say_hello</span> with <span class="literal">std::move</span>, which writes <span class="literal">HELLO DAVE</span> to the file. If you omit <span class="literal">std::move</span>, the compiler would attempt to copy it into <span class="literal">say_hello</span>. Because <span class="literal">unique_ptr</span> has a deleted copy constructor, this would generate a compiler error.</p>&#13;
<p class="indent">When <span class="literal">say_hello</span> returns, its <span class="literal">FileGuard</span> argument destructs and the custom deleter calls <span class="literal">fclose</span> on the file handle. Basically, it’s impossible to leak the file handle. You’ve tied it to the lifetime of <span class="literal">FileGuard</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec18"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab03">Table 11-3</a> enumerates all the supported <span class="literal">std::unique_ptr</span> operations. In this table, <span class="literal">ptr</span> is a raw pointer, <span class="literal">u_ptr</span> is a unique pointer, and <span class="literal">del</span> is a deleter.</p>&#13;
<p class="tabcap"><a id="ch11tab03"/><span epub:type="pagebreak" id="page_355"/><strong>Table 11-3:</strong> All of the Supported <span class="literal">std::unique_ptr</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">unique_ptr&lt;...&gt;{ }</span> or <span class="literal">unique_ptr&lt;...&gt;{ nullptr }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty unique pointer with a <span class="literal">std::default_delete&lt;...&gt;</span> deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">unique_ptr&lt;...&gt;{</span> <span class="codestrong">ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses a <span class="literal">std::default_delete&lt;...&gt;</span> deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">unique_ptr&lt;...&gt;{</span> <span class="codestrong">ptr, del</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses <span class="codestrong">del</span> as deleter.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">unique_ptr&lt;...&gt;{ move(</span><span class="codestrong">u_ptr</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a unique pointer owning the dynamic object pointed to by the unique pointer <span class="codestrong">u_ptr</span>. Transfers ownership from <span class="codestrong">u_ptr</span> to the newly created unique pointer. Also moves the deleter of <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~unique_ptr&lt;...&gt;()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls deleter on the owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">= move(</span><span class="codestrong">u_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">u_ptr2</span> to <span class="codestrong">u_ptr1</span>. Destroys currently owned object if full.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr1.</span><span class="literal">swap(</span><span class="codestrong">u_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges owned objects and deleters between <span class="codestrong">u_ptr1</span> and <span class="codestrong">u_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">swap(</span><span class="codestrong">u_ptr1</span><span class="literal">,</span> <span class="codestrong">u_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A free function identical to the <span class="literal">swap</span> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr</span><span class="literal">.reset()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If full, calls deleter on object owned by <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr</span><span class="literal">.reset(</span><span class="codestrong">ptr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deletes currently owned object; then takes ownership of <span class="codestrong">ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ptr</span> <span class="literal">=</span> <span class="codestrong">u_ptr</span><span class="literal">.release()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">u_ptr</span> becomes empty. Deleter <em>is not</em> called.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">ptr</span> <span class="literal">=</span> <span class="codestrong">u_ptr</span><span class="literal">.get()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">u_ptr</span> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">*</span><span class="codestrong">u_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">u_ptr</span><span class="literal">-&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Member dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr</span><span class="literal">[</span><span class="codestrong">index</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">References the element at <span class="codestrong">index</span> (arrays only).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">bool{</span> <span class="codestrong">u_ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">bool</span> conversion: <span class="literal">true</span> if full, <span class="literal">false</span> if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">==</span> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">!=</span> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">&gt;</span> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">&gt;=</span> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">&lt;</span> <span class="codestrong">u_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">u_ptr1</span> <span class="literal">&lt;=</span> <span class="codestrong">u_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Comparison operators; equivalent to evaluating comparison operators on raw pointers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">u_ptr</span><span class="literal">.get_deleter()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a reference to the deleter.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec5"><strong>Shared Pointers</strong></h3>&#13;
<p class="indent">A <em>shared pointer</em> has transferable, non-exclusive ownership over a single dynamic object. You can move shared pointers, which makes them transferable, and you <em>can</em> copy them, which makes their ownership non-exclusive.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_356"/>Non-exclusive ownership means that a <span class="literal">shared_ptr</span> checks whether any other <span class="literal">shared_ptr</span> objects also own the object before destroying it. This way, the last owner is the one to release the owned object.</p>&#13;
<p class="indent">The stdlib has a <span class="literal">std::shared_ptr</span> available in the <span class="literal">&lt;memory&gt;</span> header, and Boost has a <span class="literal">boost::shared_ptr</span> available in the <span class="literal">&lt;boost/smart_ptr/shared_ptr.hpp&gt;</span> header. You’ll use the stdlib version here.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Both the stdlib and Boost <span class="literal">shared_ptr</span> are essentially identical, with the notable exception that Boost’s shared pointer doesn’t support arrays and requires you to use the <span class="literal">boost::shared_array</span> class in <span class="literal">&lt;boost/smart_ptr/shared_array.hpp&gt;</span>. Boost offers a shared pointer for legacy reasons, but you should use the stdlib shared pointer.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch11lev2sec19"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::shared_ptr</span> pointer supports all the same constructors as <span class="literal">std::unique_ptr</span>. The default constructor yields an empty shared pointer. To instead establish ownership over a dynamic object, you can pass a pointer to the <span class="literal">shared_ptr</span> constructor, like so:</p>&#13;
<pre>std::shared_ptr&lt;int&gt; my_ptr{ new int{ 808 } };</pre>&#13;
<p class="indent">You also have a corollary <span class="literal">std::make_shared</span> template function that forwards arguments to the pointed-to type’s constructor:</p>&#13;
<pre>auto my_ptr = std::make_shared&lt;int&gt;(808);</pre>&#13;
<p class="indent">You should generally use <span class="literal">make_shared</span>. Shared pointers require a <em>control block</em>, which keeps track of several quantities, including the number of shared owners. When you use <span class="literal">make_shared</span>, you can allocate the control block and the owned dynamic object simultaneously. If you first use <span class="literal">operator new</span> and then allocate a shared pointer, you’re making two allocations instead of one.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Sometimes you might want to avoid using <span class="literal">make_shared</span>. For example, if you’ll be using a <span class="literal">weak_ptr</span>, you’ll still need the control block even if you can deallocate the object. In such a situation, you might prefer to have two allocations.</em></p>&#13;
</div>&#13;
<p class="indent">Because a control block is a dynamic object, <span class="literal">shared_ptr</span> objects sometimes need to allocate dynamic objects. If you wanted to take control over how <span class="literal">shared_ptr</span> allocates, you could override <span class="literal">operator new</span>. But this is shooting a sparrow with a cannon. A more tailored approach is to provide an optional template parameter called an <em>allocator type</em>.</p>&#13;
<h4 class="h4" id="ch11lev2sec20"><strong><em>Specifying an Allocator</em></strong></h4>&#13;
<p class="noindent">The allocator is responsible for allocating, creating, destroying, and deallocating objects. The default allocator, <span class="literal">std::allocator</span>, is a template class defined in the <span class="literal">&lt;memory&gt;</span> header. The default allocator allocates memory from dynamic storage and takes a template parameter. (You’ll learn about <span epub:type="pagebreak" id="page_357"/>customizing this behavior with a user-defined allocator in “Allocators” on <a href="ch11.xhtml#page_365">page 365</a>).</p>&#13;
<p class="indent">Both the <span class="literal">shared_ptr</span> constructor and <span class="literal">make_shared</span> have an allocator type template parameter, making three total template parameters: the pointed-to type, the deleter type, and the allocator type. For complicated reasons, you only ever need to declare the <em>pointed-to type</em> parameter. You can think of the other parameter types as being deduced from the pointed-to type.</p>&#13;
<p class="indent">For example, here’s a fully adorned <span class="literal">make_shared</span> invocation including a constructor argument, a custom deleter, and an explicit <span class="literal">std::allocator</span>:</p>&#13;
<pre>std::shared_ptr&lt;int<span class="ent">➊</span>&gt; sh_ptr{&#13;
  new int{ 10 }<span class="ent">➋</span>,&#13;
  [](int* x) { delete x; } <span class="ent">➌</span>,&#13;
  std::allocator&lt;int&gt;{} <span class="ent">➍</span>&#13;
};</pre>&#13;
<p class="indent">Here, you specify a single template parameter, <span class="literal">int</span>, for the pointed-to type <span class="ent">➊</span>. In the first argument, you allocate and initialize an <span class="literal">int</span> <span class="ent">➋</span>. Next is a custom deleter <span class="ent">➌</span>, and as a third argument you pass a <span class="literal">std::allocator</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">For technical reasons, you can’t use a custom deleter or custom allocator with <span class="literal">make_shared</span>. If you want a custom allocator, you can use the sister function of <span class="literal">make_shared</span>, which is <span class="literal">std::allocate_shared</span>. The <span class="literal">std::allocate _</span><span class="literal">shared</span> function takes an allocator as the first argument and forwards the remainder of the arguments to the owned object’s constructor:</p>&#13;
<pre>auto sh_ptr = std::allocate_shared&lt;int<span class="ent">➊</span>&gt;(std::allocator&lt;int&gt;{}<span class="ent">➋</span>, 10<span class="ent">➌</span>);</pre>&#13;
<p class="indent">As with <span class="literal">make_shared</span>, you specify the owned type as a template parameter <span class="ent">➊</span>, but you pass an allocator as the first argument <span class="ent">➋</span>. The rest of the arguments forward to the constructor of <span class="literal">int</span> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the curious, here are two reasons why you can’t use a custom deleter with <span class="literal">make_</span><span class="literal">shared</span>. First, <span class="literal">make_shared</span> uses <span class="literal">new</span> to allocate space for the owned object and the control block. The appropriate deleter for <span class="literal">new</span> is <span class="literal">delete</span>, so generally a custom deleter wouldn’t be appropriate. Second, the custom deleter can’t generally know how to deal with the control block, only with the owned object.</em></p>&#13;
</div>&#13;
<p class="indent">It isn’t possible to specify a custom deleter with either <span class="literal">make_shared</span> or <span class="literal">allocate_shared</span>. If you want to use a custom deleter with shared pointers, you must use one of the appropriate <span class="literal">shared_ptr</span> constructors directly.</p>&#13;
<h4 class="h4" id="ch11lev2sec21"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">std::shared_ptr</span> supports every operation that <span class="literal">std::unique_ptr</span> and <span class="literal">boost::scoped_ptr</span> support. You could use the following type alias as a drop-in replacement for <span class="literal">ScopedOathbreakers</span> in <a href="ch11.xhtml#ch11ex01">Listings 11-1</a> to <a href="ch11.xhtml#ch11ex07">11-7</a> and <span class="literal">UniqueOathbreakers</span> from <a href="ch11.xhtml#ch11ex10">Listings 11-10</a> to <a href="ch11.xhtml#ch11ex13">11-13</a>:</p>&#13;
<pre>using SharedOathbreakers = std::shared_ptr&lt;DeadMenOfDunharrow&gt;;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_358"/>The major functional difference between a shared pointer and a unique pointer is that you can copy shared pointers.</p>&#13;
<h4 class="h4" id="ch11lev2sec22"><strong><em>Transferable, Non-Exclusive Ownership</em></strong></h4>&#13;
<p class="noindent">Shared pointers are transferable (you <em>can</em> move them), and they have non-exclusive ownership (you <em>can</em> copy them). <a href="ch11.xhtml#ch11ex10">Listing 11-10</a>, which illustrates a unique pointer’s move semantics, works the same for a shared pointer. <a href="ch11.xhtml#ch11ex14">Listing 11-14</a> demonstrates that shared pointers also support copy semantics.</p>&#13;
<pre>TEST_CASE("SharedPtr can be used in copy") {&#13;
  auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;();&#13;
  SECTION("construction") {&#13;
    auto son_of_arathorn{ aragorn }; <span class="ent">➊</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("assignment") {&#13;
    SharedOathbreakers son_of_arathorn; <span class="ent">➌</span>&#13;
    son_of_arathorn = aragorn; <span class="ent">➍</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("assignment, and original gets discarded") {&#13;
    auto son_of_arathorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(); <span class="ent">➏</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 2);<span class="ent">➐</span>&#13;
    son_of_arathorn = aragorn; <span class="ent">➑</span>&#13;
    REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex14"/><em>Listing 11-14: The <span class="literal">std::shared_ptr</span> supports copy.</em></p>&#13;
<p class="indent">After constructing the shared pointer <span class="literal">aragorn</span>, you have three tests. The first test illustrates that the copy constructor that you use to build <span class="literal">son_</span><span class="literal">of_arathorn</span> <span class="ent">➊</span> shares ownership over the same <span class="literal">DeadMenOfDunharrow</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">In the second test, you construct an empty shared pointer <span class="literal">son_of _ara</span><span class="literal">thorn</span> <span class="ent">➌</span> and then show that copy assignment <span class="ent">➍</span> also doesn’t change the number of <span class="literal">DeadMenOfDunharrow</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">The third test illustrates that when you construct the full shared pointer <span class="literal">son_of_arathorn</span> <span class="ent">➏</span>, the number of <span class="literal">DeadMenOfDunharrow</span> increases to 2 <span class="ent">➐</span>. When you copy assign <span class="literal">aragorn</span> to <span class="literal">son_of_arathorn</span> <span class="ent">➑</span>, the <span class="literal">son_of_arathorn</span> deletes its <span class="literal">DeadMenOfDunharrow</span> because it has sole ownership. It then increments the reference count of the <span class="literal">DeadMenOfDunharrow</span> owned by <span class="literal">aragorn</span>. Because both shared pointers own the same <span class="literal">DeadMenOfDunharrow</span>, the <span class="literal">oaths_to_fulfill</span> decrements from 2 to 1 <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec23"><strong><em>Shared Arrays</em></strong></h4>&#13;
<p class="noindent">A <span class="literal">shared array</span> is a shared pointer that owns a dynamic array and supports <span class="literal">operator[]</span>. It works just like a unique array except it has non-exclusive ownership.</p>&#13;
<h4 class="h4" id="ch11lev2sec24"><span epub:type="pagebreak" id="page_359"/><strong><em>Deleters</em></strong></h4>&#13;
<p class="indent">Deleters work the same way for shared pointers as they do for unique pointers except you don’t need to provide a template parameter with the deleter’s type. Simply pass the deleter as the second constructor argument. For example, to convert <a href="ch11.xhtml#ch11ex12">Listing 11-12</a> to use a shared pointer, you simply drop in the following type alias:</p>&#13;
<pre>using FileGuard = std::shared_ptr&lt;FILE&gt;;</pre>&#13;
<p class="indent">Now, you’re managing <span class="literal">FILE*</span> file handles with shared ownership.</p>&#13;
<h4 class="h4" id="ch11lev2sec25"><strong><em>A Partial List of Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab04">Table 11-4</a> provides a mostly complete listing of the supported constructors of <span class="literal">shared_ptr</span>. In this table, <span class="literal">ptr</span> is a raw pointer, <span class="literal">sh_ptr</span> is a shared pointer, <span class="literal">u_ptr</span> is a unique pointer, <span class="literal">del</span> is a deleter, and <span class="literal">alc</span> is an allocator.</p>&#13;
<p class="tabcap"><a id="ch11tab04"/><strong>Table 11-4:</strong> All of the Supported <span class="literal">std::shared_ptr</span> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{ }</span> or <span class="literal">shared_ptr&lt;...&gt;{ nullptr }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty shared pointer with a <span class="literal">std::default_delete&lt;T&gt;</span> and a <span class="literal">std::allocator&lt;T&gt;</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{</span> <span class="codestrong">ptr</span><span class="codestrong">,</span> <span class="codestrong">[del]</span><span class="codestrong">,</span> <span class="codestrong">[alc]</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by <span class="codestrong">ptr</span>. Uses a <span class="literal">std::default_delete&lt;T&gt;</span> and a <span class="literal">std::allocator&lt;T&gt;</span> by default; otherwise, <span class="codestrong">del</span> as deleter, <span class="codestrong">alc</span> as allocator if supplied.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{</span> <span class="codestrong">sh_ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the shared pointer <span class="codestrong">sh_ptr</span>. Copies ownership from <span class="codestrong">sh_ptr</span> to the newly created shared pointer. Also copies the deleter and allocator of <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{</span> <span class="codestrong">sh_ptr</span> <span class="codestrong">,</span> <span class="codestrong">ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An <em>aliasing constructor</em>: the resulting shared pointer holds an unmanaged reference to <span class="codestrong">ptr</span> but participates in <span class="codestrong">sh_ptr</span> reference counting.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{ move(</span><span class="codestrong">sh_ptr</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the shared pointer <span class="codestrong">sh_ptr</span>. Transfers ownership from <span class="codestrong">sh_ptr</span> to the newly created shared pointer. Also moves the deleter of <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">shared_ptr&lt;...&gt;{ move(</span><span class="codestrong">u_ptr</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Creates a shared pointer owning the dynamic object pointed to by the unique pointer <span class="codestrong">u_ptr</span>. Transfers ownership from <span class="codestrong">u_ptr</span> to the newly created shared pointer. Also moves the deleter of <span class="codestrong">u_ptr</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch11.xhtml#ch11tab05">Table 11-5</a> provides a listing of most of the supported operations of <span class="literal">std::shared_ptr</span>. In this table, <span class="literal">ptr</span> is a raw pointer, <span class="literal">sh_ptr</span> is a shared pointer, <span class="literal">u_ptr</span> is a unique pointer, <span class="literal">del</span> is a deleter, and <span class="literal">alc</span> is an allocator.</p>&#13;
<p class="tabcap"><a id="ch11tab05"/><span epub:type="pagebreak" id="page_360"/><strong>Table 11-5:</strong> Most of the Supported <span class="literal">std::shared_ptr</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">~shared_ptr&lt;...&gt;()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Calls deleter on the owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">=</span> <span class="codestrong">sh_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copies ownership of owned object and deleter from <span class="codestrong">sh_ptr2</span> to <span class="codestrong">sh_ptr1</span>. Increments number of owners by 1. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span> <span class="literal">= move(</span><span class="codestrong">u_ptr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">u_ptr</span> to <span class="codestrong">sh_ptr</span>. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">= move(</span><span class="codestrong">sh_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Transfers ownership of owned object and deleter from <span class="codestrong">sh_ptr2</span> to <span class="codestrong">sh_ptr1</span>. Destroys currently owned object if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr1</span><span class="literal">.swap(</span><span class="codestrong">sh_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Exchanges owned objects and deleters between <span class="codestrong">sh_ptr1</span> and <span class="codestrong">sh_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">swap(</span><span class="codestrong">sh_ptr1</span><span class="literal">,</span> <span class="codestrong">sh_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A free function identical to the <span class="literal">swap</span> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">.reset()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">If full, calls deleter on object owned by <span class="codestrong">sh_ptr</span> if no other owners exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">.reset(</span><span class="codestrong">ptr</span><span class="literal">,</span> <span class="codestrong">[del]</span><span class="literal">,</span> <span class="codestrong">[alc]</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Deletes currently owned object if no other owners exist; then takes ownership of <span class="codestrong">ptr</span>. Can optionally provide deleter <span class="codestrong">del</span> and allocator <span class="codestrong">alc</span>. These default to <span class="literal">std::default_delete&lt;T&gt;</span> and <span class="literal">std::allocator&lt;T&gt;</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">ptr</span> <span class="literal">=</span> <span class="codestrong">sh_ptr</span><span class="literal">.get()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the raw pointer <span class="codestrong">ptr</span>; <span class="codestrong">sh_ptr</span> retains ownership.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">*</span><span class="codestrong">sh_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">-&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Member dereference operator on owned object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">.use_count()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">References the total number of shared pointers owning the owned object; zero if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">[</span><span class="codestrong">index</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the element at <span class="codestrong">index</span> (arrays only).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">bool{</span> <span class="codestrong">sh_ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">bool</span> conversion: <span class="literal">true</span> if full, <span class="literal">false</span> if empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">==</span> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">!=</span> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">&gt;</span> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">&gt;=</span> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">&lt;</span> <span class="codestrong">sh_ptr2</span></p>&#13;
<p class="taba"><span class="codestrong">sh_ptr1</span> <span class="literal">&lt;=</span> <span class="codestrong">sh_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Comparison operators; equivalent to evaluating comparison operators on raw pointers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">.get_deleter()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a reference to the deleter.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec6"><strong>Weak Pointers</strong></h3>&#13;
<p class="indent">A <em>weak pointer</em> is a special kind of smart pointer that has no ownership over the object to which it refers. Weak pointers allow you to track an object and to convert the weak pointer into a shared pointer <em>only if the tracked object still <span epub:type="pagebreak" id="page_361"/>exists</em>. This allows you to generate temporary ownership over an object. Like shared pointers, weak pointers are movable and copyable.</p>&#13;
<p class="indent">A common usage for weak pointers is <em>caches</em>. In software engineering, a cache is a data structure that stores data temporarily so it can be retrieved faster. A cache could keep weak pointers to objects so they destruct once all other owners release them. Periodically, the cache can scan its stored weak pointers and trim those with no other owners.</p>&#13;
<p class="indent">The stdlib has a <span class="literal">std::weak_ptr</span>, and Boost has a <span class="literal">boost::weak_ptr</span>. These are essentially identical and are only meant to be used with their respective shared pointers, <span class="literal">std::shared_ptr</span> and <span class="literal">boost::shared_ptr</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec26"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">Weak pointer constructors are completely different from scoped, unique, and shared pointers because weak pointers don’t directly own dynamic objects. The default constructor constructs an empty weak pointer. To construct a weak pointer that tracks a dynamic object, you must construct it using either a shared pointer or another weak pointer.</p>&#13;
<p class="indent">For example, the following passes a shared pointer into the weak pointer’s&#13;
constructor:</p>&#13;
<pre>auto sp = std::make_shared&lt;int&gt;(808);&#13;
std::weak_ptr&lt;int&gt; wp{ sp };</pre>&#13;
<p class="indent">Now the weak pointer <span class="literal">wp</span> will track the object owned by the shared pointer <span class="literal">sp</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec27"><strong><em>Obtaining Temporary Ownership</em></strong></h4>&#13;
<p class="noindent">Weak pointers invoke their <span class="literal">lock</span> method to get temporary ownership of their tracked object. The lock method always creates a shared pointer. If the tracked object is alive, the returned shared pointer owns the tracked object. If the tracked object is no longer alive, the returned shared pointer is empty. Consider the example in <a href="ch11.xhtml#ch11ex15">Listing 11-15</a>.</p>&#13;
<pre>TEST_CASE("WeakPtr lock() yields") {&#13;
  auto message = "The way is shut.";&#13;
  SECTION("a shared pointer when tracked object is alive") {&#13;
    auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(message); <span class="ent">➊</span>&#13;
    std::weak_ptr&lt;DeadMenOfDunharrow&gt; legolas{ aragorn }; <span class="ent">➋</span>&#13;
    auto sh_ptr = legolas.lock(); <span class="ent">➌</span>&#13;
    REQUIRE(sh_ptr-&gt;message == message); <span class="ent">➍</span>&#13;
    REQUIRE(sh_ptr.use_count() == 2); <span class="ent">➎</span>&#13;
  }&#13;
  SECTION("empty when shared pointer empty") {&#13;
    std::weak_ptr&lt;DeadMenOfDunharrow&gt; legolas;&#13;
    {&#13;
      auto aragorn = std::make_shared&lt;DeadMenOfDunharrow&gt;(message); <span class="ent">➏</span>&#13;
      legolas = aragorn; <span class="ent">➐</span>&#13;
    }&#13;
<span epub:type="pagebreak" id="page_362"/>    auto sh_ptr = legolas.lock(); <span class="ent">➑</span>&#13;
    REQUIRE(nullptr == sh_ptr); <span class="ent">➒</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex15"/><em>Listing 11-15: The <span class="literal">std::weak_ptr</span> exposes a <span class="literal">lock</span> method for obtaining temporary ownership.</em></p>&#13;
<p class="indent">In the first test, you create the shared pointer <span class="literal">aragorn</span> <span class="ent">➊</span> with a message. Next, you construct a weak pointer <span class="literal">legolas</span> using <span class="literal">aragorn</span> <span class="ent">➋</span>. This sets up <span class="literal">legolas</span> to track the dynamic object owned by <span class="literal">aragorn</span>. When you call <span class="literal">lock</span> on the weak pointer <span class="ent">➌</span>, <span class="literal">aragorn</span> is still alive, so you obtain the shared pointer <span class="literal">sh_ptr</span>, which also owns the same <span class="literal">DeadMenOfDunharrow</span>. You confirm this by asserting that the <span class="literal">message</span> is the same <span class="ent">➍</span> and that the <em>use count</em> is 2 <span class="ent">➎</span>.</p>&#13;
<p class="indent">In the second test, you also create an <span class="literal">aragorn</span> shared pointer <span class="ent">➏</span>, but this time you use the assignment operator <span class="ent">➐</span>, so the previously empty weak pointer <span class="literal">legolas</span> now tracks the dynamic object owned by <span class="literal">aragorn</span>. Next, <span class="literal">ara</span><span class="literal">gorn</span> falls out of block scope and dies. This leaves <span class="literal">legolas</span> tracking a dead object. When you call <span class="literal">lock</span> at this point <span class="ent">➑</span>, you obtain an empty shared pointer <span class="ent">➒</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec28"><strong><em>Advanced Patterns</em></strong></h4>&#13;
<p class="noindent">In some advanced usages of shared pointers, you might want to create a class that allows instances to create shared pointers referring to themselves. The <span class="literal">std::enable_shared_from_this</span> class template implements this behavior. All that’s required from a user perspective is to inherit from <span class="literal">enable_shared _</span><span class="literal">from_this</span> in the class definition. This exposes the <span class="literal">shared_from_this</span> and <span class="literal">weak_from_this</span> methods, which produce either a <span class="literal">shared_ptr</span> or a <span class="literal">weak_ptr</span> referring to the current object. This is a niche case, but if you want to see more details, refer to [util.smartptr.enab].</p>&#13;
<h4 class="h4" id="ch11lev2sec29"><strong><em>Supported Operations</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11tab06">Table 11-6</a> lists most of the supported weak pointer operations. In this table, <span class="literal">w_ptr</span> is a weak pointer, and <span class="literal">sh_ptr</span> is a shared pointer.</p>&#13;
<p class="tabcap"><a id="ch11tab06"/><strong>Table 11-6:</strong> Most of the Supported <span class="literal">std::shared_ptr</span> Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">weak_ptr&lt;...&gt;{ }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates an empty weak pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">weak_ptr&lt;...&gt;{</span> <span class="codestrong">w_ptr</span> <span class="literal">}</span> or <span class="literal">weak_ptr&lt;...&gt;{</span> <span class="codestrong">sh_ptr</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Tracks the object referred to by weak pointer <span class="codestrong">w_ptr</span> or shared pointer <span class="codestrong">sh_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">weak_ptr&lt;...&gt;{ move(</span><span class="codestrong">w_ptr</span><span class="literal">) }</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Tracks the object referred to by <span class="codestrong">w_ptr</span>; then empties <span class="codestrong">w_ptr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">~weak_ptr&lt;...&gt;()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Has no effect on the tracked object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">w_ptr1</span> <span class="literal">=</span> <span class="codestrong">sh_ptr</span> or <span class="codestrong">w_ptr1</span> <span class="literal">=</span> <span class="codestrong">w_ptr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces currently tracked object with the object owned by <span class="codestrong">sh_ptr</span> or tracked by <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr1</span> <span class="literal">= move(</span><span class="codestrong">w_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces currently tracked object with object tracked by <span class="codestrong">w_ptr2</span>. Empties <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_363"/><span class="codestrong">sh_ptr</span> <span class="literal">=</span> <span class="codestrong">w_ptr.</span><span class="literal">lock()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Creates the shared pointer <span class="codestrong">sh_ptr</span> owning the object tracked by <span class="codestrong">w_ptr</span>. If the tracked object has expired, <span class="codestrong">sh_ptr</span> is empty.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr1</span><span class="literal">.swap(</span><span class="codestrong">w_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exchanges tracked objects between <span class="codestrong">w_ptr1</span> and <span class="codestrong">w_ptr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">swap(</span><span class="codestrong">w_ptr1</span><span class="literal">,</span> <span class="codestrong">w_ptr2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A free function identical to the <span class="literal">swap</span> method.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr</span><span class="literal">.reset()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Empties the weak pointer.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">w_ptr</span><span class="literal">.use_count()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the number of shared pointers owning the tracked object.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">w_ptr</span><span class="literal">.expired()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns <span class="literal">true</span> if the tracked object has expired, <span class="literal">false</span> if it hasn’t.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">sh_ptr</span><span class="literal">.use_count()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the total number of shared pointers owning the owned object; zero if empty.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec7"><strong>Intrusive Pointers</strong></h3>&#13;
<p class="indent">An <em>intrusive pointer</em> is a shared pointer to an object with an embedded reference count. Because shared pointers usually keep reference counts, they’re not suitable for owning such objects. Boost provides an implementation called <span class="literal">boost::intrusive_ptr</span> in the <span class="literal">&lt;boost/smart_ptr/intrusive_ptr.hpp&gt;</span> header.</p>&#13;
<p class="indent">It’s rare that a situation calls for an intrusive pointer. But sometimes you’ll use an operating system or a framework that contains embedded references. For example, in Windows COM programming an intrusive pointer can be very useful: COM objects that inherit from the <span class="literal">IUnknown</span> interface have an <span class="literal">AddRef</span> and a <span class="literal">Release</span> method, which increment and decrement an embedded reference count (respectively).</p>&#13;
<p class="indent">Each time an <span class="literal">intrusive_ptr</span> is created, it calls the function <span class="literal">intrusive_ptr_add_ref</span>. When an <span class="literal">intrusive_ptr</span> is destroyed, it calls the <span class="literal">intrusive_ptr_release</span> free function. You’re responsible for freeing appropriate resources in <span class="literal">intrusive_ptr_release</span> when the reference count falls to zero. To use <span class="literal">intrusive_ptr</span>, you must provide a suitable implementation of these functions.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex16">Listing 11-16</a> demonstrates intrusive pointers using the <span class="literal">DeadMenOfDunharrow</span> class. Consider the implementations of <span class="literal">intrusive_ptr_add_ref</span> and <span class="literal">intrusive_ptr_release</span> in this listing.</p>&#13;
<pre>#include &lt;boost/smart_ptr/intrusive_ptr.hpp&gt;&#13;
&#13;
using IntrusivePtr = boost::intrusive_ptr&lt;DeadMenOfDunharrow&gt;; <span class="ent">➊</span>&#13;
size_t ref_count{}; <span class="ent">➋</span>&#13;
&#13;
void intrusive_ptr_add_ref(DeadMenOfDunharrow* d) {&#13;
  ref_count++; <span class="ent">➌</span>&#13;
}&#13;
&#13;
void intrusive_ptr_release(DeadMenOfDunharrow* d) {&#13;
<span epub:type="pagebreak" id="page_364"/>  ref_count--; <span class="ent">➍</span>&#13;
  if (ref_count == 0) delete d; <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex16"/><em>Listing 11-16: Implementations of <span class="literal">intrusive_ptr_add_ref</span> and <span class="literal">intrusive_ptr_release</span></em></p>&#13;
<p class="indent">Using the type alias <span class="literal">IntrusivePtr</span> saves some typing <span class="ent">➊</span>. Next, you declare a <span class="literal">ref_count</span> with static storage duration <span class="ent">➋</span>. This variable keeps track of the number of living intrusive pointers. In <span class="literal">intrusive_ptr_add_ref</span>, you increment <span class="literal">ref_count</span> <span class="ent">➌</span>. In <span class="literal">intrusive_ptr_release</span>, you decrement <span class="literal">ref_count</span> <span class="ent">➍</span>. When <span class="literal">ref _count</span> drops to zero, you delete the <span class="literal">DeadMenOfDunharrow</span> argument <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It’s absolutely critical that you use only a single <span class="literal">DeadMenOfDunharrow</span> dynamic object with intrusive pointers when using the setup in <a href="ch11.xhtml#ch11ex16">Listing 11-16</a>. The <span class="literal">ref_count</span> approach will correctly track only a single object. If you have multiple dynamic objects owned by different intrusive pointers, the <span class="literal">ref_count</span> will become invalid, and you’ll get incorrect <span class="literal">delete</span> behavior <span class="ent">➎</span>.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex17">Listing 11-17</a> shows how to use the setup in <a href="ch11.xhtml#ch11ex16">Listing 11-16</a> with intrusive pointers.</p>&#13;
<pre>TEST_CASE("IntrusivePtr uses an embedded reference counter.") {&#13;
  REQUIRE(ref_count == 0); <span class="ent">➊</span>&#13;
  IntrusivePtr aragorn{ new DeadMenOfDunharrow{} }; <span class="ent">➋</span>&#13;
  REQUIRE(ref_count == 1); <span class="ent">➌</span>&#13;
  {&#13;
    IntrusivePtr legolas{ aragorn }; <span class="ent">➍</span>&#13;
    REQUIRE(ref_count == 2); <span class="ent">➎</span>&#13;
  }&#13;
  REQUIRE(DeadMenOfDunharrow::oaths_to_fulfill == 1); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex17"/><em>Listing 11-17: Using a <span class="literal">boost::intrusive_ptr</span></em></p>&#13;
<p class="indent">This test begins by checking that <span class="literal">ref_count</span> is zero <span class="ent">➊</span>. Next, you construct an intrusive pointer by passing a dynamically allocated <span class="literal">DeadMenOfDunharrow</span> <span class="ent">➋</span>. This increases <span class="literal">ref_count</span> to 1, because creating an intrusive pointer invokes <span class="literal">intrusive_ptr_add_ref</span> <span class="ent">➌</span>. Within a block scope, you construct another intrusive pointer <span class="literal">legolas</span> that shares ownership&#13;
with <span class="literal">aragorn</span> <span class="ent">➍</span>. This increases the <span class="literal">ref_count</span> to 2 <span class="ent">➎</span>, because creating an intrusive pointer invokes <span class="literal">intrusive_ptr_add_ref</span>. When <span class="literal">legolas</span> falls out of block scope, it destructs, causing <span class="literal">intrusive_ptr_release</span> to invoke. This decrements <span class="literal">ref_</span><span class="literal">count</span> to 1 but doesn’t cause the owned object to delete <span class="ent">➏</span>.</p>&#13;
<h3 class="h3" id="ch11lev1sec8"><strong>Summary of Smart Pointer Options</strong></h3>&#13;
<p class="indent"><a href="ch11.xhtml#ch11tab07">Table 11-7</a> summarizes all the smart pointer options available to use in stdlib and Boost.</p>&#13;
<p class="tabcap"><a id="ch11tab07"/><span epub:type="pagebreak" id="page_365"/><strong>Table 11-7:</strong> Smart Pointers in stdlib and Boost</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Type name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>stdlib header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Boost header</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Movable/transferable ownership</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Copyable/non-exclusive ownership</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">scoped_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;boost/smart_ptr/scoped_ptr.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">scoped_array</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;boost/smart_ptr/scoped_array.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">unique_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;memory&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">shared_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;memory&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;boost/smart_ptr/shared_ptr.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">shared_array</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">&lt;boost/smart_ptr/shared_array.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">weak_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;memory&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">&lt;boost/smart_ptr/weak_ptr.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">✓</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">intrusive_ptr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">&lt;boost/smart_ptr/intrusive_ptr.hpp&gt;</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">✓</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">✓</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch11lev1sec9"><strong>Allocators</strong></h3>&#13;
<p class="noindent">Allocators are low-level objects that service requests for memory. The stdlib and Boost libraries enable you to provide allocators to customize how a library allocates dynamic memory.</p>&#13;
<p class="indent">In the majority of cases, the default allocator <span class="literal">std::allocate</span> is totally sufficient. It allocates memory using <span class="literal">operator new(size_t)</span>, which allocates raw memory from the free store, also known as the heap. It deallocates memory using <span class="literal">operator delete(void*)</span>, which deallocates the raw memory from the free store. (Recall from “Overloading Operator <span class="literal">new</span>” on <a href="ch07.xhtml#page_189">page 189</a> that <span class="literal">operator new</span> and <span class="literal">operator delete</span> are defined in the <span class="literal">&lt;new&gt;</span> header.)</p>&#13;
<p class="indent">In some settings, such as gaming, high-frequency trading, scientific analyses, and embedded applications, the memory and computational overhead associated with the default free store operations is unacceptable. In such settings, it’s relatively easy to implement your own allocator. Note that you really shouldn’t implement a custom allocator unless you’ve conducted some performance testing that indicates that the default allocator is a bottleneck. The idea behind a custom allocator is that you know a lot more about your specific program than the designers of the default allocator model, so you can make improvements that will increase allocation performance.</p>&#13;
<p class="indent">At a minimum, you need to provide a template class with the following characteristics for it to work as an allocator:</p>&#13;
<ul>&#13;
<li class="noindent">An appropriate default constructor</li>&#13;
<li class="noindent">A <span class="literal">value_type</span> member corresponding to the template parameter</li>&#13;
<li class="noindent">A template constructor that can copy an allocator’s internal state while dealing with a change in <span class="literal">value_type</span></li>&#13;
<li class="noindent">An <span class="literal">allocate</span> method</li>&#13;
<li class="noindent">A <span class="literal">deallocate</span> method</li>&#13;
<li class="noindent">An <span class="literal">operator==</span> and an <span class="literal">operator!=</span></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>The <span class="literal">MyAllocator</span> class in <a href="ch11.xhtml#ch11ex18">Listing 11-18</a> implements a simple, pedagogical variant of <span class="literal">std::allocate</span> that keeps track of how many allocations and deallocations you’ve made.</p>&#13;
<pre>#include &lt;new&gt;&#13;
&#13;
static size_t n_allocated, n_deallocated;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct MyAllocator {&#13;
  using value_type = T; <span class="ent">➊</span>&#13;
  MyAllocator() noexcept{ } <span class="ent">➋</span>&#13;
  template &lt;typename U&gt;&#13;
  MyAllocator(const MyAllocator&lt;U&gt;&amp;) noexcept { } <span class="ent">➌</span>&#13;
  T* allocate(size_t n) { <span class="ent">➍</span>&#13;
    auto p = operator new(sizeof(T) * n);&#13;
    ++n_allocated;&#13;
    return static_cast&lt;T*&gt;(p);&#13;
  }&#13;
  void deallocate(T* p, size_t n) { <span class="ent">➎</span>&#13;
    operator delete(p);&#13;
    ++n_deallocated;&#13;
  }&#13;
};&#13;
&#13;
template &lt;typename T1, typename T2&gt;&#13;
bool operator==(const MyAllocator&lt;T1&gt;&amp;, const MyAllocator&lt;T2&gt;&amp;) {&#13;
  return true; <span class="ent">➏</span>&#13;
}&#13;
template &lt;typename T1, typename T2&gt;&#13;
bool operator!=(const MyAllocator&lt;T1&gt;&amp;, const MyAllocator&lt;T2&gt;&amp;) {&#13;
  return false; <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex18"/><em>Listing 11-18: A <span class="literal">MyAllocator</span> class modeled after <span class="literal">std::allocate</span></em></p>&#13;
<p class="indent">First, you declare the <span class="literal">value_type</span> type alias for <span class="literal">T</span>, one of the requirements for implementing an allocator <span class="ent">➊</span>. Next is a default constructor <span class="ent">➋</span> and a template constructor <span class="ent">➌</span>. Both of these are empty because the allocator doesn’t have state to pass on.</p>&#13;
<p class="indent">The <span class="literal">allocate</span> method <span class="ent">➍</span> models <span class="literal">std::allocate</span> by allocating the requisite number of bytes, <span class="literal">sizeof(T) * n</span>, using <span class="literal">operator new</span>. Next, it increments the static variable <span class="literal">n_allocated</span> so you can keep track of the number of allocations for testing purposes. The <span class="literal">allocate</span> method then returns a pointer to the newly allocated memory after casting <span class="literal">void*</span> to the relevant pointer type.</p>&#13;
<p class="indent">The <span class="literal">deallocate</span> method <span class="ent">➎</span> also models <span class="literal">std::allocate</span> by calling <span class="literal">operator</span> <span class="literal">delete</span>. As an analogy to <span class="literal">allocate</span>, it increments the <span class="literal">n_deallocated</span> static variable for testing and returns.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_367"/>The final task is to implement an <span class="literal">operator==</span> and an <span class="literal">operator!=</span> taking the new class template. Because the allocator has no state, any instance is the same as any other instance, so <span class="literal">operator==</span> returns <span class="literal">true</span> <span class="ent">➏</span> and <span class="literal">operator!</span><span class="literal">=</span> returns <span class="literal">true</span> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch11.xhtml#ch11ex18">Listing 11-18</a> is a teaching tool and doesn’t actually make allocations any more efficient. It simply wraps the call to <span class="literal">new</span> and <span class="literal">delete</span></em>.</p>&#13;
</div>&#13;
<p class="indent">So far, the only class you know about that uses an allocator is <span class="literal">std::shared _ptr</span>. Consider how <a href="ch11.xhtml#ch11ex19">Listing 11-19</a> uses <span class="literal">MyAllocator</span> with <span class="literal">std::allocate</span> shared.</p>&#13;
<pre>TEST_CASE("Allocator") {&#13;
  auto message = "The way is shut.";&#13;
  MyAllocator&lt;DeadMenOfDunharrow&gt; alloc; <span class="ent">➊</span>&#13;
  {&#13;
    auto aragorn = std::allocate_shared&lt;DeadMenOfDunharrow&gt;(alloc<span class="ent">➋</span>, message<span class="ent">➌</span>);&#13;
    REQUIRE(aragorn-&gt;message == message); <span class="ent">➍</span>&#13;
    REQUIRE(n_allocated == 1); <span class="ent">➎</span>&#13;
    REQUIRE(n_deallocated == 0); <span class="ent">➏</span>&#13;
  }&#13;
  REQUIRE(n_allocated == 1); <span class="ent">➐</span>&#13;
  REQUIRE(n_deallocated == 1); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch11ex19"/><em>Listing 11-19: Using <span class="literal">MyAllocator</span> with <span class="literal">std::shared_ptr</span></em></p>&#13;
<p class="indent">You create a <span class="literal">MyAllocator</span> instance called <span class="literal">alloc</span> <span class="ent">➊</span>. Within a block, you pass <span class="literal">alloc</span> as the first argument to <span class="literal">allocate_shared</span> <span class="ent">➋</span>, which creates the shared pointer <span class="literal">aragorn</span> containing a custom <span class="literal">message</span> <span class="ent">➌</span>. Next, you confirm that <span class="literal">aragorn</span> contains the correct <span class="literal">message</span> <span class="ent">➍</span>, <span class="literal">n_allocated</span> is 1 <span class="ent">➎</span>, and <span class="literal">n_deallocated</span> is 0 <span class="ent">➏</span>.</p>&#13;
<p class="indent">After <span class="literal">aragorn</span> falls out of block scope and destructs, you verify that <span class="literal">n_allocated</span> is still 1 <span class="ent">➐</span> and <span class="literal">n_deallocated</span> is now 1 <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because allocators handle low-level details, you can really get down into the weeds when specifying their behavior. See [allocator.requirements] in the ISO C++ 17 Standard for a thorough treatment.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec10"><strong>Summary</strong></h3>&#13;
<p class="indent">Smart pointers manage dynamic objects via RAII, and you can provide allocators to customize dynamic memory allocation. Depending on which smart pointer you choose, you can encode different ownership patterns onto the dynamic object.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_368"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>11-1.</strong> Reimplement <a href="ch11.xhtml#ch11ex12">Listing 11-13</a> to use a <span class="literal">std::shared_ptr</span> rather than a <span class="literal">std::unique_ptr</span>. Notice that although you’ve relaxed the ownership requirements from exclusive to non-exclusive, you’re still transferring ownership to the <span class="literal">say_hello</span> function.</p>&#13;
<p class="noindent"><strong>11-2.</strong> Remove the <span class="literal">std::move</span> from the call to <span class="literal">say_hello</span>. Then make an additional call to <span class="literal">say_hello</span>. Notice that the ownership of <span class="literal">file_guard</span> is no longer <span class="literal">transferred</span> to <span class="literal">say_hello</span>. This permits multiple calls.</p>&#13;
<p class="noindent"><strong>11-3.</strong> Implement a <span class="literal">Hal</span> class that accepts a <span class="literal">std::shared_ptr&lt;FILE&gt;</span> in its constructor. In Hal’s destructor, write the phrase <span class="literal">Stop, Dave.</span> to the file handle held by your shared pointer. Implement a <span class="literal">write_status</span> function that writes the phrase <span class="literal">I'm completely operational.</span> to the file handle. Here’s a class declaration you can work from:</p>&#13;
<pre>struct Hal {&#13;
  Hal(std::shared_ptr&lt;FILE&gt; file);&#13;
  ~Hal();&#13;
  void write_status();&#13;
  std::shared_ptr&lt;FILE&gt; file;&#13;
};</pre>&#13;
<p class="noindent"><strong>11-4.</strong> Create several <span class="literal">Hal</span> instances and invoke <span class="literal">write_status</span> on them. Notice that you don’t need to keep track of how many <span class="literal">Hal</span> instances are open: file management gets handled via the shared pointer’s shared ownership model.</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>