- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FORENSIC IMAGE ACQUISITION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explains the forensic imaging of storage media, with an emphasis
    on performing forensically sound image acquisition. This means maximizing the
    amount of data extracted from a particular storage medium, minimizing the disturbance
    to the storage device and medium, preserving the collected evidence, and documenting
    the process (including errors).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll read about several tools and approaches here, as well as the strengths
    and weaknesses of each. As a result, you’ll be able to make an informed decision
    about which tool is most appropriate in a particular situation. You’ll learn how
    to use a variety of free or open source forensic imaging tools, such as dd, dcfldd,
    dc3dd, ewfacquire, and ftkimager-cli. In addition, I describe the sfsimage tool
    as a script that uses existing acquisition tools to create a SquashFS forensic
    evidence container.
  prefs: []
  type: TYPE_NORMAL
- en: How do you choose which tool to use when imaging a disk? To some extent, it’s
    a matter of personal preference. You may know one tool better than another or
    trust one particular tool based on past experience (or distrust a tool based on
    past experience). Each tool has its strengths and unique features. Forensic labs
    that use EnCase or FTK extensively might choose ewfacquire or ftkimager-cli for
    compatibility and policy reasons. Dcfldd and dc3dd are based on mature and well-tested
    software, and they were designed to forensically acquire raw images with extensive
    hashing and logging. For disks with many bad blocks, GNU ddrescue might be a good
    choice. For integrated hashing, encryption, and compression during acquisition,
    recent versions of dd_rescue might be an interesting alternative. Ultimately,
    the tool used will depend on the forensic lab’s organizational policy, the type
    of examination, your personal preferences, and other circumstances. No particular
    tool is recommended in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the examples in this chapter make the following assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: • The subject storage device is physically attached to the forensics exam-iner’s
    acquisition workstation.
  prefs: []
  type: TYPE_NORMAL
- en: • The subject storage device has been positively identified.
  prefs: []
  type: TYPE_NORMAL
- en: • The appropriate write-blocking mitigation is in place to prevent modification
    of the subject drive.
  prefs: []
  type: TYPE_NORMAL
- en: • Disk capacity planning has been performed to ensure disk space is not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquire an Image with dd Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting image file from dd-based tools is not a “format” in the same sense
    as other forensic formats, such as EnCase EWF or FTK SMART. Images created by
    dd-based tools don’t have a header, a footer, internal markers, or descriptive
    metadata about a case or incident. They are simply a raw mirror image of a chunk
    of data, in this case, a mirror image of a subject disk or other mass storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Warning:** the dd tools are unforgiving if you make any mistakes and will
    irrevocably overwrite any unprotected disk if instructed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the risk of damaging evidence or an examiner workstation, always
    double-check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • A write blocker is protecting the evidence/subject drive.
  prefs: []
  type: TYPE_NORMAL
- en: • The serial number of the input device (`if=`) matches the serial number on
    the physical subject disk label.
  prefs: []
  type: TYPE_NORMAL
- en: • Confirm the output file (`of=`) is a regular file located on the examiner
    system or a program that can handle the expected input to stdin.
  prefs: []
  type: TYPE_NORMAL
- en: '***Standard Unix dd and GNU dd***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command syntax for dd simply specifies an input file and an output file,
    and it may include other options that modify the command’s behavior. The following
    example shows the use of dd to copy a disk block device to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here `if=` specifies the input file, which in this case is a raw disk device
    attached to the acquisition system. The `of=` parameter is the output file, which
    is a normal file that contains the raw data copied from the disk device. On completion,
    dd reports how many bytes were transferred. You can divide the number of bytes
    transferred by the sector size, and the result should exactly match the number
    of sectors identified when you attached the device.
  prefs: []
  type: TYPE_NORMAL
- en: There can be challenges when using dd to forensically image a disk. If read
    errors occur in the middle of an acquisition, dd will abort with an “Input/output
    error.” Address this issue by adding `conv=noerror`, which will force dd to skip
    over the unreadable block and continue. The problem with skipping over unreadable
    blocks is that the sector offset on the destination file changes for filesystem
    blocks on the rest of the disk, causing the rest of the filesystem on the disk
    to appear corrupted. To illustrate, consider the pages of a book. Suppose [page
    99](ch04.xhtml#page_99) is ripped out. If the table of contents points to a chapter
    starting at [page 200](ch07.xhtml#page_200), it’s still possible to find it. The
    book’s page numbers are intact, even with the missing page. But this is not the
    case when sector 99 is ripped out of a disk image (due to a read error). The rest
    of the sectors are renumbered, and the filesystem’s “table of contents” will point
    to the wrong blocks after sector 99.
  prefs: []
  type: TYPE_NORMAL
- en: The `sync` parameter corrects this by padding the unreadable output block with
    zeros, essentially creating a “fake” sector or block (full of zeros) to represent
    the missing one. The rest of the disk image will then have the correct sector
    numbers (offsets) expected by the filesystem it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous example, but this time with protection from unreadable blocks
    (skipping and padding them with zeros), gives this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Padding the output impacts the forensic acquisition in that the image is modified
    and new data (the zeros) has been added. Cryptographic checksums of the disk will
    not match the original data on the disk (especially if there are new or changing
    unreadable areas of a disk). This problem can be managed by logging hash windows.
    This is discussed in “[Hash Windows](ch06.xhtml#ch06lev2sec08)” on [page 152](ch06.xhtml#page_152).
  prefs: []
  type: TYPE_NORMAL
- en: Another issue with dd is that the transfer block size can be larger than the
    physical media sector size. This is problematic when a read error occurs, because
    the remaining sectors in the larger block are padded with zeros, not just the
    one unreadable sector. This means some normal readable sectors might be excluded
    from the forensic image. A block size larger than the sector size could also cause
    additional padding sectors to be added to the end of a forensic image (if the
    image size is not divisible by the block size). The potential performance gained
    from increasing the block size must be weighed against the risk of losing evidence
    from a large padded block.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional dd has no capability for hashing, logging to a file, or other features
    you would expect of a forensic acquisition tool. Because the raw image contains
    no metadata about the original subject disk, you must separately document any
    information that describes the disk (or partially embed some information in the
    filename).
  prefs: []
  type: TYPE_NORMAL
- en: '***The dcfldd and dc3dd Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two popular dd derivatives, dcfldd and dc3dd, were independently developed specifically
    for use in a forensic context.
  prefs: []
  type: TYPE_NORMAL
- en: Because dcfldd and dc3dd originate from GNU dd, they use a similar command syntax.
    Neither tool has built-in support for writing to forensic formats (FTK, EnCase,
    AFF), compression, or image encryption. But you can achieve these functions through
    the use of command piping, which I’ll demonstrate in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses dcfldd to image a disk, ensuring blocks containing
    unreadable sectors are padded and don’t cause an abort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Errors are written to a separate error log file. The dcfldd tool does not use
    `conv=noerror,sync` by default; you must add it manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar imaging command for dc3dd is shown in the next example. By default,
    dc3dd does a good job of managing errors during acquisition. No `conv=noerror,sync`
    flag is needed because it’s built in. The output is well documented, both to `stdout`
    and to the log file. Here is a simple example acquisition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also configure the sfsimage script to use either dcfldd or dc3dd for
    imaging into a SquashFS forensic container. In the following example, a 4K native
    (4096-byte native sector size) drive is imaged using sfsimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example also illustrates that the physical and logical sector size of a
    drive does not impact the acquisition when using dd-style imaging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Both dcfldd and dc3dd have additional features for cryptographic hashing, image
    splitting, and piping to external programs. I’ll demonstrate these features in
    various situations throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquire an Image with Forensic Formats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several imaging formats were specifically designed with forensics in mind. Some
    of these, FTK and EnCase for example, are commercial proprietary formats and have
    been reverse engineered to allow development of open source–compatible tools.
    The next two sections describe tools for acquisition using these proprietary formats.
  prefs: []
  type: TYPE_NORMAL
- en: '***The ewfacquire Tool***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An acquisition tool that specializes in Guidance EnCase Expert Witness formats
    is ewfacquire from libewf (*[https://github.com/libyal/libewf/](https://github.com/libyal/libewf/)*).
    This tool accepts informational parameters on the command line or asks for them
    interactively. You can choose from a number of commercial formats, including the
    various EnCase formats as well as FTK. The ewfacquire tool creates acquisition
    files that enable interoperability with EnCase, FTK, and Sleuth Kit. The tool
    can also convert raw images into other formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows ewfacquire acquiring an attached disk device (a MacBook
    Air connected to the examiner workstation in Target Disk Mode with a Thunderbolt-to-FireWire
    adapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The ewfacquire acquisition completed successfully in 37 minutes, and the 120GB
    file was split into 54 compressed **.E0* files totaling 79GB.
  prefs: []
  type: TYPE_NORMAL
- en: '***AccessData ftkimager***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AccessData provides free, precompiled, command line versions of the FTK Imager.
    The tool is called ftkimager and binaries (no source code) are available for Debian
    Linux, Fedora Linux, OS X, and Windows, which you can download from the AccessData
    website at *[http://accessdata.com/product-download/digital-forensics/](http://accessdata.com/product-download/digital-forensics/)*.
  prefs: []
  type: TYPE_NORMAL
- en: The ftkimager tool can take input from a raw device, a file, or stdin. It outputs
    to an FTK SMART format, an EnCase EWF format, or stdout. The stdin and stdout
    streams are especially useful for piping to and from other programs. A number
    of other features are supported, including the addition of case metadata into
    the saved formats, compression, output file splitting (“image fragments”), hashing,
    and encrypted images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following basic example shows the use of ftkimager to acquire an attached
    disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the source device was a SanDisk thumb drive accessible via
    */dev/sdf*, and the destination filename was *sandisk*. Because the default format
    is raw, adding the `--s01` flag saves it to FTK’s SMART format. A serial number
    and model string was added to the metadata using the `--description` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ftkimager creates a log file with basic metadata and any additional information
    that was added using flags on the command line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can extract this same information using the `--print-info` flag together
    with the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '***SquashFS Forensic Evidence Container***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sfsimage tool is simply a shell wrapper script that you can configure to
    use any imaging tool that supports writing an image cleanly to stdout. The script
    takes this stream of imaged bytes and places them inside a SquashFS compressed
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, sfsimage was configured to use dc3dd as the imaging tool by
    editing the `DD` variable in the beginning of the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the block device is imaged using the `-i` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the size of the compressed **.sfs* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can list the contents of the SquashFS container file using `sfsimage -l`
    or mount it (read-only) using `sfsimage -m`. During the acquisition process, sfsimage
    saves the error log, hash log, and its own log together with the raw image file.
    You can add additional files to the sfsimage container using `sfsimage -a`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Acquire an Image to Multiple Destinations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The flexibility of the Unix piping mechanism allows the completion of multiple
    complex tasks in a single unattended step. Both dc3dd and dcfldd can specify multiple
    destination filenames, allowing you to make simultaneous image copies. The following
    example shows imaging a disk and simultaneously writing to multiple destination
    drives: a local copy on the acquisition host and a second copy on a mounted, external
    third-party drive. These two output files are specified using multiple `of=` flags
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This technique is useful if you’re creating one image for analysis and another
    for backup, when you’re creating an additional image for a third party, or for
    any other situation where multiple copies of the image are needed. The two images
    should be identical, and you can verify them by comparing cryptographic checksums.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preserve Digital Evidence with Cryptography**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preserving the integrity of evidence is fundamental to the digital forensics
    process. Integrity can be maintained by using cryptographic hashes and further
    enhanced with cryptographic signatures by the technicians who performed the acquisition.
    The purpose of hashing or signing images is to verify that the image has not changed
    since it was acquired. Because court proceedings and the presentation of evidence
    can take months or even years, it’s useful to confirm that evidence has not been
    modified during that time. This can be viewed as somewhat of a digital chain of
    custody.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections demonstrate the use of hash windows, signing with PGP
    and S/MIME, and RFC-3161 timestamping to preserve digital evidence. Let’s begin
    with some examples of basic cryptographic hashing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Cryptographic Hashing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The cryptographic hashing of forensic images is typically included as part of
    the imaging process. The entire media image (each sector in sequence) is passed
    through a one-way hash function. As of this writing, the four primary forensic
    imaging tools discussed in this book support the cryptographic hashing algorithms
    shown in [Table 6-1](ch06.xhtml#ch6table1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Supported Cryptographic Hashing Algorithms'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Hashing algorithms supported** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| dcfldd | MD5, SHA1, SHA256, SHA384, SHA512 |'
  prefs: []
  type: TYPE_TB
- en: '| dc3dd | MD5, SHA1, SHA256, SHA512 |'
  prefs: []
  type: TYPE_TB
- en: '| ewfacquire | MD5, SHA1, SHA256 |'
  prefs: []
  type: TYPE_TB
- en: '| ftkimager | MD5, SHA1 |'
  prefs: []
  type: TYPE_TB
- en: The tools using forensic formats usually produce a hash by default. Both ftkimager
    and ewfacquire automatically generate hashes during the acquisition process, which
    you saw in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a hash (or multiple hashes) with dcfldd, you specify the desired
    hash algorithms on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With dc3dd, you specify hash algorithms using `hash=` multiple times, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The traditional `dd` command doesn’t support hashing. Instead, you must pipe
    the image into a separate program during the acquisition process, which you can
    do by using the Unix `tee` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When `dd` has no `of=` specified, the data is sent to stdout where it can be
    redirected or piped into another program. In this example, it’s piped into the
    Unix `tee` command, which simultaneously saves the data to a file and sends it
    to stdout. Then it’spiped into an independent hashing tool, md5sum, where it produces
    the hash. In addition to md5sum, the Linux coreutils software package includes
    other hashing programs: sha1sum, sha224sum, sha256sum, sha384sum, and sha512sum.'
  prefs: []
  type: TYPE_NORMAL
- en: I explain the process of verifying the hashes produced in “[Verify the Integrity
    of a Forensic Image](ch07.xhtml#ch07lev1sec03)” on [page 197](ch07.xhtml#page_197).
  prefs: []
  type: TYPE_NORMAL
- en: '***Hash Windows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you image an older or damaged disk, block read errors can occur. These
    errors can happen in random places during the acquisition, and the frequency can
    increase over time. This creates a challenge when you’re preserving the integrity
    of evidence, because the cryptographic hash might be different each time the disk
    is read (reacquired, duplicated, verified, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use hash windows, or piecewise hashing. A
    hash window is a separate cryptographic hash taken over a smaller sequence of
    sectors on a disk. For example, a hash window size of 10MB during acquisition
    will generate a separate hash for every 10MB sequence of sectors and generate
    a list of hashes for a disk. If one sector becomes unreadable (or is modified
    for some reason), the hash of that window will be invalid. But all the other hash
    windows on the disk will maintain their integrity. So even if the hash of the
    full disk is invalid, if a hash window matches, the integrity of the data found
    within it will be preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Among the commercial forensic formats, early versions of the Expert Witness
    Format (EWF) only use cyclic redundancy check (CRC) checksums for individual blocks
    of data. More recent versions are not open formats, and the ftkimager has no options
    for creating or viewing hash windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create hash windows with dcfldd, you need to add the `hashwindow=` parameter
    to specify the window size. You can save the list of hash windows to a file during
    acquisition using the `hashlog=` parameter with a filename. The following example
    specifies a hash window size of 1MB, and the hashes for each sector range are
    logged to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Groups of identical disk sectors will have the same hash value. This often occurs
    when large portions of a disk are zeroes or a repeating pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'With dc3dd, hash windows are referred to as *piecewise hashing*, and hashes
    can be created, not by sector range but per split file. In the following example,
    the hashes for the sector ranges in each split file are logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is only one image file (that is, not split), there are no separate
    hash windows, just a single hash for the entire image. In the previous example,
    eight image files were created, and the MD5 hashes of each file match those reported
    during acquisition. This can be easily confirmed with md5sum as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '***Sign an Image with PGP or S/MIME***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The hash value is useful to preserve the integrity of an image over time, but
    anyone can take a cryptographic hash of an image at any time. Consider a disk
    modified by an unauthorized person who creates a new hash for the disk image.
    Unless the original hash was properly secured at the original time of acquisition,
    it’s difficult to prove which hash (the old or the new) is the correct one. Cryptographic
    signing of forensic images binds a person (or that person’s key) to the integrity
    of the image. The forensic examiner, a superior, or an external neutral party
    can sign the image at the time of acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t mean that you need to pass around multiterabyte images for people
    to sign. It’s enough to sign the hash of the drive or the list of hash windows.
    The best option is to sign the entire output log containing the timestamps, bytes
    acquired, and all resulting cryptographic hashes.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way an authorized individual signs paper forms with a pen, they
    can sign digital forms with a digital signature. Unlike pen and paper signatures,
    digital signatures are difficult to fake (unless the private key is stolen). Two
    popular standards for signing digital information are *Pretty Good Privacy (PGP)*
    and *Secure/Multipurpose Internet Mail Extensions (S/MIME)*.
  prefs: []
  type: TYPE_NORMAL
- en: The most common Linux implementation of the OpenPGP standard is GnuPG (GPG).^([1](footnote.xhtml#fn30))
    The three different signing methods include a regular binary signature, a clear
    text signature, and a detached signature. Using a clear text signature is the
    most beneficial, because it shows the text together with the signature and can
    be easily embedded into other documents and reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, S. Holmes has performed a forensic acquisition of
    a disk and signs the log output containing the MD5 hash and other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command created the *hash.log.asc* file, which contains the contents
    of the file together with the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This signed text can be verified at a later date by any third party using a
    copy of Holmes’s GPG public key.
  prefs: []
  type: TYPE_NORMAL
- en: Another encryption standard you can use to sign files is S/MIME. The use of
    S/MIME relies on X.509 certificates from a public key infrastructure (PKI), either
    privately within an organization or from a public certificate authority (CA).
    If an authorized person has a personal certificate (typically, the same one they
    use for signing and encrypting S/MIME email), they can use it to sign files containing
    acquisition details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gpgsm tool is part of GnuPG2 and supports managing X.509 keys, encryption,
    and signatures using the S/MIME standard. Once the necessary keys have been generated
    and certificates have been installed, you can use gpgsm to sign files in a similar
    manner to GPG. The following command produces a signature of a specified file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` flag specifies it should use ASCII armor, a method of encoding binary
    data in a plaintext format, instead of binary (because it’s easier to copy into
    reports or emails). The `-r` flag specifies which recipient key to use for signing.
    In this command example, the email address is used, but the key can also be specified
    by key ID, fingerprint, or matching components of X.509 strings. The `-o` specifies
    the output file for the signature, and `--sign` instructs gpgsm to create a signature
    over the specified *hash.log* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used for signing, gpgsm will create a PEM^([2](footnote.xhtml#fn31)) signature
    file that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once a signature has been created by an authorized party, the hash values and
    details of the original forensic acquisition cannot be changed. Only the person
    who created the signature can make changes and sign it again.^([3](footnote.xhtml#fn32))
    With these signatures, it’s possible to verify the integrity of the acquisition
    details without involving the person who signed it. I describe the signature verification
    process in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: You can purchase personal S/MIME certificates similar to SSL certificates for
    websites. You’ll find an overview of CAs who offer personal S/MIME certificates
    at *[https://www.sslshopper.com/email-certificates-smime-certificates.html](https://www.sslshopper.com/email-certificates-smime-certificates.html)*.
    Using a personal S/MIME certificate, you can also sign the acquisition details
    simply by sending a signed email message containing the contents of the output
    log.
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in this section are simple and use GNU Privacy Guard tools.
    There are other command line tools you can use to perform cryptographic signing.
    The OpenSSL command line tool provides a rich cryptographic toolkit that includes
    the ability to sign files using X.509 certificates and S/MIME. OpenSSL is used
    in the next section to demonstrate cryptographic timestamping.
  prefs: []
  type: TYPE_NORMAL
- en: '***RFC-3161 Timestamping***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Signatures with PGP or S/MIME strongly bind an authorized individual (or multiple
    individuals) to the integrity of a file containing forensic acquisition results.
    In some cases, it’s also useful to strongly bind the forensic acquisition results
    to a specific point in time. You can do this by using an independent timestamping
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timestamping is a formal standard defined in RFC-3161, which describes the
    format of a timestamp request and response. OpenSSL can create and send timestamp
    requests and verify responses. In the following example, an RFC-3161 compliant
    timestamp request for the acquisition log is created, producing a request file
    with a **.tsq* extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This time stamp request contains a hash of the *hash.log* file, not the actual
    file. The file is *not* sent to the timestamping server. This is important from
    an information security perspective. The timestamp service provider is only trusted
    with timestamp information, not the contents of the files being timestamped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated request can then be sent to a timestamping service using the
    `tsget` command included with OpenSSL.^([4](footnote.xhtml#fn33)) The following
    example uses the FreeTSA service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'On some Linux distributions, this script might be missing or broken. You can
    work around it by manually submitting the timestamp request with the `curl` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the timestamping server accepts the request, it returns an RFC-3161 compliant
    timestamp. In this example, the timestamp is saved with the **.tsr* file extension
    to `hash.log.tsr`. You can view the contents of the timestamp using the OpenSSL
    `ts` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A copy of the *hash.log.tsr* file provides proof that the acquisition results
    existed at a specific point intime. An independent third party can also verify
    the validity of the timestamp. I’ll demonstrate the validation of timestamps in
    [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of free and commercial timestamping services are available on the
    internet. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Comodo RFC-3161 Timestamping Service: *[http://timestamp.comodoca.com/?td=sha256](http://timestamp.comodoca.com/?td=sha256)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• FreeTSA: *[http://freetsa.org/index_en.php](http://freetsa.org/index_en.php)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• Polish CERTUM PCC - General Certification Authority: *[http://time.certum.pl/](http://time.certum.pl/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• Safe Creative Timestamping Authority (TSA) server: *[http://tsa.safecreative.org/](http://tsa.safecreative.org/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• StartCom Free RFC-3161 Timestamping Service: *[http://tsa.startssl.com/rfc3161](http://tsa.startssl.com/rfc3161)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• Zeitstempeldienst der DFN-PKI: *[http://www.pki.dfn.de/zeitstempeldienst/](http://www.pki.dfn.de/zeitstempeldienst/)*'
  prefs: []
  type: TYPE_NORMAL
- en: The examples in the last two sections strongly bind an individual and a time
    to the integrity of an image. Cryptographic tokens such as smartcards or hardware
    security modules (HSMs) can be used to secure the private keys and guarantee physical
    possession of the token to sign the image. Cryptographic keys on hard tokens cannot
    be copied or stolen. Some examples of hard tokens that can be used to make cryptographic
    signatures include Nitrokey, Yubikey, and GnuPG OpenPGP smartcards.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage Drive Failure and Errors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, a forensic lab receives a problematic hard disk to analyze. The
    disk might be old, damaged, or failing. It may have interface errors, platter
    read errors, head errors, motor resets, and other errors. In some cases, you can
    still acquire a partial forensic image of the drive. Depending on the disk size,
    the block size, and the number of unreadable sectors, imaging a bad disk could
    take several days.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that errors described here refer to the drive hardware.
    They don’t refer to software errors such as corrupt filesystems, destroyed partition
    tables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This section shows examples of different tools and how they handle error conditions.
    The dmsetup tool is useful for simulating disk errors and testing how forensic
    tools behave under various failing conditions, and was used in several of the
    following examples (the disk device is */dev/mapper/errdisk*). An overview of
    how dc3dd, dcfldd, ewfacquire, and ftkimager manage and report errors is shown
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forensic Tool Error Handling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following example shows the dcfldd tool encountering a disk with two errors.
    The locations (block offsets) of the errors on a disk are reported to stdout and
    logged to the specified file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Several bugs were encountered when testing dcfldd under Debian Linux. The block
    size used for padding remained at 4K, even when a 512-byte block size was specified
    (dd showed the same behavior). On some errors, dcfldd went into an endless loop
    and had to be manually terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dc3dd tool provides a very detailed overview of the errors encountered.
    Errors are sent to stout and saved in the specified log file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The ewfacquire tool offers a default error granularity of 64 sectors, and this
    can be changed to 1 to reduce the number of sectors padded to zero. In this example,
    ewfacquire only detected two read errors (similar to dcfldd; it skipped and padded
    a 4k block without checking the other sectors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The ftkimager reports errors and logs them. The following example uses an actual
    physically defective disk (an original first-generation iPod) because the ftkimager
    didn’t work with simulated errors created with dmsetup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each of the forensic acquisition tools had some error detection, handling, and
    logging capabilities. However, for disks with a significant number of errors or
    hardware damage, using more specialized tools might be more appropriate. The next
    section describes the use of data recovery tools for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Recovery Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several disk block recovery tools are worth mentioning because of their robust
    error handling and aggressive recovery methods. Although these tools were not
    written with forensics in mind, they are useful in situations in which other forensic
    tools have failed.
  prefs: []
  type: TYPE_NORMAL
- en: The ddrescue tool (by Antonio Diaz Diaz) was designed to recover blocks from
    damaged disks. Unlike the dd family of tools, it has a multiphase recovery algorithm,
    and you can run it against a disk multiple times to fill gaps in the image. The
    algorithm includes reading problematic parts of the disk backward to increase
    the number of recovered sectors and performing various retry operations over multiple
    passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A completed ddrescue operation results in statistics that describe the recovery
    success rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The log file that ddrescue produces shows the start and end times and a detailed
    overview of the disk’s problem areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The dd_rescue tool (note the underscore) was developed by Kurt Garloff in the
    late 1990s, and although the name contains *dd*, the command syntax is completely
    different and it doesn’t perform data conversion (same with ddrescue). But it
    does transfer blocks of data similar to dd. Several features make this tool a
    possible option for use in a digital forensic laboratory. The block size is dynamically
    changed when disk errors occur, automatically decreasing to a physical block size.
    After a period without errors, the block size is changed again to improve performance.
    You can also image the disk backwards, from the end of the disk to the beginning.
    This technique is useful if the drive has difficulty reading past a certain point
    on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: The myrescue tool is designed to initially avoid unreadable areas (no retries)
    and focuses on recovering as much of the readable areas as possible. After the
    readable sectors are copied, it works on the failed ranges. The tool documentation
    recommends letting difficult drives rest for a couple of hours between retries.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool called recoverdm also performs data recovery. It is problematicdisksproblematicdisksproblematicdisksunique
    in that it can recover data from a damaged disk at the sector level or at an individual
    file level. The tool has additional features for floppies and optical media.
  prefs: []
  type: TYPE_NORMAL
- en: '***SMART and Kernel Errors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The SMART information on the disk can provide additional indicators about the
    health of the drive and the likelihood of a successful recovery. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When performing forensic acquisition, you should note any error and failure
    messages appearing in dmesg or tool output. In cases where sectors could not be
    read and zeroed padding has been added, this needs to be recorded (depending on
    the forensic acquisition tool used, it will be logged).
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Options for Failed Drives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, I provide a few additional tips and comments to help you acquire
    problematic disks.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a disk might only operate correctly for a few minutes when it’s
    cold before it becomes inaccessible or unstable. If the disk functions properly
    for a few minutes before failing, you might still be able to make an image over
    time by repeatedly restarting the recovery. Some of the tools mentioned in “[Data
    Recovery Tools](ch03.xhtml#ch03lev2sec03)” on [page 162](ch06.xhtml#page_162)
    maintain a file that contains the recovery state from the last attempt. A recovery
    operation can be interrupted and later restarted where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: After attempting to image a drive for a while, let the drive cool down and try
    again. Sometimes as a drive overheats, the access problems can get worse. Again,
    the disk recovery tools’ restart features are useful in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect the drive electronics are faulty and a second identical (meaning
    the same make, model, and firmware revision) functioning drive is available,^([5](footnote.xhtml#fn34))
    you might be able to swap the drive electronics temporarily to recover the data.
    You don’t need to open the disk to perform this action, so the risk of damage
    (due to dust and so on) is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Professional data recovery firms have cleanrooms where trained staff can open
    drives, unstick drive heads, replace actuators, and perform other delicate operations
    on a drive. Do not attempt these procedures without the proper environment, equipment,
    and training. Just opening a drive outside of a cleanroom will expose it to dust
    particles, causing damage to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '***Damaged Optical Discs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the tools mentioned earlier should also function on optical media. Some
    tools have added features or special behavior for optical media.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ddrescue tool suggests specifying a 2048-byte sector size for optical media.
    Here’s an example of ddrescue in the process of recovering a damaged CD-ROM disc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that ddrescue reads the CD-ROM backwards in an attempt to recover blocks.
  prefs: []
  type: TYPE_NORMAL
- en: For optical discs that are partially recoverable but have a corrupt file-system,
    you can use carving tools to extract files. A data carver designed for optical
    discs is the dares carver (*[ftp://ftp.heise.de/pub/ct/ctsi/dares.tgz](ftp://ftp.heise.de/pub/ct/ctsi/dares.tgz)*),
    which supports various optical disc filesystem formats.
  prefs: []
  type: TYPE_NORMAL
- en: This section has covered the management of drive failure and errors. Drive failure
    and errors do happen and can result in partial or total data loss. In cases where
    you experience problems with a drive, be sure you document the nature of the error
    and, wherever possible, the sector that was impacted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image Acquisition over a Network**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imaging a disk over a network can be useful for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: • A disk may be located in a remote location, and it might not be feasible to
    physically seize and ship the disk to a central forensic lab (possibly due to
    disruption of business, lack of resources, or other logistical issues).
  prefs: []
  type: TYPE_NORMAL
- en: • A time-critical incident might require a remote drive image as soon as possible
    without delays due to shipping (depending on network bandwidth, disk size, and
    shipping times, shipping a disk might still be faster).^([6](footnote.xhtml#fn35))
  prefs: []
  type: TYPE_NORMAL
- en: • A machine in a local forensic lab may have a disk in a PC that cannot be feasibly
    physically removed. This could be due to the design of the PC, the lack of tools
    needed, or the risk of causing damage or destroying evidence.
  prefs: []
  type: TYPE_NORMAL
- en: In general, seizing disks does not scale well in large organizations, and having
    a broadly deployed enterprise solution for remote disk triage and acquisition
    is common. EnCase Enterprise is a classic example, with many newer firms bringing
    similar products to the market.
  prefs: []
  type: TYPE_NORMAL
- en: As with disk imaging, many possibilities exist to perform forensic acquisition
    over a network. Most solutions involve booting a forensic CD on a remote machine,
    establishing a network connection, and piping the dd output over the network to
    a local file. You can do this simply by using a combination of dd and netcat.
    Secure connections can also be made using ssh or secure netcat alternatives, such
    as socat and cryptcat.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides several examples that use ssh for a secure network connection.
    But first, let’s start by looking at rdd, which was specifically designed with
    forensic acquisition in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remote Forensic Imaging with rdd***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Designed for acquiring disk images over a network, the rdd tool was developed
    by the Netherlands Forensic Institute (NFI). The rdd tool has a number of useful
    features, including hashing, logging, compression, error handling, file splitting,
    progress indicators, and statistics. Support for EWF output can be included at
    compile time. The rdd tool uses a client-server model, where the subject PC (booted
    from a forensic boot CD) is the client and the examiner PC is the server. You
    perform an acquisition by starting a listening process on the server (examiner
    PC) and running the acquisition command on the client.
  prefs: []
  type: TYPE_NORMAL
- en: The rdd tool does not have built-in security; it must be added using a VPN,
    a secure shell, or the equivalent. When you are using rdd over untrusted or hostile
    networks, the network traffic needs to be encrypted, and listening TCP ports should
    not be exposed. You can do this by using a two-step process of establishing a
    secure network channel and using it for the acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: Without security, the rdd tool is still useful on a trusted network segment
    in a protected lab setting, when using crossed Ethernet cables, or when connecting
    two PCs with a FireWire cable. (FireWire interfaces can be used as network interfaces.)
  prefs: []
  type: TYPE_NORMAL
- en: On the examiner’s workstation, run the server mode of `rdd-copy` by specifying
    `-S`, as shown in the following example. This needs to be started before the client
    starts. Make sure no firewalls or iptables packet filtering is blocking TCP port
    4832 (the default port).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On the remote subject PC, run the client mode of `rdd-copy` using `-C`. Specify
    the input device using `-I`. The input device can be any locally attached storage
    device (it was a remote USB stick in this example). The output file, `-O`, has
    an additional option to indicate a network destination. The client tells the server
    which file to use for the acquired image, using the traditional Unix convention
    of *hostname:/path/to/filename*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Both client and server specify log files using `-l` and a hash algorithm that
    can be verified at the end of the transfer. You can monitor the progress of the
    client and the server by adding `-P 1` to either side (or both).
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Remote Imaging with ssh***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In situations where rdd is not available, you can perform a basic acquisition
    using a single `ssh` command either on the remote PC containing the subject drive
    or on the examiner PC. The following example shows imaging a disk (a USB stick
    plugged into the remote PC in this example) over the network using a secure shell
    session originating from the remote PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `dd` command is run locally, and the output is piped into the `ssh` command.
    Secure shell will pipe this data stream into the cat program on the examiner PC.
    The output from the cat program is redirected into a file residing on the examiner
    PC. Upon completion, a raw image will be available to examine with other forensic
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also acquire the image with secure shell originating from the examiner
    workstation and connecting to the remote PC with the attached subject disk. The
    following example demonstrates this from the examiner PC, imaging the same USB
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here secure shell is instructed to run the `dd` command on the remote (subject)
    machine. The output from the remote `dd` command becomes the output of the local
    `ssh` command and is redirected to a local file. On completion, a raw image file
    is available for analysis on the examiner’sPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can replace the basic `dd` commands shown in this section with dcfldd,
    dc3dd, or any of the other acquisition tools that image to stdout. You can use
    this method to collect other information about a remote (subject) machine. To
    illustrate, here are some examples of collecting data about a remote PC that has
    been started with the DEFT Linux boot CD. In this example, hdparm, smartctl, and
    lshw data are collected and saved on the examiner workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, `ssh` executes various commands on the remote machine,
    and the output is redirected to files on the local (examiner) workstation. The
    serial number of the disk is included in the file-name to ensure an obvious link
    between the physical disk and the data files collected.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remote Acquisition to a SquashFS Evidence Container***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As demonstrated previously, SquashFS can be used as a forensic evidence container,
    with sfsimage used to image local disks. The sfsimage script can also image a
    disk on a remote machine directly into a SquashFS evidence container. Two examples
    are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remote dd output can be piped via ssh into a local `sfsimage` command,
    creating a SquashFS forensic evidence container with the raw image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the remote PC is accessed by the root user (`root@remote-pc`),
    and a remote media card (`/dev/mmcblk0`) is imaged to stdout with a `dd` command.
    The stdout stream is transported over the ssh connection to the local `sfsimage`
    command where `-` (stdin) is the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second method uses the same principle, but with variables for the sfsimage
    shell script. In the sfsimage `config()` block or in a separate *sfsimage.conf*
    file, you can specify variables and configuration settings that control sfsimage
    behavior. Setting the `DD` variable to an `ssh` command will cause mksquashfs
    to take input from a remote machine via ssh. A config file in the current working
    directory is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The double quotes in the `DD` variable need to be escaped. The `SQSUDO` variable
    is set to an empty string, because no local root privileges are needed. When you
    run `sfsimage` with this config file in your local working directory, your configuration
    settings will override the default sfsimage settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note, that the input file should still be specified as a
    dash (`-`), because input is piped to stdin internally by the `ssh` command in
    the `DD` variable. The remote acquisition using sfsimage in this way looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I showed this `DD` configuration example primarily to illustrate the possibility
    of embedding remote network-imaging commands into sfsimage. The embedding of complex
    acquisition commands into config files can generally be used to change the operation
    of the sfsimage script.
  prefs: []
  type: TYPE_NORMAL
- en: '***Acquire a Remote Disk to EnCase or FTK Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also pipe remote `ssh` commands into other programs to perform tasks
    or conversions to other formats. A useful example is to remotely acquire a raw
    image and convert it to Encase/EWF as it’s being written to disk. This example
    shows a remote PC being remotely imaged to an examiner workstation and saved as
    **.ewf* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a description of the PC (eepc) and the serial number (16048539022588504422)
    are embedded into the filename of the image. The final output from the `dd` command
    is shown on completion, directly followed by the ewfacquirestream completion message.
  prefs: []
  type: TYPE_NORMAL
- en: You can use EnCase, Sleuth Kit, or any other tool that supports EWF to forensically
    analyze the resulting acquired image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using additional flags with ewfacquirestream can provide more case metadata
    details, increase the compression, and provide other features. See the ewfacquirestream(1)
    manual page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Live Imaging with Copy-On-Write Snapshots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In general, it doesn’t make sense to create a forensic image of a live system
    when the disks you need to acquire contain the running OS. Blocks are constantly
    changing on a live system. During the time needed to acquire a sector-by-sector
    image, the filesystem will change significantly, causing the imaged filesystem
    copy to be corrupt and inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it may not be feasible to boot a system with a forensic boot CD to
    remotely acquire an image. On live servers that cannot be shut down, the same
    method used to freeze the filesystem for backups might be leveraged in some situations.
    On systems that have Copy-on-Write (CoW) filesystems, you might be able to do
    a certain amount of forensic imaging if filesystem snapshots have associated block
    devices (Logical Volume Manager [LVM] for example). This will provide a consistent
    snapshot of the filesystem blocks at a certain point in time. If a CoW filesystem
    has no associated block device for a snapshot, the files will at least be frozen
    for a file-level acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: If the subject system is a cloud-based virtual machine, imaging the live system
    over a network might be your only option, unless the cloud provider can provide
    snapshot images.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquire Removable Media**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removable media are unique in that the drive device can be attached to a system
    and operate without any media. Block devices that can be forensically acquired
    only become available upon insertion of the media. USB thumb drives can be described
    as removable devices but not removable media. The medium is not removed from the
    USB thumb drive unless it is a memory card adapter or card reader.
  prefs: []
  type: TYPE_NORMAL
- en: This section covers basic removable media types, including memory cards, optical
    discs, and magnetic tapes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Memory Cards***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most memory cards behave similarly to regular drives. Their storage is represented
    as a linear sequence of blocks, giving the appearance of a regular drive with
    sectors that you can access using any tool that operates on block devices.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-1](ch06.xhtml#ch6fig1), a Micro SD card is inserted into an SD
    card adapter, which is inserted into an SD card reader, which is inserted into
    a PC. Here, several items of removable media are stacked and still appear as a
    block device that you can image normally.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f06-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Removable memory card adapters*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, all three items were inserted and attached to the acquisition
    host. The kernel detected them and created a */dev/sdg* block device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The SD adapter has a write-protect tab enabled, which isvisible in the dmesg
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the Micro SD card is imaged into a SquashFS evidence container
    using the sfsimage script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After imaging, a memory card can be safely removed from the card reader (assuming
    it has not been mounted).
  prefs: []
  type: TYPE_NORMAL
- en: '***Optical Discs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The different types of optical media vary in their physical and chemical properties;
    however, once you insert them into an attached optical drive, they have more similarities
    than differences. The three most common discs (DVD, CD-ROM, and Blu-ray) have
    a 2048-byte sector size and appear as a linear sequence of sectors (similar to
    a tape, but inaspiral). The primary difference is the density of the data bits
    (which is abstracted by the device hardware) and the disc capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imaging data discs is straightforward and similar to imaging hard disks or
    flash media. An example of an optical disc being imaged with dc3dd is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using common forensic tools, you can then analyze the *datacd.raw* image file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recovery of Compact Disc Digital Audio (CDDA), or music CDs, is different
    from that of data discs. They contain a set of music tracks that are linear streams
    of pulse-code modulation (PCM) encoded bits. Unlike with data CDs, there is some
    tolerance for errors. For this reason, tools have been created to attempt the
    recovery of CDDA and manage drive issues such as misalignment and frame jitter.^([7](footnote.xhtml#fn36))
    Most CDDA tools are simple music CD *rippers* that convert the CD tracks into
    audio files (reencoded into some other audio format). In this example, cdparanoia
    performs a raw extraction of the PCM data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This command rips the entire music CD into a single raw PCM audio image file
    containing all the audio tracks. You can then import this file into audio analysis
    software. Because the audio data has not been modified or reencoded, there is
    no audio quality loss or degradation.
  prefs: []
  type: TYPE_NORMAL
- en: DVD and Blu-ray discs with digital rights management (DRM) and region protection
    are a challenge to recover. Linux tools and instructions to recover encrypted
    content exist but have been deliberately left outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Magnetic Tapes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tapes have essentially disappeared from home environments. But they are still
    used in small, medium, and enterprise environments for backup and archiving. On
    rare occasions, you might receive a request to recover data from tapes. In corporate
    forensic labs for example, old tapes are sometimes found when company departments
    are reorganizing or moving locations.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, popular tapes used have been 4mm DAT, 8mm Exabyte, and DLT tapes.
    Today, the most common types used are LTO and 8mm DAT. The maximum native/compressed
    capacities of these tapes is 160GB/320GB for DAT-320 and 6TB/15TB for LTO-7\.
    Modern LTO drives also support encrypted tapes.
  prefs: []
  type: TYPE_NORMAL
- en: Modern tape drives are attached to host systems using a SAS or Fibre Channel
    interface. Historically, nearly all tape drives followed the SCSI Stream Command
    (SSC) standards (SSC-5 is the latest).
  prefs: []
  type: TYPE_NORMAL
- en: Tape technologies use their own concept of “files,” which are placed in sequential
    order on a tape. Typically, a tape file consists of a backup archive created by
    backup or archiving software. Tape files are not randomly accessible like disk
    drives and optical discs. Instead, you access them by moving or *spacing* forward
    or backward to the beginning of a file number and then reading logical blocks
    until the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tapes have different markers that tell the tape drive information about the
    position of the head on the tape (see [Figure 6-2](ch06.xhtml#ch6fig2)). The interesting
    markers to understand here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BOT or BOM (Beginning of Tape or Media)** Tells the drive where it can start
    reading or writing data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EOF (End of File)** Tells the drive that the end of a tape file has been
    reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EOD (End of Data)** Tells the drive that the end of the written data has
    been reached (found immediately after the last tape file). This is the logical
    end of the tape.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PEOT, EOT, or EOM ([Physical] End of Tape or Media)** Tells the drive that
    the end of the physical tape length has been reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f06-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Files and markers on a tape*'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re acquiring tapes for forensic purposes, it’s essential to copy every
    file on the tape up to the EOD marker (the last readable file on the tape). It’s
    impossible to read past the EOD on a tape using standard SCSI commands. Some forensic
    firms offer specialized hardware and services which are able to recover data beyond
    the EOD.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extract files from a tape using dd variants. In the example that follows,
    three tape files are recovered from a tape. The nonrewinding device for tape access
    is chosen, typically */dev/nst0* on Linux, to prevent the drive from rewinding
    before all the files have been copied. The command is run repeatedly, always using
    the same input device (it takes the next file on the tape), until it reaches “0+0
    records in,” indicating that all files have been extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After the tape files have been recovered, you can analyze the file type. Often,
    you can just use a basic file type program to determine which archive or backup
    format was used. In this example, two *.tar* files and one *.dump* file were extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Each of the *hash*.log* files contains a separate MD5 hash for each tape file
    extracted. In this example, *file3.tape* is empty and can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**RAID and Multidisk Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The forensic acquisition of Redundant Array of Independent Disks (RAID) systems
    brings a number of challenges and might require additional steps to complete.
    Capacity planning is important, because it may involve imaging a large number
    of disks.
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes the individual disks in a RAID have been imaged separately
    and exist on the acquisition workstation. The goal here is to assemble the imaged
    disks and make the meta device layer accessible as a file or block device, allowing
    you to use forensic analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, RAID systems create their own header information at the beginning
    of a disk (and sometimes at the end of a disk). The header is for unique identifiers
    (UUIDs), array names, timestamps, RAID configuration details, and other housekeeping
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proprietary RAID Acquisition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In situations where a hardware RAID controller was used and no software exists
    to assemble the RAID offline, you may need to clone the RAID disks and boot an
    examination system with the controller physically installed.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section focus on Linux software RAID, but a number of open
    source tools are available that can support acquiring and analyzing proprietary
    RAID systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following packages contain such tools and are available from
    the Debian software repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dpt-i2o-raidutils** Adaptec I2O hardware RAID management utilities'
  prefs: []
  type: TYPE_NORMAL
- en: '**array-info** A command line tool for reporting RAID status for several RAID
    types'
  prefs: []
  type: TYPE_NORMAL
- en: '**cciss-vol-status** HP SmartArray RAID Volume Status Checker'
  prefs: []
  type: TYPE_NORMAL
- en: '**cpqarrayd** A monitoring tool for HP (Compaq) SmartArray controllers'
  prefs: []
  type: TYPE_NORMAL
- en: '**dpt-i2o-raidutils** Adaptec I2O hardware RAID management utilities'
  prefs: []
  type: TYPE_NORMAL
- en: '**mpt-status** A tool to get RAID status out of mpt (and other) HW RAID controllers'
  prefs: []
  type: TYPE_NORMAL
- en: '**varmon** VA RAID monitor'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these software packages, the dmraid tool is able to identify
    RAID metadata for a number of proprietary formats. You can find a list of supported
    formats by using the `-l` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The dmraid tool uses the same device mapper facility shown in “[Manage Drive
    Failure and Errors](ch06.xhtml#ch06lev1sec04)” on [page 159](ch06.xhtml#page_159)
    (where the dmsetup tool was used to simulate errors). The dmraid(8) manual page
    provides a number of examples for reassembling various proprietary RAID configurations.^([8](footnote.xhtml#fn37))
  prefs: []
  type: TYPE_NORMAL
- en: '***JBOD and RAID-0 Striped Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just a Bunch Of Disks (JBOD) is the term used to indicate that a number of disks
    have been concatenated into one logical drive (without any RAID configuration
    for performance or redundancy). To assemble a group of disks into a single JBOD
    device, you can use the `dmsetup` command.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re building devices from multiple disks, it’s useful to have a separate
    table file to define the device, offsets, and mappings. In this simple text file,
    you can also include comments with information about the disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example has a JBOD with three disks of different sizes (a charactaristic
    of JBOD systems is that any combination of drive sizes can be used). The JBOD
    device mapper table file (*jbod-table.txt* in this example) defines how they are
    concatenated. Run the `dmsetup` command with the table file as input to create
    the device in */dev/mapper*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This table defines three mappings that construct the device file, which will
    appear in */dev/mapper*. Each line defines the offset in the mapper device, the
    number of sectors to map, the target type (linear), and the target device with
    an offset (sector zero here, because we want the whole device). Getting the offsets
    right can be tricky and may require some calculation. Double-check the offsets
    first if there are problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table is piped into the `dmsetup create` command, specifying the name of
    the mapper device. After the device is created, you can use regular forensic tools
    to operate on it. The following example shows the Sleuth Kit `fsstat` command
    being used on the newly created device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When you no longer need the mapper device, remove it by using the `dmsetup`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See the dmsetup(8) manual page for more information about the different device
    mapper types the dmsetup tool uses. You can use device mappings for encryption,
    snapshots, RAID systems, and even simulating errors and failing devices (which
    is useful for testing the behavior of forensic tools).
  prefs: []
  type: TYPE_NORMAL
- en: RAID-0 striped disks are created for performance, not redundancy. A group of
    disks in a RAID-0 configuration has the combined capacity of all the drives, and
    disk access is distributed across the array (performance increases as disks are
    added).
  prefs: []
  type: TYPE_NORMAL
- en: If you know the offsets and chunk size of a striped RAID-0 array, the dmsetup
    tool can create a mapper device to represent the assembled array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a RAID-0 consisting of two striped disks is attached
    to the acquisition host. It is known that the subject RAID system has 2048 initial
    sectors containing metadata and that the chunk size is 128 sectors. You can then
    assemble the RAID as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can analyze this */dev/mapper* device using regular filesystem forensic
    tools. An example using Sleuth Kit’s `fls` command on the newly created device
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to remove the device when the tasks are completed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Microsoft Dynamic Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft created the Logical Disk Manager (LDM) to manage logical volumes,
    and you can use the Linux-based tool ldmtool to analyze Microsoft dynamic disks.
    The goal here is to make the volume available for block-level access by forensic
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, two subject disks with a volume created by Microsoft LDM are
    attached to the acquisition host. An LDM disk group is identified by its *Globally
    Unique Identifier (GUID)*. You can scan the disks for the disk group GUID, which
    will lead to more information about the disk group when the ldmtool `show` command
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `show` command provides the disk group name and GUID, the volume names,
    and the names of disks. This is enough information to create a mapper device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the GUID and the volume name, you can create a volume device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a device in */dev/mapper* that corresponds to the filesystem on
    the dynamic disk (this is equivalent to a partition device like */dev/sda1*).
    Then you can use regular forensic analysis tools to operate on this device. An
    example using the Sleuth Kit `fsstat` command is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When you no longer need the device, remove it using the `dmsetup` command, as
    shown in “[JBOD and RAID-0 Striped Disks](ch06.xhtml#ch06lev2sec25)” on [page
    179](ch06.xhtml#page_179).
  prefs: []
  type: TYPE_NORMAL
- en: '***RAID-1 Mirrored Disks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mirrored disks are simple and consist of two identical disks (or should be if
    they were synchronized). Image both disks into separate image files. Depending
    on the mirroring software or hardware, a header might be in the beginning sectors
    of the disk that you need to skip when you’re performing analysis work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows mirrored disks containing an EXT4 partition. The
    mirroring software (Linux Software RAID) used the first 32,768 sectors, and the
    mirrored filesystem starts at that offset on the physical disks and without an
    offset for the multiple device,^([9](footnote.xhtml#fn38)) md0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the same filesystem on md0 is also found at the 32k offset
    of the two physical devices (sde and sdg). The cryptographic checksums of mirrored
    disks will probably not match each other, because the RAID header information
    might be different (unique disk UUIDs and so on) and the disks might not be perfectly
    synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux RAID-5***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If multiple disks are part of a Linux RAID array, you can acquire them individually
    and then assemble them using several methods. The dmsetup tool provides an interface
    to mdadm using tables. The mdadm tool can operate on devices that have been mapped
    or looped. In the following example, three acquired drive images from a Linux
    MD RAID-5 setup are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'An mmls analysis of the individual partition tables reveals a Linux RAID partition
    at sector 2048 of each disk image (*sda.raw*, *sdb.raw*, and *sdc.raw*). This
    sector offset is converted (using Bash math expansion) to a byte offset for the
    `losetup` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A read-only loop device is created for each of the disks in the array using
    the calculated byte offset (2048 sectors, which is 1048576 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands create loop devices corresponding to the three acquired
    image files. You can assemble an array using mdadm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can access and analyze the RAID meta disk device using regular forensic
    tools on the */dev/md0* device. An example using Sleuth Kit’s `fsstat` command
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mount the newly created device and access it using regular file
    tools. The normal Linux `mount` command can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’ve completed the analysis, reverse the steps for the cleanup process,
    including using the `stop` command with the mdadm system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the system configuration, the Linux kernel may automatically attempt
    to reassemble attached RAID devices if they’re detected, possibly starting a rebuild
    operation that could destroy evidence. It’s important to use write blocking with
    live devices and ensure that read-only loop devices and arrays are created.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the techniques described in this chapter apply to loop devices mapping
    to image files. More examples of creating and using loop devices are shown in
    [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I covered the main topic of the book—forensic acquisition.
    You learned how to use the different dd-based tools, create images with forensic
    formats, and use SquashFS as a forensic evidence container. Various aspects of
    evidence preservation using cryptography were shown, including hashing, hash windows,
    signing, and timestamping. You now have a deeper understanding of error management
    and recovery when imaging problematic media. You are able to image over a network
    and image removable media and multi-disk (RAID) systems. This is the core of the
    forensic acquisition process.
  prefs: []
  type: TYPE_NORMAL
