- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: SQL Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*SQL* is a programming language used to query or modify information stored
    within a database. A *SQL injection* is an attack in which the attacker executes
    arbitrary SQL commands on an application’s database by supplying malicious input
    inserted into a SQL statement. This happens when the input used in SQL queries
    is incorrectly filtered or escaped and can lead to authentication bypass, sensitive
    data leaks, tampering of the database, and RCE in some cases.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL*是用于查询或修改存储在数据库中的信息的编程语言。*SQL注入*是一种攻击，攻击者通过在SQL语句中插入恶意输入，执行任意SQL命令以攻击应用程序的数据库。当SQL查询中使用的输入未正确过滤或转义时，就会发生这种情况，这可能导致身份验证绕过、敏感数据泄露、数据库篡改，甚至在某些情况下发生远程代码执行（RCE）。'
- en: 'SQL injections are on the decline, since most web frameworks now have built-in
    mechanisms that protect against them. But they are still common. If you can find
    one, they tend to be critical vulnerabilities that result in high payouts, so
    when you first start hunting for vulnerabilities on a target, looking out for
    them is still worthwhile. In this chapter, we will talk about how to find and
    exploit two types of SQL injections: classic SQL injections and blind SQL injections.
    We will also talk about injections in NoSQL databases, which are databases that
    do not use the SQL query language.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的数量有所下降，因为现在大多数Web框架都有内建机制来防范它们。但它们仍然很常见。如果你能发现SQL注入漏洞，它们往往是至关重要的漏洞，会导致高额回报，因此当你开始进行目标漏洞挖掘时，仍然值得留意这些漏洞。本章将讲解如何发现和利用两种类型的SQL注入：经典SQL注入和盲注SQL注入。我们还将讨论NoSQL数据库中的注入，NoSQL数据库是不使用SQL查询语言的数据库。
- en: Note that the examples used in this chapter are based on MySQL syntax. The code
    for injecting commands into other database types will be slightly different, but
    the overall principles remain the same.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章中使用的示例基于MySQL语法。注入到其他类型数据库的代码会有所不同，但总体原则是相同的。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: To understand SQL injections, let’s start by understanding what SQL is. *Structured
    Query Language (SQL)* is a language used to manage and communicate with databases.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解SQL注入，我们首先需要了解SQL是什么。*结构化查询语言（SQL）*是一种用于管理和与数据库进行通信的语言。
- en: 'Traditionally, a *database* contains tables, rows, columns, and fields. The
    rows and columns contain the data, which gets stored in single fields. Let’s say
    that a web application’s database contains a table called Users ([Table 11-1](#table11-1)).
    This table contains three columns: ID, Username, and Password. It also contains
    three rows of data, each storing the credentials of a different user.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，*数据库*包含表格、行、列和字段。行和列包含数据，数据存储在单一字段中。假设某个Web应用程序的数据库包含一个名为Users的表（[表11-1](#table11-1)）。该表包含三列：ID、用户名和密码。同时，它也包含三行数据，每行存储着不同用户的凭证。
- en: 'Table 11-1: The Example Users Database Table'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1：示例用户数据库表
- en: '| **ID** | **Username** | **Password** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **用户名** | **密码** |'
- en: '| --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `1` | *admin* | `t5dJ12rp$fMDEbSWz` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `1` | *admin* | `t5dJ12rp$fMDEbSWz` |'
- en: '| `2` | *vickie* | `password123` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `2` | *vickie* | `password123` |'
- en: '| `3` | *jennifer* | `letmein!` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `3` | *jennifer* | `letmein!` |'
- en: 'The SQL language helps you efficiently interact with the data stored in databases
    by using queries. For example, SQL `SELECT` statements can be used to retrieve
    data from the database. The following query will return the entire Users table
    from the database:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语言通过使用查询帮助你高效地与存储在数据库中的数据进行交互。例如，SQL的`SELECT`语句可以用来从数据库中检索数据。以下查询将返回数据库中的整个Users表：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This query would return all usernames in the Users table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询将返回Users表中所有的用户名：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, this query would return all users with the username *admin*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个查询将返回所有用户名为*admin*的用户：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are many more ways to construct a SQL query that interacts with a database.
    You can learn more about SQL syntax from W3Schools at [https://www.w3schools.com/sql/default.asp](https://www.w3schools.com/sql/default.asp).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以构造与数据库交互的SQL查询。你可以从W3Schools学习更多关于SQL语法的知识，网址是[https://www.w3schools.com/sql/default.asp](https://www.w3schools.com/sql/default.asp)。
- en: Injecting Code into SQL Queries
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向SQL查询中注入代码
- en: 'A SQL injection attack occurs when an attacker is able to inject code into
    the SQL statements that the target web application uses to access its database,
    thereby executing whatever SQL code the attacker wishes. For example, let’s say
    that a website prompts its users for their username and password, then inserts
    these into a SQL query to log in the user. The following POST request parameters
    from the user will be used to populate a SQL query:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击发生在攻击者能够将代码注入到目标Web应用程序用来访问其数据库的SQL语句中，从而执行攻击者希望执行的任何SQL代码。例如，假设一个网站要求用户输入用户名和密码，然后将这些信息插入到SQL查询中进行用户登录。以下是用户提交的POST请求参数，它们将用于填充SQL查询：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This SQL query will find the ID of a user that matches the username and password
    provided in the POST request. The application will then log in to that user’s
    account:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SQL查询将找到与POST请求中提供的用户名和密码匹配的用户ID。然后，应用程序将登录到该用户的帐户：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So what’s the problem here? Since users can’t predict the passwords of others,
    they should have no way of logging in as others, right? The issue is that attackers
    can insert characters that are special to the SQL language to mess with the logic
    of the query. For example, if an attacker submits the following POST request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里的问题是什么呢？由于用户无法预测其他人的密码，他们应该无法以其他人的身份登录，对吧？问题在于，攻击者可以插入对SQL语言有特殊意义的字符，从而干扰查询逻辑。例如，如果攻击者提交以下POST请求：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'the generated SQL query would become this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SQL查询将变成这样：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `--` sequence denotes the start of a SQL comment, which doesn’t get interpreted
    as code, so by adding `--` into the username part of the query, the attacker effectively
    comments out the rest of the SQL query. The query becomes this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`--`序列表示SQL注释的开始，注释部分不会被解释为代码，因此通过在查询的用户名部分添加`--`，攻击者有效地将SQL查询的其余部分注释掉。查询变成这样：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This query will return the admin user’s ID, regardless of the password provided
    by the attacker. By injecting special characters into the SQL query, the attacker
    bypassed authentication and can log in as the admin without knowing the correct
    password!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将返回管理员用户的ID，无论攻击者提供的密码是什么。通过将特殊字符注入到SQL查询中，攻击者绕过了身份验证，并且可以在不知道正确密码的情况下以管理员身份登录！
- en: 'Authentication bypass is not the only thing attackers can achieve with SQL
    injection. Attackers might also be able to retrieve data they shouldn’t be allowed
    to access. Let’s say a website allows users to access a list of their emails by
    providing the server a username and an access key to prove their identity:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证绕过并不是攻击者通过SQL注入能够实现的唯一目的。攻击者还可能能够检索他们不应该访问的数据。假设一个网站允许用户通过提供用户名和访问密钥来访问他们的电子邮件列表，以证明身份：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This GET request might generate a query to the database with the following
    SQL statement:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GET请求可能会生成一个查询，使用以下SQL语句：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, attackers can use the SQL query to read data from other tables
    that they should not be able to read. For instance, imagine they sent the following
    HTTP request to the server:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以利用SQL查询读取他们不应该能够访问的其他表中的数据。例如，假设他们向服务器发送了以下HTTP请求：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The server would turn the original SQL query into this one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器会将原始SQL查询转换为如下所示：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The SQL `UNION` 2 operator combines the results of two different `SELECT` statements.
    Therefore, this query combines the results of the first `SELECT` statement 1,
    which returns a user’s emails, and the second `SELECT` statement 3, which, as
    described earlier, returns all usernames and passwords from the Users table. Now
    the attacker can read all users’ usernames and passwords in the HTTP response!
    (Note that many SQL injection payloads would comment out whatever comes after
    the injection point 4, to prevent the rest of the query from messing up the syntax
    or logic of the query.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SQL `UNION` 2 操作符将两个不同的`SELECT`语句的结果结合起来。因此，这个查询将结合第一个`SELECT`语句1的结果（返回用户的电子邮件），以及第二个`SELECT`语句3的结果（如前所述，返回所有用户表中的用户名和密码）。现在，攻击者可以在HTTP响应中读取所有用户的用户名和密码！（注意，许多SQL注入负载会将注入点4之后的内容注释掉，以防止查询的其余部分干扰查询的语法或逻辑。）
- en: 'SQL injection isn’t limited to `SELECT` statements, either. Attackers can also
    inject code into statements like `UPDATE` (used to update a record), `DELETE`
    (used to delete existing records), and `INSERT` (used to create new entries in
    a table). For example, let’s say that this is the HTTP POST request used to update
    a user’s password on the target website:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入不仅限于 `SELECT` 语句。攻击者还可以将代码注入到类似 `UPDATE`（用于更新记录）、`DELETE`（用于删除现有记录）和 `INSERT`（用于在表中创建新条目）等语句中。例如，假设这是用于在目标网站上更新用户密码的
    HTTP POST 请求：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The website would form an `UPDATE` query with your new password and the ID
    of the currently logged-in user. This query will update the row in the Users table
    whose ID field is equal to 2, and set its password to `password12345`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网站会根据您的新密码和当前登录用户的 ID 形成一个 `UPDATE` 查询。此查询将更新用户表中 ID 字段等于 2 的行，并将其密码设置为 `password12345`：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this case, attackers can control the `SET` clause of the statement, which
    is used to specify which rows should be updated in a table. The attacker can construct
    a POST request like this one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以控制语句的 `SET` 子句，该子句用于指定应更新表中的哪些行。攻击者可以构造一个这样的 POST 请求：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This request generates the following SQL query:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该请求生成以下 SQL 查询：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `WHERE` clause, which specifies the criteria of the rows that should be
    updated, is commented out in this query. The database would update all rows in
    the table, and change all of the passwords in the Users table to `password12345`.
    The attacker can now log in as anyone by using that password.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询中的 `WHERE` 子句指定了应更新的行的条件，但它被注释掉了。数据库会更新表中的所有行，并将用户表中的所有密码更改为 `password12345`。攻击者现在可以使用该密码作为任何用户登录。
- en: Using Second-Order SQL Injections
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用二阶 SQL 注入
- en: So far, the SQL injections we’ve discussed are all first-order SQL injections.
    *First-order SQL injections* happen when applications use user-submitted input
    directly in a SQL query. On the other hand, *second-order SQL injections* happen
    when user input gets stored into a database, then retrieved and used unsafely
    in a SQL query. Even if applications handle input properly when it’s submitted
    by the user, these vulnerabilities can occur if the application mistakenly treats
    the data as safe when it’s retrieved from the database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的 SQL 注入都是一阶 SQL 注入。*一阶 SQL 注入*发生在应用程序直接使用用户提交的输入来构建 SQL 查询时。另一方面，*二阶
    SQL 注入*发生在用户输入被存储到数据库中，然后在查询中被不安全地检索和使用。即使应用程序在用户提交输入时正确处理了数据，如果在从数据库检索数据时误将其视为安全数据，这些漏洞仍然可能发生。
- en: 'For example, consider a web application that allows users to create an account
    by specifying a username and a password. Let’s say that a malicious user submits
    the following request:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个允许用户通过指定用户名和密码来创建帐户的 Web 应用程序。假设恶意用户提交了以下请求：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This request submits the username `vickie' UNION SELECT Username, Password FROM
    Users;--` and the password `password123` to the */signup* endpoint. The `username`
    POST request parameter contains a SQL injection payload that would `SELECT` all
    usernames and passwords and concatenate them to the results of the database query.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该请求将用户名 `vickie' UNION SELECT Username, Password FROM Users;--` 和密码 `password123`
    提交到 */signup* 端点。`username` POST 请求参数包含一个 SQL 注入负载，这将 `SELECT` 所有用户名和密码，并将它们与数据库查询结果连接起来。
- en: The application properly handles the user input when it’s submitted, using the
    protection techniques I’ll discuss in the next section. And the string `vickie'
    UNION SELECT Username, Password FROM Users;--` is stored into the application’s
    database as the attacker’s username.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在提交时正确处理用户输入，使用我将在下一部分中讨论的保护技术。并且字符串 `vickie' UNION SELECT Username, Password
    FROM Users;--` 被存储到应用程序的数据库中，作为攻击者的用户名。
- en: 'Later, the malicious user accesses their email with the following GET request:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，恶意用户通过以下 GET 请求访问他们的电子邮件：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, let’s say that if the user doesn’t provide a username and an
    access key, the application will retrieve the username of the currently logged-in
    user from the database and use it to populate a SQL query:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，假设如果用户没有提供用户名和访问密钥，应用程序将从数据库中检索当前登录用户的用户名，并用它来填充 SQL 查询：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But the attacker’s username, which contains SQL code, will turn the SQL query
    into the following one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是攻击者的用户名包含 SQL 代码，这将使 SQL 查询变成以下内容：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will return all usernames and passwords as email titles and bodies in the
    HTTP response!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有用户名和密码，作为电子邮件标题和正文显示在 HTTP 响应中！
- en: Prevention
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防范
- en: Because SQL injections are so devastating to an application’s security, you
    must take action to prevent them. One way you can prevent SQL injections is by
    using prepared statements. *Prepared statements* are also called *parameterized
    queries*, and they make SQL injections virtually impossible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL注入对应用程序安全的破坏性极大，你必须采取措施来防止它们。防止SQL注入的一种方法是使用预处理语句。*预处理语句*也叫做*参数化查询*，它们几乎可以让SQL注入变得不可能。
- en: Before we dive into how prepared statements work, it’s important to understand
    how SQL queries are executed. SQL is a programming language, and your SQL query
    is essentially a program. When the SQL program arrives at the SQL server, the
    server will parse, compile, and optimize it. Finally, the server will execute
    the program and return the results of the execution ([Figure 11-1](#figure11-1))*.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '在深入了解预处理语句如何工作之前，理解SQL查询是如何执行的非常重要。SQL是一种编程语言，而你的SQL查询本质上是一个程序。当SQL程序到达SQL服务器时，服务器会解析、编译并优化它。最后，服务器会执行该程序并返回执行结果（[图
    11-1](#figure11-1)）*.* '
- en: '![f11001](image_fi/501546c11/f11001.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](image_fi/501546c11/f11001.png)'
- en: 'Figure 11-1: Life of a SQL query'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：SQL查询的生命周期
- en: When you insert user-supplied input into your SQL queries, you are basically
    rewriting your program dynamically, using user input. An attacker can supply data
    that interferes with the program’s code and alter its logic ([Figure 11-2](#figure11-2)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将用户提供的输入插入到你的SQL查询中时，你基本上是在动态地重写你的程序，使用用户的输入。攻击者可以提供干扰程序代码的数据，进而改变其逻辑（[图 11-2](#figure11-2)）。
- en: '![f11002](image_fi/501546c11/f11002.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](image_fi/501546c11/f11002.png)'
- en: 'Figure 11-2: A SQL query that concatenates user input into the query before
    compilation will make the database treat user input as code.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：在编译前将用户输入连接到查询中的SQL查询会使数据库将用户输入当作代码处理。
- en: Prepared statements work by making sure that user-supplied data does not alter
    your SQL query’s logic. These SQL statements are sent to and compiled by the SQL
    server before any user-supplied parameters are inserted. This means that instead
    of passing a complete SQL query to the server to be compiled, you define all the
    SQL logic first, compile it, and then insert user-supplied parameters into the
    query right before execution ([Figure 11-3](#figure11-3)). After the parameters
    are inserted into the final query, the query will not be parsed and compiled again.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句的工作原理是确保用户提供的数据不会改变你的SQL查询的逻辑。这些SQL语句在插入任何用户提供的参数之前会先被发送到SQL服务器进行编译。这意味着你不是将完整的SQL查询传递给服务器编译，而是首先定义所有SQL逻辑，编译它，然后在执行前插入用户提供的参数（[图
    11-3](#figure11-3)）。参数插入最终查询后，查询将不会再次被解析和编译。
- en: '![f11003](image_fi/501546c11/f11003.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](image_fi/501546c11/f11003.png)'
- en: 'Figure 11-3: A SQL query that concatenates user input into the query after
    compilation allows the database to distinguish between the code part and the data
    part of the SQL query.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：在编译后将用户输入连接到查询中的SQL查询允许数据库区分SQL查询的代码部分和数据部分。
- en: Anything that wasn’t in the original statement will be treated as string data,
    not executable SQL code, so the program logic part of your SQL query will remain
    intact. This allows the database to distinguish between the code part and the
    data part of the SQL query, regardless of what the user input looks like.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不在原始语句中的内容都会被视为字符串数据，而不是可执行的SQL代码，因此你的SQL查询的程序逻辑部分将保持不变。这允许数据库区分SQL查询中的代码部分和数据部分，无论用户输入是什么样的。
- en: 'Let’s look at an example of how to execute SQL statements safely in PHP. Say
    that we want to retrieve a user’s ID by using their provided username and password,
    so we want to execute this SQL statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个如何在PHP中安全执行SQL语句的示例。假设我们希望通过用户提供的用户名和密码来检索用户的ID，因此我们想执行以下SQL语句：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s how to do that in PHP:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PHP中实现的方法：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In PHP, we first establish a connection with our database 1, and then retrieve
    the username and password as POST parameters from the user 23*.*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '在PHP中，我们首先与数据库建立连接 1，然后从用户那里通过POST参数获取用户名和密码 23*.* '
- en: 'To use a prepared statement, you would define the structure of the query first.
    We’ll write out the query without its parameters, and put question marks as placeholders
    for the parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预处理语句，你需要先定义查询的结构。我们会写出没有参数的查询，并用问号作为参数的占位符：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This query string will now be compiled by the SQL server as SQL code. You can
    then send over the parameters of the query separately. The following line of code
    will insert the user input into the SQL query:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询字符串现在将由SQL服务器作为SQL代码进行编译。然后，你可以单独发送查询的参数。以下代码行将用户输入插入到SQL查询中：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, you execute the query:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你执行查询：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The username and password values provided by the user aren’t compiled like
    the statement template, and aren’t executed as the logic part of the SQL code.
    Therefore, if an attacker provides the application with a malicious input like
    this one, the entire input would be treated as plain data, not as SQL code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的用户名和密码值不像语句模板那样被编译，并且不会作为SQL代码的逻辑部分执行。因此，如果攻击者提供恶意输入，像这样，整个输入将被视为普通数据，而不是SQL代码：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'How to use prepared statements depends on the programming language you are
    using to code your applications. Wikipedia provides a few examples: [https://en.wikipedia.org/wiki/Prepared_statement](https://en.wikipedia.org/wiki/Prepared_statement)*.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用预编译语句取决于你用来编写应用程序的编程语言。维基百科提供了一些示例：[https://en.wikipedia.org/wiki/Prepared_statement](https://en.wikipedia.org/wiki/Prepared_statement)*.*
- en: 'Another way of preventing SQL injections is to use an allowlist for allowed
    values. For example, the SQL `ORDER BY` clause allows a query to specify the column
    by which to sort the results. Therefore, this query will return all of the user’s
    emails in our table, sorted by the Date column, in descending order:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 防止SQL注入的另一种方法是使用允许值的允许列表。例如，SQL的`ORDER BY`子句允许查询指定排序结果的列。因此，这个查询将返回我们表中所有用户的电子邮件，并按Date列进行降序排序：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the application allows users to specify a column to use for ordering their
    email, it can rely on an allowlist of column names for the `ORDER BY` clause instead
    of allowing arbitrary input from the user. For example, the application can allow
    only the values `Date`, `Sender`, and `Title`, and reject all other user-input
    values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序允许用户指定一个列来对其电子邮件进行排序，它可以依赖一个允许列表（allowlist）来定义`ORDER BY`子句中的列名，而不是允许用户输入任意内容。例如，应用程序可以只允许`Date`、`Sender`和`Title`这三个值，拒绝所有其他用户输入的值。
- en: Finally, you can carefully sanitize and escape user input. However, this approach
    isn’t entirely bulletproof, because it’s easy to miss special characters that
    attackers could use to construct a SQL injection attack. Special characters that
    should be sanitized or escaped include the single quote (`'`) and double quote
    (`"`), but special characters specific to each type of database also exist. For
    more information about SQL input sanitization, read OWASP’s cheat sheet at [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以小心地清理和转义用户输入。然而，这种方法并非万无一失，因为攻击者可以利用一些特定的字符来构造SQL注入攻击，可能会遗漏某些特殊字符。需要清理或转义的特殊字符包括单引号(`'`)和双引号(`"`)，但是每种类型的数据库还有各自特定的特殊字符。有关SQL输入清理的更多信息，请阅读OWASP的备忘单：[https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)。
- en: Hunting for SQL Injections
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入漏洞猎杀
- en: 'Let’s start hunting for SQL injections! Earlier in this chapter, I mentioned
    that we can classify SQL injections as either first order or second order. But
    there’s another way of classifying SQL injections that is useful when exploiting
    them: classic SQL injections, and blind SQL. The approach to detecting and exploiting
    these differs.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始寻找SQL注入漏洞！在本章前面提到过，我们可以将SQL注入分为第一类和第二类。但在利用SQL注入时，还有另一种分类方式：经典SQL注入和盲注SQL。检测和利用这些注入的方式是不同的。
- en: Before we dive into each type, a common technique for detecting any SQL injection
    is to insert a single quote character (`'`) into every user input and look for
    errors or other anomalies. The single quote is a special character in SQL statements
    that denotes the end of a query string. If the application is protected against
    SQL injections, it should treat the single quote as plain data, and inserting
    a single quote into the input field should not trigger database errors or change
    the logic of the database query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论每种类型之前，一种常见的检测SQL注入的技巧是将单引号字符(`'`)插入到每个用户输入中，查看是否出现错误或其他异常。单引号是SQL语句中的特殊字符，用来标示查询字符串的结束。如果应用程序已经保护了SQL注入，它应该将单引号视为普通数据，插入单引号到输入字段中不应触发数据库错误，也不应改变数据库查询的逻辑。
- en: Another general way of finding SQL injections is *fuzzing*, which is the practice
    of submitting specifically designed SQL injection payloads to the application
    and monitoring the server’s response. We will talk about this in Chapter 25.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的SQL注入检测方法是 *模糊测试*，即向应用程序提交特别设计的SQL注入有效载荷，并监视服务器的响应。我们将在第25章讨论这一点。
- en: Otherwise, you can submit payloads designed for the target’s database intended
    to trigger a difference in database response, a time delay, or a database error.
    Remember, you’re looking for clues that the SQL code you injected can be executed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以提交针对目标数据库设计的有效载荷，目的是触发数据库响应中的差异、时间延迟或数据库错误。记住，你需要寻找的线索是你注入的SQL代码是否能被执行。
- en: 'Step 1: Look for Classic SQL Injections'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：查找经典SQL注入
- en: '*Classic SQL injections* are the easiest to find and exploit. In classic SQL
    injections, the results of the SQL query are returned directly to the attacker
    in an HTTP response. There are two subtypes: UNION based and error based.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*经典SQL注入* 是最容易发现和利用的。在经典SQL注入中，SQL查询的结果直接返回给攻击者作为HTTP响应。它有两个子类型：基于UNION和基于错误。'
- en: 'Our email example earlier is a case of the UNION-based approach: an attacker
    uses the `UNION` operator to concatenate the results of another query onto the
    web application’s response:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的电子邮件示例是基于UNION的方法：攻击者使用 `UNION` 运算符将另一个查询的结果连接到Web应用程序的响应中：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, the server would return all usernames and passwords along with
    the user *vickie*’s emails in the HTTP response ([Table 11-2](#table11-2)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器会在HTTP响应中返回所有用户名和密码以及用户*vickie*的电子邮件([表11-2](#table11-2))。
- en: 'Table 11-2: Emails That Result from Our Malicious Query'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-2：我们恶意查询所导致的电子邮件
- en: '| **Title** | **Body** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **正文** |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Finish setting up your account! | Please finish setting up your *example.com*
    account by submitting a recovery email address. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 完成账户设置！ | 请通过提交恢复邮箱地址来完成你的*example.com*账户设置。 |'
- en: '| Welcome | Welcome to *example.com*’s email service |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 欢迎 | 欢迎使用*example.com*的电子邮件服务 |'
- en: '| admin | t5dJ12rp$fMDEbSWz |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| admin | t5dJ12rp$fMDEbSWz |'
- en: '| vickie | password123 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| vickie | password123 |'
- en: '| jennifer | letmein! |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| jennifer | letmein! |'
- en: 'On the other hand, error-based SQL injection attacks trigger an error in the
    database to collect information from the returned error message. For example,
    we can induce an error by using the `CONVERT()` function in MySQL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于错误的SQL注入攻击通过触发数据库中的错误来收集返回的错误消息中的信息。例如，我们可以通过使用MySQL中的 `CONVERT()` 函数来诱发错误：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CONVERT(``VALUE``,` `FORMAT``)` function attempts to convert `VALUE` to
    the format specified by `FORMAT`. Therefore, this query will force the database
    to convert the admin’s password to a `date` format, which can sometimes cause
    the database to throw a descriptive error like this one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONVERT(``VALUE``, ``FORMAT``)` 函数尝试将 `VALUE` 转换为由 `FORMAT` 指定的格式。因此，这个查询将迫使数据库将管理员的密码转换为
    `date` 格式，这有时会导致数据库抛出像这样的描述性错误：'
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The database throws descriptive errors to help developers pinpoint problems,
    but can also accidentally reveal information to outsiders if error messages are
    shown to regular users as well. In this example, the database points out that
    it has failed to convert a string value, `"t5dJ12rp$fMDEbSWz"`, to the `date`
    format. But `t5dJ12rp$fMDEbSWz` is the password of the admin account! By displaying
    a descriptive error message, the database has accidentally revealed a sensitive
    piece of information to outsiders.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库抛出描述性错误，帮助开发人员定位问题，但如果错误消息也显示给普通用户，可能会无意间向外部泄露信息。在这个例子中，数据库指出它未能将字符串值 `"t5dJ12rp$fMDEbSWz"`
    转换为 `date` 格式。但是 `t5dJ12rp$fMDEbSWz` 是管理员账户的密码！通过显示描述性错误消息，数据库无意中泄露了一个敏感信息。
- en: 'Step 2: Look for Blind SQL Injections'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：查找盲注SQL注入
- en: 'Also called *inferential SQL injections*, *blind SQL injections* are a little
    harder to detect and exploit. They happen when attackers cannot directly extract
    information from the database because the application doesn’t return SQL data
    or descriptive error messages. In this case, attackers can infer information by
    sending SQL injection payloads to the server and observing its subsequent behavior.
    Blind SQL injections have two subtypes as well: Boolean based and time based.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 盲注SQL注入，也叫做*推理SQL注入*，稍微难以检测和利用。它发生在攻击者无法直接从数据库中提取信息时，因为应用程序不返回SQL数据或描述性错误消息。在这种情况下，攻击者可以通过向服务器发送SQL注入有效载荷并观察其随后的行为来推测信息。盲注SQL注入有两个子类型：基于布尔值和基于时间的。
- en: '*Boolean-based SQL injection* occurs when attackers infer the structure of
    the database by injecting test conditions into the SQL query that will return
    either `true` or `false`. Using those responses, attackers could slowly infer
    the contents of the database. For example, let’s say that *example.com* maintains
    a separate table to keep track of the premium members on the platform. Premium
    members have access to advanced features, and their home pages display a `Welcome,
    premium member!` banner. The site determines who is premium by using a cookie
    that contains the user’s ID and matching it against a table of registered premium
    members. The GET request containing such a cookie might look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于布尔值的SQL注入* 发生在攻击者通过向SQL查询中注入测试条件来推测数据库结构时，这些测试条件会返回 `true` 或 `false`。攻击者可以利用这些响应慢慢推断出数据库的内容。例如，假设
    *example.com* 维护了一个独立的表格来跟踪平台上的高级会员。高级会员可以访问高级功能，并且他们的主页会显示 `欢迎，高级会员！` 横幅。该站点通过使用包含用户ID的cookie，并将其与已注册的高级会员表格进行匹配，来判断谁是高级会员。包含此类cookie的GET请求可能如下所示：'
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The application uses this request to produce the following SQL query:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用此请求生成以下SQL查询：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If this query returns data, the user is a premium member, and the `Welcome,
    premium member!` banner will be displayed. Otherwise, the banner won’t be displayed.
    Let’s say your account isn’t premium. What would happen if you submit this user
    ID instead?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个查询返回数据，用户就是高级会员，并且会显示 `欢迎，高级会员！` 横幅。否则，横幅不会显示。假设你的账号不是高级会员。如果你提交这个用户ID会发生什么？
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Well, the query would become the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，查询将变为以下形式：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `SUBSTR(``STRING``,` `POSITION``,` `LENGTH``)` function extracts a substring
    from the `STRING`, of a specified `LENGTH`, at the specified `POSITION` in that
    string. Therefore, `SUBSTR(Password, 1, 1)` 1 returns the first character of each
    user’s password. Since user 2 isn’t a premium member, whether this query returns
    data will depend on the second `SELECT` statement, which returns data if the admin
    account’s password starts with an `a`. This means you can brute-force the admin’s
    password; if you submit this user ID as a cookie, the web application would display
    the premium banner if the admin account’s password starts with an `a`. You could
    try this query with the letters `b`, `c`, and so on, until it works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBSTR(``STRING``,` `POSITION``,` `LENGTH``)` 函数从指定的 `STRING` 中提取一个子字符串，长度为指定的
    `LENGTH`，并从指定的 `POSITION` 开始。因此，`SUBSTR(Password, 1, 1)` 返回每个用户密码的第一个字符。由于用户2不是高级会员，是否返回数据取决于第二个
    `SELECT` 语句，如果管理员账号的密码以 `a` 开头，这个查询会返回数据。这意味着你可以暴力破解管理员的密码；如果你将这个用户ID作为cookie提交，当管理员账户的密码以
    `a` 开头时，网页应用会显示高级会员横幅。你可以继续尝试使用字母 `b`、`c` 等，直到成功。'
- en: You can use this technique to extract key pieces of information from the database,
    such as the database version, table names, column names, and credentials. I talk
    more about this in “Escalating the Attack” on page 201.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个技术从数据库中提取关键信息，例如数据库版本、表名、列名和凭证。我在第201页的“升级攻击”中讲得更详细。
- en: A *time-based SQL injection* is similar, but instead of relying on a visual
    cue in the web application, the attacker relies on the response-time difference
    caused by different SQL injection payloads. For example, what might happen if
    the injection point from our preceding example doesn’t return any visual clues
    about the query’s results? Let’s say premium members don’t get a special banner,
    and their user interfaces don’t look any different. How do you exploit this SQL
    injection then?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于时间的SQL注入* 类似于此，但攻击者不是依赖于网页应用中的视觉提示，而是通过不同的SQL注入负载引起的响应时间差异。例如，如果我们前面提到的注入点没有返回任何关于查询结果的视觉线索，可能会发生什么？假设高级会员不会得到特别的横幅，他们的用户界面看起来也没有什么不同。那么在这种情况下你如何利用SQL注入？'
- en: 'In many databases, you can trigger a time delay by using a SQL query. If the
    time delay occurs, you’ll know the query worked correctly. Try using an `IF` statement
    in the SQL query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据库中，你可以通过使用SQL查询触发时间延迟。如果出现时间延迟，你就知道查询已正确执行。试着在SQL查询中使用 `IF` 语句：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For example, say you submit the following ID:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你提交以下ID：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The SQL query would become the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询将变为以下形式：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `SLEEP(``SECONDS``)` function in MySQL will create a time delay in the response
    for the specified number of seconds. This query will instruct the database to
    sleep for 10 seconds if the admin’s password starts with an `a` character. Using
    this technique, you can slowly figure out the admin’s password.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中的`SLEEP(``SECONDS``)`函数将在响应中创建指定秒数的时间延迟。如果管理员的密码以`a`字符开头，这个查询将指示数据库休眠10秒钟。通过这种技术，你可以慢慢找出管理员的密码。
- en: 'Step 3: Exfiltrate Information by Using SQL Injections'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：通过SQL注入泄露信息
- en: Imagine that the web application you’re attacking doesn’t use your input in
    a SQL query right away. Instead, it uses the input unsafely in a SQL query during
    a backend operation, so you have no way to retrieve the results of injection via
    an HTTP response, or infer the query’s results by observing server behavior. Sometimes
    there’s even a time delay between when you submitted the payload and when the
    payload gets used in an unsafe query, so you won’t immediately be able to observe
    differences in the application’s behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你攻击的web应用程序不会立即将你的输入用于SQL查询。相反，它会在后台操作中不安全地使用这些输入，在这种情况下，你无法通过HTTP响应来获取注入的结果，或者通过观察服务器的行为推测查询的结果。有时，提交负载和负载在不安全查询中使用之间甚至会有时间延迟，因此你无法立即观察到应用程序行为的差异。
- en: 'In this case, you’ll need to make the database store information somewhere
    when it does run the unsafe SQL query. In MySQL, the `SELECT. . .INTO` statement
    tells the database to store the results of a query in an output file on the local
    machine. For example, the following query will cause the database to write the
    admin’s password into */var/www/html/output.txt*, a file located on the web root
    of the target web server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要让数据库在运行不安全的SQL查询时将信息存储在某个地方。在MySQL中，`SELECT...INTO`语句告诉数据库将查询的结果存储在本地机器的输出文件中。例如，以下查询将导致数据库将管理员的密码写入*/var/www/html/output.txt*，该文件位于目标web服务器的网页根目录下：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We upload to the */var/www/html* directory because it’s the default web directory
    for many Linux web servers. Then you can simply access the information by navigating
    to the */output.txt* page on the target: *https://example.com/output.txt*. This
    technique is also a good way to detect second-order SQL injections, since in second-order
    SQL injections, there is often a time delay between the malicious input and the
    SQL query being executed.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件上传到*/var/www/html*目录，因为这是许多Linux web服务器的默认网页目录。然后，你可以通过访问目标的*/output.txt*页面轻松获取信息：*https://example.com/output.txt*。这种技术也是检测二次SQL注入的一个好方法，因为在二次SQL注入中，恶意输入和SQL查询执行之间通常会有时间延迟。
- en: Let’s put this information in context. Say that when you browse *example.com*,
    the application adds you to a database table to keep track of currently active
    users. Accessing a page with a cookie, like this
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个信息放在上下文中。假设当你浏览*example.com*时，应用程序将你添加到一个数据库表中，以跟踪当前活动的用户。访问带有cookie的页面，如下所示
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'will cause the application to add you to a table of active users. In this example,
    the ActiveUsers table contains only two columns: one for the user ID and one for
    the username of the logged-in user. The application uses an `INSERT` statement
    to add you to the ActiveUsers table. `INSERT` statements add a row into the specified
    table with the specified values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致应用程序将你添加到一个活动用户表中。在这个示例中，ActiveUsers表只包含两列：一列是用户ID，另一列是登录用户的用户名。应用程序使用`INSERT`语句将你添加到ActiveUsers表中。`INSERT`语句将带有指定值的一行插入到指定的表中：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, an attacker can craft a malicious cookie to inject into the `INSERT`
    statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以精心构造一个恶意cookie，将其注入到`INSERT`语句中：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This cookie 1 will, in turn, cause the `INSERT` statement to save the admin’s
    password into the *output.txt* file on the victim server:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个cookie 1将导致`INSERT`语句将管理员的密码保存到受害者服务器上的*output.txt*文件中：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, you will find the password of the admin account stored into the *output.txt*
    file on the target server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你会发现管理员账号的密码存储在目标服务器的*output.txt*文件中。
- en: 'Step 4: Look for NoSQL Injections'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤4：寻找NoSQL注入
- en: Databases don’t always use SQL. *NoSQL*, or *Not Only SQL*, databases are those
    that don’t use the SQL language. Unlike SQL databases, which store data in tables,
    NoSQL databases store data in other structures, such as key-value pairs and graphs.
    NoSQL query syntax is database-specific, and queries are often written in the
    programming language of the application. Modern NoSQL databases, such as MongoDB,
    Apache CouchDB, and Apache Cassandra, are also vulnerable to injection attacks.
    These vulnerabilities are becoming more common as NoSQL rises in popularity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库并不总是使用 SQL。*NoSQL*，即 *Not Only SQL*（不仅仅是 SQL），是指那些不使用 SQL 语言的数据库。与 SQL 数据库（它们将数据存储在表格中）不同，NoSQL
    数据库将数据存储在其他结构中，如键值对和图形。NoSQL 查询语法是特定于数据库的，查询通常用应用程序的编程语言编写。现代的 NoSQL 数据库，如 MongoDB、Apache
    CouchDB 和 Apache Cassandra，也容易受到注入攻击。随着 NoSQL 的流行，这些漏洞变得越来越常见。
- en: 'Take MongoDB, for example. In MongoDB syntax, `Users.find()` returns users
    that meet a certain criteria. For example, the following query returns users with
    the username `vickie` and the password `password123`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以 MongoDB 为例。在 MongoDB 语法中，`Users.find()` 返回符合某个条件的用户。例如，以下查询返回用户名为 `vickie`
    且密码为 `password123` 的用户：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the application uses this functionality to log in users and populates the
    database query directly with user input, like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用此功能登录用户，并且直接用用户输入填充数据库查询，如下所示：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'attackers can submit the password `{$ne: ""}` to log in as anyone. For example,
    let’s say that the attacker submits a username of `admin` and a password of `{$ne:
    ""}`. The database query would become as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '攻击者可以提交密码 `{$ne: ""}` 来以任何身份登录。例如，假设攻击者提交了用户名 `admin` 和密码 `{$ne: ""}`。数据库查询将变成如下：'
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In MongoDB, `$ne` selects objects whose value is not equal to the specified
    value. Here, the query would return users whose username is `admin` and password
    isn’t equal to an empty string, which is true unless the admin has a blank password!
    The attacker can thus bypass authentication and gain access to the admin account.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，`$ne` 用于选择那些值不等于指定值的对象。在这里，查询将返回用户名为 `admin` 且密码不为空字符串的用户，除非管理员的密码为空！因此，攻击者可以绕过身份验证并访问管理员账户。
- en: 'Injecting into MongoDB queries can also allow attackers to execute arbitrary
    JavaScript code on the server. In MongoDB, the `$where`, `mapReduce`, `$accumulator`,
    and `$function` operations allow developers to run arbitrary JavaScript. For example,
    you can define a function within the `$where` operator to find users named `vickie`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 向 MongoDB 查询中注入代码还可以让攻击者在服务器上执行任意 JavaScript 代码。在 MongoDB 中，`$where`、`mapReduce`、`$accumulator`
    和 `$function` 操作允许开发者运行任意 JavaScript 代码。例如，你可以在 `$where` 操作符中定义一个函数来查找名为 `vickie`
    的用户：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Say the developer allows unvalidated user input in this function and uses that
    to fetch account data, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设开发者允许在此函数中使用未经验证的用户输入，并利用该输入来获取账户数据，如下所示：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In that case, an attacker can execute arbitrary JavaScript code by injecting
    it into the `$where` operation. For example, the following piece of malicious
    code will launch a denial-of-service (DoS) attack by triggering a never-ending
    `while` loop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以通过将任意 JavaScript 代码注入到 `$where` 操作中来执行该代码。例如，以下恶意代码段将通过触发一个永无止境的
    `while` 循环来发起拒绝服务（DoS）攻击：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The process of looking for NoSQL injections is similar to detecting SQL injections.
    You can insert special characters such as quotes (`' "`), semicolons (`;`), and
    backslashes (`\`), as well as parentheses (`()`), brackets(`[]`), and braces (`{}`)
    into user-input fields and look for errors or other anomalies. You can also automate
    the hunting process by using the tool NoSQLMap ([https://github.com/codingo/NoSQLMap/](https://github.com/codingo/NoSQLMap/)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 NoSQL 注入的过程类似于检测 SQL 注入。你可以将特殊字符如引号（`' "`）、分号（`;`）、反斜杠（`\`），以及括号（`()`）、中括号（`[]`）和大括号（`{}`）插入到用户输入字段中，并查找错误或其他异常情况。你也可以通过使用工具
    NoSQLMap ([https://github.com/codingo/NoSQLMap/](https://github.com/codingo/NoSQLMap/))
    来自动化搜索过程。
- en: Developers can prevent NoSQL injection attacks by validating user input and
    avoiding dangerous database functionalities. In MongoDB, you can disable the running
    of server-side JavaScript by using the `--noscripting` option in the command line
    or setting the `security.javascriptEnabled` flag in the configuration file to
    `false`. Find more information at [https://docs.mongodb.com/manual/faq/fundamentals/index.html](https://docs.mongodb.com/manual/faq/fundamentals/index.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过验证用户输入并避免使用危险的数据库功能来防止 NoSQL 注入攻击。在 MongoDB 中，你可以通过在命令行中使用 `--noscripting`
    选项，或者在配置文件中将 `security.javascriptEnabled` 标志设置为 `false` 来禁用服务器端 JavaScript 的运行。更多信息请参考
    [https://docs.mongodb.com/manual/faq/fundamentals/index.html](https://docs.mongodb.com/manual/faq/fundamentals/index.html)。
- en: Additionally, you should follow the *principle of least privilege* when assigning
    rights to applications. This means that applications should run with only the
    privileges they require to operate. For example, when an application requires
    only read access to a file, it should not be granted any write or execute permissions.
    This will lower your risk of complete system compromise during an attack.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在为应用程序分配权限时，你应该遵循 *最小权限原则*。这意味着应用程序应仅以其正常运行所需的权限运行。例如，当一个应用程序只需要读取文件时，就不应该授予任何写入或执行权限。这将降低攻击中完全系统被攻破的风险。
- en: Escalating the Attack
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升攻击
- en: Attackers most often use SQL injections to extract information from the database.
    Successfully collecting data from a SQL injection is a technical task that can
    sometimes be complicated. Here are some tips you can use to gain information about
    a target for exploitation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者通常使用 SQL 注入来从数据库中提取信息。成功地从 SQL 注入中收集数据是一项技术任务，有时可能会很复杂。以下是一些可以用来收集目标信息以进行利用的提示。
- en: Learn About the Database
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解数据库
- en: First, it’s useful to gain information about the structure of the database.
    Notice that many of the payloads that I’ve used in this chapter require some knowledge
    of the database, such as table names and field names.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解数据库结构是非常有用的。注意，在本章中我使用的许多有效载荷都需要对数据库有所了解，例如表名和字段名。
- en: 'To start with, you need to determine the database software and its structure.
    Attempt some trial-and-error SQL queries to determine the database version. Each
    type of database will have different functions for returning their version numbers,
    but the query should look something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确定数据库软件及其结构。尝试一些试探性的 SQL 查询来确定数据库版本。每种类型的数据库都有不同的函数来返回其版本号，但查询看起来应该像这样：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Some common commands for querying the version type are `@@version` for Microsoft
    SQL Server and MySQL, `version()` for PostgreSQL, and `v$version` for Oracle.
    The `1` in the `UNION SELECT 1,` `DATABASE_VERSION_QUERY``;--` line is necessary,
    because for a `UNION` statement to work, the two `SELECT` statements it connects
    need to have the same number of columns. The first `1` is essentially a dummy
    column name that you can use to match column numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的查询版本类型的命令包括：`@@version` 用于 Microsoft SQL Server 和 MySQL，`version()` 用于
    PostgreSQL，`v$version` 用于 Oracle。在 `UNION SELECT 1,` `DATABASE_VERSION_QUERY``;--`
    这一行中的 `1` 是必要的，因为要使 `UNION` 语句正常工作，它连接的两个 `SELECT` 语句需要有相同数量的列。第一个 `1` 本质上是一个占位符列名，可以用来匹配列的数量。
- en: 'Once you know the kind of database you’re working with, you could start to
    scope it out further to see what it contains. This query in MySQL will show you
    the table names of user-defined tables:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了你所使用的数据库类型，你可以进一步查看它包含的内容。以下是 MySQL 查询，它将显示用户自定义表的表名：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And this one will show you the column names of the specified table. In this
    case, the query will list the columns in the Users table:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将显示指定表的列名。在这种情况下，查询将列出 `Users` 表中的列：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All of these techniques are possible during classic and blind attacks. You
    just need to find a different way to fit those commands into your constructed
    queries. For instance, you can determine a database’s version with a time-based
    technique like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术在经典攻击和盲注攻击中都可以使用。你只需要找到不同的方式将这些命令嵌入到你构造的查询中。例如，你可以使用基于时间的技术来确定数据库的版本，方法如下：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After you’ve learned about the database’s structure, start targeting certain
    tables to exfiltrate data that interests you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了数据库结构之后，开始针对特定的表进行数据提取，获取你感兴趣的信息。
- en: Gain a Web Shell
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 Web Shell
- en: 'Another way to escalate SQL injections is to attempt to gain a web shell on
    the server. Let’s say we’re targeting a PHP application. The following piece of
    PHP code will take the request parameter named `cmd` and execute it as a system
    command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can use the SQL injection vulnerability to upload this PHP code to a location
    that you can access on the server by using `INTO OUTFILE`. For example, you can
    write the password of a nonexistent user and the PHP code `<? system($_REQUEST[''cmd'']);
    ?>` into a file located at */var/www/html/shell.php* on the target server:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since the password of the nonexistent user will be blank, you are essentially
    uploading the PHP script to the *shell.php* file. Then you can simply access your
    *shell.php* file and execute any command you wish:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Automating SQL Injections
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing for SQL injection manually isn’t scalable. I recommend using tools to
    help you automate the entire process described in this chapter, from SQL injection
    discovery to exploitation. For example, sqlmap ([http://sqlmap.org/](http://sqlmap.org/))
    is a tool written in Python that automates the process of detecting and exploiting
    SQL injection vulnerabilities. A full tutorial of sqlmap is beyond the scope of
    this book, but you can find its documentation at [https://github.com/sqlmapproject/sqlmap/wiki/](https://github.com/sqlmapproject/sqlmap/wiki/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into automating your attacks with sqlmap, make sure you understand
    each of its techniques so you can optimize your attacks. Most of the techniques
    it uses are covered in this chapter. You can either use sqlmap as a standalone
    tool or integrate it with the testing proxy you’re using. For example, you can
    integrate sqlmap into Burp by installing the SQLiPy Burp plug-in.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your First SQL Injection!
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL injections are an exciting vulnerability to find and exploit, so dive into
    finding one on a practice application or bug bounty program. Since SQL injections
    are sometimes quite complex to exploit, start by attacking a deliberately vulnerable
    application like the Damn Vulnerable Web Application for practice, if you’d like.
    You can find it at [http://www.dvwa.co.uk/](http://www.dvwa.co.uk/). Then follow
    this road map to start finding real SQL injection vulnerabilities in the wild:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Map any of the application’s endpoints that take in user input.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert test payloads into these locations to discover whether they’re vulnerable
    to SQL injections. If the endpoint isn’t vulnerable to classic SQL injections,
    try inferential techniques instead.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve confirmed that the endpoint is vulnerable to SQL injections, use
    different SQL injection queries to leak information from the database.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Escalate the issue. Figure out what data you can leak from the endpoint and
    whether you can achieve an authentication bypass. Be careful not to execute any
    actions that would damage the integrity of the target’s database, such as deleting
    user data or modifying the structure of the database.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, draft up your first SQL injection report with an example payload that
    the security team can use to duplicate your results. Because SQL injections are
    quite technical to exploit most of the time, it’s a good idea to spend some time
    crafting an easy-to-understand proof of concept.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，草拟你的第一份SQL注入报告，提供一个示例有效载荷，供安全团队用来复制你的结果。因为SQL注入大多数时候利用起来相当技术性，花时间制作一个易于理解的概念验证是个好主意。
