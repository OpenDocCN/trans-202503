<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>Project 5: Real-Time Music Visualizer by Michael Krumpus</title>
    <link href="../styles/9781593278472.css" rel="stylesheet" type="text/css"/>
    <link href="../68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_94"/><span class="big">5</span><br/>Real-Time Music Visualizer by Michael Krumpus</h2>
<p class="ch-sub"><span epub:type="pagebreak" id="page_95"/>This project shows you how to create an awesome music visualizer using an arduino and an LED strip.</p>
<div class="image"><img src="../images/f0095-01.jpg" alt="image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_96"/>After building this project, you’ll be able to plug any music source into the circuit and the LED strip will display a cool, multicolored light show synchronized to your music in real time. This project is great for parties, DJ booths, or even your dorm room! To see the visualizer in action, have a look at this short video: <em><a href="https://youtu.be/GkjBT-EmRw8">https://youtu.be/GkjBT-EmRw8</a></em>.</p>
<p class="indent">First we’ll look at the theory behind making a music visualizer so you have some understanding of how it works before getting into the build. After the circuit is built, you’ll learn how the code works and how to load it into the Arduino. Finally, we’ll cover some tips on how to revise the code to make it behave differently so you can experiment on your own.</p>
<h3 class="h3" id="lev74"><strong>GET THE PARTS</strong></h3>
<p class="noindent">The parts for the Real-Time Music Visualizer are easy to find. This list suggests Adafruit for some of the more specialized parts and Mouser for simple passive components.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>The length of your LED strip determines your power needs. For a 2 m strip, a 2 A power supply is enough. But if you use a 3 m strip, you’ll need a 5 A or 10 A supply. Adafruit P/N 658 is a good option for 10 A.</em></p>
</div>
<ul>
<li class="noindent">Arduino Uno (Adafruit P/N 50; see “<a href="intro.xhtml#lev17">Getting Started with the Arduino and the Arduino IDE</a>” on <a href="intro.xhtml#page_15">page 15</a> for setup instructions)</li>
<li class="noindent">1, 2, or 3 m WS2812B RGB LED strip (for example, Adafruit NeoPixel P/N 1461)</li>
<li class="noindent">5 V, 2 A power supply (Adafruit P/N 276, or P/N 658 for 10 A)</li>
<li class="noindent">2.1 mm DC breadboard power jack (Adafruit P/N 368)</li>
<li class="noindent">Two breadboard audio jacks (Adafruit P/N 1699)</li>
<li class="noindent">10 kΩ potentiometer (for example, Adafruit P/N 356)</li>
<li class="noindent">Solderless full-size breadboard (Adafruit P/N 239)</li>
<li class="noindent">22-gauge solid hookup wire for connecting components (Adafruit P/N 1311)</li>
<li class="noindent">Three 4.7 kΩ resistors (Mouser P/N 291-4.7K-RC)</li>
<li class="noindent">Two 100 kΩ resistors (Mouser P/N 291-100K-RC)</li>
<li class="noindent">2.2 kΩ resistor (Mouser P/N 291-2.2K-RC)</li>
<li class="noindent">470 Ω resistor (Mouser P/N 291-470-RC)</li>
<li class="noindent">0.047 μF (47 nF) ceramic capacitor (Mouser P/N 594-K473K10X7RF5UH5)</li>
<li class="noindent">10 μF aluminum electrolytic capacitor (Mouser P/N 80-ESK106M016AC3AA)</li>
<li class="noindent">1,000 μF aluminum electrolytic capacitor (Mouser P/N 647-UVR1C102MPD)</li>
<li class="noindent"><span epub:type="pagebreak" id="page_97"/>Two 3.5 mm audio cables (Adafruit P/N 2698)</li>
<li class="noindent">Music player and speakers of your choice</li>
</ul>
<h3 class="h3" id="lev75"><strong>HOW IT WORKS: TURNING MUSIC INTO DATA</strong></h3>
<p class="noindent">To visualize your music, the visualizer must analyze the content of an audio signal and display something in response on the LED strip. But how do we analyze an audio signal with Arduino code? The secret lies in the <em>Fast Fourier Transform (FFT)</em> algorithm, a mathematical technique dating back to the 19th century. We won’t go into the math details because digital signal processing is quite complex, but the basic idea is that a signal that varies over time (like the voltage of an audio signal) can be analyzed and broken down into its frequency components. You’re probably already familiar with this idea if you’ve seen a spectrum analyzer on stereo equipment and music players on your computer, shown in <a href="ch05.xhtml#ch05fig1">Figure 5-1</a>.</p>
<div class="image"><a id="ch05fig1"/><img src="../images/f0097-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-1:</strong> A typical spectrum analyzer</p>
<p class="indent">The vertical bars represent frequency bands, with the bars on the left representing lower frequencies (bass) and those on the right representing higher frequencies (treble). The Arduino code in this project will sample the audio signal’s voltage and perform the FFT algorithm on the audio samples to determine the signal strength in each frequency band. Then we’ll use the levels of the low-frequency bands (the bass beat of the music) to create an interesting display on the LED strip.</p>
<p class="indent">In the visualizer circuit you’ll plug your computer, phone, tablet, or other music device into a 3.5 mm (1/8 inch) input jack to take the music signal. You’ll connect an output jack to your powered speakers, stereo amplifier, or whatever device you use to amplify your music and output it to speakers. In other words, the circuit sits between your music source and amplifier/speaker equipment so it <span epub:type="pagebreak" id="page_98"/>can “listen” to the music and put on a show. The rest of the circuit consists of some simple components and an Arduino. There are some tricky aspects to dealing with audio signals in electronics, so this section describes a couple of the techniques we’ll use to make the circuit work. This section will teach you quite a bit about audio processing!</p>
<h4 class="h4" id="lev76"><strong>Input Bias</strong></h4>
<p class="noindent">An Arduino board can measure voltages on its six analog input pins, labeled A0 through A5 on the board. Your visualizer will connect the audio signal for your music to Arduino pin A0 to take a large number of sample measurements very quickly, then apply the FFT algorithm to the signal to transform it into data the Arduino can analyze.</p>
<p class="indent">If you’re familiar with analog input measurement on Arduino, you know that a call to the <span class="literal">analogRead()</span> function, which reads data from the analog pins, returns a value in the range of 0–1023, which represents the measured voltage in the range of 0–5 V. But there is a problem when we want to measure an analog audio signal: audio is an <em>alternating current</em>, not direct current. That is, the voltage swings above ground (0 V) and then <em>below</em> ground to a negative voltage (see <a href="ch05.xhtml#ch05fig2">Figure 5-2</a>).</p>
<div class="image"><a id="ch05fig2"/><img src="../images/f0098-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-2:</strong> A simple audio signal oscillating between positive and negative voltages</p>
<p class="indent">The Arduino cannot measure voltages below 0 V, so we cannot connect an audio signal to pin A0 without potentially damaging the Arduino. How do we solve this?</p>
<p class="indent">The solution is to “bias” the voltage up to a higher level so that it is not centered around 0 V, but around a higher voltage instead. That means when the voltage swings low it won’t dip under 0 V. We accomplish this with a voltage divider made out of two resistors of equal value. The audio signal has one resistor connecting it to 5 V and another connecting it to 0 V (<a href="ch05.xhtml#ch05fig3">Figure 5-3</a>). This biases the signal up to the midpoint between 0 and 5 V, or 2.5 V.</p>
<div class="image"><span epub:type="pagebreak" id="page_99"/><a id="ch05fig3"/><img src="../images/f0099-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-3:</strong> An input bias circuit for an audio signal</p>
<p class="indent"><a href="ch05.xhtml#ch05fig4">Figure 5-4</a> shows the same signal, but centered around 2.5 V instead of 0 V. Now the Arduino can measure audio voltages without worrying about them swinging below ground. Audio signals are usually only a few volts from peak to peak, so this approach works well.</p>
<div class="image"><a id="ch05fig4"/><img src="../images/f0099-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-4:</strong> An audio signal now biased up 2.5 V</p>
<h4 class="h4" id="lev77"><strong>Sensitivity Control</strong></h4>
<p class="noindent">The audio signal needs to be strong enough that the voltage swings over a large enough range for the visualizer to be able to effectively analyze it. But some audio sources don’t output a really strong signal. We need to give our circuit the ability to adjust the sensitivity so that we can work with weak signals. This section describes a clever trick to accomplish this.</p>
<p class="indent">Recall from the previous section that the Arduino can measure voltages between 0 V and 5 V, and that we’ve biased the audio voltage up to be centered around 2.5 V. If the audio signal is weak and the voltage doesn’t vary much, we’d have a signal like that shown in <a href="ch05.xhtml#ch05fig5">Figure 5-5</a>. This might be the case in a “line-level” signal where the peak-to-peak voltage is only 1 V.</p>
<div class="image"><span epub:type="pagebreak" id="page_100"/><a id="ch05fig5"/><img src="../images/f0100-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-5:</strong> A weak audio signal</p>
<p class="indent">Measuring this signal will result in <span class="literal">analogRead(0)</span> values around 512 (the midpoint between 0–1023), but they won’t vary enough to give us a good analysis.</p>
<p class="indent">Fortunately, the Arduino board has a special pin called the <em>analog reference (AREF)</em>. We can provide a voltage on this pin and tell the Arduino code that this is the highest voltage we are going to read on the analog input. For example, to measure voltages between 0 V and 2 V and have the <span class="literal">analogRead()</span> value use the full 0–1023 range, we provide 2 V on the AREF pin. A 2 V measurement will give the value of 1023 instead of something much lower.</p>
<p class="indent">In this circuit we’ll use a potentiometer to provide a voltage to the AREF pin. For higher sensitivity, we simply provide a lower voltage by turning the potentiometer.</p>
<p class="indent">Easy, right? Not so fast! Remember that the audio signal is centered around 2.5 V. If we lower the analog reference too low, we’ll be ignoring the upper part of the signal because the top peaks will be “cut off.” In this case we will just get garbage from the FFT algorithm. The solution is that we <em>also</em> lower the top voltage on the input bias circuit so that the bias circuit will center the audio signal around the midpoint between 0 V and the voltage we provide to AREF. <a href="ch05.xhtml#ch05fig6">Figure 5-6</a> shows the situation where we have a weak audio signal that swings only about 1 V from peak to peak. The potentiometer in the circuit provides an AREF voltage of 2 V, which we also use as the top of the bias circuit. Now the audio signal is centered around 1 V and fills a much larger range of <span class="literal">analogRead()</span> values. In effect, we’ve amplified the signal! We didn’t actually increase the voltage of the signal; we simply reduced the range of voltages that we’re measuring so that the weak signal fills more of the range. Clever.</p>
<div class="image"><a id="ch05fig6"/><img src="../images/f0100-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-6:</strong> A weak audio signal with sensitivity adjusted to set top voltage to 2 V</p>
<h3 class="h3" id="lev78"><span epub:type="pagebreak" id="page_101"/><strong>BUILD IT</strong></h3>
<p class="noindent">It’s time to start building the music visualizer circuit on a breadboard. These instructions will show this process in multiple steps to make it easier to build up the circuit. You may choose to lay out your components on the breadboard differently, but these diagrams are intended to give you the most clarity. Let’s get started!</p>
<ol>
<li class="noindent"><p class="list"><strong>Add the audio jacks to the breadboard.</strong> Connect the left and right channels of the input jack directly to the left and right channels of the output jack, respectively, as shown in <a href="ch05.xhtml#ch05fig7">Figure 5-7</a>. This means that the music flows through to output. The jack middle pins should connect to ground. Also connect the power rails of each side of the board with red and black wires as shown.</p>
<div class="image"><a id="ch05fig7"/><img src="../images/f0101-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-7:</strong> Audio jacks and power rail connections</p></li>
<li class="noindent"><p class="list"><strong>Filter out noise with an audio summing circuit.</strong> Now connect the left and right channels together through a resistor on each channel to prevent crosstalk (interference) between them. Add a 4.7 kΩ resistor on each channel, as shown in <a href="ch05.xhtml#ch05fig8">Figure 5-8</a>. Add the 10 μF capacitor with the negative terminal (the shorter lead) on the left, connected to the output jack via the 4.7 kΩ resistor. Then add a 0.047 μF (or 47 nF) capacitor and connect one leg to the positive terminal of the 10 μF capacitor and the other leg to ground, as shown. These help to filter out noise and block DC current.</p>
<div class="image"><a id="ch05fig8"/><img src="../images/f0101-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-8:</strong> Audio summing circuit and filter</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_102"/><strong>Build up the input bias and analog reference circuit.</strong> Recall that our voltage divider is made of two 100 kΩ resistors and will center the audio signal between 0 V and the analog reference voltage, which we control with the 10 kΩ potentiometer. Insert those resistors, with one leg of the first resistor placed directly in the ground rail, and the other leg connected to the second 100 kΩ resistor, as shown in <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>. Make sure the second resistor is inserted adjacent to the first, as shown. Now place a potentiometer in the breadboard and connect the rightmost pin to ground through a 2.2 kΩ resistor. Connect a 4.7 kΩ resistor to the middle pin of the potentiometer—this will eventually connect to the AREF pin on the Arduino—and make sure this resistor straddles the center divide on the breadboard. This middle pin should also connect to the second leg of the second 100 kΩ resistor. The final empty pin of the potentiometer connects to the power rail.</p>
<div class="image"><a id="ch05fig9"/><img src="../images/f0102-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-9:</strong> Input bias components</p></li>
<li class="noindent"><p class="list"><strong>Connect a power jack to power the circuit.</strong> Connect the power jack to the power rails of the breadboard. Also connect the large 1,000 μF capacitor to the power lines as shown in <a href="ch05.xhtml#ch05fig10">Figure 5-10</a>. Electrolytic capacitors are polarized, so pay attention to the polarity: the positive lead is longer than the negative lead and should connect to the positive rail. There is also a white stripe on the negative side of the capacitor. This capacitor provides a reservoir of voltage in case the LED strip draws a lot of current all at once. For example, setting all LEDs on the strip to white at the same time would draw a lot of current from the circuit, but the capacitor would help smooth out any resulting voltage dips so the circuit doesn’t overload.</p>
<div class="image"><span epub:type="pagebreak" id="page_103"/><a id="ch05fig10"/><img src="../images/f0103-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-10:</strong> Power connection for the LED strip</p></li>
<li class="noindent"><p class="list"><strong>Connect the LED strip to your circuit.</strong> The LED strip has three connections: 5 V, ground, and data in (DIN). These electrical connections are not always in the same order on all LED strips. For example, the DIN connection is often in the middle, but <a href="ch05.xhtml#ch05fig11">Figure 5-11</a> shows it at the top. Just pay close attention to the labels on your LED strip. You may need to solder wires to your LED strip if yours doesn’t have a connector of some kind (turn to the appendix for instructions on soldering). Whatever the case, connect the 5 V, ground, and DIN connections to the circuit as shown in <a href="ch05.xhtml#ch05fig11">Figure 5-11</a>, with the DIN pin connected to a 470 Ω resistor (the other end of the resistor will connect to the Arduino).</p>
<div class="image"><a id="ch05fig11"/><img src="../images/f0103-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-11:</strong> Connecting the LED strip</p></li>
<li class="noindent"><p class="list"><strong>Wire up the Arduino.</strong> We’re almost done! The last wires connect to your Arduino board, as shown in <a href="ch05.xhtml#ch05fig12">Figure 5-12</a>. The green wire connects Arduino pin 6 to the 470 Ω resistor on the DIN <span epub:type="pagebreak" id="page_104"/>connection. The blue wire connects to the Arduino AREF pin. The yellow wire is the audio signal and connects to Arduino analog pin A0. The last connection you need to make is wiring the breadboard ground signal to an Arduino ground pin marked GND, but don’t make this connection just yet. If there is a program already running on your Arduino, it could damage parts of your circuit when you connect your circuit to the Arduino. So, to be safe, we’ll load the sketch for this project first and then finish connecting the Arduino.</p>
<div class="image"><a id="ch05fig12"/><img src="../images/f0104-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 5-12:</strong> Connecting the Arduino to the circuit</p></li>
</ol>
<h3 class="h3" id="lev79"><strong>CODE IT</strong></h3>
<p class="noindent">This circuit won’t do anything without some awesome code on the Arduino! The Arduino sketch we’ll use is fairly complex and there isn’t room to print it all here, but this section will describe how it generally works so you can learn the basics. Download the sketch from the book’s resources at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em>.</p>
<h4 class="h4" id="lev80"><strong>How It Works</strong></h4>
<p class="noindent">The Arduino program’s job is to “listen” to the music by capturing voltage samples in a buffer and then perform an FFT analysis on <span epub:type="pagebreak" id="page_105"/>those samples to determine the levels of each frequency band. This gives us data similar to an ordinary spectrum analyzer—the signal strength of each frequency band at any particular moment.</p>
<p class="indent">Instead of just displaying columns of LEDs, though, we do something much more interesting. Every time a new maximum or peak in a frequency band is detected, the code generates a pair of moving pixels that originate in the middle of the LED strip and move outward toward the ends. The speed of the moving pixels depends on the peak’s strength, and the pixels fade in brightness as they move outward. The colors of the peaks vary randomly. Note that we pay attention only to the bottom three frequency bands (out of eight bands) so that we are visualizing the music’s beat.</p>
<p class="indent">Here’s the code for the main loop, with explanatory comments:</p>
<p class="programs"><span class="light-teal">void</span> <span class="green">loop</span>() {<br/>  <span class="gray">// While the ADC interrupt is enabled, wait. The program is</span><br/>  <span class="gray">// still gathering audio samples in the capture buffer.</span><br/>  <span class="green">while</span> (ADCSRA &amp; _BV(ADIE)) {<br/><span class="gray">    // Wait...</span><br/>  }<br/><br/>  <span class="gray">// The sampling interrupt has finished filling the buffer,</span><br/>  <span class="gray">// so show the output we computed last time through the</span><br/>  <span class="gray">// loop. This sends the data to the LED strip.</span><br/>  strip.show();<br/><br/>  <span class="gray">// Perform the FFT algorithm to convert samples to</span><br/>  <span class="gray">// complex numbers.</span><br/>  fft_input(capture, bfly_buff);<br/><br/>  <span class="gray">// Now that we've updated the LED strip and processed the</span><br/>  <span class="gray">// audio samples with FFT, we can resume the collection</span><br/>  <span class="gray">// of audio samples in the sample buffer. The interrupt</span><br/>  <span class="gray">// service routine (ISR) will run while we compute the next</span><br/>  <span class="gray">// LED output based on the audio samples we captured.</span><br/>  startSampling();<br/><br/>  <span class="gray">// Perform the rest of the FFT computation:</span><br/>  fft_execute(bfly_buff);          <span class="gray">// Process complex data</span><br/>  fft_output(bfly_buff, spectrum); <span class="gray">// Complex -&gt; spectrum</span><br/><br/>  <span class="gray">// Now call this to analyze the audio. See comments in this</span><br/>  <span class="gray">// function for details.</span><br/>  analyzeAudioSamples();<br/><br/>  <span class="gray">// The peak values for each of the 8 bands has been</span><br/>  <span class="gray">// computed. A bit in the 8-bit value newPeakFlags</span><br/><span epub:type="pagebreak" id="page_106"/>  <span class="gray">// indicates whether the analysis found a *new* peak</span><br/>  <span class="gray">// in the band.</span><br/>  <span class="green">for</span> (i = 0; i &lt;= CUTOFF_BAND; i++) {<br/>  <span class="gray">  // If a new peak was found in band i...</span><br/>    <span class="green">if</span> (newPeakFlags &amp; (1 &lt;&lt; i)) {<br/>  <span class="gray">    // Map the peak value to a magnitude in range [0,255].</span><br/>  <span class="gray">    // We pass in the band number because the mapping is</span><br/>  <span class="gray">    // different for different bands.</span><br/>      <span class="light-teal">uint8_t</span> magnitude = getMagnitude(i, bandPeakLevel[i]);<br/><br/>  <span class="gray">    // A nonzero magnitude means that the peak value is</span><br/>  <span class="gray">    // large enough to do something visually with it. We</span><br/>  <span class="gray">    // ignore small peaks.</span><br/>      <span class="green">if</span> (magnitude &gt; 0) {<br/>  <span class="gray">      // We want to store the information about the peak</span><br/>  <span class="gray">      // in a peak_t structure. When we actually draw a</span><br/>  <span class="gray">      // visualization, the peak_t structures in peaks[]</span><br/>  <span class="gray">      // represent the "visually active" band peaks.</span><br/><br/>        <span class="gray">// Look through the list of peak structures 'peaks'</span><br/>        <span class="gray">// for an unused one.</span><br/>        <span class="green">for</span> (j = 0; j &lt; N_PEAKS; j++) {<br/>          <span class="green">if</span> (peaks[j].magnitude == 0) {<br/>            <span class="gray">// Unused peak found.</span><br/>            peakIndex = j;<br/>            <span class="green">break</span>;<br/>          }<br/>        }<br/>        <span class="gray">// If an unused one not found, we use the last one</span><br/>        <span class="gray">// that was used (peakIndex).</span><br/><br/>        <span class="gray">// Initialize the structure.</span><br/>        peaks[peakIndex].age = 0;<br/>        <span class="gray">// A random component for a visualization to use. For</span><br/>        <span class="gray">// example, to shift the color a small amount.</span><br/>        peaks[peakIndex].rnd = <span class="orange">random</span>(255); <br/>        peaks[peakIndex].baseColor =<br/>          getRandomBaseColor(peaks[peakIndex].rnd);<br/>        peaks[peakIndex].magnitude = magnitude;<br/>      }<br/>    }<br/>  }<br/><br/>  <span class="gray">// Clear the last frame.</span><br/>  strip.<span class="orange">clear</span>();<br/>  <span class="gray">// Draw the peaks on the LED strip.</span><br/>  doVisualization();<br/>} <span class="gray">// end loop()</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_107"/>There’s a lot more to the code than this main loop, and most of the heavy lifting is performed in the <span class="literal">analyzeAudioSamples()</span> and <span class="literal">doVisualization()</span> functions. You certainly don’t have to understand how all of it works to enjoy the project, though. In the next section you will load the code onto your Arduino.</p>
<h4 class="h4" id="lev81"><strong>Get the Code</strong></h4>
<p class="noindent">The full source code for the project is in the book’s resources at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em>. You’ll also find the library used to drive the RGB (red-green-blue) LED strip in the resources, which you’ll need to install into the Arduino IDE. Adafruit has an excellent guide on installing Arduino libraries at <em><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-installation">https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-installation</a></em>. After installation, your Arduino directory for this code should have this structure:</p>
<p class="programs">your_sketchbook<br/> |<br/> +--libraries<br/> |   |<br/> |   +--ffft<br/> |   |<br/> |   +--Adafruit_NeoPixel<br/> |<br/> +--RealtimeMusicVisualizer<br/>     |<br/>     +--RealtimeMusicVisualizer.h<br/>     +--RealtimeMusicVisualizer.ino</p>
<p class="indent">Now open the Arduino IDE and load the RealtimeMusicVisualizer sketch. Compile and upload it to your Arduino. It is usually a good idea to disconnect the Arduino from your new circuit before powering on the Arduino. After you’ve uploaded the code onto the Arduino, you can make the four wire connections to your circuit described earlier.</p>
<h3 class="h3" id="lev82"><strong>USE IT</strong></h3>
<p class="noindent">Using the music visualizer is as easy as making a few connections:</p>
<ol>
<li class="noindent"><p class="list">Connect the audio input jack to your music source with a 3.5 mm audio cable.</p></li>
<li class="noindent"><p class="list">Connect the audio output jack to your stereo receiver or some powered speakers.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_108"/>Connect your 5 V power supply to the power jack on the breadboard circuit. The power supply must be capable of supplying at least 2 A of current.</p></li>
<li class="noindent"><p class="list">Connect power to your Arduino board, either with a USB cable or other power adapter. Otherwise, you can provide power to the Arduino from the 5 V breadboard supply by connecting a wire to the 5 V pin on the Arduino.</p></li>
</ol>
<p class="indent">Now turn on the music and enjoy the show! You’ll want your music player to be at a fairly high volume, especially if it’s a small device like a phone or tablet. Computers tend to output a stronger signal. If the music is not producing much of a visualization, increase the sensitivity of the potentiometer on the breadboard by turning the knob clockwise until you can clearly see the beat of the music.</p>
<h3 class="h3" id="lev83"><strong>TAKE IT FURTHER</strong></h3>
<p class="noindent">If you’re experienced with Arduino programming, you’ll probably want to play with the code and make it do different things. Here are some ideas to explore:</p>
<ul>
<li class="noindent"><p class="list"><strong>Change the number of LEDs.</strong> If your LED strip has a different number of LEDs, you should adjust the code. For example, if you have a 3 m strip with 180 LEDs, change the line in the file <em>RealtimeMusicVisualizer.ino</em> that defines <span class="literal">N_LEDS</span> to the new value:</p>
<p class="programs"><span class="green">#define</span> N_LEDS 180</p></li>
<li class="noindent"><p class="list"><strong>Make the pixels move in one direction.</strong> Instead of having the moving pixels move from the center of the strip toward both ends, you can make them start from one end only. Set <span class="literal">SINGLE_DIRECTION</span> to <span class="literal">true</span> in <em>RealtimeMusicVisualizer.ino</em>:</p>
<p class="programs"><span class="green">#define</span> SINGLE_DIRECTION <span class="light-teal">true</span></p></li>
<li class="noindent"><p class="list"><strong>Make the code respond to more frequency bands.</strong> The code pays attention only to the bottom three frequency bands. By changing the value of <span class="literal">CUTOFF_BAND</span>, you can listen to more bands. The current value is <span class="literal">2</span> because the bottom three bands are numbered 0, 1, and 2. If you wanted to respond to the bottom five bands, you’d change the line to this:</p>
<p class="programs"><span class="green">#define</span> CUTOFF_BAND 4</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_109"/><strong>Change the brightness.</strong> Is the visualizer too bright for you? Maybe you aren’t throwing a huge party but just adding some bling to your dorm room. You can turn down the brightness by reducing the value of <span class="literal">MAX_BRIGHTNESS</span>. The default is <span class="literal">255</span>, so try a lower value like <span class="literal">100</span>:</p>
<p class="programs"><span class="green">#define</span> MAX_BRIGHTNESS 100</p></li>
<li class="noindent"><p class="list"><strong>Change the way the colors vary over time.</strong> The visualizer displays pixels of two colors that change over time. For each of these two colors, the speed at which the color changes over time is controlled by the values <span class="literal">MIN_COLOR_CHANGE_COUNT</span> and <span class="literal">MAX_COLOR_CHANGE_COUNT</span>. When a new color is chosen, a value between these min and max values is set, indicating how many pixels will be that color until a new color is chosen. The default min and max values are <span class="literal">5</span> and <span class="literal">10</span>. If you want the chosen colors to appear for longer before they change, increase these values. If you want every pixel to be a new color, you can set both values to <span class="literal">1</span>:</p>
<p class="programs"><span class="green">#define</span> MIN_COLOR_CHANGE_COUNT 1<br/><span class="green">#define</span> MAX_COLOR_CHANGE_COUNT 1</p></li>
<li class="noindent"><strong>Write your own visualization.</strong> If you have an idea for a whole new visualization, you can modify or rewrite the function <span class="literal">doVisualization()</span>. This function draws the moving pixels that are defined by the <span class="literal">peak_t</span> structures in the array <span class="literal">peaks</span>. If you study the code for a while, you will understand how it works. This project is based on a more complex visualizer that has many different visualizations: the Lumazoid board (a nootropic design product). You can get some ideas for different visualizations from the Lumazoid source code at <em><a href="https://github.com/nootropicdesign/lumazoid">https://github.com/nootropicdesign/lumazoid</a></em>.</li>
</ul>
<h3 class="h3" id="lev84"><strong>SUMMARY</strong></h3>
<p class="noindent">If you’ve built the circuit and got everything working, congratulations! You now have a very cool way to light up your music, and hopefully you learned some things along the way, too. If you read all the material in this chapter about how music is analyzed using digital signal processing and how to deal with audio signal voltages using simple electronics tricks, you already know more than most people about the true nature of audio signals.</p>
</div>
  </body>
</html>
