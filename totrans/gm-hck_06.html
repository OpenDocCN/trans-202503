<html><head></head><body>
<h2 class="h2c" id="ch04"><span epub:type="pagebreak" id="page_65"/><span class="big1"><strong>4</strong></span><br/><strong>FROM CODE TO MEMORY: A GENERAL PRIMER</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">At the lowest level, a game’s code, data, input, and output are complex abstractions of erratically changing bytes. Many of these bytes represent variables or machine code generated by a compiler that was fed the game’s source code. Some represent images, models, and sounds. Others exist only for an instant, posted by the computer’s hardware as input and destroyed when the game finishes processing them. The bytes that remain inform the player of the game’s internal state. But humans can’t think in bytes, so the computer must translate them in a way we can understand.</p>&#13;
<p class="indent">There’s a huge disconnect in the opposite direction as well. A computer doesn’t actually understand high-level code and visceral game content, so these must be translated from the abstract into bytes. Some content—such as images, sounds, and text—is stored losslessly, ready to be presented to the <span epub:type="pagebreak" id="page_66"/>player at a microsecond’s notice. A game’s code, logic, and variables, on the other hand, are stripped of all human readability and compiled down to machine data.</p>&#13;
<p class="indent">By manipulating a game’s data, game hackers obtain humanly improbable advantages within the game. To do this, however, they must understand how a developer’s code manifests once it has been compiled and executed. Essentially, they must think like computers.</p>&#13;
<p class="indent">To get you thinking like a computer, this chapter will begin by teaching you how numbers, text, simple structures, and unions are represented in memory at the byte level. Then you’ll dive deeper to explore how class instances are stored in memory and how abstract instances know which virtual functions to call at runtime. In the last half of the chapter, you’ll take an x86 assembly language crash course that covers syntax, registers, operands, the call stack, arithmetic operations, branching operations, function calls, and calling conventions.</p>&#13;
<p class="indent">This chapter focuses very heavily on general technical details. There isn’t a lot of juicy information that immediately relates to hacking games, but the knowledge you gain here will be central in the coming chapters, when we talk about topics like programmatically reading and writing memory, injecting code, and manipulating control flow.</p>&#13;
<p class="indent">Since C++ is the de facto standard for both game and bot development, this chapter explains the relationships between C++ code and the memory that represents it. Most native languages have very similar (sometimes identical) low-level structure and behavior, however, so you should be able to apply what you learn here to just about any piece of software.</p>&#13;
<p class="indent">All of the example code in this chapter is in the <em>GameHackingExamples/Chapter4_CodeToMemory</em> directory of this book’s source files. The included projects can be compiled with Visual Studio 2010 but should also work with any other C++ compiler. Download them at <em><a href="https://www.nostarch.com/gamehacking/">https://www.nostarch.com/gamehacking/</a></em> and compile them if you want to follow along.</p>&#13;
<h3 class="h3" id="ch00lev1sec69"><strong>How Variables and Other Data Manifest in Memory</strong></h3>&#13;
<p class="noindent">Properly manipulating a game’s state can be very hard, and finding the data that controls it is not always as easy as clicking Next Scan and hoping Cheat Engine won’t fail you. In fact, many hacks must manipulate dozens of related values at once. Finding these values and their relationships often requires you to analytically identify structures and patterns. Moreover, developing game hacks typically means re-creating the original structures within your bot’s code.</p>&#13;
<p class="indent">To do these things, you need an in-depth understanding of exactly how variables and data are laid out in the game’s memory. Through example code, OllyDbg memory dumps, and some tables to tie everything together, this section will teach you everything there is to know about how different types of data manifest in memory.</p>&#13;
<h4 class="h4" id="ch00lev1sec70"><span epub:type="pagebreak" id="page_67"/><strong><em>Numeric Data</em></strong></h4>&#13;
<p class="noindent">Most of the values game hackers need (like the player’s health, mana, location, and level) are represented by numeric data types. Because numeric data types are also a building block for all other data types, understanding them is extremely important. Luckily, they have relatively straightforward representations in memory: they are predictably aligned and have a fixed bit width. <a href="ch04.xhtml#ch4tab1">Table 4-1</a> shows the five main numeric data types you’ll find in Windows games, along with their sizes and ranges.</p>&#13;
<p class="tablecap"><a id="ch4tab1"/><strong>Table 4-1:</strong> Numeric Data Types</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Type name(s)</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Signed range</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Unsigned range</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">char</span>, <span class="literal">BYTE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">8 bits</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">-128 to 127</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0 to 255</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">short</span>, <span class="literal">WORD</span>, <span class="literal">wchar_t</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16 bits</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">-32,768 to -32,767</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0 to 65535</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">int</span>, <span class="literal">long</span>, <span class="literal">DWORD</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">32 bits</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">-2,147,483,648 to 2,147,483,647</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0 to 4,294,967,295</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">long long</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">64 bits</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0 to 18,446,744,073,709,551,615</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">float</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">32 bits</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">+/-1.17549*10<sup>-38</sup> to +/-3.40282*10<sup>38</sup></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">N/A</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The sizes of numeric data types can differ between architectures and even compilers. Since this book focuses on hacking x86 games on Windows, I’m using type names and sizes made standard by Microsoft. With the exception of <span class="literal">float</span>, the data types in <a href="ch04.xhtml#ch4tab1">Table 4-1</a> are stored with <em>little-endian ordering</em>, meaning the least significant bytes of an integer are stored in the lowest addresses occupied by that integer. For example, <a href="ch04.xhtml#ch4fig1">Figure 4-1</a> shows that <span class="literal">DWORD</span> 0x0A0B0C0D is represented by the bytes 0x0D 0x0C 0x0B 0x0A.</p>&#13;
<div class="image"><img src="../images/f04-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: Little-endian ordering diagram</em></p>&#13;
<p class="indent">The <span class="literal">float</span> data type can hold mixed numbers, so its representation in memory isn’t as simple as that of other data types. For example, if you see <span epub:type="pagebreak" id="page_68"/>0x0D 0x0C 0x0B 0x0A in memory and that value is a <span class="literal">float</span>, you can’t simply convert it to 0x0A0B0C0D. Instead, <span class="literal">float</span> values have three components: the <em>sign</em> (bit 0), <em>exponent</em> (bits 1–8), and <em>mantissa</em> (bits 9–31).</p>&#13;
<p class="indent">The sign determines whether the number is negative or positive, the exponent determines how many places to move the decimal point (starting before the mantissa), and the mantissa holds an approximation of the value. You can retrieve the stored value by evaluating the expression <em>mantissa</em> × 10<sup><em>n</em></sup> (where <em>n</em> is the exponent) and multiplying the result by –1 if the sign is set.</p>&#13;
<p class="indent">Now let’s look at some numeric data types in memory. <a href="ch04.xhtml#ch4exe1">Listing 4-1</a> initializes nine variables.</p>&#13;
<p class="programs">unsigned char ubyteValue = 0xFF;<br/>char byteValue = 0xFE;<br/>unsigned short uwordValue = 0x4142;<br/>short wordValue = 0x4344;<br/>unsigned int udwordValue = 0xDEADBEEF;<br/>int dwordValue = 0xDEADBEEF;<br/>unsigned long long ulongLongValue = 0xEFCDAB8967452301;<br/>long long longLongValue = 0xEFCDAB8967452301;<br/>float floatValue = 1337.7331;</p>&#13;
<p class="listt"><a id="ch4exe1"/><em>Listing 4-1: Creating variables of numeric data types in C++</em></p>&#13;
<p class="indent">Starting from the top, this example includes variables of types <span class="literal">char</span>, <span class="literal">short</span>, <span class="literal">int</span>, <span class="literal">long long</span>, and <span class="literal">float</span>. Four of these are unsigned, and five are signed. (In C++, a <span class="literal">float</span> can’t be unsigned.) Taking into account what you’ve learned so far, carefully study the relationship between the code in <a href="ch04.xhtml#ch4exe1">Listing 4-1</a> and the memory dump in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>. Assume that the variables are declared in global scope.</p>&#13;
<div class="image"><img src="../images/f04-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig2"/><em>Figure 4-2: OllyDbg memory dump of our numeric data</em></p>&#13;
<p class="indent">You might notice that some values seem arbitrarily spaced out. Since it’s much faster for processors to access values residing at addresses that are multiples of the address size (which is 32 bits in x86), compilers <em>pad</em> values with zeros in order to align them on such addresses—hence, padding is also called <em>alignment</em>. Single-byte values are not padded, since operations that access them perform the same regardless of alignment.</p>&#13;
<p class="indent">Keeping this in mind, take a look at <a href="ch04.xhtml#ch4tab2">Table 4-2</a>, which provides a sort of memory-to-code crosswalk between the memory dump in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> and the variables declared in <a href="ch04.xhtml#ch4exe1">Listing 4-1</a>.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_69"/><a id="ch4tab2"/><strong>Table 4-2:</strong> Memory-to-Code Crosswalk for <a href="ch04.xhtml#ch4exe1">Listing 4-1</a> and <a href="ch04.xhtml#ch4fig2">Figure 4-2</a></p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Object</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB3018</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">1 byte</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0xFF</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ubyteValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB3019</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1 byte</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xFE</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">byteValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB301A</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">2 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Padding before <span class="literal">uwordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB301C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x42 0x41</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">uwordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB301E</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">2 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Padding before <span class="literal">wordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB3020</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x44 0x43</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">wordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB3022</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">2 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Padding before <span class="literal">udwordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB3024</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xEF 0xBE 0xAD 0xDE</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">udwordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB3028</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0xEF 0xBE 0xAD 0xDE</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">dwordValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB302C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x76 0x37 0xA7 0x44</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">floatValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00BB3030</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">8 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ulongLongValue</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00BB3038</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">LongLongValue</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Address column lists locations in memory, and the Data column tells you exactly what’s stored there. The Object column tells you which variable from <a href="ch04.xhtml#ch4exe1">Listing 4-1</a> each piece of data relates to. Notice that <span class="literal">floatValue</span> is placed before <span class="literal">ulongLongValue</span> in memory, even though it’s the last variable declared in <a href="ch04.xhtml#ch4exe1">Listing 4-1</a>. Because these variables are declared in global scope, the compiler can place them wherever it wants. This particular move is likely a result of either alignment or optimization.</p>&#13;
<h4 class="h4" id="ch00lev1sec71"><strong><em>String Data</em></strong></h4>&#13;
<p class="noindent">Most developers use the term <em>string</em> as if it’s synonymous with <em>text</em>, but text is only the most common use for strings. At a low level, strings are just arrays of arbitrary numeric objects that appear linear and unaligned in memory. <a href="ch04.xhtml#ch4exe2">Listing 4-2</a> shows four text string declarations.</p>&#13;
<p class="programs">// char will be 1 byte per character<br/>char* thinStringP = "my_thin_terminated_value_pointer";<br/>char thinStringA[40] = "my_thin_terminated_value_array";<br/><br/><br/>// wchar_t will be 2 bytes per character<br/>wchar_t* wideStringP = L"my_wide_terminated_value_pointer";<br/>wchar_t wideStringA[40] = L"my_wide_terminated_value_array";</p>&#13;
<p class="listt"><a id="ch4exe2"/><em>Listing 4-2: Declaring several strings in C++</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>In the context of text, strings hold character objects (<span class="literal">char</span> for 8-bit encoding or <span class="literal">wchar_t</span> for 16-bit encoding), and the end of each string is specified by a <em>null terminator</em>, a character equal to 0x0. Let’s look at the memory where these variables are stored, as shown in the two memory dumps in <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>.</p>&#13;
<div class="image"><img src="../images/f04-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig3"/><em>Figure 4-3: In this OllyDbg memory dump of string data, the human-readable text in the ASCII column is the text we stored in <a href="ch04.xhtml#ch4exe2">Listing 4-2</a>.</em></p>&#13;
<p class="indent">If you’re not used to reading memory, the OllyDbg dump might be a bit difficult to follow at this point. <a href="ch04.xhtml#ch4tab3">Table 4-3</a> shows a deeper look at the correlation between the code in <a href="ch04.xhtml#ch4exe2">Listing 4-2</a> and the memory in <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>.</p>&#13;
<p class="tablecap"><a id="ch4tab3"/><strong>Table 4-3:</strong> Memory-to-Code Crosswalk for <a href="ch04.xhtml#ch4exe2">Listing 4-2</a> and <a href="ch04.xhtml#ch4fig3">Figure 4-3</a></p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Object</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" colspan="4" class="table_th"><p class="tablec">Pane 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x012420F8</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">32 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x6D 0x79 0x5F {...} 0x74 0x65 0x72</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">thinStringP</span> characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x01242118</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00 0x00 0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">thinStringP</span> terminator and padding</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x0124211C</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 0x00 0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Unrelated data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x01242120</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">64 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x6D 0x00 0x79 {...} 0x00 0x72 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">wideStringP</span> characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01242160</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 0x00 0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">wideStringP</span> terminator and padding</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_2"><p class="table">{...}</p></td>&#13;
<td style="vertical-align: top;" class="table_2"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_2"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_2"><p class="table">Unrelated data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" colspan="4" class="table_th"><p class="tablec">Pane 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01243040</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0xF8 0x20 0x24 0x01</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Pointer to <span class="literal">thinStringP</span> at <span class="literal">0x012420F8</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x01243044</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">30 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x6D 0x79 0x5F {...} 0x72 0x61 0x79</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">thinStringA</span> characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01243062</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">10 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00 repeated 10 times</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">thinStringA</span> terminator and array fill</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0124306C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20 0x21 0x24 0x01</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pointer to <span class="literal">wideStringP</span> at <span class="literal">0x01242120</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x01243070</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">60 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x6D 0x00 0x79 {...} 0x00 0x79 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">wideStringA</span> characters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x012430AC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">20 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00 repeated 10 times</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">wideStringA</span> terminator and array fill</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>In <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>, pane 1 shows that the values stored where <span class="literal">thinStringP</span> (address 0x01243040) and <span class="literal">wideStringP</span> (address 0x0124306C) belong in memory are only 4 bytes long and contain no string data. That’s because these variables are actually pointers to the first characters of their respective arrays. For example, <span class="literal">thinStringP</span> contains 0x012420F8, and in pane 2 in <a href="ch04.xhtml#ch4fig3">Figure 4-3</a>, you can see <span class="literal">"my_thin_terminated_value_pointer"</span> located at address 0x012420F8.</p>&#13;
<p class="indent">Look at the data between these pointers in pane 1, and you can see the text being stored by <span class="literal">thinStringA</span> and <span class="literal">wideStringA</span>. Furthermore, notice that <span class="literal">thinStringA</span> and <span class="literal">wideStringA</span> are padded beyond their null terminators; this is because these variables were declared as arrays with length <span class="literal">40</span>, so they are filled up to 40 characters.</p>&#13;
<h4 class="h4" id="ch00lev1sec72"><strong><em>Data Structures</em></strong></h4>&#13;
<p class="noindent">Unlike the data types we have previously discussed, <em>structures</em> are containers that hold multiple pieces of simple, related data. Game hackers who know how to identify structures in memory can mimic those structures in their own code. This can greatly reduce the number of addresses they must find, as they need to find only the address to the start of the structure, not the address of every individual item.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This section talks about structures as simple containers that lack member functions and contain only simple data. Objects that exceed these limitations will be discussed in “<a href="ch04.xhtml#ch00lev1sec76">Classes and VF Tables</a>” on <a href="ch04.xhtml#page_74">page 74</a>.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec73"><strong>Structure Element Order and Alignment</strong></h5>&#13;
<p class="noindent">Since structures simply represent an assortment of objects, they don’t visibly manifest in memory dumps. Instead, a memory dump of a structure shows the objects that are contained within that structure. The dump would look much like the others I’ve shown in this chapter, but with important differences in both order and alignment.</p>&#13;
<p class="indent">To see these differences, start by taking a look at <a href="ch04.xhtml#ch4exe3">Listing 4-3</a>.</p>&#13;
<p class="programs">struct MyStruct {<br/>    unsigned char ubyteValue;<br/>    char byteValue;<br/>    unsigned short uwordValue;<br/>    short wordValue;<br/>    unsigned int udwordValue;<br/>    int dwordValue;<br/>    unsigned long long ulongLongValue;<br/>    long long longLongValue;<br/>    float floatValue;<br/>};<br/>MyStruct&amp; m = 0;<br/>printf("Offsets: %d,%d,%d,%d,%d,%d,%d,%d,%d\n",<br/>        &amp;m-&gt;ubyteValue, &amp;m-&gt;byteValue,<br/>        &amp;m-&gt;uwordValue, &amp;m-&gt;wordValue,<br/>        &amp;m-&gt;udwordValue, &amp;m-&gt;dwordValue,<br/>        &amp;m-&gt;ulongLongValue, &amp;m-&gt;longLongValue,<br/>        &amp;m-&gt;floatValue);</p>&#13;
<p class="listt"><span epub:type="pagebreak" id="page_72"/><a id="ch4exe3"/><em>Listing 4-3: A C++ structure and some code that uses it</em></p>&#13;
<p class="indent">This code declares a structure named <span class="literal">MyStruct</span> and creates a variable named <span class="literal">m</span> that supposedly points to an instance of the structure at address 0. There’s not actually an instance of the structure at address 0, but this trick lets me use the ampersand operator (<span class="literal">&amp;</span>) in the <span class="literal">printf()</span> call to get the address of each member of the structure. Since the structure is located at address 0, the address printed for each member is equivalent to its offset from the start of the structure.</p>&#13;
<p class="indent">The ultimate purpose of this example is to see exactly how each member is laid out in memory, relative to the start of the structure. If you were to run the code, you’d see the following output:</p>&#13;
<p class="programs">Offsets: 0,1,2,4,8,12,16,24,32</p>&#13;
<p class="indent">As you can see, the variables in <span class="literal">MyStruct</span> are ordered exactly as they were defined in code. This sequential member layout is a mandatory property of structures. Compare this to the example from <a href="ch04.xhtml#ch4exe1">Listing 4-1</a>, when we declared an identical set of variables; in the memory dump from <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>, the compiler clearly placed some values out of order in memory.</p>&#13;
<p class="indent">Furthermore, you may have noticed that the members are not aligned like the globally scoped variables in <a href="ch04.xhtml#ch4exe1">Listing 4-1</a>; if they were, for example, there would be 2 padding bytes before <span class="literal">uwordValue</span>. This is because structure members are aligned on addresses divisible by either the <em>struct member alignment</em> (a compiler option that accepts 1, 2, 4, 8, or 16 bytes; in this example, it’s set to 4) or the size of the member—whichever is smaller. I arranged the members of <span class="literal">MyStruct</span> so that the compiler didn’t need to pad the values.</p>&#13;
<p class="indent">If, however, we put a <span class="literal">char</span> immediately after <span class="literal">ulongLongValue</span>, the <span class="literal">printf()</span> call would give the following output:</p>&#13;
<p class="programs">Offsets: 0,1,2,4,8,12,16,28,36</p>&#13;
<p class="indent">Now, take a look at the original and the modified outputs together:</p>&#13;
<p class="programs">Original: Offsets: 0,1,2,4,8,12,16,24,32<br/>Modified: Offsets: 0,1,2,4,8,12,16,28,36</p>&#13;
<p class="indent">In the modified version, the last two values, which are the offsets for <span class="literal">longLongValue</span> and <span class="literal">floatValue</span> from the start of the structure, have changed. Thanks to the struct member alignment, the variable <span class="literal">longLongValue</span> moves by 4 bytes (1 for the <span class="literal">char</span> value and 3 following it) to ensure it gets placed on an address divisible by 4.</p>&#13;
<h5 class="h5" id="ch00lev1sec74"><span epub:type="pagebreak" id="page_73"/><strong>How Structures Work</strong></h5>&#13;
<p class="noindent">Understanding structures—how they are aligned and how to mimic them—can be very useful. For instance, if you replicate a game’s structures in your own code, you can read or write those entire structures from memory in a single operation. Consider a game that declares the player’s current and max health like so:</p>&#13;
<p class="programs">struct {<br/>    int current;<br/>    int max;<br/>} vital;<br/>vital health;</p>&#13;
<p class="indent">If an inexperienced game hacker wants to read this information from memory, they might write something like this to fetch the health values:</p>&#13;
<p class="programs">int currentHealth = readIntegerFromMemory(currentHealthAddress);<br/>int maxHealth =  readIntegerFromMemory(maxHealthAddress);</p>&#13;
<p class="indent">This game hacker doesn’t realize that seeing these values right next to each other in memory could be more than a lucky happenstance, so they’ve used two separate variables. But if you came along with your knowledge of structures, you might conclude that, since these values are closely related and are adjacent in memory, our hacker could have used a structure instead:</p>&#13;
<p class="programs">   struct {<br/>       int current;<br/>       int max;<br/>   } _vital;<br/><span class="ent">➊</span> _vital health = readTypeFromMemory&lt;_vital&gt;(healthStructureAddress);</p>&#13;
<p class="indent">Since this code assumes a structure is being used and correctly mimics it, it can fetch both health and max health in just one line <span class="ent">➊</span>. We’ll dive deeper into how to write your own code to read memory from in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec75"><strong><em>Unions</em></strong></h4>&#13;
<p class="noindentb">Unlike structures, which encapsulate multiple pieces of related data, <em>unions</em> contain a single piece of data that is exposed through multiple variables. Unions follow three rules:</p>&#13;
<p class="bull">• The size of a union in memory is equal to that of its largest member.</p>&#13;
<p class="bull">• Members of a union all reference the same memory.</p>&#13;
<p class="bull">• A union inherits the alignment of its largest member.</p>&#13;
<p class="indentt">The <span class="literal">printf()</span> call in the following code helps illustrate the first two rules:</p>&#13;
<p class="programs">union {<br/>    BYTE byteValue;<br/>    struct {<br/>        WORD first;<br/>        WORD second;<br/>    } words;<br/>    DWORD value;<br/>} dwValue;<br/>dwValue.value = 0xDEADBEEF;<br/>printf("Size %d\nAddresses 0x%x,0x%x\nValues 0x%x,0x%x\n",<br/>    sizeof(dwValue), &amp;dwValue.value, &amp;dwValue.words,<br/>    dwValue.words.first, dwValue.words.second);</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>This call to <span class="literal">printf()</span> outputs the following:</p>&#13;
<p class="programs">Size 4<br/>Addresses 0x2efda8,0x2efda8 <br/>Values 0xbeef,0xdead</p>&#13;
<p class="indent">The first rule is illustrated by the <span class="literal">Size</span> value, which is printed first. Even though <span class="literal">dwValue</span> has three members that occupy a total of 9 bytes, it has a size of only 4 bytes. The size result validates the second rule as well, because <span class="literal">dwValue.value</span> and <span class="literal">dwValue.words</span> both point to address <span class="literal">0x2efda8</span>, as shown by the values printed after the word <span class="literal">Addresses</span>. The second rule is also validated by the fact that <span class="literal">dwValue.words.first</span> and <span class="literal">dwValue.words.second</span> contain <span class="literal">0xbeef</span> and <span class="literal">0xdead</span>, printed after <span class="literal">Values</span>, which makes sense considering that <span class="literal">dwValue.value</span> is <span class="literal">0xdeadbeef</span>. The third rule isn’t demonstrated in this example because we don’t have enough memory context, but if you were to put this union inside a structure and surround it with whatever types you like, it would in fact always align like a <span class="literal">DWORD</span>.</p>&#13;
<h4 class="h4" id="ch00lev1sec76"><strong><em>Classes and VF Tables</em></strong></h4>&#13;
<p class="noindent">Much like structures, <em>classes</em> are containers that hold and isolate multiple pieces of data, but classes can also contain function definitions.</p>&#13;
<h5 class="h5" id="ch00lev1sec77"><strong>A Simple Class</strong></h5>&#13;
<p class="noindent">Classes with normal functions, such as <span class="literal">bar</span> in <a href="ch04.xhtml#ch4exe4">Listing 4-4</a>, conform to the same memory layouts as structures.</p>&#13;
<p class="programs">class bar {<br/>public:<br/>    bar() : bar1(0x898989), bar2(0x10203040) {}<br/>    void myfunction() { bar1++; }<br/>    int bar1, bar2;<br/>};<br/><br/>bar _bar = bar();<br/>printf("Size %d; Address 0x%x : _bar\n", sizeof(_bar), &amp;_bar);</p>&#13;
<p class="listt"><a id="ch4exe4"/><em>Listing 4-4: A C++ class</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>The <span class="literal">printf()</span> call in <a href="ch04.xhtml#ch4exe4">Listing 4-4</a> would output the following:</p>&#13;
<p class="programs">Size 8; Address 0x2efd80 : _bar</p>&#13;
<p class="indent">Even though <span class="literal">bar</span> has two member functions, this output shows that it spans only the 8 bytes needed to hold <span class="literal">bar1</span> and <span class="literal">bar2</span>. This is because the <span class="literal">bar</span> class doesn’t include abstractions of those member functions, so the program can call them directly.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Access levels such as <span class="literal">public</span>, <span class="literal">private</span>, and <span class="literal">protected</span> do not manifest in memory. Regardless of these modifiers, members of classes are still ordered as they are defined.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec78"><strong>A Class with Virtual Functions</strong></h5>&#13;
<p class="noindent">In classes that do include abstract functions (often called <em>virtual</em> functions), the program must know which function to call. Consider the class definitions in <a href="ch04.xhtml#ch4exe5">Listing 4-5</a>:</p>&#13;
<p class="programs">class foo {<br/>public:<br/>foo() : myValue1(0xDEADBEEF), myValue2(0xBABABABA) {}<br/>    int myValue1;<br/>    static int myStaticValue;<br/>    virtual void bar() { printf("call foo::bar()\n"); }<br/>    virtual void baz() { printf("call foo::baz()\n"); }<br/>    virtual void barbaz() {}<br/>    int myValue2;<br/>};<br/><br/>int foo::myStaticValue = 0x12121212;<br/><br/>class fooa : public foo {<br/>public:<br/>    fooa() : foo() {}<br/>    virtual void bar() { printf("call fooa::bar()\n"); }<br/>    virtual void baz() { printf("call fooa::baz()\n"); }<br/>};<br/><br/>class foob : public foo {<br/>public:<br/>    foob() : foo() {}<br/>    virtual void bar() { printf("call foob::bar()\n"); }<br/>    virtual void baz() { printf("call foob::baz()\n"); }<br/>};</p>&#13;
<p class="listt"><a id="ch4exe5"/><em>Listing 4-5: The foo, fooa, and foob classes</em></p>&#13;
<p class="indent">The class <span class="literal">foo</span> has three virtual functions: <span class="literal">bar</span>, <span class="literal">baz</span>, and <span class="literal">barbaz</span>. Classes <span class="literal">fooa</span> and <span class="literal">foob</span> inherit from class <span class="literal">foo</span> and overload both <span class="literal">bar</span> and <span class="literal">baz</span>. Since <span class="literal">fooa</span> <span epub:type="pagebreak" id="page_76"/>and <span class="literal">foob</span> have a public base class of <span class="literal">foo</span>, a <span class="literal">foo</span> pointer can point to them, but the program must still call the correct versions of <span class="literal">bar</span> and <span class="literal">baz</span>. You can see this by executing the following code:</p>&#13;
<p class="programs">foo* _testfoo = (foo*)new fooa();<br/>_testfoo-&gt;bar(); // calls fooa::bar()</p>&#13;
<p class="indent">And here is the output:</p>&#13;
<p class="programs">call fooa::bar()</p>&#13;
<p class="indent">The output shows that <span class="literal">_testfoo-&gt;bar()</span> invoked <span class="literal">fooa::bar()</span> even though <span class="literal">_testfoo</span> is a <span class="literal">foo</span> pointer. The program knew which version of the function to call, because the compiler included a <em>VF (virtual function) table</em> in the memory of <span class="literal">_testfoo</span>. VF tables are arrays of function addresses that abstract class instances use to tell a program where their overloaded functions are located.</p>&#13;
<h5 class="h5" id="ch00lev1sec79"><strong>Class Instances and Virtual Function Tables</strong></h5>&#13;
<p class="noindent">To understand the relationship between class instances and VF tables, let’s inspect a memory dump of the three objects declared in this listing:</p>&#13;
<p class="programs">foo _foo = foo();<br/>fooa _fooa = fooa();<br/>foob _foob = foob();</p>&#13;
<p class="indent">These objects are of the types defined in <a href="ch04.xhtml#ch4exe5">Listing 4-5</a>. You can see them in memory in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a>.</p>&#13;
<div class="image"><img src="../images/f04-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig4"/><em>Figure 4-4: OllyDbg memory dump of class data</em></p>&#13;
<p class="indent">Pane 1 shows that each class instance stores its members just like a structure, but it precedes them with a <span class="literal">DWORD</span> value that points to the class instance’s VF table. Pane 2 shows the VF tables for each of our three class instances. The memory-to-code crosswalk in <a href="ch04.xhtml#ch4tab4">Table 4-4</a> shows how these panes and the code tie together.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_77"/><a id="ch4tab4"/><strong>Table 4-4:</strong> Memory-to-Code Crosswalk for <a href="ch04.xhtml#ch4exe5">Listing 4-5</a> and <a href="ch04.xhtml#ch4fig4">Figure 4-4</a></p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Object</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" colspan="4" class="table_th"><p class="tablec">Pane 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x0018FF20</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022B0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">_foo</span> and pointer to <span class="literal">foo</span> VF table</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0018FF24</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF 0xBABABABA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">_foo.myValue1</span> and <span class="literal">_foo.myValue2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x0018FF2C</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022C0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">_fooa</span> and pointer to <span class="literal">fooa</span> VF table</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0018FF30</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF 0xBABABABA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">_fooa.myValue1</span> and <span class="literal">_fooa.myValue2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x0018FF38</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022D0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">_foob</span> and pointer to <span class="literal">foob</span> VF table</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0018FF3C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF 0xBABABABA</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">_foob.myValue1</span> and <span class="literal">_foob.myValue2</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_2a"><p class="table">{...}</p></td>&#13;
<td style="vertical-align: top;" class="table_2a"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_2a"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_2a"><p class="table">Unrelated data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" colspan="4" class="table_th"><p class="tablec">Pane 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022B0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00401060</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">foo</span> VF table; address of <span class="literal">foo::bar</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004022B4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00401080</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Address of <span class="literal">foo::baz</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022B8</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004010A0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Address of <span class="literal">foo::barbaz</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004022BC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0040243C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unrelated data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022C0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004010D0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">fooa</span> VF table; address of <span class="literal">fooa::bar</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004022C4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004010F0</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Address of <span class="literal">fooa::baz</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022C8</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004010A0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Address of <span class="literal">foo::barbaz</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004022CC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004023F0</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unrelated data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022D0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x00401130</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Start of <span class="literal">foob</span> VF table; address of <span class="literal">foob::bar</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x004022D4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00401150</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Address of <span class="literal">foob::baz</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004022D8</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4 bytes</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x004010A0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Address of <span class="literal">foo::barbaz</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This crosswalk shows how the VF tables for the code in <a href="ch04.xhtml#ch4exe5">Listing 4-5</a> are laid out in memory. Each VF table is generated by the compiler when the binary is made, and the tables remain constant. To save space, instances of the same class all point to the same VF table, which is why the VF tables aren’t placed inline with the class.</p>&#13;
<p class="indent">Since we have three VF tables, you might wonder how a class instance knows which VF table to use. The compiler places code similar to the following bit of assembly in each virtual class constructor:</p>&#13;
<p class="programs">MOV DWORD PTR DS:[EAX], VFADDR</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>This example takes the static address of a VF table (<span class="literal">VFADDR</span>) and places it in memory as the first member of the class.</p>&#13;
<p class="indent">Now look at addresses 0x004022B0, 0x004022C0, and 0x004022D0 in <a href="ch04.xhtml#ch4tab4">Table 4-4</a>. These addresses contain the beginning of the <span class="literal">foo</span>, <span class="literal">fooa</span>, and <span class="literal">foob</span> VF tables. Notice that <span class="literal">foo::barbaz</span> exists in all three VF tables; this is because the function is not overloaded by either subclass, meaning instances of each subclass will call the original implementation directly.</p>&#13;
<p class="indent">Notice, too, that <span class="literal">foo::myStaticValue</span> does not appear in this crosswalk. Since the value is static, it doesn’t actually need to exist as a part of the <span class="literal">foo</span> class; it’s placed inside this class only for better code organization. In reality, it gets treated like a global variable and is placed elsewhere.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>VF TABLES AND CHEAT ENGINE</strong></p>&#13;
<p class="noindent">Remember Cheat Engine’s First element of pointerstruct must point to module option for pointer scans from <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> on <a href="ch01.xhtml#page_14">page 14</a>? Now that you’ve read a bit about VF tables, that knowledge should help you understand how this option works: it makes Cheat Engine ignore all heap chunks where the first member is not a pointer to a valid VF table. It speeds up scans, but it works only if every step in a pointer path is part of an abstract class instance.</p>&#13;
</div>&#13;
<p class="indent">The memory tour ends here, but if you have trouble identifying a chunk of data in the future, come back to this section for reference. Next, we’ll look at how a computer can understand a game’s high-level source code in the first place.</p>&#13;
<h3 class="h3" id="ch00lev1sec80"><strong>x86 Assembly Crash Course</strong></h3>&#13;
<p class="noindent">When a program’s source code is compiled into a binary, it is stripped of all unnecessary artifacts and translated into <em>machine code</em>. This machine code, made up of only bytes (command bytes are called <em>opcodes</em>, but there are also bytes representing operands), gets fed directly to the processor and tells it exactly how to behave. Those 1s and 0s flip transistors to control computation, and they can be extremely difficult to understand. To make computers a little easier to talk to, engineers working with such code use <em>assembly language</em>, a shorthand that represents raw machine opcodes with abbreviated names (called mnemonics) and a simplistic syntax.</p>&#13;
<p class="indent">Assembly language is important for game hackers to know because many powerful hacks can be achieved only through direct manipulation of a game’s assembly code, via methods such as NOPing or hooking. In this section, you’ll learn the basics of <em>x86 assembly language</em>, a specific flavor of <span epub:type="pagebreak" id="page_79"/>assembly made for speaking to 32-bit processors. Assembly language is very extensive, so for the sake of brevity this section talks only about the small subset of assembly concepts that are most useful to game hackers.<sup><a id="ch00fn_01"/><a href="footnote.xhtml#ch00fn01">1</a></sup></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Throughout this section, many small snippets of assembly code include comments set off by a semicolon (<span class="literal">;</span>) to describe each instruction in greater detail.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec81"><strong><em>Command Syntax</em></strong></h4>&#13;
<p class="noindent">Assembly language is used to describe machine code, so its syntax is pretty simplistic. While this syntax makes it very easy for someone to understand individual commands (also called <em>operations</em>), it also makes understanding complex blocks of code very hard. Even algorithms that are easily readable in high-level code seem obfuscated when written in assembly. For example, the following snippet of pseudocode:</p>&#13;
<p class="programs">if (EBX &gt; EAX)<br/>    ECX = EDX<br/>else<br/>    ECX = 0</p>&#13;
<p class="noindent">would look like <a href="ch04.xhtml#ch4exe6">Listing 4-6</a> in x86 assembly.</p>&#13;
<p class="programs">    CMP EBX, EAX<br/>    JG label1<br/>    MOV ECX, 0<br/>    JMP label2<br/>label1:<br/>    MOV ECX, EDX<br/>label2:</p>&#13;
<p class="listt"><a id="ch4exe6"/><em>Listing 4-6: Some x86 assembly commands</em></p>&#13;
<p class="indent">Therefore, it takes extensive practice to understand even the most trivial functions in assembly. Understanding individual commands, however, is very simple, and by the end of this section, you’ll know how to parse the commands I just showed you.</p>&#13;
<h5 class="h5" id="ch00lev1sec82"><strong>Instructions</strong></h5>&#13;
<p class="noindent">The first part of an assembly command is called an <em>instruction</em>. If you equate an assembly command to a terminal command, the instruction is the program to run. At the machine code level, instructions are typically the first byte of a command;<sup><a id="ch00fn_02"/><a href="footnote.xhtml#ch00fn02">2</a></sup> there are also some 2-byte instructions, where the first byte is 0x0F. Regardless, an instruction tells the processor exactly what to do. In <a href="ch04.xhtml#ch4exe6">Listing 4-6</a>, <span class="literal">CMP</span>, <span class="literal">JG</span>, <span class="literal">MOV</span>, and <span class="literal">JMP</span> are all instructions.</p>&#13;
<h5 class="h5" id="ch00lev1sec83"><span epub:type="pagebreak" id="page_80"/><strong>Operand Syntax</strong></h5>&#13;
<p class="noindent">While some instructions are complete commands, the vast majority are incomplete unless followed by <em>operands</em>, or parameters. Every command in <a href="ch04.xhtml#ch4exe6">Listing 4-6</a> has at least one operand, like <span class="literal">EBX</span>, <span class="literal">EAX</span>, and <span class="literal">label1</span>.</p>&#13;
<p class="indentb">Assembly operands come in three forms:</p>&#13;
<p class="noindenth"><strong>Immediate value</strong> An integer value that is declared inline (hexadecimal values have a trailing <span class="literal">h</span>).</p>&#13;
<p class="noindenth"><strong>Register</strong> A name that refers to a processor register.</p>&#13;
<p class="noindenth"><strong>Memory offset</strong> An expression, placed in brackets, that represents the memory location of a value. The expression can be an immediate value or a register. Alternatively, it can be either the sum or difference of a register and immediate value (something like <span class="literal">[REG+Ah]</span> or <span class="literal">[REG-10h]</span>).</p>&#13;
<p class="indentt">Each instruction in x86 assembly can have between zero and three operands, and commas are used to separate multiple operands. In most cases, instructions that require two operands have a <em>source operand</em> and a <em>destination operand</em>. The ordering of these operands is dependent on the assembly syntax. For example, <a href="ch04.xhtml#ch4exe7">Listing 4-7</a> shows a group of pseudocommands written in the Intel syntax, which is used by Windows (and, thus, by Windows game hackers):</p>&#13;
<p class="programs">   MOV R1, 1          ; set R1 (register) to 1 (immediate)<br/><span class="ent">➊</span> MOV R1, [BADF00Dh] ; set R1 to value at [BADFOODh] (memory offset)<br/>   MOV R1, [R2+10h]   ; set R1 to value at [R2+10h] (memory offset)<br/>   MOV R1, [R2-20h]   ; set R1 to value at [R2+20h] (memory offset)</p>&#13;
<p class="listt"><a id="ch4exe7"/><em>Listing 4-7: Demonstrating Intel syntax</em></p>&#13;
<p class="indent">In the Intel syntax, the destination operand comes first, followed by the source, so at <span class="ent">➊</span>, <span class="literal">R1</span> is the destination and <span class="literal">[BADFOODh]</span> is the source. On the other hand, compilers like GCC (which can be used to write bots on Windows) use a syntax known as AT&amp;T, or UNIX, syntax. This syntax does things a little differently, as you can see in the following example:</p>&#13;
<p class="programs">MOV $1, %R1         ; set R1 (register) to 1 (immediate)<br/>MOV 0xBADF00D, %R1  ; set R1 to value at 0xBADFOOD (memory offset)<br/>MOV 0x10(%R2), %R1  ; set R1 to value at 0x10(%R2) (memory offset)<br/>MOV -0x20(%R2), %R1 ; set R1 to value at -0x20(%R2) (memory offset)</p>&#13;
<p class="indent">This code is the AT&amp;T version of <a href="ch04.xhtml#ch4exe7">Listing 4-7</a>. AT&amp;T syntax not only reverses the operand order but also requires operand prefixing and has a different format for memory offset operands.</p>&#13;
<h5 class="h5" id="ch00lev1sec84"><strong>Assembly Commands</strong></h5>&#13;
<p class="noindent">Once you understand assembly instructions and how to format their operands, you can start writing commands. The following code shows an assembly function, consisting of some very basic commands, that essentially does nothing.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_81"/><br/>PUSH EBP     ; put EBP (register) on the stack<br/>MOV EBP, ESP ; set EBP to value of ESP (register, top of stack)<br/>PUSH -1      ; put -1 (immediate) on the stack<br/>ADD ESP, 4   ; negate the 'PUSH -1' to put ESP back where it was (a PUSH<br/>                 ; subtracts 4 from ESP, since it grows the stack)<br/>MOV ESP, EBP ; set ESP to the value of EBP (they will be the same anyway,<br/>                 ; since we have kept ESP in the same place)<br/>POP EBP      ; set EBP to the value on top of the stack (it will be what<br/>                 ; EBP started with, put on the stack by PUSH EBP)<br/>XOR EAX, EAX ; exclusive-or EAX (register) with itself (same effect as<br/>                 ; 'MOV EAX, 0' but much faster)<br/>RETN         ; return from the function with a value of 0 (EAX typically<br/>                 ; holds the return value)</p>&#13;
<p class="indent">The first two lines, a <span class="literal">PUSH</span> command and a <span class="literal">MOV</span> command, set up a stack frame. The next line pushes –1 to the stack, which is undone when the stack is set back to its original position by the <span class="literal">ADD ESP, 4</span> command. Following that, the stack frame is removed, the return value (stored in <span class="literal">EAX</span>) is set to <span class="literal">0</span> with an <span class="literal">XOR</span> instruction, and the function returns.</p>&#13;
<p class="indent">You’ll learn more about stack frames and functions in “<a href="ch04.xhtml#ch00lev1sec91">The Call Stack</a>” on <a href="ch04.xhtml#page_86">page 86</a> and “<a href="ch04.xhtml#ch00lev1sec98">Function Calls</a>” on <a href="ch04.xhtml#page_94">page 94</a>. For now, turn your attention to the constants in the code—namely <span class="literal">EBP</span>, <span class="literal">ESP</span>, and <span class="literal">EAX</span>, which are used frequently in the code as operands. These values, among others, are called <em>processor registers</em>, and understanding them is essential to understanding the stack, function calls, and other low-level aspects of assembly code.</p>&#13;
<h4 class="h4" id="ch00lev1sec85"><strong><em>Processor Registers</em></strong></h4>&#13;
<p class="noindent">Unlike high-level programming languages, assembly language does not have user-defined variable names. Instead, it accesses data by referencing its memory address. During intensive computation, however, it can be extremely costly for the processor to constantly deal with the overhead of reading and writing data to RAM. To mitigate this high cost, x86 processors provide a small set of temporary variables, called processor registers, which are small storage spaces within the processor itself. Since accessing these registers requires far less overhead than accessing RAM, assembly uses them to describe its internal state, pass volatile data around, and store context-sensitive variables.</p>&#13;
<h5 class="h5" id="ch00lev1sec86"><strong>General Registers</strong></h5>&#13;
<p class="noindentb">When assembly code needs to store or operate on arbitrary data, it uses a subset of process registers called <em>general registers</em>. These registers are used exclusively to store process-specific data, such as a function’s local variables. Each general register is 32 bits and thus can be thought of as a <span class="literal">DWORD</span> variable. General registers are also optimized for specific purposes:</p>&#13;
<p class="noindenth"><strong>EAX, the accumulator</strong> This register is optimized for mathematical computations. Some operations, such as multiplication and division, can only occur in EAX.</p>&#13;
<p class="noindenth"><span epub:type="pagebreak" id="page_82"/><strong>EBX, the base register</strong> This register is used arbitrarily for extra storage. Since its 16-bit predecessor, BX, was the only register that operations could use to reference memory addresses, EBX was used as a reference to RAM. In x86 assembly, however, all registers can be address references, leaving EBX without a true purpose.</p>&#13;
<p class="noindenth"><strong>ECX, the counter</strong> This register is optimized to act as the counter variable (often called <span class="literal">i</span> in high-level code) in a loop.</p>&#13;
<p class="noindenth"><strong>EDX, the data register</strong> This register is optimized to act as a helper to EAX. In 64-bit computations, for instance, EAX acts as bits 0–31 and EDX acts as bits 32–63.</p>&#13;
<p class="indentt">These registers also have a set of 8- and 16-bit subregisters that you can use to access partial data. Think of every general register as a union, where a register name describes the 32-bit member and the subregisters are alternate members that allow access to smaller pieces of the register. The following code shows what this union might look like for EAX:</p>&#13;
<p class="programs">union {<br/>    DWORD EAX;<br/>    WORD AX;<br/>    struct {<br/>        BYTE L;<br/>        BYTE H;<br/>    } A;<br/>} EAX;</p>&#13;
<p class="indent">In this example, <span class="literal">AX</span> allows access to the lower <span class="literal">WORD</span> of <span class="literal">EAX</span>, while <span class="literal">AL</span> allows access to the lower <span class="literal">BYTE</span> of <span class="literal">AX</span> and <span class="literal">AH</span> to its higher <span class="literal">BYTE</span>. Every general register has this structure, and I outline the other registers’ subregisters in <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>.</p>&#13;
<div class="image"><img src="../images/f04-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig5"/><em>Figure 4-5: x86 registers and subregisters</em></p>&#13;
<p class="indent">EAX, EBC, ECX, and EDX have higher words, too, but the compiler will almost never access them on its own, as it can just use the lower word when it needs word-only storage.</p>&#13;
<h5 class="h5" id="ch00lev1sec87"><span epub:type="pagebreak" id="page_83"/><strong>Index Registers</strong></h5>&#13;
<p class="noindentb">x86 assembly also has four <em>index registers</em>, which are used to access data streams, reference the call stack, and keep track of local information. Like the general registers, index registers are 32 bits, but index registers have more strictly defined purposes:</p>&#13;
<p class="noindenth"><strong>EDI, the destination index</strong> This register is used to index memory targeted by write operations. If there are no write operations in a piece of code, the compiler can use EDI for arbitrary storage if needed.</p>&#13;
<p class="noindenth"><strong>ESI, the source index</strong> This register is used to index memory targeted by read operations. It can also be used arbitrarily.</p>&#13;
<p class="noindenth"><strong>ESP, the stack pointer</strong> This register is used to reference the top of the call stack. All stack operations directly access this register. You must use ESP only when working with the stack, and it must always point to the top of the stack.</p>&#13;
<p class="noindenth"><strong>EBP, the stack base pointer</strong> This register marks the bottom of the stack frame. Functions use it as a reference to their parameters and local variables. Some code may be compiled with an option to omit this behavior, in which case EBP can be used arbitrarily.</p>&#13;
<p class="indentt">Like the general registers, each index register has a 16-bit counterpart: DI, SI, SP, and BP, respectively. However, the index registers have no 8-bit subregisters.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>WHY DO SOME X86 REGISTERS HAVE SUBREGISTERS?</strong></p>&#13;
<p class="noindent">There is a historical reason why both general and index registers have 16-bit counterparts. The x86 architecture was based on a 16-bit architecture, from which it <em>extended</em> the registers AX, BX, CX, DX, DI, SI, SP, and BP. Appropriately, the extensions retain the same names but are prefixed with an <em>E</em>, for “extended.” The 16-bit versions remain for backward compatibility. This also explains why index registers have no 8-bit abstractions: they are intended to be used as memory-address offsets, and there is no practical need to know partial bytes of such values.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec88"><strong>The Execution Index Register</strong></h5>&#13;
<p class="noindent">The Execution Index register, referred to as <em>EIP</em>, has a very concrete purpose: it points to the address of the code currently being executed by the processor. Because it controls the flow of execution, it is directly incremented by the processor and is off-limits to assembly code. To modify EIP, assembly code must indirectly access it using operations such as <span class="literal">CALL</span>, <span class="literal">JMP</span>, and <span class="literal">RETN</span>.</p>&#13;
<h5 class="h5" id="ch00lev1sec89"><span epub:type="pagebreak" id="page_84"/><strong>The EFLAGS Register</strong></h5>&#13;
<p class="noindent">Unlike high-level code, assembly language doesn’t have binary comparison operators like <span class="literal">==</span>, <span class="literal">&gt;</span>, and <span class="literal">&lt;</span>. Instead, it uses the <span class="literal">CMP</span> command to compare two values, storing the resulting information in the EFLAGS register. Then, the code changes its control flow using special operations that depend on the value stored in ELFAGS.</p>&#13;
<p class="indent">While comparison commands are the only user-mode operations that can access EFLAGS, they use only this register’s <em>status</em> bits: 0, 2, 4, 6, 7, and 11. Bits 8–10 act as control flags, bits 12–14 and 16–21 act as system flags, and the remaining bits are reserved for the processor. <a href="ch04.xhtml#ch4tab5">Table 4-5</a> shows the type, name, and description of each EFLAGS bit.</p>&#13;
<p class="tablecap"><a id="ch4tab5"/><strong>Table 4-5:</strong> EFLAGS bits</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Bit(s)</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Carry</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Set if a carry or borrow was generated from the most significant bit during the previous instruction.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Parity</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Set if the least significant byte resulting from the previous instruction has an even number of bits set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">4</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Adjust</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Same as the carry flag, but considers the 4 least significant bits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">6</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Zero</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Set if the resulting value from the previous instruction is equal to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">7</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Sign</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Set if the resulting value from the previous instruction has its sign bit (most significant bit) set.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Control</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Trap</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">When set, the processor sends an interrupt to the operating system kernel after executing the next operation.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">9</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Control</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Interrupt</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">When not set, the system ignores maskable interrupts.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">10</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Control</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Direction</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">When set, ESI and EDI are decremented by operations that automatically modify them. When not set, they are incremented.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">11</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Status</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Overflow</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Set when a value is overflowed by the previous instruction, such as when ADD is performed on a positive value and the result is a negative value.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The EFLAGS register also contains a system bit and a reserved bit, but those are irrelevant in user-mode assembly and game hacking, so I’ve omitted them from this table. Keep EFLAGS in mind when you’re debugging game code to figure out how it works. For example, if you set a breakpoint on a JE (jump if equal) instruction, you can look at the EFLAGS 0 bit to see whether the jump will be taken.</p>&#13;
<h5 class="h5" id="ch00lev1sec90"><strong>Segment Registers</strong></h5>&#13;
<p class="noindentb">Finally, assembly language has a set of 16-bit registers called <em>segment registers</em>. Unlike other registers, segment registers are not used to store data; they are used to locate it. In theory, they point to isolated segments of memory, <span epub:type="pagebreak" id="page_85"/>allowing different types of data to be stored in completely separate memory segments. The implementation of such segmentation is left up to the operating system. These are the x86 segment registers and their intended purposes:</p>&#13;
<p class="noindenth"><strong>CS, the code segment</strong> This register points to the memory that holds an application’s code.</p>&#13;
<p class="noindenth"><strong>DS, the data segment</strong> This register points to the memory that holds an application’s data.</p>&#13;
<p class="noindenth"><strong>ES, FS, and GS, the extra segments</strong> These registers point to any proprietary memory segments used by the operating system.</p>&#13;
<p class="noindenth"><strong>SS, the stack segment</strong> This register points to memory that acts as a dedicated call stack.</p>&#13;
<p class="indentt">In assembly code, segment registers are used as prefixes to memory offset operands. When a segment register isn’t specified, DS is used by default. This means that the command <span class="literal">PUSH [EBP]</span> is effectively the same as <span class="literal">PUSH DS:[EBP]</span>. But the command <span class="literal">PUSH FS:[EBP]</span> is different: it reads memory from the FS segment, not the DS segment.</p>&#13;
<p class="indent">If you look closely at the Windows x86 implementation of memory segmentation, you might notice that these segment registers were not exactly used as intended. To see this in action, you can run the following commands with the OllyDbg command line plug-in while OllyDbg is attached to a paused process:</p>&#13;
<p class="programs">? <span class="codestrong">CALC (DS==SS &amp;&amp; SS==GS &amp;&amp; GS==ES)</span><br/>? 1<br/>? <span class="codestrong">CALC DS-CS</span><br/>? 8<br/>? <span class="codestrong">CALC FS-DS</span><br/>; returns nonzero (and changes between threads)</p>&#13;
<p class="indent">This output tells us three distinct things. First, it shows that there are only three segments being used by Windows: FS, CS, and everything else. This is demonstrated by DS, SS, GS, and ES being equal. For the same reason, this output shows that DS, SS, GS, and ES can all be used interchangeably, as they all point to the same memory segments. Lastly, since FS changes depending on the thread, this output shows that it is thread dependent. FS is an interesting segment register, and it points to certain thread-specific data. In “<a href="ch06.xhtml#ch00lev1sec132">Bypassing ASLR in Production</a>” on <a href="ch06.xhtml#page_128">page 128</a>, we’ll explore how the data in FS can be used to bypass ASLR—something most bots will need to do.</p>&#13;
<p class="indent">In fact, in assembly code generated for Windows by a compiler, you’d only ever see three segments used: DS, FS, and SS. Interestingly enough, even though CS seems to show a constant offset from DS, it has no real purpose in user-mode code. Knowing all of these things, you can further conclude that there are only two segments being used by Windows: FS and everything else.</p>&#13;
<p class="indent">These two segments actually point to different locations in the same memory (there’s no simple way to verify this, but it is true), which shows <span epub:type="pagebreak" id="page_86"/>that Windows actually doesn’t use memory segments at all. Instead, it uses a flat memory model in which segment registers are nearly irrelevant. While all segment registers point to the same memory, only FS and CS point to different locations, and CS is not used.</p>&#13;
<p class="indent">In conclusion, there are only three things you need to know about segment registers when working with x86 assembly in Windows. First, DS, SS, GS, and ES are interchangeable, but for clarity DS should be used to access data and SS should be used to access the call stack. Second, CS can be safely forgotten. Third, FS is the only segment register with a special purpose; it should be left alone for now.</p>&#13;
<h4 class="h4" id="ch00lev1sec91"><strong><em>The Call Stack</em></strong></h4>&#13;
<p class="noindent">Registers are powerful, but unfortunately they come in very limited supply. In order for assembly code to effectively store all of its local data, it must also use the <em>call stack</em>. The stack is used to store many different values, including function parameters, return addresses, and some local variables.</p>&#13;
<p class="indent">Understanding the ins and outs of the call stack will come in handy when you’re reverse engineering a game. Moreover, you’ll rely on this knowledge heavily when we jump into control flow manipulation in <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>&#13;
<h5 class="h5" id="ch00lev1sec92"><strong>Structure</strong></h5>&#13;
<p class="noindent">You can think of the call stack as a <em>FILO (first-in-last-out)</em> list of <span class="literal">DWORD</span> values that can be directly accessed and manipulated by assembly code. The term <em>stack</em> is used because the structure resembles a stack of paper: objects are both added to and removed from the top. Data is added to the stack through the <span class="literal">PUSH <span class="codeitalic">operand</span></span> command, and it is removed (and placed in a register) through the <span class="literal">POP <span class="codeitalic">register</span></span> command. <a href="ch04.xhtml#ch4fig6">Figure 4-6</a> shows how this process might look.</p>&#13;
<div class="image"><img src="../images/f04-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig6"/><em>Figure 4-6: The structure of a stack</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>In Windows, the stack grows from higher memory addresses to lower ones. It occupies a finite block of memory, piling up to address 0x00000000 (the absolute top) from address <em>n</em> (the absolute bottom). This means that ESP (the pointer to the top of the stack) decreases as items are added and increases as items are removed.</p>&#13;
<h5 class="h5" id="ch00lev1sec93"><strong>The Stack Frame</strong></h5>&#13;
<p class="noindent">When an assembly function uses the stack to store data, it references the data by creating a <em>stack frame</em>. It does so by storing ESP in EBP and then subtracting <em>n</em> bytes from ESP, effectively opening an <em>n</em>-byte gap that is <em>framed</em> between the registers EBP and ESP. To better understand this, first imagine that the stack in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a> is passed to a function that requires 0x0C bytes of local storage space.</p>&#13;
<div class="image"><img src="../images/f04-07.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig7"/><em>Figure 4-7: Initial example stack (read from bottom to top)</em></p>&#13;
<p class="indent">In this example, address 0x0000 is the absolute top of the stack. We have unused memory from addresses 0x0000 to 0xFF00 – 4, and at the time of the function call, 0xFF00 is the top of the stack. ESP points to this address. The stack memory after 0xFF00 is used by preceding functions in the call chain (from 0xFF04 to 0xFFFF). When the function is called, the first thing it does is execute the following assembly code, which creates a stack frame of 0x0C (12 in decimal) bytes:</p>&#13;
<p class="programs">PUSH EBP      ; saves the bottom of the lower stack frame<br/>MOV EBP, ESP  ; stores the bottom of the current stack frame, in EBP<br/>                  ; (also 4 bytes above the lower stack frame)<br/>SUB ESP, 0x0C ; subtracts 0x0C bytes from ESP, moving it up the stack<br/>                  ; to mark the top of the stack frame</p>&#13;
<p class="indent">After this code executes, the stack looks more like the one shown in <a href="ch04.xhtml#ch4fig8">Figure 4-8</a>. After creating this stack, the function can work with the 0x0C bytes it allocated on the stack.</p>&#13;
<p class="indent">0x0000 is still the absolute top of the stack. We have unused stack memory from addresses 0x0000 to 0xFF00 – 20, and the memory at address 0xFF00 – 16 contains the final 4 bytes of local storage (referenced by <span class="literal">[EBP-Ch]</span>). This is also the top of the current stack frame, so ESP points here. 0xFF00 – 12 contains the middle 4 bytes of local storage (referenced by <span class="literal">[EBP-8h]</span>), and 0xFF00 – 8 contains the first 4 bytes of local storage (referenced by <span class="literal">[EBP-4h]</span>). EBP points to 0xFF00 – 4, which is the bottom of the current stack frame; this address holds the original value of EBP. 0xFF00 is the top of the lower stack frame, and the original ESP in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a> pointed here. Finally, you can still see the stack memory from preceding functions in the call chain from 0xFF04 to 0xFFFF.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_88"/><img src="../images/f04-08.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch4fig8"/><em>Figure 4-8: Example stack with stack frame set up (read from bottom to top)</em></p>&#13;
<p class="indent">With the stack in this state, the function is free to use its local data as it pleases. If this function called another function, the new function would build its own stack frame using the same technique (the stack frames really stack up). Once a function finishes using a stack frame, however, it must restore the stack to its previous state. In our case, that means making the stack look like it did in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>. When the second function finishes, our first function cleans the stack using the following two commands:</p>&#13;
<p class="programs">MOV ESP, EBP  ; demolishes the stack frame, bringing ESP to 4 bytes above<br/>                  ; its original value (0xFF00-4)<br/>POP EBP       ; restores the bottom of the old stack frame that was saved by<br/>                  ; 'PUSH EBP'. Also adds 4 bytes to ESP, putting it back at<br/>                  ; its original value</p>&#13;
<p class="indent">But if you want to change the parameters passed to a function in a game, don’t look for them in that function’s stack frame. A function’s parameters are stored in the stack frame of the function that called it, and they’re referenced through <span class="literal">[EBP+8h]</span>, <span class="literal">[EBP+Ch]</span>, and so on. They start at <span class="literal">[EBP+8h]</span> because <span class="literal">[EBP+4h]</span> stores the function’s return address. (“<a href="ch04.xhtml#ch00lev1sec98">Function Calls</a>” on <a href="ch04.xhtml#page_94">page 94</a> explains this topic further.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Code can be compiled with stack frames disabled. When this is the case, you’ll notice that functions don’t open with <span class="literal">PUSH EBP</span> and instead reference everything relative to ESP. More often than not, though, stack frames are enabled in compiled game code.</em></p>&#13;
</div>&#13;
<p class="indent">Now that you have a grasp on the fundamentals of assembly code, let’s explore some specifics that will come in handy when hacking games.</p>&#13;
<h4 class="h4" id="ch00lev1sec94"><span epub:type="pagebreak" id="page_89"/><strong><em>Important x86 Instructions for Game Hacking</em></strong></h4>&#13;
<p class="noindent">While assembly language has hundreds of instructions, many well-equipped game hackers understand only a small subset of them, which I cover in detail here. This subset typically encapsulates all instructions that are used to modify data, call functions, compare values, or jump around within code.</p>&#13;
<h5 class="h5" id="ch00lev1sec95"><strong>Data Modification</strong></h5>&#13;
<p class="noindent">Data modification often happens over several assembly operations, but the end result has to be stored either in memory or in a register, typically with the <span class="literal">MOV</span> instruction. The <span class="literal">MOV</span> operation takes two operands: a destination and a source. <a href="ch04.xhtml#ch4tab6">Table 4-6</a> shows all possible sets of <span class="literal">MOV</span> operands and the results you can expect from those calls.</p>&#13;
<p class="tablecap"><a id="ch4tab6"/><strong>Table 4-6:</strong> Operands to the <span class="literal">MOV</span> Instruction</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Instruction syntax</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Result</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV R1, R2</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies <span class="literal">R2</span>’s value to <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MOV R1, [R2]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Copies the value from the memory referenced by <span class="literal">R2</span> to <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV R1, [R2+Ah]</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies the value from the memory referenced by <span class="literal">R2+0xA</span> to <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MOV R1, [DEADBEEFh]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Copies the value from the memory at 0xDEADBEEF to <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV R1, BADF00Dh</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies the value 0xBADF00D to <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MOV [R1], R2</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Copies <span class="literal">R2</span>’s value to the memory referenced by <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV [R1], BADF00Dh</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies the value 0xBADF00D to the memory referenced by <span class="literal">R1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MOV [R1+4h], R2</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Copies <span class="literal">R2</span>’s value to the memory referenced by <span class="literal">R1+0x4</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV [R1+4h], BADF00Dh</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies the value 0xBADF00D to the memory referenced by <span class="literal">R1+0x4</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MOV [DEADBEEFh], R1</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Copies <span class="literal">R1</span>’s value to the memory at 0xDEADBEEF.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV [DEADBEEFh], BADF00Dh</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Copies the value 0xBADF00D to the memory at 0xDEADBEEF.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <span class="literal">MOV</span> instruction can take a lot of operand combinations, but some aren’t allowed. First, the destination operand can’t be an immediate value; it must be a register or memory address, because immediate values can’t be modified. Second, values can’t be directly copied from one memory address to another. Copying a value requires two separate operations, like so:</p>&#13;
<p class="programs">MOV EAX, [EBP+10h]   ; copy memory from EBP+0x10 to EAX<br/>MOV [DEADBEEFh], EAX ; MOV the copied memory to memory at 0xDEADBEEF</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>These instructions copy whatever is stored at EBP+0x10 to the memory at 0xDEADBEEF.</p>&#13;
<h5 class="h5" id="ch00lev1sec96"><strong>Arithmetic</strong></h5>&#13;
<p class="noindent">Like many high-level languages, assembly language has two types of arithmetic: unary and binary. Unary instructions take a single operand that acts as both a destination and a source. This operand can be a register or a memory address. <a href="ch04.xhtml#ch4tab7">Table 4-7</a> shows the common unary arithmetic instructions in x86.</p>&#13;
<p class="tablecap"><a id="ch4tab7"/><strong>Table 4-7:</strong> Unary Arithmetic Instructions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Instruction syntax</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Result</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">INC <span class="codeitalic">operand</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Adds 1 to the operand value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">DEC <span class="codeitalic">operand</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Subtracts 1 from the operand value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">NOT <span class="codeitalic">operand</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Logically negates the operand value (flips all bits).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">NEG <span class="codeitalic">operand</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Performs two’s-complement negation (flips all bits and adds 1; essentially multiplies by -1).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Binary instructions (which make up the majority of x86 arithmetic), on the other hand, are syntactically similar to the <span class="literal">MOV</span> instruction. They require two operands and have similar operand limitations. Unlike <span class="literal">MOV</span>, however, their destination operand serves a second purpose: it is also the left-hand value in the calculation. For example, the assembly operation <span class="literal">ADD EAX,EBX</span> equates to <span class="literal">EAX = EAX + EBX</span> or <span class="literal">EAX += EBX</span> in C++. <a href="ch04.xhtml#ch4tab8">Table 4-8</a> shows the common x86 binary arithmetic instructions.</p>&#13;
<p class="tablecap"><a id="ch4tab8"/><strong>Table 4-8:</strong> Binary Arithmetic Instructions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Instruction syntax</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operand notes</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ADD <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal"><span class="codeitalic">destination</span> += <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">SUB <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">destination</span> -= <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">AND <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal"><span class="codeitalic">destination</span> &amp;= <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">OR <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">destination</span> |= <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">XOR <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal"><span class="codeitalic">destination</span> ^= <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">SHL <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">destination</span> = <span class="codeitalic">destination</span> &lt;&lt; <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">source</span></span> must be CL or an 8-bit immediate value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">SHR <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal"><span class="codeitalic">destination</span> = <span class="codeitalic">destination</span> &gt;&gt; <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal"><span class="codeitalic">source</span></span> must be CL or an 8-bit immediate value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">IMUL <span class="codeitalic">destination</span>, <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">destination</span> *= <span class="codeitalic">source</span></span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal"><span class="codeitalic">destination</span></span> must be a register; source cannot be an immediate value.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Of these arithmetic instructions, <span class="literal">IMUL</span> is special because you can pass it a third operand, in the form of an immediate value. With this prototype, the destination operand is no longer involved in the calculation, which <span epub:type="pagebreak" id="page_91"/>instead takes place between the remaining operands. For example, the assembly command <span class="literal">IMUL EAX,EBX,4h</span> equates to <span class="literal">EAX = EBX * 0x4</span> in C++.</p>&#13;
<p class="indent">You can also pass a single operand to <span class="literal">IMUL</span>.<sup><a id="ch00fn_03"/><a href="footnote.xhtml#ch00fn03">3</a></sup> In this case, the operand acts as the source and can be either a memory address or a register. Depending on the size of the source operand, the instruction will use different parts of the EAX register for inputs and output, as shown in <a href="ch04.xhtml#ch4tab9">Table 4-9</a>.</p>&#13;
<p class="tablecap"><a id="ch4tab9"/><strong>Table 4-9:</strong> Possible <span class="literal">IMUL</span> Register Operands</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Source size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Input</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Output</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bits</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">AL</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16 bit, stored in AH:AL (which is AX)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16 bits</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">AX</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32 bit, stored in DX:AX (bits 0–15 in AX and bits 16–31 in DX)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32 bits</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">EAX</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">64 bit, stored in EDX:EAX (bits 0–31 in EAX and bits 32–64 in EDX)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Notice that even though the input is only one register, each output uses two registers. That’s because in multiplication, the result generally is larger than the inputs.</p>&#13;
<p class="indent">Let’s look at an example calculation using <span class="literal">IMUL</span> with a single 32-bit operand:</p>&#13;
<p class="programs">IMUL [BADFOODh] ; 32-bit operand is at address 0xBADFOOD</p>&#13;
<p class="indent">This command behaves like the following pseudocode:</p>&#13;
<p class="programs">EDX:EAX = EAX * [BADFOODh]</p>&#13;
<p class="indent">Similarly, here’s an operation that uses <span class="literal">IMUL</span> with a single 16-bit operand:</p>&#13;
<p class="programs">IMUL CX ; 16-bit operand is stored in CX</p>&#13;
<p class="indent">And its corresponding pseudocode:</p>&#13;
<p class="programs">DX:AX = AX * CX</p>&#13;
<p class="indent">Finally, this is an <span class="literal">IMUL</span> command with a single 8-bit operand:</p>&#13;
<p class="programs">IMUL CL ; 8-bit operand is stored in CL</p>&#13;
<p class="indent">And its corresponding pseudocode:</p>&#13;
<p class="programs">AX = AL * CL</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>x86 assembly language has division as well, through the <span class="literal">IDIV</span> instruction.<sup><a id="ch00fn_04"/><a href="footnote.xhtml#ch00fn04">4</a></sup> The <span class="literal">IDIV</span> instruction accepts a single source operand and follows register rules similar to those for <span class="literal">IMUL</span>. As <a href="ch04.xhtml#ch4tab10">Table 4-10</a> shows, <span class="literal">IDIV</span> operations require two inputs and two outputs.</p>&#13;
<p class="tablecap"><a id="ch4tab10"/><strong>Table 4-10:</strong> Possible <span class="literal">IDIV</span> Register Operands</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Source size</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Input</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Output</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8 bit</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16 bit, stored in AH:AL (which is AX)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Remainder in AH; quotient in AL</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16 bit</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32 bit, stored in DX:AX</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Remainder in DX; quotient in AX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32 bit</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">64 bit, stored in EDX:EAX</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Remainder in EDX; quotient in EAX</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In division, the inputs are generally larger than the output, so here the inputs take two registers. Moreover, division operations must store a remainder, which gets stored in the first input register. For example, here’s how a 32-bit <span class="literal">IDIV</span> calculation would look:</p>&#13;
<p class="programs">MOV EDX, 0          ; there's no high-order DWORD in the input, so EDX is 0<br/>MOV EAX, inputValue ; 32-bit input value <br/>IDIV ECX            ; divide EDX:EAX by ECX</p>&#13;
<p class="indent">And here’s some pseudocode that expresses what happens under the hood:</p>&#13;
<p class="programs">EAX = EDX:EAX / ECX ; quotient<br/>EDX = EDX:EAX % ECX ; remainder</p>&#13;
<p class="indent">These details of <span class="literal">IDIV</span> and <span class="literal">IMUL</span> are important to remember, as the behavior can otherwise be quite obfuscated when you’re simply looking at the commands.</p>&#13;
<h5 class="h5" id="ch00lev1sec97"><strong>Branching</strong></h5>&#13;
<p class="noindent">After evaluating an expression, programs can decide what to execute next based on the result, typically using constructs such as <span class="literal">if()</span> statements or <span class="literal">switch()</span> statements. These control flow statements don’t exist at the assembly level, however. Instead, assembly code uses the EFLAGS register to make decisions and jump operations to execute different blocks; this process is called <em>branching</em>.</p>&#13;
<p class="indent">To get the proper value in EFLAGS, assembly code uses one of two instructions: <span class="literal">TEST</span> or <span class="literal">CMP</span>. Both compare two operands, set the status bits of EFLAGS, and then discard any results. <span class="literal">TEST</span> compares the operands using a logical AND, while <span class="literal">CMP</span> uses signed subtraction to subtract the latter operand from the former.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>In order to branch properly, the code has a jump command immediately following the comparison. Each type of jump instruction accepts a single operand that specifies the address of the code to jump to. How a particular jump instruction behaves depends on the status bits of EFLAGS. <a href="ch04.xhtml#ch4tab11">Table 4-11</a> describes some x86 jump instructions.</p>&#13;
<p class="tablecap"><a id="ch4tab11"/><strong>Table 4-11:</strong> Common x86 Jump Instructions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Name</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Behavior</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JMP dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Unconditional jump</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps to <span class="literal">dest</span> (sets <span class="literal">EIP</span> to <span class="literal">dest</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jump if equal</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">ZF</span> (zero flag) is 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JNE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jump if not equal</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">ZF</span> is 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JG dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jump if greater</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">ZF</span> is 0 and <span class="literal">SF</span> (sign flag) is equal to <span class="literal">OF</span> (overflow flag).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JGE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jump if greater or equal</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">SF</span> is equal to <span class="literal">OF</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JA dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unsigned <span class="literal">JG</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">CF</span> (carry flag) is 0 and <span class="literal">ZF</span> is 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JAE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Unsigned <span class="literal">JGE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">CF</span> is 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JL dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jump if less</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">SF</span> is not equal to <span class="literal">OF</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JLE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jump if less or equal</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">ZF</span> is 1 or <span class="literal">SF</span> is not equal to <span class="literal">OF</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JB dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unsigned <span class="literal">JL</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">CF</span> is 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JBE dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Unsigned <span class="literal">JLE</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">CF</span> is 1 or <span class="literal">ZF</span> is 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JO dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jump if overflow</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">OF</span> is 1.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JNO dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jump if not overflow</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">OF</span> is 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">JZ dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jump if zero</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps if <span class="literal">ZF</span> is 1 (identical to <span class="literal">JE</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">JNZ dest</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jump if not zero</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Jumps if <span class="literal">ZF</span> is 0 (identical to <span class="literal">JNE</span>).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Remembering which flags control which jump instructions can be a pain, but their purpose is clearly expressed in their name. A good rule of thumb is that a jump preceded by a <span class="literal">CMP</span> is the same as its corresponding operator. For example, <a href="ch04.xhtml#ch4tab11">Table 4-11</a> lists <span class="literal">JE</span> as “jump if equal,” so when <span class="literal">JE</span> follows a <span class="literal">CMP</span> operation, it’s the same as the <span class="literal">==</span> operator. Similarly, <span class="literal">JGE</span> would be <span class="literal">&gt;=</span>, <span class="literal">JLE</span> would be <span class="literal">&gt;=</span>, and so on.</p>&#13;
<p class="indent">As an example, consider the high-level code shown in <a href="ch04.xhtml#ch4exe8">Listing 4-8</a>.</p>&#13;
<p class="programs">--<span class="codeitalic">snip</span>--<br/>if (EBX &gt; EAX)<br/>    ECX = EDX;<br/>else<br/>    ECX = 0;<br/>--<span class="codeitalic">snip</span>--</p>&#13;
<p class="listt"><a id="ch4exe8"/><em>Listing 4-8: A simple conditional statement</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>This <span class="literal">if()</span> statement just checks whether <span class="literal">EBX</span> is greater than <span class="literal">EAX</span> and sets <span class="literal">ECX</span> based on the result. In assembly, the same statement may look something like this:</p>&#13;
<p class="programs">       --<span class="codeitalic">snip</span>--<br/>       CMP EBX, EAX  ; if (EBX &gt; EAX)<br/>       JG label1     ; jump to label1 if EBX &gt; EAX<br/>       MOV ECX, 0    ; ECX = 0 (else block)<br/>       JMP label2    ; jump over the if block<br/>   label1: <br/><span class="ent">➊</span>     MOV ECX, EDX ; ECX = EDX (if block)<br/>   label2:<br/>       --<span class="codeitalic">snip</span>--</p>&#13;
<p class="indent">The assembly for the <span class="literal">if()</span> statement in <a href="ch04.xhtml#ch4exe8">Listing 4-8</a> begins with a <span class="literal">CMP</span> instruction and branches if <span class="literal">EBX</span> is greater than <span class="literal">EAX</span>. If the branch is taken, <span class="literal">EIP</span> is set to the <span class="literal">if</span> block at <span class="ent">➊</span> courtesy of the <span class="literal">JG</span> instruction. If the branch is not taken, the code continues executing linearly and hits the <span class="literal">else</span> block immediately after the <span class="literal">JG</span> instruction. When the <span class="literal">else</span> block finishes executing, an unconditional <span class="literal">JMP</span> sets <span class="literal">EIP</span> to <span class="literal">0x7</span>, skipping over the <span class="literal">if</span> block.</p>&#13;
<h5 class="h5" id="ch00lev1sec98"><strong>Function Calls</strong></h5>&#13;
<p class="noindent">In assembly code, functions are isolated blocks of commands executed through the <span class="literal">CALL</span> instruction. The <span class="literal">CALL</span> instruction, which takes a function address as the only operand, pushes a return address onto the stack and sets EIP to its operand value. The following pseudocode shows a <span class="literal">CALL</span> in action, with memory addresses on the left in hex:</p>&#13;
<p class="programs">0x1: CALL EAX<br/>0x2: ...</p>&#13;
<p class="indent">When <span class="literal">CALL EAX</span> is executed, the next address is pushed to the stack and <span class="literal">EIP</span> is set to <span class="literal">EAX</span>, showing that <span class="literal">CALL</span> is essentially a <span class="literal">PUSH</span> and <span class="literal">JMP</span>. The following pseudocode underscores this point:</p>&#13;
<p class="programs">0x1: PUSH 3h<br/>0x2: JMP EAX<br/>0x3: ...</p>&#13;
<p class="indent">While there’s an extra address between the <span class="literal">PUSH</span> instruction and the code to execute, the result is the same: before the block of code at <span class="literal">EAX</span> is executed, the address of the code that follows the branch is pushed to the stack. This happens so the <em>callee</em> (the function being called) knows where to jump to in the <em>caller</em> (the function doing the call) when it returns.</p>&#13;
<p class="indent">If a function without parameters is called, a <span class="literal">CALL</span> command is all that’s necessary. If the callee takes parameters, however, the parameters must first <span epub:type="pagebreak" id="page_95"/>be pushed onto the stack in reverse order. The following pseudocode shows how a function call with three parameters might look:</p>&#13;
<p class="programs">PUSH 300h   ; arg3<br/>PUSH 200h   ; arg2 <br/>PUSH 100h   ; arg1 <br/>CALL ECX    ; call</p>&#13;
<p class="indent">When the callee is executed, the top of the stack contains a return address that points to the code after the call. The first parameter, <span class="literal">0x100</span>, is below the return address on the stack. The second parameter, <span class="literal">0x200</span>, is below that, followed by the third parameter, <span class="literal">0x300</span>. The callee sets up its stack frame, using memory offsets from <span class="literal">EBP</span> to reference each parameter. Once the callee has finished executing, it restores the caller’s stack frame and executes the <span class="literal">RET</span> instruction, which pops the return address off the stack and jumps to it.</p>&#13;
<p class="indent">Since the parameters are not a part of the callee’s stack frame, they remain on the stack after <span class="literal">RET</span> is executed. If the caller is responsible for cleaning the stack, it adds 12 (3 parameters, at 4 bytes each) to ESP immediately after <span class="literal">CALL ECX</span> completes. If the callee is responsible, it cleans up by executing <span class="literal">RET 12</span> instead of <span class="literal">RET</span>. This responsibility is determined by the callee’s <em>calling convention</em>.</p>&#13;
<p class="indent">A function’s calling convention tells the compiler how the assembly code should pass parameters, store instance pointers, communicate the return value, and clean the stack. Different compilers have different calling conventions, but the ones listed in <a href="ch04.xhtml#ch4tab12">Table 4-12</a> are the only four that a game hacker is likely to encounter.</p>&#13;
<p class="tablecap"><a id="ch4tab12"/><strong>Table 4-12:</strong> Calling Conventions to Know for Game Hacking</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Directive</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Cleaner</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">__cdecl</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">caller</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Default convention in Visual Studio.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">__stdcall</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">callee</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Convention used by Win32 API functions.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">__fastcall</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">callee</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">First two <span class="literal">DWORD</span> (or smaller) parameters are passed in ECX and EDX.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">__thiscall</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">callee</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Used for member functions. The pointer to the class instance is passed in ECX.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Directive column in <a href="ch04.xhtml#ch4tab12">Table 4-12</a> gives the name of the calling convention, and the Cleaner column tells you whether the caller or callee is responsible for cleaning the stack given that directive. In the case of these four calling conventions, parameters are always pushed right to left, and return values are always stored in EAX. This is a standard, but not a rule; it can differ across other calling conventions.</p>&#13;
<h3 class="h3" id="ch00lev1sec99"><span epub:type="pagebreak" id="page_96"/><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">My goal in writing this chapter was to help you understand memory and assembly in a general sense, before we dig into game-hacking specifics. With your newfound ability to think like a computer, you should be adequately armed to start tackling more advanced memory forensics tasks. If you’re itching for a peek at how you’ll apply all of this to something real, flip to “<a href="ch08.xhtml#ch00lev1sec169">Applying Call Hooks to Adobe AIR</a>” on <a href="ch08.xhtml#page_169">page 169</a> or “<a href="ch08.xhtml#ch00lev1sec174">Applying Jump Hooks and VF Hooks to Direct3D</a>” on <a href="ch08.xhtml#page_175">page 175</a>.</p>&#13;
<p class="indent">If you want some hands-on time with memory, compile this chapter’s example code and use Cheat Engine or OllyDbg to inspect, tweak, and poke at the memory until you’ve got the hang of it. This is important, as the next chapter will build on these skills by teaching you advanced memory forensic techniques.</p>&#13;
</body></html>