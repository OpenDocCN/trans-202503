- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONTROL FLOW CONSTRUCTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg271_Image_273.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: When writing a program in C or assembly language, we specify the order in which
    each statement or instruction is executed. This order is called the *control flow*.
    Programming by specifying the control flow is known as *imperative programming*.
    This is in contrast to *declarative programming*, where we state the logic of
    the computation and another program figures out the control flow to perform it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: If you have been using `make` to build your programs, as recommended in [Chapter
    2](ch02.xhtml), the statements in your makefile are an example of declarative
    programming. You specify the logic of the results, and the `make` program figures
    out the control flow to produce the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three fundamental control flow constructs: sequence, iteration, and
    selection. You’ve already seen sequence in the programs we’ve written thus far:
    each instruction, or subfunction, is executed in the order in which it’s written.
    In this chapter, I’ll show you how to alter the control flow from the written
    order to iterate the same block of written instructions or to select between several
    blocks of written instructions. You’ll see how each of these control flow constructs
    is implemented at the assembly language level. In [Chapter 14](ch14.xhtml), I’ll
    cover the details of altering control flow by calling a subfunction.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Branches**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *branch instruction* transfers control flow to the memory location specified
    by the instruction. There are two types of branches: unconditional and conditional.
    Both iteration and selection use conditional branches to alter control flow based
    on a true/false condition. You’ll also often use unconditional branches when implementing
    the iteration and selection flow constructs. We’ll start with those and then look
    at conditional branches.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '***Unconditional***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you learned in [Chapter 9](ch09.xhtml), when an instruction is executed,
    the CPU automatically increments the program counter, `pc`, by 4 to hold the address
    of the next instruction in memory. Instead of adding 4 to the program counter,
    an unconditional branch instruction changes the program counter to the branch
    target address, which causes the CPU to continue program execution at the target
    address.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'You already learned about one unconditional branch instruction—`ret`, which
    is used to return from functions—in [Chapter 10](ch10.xhtml). There are two others,
    `b` and `br`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: b**—Branch unconditionally**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`b` label branches to the address of label within the range of ±128MB from
    this instruction.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: br**—Branch register unconditionally**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`br x`s branches to the 64-bit address in `x`s.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The `b` instruction is commonly used together with a conditional branch instruction
    to skip blocks of code or to go back to the beginning of a block of code and execute
    it again. For the `b` instruction, the CPU sign-extends the 26-bit word offset
    between the `b` instruction and label to 64 bits and adds this signed number to
    `pc`. The `br` instruction simply copies the 64 bits in `x`s to `pc`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Although `br x30` would seem to have the same effect as `ret`, the `br` and
    `ret` instructions are not aliases for each other; they are different instructions.
    The difference is that `br` tells the CPU that this is probably *not* a function
    return, while `ret` tells the CPU that this probably *is* a function return. The
    details are beyond the scope of this book, but these hints can help the CPU optimize
    some of the specifics of executing instructions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '***Conditional***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two types of conditional branch instructions. One tests the settings
    of the condition flags in the `nzcv` register (see [Figure 9-4](ch09.xhtml#ch9fig4)
    in [Chapter 9](ch09.xhtml)). We need to use another instruction to set the flags
    before testing them to determine whether to branch or not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The other type of conditional branch instruction tests the value in a register
    to determine whether to branch. Instructions in this group do not depend on the
    condition flags, nor do they change them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with the instructions that branch according to the settings of the
    condition flags:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: b.cond**—Branch conditionally**
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`b.`cond label tests the settings in the `nzcv` register and branches to label
    if they match cond, in the range of ±128MB from this instruction. The possible
    values for cond are given in [Table 13-1](ch13.xhtml#ch13tab1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Allowable Branching Condition Codes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | cond | **Meaning** | **Condition flags** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| `0000` | `eq` | Equal | *Z* |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| `0001` | `ne` | Not equal | ¬*Z* |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| `0010` | `cs` or `hs` | Carry set; unsigned higher or same | *C* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| `0011` | `cc` or `lo` | Carry not set; unsigned lower | ¬*C* |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `0100` | `mi` | Minus; negative | *N* |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `0101` | `pl` | Plus; positive or zero | ¬*N* |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `0110` | `vs` | Overflow | *V* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `0111` | `vc` | No overflow | ¬*V* |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `1000` | `hi` | Unsigned higher | *C* ∧ ¬*Z* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `1001` | `ls` | Unsigned lower or same | ¬(*C* ∧ ¬*Z*) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `1010` | `ge` | Signed greater than or equal | *N* = *V* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `1011` | `lt` | Signed less than | ¬(*N* = *V* ) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `1100` | `gt` | Signed greater than | ¬*Z* ∧ (*N* = *V* ) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `1101` | `le` | Signed less than or equal | ¬(¬*Z* ∧ (*N* = *V* )) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `1110` | `al` | Always | Any |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `1111` | `nv` | Always | Any |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: You should use the `b.`cond instruction when you want to take one of two branches
    in your program, depending on the result of another operation. It’s important
    that the `b.`cond instruction immediately follow the instruction whose result
    is driving the decision to branch. An intervening instruction or function call
    might change the settings of the condition flags, giving an erroneous basis for
    the decision.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, there are four instructions that branch depending on the
    value in a general-purpose register:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: cbz**—Compare and branch if zero**
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`cbz w`s`,` label branches to label if the value in `w`s is `0`, in the range
    of ±1MB from this instruction.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`cbz x`s`,` label branches to label if the value in `x`s is `0`, in the range
    of ±1MB from this instruction.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: cbnz**—Compare and branch if not zero**
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`cbnz w`s`,` label branches to label if the value in `w`s is not `0`, in the
    range of ±1MB from this instruction.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`cbnz x`s`,` label branches to label if the value in `x`s is not `0`, in the
    range of ±1MB from this instruction.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: tbz**—Test bit and branch if zero**
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`tbz w`s`,` imm`,` label branches to label if bit number imm in `w`s is `0`,
    in the range of ±1MB from this instruction.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`tbz x`s`,` imm`,` label branches to label if bit number imm in `x`s is `0`,
    in the range of ±1MB from this instruction.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: tbnz**—Test bit and branch if not zero**
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`tbnz w`s`,` imm`,` label branches to label if bit number imm in `w`s is not
    `0`, in the range of ±1MB from this instruction.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`tbnz x`s`,` imm`,` label branches to label if bit number imm in `x`s is not
    `0`, in the range of ±1MB from this instruction.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*When using a conditional branch like* b.gt *or* b.le, *it’s easy to forget
    the order of the test: source compared to destination, or destination compared
    to source. When testing my program, I almost always start by using* gdb *and putting
    a breakpoint at the conditional branch instruction. When the program breaks, I
    check the values and use the* si *command to see which way the branch went.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to control the flow of instruction execution, I’ll show
    you some programming constructs. We’ll start with repetition. This can be implemented
    in two ways: *iteration*, in which the program loops through a block of code repeatedly
    until a condition is met, and *recursion*, where a function calls itself repeatedly
    until a condition is met.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover iteration in the next section and explain how recursion works when
    I discuss special uses of subfunctions in [Chapter 15](ch15.xhtml).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Iteration**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many algorithms use iteration, also known as *looping*. A loop continues the
    iteration of a block of code until the value(s) of the *loop control variable(s)*
    meet a *termination condition* that causes the loop to end. With a looping construct,
    the value(s) of the loop control variable(s) must be changed within the iterated
    block of instructions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Processing a text string one character at a time provides a good example of
    looping. I will use the two system call functions from [Figure 2-1](ch02.xhtml#ch2fig1)
    in [Chapter 2](ch02.xhtml), `write` and `read`, to illustrate the concepts. That
    figure shows that `printf` converts data from its memory storage format to a character
    format and calls the `write` system call function to display the characters on
    the screen. When reading characters from the keyboard, `scanf` calls the `read`
    system call function and converts the characters to a memory storage format.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个字符处理文本字符串是循环的一个很好的例子。我将使用 [图 2-1](ch02.xhtml#ch2fig1) 中的两个系统调用函数，`write` 和
    `read`，来说明这些概念。该图显示，`printf` 将数据从内存存储格式转换为字符格式，并调用 `write` 系统调用函数将字符显示在屏幕上。当从键盘读取字符时，`scanf`
    调用 `read` 系统调用函数，并将字符转换为内存存储格式。
- en: '***write and read System Call Functions***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***write 和 read 系统调用函数***'
- en: The `write` and `read` system call functions see the screen and keyboard as
    files. When a program is first launched, the operating system opens three files—*standard
    input*, *standard output*, and *standard error*—and assigns an integer to each
    file, which is called the *file descriptor*. The program interacts with each file
    by using the file descriptor. The C interfaces for calling `write` and `read`
    are specified in the *Portable Operating System Interface (POSIX)* standard, which
    you can find at *[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 系统调用函数将屏幕和键盘视为文件。当程序首次启动时，操作系统打开三个文件——*标准输入*、*标准输出* 和 *标准错误*——并为每个文件分配一个整数，这个整数被称为
    *文件描述符*。程序通过使用文件描述符与每个文件进行交互。调用 `write` 和 `read` 的 C 接口在 *可移植操作系统接口 (POSIX)* 标准中定义，你可以在
    *[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)*
    上找到该标准。'
- en: The general formats for calling these two functions are
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这两个函数的一般格式是
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where fd is the file descriptor, buf is the address of the character storage,
    and n is the number of characters to write or read. You can read more details
    in the man pages for `write` and `read`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，fd 是文件描述符，buf 是字符存储的地址，n 是要写入或读取的字符数。你可以在 `write` 和 `read` 的手册页中阅读更多细节：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Table 13-2](ch13.xhtml#ch13tab2) shows the file descriptors I’ll use and the
    device each is normally associated with.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-2](ch13.xhtml#ch13tab2) 显示了我将使用的文件描述符及其通常关联的设备。'
- en: '**Table 13-2:** The File Descriptors for the `write` and `read` System Call
    Functions'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-2：** `write` 和 `read` 系统调用函数的文件描述符'
- en: '| **Name** | **Number** | **Use** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **编号** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `STDIN_FILENO` | 0 | Read characters from the keyboard |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `STDIN_FILENO` | 0 | 从键盘读取字符 |'
- en: '| `STDOUT_FILENO` | 1 | Write characters to the screen |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `STDOUT_FILENO` | 1 | 将字符写入屏幕 |'
- en: '| `STDERR_FILENO` | 2 | Write error messages to the screen |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `STDERR_FILENO` | 2 | 将错误信息写入屏幕 |'
- en: These names are defined in the system header file, *unistd.h*, which is located
    at */usr/include/unistd.h* on my Raspberry Pi O (note that the location on your
    system may be different). Now, let’s move on to looping constructs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称在系统头文件 *unistd.h* 中定义，该文件位于我的 Raspberry Pi O 上的 */usr/include/unistd.h*
    （注意，你系统中的位置可能不同）。现在，让我们继续讨论循环结构。
- en: '***while Loop***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***while 循环***'
- en: 'The `while` loop is a fundamental form of looping. Here is the form in C:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是循环的基本形式。以下是 C 语言中的形式：'
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before entering the `while` loop, you need to initialize the loop control variable.
    At the beginning of the `while` loop, expression is evaluated as a Boolean. If
    it evaluates to false (`0` in C), control flow continues to next statement. If
    expression evaluates to true—that is, any nonzero value in C—the statements in
    body are executed, the loop control variable is changed, and control flow continues
    at the top with the reevaluation of expression.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入 `while` 循环之前，你需要初始化循环控制变量。在 `while` 循环的开始，表达式会作为布尔值进行求值。如果表达式求值为假（在 C 中为
    `0`），控制流将继续到下一个语句。如果表达式求值为真——即 C 中的任何非零值——则执行循环体内的语句，改变循环控制变量，控制流会重新回到顶部，重新评估表达式。
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) shows the control flow of a `while` loop.
    Although the loop termination condition can be dependent on more than one variable,
    I’ll use just one here to clarify the discussion.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch13fig1) 显示了 `while` 循环的控制流。虽然循环的终止条件可以依赖于多个变量，但我这里只使用一个变量来澄清讨论。'
- en: '![image](../images/pg276_Image_274.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg276_Image_274.jpg)'
- en: '*Figure 13-1: The control flow of the* while *loop*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：while 循环的控制流*'
- en: '[Listing 13-1](ch13.xhtml#ch13list1) shows how to use a `while` loop to write
    a text string in the terminal window one character at a time.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-1](ch13.xhtml#ch13list1)展示了如何使用`while`循环将文本字符串一个字符一个字符地写入终端窗口。'
- en: '*hello_world.c*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.c*'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-1: A program to write “Hello, World!” one character at a time*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-1：一个将“Hello, World!”一个字符一个字符写入屏幕的程序*'
- en: I use the `#define` directive to give a symbolic name to the `NUL` character
    ❶. The `message_ptr` variable is defined to be a pointer to a `char` type and
    is used as the loop control variable. It’s initialized to point to a text string
    ❷. As you’ll see when we look at the assembly language for this code, the compiler
    will store the text string in a read-only part of memory and store the address
    of the first character in that text string in the `message_ptr` pointer variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`#define`指令为`NUL`字符 ❶指定了一个符号名称。`message_ptr`变量被定义为指向`char`类型的指针，并作为循环控制变量。它被初始化为指向一个文本字符串
    ❷。正如我们在查看这段代码的汇编语言时看到的，编译器将把文本字符串存储在内存的只读部分，并将该文本字符串中第一个字符的地址存储在`message_ptr`指针变量中。
- en: 'The `while` statement first checks to see if the loop control variable, `message_ptr`,
    is pointing to the `NUL` character ❸; if not, program flow enters the `while`
    loop body and writes the character pointed to by `message_ptr` to the screen ❹.
    The loop control variable is then incremented to point to the next character in
    the text string ❺. Program flow returns to the top of the loop, where the next
    character is checked to see if it’s the `NUL` character. This loop terminates
    when `message_ptr` points to the `NUL` character ❸. Testing for this condition
    first means the program won’t even enter the body of the `while` loop if the string
    is empty, as `message_ptr` will only point to a `NUL` character. This is a subtle
    but important point about `while` loops: the code in the body is never executed
    if the termination condition is already met.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句首先检查循环控制变量`message_ptr`是否指向`NUL`字符 ❸；如果不是，程序流程进入`while`循环体，并将`message_ptr`指向的字符写入屏幕
    ❹。然后，循环控制变量递增，指向文本字符串中的下一个字符 ❺。程序流程返回到循环的顶部，检查下一个字符是否是`NUL`字符。当`message_ptr`指向`NUL`字符
    ❸时，循环终止。首先测试这个条件意味着如果字符串为空，程序甚至不会进入`while`循环体，因为`message_ptr`只会指向`NUL`字符。这是一个微妙但重要的`while`循环要点：如果终止条件已经满足，循环体中的代码是永远不会被执行的。'
- en: For [Listing 13-1](ch13.xhtml#ch13list1), the compiler generated the assembly
    language shown in [Listing 13-2](ch13.xhtml#ch13list2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[示例 13-1](ch13.xhtml#ch13list1)，编译器生成了在[示例 13-2](ch13.xhtml#ch13list2)中显示的汇编语言。
- en: '*hello_world.s*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.s*'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-2: The compiler-generated assembly language for the function in
    [Listing 13-1](ch13.xhtml#ch13list1)*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-2：在[示例 13-1](ch13.xhtml#ch13list1)中的函数对应的编译器生成的汇编语言*'
- en: The assembly language shows that the text string is stored in the `.rodata`
    section ❶. Then, `message_ptr` is initialized to contain the address of the beginning
    of the text string ❷.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言显示，文本字符串存储在`.rodata`部分 ❶。然后，`message_ptr`被初始化为包含文本字符串起始地址的指针 ❷。
- en: Although this assembly language seems to be testing for the termination condition
    at the end of the loop ❹, it follows the logical flow shown in [Figure 13-1](ch13.xhtml#ch13fig1).
    It first branches down to `.L2` ❸, where the test is made for the terminating
    condition, before branching up to `.L3` to start execution of the body of the
    `while` loop ❺. You might notice that the compiler used a `bne` instruction. This
    is the same as `b.ne`; the `.` character is optional when writing the conditional
    branch instructions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段汇编语言似乎在循环结束时检测终止条件 ❹，但它遵循了[图 13-1](ch13.xhtml#ch13fig1)所示的逻辑流程。首先，它跳转到`.L2`
    ❸，在那里检查终止条件，然后跳转到`.L3`开始执行`while`循环体 ❺。你可能注意到，编译器使用了`bne`指令。它和`b.ne`是一样的；在编写条件分支指令时，`.`字符是可选的。
- en: 'There is a new instruction, `cmp` ❹, in this code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有一个新的指令，`cmp` ❹：
- en: cmp**—Compare**
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: cmp**—比较**
- en: '`cmp` reg`,` imm subtracts imm from the value in reg and sets the condition
    flags accordingly. The result of the subtraction is discarded.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` reg`,` imm从寄存器reg的值中减去imm，并根据结果设置条件标志。减法的结果会被丢弃。'
- en: '`cmp` reg1`,` reg2 subtracts the value in reg2 from the value in reg1 and sets
    the condition flags accordingly. The result of the subtraction is discarded.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` reg1`,` reg2从寄存器reg1的值中减去寄存器reg2的值，并根据结果设置条件标志。减法的结果会被丢弃。'
- en: A `cmp` instruction immediately followed by a conditional branch instruction
    is commonly used to make decisions in a program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令紧接着条件分支指令常常用于程序中的决策。'
- en: For comparison with what the compiler did, we’ll follow the `while` loop pattern
    in my assembly language version, shown in [Listing 13-3](ch13.xhtml#ch13list3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与编译器所做的比较，我们将在我的汇编语言版本中遵循 `while` 循环的模式，如 [清单 13-3](ch13.xhtml#ch13list3)
    所示。
- en: '*hello_world.s*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.s*'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-3: An assembly language program to write Hello, World! one character
    at a time*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-3：一个汇编语言程序，通过一次输出一个字符写出 Hello, World！*'
- en: We could have used a `cbz` instruction in our condition check instead of the
    `cmp` and `b.eq` sequence ❶, but I think the use of `NUL` here is clearer. This
    solution will also work for any terminating character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在条件检查中使用 `cbz` 指令，而不是 `cmp` 和 `b.eq` 序列 ❶，但我认为这里使用 `NUL` 更加清晰。这个解决方案同样适用于任何终止字符。
- en: My assembly language solution is less efficient than what the compiler generated
    ([Listing 13-2](ch13.xhtml#ch13list2)), because the `b` instruction is executed
    in addition to the conditional `b.eq` instruction with each iteration of the loop.
    The slight increase in execution time is usually worth the code readability improvement.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我的汇编语言解决方案比编译器生成的代码（[清单 13-2](ch13.xhtml#ch13list2)）效率低，因为每次循环迭代都会执行 `b` 指令，此外还有条件
    `b.eq` 指令。虽然执行时间稍微增加，但通常值得为了代码可读性做出这种权衡。
- en: A `while` loop works well when a *sentinel value*, which is a unique value that
    marks the end of a data sequence, is used as the termination condition. For example,
    the `while` loop in [Listings 13-1](ch13.xhtml#ch13list1) and [13-3](ch13.xhtml#ch13list3)
    works for any length of text string and continues writing one character at a time
    to the screen until it reaches the sentinel value, a `NUL` character. C has another
    looping construct, the `for` loop, that many programmers find to be more natural
    for some algorithms; we’ll look at that next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个 *哨兵值*（这是一个标记数据序列结束的唯一值）作为终止条件时，`while` 循环效果很好。例如，[清单 13-1](ch13.xhtml#ch13list1)
    和 [13-3](ch13.xhtml#ch13list3) 中的 `while` 循环适用于任何长度的文本字符串，并且会继续将一个字符一个字符地写入屏幕，直到遇到哨兵值，即
    `NUL` 字符。C 语言还有另一种循环结构，`for` 循环，许多程序员认为它在某些算法中更自然；我们接下来会看看它。
- en: '***for Loop***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 循环***'
- en: 'Although their C syntax differs, the looping constructs `while` and `for` are
    semantically equivalent. The syntactical difference is that the for *loop* allows
    you to group all three control elements—loop control variable initialization,
    checking, and changing—within the parentheses. The general form of a `for` loop
    in C is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的 C 语法有所不同，但 `while` 和 `for` 循环结构在语义上是等价的。语法上的区别是，`for` *循环*允许你将所有三个控制元素——循环控制变量初始化、检查和改变——都放在括号内。C
    中 `for` 循环的一般形式如下：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Placing all the control elements within the parentheses is not required. In
    fact, we could also write a `for` loop as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有控制元素放在括号内并非必须。实际上，我们也可以将 `for` 循环写成如下形式：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `for` loop syntax does require the inclusion of both semicolons
    in the parentheses.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`for` 循环语法确实要求在括号中包括两个分号。
- en: In [Listing 13-4](ch13.xhtml#ch13list4), I have rewritten the program from [Listing
    13-1](ch13.xhtml#ch13list1) using a `for` loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 13-4](ch13.xhtml#ch13list4) 中，我用 `for` 循环重写了 [清单 13-1](ch13.xhtml#ch13list1)
    中的程序。
- en: '*hello_world_for.c*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_for.c*'
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-4: A program to write Hello, World! using a* for *loop*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-4：使用* for *循环编写 Hello, World！的程序*'
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Since the* for *statement in this program controls only one C statement, you
    really don’t need the curly brackets around that statement. I usually include
    them anyway, because if I later modify the program and add another statement,
    I often forget that I then need the curly brackets.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于此程序中的* for *语句只控制一个 C 语句，实际上你不需要在该语句周围加上大括号。我通常还是会加上它们，因为如果我稍后修改程序并添加另一个语句时，我经常会忘记需要加大括号。*'
- en: You may wonder if either looping construct is better than the other. Here’s
    where your knowledge of assembly language becomes useful. When I used `gcc` to
    generate the assembly language for [Listing 13-4](ch13.xhtml#ch13list4), I got
    the same assembly language code I did for the `while` loop version in [Listing
    13-1](ch13.xhtml#ch13list1). Since the assembly language for the `for` loop is
    shown in [Listing 13-2](ch13.xhtml#ch13list2), I won’t repeat it here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道哪种循环结构更好。这里正是你汇编语言知识派上用场的时候。当我使用`gcc`生成[清单 13-4](ch13.xhtml#ch13list4)的汇编语言时，得到的汇编语言代码与[清单
    13-1](ch13.xhtml#ch13list1)中的`while`循环版本是一样的。由于`for`循环的汇编语言已在[清单 13-2](ch13.xhtml#ch13list2)中展示，所以这里不再重复。
- en: The conclusion we can reach from this comparison of a `for` loop with a `while`
    loop is that you should use the high-level language looping construct that feels
    natural for the problem you’re solving. It’s usually a subjective choice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从`for`循环与`while`循环的对比中，我们可以得出结论，你应该使用对于你解决的问题最自然的高级语言循环结构。通常这是一个主观的选择。
- en: 'A `for` loop is often used for a *count-controlled loop*, in which the number
    of iterations is known before the loop is started. You’ll see an example of this
    usage in a moment, when we look at the selection constructs. First, though, let’s
    look at the third looping construct in C. This provides a different behavior:
    whereas the `while` loop and `for` loop constructs will skip the body of the loop
    if the termination conditions are met by the initial value of the loop control
    variable, it will always execute the loop body at least once.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环通常用于*计数控制循环*，其中循环迭代次数在开始循环之前就已确定。稍后我们将看到此用法的示例，当我们讨论选择结构时。首先，让我们看看 C
    语言中的第三种循环结构。它提供了不同的行为：与`while`循环和`for`循环结构在终止条件被循环控制变量的初始值满足时跳过循环体的做法不同，`do-while`循环结构将始终至少执行一次循环体。'
- en: '***do-while Loop***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***do-while 循环***'
- en: 'In some situations, your algorithm needs to execute the body of the loop at
    least once. In these cases, the do-while *loop* may be more natural. It has the
    following general form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您的算法需要至少执行一次循环体。在这些情况下，do-while *循环*可能会更自然。它具有以下一般形式：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `do-while` looping construct, the value of the expression is computed
    at the end of the loop body. Looping continues until this evaluation results in
    a Boolean false.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do-while`循环结构中，表达式的值是在循环体结束时计算的。循环会持续执行，直到该评估结果为布尔值 false。
- en: In [Listing 13-5](ch13.xhtml#ch13list5), I have rewritten the Hello, World!
    program using a `do-while` loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-5](ch13.xhtml#ch13list5)中，我使用`do-while`循环重写了 Hello, World! 程序。
- en: '*hello_world_do.c*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_do.c*'
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-5: A program to write Hello, World! using a* do-while *loop*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-5：使用* do-while *循环编写 Hello, World! 程序*'
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This program has a potential bug! The* do-while *loop construct will always
    execute the body of the loop at least once. Consider an empty text string, which
    is a single byte containing the* NUL *character. A* do-while *loop writes the*
    NUL *character to the screen (which does nothing) and then checks the next byte
    in memory, which could be anything. If this byte is not a* NUL *character, the*
    do-while *loop will continue to execute, writing whatever characters this and
    the following bytes represent, until it reaches a* NUL *character. The behavior
    of the program could be different each time it’s run, so the error may not show
    up in your testing.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个程序有潜在的bug！* do-while *循环结构将始终至少执行一次循环体。考虑一个空的文本字符串，它是一个包含* NUL *字符的单字节。一个*
    do-while *循环会将* NUL *字符写到屏幕上（实际上没有做任何事情），然后检查内存中的下一个字节，这个字节可能是任何内容。如果这个字节不是* NUL
    *字符，* do-while *循环会继续执行，写入该字节及下一个字节所表示的字符，直到遇到* NUL *字符。程序的行为可能每次运行时都不同，因此错误可能不会在你的测试中显现出来。*'
- en: We can use the assembly language generated by `gcc`, which is shown in [Listing
    13-6](ch13.xhtml#ch13list6), to illustrate the difference between the `do-while`
    construct and the `while` and `for` constructs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`gcc`生成的汇编语言（见[清单 13-6](ch13.xhtml#ch13list6)），来说明`do-while`结构与`while`和`for`结构之间的差异。
- en: '*hello_world_do.s*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_do.s*'
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-6: The compiler-generated assembly language for the function in
    [Listing 13-5](ch13.xhtml#ch13list5)*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-6：编译器生成的[清单 13-5](ch13.xhtml#ch13list5)函数的汇编语言*'
- en: If you compare the assembly language shown in [Listing 13-6](ch13.xhtml#ch13list6)
    with that in [Listing 13-2](ch13.xhtml#ch13list2), which shows the assembly language
    generated for both the `while` and `for` loops, you’ll see that the only difference
    is that the `do-while` loop doesn’t branch down to perform the loop control check
    ❷ before executing the loop for the first time ❶. The `do-while` construct might
    seem more efficient, but in the assembly language, the only saving is a single
    branch the first time the loop is executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at how to select whether to execute a block of code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 13.1     Enter the three C programs in [Listings 13-1](ch13.xhtml#ch13list1),
    [13-4](ch13.xhtml#ch13list4), and [13-5](ch13.xhtml#ch13list5), and use the compiler
    to generate the assembly language for each of them. Compare the assembly language
    for the three looping constructs. Compilers change with version changes, so you
    should look at what your version of the compiler does.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '13.2     Write a program in assembly language that:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: (a)     Prompts the user to enter some text
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: (b)     Uses the `read` system call function to read the entered text
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: (c)     Echoes the user’s entered text in the terminal window
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You will need to allocate space on the stack for storing the characters entered
    by the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditionals**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common flow construct is selection, where we determine whether to execute
    a block of code. I’ll start with the simplest case, determining whether to execute
    a single block based on a Boolean conditional statement, then I’ll show you how
    to use a Boolean conditional statement to select one of two blocks. I’ll end the
    chapter by discussing ways to select between several blocks based on an integral
    value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***if***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general form of an if *conditional* in C is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The expression is evaluated as a Boolean. If it evaluates to false, or `0` in
    C, control flow continues to next statement. If expression evaluates to true (a
    nonzero value in C), the statements in block are executed, and control flow continues
    to next statement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-7](ch13.xhtml#ch13list7) gives an example of an `if` statement
    that simulates flipping a coin 10 times and showing when it comes up heads.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips1.c*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-7: A program to flip a coin and show when it comes up heads*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This program uses a count-controlled `for` loop to simulate flipping a coin
    10 times ❶. The simulation involves calling the `random` function in the C standard
    library ❷. If the random number is in the lower half of all possible values from
    the `random` function ❸, we call that “heads.” To display this result we use the
    `puts` function in the C standard library, which prints a simple text string to
    the screen with an appended newline character ❹. For [Listing 13-7](ch13.xhtml#ch13list7),
    the compiler generated the assembly language shown in [Listing 13-8](ch13.xhtml#ch13list8).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips1.s*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-8: The compiler-generated assembly language for the function in
    [Listing 13-7](ch13.xhtml#ch13list7)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement is implemented with a simple conditional branch. If the condition—in
    this case, `bgt`, for branch if greater than ❶—is true, the program flow branches
    over the block of code that is controlled by the `if` statement ❷. Next, I’ll
    show you how to select between two different blocks of code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '***if-then-else***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general form of an if-then-else *conditional* in C is as follows (C does
    not use a `then` keyword):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The expression is evaluated as a Boolean. If expression evaluates to true, the
    statements in then block are executed and control flow branches to next statement.
    If it evaluates to false (`0` in C), control flow branches to else block and then
    continues to next statement.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](ch13.xhtml#ch13fig2) shows the control flow of the `if-then-else`
    conditional.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg286_Image_275.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: The control flow of an* if-then-else *conditional*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The coin-flipping program in [Listing 13-7](ch13.xhtml#ch13list7) isn’t user-friendly
    because the user doesn’t know the total number of times the coin was flipped.
    We can improve the program by using an `if-then-else` conditional to print a message
    stating when the coin came up tails, as shown in [Listing 13-9](ch13.xhtml#ch13list9).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.c*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-9: A program to flip a coin and declare it heads or tails*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-10](ch13.xhtml#ch13list10) shows the assembly language the compiler
    generates for [Listing 13-9](ch13.xhtml#ch13list9).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.s*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-10: The compiler-generated assembly language for the function in
    [Listing 13-9](ch13.xhtml#ch13list9)*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language shows that we need an unconditional branch at the end
    of the `then` block ❶ to branch over the `else` block ❷.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: My assembly language design of the coin-flipping program differs slightly, as
    shown in [Listing 13-11](ch13.xhtml#ch13list11).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.s*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-11: An assembly language design for the coin-flipping program*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The `random` function returns a random number in the `w0` register. I leave
    it there for comparison with the halfway point, which I’ve loaded into the `w1`
    register ❶. The `w0` and `w1` registers don’t need to be saved in a function.
    The compiler used `w20` for the `random_number` variable, which does need to be
    saved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: When deciding which registers to use for variables in a function, it’s important
    that you check the rules in [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml).
    That table says that a function must preserve the value in `x19` for the calling
    function. You can probably see the importance of having agreed-upon rules here.
    Not only must our function return to the calling function with its value in `x19`
    preserved, but we can assume that the functions that our function calls also preserve
    our value in `x19`. So, it’s safe to assume that the value remains the same through
    a function call.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'I won’t go into the details here, but if you need to select one of several
    blocks of code to execute, you can use the `else-if` statement in a *ladder construct*.
    The general form is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `if-then-else` selection is based on a Boolean evaluation of the controlling
    expression, but as you’ll see in the next section, there are algorithms in which
    the selection is based on a discrete value, which is used to select one of several
    cases.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***switch***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'C provides a switch *conditional*, where control flow branches to a place in
    a list of code blocks depending on the value of a selector. The general form of
    the `switch` is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The selector can be any expression that evaluates to an integer. Each selector_1,
    selector_2, . . . , selector_n must be an integer constant. The `switch` will
    branch to the `case` whose selector_1, selector_2, . . . , selector_n is equal
    to the selector evaluation. If selector does not evaluate to any of the selector_1,
    selector_2, . . . , selector_n integers, the `switch` branches to `default`. After
    executing the corresponding block_1, block_2, . . . , block_n, program flow continues
    through the remaining blocks of code. A `break` statement at any place in the
    `switch` will exit the `switch` at that point and branch down to next statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-12](ch13.xhtml#ch13list12) shows how to use a `switch` statement
    in C.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.c*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-12: A* switch *statement*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: I want this program to execute only the case corresponding to the value of `i`.
    To prevent it from executing the following cases in the `switch`, I end each block
    with a `break` statement, which causes an exit from the `switch` ❶.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-13](ch13.xhtml#ch13list13) shows how the compiler implemented this
    `switch`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.s*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-13: Compiler-generated assembly language for the function in [Listing
    13-12](ch13.xhtml#ch13list12)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-13](ch13.xhtml#ch13list13), the compiler creates two parts for
    the `switch`. The first part is the logic to decide which block of code to execute
    ❶. Depending on the value of the selector, this will transfer program flow to
    the correct block in the second part ❷.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at another way to implement a `switch`: a *branch table*, also
    called a *jump table*. A branch table is a table of the block addresses that we
    need to select from. We need to design an algorithm that will select the correct
    address in the table, based on the value of the selector, and then branch to that
    address.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows one way to do this for our current
    example.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.s*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-14: An assembly language design for using a branch table*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in the branch table is the address of the code block to execute for
    the corresponding value of the selector variable. The `.quad` assembler directive
    tells the assembler to allocate 8 bytes of memory and initialize it to the value
    of the operand ❷. We’re using it to store the address of each of the code blocks
    our algorithm will select from. Since the items in our branch table are 64-bit
    addresses, we need to align the beginning of the table at a 64-bit address boundary
    ❶.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm uses `x19` and `x20` as local variables, and the procedure call
    standard states that we need to save their contents for the calling function (see
    [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml)) ❸. We can also
    assume that their contents will be preserved by the functions we call from this
    function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We need to determine which block address to load from the branch table. We start
    with the address of the beginning of the table ❹. Then, we compare the current
    value of `i`, in `x19`, with the number of the default case. If the value of `i`
    is lower than the default case, we’ll use the `csel` instruction to move that
    value into `x1`. If it’s the same or higher, the `csel` instruction moves the
    number of the default case in `x20` to `x1` ❹. Now that we have the case number
    in `x1`, we need to subtract 1 to get the offset in the table from the first item
    in the table ❻.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to convert the case offset to an address offset so we can add
    it to the address of the beginning of the branch table. Each item in the branch
    table is 8 bytes wide. We use an option of the `add` instruction to shift the
    value of our offset, in `x1`, 3 bits to the left ❼. This multiplies the offset
    by 8 before adding it to the beginning address of the branch table, in `x0`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now, `x0` contains the address in the branch table of the item we want. We replace
    the address of the item with the item itself, which is the address of the block
    to execute ❽.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `csel` instruction can be useful for a simple `if-then-else` construct
    when you’re selecting between two values in registers. It takes this form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: csel**—Conditional select**
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`csel` reg1, reg2, reg3, cond tests the settings in the `nzcv` register and
    moves reg2 to reg1 if cond is true or moves reg3 to reg1 if cond is false.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You now know two ways to implement a `switch` construct. It’s difficult to say
    whether a branch table is more efficient than an `if-else` ladder. For a large
    number of cases, an `if-else` ladder may require many tests before reaching the
    correct case to select. The efficiency also depends on things such as cache usage
    and the internal CPU design, and it can vary between CPU implementations that
    use the same instruction set. Any differences between the two techniques will
    probably be insignificant, so you should choose the one that seems to better match
    the problem you’re solving.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 13.3     Change the assembly language program in [Listing 13-11](ch13.xhtml#ch13list11)
    so that it sees the lowest one-fourth and the highest one-fourth of the random
    numbers (`0` to `RAND_MAX/4` and `3*RAND_MAX/4` to `RAND_MAX`) as heads. It will
    see the middle half of the random numbers (`RAND_MAX/4` to `3*RAND_MAX/4`) as
    tails.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 13.4     Remove the `break` statements in the program in [Listing 13-12](ch13.xhtml#ch13list12).
    How does this change the behavior of the program? Generate the assembly language
    from your changed program and compare it to that in [Listing 13-13](ch13.xhtml#ch13list13).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 13.5     Change the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses `if` conditionals instead of the `csel` instruction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 13.6     Rewrite the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses a ladder of `if-else` conditionals instead of a `switch`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unconditional branch** Changes the program counter to alter the control flow.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional branch** Evaluates Boolean combinations of the status flags in
    the `nzcv` register and alters control flow if the combination evaluates to true.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: while **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: for **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: do-while **loop** Executes a block of code once and iterates it until a Boolean
    condition becomes false.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: if **conditional** Checks for a Boolean condition and then executes a block
    of code if the condition is true.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else **conditional** Checks for a Boolean condition and then executes
    one of two blocks of code, depending on whether the condition is true or false.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: switch **conditional** Evaluates an expression and then branches to a location
    in a list of blocks of code, depending on the integer value of the expression.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about control flow constructs and the `main` function, we’ll
    move on to discuss how to write your own subfunctions. In the next chapter, you’ll
    learn how to pass arguments and how to access those arguments in the subfunction.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
