- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONTROL FLOW CONSTRUCTS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg271_Image_273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When writing a program in C or assembly language, we specify the order in which
    each statement or instruction is executed. This order is called the *control flow*.
    Programming by specifying the control flow is known as *imperative programming*.
    This is in contrast to *declarative programming*, where we state the logic of
    the computation and another program figures out the control flow to perform it.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been using `make` to build your programs, as recommended in [Chapter
    2](ch02.xhtml), the statements in your makefile are an example of declarative
    programming. You specify the logic of the results, and the `make` program figures
    out the control flow to produce the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three fundamental control flow constructs: sequence, iteration, and
    selection. You’ve already seen sequence in the programs we’ve written thus far:
    each instruction, or subfunction, is executed in the order in which it’s written.
    In this chapter, I’ll show you how to alter the control flow from the written
    order to iterate the same block of written instructions or to select between several
    blocks of written instructions. You’ll see how each of these control flow constructs
    is implemented at the assembly language level. In [Chapter 14](ch14.xhtml), I’ll
    cover the details of altering control flow by calling a subfunction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Branches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *branch instruction* transfers control flow to the memory location specified
    by the instruction. There are two types of branches: unconditional and conditional.
    Both iteration and selection use conditional branches to alter control flow based
    on a true/false condition. You’ll also often use unconditional branches when implementing
    the iteration and selection flow constructs. We’ll start with those and then look
    at conditional branches.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Unconditional***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you learned in [Chapter 9](ch09.xhtml), when an instruction is executed,
    the CPU automatically increments the program counter, `pc`, by 4 to hold the address
    of the next instruction in memory. Instead of adding 4 to the program counter,
    an unconditional branch instruction changes the program counter to the branch
    target address, which causes the CPU to continue program execution at the target
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already learned about one unconditional branch instruction—`ret`, which
    is used to return from functions—in [Chapter 10](ch10.xhtml). There are two others,
    `b` and `br`:'
  prefs: []
  type: TYPE_NORMAL
- en: b**—Branch unconditionally**
  prefs: []
  type: TYPE_NORMAL
- en: '`b` label branches to the address of label within the range of ±128MB from
    this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: br**—Branch register unconditionally**
  prefs: []
  type: TYPE_NORMAL
- en: '`br x`s branches to the 64-bit address in `x`s.'
  prefs: []
  type: TYPE_NORMAL
- en: The `b` instruction is commonly used together with a conditional branch instruction
    to skip blocks of code or to go back to the beginning of a block of code and execute
    it again. For the `b` instruction, the CPU sign-extends the 26-bit word offset
    between the `b` instruction and label to 64 bits and adds this signed number to
    `pc`. The `br` instruction simply copies the 64 bits in `x`s to `pc`.
  prefs: []
  type: TYPE_NORMAL
- en: Although `br x30` would seem to have the same effect as `ret`, the `br` and
    `ret` instructions are not aliases for each other; they are different instructions.
    The difference is that `br` tells the CPU that this is probably *not* a function
    return, while `ret` tells the CPU that this probably *is* a function return. The
    details are beyond the scope of this book, but these hints can help the CPU optimize
    some of the specifics of executing instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Conditional***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two types of conditional branch instructions. One tests the settings
    of the condition flags in the `nzcv` register (see [Figure 9-4](ch09.xhtml#ch9fig4)
    in [Chapter 9](ch09.xhtml)). We need to use another instruction to set the flags
    before testing them to determine whether to branch or not.
  prefs: []
  type: TYPE_NORMAL
- en: The other type of conditional branch instruction tests the value in a register
    to determine whether to branch. Instructions in this group do not depend on the
    condition flags, nor do they change them.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with the instructions that branch according to the settings of the
    condition flags:'
  prefs: []
  type: TYPE_NORMAL
- en: b.cond**—Branch conditionally**
  prefs: []
  type: TYPE_NORMAL
- en: '`b.`cond label tests the settings in the `nzcv` register and branches to label
    if they match cond, in the range of ±128MB from this instruction. The possible
    values for cond are given in [Table 13-1](ch13.xhtml#ch13tab1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-1:** Allowable Branching Condition Codes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | cond | **Meaning** | **Condition flags** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0000` | `eq` | Equal | *Z* |'
  prefs: []
  type: TYPE_TB
- en: '| `0001` | `ne` | Not equal | ¬*Z* |'
  prefs: []
  type: TYPE_TB
- en: '| `0010` | `cs` or `hs` | Carry set; unsigned higher or same | *C* |'
  prefs: []
  type: TYPE_TB
- en: '| `0011` | `cc` or `lo` | Carry not set; unsigned lower | ¬*C* |'
  prefs: []
  type: TYPE_TB
- en: '| `0100` | `mi` | Minus; negative | *N* |'
  prefs: []
  type: TYPE_TB
- en: '| `0101` | `pl` | Plus; positive or zero | ¬*N* |'
  prefs: []
  type: TYPE_TB
- en: '| `0110` | `vs` | Overflow | *V* |'
  prefs: []
  type: TYPE_TB
- en: '| `0111` | `vc` | No overflow | ¬*V* |'
  prefs: []
  type: TYPE_TB
- en: '| `1000` | `hi` | Unsigned higher | *C* ∧ ¬*Z* |'
  prefs: []
  type: TYPE_TB
- en: '| `1001` | `ls` | Unsigned lower or same | ¬(*C* ∧ ¬*Z*) |'
  prefs: []
  type: TYPE_TB
- en: '| `1010` | `ge` | Signed greater than or equal | *N* = *V* |'
  prefs: []
  type: TYPE_TB
- en: '| `1011` | `lt` | Signed less than | ¬(*N* = *V* ) |'
  prefs: []
  type: TYPE_TB
- en: '| `1100` | `gt` | Signed greater than | ¬*Z* ∧ (*N* = *V* ) |'
  prefs: []
  type: TYPE_TB
- en: '| `1101` | `le` | Signed less than or equal | ¬(¬*Z* ∧ (*N* = *V* )) |'
  prefs: []
  type: TYPE_TB
- en: '| `1110` | `al` | Always | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `1111` | `nv` | Always | Any |'
  prefs: []
  type: TYPE_TB
- en: You should use the `b.`cond instruction when you want to take one of two branches
    in your program, depending on the result of another operation. It’s important
    that the `b.`cond instruction immediately follow the instruction whose result
    is driving the decision to branch. An intervening instruction or function call
    might change the settings of the condition flags, giving an erroneous basis for
    the decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, there are four instructions that branch depending on the
    value in a general-purpose register:'
  prefs: []
  type: TYPE_NORMAL
- en: cbz**—Compare and branch if zero**
  prefs: []
  type: TYPE_NORMAL
- en: '`cbz w`s`,` label branches to label if the value in `w`s is `0`, in the range
    of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cbz x`s`,` label branches to label if the value in `x`s is `0`, in the range
    of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: cbnz**—Compare and branch if not zero**
  prefs: []
  type: TYPE_NORMAL
- en: '`cbnz w`s`,` label branches to label if the value in `w`s is not `0`, in the
    range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cbnz x`s`,` label branches to label if the value in `x`s is not `0`, in the
    range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: tbz**—Test bit and branch if zero**
  prefs: []
  type: TYPE_NORMAL
- en: '`tbz w`s`,` imm`,` label branches to label if bit number imm in `w`s is `0`,
    in the range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tbz x`s`,` imm`,` label branches to label if bit number imm in `x`s is `0`,
    in the range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: tbnz**—Test bit and branch if not zero**
  prefs: []
  type: TYPE_NORMAL
- en: '`tbnz w`s`,` imm`,` label branches to label if bit number imm in `w`s is not
    `0`, in the range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tbnz x`s`,` imm`,` label branches to label if bit number imm in `x`s is not
    `0`, in the range of ±1MB from this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When using a conditional branch like* b.gt *or* b.le, *it’s easy to forget
    the order of the test: source compared to destination, or destination compared
    to source. When testing my program, I almost always start by using* gdb *and putting
    a breakpoint at the conditional branch instruction. When the program breaks, I
    check the values and use the* si *command to see which way the branch went.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to control the flow of instruction execution, I’ll show
    you some programming constructs. We’ll start with repetition. This can be implemented
    in two ways: *iteration*, in which the program loops through a block of code repeatedly
    until a condition is met, and *recursion*, where a function calls itself repeatedly
    until a condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover iteration in the next section and explain how recursion works when
    I discuss special uses of subfunctions in [Chapter 15](ch15.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Iteration**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many algorithms use iteration, also known as *looping*. A loop continues the
    iteration of a block of code until the value(s) of the *loop control variable(s)*
    meet a *termination condition* that causes the loop to end. With a looping construct,
    the value(s) of the loop control variable(s) must be changed within the iterated
    block of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a text string one character at a time provides a good example of
    looping. I will use the two system call functions from [Figure 2-1](ch02.xhtml#ch2fig1)
    in [Chapter 2](ch02.xhtml), `write` and `read`, to illustrate the concepts. That
    figure shows that `printf` converts data from its memory storage format to a character
    format and calls the `write` system call function to display the characters on
    the screen. When reading characters from the keyboard, `scanf` calls the `read`
    system call function and converts the characters to a memory storage format.
  prefs: []
  type: TYPE_NORMAL
- en: '***write and read System Call Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `write` and `read` system call functions see the screen and keyboard as
    files. When a program is first launched, the operating system opens three files—*standard
    input*, *standard output*, and *standard error*—and assigns an integer to each
    file, which is called the *file descriptor*. The program interacts with each file
    by using the file descriptor. The C interfaces for calling `write` and `read`
    are specified in the *Portable Operating System Interface (POSIX)* standard, which
    you can find at *[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)*.
  prefs: []
  type: TYPE_NORMAL
- en: The general formats for calling these two functions are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'where fd is the file descriptor, buf is the address of the character storage,
    and n is the number of characters to write or read. You can read more details
    in the man pages for `write` and `read`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 13-2](ch13.xhtml#ch13tab2) shows the file descriptors I’ll use and the
    device each is normally associated with.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-2:** The File Descriptors for the `write` and `read` System Call
    Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Number** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `STDIN_FILENO` | 0 | Read characters from the keyboard |'
  prefs: []
  type: TYPE_TB
- en: '| `STDOUT_FILENO` | 1 | Write characters to the screen |'
  prefs: []
  type: TYPE_TB
- en: '| `STDERR_FILENO` | 2 | Write error messages to the screen |'
  prefs: []
  type: TYPE_TB
- en: These names are defined in the system header file, *unistd.h*, which is located
    at */usr/include/unistd.h* on my Raspberry Pi O (note that the location on your
    system may be different). Now, let’s move on to looping constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '***while Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `while` loop is a fundamental form of looping. Here is the form in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before entering the `while` loop, you need to initialize the loop control variable.
    At the beginning of the `while` loop, expression is evaluated as a Boolean. If
    it evaluates to false (`0` in C), control flow continues to next statement. If
    expression evaluates to true—that is, any nonzero value in C—the statements in
    body are executed, the loop control variable is changed, and control flow continues
    at the top with the reevaluation of expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) shows the control flow of a `while` loop.
    Although the loop termination condition can be dependent on more than one variable,
    I’ll use just one here to clarify the discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg276_Image_274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The control flow of the* while *loop*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch13list1) shows how to use a `while` loop to write
    a text string in the terminal window one character at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: A program to write “Hello, World!” one character at a time*'
  prefs: []
  type: TYPE_NORMAL
- en: I use the `#define` directive to give a symbolic name to the `NUL` character
    ❶. The `message_ptr` variable is defined to be a pointer to a `char` type and
    is used as the loop control variable. It’s initialized to point to a text string
    ❷. As you’ll see when we look at the assembly language for this code, the compiler
    will store the text string in a read-only part of memory and store the address
    of the first character in that text string in the `message_ptr` pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` statement first checks to see if the loop control variable, `message_ptr`,
    is pointing to the `NUL` character ❸; if not, program flow enters the `while`
    loop body and writes the character pointed to by `message_ptr` to the screen ❹.
    The loop control variable is then incremented to point to the next character in
    the text string ❺. Program flow returns to the top of the loop, where the next
    character is checked to see if it’s the `NUL` character. This loop terminates
    when `message_ptr` points to the `NUL` character ❸. Testing for this condition
    first means the program won’t even enter the body of the `while` loop if the string
    is empty, as `message_ptr` will only point to a `NUL` character. This is a subtle
    but important point about `while` loops: the code in the body is never executed
    if the termination condition is already met.'
  prefs: []
  type: TYPE_NORMAL
- en: For [Listing 13-1](ch13.xhtml#ch13list1), the compiler generated the assembly
    language shown in [Listing 13-2](ch13.xhtml#ch13list2).
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: The compiler-generated assembly language for the function in
    [Listing 13-1](ch13.xhtml#ch13list1)*'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language shows that the text string is stored in the `.rodata`
    section ❶. Then, `message_ptr` is initialized to contain the address of the beginning
    of the text string ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Although this assembly language seems to be testing for the termination condition
    at the end of the loop ❹, it follows the logical flow shown in [Figure 13-1](ch13.xhtml#ch13fig1).
    It first branches down to `.L2` ❸, where the test is made for the terminating
    condition, before branching up to `.L3` to start execution of the body of the
    `while` loop ❺. You might notice that the compiler used a `bne` instruction. This
    is the same as `b.ne`; the `.` character is optional when writing the conditional
    branch instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new instruction, `cmp` ❹, in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: cmp**—Compare**
  prefs: []
  type: TYPE_NORMAL
- en: '`cmp` reg`,` imm subtracts imm from the value in reg and sets the condition
    flags accordingly. The result of the subtraction is discarded.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmp` reg1`,` reg2 subtracts the value in reg2 from the value in reg1 and sets
    the condition flags accordingly. The result of the subtraction is discarded.'
  prefs: []
  type: TYPE_NORMAL
- en: A `cmp` instruction immediately followed by a conditional branch instruction
    is commonly used to make decisions in a program.
  prefs: []
  type: TYPE_NORMAL
- en: For comparison with what the compiler did, we’ll follow the `while` loop pattern
    in my assembly language version, shown in [Listing 13-3](ch13.xhtml#ch13list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: An assembly language program to write Hello, World! one character
    at a time*'
  prefs: []
  type: TYPE_NORMAL
- en: We could have used a `cbz` instruction in our condition check instead of the
    `cmp` and `b.eq` sequence ❶, but I think the use of `NUL` here is clearer. This
    solution will also work for any terminating character.
  prefs: []
  type: TYPE_NORMAL
- en: My assembly language solution is less efficient than what the compiler generated
    ([Listing 13-2](ch13.xhtml#ch13list2)), because the `b` instruction is executed
    in addition to the conditional `b.eq` instruction with each iteration of the loop.
    The slight increase in execution time is usually worth the code readability improvement.
  prefs: []
  type: TYPE_NORMAL
- en: A `while` loop works well when a *sentinel value*, which is a unique value that
    marks the end of a data sequence, is used as the termination condition. For example,
    the `while` loop in [Listings 13-1](ch13.xhtml#ch13list1) and [13-3](ch13.xhtml#ch13list3)
    works for any length of text string and continues writing one character at a time
    to the screen until it reaches the sentinel value, a `NUL` character. C has another
    looping construct, the `for` loop, that many programmers find to be more natural
    for some algorithms; we’ll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: '***for Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although their C syntax differs, the looping constructs `while` and `for` are
    semantically equivalent. The syntactical difference is that the for *loop* allows
    you to group all three control elements—loop control variable initialization,
    checking, and changing—within the parentheses. The general form of a `for` loop
    in C is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing all the control elements within the parentheses is not required. In
    fact, we could also write a `for` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `for` loop syntax does require the inclusion of both semicolons
    in the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-4](ch13.xhtml#ch13list4), I have rewritten the program from [Listing
    13-1](ch13.xhtml#ch13list1) using a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world_for.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-4: A program to write Hello, World! using a* for *loop*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Since the* for *statement in this program controls only one C statement, you
    really don’t need the curly brackets around that statement. I usually include
    them anyway, because if I later modify the program and add another statement,
    I often forget that I then need the curly brackets.*'
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder if either looping construct is better than the other. Here’s
    where your knowledge of assembly language becomes useful. When I used `gcc` to
    generate the assembly language for [Listing 13-4](ch13.xhtml#ch13list4), I got
    the same assembly language code I did for the `while` loop version in [Listing
    13-1](ch13.xhtml#ch13list1). Since the assembly language for the `for` loop is
    shown in [Listing 13-2](ch13.xhtml#ch13list2), I won’t repeat it here.
  prefs: []
  type: TYPE_NORMAL
- en: The conclusion we can reach from this comparison of a `for` loop with a `while`
    loop is that you should use the high-level language looping construct that feels
    natural for the problem you’re solving. It’s usually a subjective choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop is often used for a *count-controlled loop*, in which the number
    of iterations is known before the loop is started. You’ll see an example of this
    usage in a moment, when we look at the selection constructs. First, though, let’s
    look at the third looping construct in C. This provides a different behavior:
    whereas the `while` loop and `for` loop constructs will skip the body of the loop
    if the termination conditions are met by the initial value of the loop control
    variable, it will always execute the loop body at least once.'
  prefs: []
  type: TYPE_NORMAL
- en: '***do-while Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In some situations, your algorithm needs to execute the body of the loop at
    least once. In these cases, the do-while *loop* may be more natural. It has the
    following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `do-while` looping construct, the value of the expression is computed
    at the end of the loop body. Looping continues until this evaluation results in
    a Boolean false.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-5](ch13.xhtml#ch13list5), I have rewritten the Hello, World!
    program using a `do-while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world_do.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-5: A program to write Hello, World! using a* do-while *loop*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This program has a potential bug! The* do-while *loop construct will always
    execute the body of the loop at least once. Consider an empty text string, which
    is a single byte containing the* NUL *character. A* do-while *loop writes the*
    NUL *character to the screen (which does nothing) and then checks the next byte
    in memory, which could be anything. If this byte is not a* NUL *character, the*
    do-while *loop will continue to execute, writing whatever characters this and
    the following bytes represent, until it reaches a* NUL *character. The behavior
    of the program could be different each time it’s run, so the error may not show
    up in your testing.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the assembly language generated by `gcc`, which is shown in [Listing
    13-6](ch13.xhtml#ch13list6), to illustrate the difference between the `do-while`
    construct and the `while` and `for` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world_do.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-6: The compiler-generated assembly language for the function in
    [Listing 13-5](ch13.xhtml#ch13list5)*'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the assembly language shown in [Listing 13-6](ch13.xhtml#ch13list6)
    with that in [Listing 13-2](ch13.xhtml#ch13list2), which shows the assembly language
    generated for both the `while` and `for` loops, you’ll see that the only difference
    is that the `do-while` loop doesn’t branch down to perform the loop control check
    ❷ before executing the loop for the first time ❶. The `do-while` construct might
    seem more efficient, but in the assembly language, the only saving is a single
    branch the first time the loop is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at how to select whether to execute a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1     Enter the three C programs in [Listings 13-1](ch13.xhtml#ch13list1),
    [13-4](ch13.xhtml#ch13list4), and [13-5](ch13.xhtml#ch13list5), and use the compiler
    to generate the assembly language for each of them. Compare the assembly language
    for the three looping constructs. Compilers change with version changes, so you
    should look at what your version of the compiler does.
  prefs: []
  type: TYPE_NORMAL
- en: '13.2     Write a program in assembly language that:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     Prompts the user to enter some text
  prefs: []
  type: TYPE_NORMAL
- en: (b)     Uses the `read` system call function to read the entered text
  prefs: []
  type: TYPE_NORMAL
- en: (c)     Echoes the user’s entered text in the terminal window
  prefs: []
  type: TYPE_NORMAL
- en: You will need to allocate space on the stack for storing the characters entered
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditionals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common flow construct is selection, where we determine whether to execute
    a block of code. I’ll start with the simplest case, determining whether to execute
    a single block based on a Boolean conditional statement, then I’ll show you how
    to use a Boolean conditional statement to select one of two blocks. I’ll end the
    chapter by discussing ways to select between several blocks based on an integral
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '***if***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general form of an if *conditional* in C is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The expression is evaluated as a Boolean. If it evaluates to false, or `0` in
    C, control flow continues to next statement. If expression evaluates to true (a
    nonzero value in C), the statements in block are executed, and control flow continues
    to next statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-7](ch13.xhtml#ch13list7) gives an example of an `if` statement
    that simulates flipping a coin 10 times and showing when it comes up heads.'
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips1.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-7: A program to flip a coin and show when it comes up heads*'
  prefs: []
  type: TYPE_NORMAL
- en: This program uses a count-controlled `for` loop to simulate flipping a coin
    10 times ❶. The simulation involves calling the `random` function in the C standard
    library ❷. If the random number is in the lower half of all possible values from
    the `random` function ❸, we call that “heads.” To display this result we use the
    `puts` function in the C standard library, which prints a simple text string to
    the screen with an appended newline character ❹. For [Listing 13-7](ch13.xhtml#ch13list7),
    the compiler generated the assembly language shown in [Listing 13-8](ch13.xhtml#ch13list8).
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips1.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-8: The compiler-generated assembly language for the function in
    [Listing 13-7](ch13.xhtml#ch13list7)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement is implemented with a simple conditional branch. If the condition—in
    this case, `bgt`, for branch if greater than ❶—is true, the program flow branches
    over the block of code that is controlled by the `if` statement ❷. Next, I’ll
    show you how to select between two different blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: '***if-then-else***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general form of an if-then-else *conditional* in C is as follows (C does
    not use a `then` keyword):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The expression is evaluated as a Boolean. If expression evaluates to true, the
    statements in then block are executed and control flow branches to next statement.
    If it evaluates to false (`0` in C), control flow branches to else block and then
    continues to next statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](ch13.xhtml#ch13fig2) shows the control flow of the `if-then-else`
    conditional.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg286_Image_275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: The control flow of an* if-then-else *conditional*'
  prefs: []
  type: TYPE_NORMAL
- en: The coin-flipping program in [Listing 13-7](ch13.xhtml#ch13list7) isn’t user-friendly
    because the user doesn’t know the total number of times the coin was flipped.
    We can improve the program by using an `if-then-else` conditional to print a message
    stating when the coin came up tails, as shown in [Listing 13-9](ch13.xhtml#ch13list9).
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-9: A program to flip a coin and declare it heads or tails*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-10](ch13.xhtml#ch13list10) shows the assembly language the compiler
    generates for [Listing 13-9](ch13.xhtml#ch13list9).'
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-10: The compiler-generated assembly language for the function in
    [Listing 13-9](ch13.xhtml#ch13list9)*'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language shows that we need an unconditional branch at the end
    of the `then` block ❶ to branch over the `else` block ❷.
  prefs: []
  type: TYPE_NORMAL
- en: My assembly language design of the coin-flipping program differs slightly, as
    shown in [Listing 13-11](ch13.xhtml#ch13list11).
  prefs: []
  type: TYPE_NORMAL
- en: '*coin_flips2.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-11: An assembly language design for the coin-flipping program*'
  prefs: []
  type: TYPE_NORMAL
- en: The `random` function returns a random number in the `w0` register. I leave
    it there for comparison with the halfway point, which I’ve loaded into the `w1`
    register ❶. The `w0` and `w1` registers don’t need to be saved in a function.
    The compiler used `w20` for the `random_number` variable, which does need to be
    saved.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding which registers to use for variables in a function, it’s important
    that you check the rules in [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml).
    That table says that a function must preserve the value in `x19` for the calling
    function. You can probably see the importance of having agreed-upon rules here.
    Not only must our function return to the calling function with its value in `x19`
    preserved, but we can assume that the functions that our function calls also preserve
    our value in `x19`. So, it’s safe to assume that the value remains the same through
    a function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'I won’t go into the details here, but if you need to select one of several
    blocks of code to execute, you can use the `else-if` statement in a *ladder construct*.
    The general form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `if-then-else` selection is based on a Boolean evaluation of the controlling
    expression, but as you’ll see in the next section, there are algorithms in which
    the selection is based on a discrete value, which is used to select one of several
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: '***switch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'C provides a switch *conditional*, where control flow branches to a place in
    a list of code blocks depending on the value of a selector. The general form of
    the `switch` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The selector can be any expression that evaluates to an integer. Each selector_1,
    selector_2, . . . , selector_n must be an integer constant. The `switch` will
    branch to the `case` whose selector_1, selector_2, . . . , selector_n is equal
    to the selector evaluation. If selector does not evaluate to any of the selector_1,
    selector_2, . . . , selector_n integers, the `switch` branches to `default`. After
    executing the corresponding block_1, block_2, . . . , block_n, program flow continues
    through the remaining blocks of code. A `break` statement at any place in the
    `switch` will exit the `switch` at that point and branch down to next statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-12](ch13.xhtml#ch13list12) shows how to use a `switch` statement
    in C.'
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-12: A* switch *statement*'
  prefs: []
  type: TYPE_NORMAL
- en: I want this program to execute only the case corresponding to the value of `i`.
    To prevent it from executing the following cases in the `switch`, I end each block
    with a `break` statement, which causes an exit from the `switch` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-13](ch13.xhtml#ch13list13) shows how the compiler implemented this
    `switch`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-13: Compiler-generated assembly language for the function in [Listing
    13-12](ch13.xhtml#ch13list12)*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-13](ch13.xhtml#ch13list13), the compiler creates two parts for
    the `switch`. The first part is the logic to decide which block of code to execute
    ❶. Depending on the value of the selector, this will transfer program flow to
    the correct block in the second part ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at another way to implement a `switch`: a *branch table*, also
    called a *jump table*. A branch table is a table of the block addresses that we
    need to select from. We need to design an algorithm that will select the correct
    address in the table, based on the value of the selector, and then branch to that
    address.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows one way to do this for our current
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: '*switch.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-14: An assembly language design for using a branch table*'
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in the branch table is the address of the code block to execute for
    the corresponding value of the selector variable. The `.quad` assembler directive
    tells the assembler to allocate 8 bytes of memory and initialize it to the value
    of the operand ❷. We’re using it to store the address of each of the code blocks
    our algorithm will select from. Since the items in our branch table are 64-bit
    addresses, we need to align the beginning of the table at a 64-bit address boundary
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm uses `x19` and `x20` as local variables, and the procedure call
    standard states that we need to save their contents for the calling function (see
    [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml)) ❸. We can also
    assume that their contents will be preserved by the functions we call from this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We need to determine which block address to load from the branch table. We start
    with the address of the beginning of the table ❹. Then, we compare the current
    value of `i`, in `x19`, with the number of the default case. If the value of `i`
    is lower than the default case, we’ll use the `csel` instruction to move that
    value into `x1`. If it’s the same or higher, the `csel` instruction moves the
    number of the default case in `x20` to `x1` ❹. Now that we have the case number
    in `x1`, we need to subtract 1 to get the offset in the table from the first item
    in the table ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to convert the case offset to an address offset so we can add
    it to the address of the beginning of the branch table. Each item in the branch
    table is 8 bytes wide. We use an option of the `add` instruction to shift the
    value of our offset, in `x1`, 3 bits to the left ❼. This multiplies the offset
    by 8 before adding it to the beginning address of the branch table, in `x0`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `x0` contains the address in the branch table of the item we want. We replace
    the address of the item with the item itself, which is the address of the block
    to execute ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `csel` instruction can be useful for a simple `if-then-else` construct
    when you’re selecting between two values in registers. It takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: csel**—Conditional select**
  prefs: []
  type: TYPE_NORMAL
- en: '`csel` reg1, reg2, reg3, cond tests the settings in the `nzcv` register and
    moves reg2 to reg1 if cond is true or moves reg3 to reg1 if cond is false.'
  prefs: []
  type: TYPE_NORMAL
- en: You now know two ways to implement a `switch` construct. It’s difficult to say
    whether a branch table is more efficient than an `if-else` ladder. For a large
    number of cases, an `if-else` ladder may require many tests before reaching the
    correct case to select. The efficiency also depends on things such as cache usage
    and the internal CPU design, and it can vary between CPU implementations that
    use the same instruction set. Any differences between the two techniques will
    probably be insignificant, so you should choose the one that seems to better match
    the problem you’re solving.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3     Change the assembly language program in [Listing 13-11](ch13.xhtml#ch13list11)
    so that it sees the lowest one-fourth and the highest one-fourth of the random
    numbers (`0` to `RAND_MAX/4` and `3*RAND_MAX/4` to `RAND_MAX`) as heads. It will
    see the middle half of the random numbers (`RAND_MAX/4` to `3*RAND_MAX/4`) as
    tails.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4     Remove the `break` statements in the program in [Listing 13-12](ch13.xhtml#ch13list12).
    How does this change the behavior of the program? Generate the assembly language
    from your changed program and compare it to that in [Listing 13-13](ch13.xhtml#ch13list13).
  prefs: []
  type: TYPE_NORMAL
- en: 13.5     Change the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses `if` conditionals instead of the `csel` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6     Rewrite the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses a ladder of `if-else` conditionals instead of a `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unconditional branch** Changes the program counter to alter the control flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional branch** Evaluates Boolean combinations of the status flags in
    the `nzcv` register and alters control flow if the combination evaluates to true.'
  prefs: []
  type: TYPE_NORMAL
- en: while **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  prefs: []
  type: TYPE_NORMAL
- en: for **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  prefs: []
  type: TYPE_NORMAL
- en: do-while **loop** Executes a block of code once and iterates it until a Boolean
    condition becomes false.
  prefs: []
  type: TYPE_NORMAL
- en: if **conditional** Checks for a Boolean condition and then executes a block
    of code if the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else **conditional** Checks for a Boolean condition and then executes
    one of two blocks of code, depending on whether the condition is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: switch **conditional** Evaluates an expression and then branches to a location
    in a list of blocks of code, depending on the integer value of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about control flow constructs and the `main` function, we’ll
    move on to discuss how to write your own subfunctions. In the next chapter, you’ll
    learn how to pass arguments and how to access those arguments in the subfunction.
  prefs: []
  type: TYPE_NORMAL
