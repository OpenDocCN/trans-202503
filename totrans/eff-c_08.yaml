- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INPUT/OUTPUT</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">输入/输出</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter will teach you how to perform input/output (I/O) operations to
    read data from, or write data to, terminals and filesystems. Information can enter
    a program via command line arguments or the environment and exit it via its return
    status. However, most information typically enters or exits a program through
    I/O operations. We’ll cover techniques that use C standard streams and POSIX file
    descriptors. We’ll start by discussing C standard text and binary streams. We’ll
    then cover different ways of opening and closing files using C standard library
    and POSIX functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何执行输入/输出（I/O）操作，从终端或文件系统读取数据或写入数据。信息可以通过命令行参数或环境进入程序，并通过返回状态退出程序。然而，大多数信息通常是通过I/O操作进入或退出程序的。我们将讨论使用C标准流和POSIX文件描述符的技术。我们将首先讨论C标准文本和二进制流。然后，我们将介绍使用C标准库和POSIX函数打开和关闭文件的不同方法。
- en: Next, we’ll discuss reading and writing characters and lines, reading and writing
    formatted text, and reading from and writing to binary streams. We’ll also cover
    stream buffering, stream orientation, and file positioning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论字符和行的读取与写入、格式化文本的读取与写入，以及从二进制流中读取和写入。我们还将涵盖流缓冲、流定向和文件定位。
- en: Many other devices and I/O interfaces (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ioctl</samp>)
    are available but are beyond the scope of this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他设备和I/O接口（例如<samp class="SANS_TheSansMonoCd_W5Regular_11">ioctl</samp>）可用，但它们超出了本书的范围。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Standard I/O Streams</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">标准I/O流</samp>
- en: C provides streams to communicate with files stored on supported, structured
    storage devices and terminals. A *stream* is a uniform abstraction for communicating
    with files and devices that consume or produce sequential data such as sockets,
    keyboards, Universal Serial Bus (USB) ports, and printers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C提供了与存储在受支持的结构化存储设备和终端上的文件进行通信的流。*流*是与文件和设备（如套接字、键盘、通用串行总线（USB）端口和打印机）通信的统一抽象，这些设备或文件消耗或生成顺序数据。
- en: C uses the opaque <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    data type to represent streams. A <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    object holds the internal state information for the connection to the associated
    file, including the file position indicator, buffering information, an error indicator,
    and an end-of-file indicator. You should never allocate a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    object yourself. C standard library functions operate on objects of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FILE *</samp> (that is, a pointer to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> type). As a result,
    streams are frequently referred to as *file pointers*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C使用不透明的<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>数据类型来表示流。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>对象保存与关联文件连接的内部状态信息，包括文件位置指示器、缓冲区信息、错误指示器和文件结束指示器。你不应该自己分配<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>对象。C标准库函数操作的是类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE
    *</samp>（即指向<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>类型的指针）的对象。因此，流通常被称为*文件指针*。
- en: C provides an extensive application programming interface (API), found in <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>, for operating on streams;
    we’ll explore this API later in this chapter. However, because these I/O functions
    need to work with a wide variety of devices and filesystems across many platforms,
    they’re highly abstracted, which makes them unsuitable for anything beyond the
    simplest applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C提供了一个广泛的应用程序接口（API），该接口可以在<samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>中找到，用于操作流；我们将在本章稍后探讨此API。然而，由于这些I/O函数需要与许多平台上各种各样的设备和文件系统协同工作，因此它们具有高度的抽象性，这使得它们不适用于超出最简单应用的场景。
- en: For example, the C standard has no concept of directories, because it must be
    able to work with nonhierarchical filesystems. The C standard makes few references
    to filesystem-specific details, like file permissions or locking. However, function
    specifications frequently state that certain behaviors happen “to the extent that
    the underlying system supports it,” meaning that they will occur only if they’re
    supported by your implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C标准没有目录的概念，因为它必须能够与非层次化的文件系统兼容。C标准对文件系统特定细节的引用较少，如文件权限或锁定。然而，函数规范通常指出，某些行为会在“底层系统支持的程度上”发生，这意味着只有在你的实现支持这些行为时，它们才会发生。
- en: As a result, you’ll generally need to use the less portable APIs provided by
    POSIX, Windows, and other platforms to perform I/O in real-world applications.
    Frequently, applications will define their own APIs that, in turn, rely on platform-specific
    APIs to provide safe, secure, and portable I/O operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你通常需要使用POSIX、Windows以及其他平台提供的较不便携的API来执行实际应用中的I/O操作。通常，应用程序会定义自己的API，这些API又依赖于平台特定的API来提供安全、可靠且便携的I/O操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Error and End-of-File
    Indicators</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">错误和文件结束指示符</samp>
- en: 'As just mentioned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    object holds the internal state information for the connection to the associated
    file, including an error indicator that records whether a read/write error has
    occurred and an end-of-file indicator that records whether the end of the file
    has been reached. When opened, the error and end-of-file indicators for the stream
    are cleared. The following C standard library functions all set the error indicator
    for the stream when an error occurs: the byte input functions (<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>),
    byte output functions (<samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>. Input functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    will also set the end-of-file indicator for the stream if the stream is at end-of-file.
    Certain functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp> clear the error
    indicator for the stream, and functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ungetc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    clear the end-of-file indicator for the stream. The wide character I/O functions
    behave similarly.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>对象保存与关联文件连接的内部状态信息，包括一个错误指示符，用于记录是否发生了读写错误，以及一个文件结束指示符，用于记录是否已到达文件末尾。文件打开时，流的错误指示符和文件结束指示符会被清除。以下C标准库函数会在发生错误时设置流的错误指示符：字节输入函数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>）、字节输出函数（<samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>。输入函数，如<sup class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>，如果流已到达文件末尾，也会设置流的文件结束指示符。某些函数，如<sup
    class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp>，会清除流的错误指示符，而函数如<sup
    class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ungetc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>，会清除流的文件结束指示符。宽字符I/O函数的行为类似。
- en: 'These indicators may be tested and cleared explicitly:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指示符可以显式测试和清除：
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ferror</samp> function tests
    the error indicator for the specified stream and returns nonzero if and only if
    the error indicator is set for the specified stream.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ferror</samp> 函数测试指定流的错误指示符，并且仅在指定流的错误指示符被设置时返回非零值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">feof</samp> function tests
    the end-of-file indicator for the specified stream and returns nonzero if and
    only if the end-of-file indicator is set for the specified stream.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">feof</samp> 函数测试指定流的文件结尾指示符，并且仅在指定流的文件结尾指示符被设置时返回非零值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> function clears
    the end-of-file and error indicators for the specified stream.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> 函数清除指定流的文件结尾和错误指示符。
- en: 'The following short program illustrates the interaction between these functions
    and the two indicators:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短程序展示了这些函数与两个指示符之间的交互：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This program produces the following output on <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在 <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> 上生成以下输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The loop terminates by end-of-file, after which the end-of-file indicator is
    set. Both indicators are cleared by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp>
    function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通过文件结尾终止，之后设置文件结尾指示符。这两个指示符会通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp>
    函数被清除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stream Buffering</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">流缓冲</samp>
- en: '*Buffering* is the process of temporarily storing data in memory that’s passing
    between a process and a device or file. Buffering improves the throughput of I/O
    operations, which often have high latencies per individual I/O operation with
    the system. Similarly, when a program requests to write to block-oriented devices
    like disks, the driver can cache the data in memory until it has accumulated enough
    data for one or more device blocks, at which point it writes the data all at once
    to the disk, improving throughput. This strategy is called *flushing* the output
    buffer.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲* 是将数据暂时存储在内存中的过程，数据在进程和设备或文件之间传递。缓冲提高了 I/O 操作的吞吐量，因为每个 I/O 操作通常会有较高的延迟。类似地，当程序请求写入块设备（如磁盘）时，驱动程序可以将数据缓存到内存中，直到累积足够的数据形成一个或多个设备块，此时会将数据一次性写入磁盘，从而提高吞吐量。这种策略称为*刷新*输出缓冲区。'
- en: 'A stream can be in one of three states:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流可以处于以下三种状态之一：
- en: '**Unbuffered** Characters are intended to appear from the source or at the
    destination as soon as possible. Streams where more than one program may be accessing
    the data concurrently are often best unbuffered. Streams used for error reporting
    or logging might be unbuffered.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**无缓冲** 字符旨在尽可能快地从源或到达目的地。通常多个程序可能并发访问的数据流，最好使用无缓冲模式。用于错误报告或日志记录的流也可能是无缓冲的。'
- en: '**Fully buffered** Characters are intended to be transmitted to or from the
    host environment as a block when a buffer is filled. Streams used for file I/O
    are normally fully buffered to optimize throughput.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**全缓冲** 字符被设计成在缓冲区填满时作为一个块传输到主机环境或从主机环境传输。用于文件 I/O 的流通常采用全缓冲方式，以优化吞吐量。'
- en: '**Line buffered** Characters are intended to be transmitted to or from the
    host environment as a block when a newline character is encountered. Streams connected
    to interactive devices such as terminals are line-buffered when you open them.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**行缓冲** 字符在遇到换行符时，旨在作为一个块传输到主机环境或从主机环境传输。连接到交互设备（如终端）的流在打开时通常采用行缓冲模式。'
- en: In the next section, we’ll introduce predefined streams and describe how they’re
    buffered.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍预定义流并描述它们是如何进行缓冲的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predefined Streams</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">预定义流</samp>
- en: 'A C program has three *predefined text streams* open and available for use
    on startup. These predefined streams are declared in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 C 程序在启动时会打开并可用三种 *预定义文本流*。这些预定义流在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    中声明：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The *standard output stream* (<samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>)
    is the conventional output destination from the program. This stream is usually
    associated with the terminal that initiated the program but can be redirected
    to a file or other stream. You can enter the following commands in a Linux or
    Unix shell:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输出流*（<samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>）是程序的传统输出目标。这个流通常与启动程序的终端相关联，但可以被重定向到文件或其他流。在Linux或Unix的shell中，你可以输入以下命令：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the output from the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp>
    command is redirected to *tempfile*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp>命令的输出被重定向到*tempfile*。
- en: 'The *standard input stream* (<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>)
    is the conventional input source for the program. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    is associated with the keyboard but may be redirected to input from a file, for
    example, with the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输入流*（<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>）是程序的传统输入源。默认情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>与键盘相关联，但也可以被重定向为来自文件的输入，例如，使用以下命令：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The contents of the file *tempfile* are redirected to the <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> command, which
    outputs the newline (1), word (7), and byte (34) counts from *tempfile.* The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    streams are fully buffered if and only if the stream doesn’t refer to an interactive
    device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*tempfile*的内容被重定向到<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>流，传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>命令，输出*tempfile*的换行符（1）、单词数（7）和字节数（34）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>流会在仅当流不指向交互式设备时，才完全缓冲。
- en: The *standard error stream* (<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>)
    is for writing diagnostic output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    stream isn’t fully buffered so that error messages can be viewed as soon as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准错误流*（<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>）用于写入诊断输出。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>流不会完全缓冲，以便尽快查看错误信息。'
- en: '[Figure 8-1](chapter8.xhtml#fig8-1) shows the predefined streams <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    attached to the keyboard and display of the user’s terminal.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](chapter8.xhtml#fig8-1)显示了预定义的流<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>，它们附加在用户终端的键盘和显示器上。'
- en: '![](../images/f08001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f08001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Standard streams
    attached to I/O communication channels</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-1：附加到I/O通信通道的标准流</samp>
- en: 'The output stream of one program can be redirected to be another application’s
    input stream by using POSIX pipes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序的输出流可以通过使用POSIX管道被重定向到另一个应用程序的输入流：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The stream editor <samp class="SANS_TheSansMonoCd_W5Regular_11">sed</samp> is
    a Unix utility used for filtering and transforming text. The vertical bar character
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) is available on many
    platforms to chain commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 流编辑器<samp class="SANS_TheSansMonoCd_W5Regular_11">sed</samp>是一个用于过滤和转换文本的Unix工具。竖线字符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">|</samp>）在许多平台上可用于链式命令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stream Orientation</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">流方向</samp>
- en: Each stream has an *orientation* that indicates whether the stream contains
    narrow or wide characters. After a stream is associated with an external file,
    but before any operations are performed on it, the stream doesn’t have an orientation.
    Once a wide-character I/O function has been applied to a stream without orientation,
    the stream becomes a *wide-oriented stream*. Similarly, once a byte I/O function
    has been applied to a stream without orientation, the stream becomes a *byte-oriented
    stream*. Multibyte character sequences or narrow characters that can be represented
    as an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    (which are required by the C standard to be 1 byte) can be written to a byte-oriented
    stream.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流都有一个*方向*，它表示该流是包含窄字符还是宽字符。在一个流与外部文件关联之后，但在进行任何操作之前，该流没有方向。一旦应用了宽字符I/O函数到一个没有方向的流，该流就变成了*宽字符导向流*。类似地，一旦应用了字节I/O函数到一个没有方向的流，该流就变成了*字节导向流*。可以作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型对象表示的多字节字符序列或窄字符（根据C标准，这些字符需要占用1个字节）可以写入字节导向流中。
- en: You can reset the orientation of a stream by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwide</samp>
    function or by closing and then reopening the file. Applying a byte I/O function
    to a wide-oriented stream or a wide-character I/O function to a byte-oriented
    stream results in undefined behavior. Never mix narrow-character data, wide-character
    data, and binary data in the same file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fwide</samp> 函数或者通过关闭并重新打开文件来重置流的方向。如果对宽字符流应用字节I/O函数，或者对字节导向流应用宽字符I/O函数，将导致未定义的行为。永远不要将窄字符数据、宽字符数据和二进制数据混合存储在同一文件中。
- en: All three predefined streams (<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>)
    are unoriented at program startup.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种预定义流（<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>）在程序启动时都是无方向的。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Text and Binary
    Streams</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">文本流与二进制流</samp>'
- en: The C standard supports both text streams and binary streams. A *text stream*
    is an ordered sequence of characters composed into lines, each of which consists
    of zero or more characters plus a terminating newline character sequence. You
    can denote a single line break on a Unix-like system by using a line feed (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>). Most Microsoft Windows programs
    use a carriage return (<samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>)
    followed by a line feed (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C标准支持文本流和二进制流。*文本流* 是由字符组成的有序序列，字符按行排列，每行由零个或多个字符及一个终止换行符序列组成。在类Unix系统中，你可以使用换行符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>）表示单一的换行。大多数微软Windows程序使用回车符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>）后跟换行符（<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>）。
- en: The different newline conventions can cause text files that have been transferred
    between systems with different conventions to display or parse incorrectly, though
    this is increasingly uncommon on recent systems that now understand foreign newline
    conventions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的换行符约定可能导致在不同约定的系统之间传输的文本文件显示或解析不正确，尽管在现代系统中这种情况已经变得不常见，因为这些系统现在能够理解外部的换行符约定。
- en: A *binary stream* is an ordered sequence of arbitrary binary data. Data read
    in from a binary stream will be the same as data written out earlier to that same
    stream, under the same implementation. On non-POSIX systems, streams may have
    an implementation-defined number of null bytes appended to the end of the stream.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制流* 是一种有序的任意二进制数据序列。从二进制流读取的数据将与之前写入该流的数据相同，在相同的实现下也是如此。在非POSIX系统中，流的末尾可能会附加由实现定义的数量的空字节。'
- en: Binary streams are always more capable and more predictable than text streams.
    However, the easiest way to read or write an ordinary text file that can work
    with other text-oriented programs is through a text stream.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制流总是比文本流更强大、更可预测。然而，读取或写入一个普通的文本文件，且能与其他文本导向的程序兼容，最简单的方法是通过文本流。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Opening and Creating Files</samp>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">打开和创建文件</samp>
- en: When you open or create a file, it’s associated with a stream. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp>
    and the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> functions
    open or create a file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开或创建一个文件时，它会与一个流关联。<samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp>
    和 POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数用于打开或创建文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fopen</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fopen</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> function opens
    the file whose name is given as a string and pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    and then associates a stream with it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> 函数打开一个文件，该文件的名称由字符串给出并由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> 指向，然后将一个流与之关联：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument points
    to one of the strings shown in [Table 8-1](chapter8.xhtml#tab8-1) to determine
    how to open the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> 参数指向[表 8-1](chapter8.xhtml#tab8-1)中显示的字符串之一，用于确定如何打开文件。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Valid
    File Mode Strings</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-1：</samp> <samp class="SANS_Futura_Std_Book_11">有效的文件模式字符串</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Mode string</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">模式字符串</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    existing text file for reading</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> | <samp class="SANS_Futura_Std_Book_11">打开现有文本文件以供读取</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> | <samp class="SANS_Futura_Std_Book_11">Truncate
    to zero length or create text file for writing</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> | <samp class="SANS_Futura_Std_Book_11">截断为零长度或创建文本文件以供写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> | <samp class="SANS_Futura_Std_Book_11">Append,
    open, or create text file for writing at end-of-file</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> | <samp class="SANS_Futura_Std_Book_11">附加、打开或创建文本文件以在文件末尾写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">rb</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    existing binary file for reading</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">rb</samp> | <samp class="SANS_Futura_Std_Book_11">打开现有二进制文件以供读取</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> | <samp class="SANS_Futura_Std_Book_11">Truncate
    file to zero length or create binary file for writing</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> | <samp class="SANS_Futura_Std_Book_11">截断文件为零长度或创建二进制文件以供写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ab</samp> | <samp class="SANS_Futura_Std_Book_11">Append,
    open, or create binary file for writing at end-of-file</samp> |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ab</samp> | <samp class="SANS_Futura_Std_Book_11">附加、打开或创建二进制文件以在文件末尾写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r+</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    existing text file for reading and writing</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r+</samp> | <samp class="SANS_Futura_Std_Book_11">打开现有文本文件以供读写</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+</samp> | <samp class="SANS_Futura_Std_Book_11">Truncate
    to zero length or create text file for reading and writing</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+</samp> | <samp class="SANS_Futura_Std_Book_11">截断为零长度或创建文本文件以供读写</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a+</samp> | <samp class="SANS_Futura_Std_Book_11">Append,
    open, or create text file for update, writing at current end-of-file</samp> |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a+</samp> | <samp class="SANS_Futura_Std_Book_11">附加、打开或创建文本文件以供更新，在文件当前末尾写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rb+</samp> | <samp class="SANS_Futura_Std_Book_11">Open
    existing binary file for reading and writing</samp> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">r+b</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rb+</samp> | <samp class="SANS_Futura_Std_Book_11">打开现有二进制文件以供读写</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wb+</samp> | <samp class="SANS_Futura_Std_Book_11">Truncate
    to zero length or create binary file for reading and writing</samp> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+b</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wb+</samp> | <samp class="SANS_Futura_Std_Book_11">截断为零长度或创建用于读取和写入的二进制文件</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ab+</samp> | <samp class="SANS_Futura_Std_Book_11">Append,
    open, or create binary file for update, writing at current end-of-file</samp>
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">a+b</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ab+</samp> | <samp class="SANS_Futura_Std_Book_11">追加，打开或创建用于更新的二进制文件，在当前文件末尾写入</samp>
    |'
- en: Opening a file with read mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>
    as the first character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    argument) fails if the file doesn’t exist or cannot be read.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以读取模式打开文件（通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> 作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> 参数的第一个字符传递）会失败，如果文件不存在或无法读取。
- en: Opening a file with append mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    as the first character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    argument) causes all subsequent writes to the file to occur at the current end-of-file
    at the point of buffer flush or actual write, regardless of intervening calls
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> functions. Incrementing
    the current end-of-file by the amount of data written is atomic with respect to
    other threads writing to the same file provided the file was also opened in append
    mode. If the implementation is incapable of incrementing the current end-of-file
    atomically, it will fail instead of performing nonatomic end-of-file writes. In
    some implementations, opening a binary file with append mode (by passing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as the second or third character
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument) may
    initially set the file position indicator for the stream beyond the last data
    written because of null character padding.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以追加模式打开文件（通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> 参数的第一个字符传递）会导致所有后续写入文件的操作发生在当前文件末尾，直到缓冲区刷新或实际写入时，无论是否有对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> 函数的调用。将当前文件末尾的指针按写入的数据量递增是原子性的，只要文件也以追加模式打开，并且其他线程在写入同一文件时不干扰。如果实现无法原子地递增当前文件末尾，它将失败，而不是进行非原子性写入。在某些实现中，以追加模式打开二进制文件（通过将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    参数的第二个或第三个字符传递）可能会由于空字符填充而将文件位置指示器设置在最后一个数据写入之后。
- en: You can open a file in update mode by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    as the second or third character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    argument, allowing both read and write operations to be performed on the associated
    stream. Opening (or creating) a text file with update mode may instead open (or
    create) a binary stream in some implementations. On POSIX systems, text and binary
    streams have the exact same behavior.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    参数的第二个或第三个字符传递来以更新模式打开文件，从而可以对相关流执行读取和写入操作。在某些实现中，以更新模式打开（或创建）文本文件可能会改为打开（或创建）二进制流。在
    POSIX 系统中，文本流和二进制流的行为完全相同。
- en: The C11 standard added the *exclusive mode* for reading and writing binary and
    text files, as shown in [Table 8-2](chapter8.xhtml#tab8-2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C11 标准增加了*独占模式*，用于读取和写入二进制文件和文本文件，如 [表 8-2](chapter8.xhtml#tab8-2) 所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp> <samp class="SANS_Futura_Std_Book_11">Valid
    File Mode Strings Added by C11</samp>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-2：</samp> <samp class="SANS_Futura_Std_Book_11">C11
    添加的有效文件模式字符串</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Mode string</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">模式字符串</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">wx</samp> | <samp class="SANS_Futura_Std_Book_11">Create
    exclusive text file for writing</samp> |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| < sAmp class="SANS_TheSansMonoCd_W5Regular_11">wx</samp> | < sAmp class="SANS_Futura_Std_Book_11">创建独占文本文件用于写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">wbx</samp> | <samp class="SANS_Futura_Std_Book_11">Create
    exclusive binary file for writing</samp> |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| < sAmp class="SANS_TheSansMonoCd_W5Regular_11">wbx</samp> | < sAmp class="SANS_Futura_Std_Book_11">创建独占二进制文件用于写入</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+x</samp> | <samp class="SANS_Futura_Std_Book_11">Create
    exclusive text file for reading and writing</samp> |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| < sAmp class="SANS_TheSansMonoCd_W5Regular_11">w+x</samp> | < sAmp class="SANS_Futura_Std_Book_11">创建独占文本文件用于读写</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">w+bx</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wb+x</samp> | <samp class="SANS_Futura_Std_Book_11">Create
    exclusive binary file for reading and writing</samp> |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| < sAmp class="SANS_TheSansMonoCd_W5Regular_11">w+bx</samp> < sAmp class="SANS_Futura_Std_Book_11">或</samp>
    < sAmp class="SANS_TheSansMonoCd_W5Regular_11">wb+x</samp> | < sAmp class="SANS_Futura_Std_Book_11">创建独占二进制文件用于读写</samp>
    |'
- en: Opening a file with exclusive mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    as the last character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    argument) fails if the file already exists or cannot be created. The check for
    the existence of the file and the creation of the file if it doesn’t exist are
    atomic with respect to other threads and concurrent program executions. If the
    implementation is incapable of performing the check for the existence of the file
    and the creation of the file atomically, it fails rather than perform a nonatomic
    check and creation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以独占模式打开文件（通过在< sAmp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> 参数的最后一个字符传递
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>）如果文件已存在或无法创建则会失败。文件存在性的检查和如果文件不存在则创建文件的操作是原子性的，涉及到其他线程和并发程序执行。如果实现无法原子地执行文件存在性检查和文件创建，它会失败，而不是进行非原子检查和创建。
- en: 'As a final note, make sure that you never copy a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    object. The following program, for example, can fail because a by-value copy of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> is being used in the
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp>:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保永远不要复制一个 < sAmp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> 对象。例如，下面的程序可能会失败，因为在调用
    < sAmp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp> 时，使用了 < sAmp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    的按值复制：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This program has undefined behavior and typically crashes when run.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序具有未定义的行为，通常会在运行时崩溃。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">open</samp>
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: < sAmp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">open</samp>
- en: 'On POSIX systems, the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    function (IEEE Std 1003.1:2018) establishes the connection between a file identified
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and a value called
    a *file descriptor*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX 系统中，< sAmp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数（IEEE
    Std 1003.1:2018）建立了文件 < sAmp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    与一个叫做 *文件描述符* 的值之间的连接：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *file descriptor* is a nonnegative integer that refers to the structure
    representing the file (called the *open file description*). The file descriptor
    returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function
    is the lowest numbered unused file descriptor and is unique to the calling process.
    The file descriptor is used by other I/O functions to refer to that file. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function sets the file
    offset used to mark the current position within the file to the beginning of the
    file. For a file descriptor underlying a stream, this file offset is separate
    from the stream’s file position indicator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件描述符* 是一个非负整数，指向表示文件的结构（称为 *打开文件描述*）。由< sAmp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    函数返回的文件描述符是未使用的最低编号文件描述符，并且是唯一的，属于调用该函数的进程。文件描述符被其他 I/O 函数用来引用该文件。< sAmp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    函数将文件偏移量设置为标记文件内当前的位置，从文件的开始位置开始。对于一个流的文件描述符，这个文件偏移量与流的文件位置指示器是分开的。'
- en: 'The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>
    parameter sets the open file description’s *file access modes*, which specify
    whether the file is being opened for reading, writing, or both. Values for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> are constructed by a bitwise-inclusive
    OR of a file access mode and any combination of access flags. Applications must
    specify exactly one of the following file access modes in the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 参数的值设置了打开文件描述符的 *文件访问模式*，指定文件是以读取、写入还是两者同时进行打开。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 的值是通过按位或操作组合文件访问模式和任何访问标志。应用程序必须在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 的值中指定以下文件访问模式之一：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXEC </samp> Open for execute
    only (nondirectory files)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXEC </samp> 仅用于执行（非目录文件）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDONLY </samp>Open for reading
    only
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDONLY </samp>仅用于读取
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDWR </samp>Open for reading
    and writing
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDWR </samp>同时用于读取和写入
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_SEARCH</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11"> </samp>Open
    directory for search only
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_SEARCH</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11"> </samp>仅用于搜索的目录打开
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_WRONLY </samp>Open for writing
    only
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_WRONLY </samp>仅用于写入
- en: 'The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>
    parameter also sets the *file status flags*, which control the behavior of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function and affect
    how file operations are performed. These flags include the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 参数的值还设置了 *文件状态标志*，这些标志控制
    <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数的行为，并影响文件操作的执行方式。这些标志包括以下内容：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_APPEND</samp> Sets the file offset
    to the end-of-file prior to each write
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_APPEND</samp> 在每次写入之前，将文件偏移量设置为文件末尾
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_TRUNC</samp> Truncates the length
    to 0
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_TRUNC</samp> 将文件长度截断为 0
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_CREAT</samp> Creates a file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_CREAT</samp> 创建文件
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXCL</samp> Causes the open to
    fail if <samp class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp> is also set
    and the file exists
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXCL</samp> 如果同时设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp>
    并且文件已存在，则导致打开失败
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function takes
    a variable number of arguments. The value of the argument following the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> argument specifies the file-mode
    bits (the file permissions when you create a new file) and is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">mode_t</samp>.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数接受可变数量的参数。紧随 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 参数后的值指定文件模式位（当创建新文件时的文件权限），类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mode_t</samp>。
- en: '[Listing 8-1](chapter8.xhtml#Lis8-1) shows an example of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    function to open a file for writing.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](chapter8.xhtml#Lis8-1) 展示了一个使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    函数打开文件进行写入的示例。'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: Opening a file
    as write-only</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-1：以写入模式打开文件</samp>
- en: 'The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> ❷ takes
    multiple arguments, including the pathname of the file, the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>,
    and the mode. We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    flag ❶ that is a bitwise-inclusive OR of the following mode bits for access permission:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> ❷ 时需要多个参数，包括文件的路径名、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> 和模式。我们创建了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp>
    标志 ❶，它是以下访问权限模式位的按位或组合：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRUSR </samp>Read permission
    bit for the owner of the file
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRUSR </samp>文件所有者的读取权限位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IWUSR </samp>Write permission
    bit for the owner of the file
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IWUSR </samp>文件所有者的写权限位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRGRP </samp>Read permission
    bit for the group owner of the file
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRGRP </samp>文件组所有者的读权限位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IROTH </samp>Read permission
    bit for other users
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IROTH </samp>其他用户的读权限位
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function sets
    these permissions only if it creates the file. If the file already exists, its
    current permissions are kept. The file access mode is <samp class="SANS_TheSansMonoCd_W5Regular_11">O_WRONLY</samp>,
    which means the file is opened for writing only. The <samp class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp>
    file status flag informs <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    to create the file; the <samp class="SANS_TheSansMonoCd_W5Regular_11">O_TRUNC</samp>
    file status flag informs <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    that if the file exists and is successfully opened, it should discard the previous
    contents of the file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数仅在创建文件时设置这些权限。如果文件已存在，它的当前权限将保持不变。文件访问模式为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">O_WRONLY</samp>，表示文件仅用于写入。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp> 文件状态标志通知 <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    创建该文件；<samp class="SANS_TheSansMonoCd_W5Regular_11">O_TRUNC</samp> 文件状态标志通知 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 如果文件存在且成功打开，应丢弃文件的先前内容。
- en: If the file was successfully opened, the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    function returns a nonnegative integer representing the file descriptor. Otherwise,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> returns −1 and sets
    <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp> to indicate the error.
    [Listing 8-1](chapter8.xhtml#Lis8-1) checks for a value of −1, writes a diagnostic
    message to the predefined <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    stream if an error occurred, and then exits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件成功打开，<samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 函数返回一个非负整数，表示文件描述符。否则，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">open</samp> 返回 −1，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>
    设置为指示错误的值。[Listing 8-1](chapter8.xhtml#Lis8-1) 检查是否返回 −1，如果发生错误，则将诊断消息写入预定义的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> 流，并退出。
- en: In addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>, POSIX
    has other useful functions for working with file descriptors, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fileno</samp> function to get the file
    descriptor associated with an existing file pointer and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp>
    function to create a new stream file pointer from an existing file descriptor.
    POSIX APIs available through the file descriptor allow access to features of POSIX
    filesystems that aren’t normally exposed through the file pointer interfaces such
    as directories (<samp class="SANS_TheSansMonoCd_W5Regular_11">posix_getdents</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopendir</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">readdir</samp>),
    file permissions (<samp class="SANS_TheSansMonoCd_W5Regular_11">fchmod</samp>),
    and file locks (<samp class="SANS_TheSansMonoCd_W5Regular_11">fcntl</samp>).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>，POSIX 还提供了其他有用的函数来处理文件描述符，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fileno</samp> 函数用于获取与现有文件指针关联的文件描述符，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp> 函数用于通过现有的文件描述符创建一个新的流文件指针。通过文件描述符提供的
    POSIX API 允许访问 POSIX 文件系统的功能，这些功能通常不会通过文件指针接口暴露出来，例如目录（<samp class="SANS_TheSansMonoCd_W5Regular_11">posix_getdents</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdopendir</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">readdir</samp>）、文件权限（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fchmod</samp>）和文件锁（<samp class="SANS_TheSansMonoCd_W5Regular_11">fcntl</samp>）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Closing Files</samp>
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">关闭文件</samp>
- en: Opening a file allocates resources. If you continually open files without closing
    them, you’ll eventually run out of file descriptors or handles available for your
    process, and attempting to open more files will fail. Consequently, it’s important
    to close files after you’ve finished using them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件会分配资源。如果你不断地打开文件却没有关闭它们，最终你的进程将用尽可用的文件描述符或句柄，尝试打开更多文件时将会失败。因此，使用完文件后关闭文件是非常重要的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fclose</samp>
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fclose</samp>
- en: 'The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    function closes the file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库中的<samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>函数用于关闭文件：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any unwritten buffered data for the stream is delivered to the host environment
    to be written to the file. Any unread buffered data is discarded.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 流中任何未写入的缓冲数据将传递给主机环境，写入文件中。任何未读取的缓冲数据将被丢弃。
- en: It’s possible for the <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    function to fail. When <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    writes the remaining buffered output, for example, it might return an error because
    the disk is full. Even if you know the buffer is empty, errors can still occur
    when closing a file if you’re using the Network File System (NFS) protocol. Despite
    the possibility of failure, recovery is often impossible, so programmers commonly
    ignore errors returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>.
    When closing the file fails, a common practice is to abort the process or to truncate
    the file so its contents are meaningful when next read.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>函数可能会失败。例如，当<fclose</samp>写入剩余的缓冲输出时，可能会因为磁盘已满而返回错误。即使你知道缓冲区已空，如果使用网络文件系统（NFS）协议关闭文件时，仍然可能发生错误。尽管可能会失败，但通常无法恢复，因此程序员通常忽略<fclose</samp>返回的错误。关闭文件失败时，一种常见的做法是中止进程或截断文件，使其内容在下次读取时仍然有意义。
- en: 'To ensure your code is robust, make sure you check for errors. File I/O can
    fail for any number of reasons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if any
    errors were detected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的代码稳健，务必检查错误。文件I/O可能由于各种原因失败。如果检测到错误，<samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>函数会返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You need to explicitly call <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> on any buffered
    stream the program has written to, instead of letting <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>
    (or a return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>) flush
    it, to perform the error checking.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要显式调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>，以刷新程序写入的任何缓冲流，而不是让<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>（或从<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>返回）来刷新它，以执行错误检查。
- en: The value of a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>
    object is indeterminate after the associated file is closed. Whether a file of
    zero length (in which an output stream hasn’t written any data) exists is implementation
    defined.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关文件被关闭后，指向<samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp>对象的指针值是未定义的。是否存在一个零长度的文件（即没有写入任何数据的输出流）由实现定义。
- en: You can reopen a closed file in the same program or another one, and its contents
    can be reclaimed or modified. If the initial call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function returns or if the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>
    function is called, all open files close (and all output streams are flushed)
    before program termination.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一程序或另一个程序中重新打开已关闭的文件，并且可以恢复或修改其内容。如果初始调用的<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数返回或调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>函数，所有打开的文件会在程序终止前关闭（并且所有输出流会被刷新）。
- en: Other paths to program termination, such as calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp>
    function, may not close all files properly, which means that buffered data not
    yet written to a disk might be lost.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 程序终止的其他路径，例如调用<samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp>函数，可能无法正确关闭所有文件，这意味着尚未写入磁盘的缓冲数据可能会丢失。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">close</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">close</samp>
- en: 'On POSIX systems, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>
    function to deallocate the file descriptor specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">fd</samp>:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在POSIX系统上，你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>函数来释放由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fd</samp>指定的文件描述符：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If an I/O error occurred while reading from or writing to the filesystem during
    <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>, it may return −1 with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp> set to the cause of
    failure. If an error is returned, the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">fd</samp>
    is unspecified, meaning you can no longer read or write data to the descriptor
    or attempt to close it again—effectively leaking the file descriptor. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">posix_close</samp> function is being added
    to The Open Group Base Specifications Issue 8 to address this problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> 时，从文件系统读取或写入数据发生
    I/O 错误，可能会返回 −1，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>
    会被设置为错误原因。如果返回错误，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">fd</samp> 的状态是未定义的，这意味着你无法再读取或写入数据到该描述符，也不能再次尝试关闭它——这实际上导致文件描述符泄漏。为了解决这个问题，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">posix_close</samp> 函数已被添加到《开放组基础规范》第 8
    版中。
- en: Once a file is successfully closed, the file descriptor no longer exists, because
    the integer corresponding to it no longer refers to a file. Files are also closed
    when the process owning that file descriptor terminates.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件成功关闭，文件描述符将不再存在，因为与其对应的整数不再指向任何文件。当拥有该文件描述符的进程终止时，文件也会被关闭。
- en: Except in rare circumstances, an application that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp>
    to open a file will use <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    to close it; an application that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    to open a file will use <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>
    to close it (unless it passed the descriptor to <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp>,
    in which case it must close by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose)</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在极少数情况下，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> 打开文件的应用程序会使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> 来关闭文件；使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    打开文件的应用程序会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> 来关闭文件（除非它将描述符传递给了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp>，在这种情况下，它必须通过调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> 来关闭文件）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing Characters and Lines</samp>
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">读取和写入字符与行</samp>
- en: The C standard defines functions for reading and writing specific characters
    or lines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准定义了用于读取和写入特定字符或行的函数。
- en: Most byte stream functions have counterparts that take a wide character (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>) or wide-character string
    instead of a narrow character (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>)
    or string, respectively (see [Table 8-3](chapter8.xhtml#tab8-3)). Byte-stream
    functions are declared in the header file <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>,
    and the wide-stream functions are declared in <samp class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp>.
    The wide-character functions operate on the same streams (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数字节流函数都有相应的版本，可以使用宽字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>）或宽字符字符串来替代窄字符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>）或字符串（参见 [表 8-3](chapter8.xhtml#tab8-3)）。字节流函数在头文件
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp> 中声明，而宽字符流函数在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp> 中声明。宽字符函数在相同的流（例如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>）上操作。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow-
    and Wide-String I/O Functions</samp>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-3：</samp> <samp class="SANS_Futura_Std_Book_11">窄字符与宽字符
    I/O 函数</samp>
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads a character from a stream.</samp>
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">从流中读取一个字符。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">getwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads a character from a stream.</samp>
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">getwchar</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads a character from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetws</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads a line from a stream.</samp> |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fputwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">Writes a character to a stream.</samp>
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">putwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">Writes a character to a stream.</samp>
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fputws</samp>
    | <samp class="SANS_Futura_Std_Book_11">Writes a string to a stream.</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">putwchar</samp>
    | <samp class="SANS_Futura_Std_Book_11">Writes a character to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    | <samp class="SANS_Futura_Std_Book_11">Writes a string to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ungetc</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ungetwc</samp>
    | <samp class="SANS_Futura_Std_Book_11">Returns a character to a stream.</samp>
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">scanf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wscanf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads formatted character input from</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fwscanf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads formatted character input from a
    stream.</samp> |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sscanf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">swscanf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Reads formatted character input from a
    buffer.</samp> |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wprintf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Prints formatted character output to</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">fprintf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">fwprintf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Prints formatted character output to a
    stream.</samp> |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">swprintf</samp>
    | <samp class="SANS_Futura_Std_Book_11">Prints formatted character output to a
    buffer.</samp> |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">snprintf</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    | <samp class="SANS_Futura_Std_Book_11">This is the same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp>
    <samp class="SANS_Futura_Std_Book_11">with truncation. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">swprintf</samp>
    <samp class="SANS_Futura_Std_Book_11">function also takes a length argument but
    behaves</samp> <samp class="SANS_Futura_Std_Book_11">differently from</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">snprintf</samp> <samp class="SANS_Futura_Std_Book_11">in
    the way it interprets it.</samp> |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: In this chapter, we’ll discuss the byte-stream functions only. You may want
    to avoid wide-character function variants altogether and work exclusively with
    UTF-8 character encodings, if possible, as these functions are less prone to programmer
    error and security vulnerabilities.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function converts
    the character <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> to the type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and writes
    it to <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if a write
    error occurs; otherwise, it returns the character it has written.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> function is just
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>, except that most
    libraries implement it as a macro:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> is implemented
    as a macro, it may evaluate its <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>
    argument more than once. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>
    is generally safer. See CERT C rule FIO41-C, “Do not call <samp class="SANS_TheSansMonoCd_W5Regular_11">getc()</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">putc()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">getwc()</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">putwc()</samp> with a stream
    argument that has side effects,” for more information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp> function is
    equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> function,
    except that it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    as the value of the stream argument.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>函数等同于<samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp>函数，不同之处在于它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>作为流参数的值。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp> function writes
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to the stream
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp>函数将字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>写入流<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function doesn’t write the null character from the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—nor
    does it write a newline character—but outputs only the characters in the string.
    If a write error occurs, <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. Otherwise, it
    returns a nonnegative value. For example, the following statements output the
    text <samp class="SANS_TheSansMonoCd_W5Regular_11">I am Groot</samp>, followed
    by a newline:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不会写入字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>中的空字符，也不会写入换行符，而只输出字符串中的字符。如果发生写入错误，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>。否则，它将返回一个非负值。例如，以下语句输出文本<samp
    class="SANS_TheSansMonoCd_W5Regular_11">I am Groot</samp>，后跟一个换行符：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function writes
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to the stream
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> followed by a newline:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>函数将字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>写入流<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>，后跟一个换行符：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is the
    most convenient function for printing simple messages because it takes only a
    single argument. Here’s an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>函数是打印简单消息时最方便的函数，因为它只需要一个参数。以下是一个示例：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> function reads
    the next character as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> from a stream and returns its value, converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>函数从流中读取下一个字符，将其作为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>类型，并返回其值，转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If an end-of-file condition or read error occurs, the function returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生文件结束或读取错误，函数将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp> function is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>, except that if
    it’s implemented as a macro, it may evaluate its stream argument more than once.
    Consequently, this argument should never be an expression with side effects. Analogous
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> is generally safer
    and should be preferred to <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>函数等同于<samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>，不同之处在于如果它作为宏实现，可能会多次评估其流参数。因此，该参数不应为带有副作用的表达式。类似于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>函数，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>通常更安全，应优先使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>而非<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> function is
    equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp> function,
    except that it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    as the value of the stream argument.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>函数等同于<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>函数，不同之处在于它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>作为流参数的值。
- en: 'You may recall that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function reads characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    and writes them into a character array until a newline or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    is reached. The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    is inherently insecure. It was deprecated in C99 and removed from C11 and *should
    never be used*. If you need to read a string from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>,
    consider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp>
    function instead. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp>
    function reads at most one less than <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    characters from a stream into a character array pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: No additional characters are read after a (retained) newline character or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. A null character is written
    immediately following the last character read into the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Stream Flushing</samp>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As described earlier in this chapter, streams can be fully or partially buffered,
    meaning that data you thought you wrote may not yet be delivered to the host environment.
    This can be a problem when the program terminates abruptly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>
    function delivers any unwritten data for a specified stream to the host environment
    to be written to the file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The behavior is undefined if the last operation on the stream was input. If
    the stream is a null pointer, the <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>
    function performs this flushing action on all streams. Make sure that your file
    pointer isn’t null before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>
    if this isn’t your intent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting the Position in a File</samp>
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Random-access files (which include a disk file, for example, but not a terminal)
    maintain a file position indicator associated with the stream. The *file position
    indicator* describes where in the file the stream is currently reading or writing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When you open a file, the indicator is positioned at the file’s start (unless
    you open it in append mode). You can position the indicator wherever you want
    to read or write any portion of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp>
    function obtains the current value of the file position indicator, while the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function sets the file position
    indicator. These functions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> type to represent offsets (positions) in a file and are therefore limited
    to offsets that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>. [Listing 8-2](chapter8.xhtml#Lis8-2) demonstrates the use of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Using the</samp>
    <samp class="I">ftell</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="I">fseek</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This program opens a file called *fred.txt* and calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp>
    function to find the file size. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp>
    function calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> to set
    the file position indicator to the end of the file (indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">SEEK_END</samp>)
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function to
    retrieve the current value of the file position indicator for the stream as a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>. This value is returned
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp> function
    and is printed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. Finally, we close the file referenced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp>
    file pointer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function has
    different constraints for text and binary files. The offset must be either zero
    or a value previously returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp>
    for a text file, whereas you can use calculated offsets for a binary file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: To ensure your code is robust, make sure you check for errors. File I/O can
    fail for any number of reasons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp>
    function returns a null pointer when it fails. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    function returns nonzero only for a request that cannot be satisfied. On failure,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">−1L</samp> and stores an implementation-defined
    value in <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>. If the return
    value from <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> is equal
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1L</samp>, we use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">err</samp> function to print the last
    component of the program name, a colon character, a space followed by an appropriate
    error message corresponding to the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>,
    and finally, a newline character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if any
    errors were detected. One of the unfortunate aspects of the C standard library
    demonstrated by this short program is that each function tends to report errors
    in its own unique way, so you normally need to refer to your documentation to
    see how to test for errors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    functions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp>
    type to represent offsets. This type can represent arbitrarily large offsets,
    meaning you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> with arbitrarily
    large files. A wide-oriented stream has an associated <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp>
    object that stores the stream’s current parse state. A successful call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> stores this multibyte state
    information as part of the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp>
    object. A later successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    using the same stored <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp>
    value restores the parse state as well as the position within the controlled stream.
    It’s not possible to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp>
    object to an integer byte or character offset within the stream except indirectly
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> followed
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp>. The short program
    shown in [Listing 8-3](chapter8.xhtml#Lis8-3) demonstrates the use of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    functions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Using the</samp>
    <samp class="I">fgetpos</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="I">fsetpos</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'This program opens the *fred.txt* file for writing and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp>
    to get the current file position within the file, which is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">pos</samp>.
    We then write some text to the file before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>
    to restore the file position indicator to the position stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">pos</samp>.
    At this point, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp>
    function to retrieve and print the file position, which should be 0\. After running
    this program, *fred.txt* contains the following text:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You cannot write to a stream and then read from it again without an intervening
    call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> function
    to write any unwritten data or to a file positioning function (<samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>).
    You also cannot read from a stream and then write to it without an intervening
    call to a file positioning function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> function sets
    the file position indicator to the beginning of the file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> function is
    equivalent to invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> to clear
    the error indicator for the stream:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because there is no way to determine if <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>
    failed, you should use <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    so that you can check for errors.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t attempt to use file positions in files opened in append mode,
    because many systems don’t modify the current file position indicator for append
    or will forcefully reset to the end of the file when writing. If using APIs that
    use file positions, the file position indicator is maintained by subsequent reads,
    writes, and positioning requests. Both POSIX and Windows have APIs that never
    use the file position indicator; for those, you always need to specify the offset
    into the file at which to perform the I/O. POSIX defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">lseek</samp>
    function, which behaves similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    but operates on an open file description (IEEE Std 1003.1:2018).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Removing and Renaming Files</samp>
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C standard library provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>
    function to delete a file and a <samp class="SANS_TheSansMonoCd_W5Regular_11">rename</samp>
    function to move or rename it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In POSIX, the file deletion function is <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp>,
    and the directory removal function is <samp class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp>:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: POSIX also uses <samp class="SANS_TheSansMonoCd_W5Regular_11">rename</samp>
    for renaming. One obvious difference between the C standard and POSIX is that
    C does not have a concept of directories, while POSIX does. Consequently, no specific
    semantics are defined in the C standard for dealing with directories.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp> function has
    better-defined semantics than the <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>
    function because it’s specific to POSIX filesystems. In POSIX and Windows, we
    can have any number of links to a file, including hard links and open file descriptors.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp> function always
    removes the directory entry for the file but deletes the file only when there
    are no more links or open file descriptors referencing it. Even after deletion,
    the contents of the file may remain in permanent storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp>
    function removes a directory whose name is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    only if it is an empty directory.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In POSIX, the <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> function
    is required to behave the same as the <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp>
    function when the argument is not a directory and to behave the same as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp> function when the argument
    is a directory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>
    function may behave differently on other operating systems.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem is shared with other programs running concurrently to yours.
    These other programs will modify the filesystem while your program runs. This
    means that a file entry can disappear or be replaced by a different file entry,
    which can be a source of security exploits and unexpected data loss. POSIX provides
    functions that let you unlink and rename files referred to by an open file descriptor
    or handle. These can be used to prevent security exploits and possible unexpected
    data loss in a shared public filesystem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Temporary Files</samp>
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We frequently use *temporary files* as an interprocess communication mechanism
    or for temporarily storing information out to disk to free up random-access memory
    (RAM). For example, one process might write to a temporary file that another process
    reads from. These files are normally created in a temporary directory by using
    functions such as the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">tmpfile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmpnam</samp> or POSIX’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mkstemp</samp>.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Temporary directories can be either global or user specific. In Unix and Linux,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TMPDIR</samp> environment variable
    is used to specify the location of the global temporary directories, which are
    typically */tmp* and */var/tmp*. Systems running Wayland or the X11 window system
    usually have user-specific temporary directories defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">$XDG_RUNTIME_DIR</samp>
    environment variable, which is typically set to */run/user/$uid*. In Windows,
    you can find user-specific temporary directories in the *AppData* section of the
    User Profile, typically *C:\Users\User Name\AppData\Local\Temp* (*%USERPROFILE%\AppData\Local\Temp*).
    On Windows, the global temporary directory is specified by either the <samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">TEMP</samp> environment variable.
    The *C:\Windows\Temp* directory is a system folder used by Windows to store temporary
    files.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, it’s best for each user to have their own temporary directory,
    because the use of global temporary directories frequently results in security
    vulnerabilities. The most secure function for creating temporary files is the
    POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">mkstemp</samp> function. However,
    because accessing files in shared directories may be difficult or impossible to
    implement securely, we recommended that you not use any of the available functions
    and instead perform the interprocess communication by using sockets, shared memory,
    or other mechanisms designed for this purpose.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Formatted Text Streams</samp>
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll demonstrate the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    function to read formatted input. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    function is the corresponding input version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fprintf</samp>
    function that we introduced all the way back in [Chapter 1](chapter1.xhtml) and
    has the following signature:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function reads
    input from the stream pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>,
    under control of the <samp class="SANS_TheSansMonoCd_W5Regular_11">format</samp>
    string that tells the function how many arguments to expect, their type, and how
    to convert them for assignment. Subsequent arguments are pointers to the objects
    receiving the converted input. The result is undefined if there are insufficient
    arguments for the <samp class="SANS_TheSansMonoCd_W5Regular_11">format</samp>
    string. If you provide more arguments than conversion specifiers, the excess arguments
    are evaluated but otherwise ignored. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    function has lots of functionality that we’ll only touch upon here. For more information,
    refer to the C standard.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>,
    as well as some other I/O functions, we’ll implement a program that reads in the
    *signals.txt* file shown in [Listing 8-4](chapter8.xhtml#Lis8-4) and prints each
    line.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: The</samp> <samp
    class="SANS_Futura_Std_Book_11">signals.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of this file contains the following: a signal number (a small positive-integer
    value), the signal ID (a small string of up to six alphanumeric characters), and
    a short string with a description of the signal. Fields are whitespace delimited
    except for the description field, which is delimited by one or more space or tab
    characters at the beginning and by a newline at the end.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](chapter8.xhtml#Lis8-5) shows the signals program, which reads
    this file and prints out each line.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: The signals program</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'We define several variables in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp>
    structure ❶, which we use to store the signal information found on each line of
    the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp> structure
    contains three members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp>
    member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> that will
    hold the signal number; a <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp>
    member that’s an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and will hold the signal ID; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp>
    member, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    that will hold the description of the signal. Both arrays have fixed sizes that
    we determined were adequately sized for the strings being read from the file.
    If the strings read from the file are too long to fit in these arrays, the program
    will treat it as an error.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> ❸ reads
    each line of input from the file. It appears inside of an infinite <samp class="SANS_TheSansMonoCd_W5Regular_11">while
    (true)</samp> loop ❷ that we must break out of for the program to terminate. We
    assign the return value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    function to a local variable <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if an input failure occurs
    before the first conversion has completed. Otherwise, the function returns the
    number of input items assigned, which can be fewer than provided for, or even
    zero, in the event of an early matching failure. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    assigns three input items, so we print the signal description only when <samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is equal to 3\. Next, we call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ferror(in)</samp> to determine if
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> set the
    error indicator. If it did, we print <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>
    with a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">perror</samp>
    function and then set the status to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>.
    Next, if <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>,
    we break out of the loop because we have successfully processed all the input.
    The final possibility is that <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>
    returned a value that is not the expected number of input items, nor is it <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> indicating an early matching
    failure. In this case, we treat the condition as a nonfatal error:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    to let the user know that there is a problem with one of the signal descriptions
    in the file, but we continue to process the remaining entries. The loop discards
    the defective line and <samp class="SANS_TheSansMonoCd_W5Regular_11">status</samp>
    is assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>
    to indicate to the calling program that an error occurred. You’ll notice that
    proper error handling in this program makes up the bulk of the code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function uses
    a *format string* that determines how the input text is assigned to each argument.
    In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">"%d%9s%*[\t]%99[^\n]"</samp>
    format string contains four *conversion specifiers*, which specify how the input
    read from the stream is converted into values stored in the objects referenced
    by the format string’s arguments. We introduce each conversion specification with
    the percent character (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>).
    After the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, the following
    may appear, in sequence:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: An optional character <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    that discards the input without assigning it to an argument
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional integer greater than zero that specifies the maximum field width
    (in characters)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional length modifier that specifies the size of the object
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conversion specifier character that specifies the type of conversion to be
    applied
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first conversion specifier in the format string is <samp class="SANS_TheSansMonoCd_W5Regular_11">%d</samp>.
    This conversion specifier matches the first optionally signed decimal integer,
    which should correspond to the signal number in the file, and stores the value
    in the third argument referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signum</samp>.
    Without an optional length modifier, the length of the input depends on the conversion
    specifier’s default type. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>
    conversion specifier, the argument must point to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The second conversion specifier in this format string is <samp class="SANS_TheSansMonoCd_W5Regular_11">%9s</samp>,
    which matches the next sequence of non-whitespace characters from the input stream—corresponding
    to the signal name—and stores these characters as a string in the fourth argument
    referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signame</samp>.
    The length modifier prevents more than nine characters from being input and then
    writes a null character in <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signame</samp>
    after the matched characters. A conversion specifier of <samp class="SANS_TheSansMonoCd_W5Regular_11">%10s</samp>
    in this example would allow a buffer overflow to occur. A conversion specifier
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">%9s</samp> can still fail to
    read the entire string, resulting in a matching error. When reading data into
    a fixed-size buffer as we are doing, you should test inputs that exactly match
    or slightly exceed the fixed buffer length to ensure buffer overflow does not
    occur and that the string is properly null terminated.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to skip the third conversion specifier for a moment and talk about
    the fourth one: <samp class="SANS_TheSansMonoCd_W5Regular_11">%99[^\n]</samp>.
    This fancy conversion specifier will match the signal description field in the
    file. The brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) contain
    a *scanset*, which is like a regular expression. This scanset uses the circumflex
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>) to exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    characters. Put together, <samp class="SANS_TheSansMonoCd_W5Regular_11">%99[^\n]</samp>
    reads all the characters until it reaches a <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>) and stores them
    in the fifth argument referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.sigdesc</samp>.
    C programmers commonly use this syntax to read an entire line. This conversion
    specifier also includes a maximum string length of 99 characters to avoid buffer
    overflows.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now revisit the third conversion specifier: <samp class="SANS_TheSansMonoCd_W5Regular_11">%*[\t]</samp>.
    As we have just seen, the fourth conversion specifier reads all the characters,
    starting from the end of the signal ID. Unfortunately, this includes any whitespace
    characters between the signal ID and the start of the description. The purpose
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%*[\t]</samp> conversion
    specifier is to consume any space or horizontal tab characters between these two
    fields and suppress them by using the assignment-suppressing specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
    It’s also possible to include other whitespace characters in the scanset for this
    conversion specifier.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>
    function ❹ to close the file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading from and Writing to Binary Streams</samp>
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> functions can
    operate on both text and binary streams. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp>
    function has the following signature:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function writes up to <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp>
    elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes from
    the array pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp>
    function behaves as if it converts each object to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> (every object can be converted to an array of this type) and then
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function
    to write the value of each character in the array in order. The file position
    indicator for the stream is advanced by the number of characters successfully
    written.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: POSIX defines similar <samp class="SANS_TheSansMonoCd_W5Regular_11">read</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">write</samp> functions that
    operate on file descriptors instead of streams (IEEE Std 1003.1:2018).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-6](chapter8.xhtml#Lis8-6) demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp>
    function to write signal records to the *signals.bin* file.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Writing to a binary
    file using direct I/O</samp>'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We open the *signals.bin* file in <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp>
    mode ❶ to create a binary file for writing. We declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp>
    structures ❷ and initialize them with the signal values we want to write to the
    file. For comparison, the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigrec30</samp>
    structure is initialized with positional initializers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigrec31</samp>
    is initialized using designated initializers. Both initialization styles have
    the same behavior; designated initializers make the declaration less terse but
    clearer. The actual writing begins at ❸. We check the return values from each
    call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> function
    to ensure that it wrote the correct number of elements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-7](chapter8.xhtml#Lis8-7) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp>
    function to read the data we just wrote from the *signals.bin* file.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Reading from a
    binary file using direct I/O</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We open the binary file by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">rb</samp>
    mode ❶ for reading. Next, to make this example a bit more interesting, the program
    reads and prints the information for a specific signal, rather than reading the
    entire file. We could indicate which signal to read by using an argument to the
    program, but for this example, we hardcoded it as the second signal. To accomplish
    this, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>
    function ❷ to set the file position indicator for the stream referenced by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fp</samp>. As mentioned earlier in this
    chapter, the file position indicator determines the file position for the subsequent
    I/O operation. For a binary stream, we set the new position by adding the offset
    (measured in bytes) to the position specified by the final argument (the beginning
    of the file, as indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">SEEK_SET</samp>).
    The first signal is at position 0 in the file, and each subsequent signal is at
    an integer multiple of the size of the structure from the beginning of the file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: After the file position indicator is positioned at the start of the second signal,
    we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> function
    ❸ to read the data from the binary file into the structure referenced by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">&sigrec</samp>. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp>
    reads a single element whose size is specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(rec)</samp>
    from the stream pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp>.
    In most cases, this object has the size and type of the corresponding call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp>. The file position
    indicator for the stream is advanced by the number of characters successfully
    read. We check the return value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp>
    function to ensure the correct number of elements, here one, was read.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Endian</samp>
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object types other than character types can include padding as well as value
    representation bits. Different target platforms can pack bytes into multiple-byte
    words in different ways, called *endianness*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The term* endianness *is drawn from Jonathan Swift’s 1726 satire,* Gulliver’s
    Travels*, in which civil war erupts over whether the big end or the little end
    of a boiled egg is the proper end to crack open.*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: A *big-endian ordering* places the most significant byte first and the least
    significant byte last, while a *little-endian ordering* does the opposite. For
    example, consider the unsigned hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1234</samp>,
    which requires at least two bytes to represent. In a big-endian ordering, these
    two bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x12</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x34</samp>, while in a little-endian
    ordering, the bytes are arranged as <samp class="SANS_TheSansMonoCd_W5Regular_11">0x34</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x12</samp>. Intel and AMD processors
    use the little-endian format, while the ARM and POWER series of processors can
    switch between the little- and big-endian formats. However, big-endian is the
    dominant ordering in network protocols such as Internet Protocol (IP), Transmission
    Control Protocol (TCP), and User Datagram Protocol (UDP). Endianness can cause
    problems when a binary file is created on one computer and is read on another
    computer with different endianness.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: C23 has added a mechanism to determine your implementation’s byte ordering at
    runtime using three macros that expand to integer constant expressions. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_LITTLE__</samp> macro represents
    a byte order storage in which the least significant byte is placed first and the
    rest are in ascending order. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_BIG__</samp>
    macro represents a byte order storage in which the most significant byte is placed
    first and the rest are in descending order.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp>
    macro describes the endianness of the execution environment with respect to bit-precise
    integer types, standard integer types, and most extended integer types. The short
    program in [Listing 8-8](chapter8.xhtml#Lis8-8) determines the byte ordering for
    the execution environment by testing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp>
    macro. If the execution environment is neither little-endian nor big-endian and
    has some other implementation-defined byte order, the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp>
    will have a different value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Determining the
    byte ordering</samp>'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: All this variation between platforms implies that, for interhost communication,
    you should adopt a standard for the external format and use format conversion
    functions to *marshal* arrays of external data to and from multiple-byte native
    objects (using exact width types). POSIX has some suitable functions for this
    purpose, including <samp class="SANS_TheSansMonoCd_W5Regular_11">htonl</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">htons</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntohl</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntohs</samp>, that convert values
    between host and network byte order.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Endianness independence in binary data formats can be achieved by always storing
    the data in one fixed endianness or including a field in the binary file to indicate
    the endianness of the data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about streams, including stream buffering, the
    predefined streams, stream orientation, and the difference between text and binary
    streams.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to create, open, and close files by using the C standard
    library and POSIX APIs. You also learned how to read and write characters and
    lines, read and write formatted text, and read and write from binary streams.
    You looked at how to flush a stream, set the position in a file, remove files,
    and rename files. Without I/O, communication with the user would be limited to
    the program’s return value. Finally, you learned about temporary files and how
    to avoid using them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the compilation process and the preprocessor,
    including file inclusion, conditional inclusion, and macros.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
