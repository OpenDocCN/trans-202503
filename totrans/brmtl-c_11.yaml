- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interrupts
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The two main methods for handling I/O are *polling*, which repeatedly asks the
    device whether it has any data ready, and *interrupts*, which are when the device
    interrupts normal workflow to tell you it’s ready. This chapter describes the
    difference between polling and interrupts as well as explains how interrupts work
    so you can use them to write a string to the serial port more efficiently (yes,
    “Hello World” again).
  prefs: []
  type: TYPE_NORMAL
- en: Polling vs. Interrupts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider how polling and interrupts would work in the case of the telephone.
    With polling, the ringer is turned off, and you must check the phone every 10
    seconds to see whether a call is coming in. You must sit by the phone and not
    get bored easily. This method is what we used in our previous serial program in
    Chapter 9, which basically went like the following dialogue:'
  prefs: []
  type: TYPE_NORMAL
- en: “Are you busy?” “Yes.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Are you busy?” “Yes.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Are you busy?” “Yes.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Are you busy?” “No.” “Here’s the next character.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The computer is stuck in a polling loop, waiting for the UART status register
    to indicate that the UART is ready for the next character. At this point, the
    computer has nothing else to do and doesn’t get bored. The main advantages of
    polling are that it’s easy to understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to the telephone again, but this time we’ll use the interrupt
    method. You don’t sit by the phone continually checking whether a call is coming
    in. Instead, you go about your normal business until the phone rings (an interrupt
    occurs). Then you drop everything, race to the phone, and pick up it—only to discover
    that it’s another telemarketing call for something you wouldn’t buy in a million
    years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key sequence of events in the interrupt scenario is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We go about our normal work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get an interrupt (the phone rings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pick up the phone (service the interrupt), shout “No, I don’t want to buy
    a combination shaving brush and fountain pen,” and hang up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We resume our normal work where we left off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interrupts for Serial I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can send characters to the UART only when the transmit data register (TDR)
    is empty. [Figure 10-1](#figure10-1) shows a block diagram of a portion of the
    UART to illustrate how the TDR works.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](image_fi/501621c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: UART transmission hardware'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to send a character, we dump it in the TDR, which holds 8 bits.
    The character is then dumped into the *transmit shift register (TSR)*, which holds
    10 bits. The 2 extra bits are the start bit at the beginning of the character
    and the stop bit at the end of the character. The TSR then sends the data out
    the *transmit serial line (TX)* one bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: When the data is moved from the TDR to the TSR, the TDR becomes empty and is
    ready to receive another character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The polling loop we’ve been using looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In English, this says, “Are you empty yet? Are you empty yet? Are you empty
    yet?” And it’s just as annoying in C code as it is in English. Again, polling’s
    main advantage is its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: The other way to transmit characters is to tell the system we want an interrupt
    when the UART is ready to receive another character. An interrupt function is
    called automatically when something occurs. In our case, we want an interrupt
    when the TDR is empty.
  prefs: []
  type: TYPE_NORMAL
- en: With interrupts, we tell the processor, “I’m going to go off and do useful work.
    When the TDR is empty, I want you to interrupt the normal flow and call an *interrupt
    routine* function, so I can give you the next character.”
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt Routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an interrupt occurs, the CPU calls an interrupt routine function, located
    at a fixed address determined by the CPU’s design. Early CPUs had *one* address
    for all interrupts, so the code had to go through a number of checks to see what
    had interrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nowadays, even a simple chip can have many different devices. Checking all of
    them to see which one interrupted is a time-consuming process. As a result, chips
    (including our ARM chip), now use *vectored interrupts*, which means each peripheral
    gets its own interrupt address. Interrupts from UART1 will call an interrupt routine
    at one address, while interrupts from UART2 will go to another (specifically `USART2_IRQHandler`),
    and so on for other peripheral devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interrupt vector is defined in the *startup/startup_stm32f030x8.S* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, the code defines the `USART2_IRQHandler` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second directive (`.thumb_set`) defines the procedure `USART2_IRQHandler`
    to be the same as `Default_Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: The first `.weak` directive defines it as a *weak symbol*. If it were a regular
    symbol and we tried to define our own `USART2_IRQHandler`, the linker would abort
    with a `Duplicate symbol` error message. However, because the symbol is weak,
    the linker will throw away the weak definition and use the one that we provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *startup/startup_stm32f030x8.S* file defines `Default_Handler` later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The default response to an interrupt is to loop forever, making the machine
    almost totally useless (I say “almost totally useless” because the machine will
    still respond to the debugger and a reset).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write our own `USART2_IRQHandler` to respond when the TDR is empty and
    thereby replace the default handler with something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a String with Interrupts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s change our serial I/O program from Chapter 9 so that it uses interrupts
    instead of polling to write a string. All that’s communicated between the upper
    layer (the main program) and the lower layer (interrupt routine) is a single global
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `const` qualifier tells C that the character data is constant and we’ll
    never attempt to change it. The `volatile` qualifier tells C that this variable
    may be changed at any time by something outside the flow of a normal C program,
    such as an interrupt function.
  prefs: []
  type: TYPE_NORMAL
- en: To clarify, because C’s syntax is a little complex at this point, the `const`
    appears before the `char` declaration and means that the character data is constant.
    It does not appear after the pointer operator (`*`), so the pointer is not constant.
    The `volatile` modifier appears after the pointer operator, indicating the pointer
    may be changed. The lack of the `const` modifier after the pointer operator means
    that the program can change this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be careful with any variables used by both layers. Fortunately,
    for this example, that’s just one variable, `usart2String`. The following lists
    show the workflow for that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upper Layer (Main Program)**'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for `usart2String` to become `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point it to the string we want to send to the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the first character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the UART interrupt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower Layer (Interrupt)**'
  prefs: []
  type: TYPE_NORMAL
- en: If we’ve reached the end of the string, set `usart2String` to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acknowledge that the UART received the interrupt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the character pointed to by the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the upper and lower layers increment the pointer. We need to be very careful
    when it comes to enabling the interrupt to make sure both layers don’t try to
    use the pointer at the same time. The upper layer won’t do anything until `usart2String
    == NULL`, and the lower layer sets `usart2String` to `NULL` only when it has run
    out of data and disables the UART2 interrupt. The upper layer protects itself
    by not enabling interrupts until after it performs the increment. Thus, the interrupt
    routine cannot monkey with the code.
  prefs: []
  type: TYPE_NORMAL
- en: This analysis is extremely important. When it’s not done or not done properly,
    the program will fail, and the failures will occur at random times with random
    results. These results pose an extremely difficult, debug-resistant problem.
  prefs: []
  type: TYPE_NORMAL
- en: I actually spent about three years finding one of these bugs. The problem occurred
    only for one customer and only about once every two months. We were completely
    unable to reproduce it in the lab. Fortunately, the customer was very mellow and
    willing to work with us on the solution. Later in this chapter, we’ll explore
    what happens when this analysis is not done and consider some techniques for diagnosing
    interrupt-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-1](#listing10-1) contains the interrupt-driven serial I/O program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: 10.serial.int/main.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Program Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 10-1](#listing10-1) looks a lot like the serial I/O program from Chapter
    9, because setting up the I/O system is the same, with a lot of extra little details.
    But in this case, we added something new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `NVIC_EnableIRQ` function initializes the *nested vectored interrupt controller
    (NVIC)*, which is a bit of hardware that decides what the processor does when
    it receives an interrupt and enables the USART2 interrupt. When the processor
    is reset, it turns off all interrupts, so we need to tell it that we want USART2
    to interrupt it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `myPuts` function, which sends a string (instead of a
    single character, like `myPutchar` from Chapter 9) to the serial device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is wait for the previous string to finish 1. We know that
    if `usart2String` is not `NULL`, the interrupt routine is active and we should
    wait until the previous string is transmitted. When it becomes `NULL`, the interrupt
    routine is inactive and we can start our transmission.
  prefs: []
  type: TYPE_NORMAL
- en: When we do get our turn, we tell the interrupt function what string we are transmitting
    2, and then we transmit the first character 3. As a final step, we enable the
    transmit data buffer empty interrupt 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several symbols control what interrupts are enabled. The `USART_CR1_TXNEIE`
    bit tells the UART to interrupt when the transmit data buffer is empty. Here are
    some other symbols to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USART_CR1_IDLEIE` IDLE interrupt enable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_CR1_RXNEIE` Receive interrupt enable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_CR1_TCIE` Transmission complete interrupt enable (interrupt when the
    character has gone out, not when we first load a character into the transmission
    register)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_CR1_PEIE` Parity error interrupt enable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we send the first character, the TDR is filled. When it is transferred
    to the TSR, the TDR will be empty and we’ll get an interrupt. From here on, the
    interrupt routine does the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual interrupt routine is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function declaration uses a magic name that identifies it as the interrupt
    routine 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the function gets called, we know we have an interrupt from USART2, but
    we don’t know what type of interrupt it is because the USART has multiple types
    of interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USART_ISR_TXE` TDRempty'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_CTSIF` CTS interrupt'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_TC` Transmission complete'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_RXNE` Receive data register not empty (data ready to be read)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_ORE` Overrun error detected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_IDLE` Idle line detected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_FE` Framing error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_PE` Parity error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_NE` Noise flag'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_CMF` Character match'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USART_ISR_TXE` Receiver timeout'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these interrupts will result in a call to `USART2_IRQHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to check whether we have a transmit buffer empty interrupt 2.
    Our interrupt function should never be called with `usart2String` set to `NULL`,
    but “should” and “reality” are vastly different, so we put in a little bit of
    paranoia to make sure we don’t crash if something goes wrong 3. The variable `usart2String`
    should never be `NULL` at this point, but if it is, we don’t want to cause trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Without that check, we might try to deference a `NULL` pointer 4. Dereferencing
    a `NULL` pointer is illegal, and the STM32 is nice enough to have hardware to
    check for this condition. When it occurs, the STM32 generates a *memory fault
    interrupt*. In other words, the interrupt handler is being interrupted, and control
    transfers to the memory fault interrupt handler. However, we haven’t written one,
    so the default handler is executed. As mentioned previously, the default handler
    locks up the system until you reset it. To protect ourselves against an improper
    `usart2String`, when we see it, we do the safest thing, which is to turn off the
    interrupt and do nothing else 3.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check to see whether we’ve run out of string. If we have, we `NULL`
    out the string to signal to the top level that we’re done and to turn off interrupts.
    Otherwise, we know we have data for the UART and that the TDR is empty, so we
    dump a character into it 5. Once we’ve sent the character, we need to point to
    the next one for the next time we get interrupted, and then return to the main
    program 6.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the TDR is full, and the UART is sending characters. The interrupt
    route has nothing more to do, so it will return and normal execution will resume.
    When the character is sent and the TDR is empty, we’ll get another interrupt,
    which will continue until we run out of string and turn off the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware engineers at STMicroelectronics have helpfully explained this process
    with a diagram (see [Figure 10-2](#figure10-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10002](image_fi/501621c10/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: USART interrupt mapping'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows that if the TCIE (transmit character interrupt enable) bit
    is on 1 and a character has been transmitted (TC) 2, the output of the AND gate
    is true 3. This result is combined with the output of three other interrupts,
    and if any one is true (OR gate), the result 4 is true. Then that result is combined
    with the output of another OR gate 5 for all the other signals, and the result
    of the last OR gate is the USART interrupt signal. Note that the diagram is meant
    to simplify this process. If you want to know what the alphabet soup of inputs
    mean, read the 800-page reference manual for this processor.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt Hell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interrupts are extremely powerful tools when it comes to controlling hardware
    as well as dealing with events in real time. However, using interrupts can cause
    a number of unique and difficult problems to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, they can interrupt normal program flow at any time. For example, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s the value of `i` after this statement is executed? The answer is obviously
    5, unless an interrupt routine just executed and modified it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Second, interrupt routines execute asynchronously, which means they execute
    whenever they feel like it, so any bugs caused by poorly written interrupt routines
    can be difficult to reproduce. I’ve seen cases where a bug occurred only randomly
    after about two weeks of testing because the interrupt had to occur exactly when
    one of two instructions was executing—that’s two out of the tens of thousands
    in the code. It took a lot of testing to stumble upon this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the inherent difficulties with interrupt routines, it pays to give
    them a lot of respect. The most important design rule when dealing with interrupt
    routines is to keep them small and simple, because the less the routine does,
    the less there is that can go wrong. It’s better to leave the “thinking” to the
    higher-level code where debuggers work nicely and where reproducibility is not
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt routines also need to execute quickly, because while an interrupt
    routine is executing, other interrupts are held off until the routine is finished.
    If you take a long time in an interrupt routine that’s reading a character from
    UART1, another device, such as UART2, might lose data because its interrupt couldn’t
    get serviced in time.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Buffer to Increase Speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system we just used has some limits. It can transmit only one message at
    a time. Suppose we wanted to output multiple short messages. Each one would have
    to wait until the previous one finished. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One solution to this problem is to create a *buffer* to hold the character data
    until the interrupt routine can service it. Doing that adds complexity to the
    application, but it increases the speed at which your top-level program can send
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Using serial I/O means considering the general trend of speed versus simplicity.
    The polling version was very simple and slow. The single string interrupt version
    was faster but more complex. The buffer system we are using now is much faster
    and much more complex. This trend is true for most programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this problem, let’s go back to the buffer. We’ll use a *circular buffer*
    that has the following basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s called a circular buffer because the indices wrap. In other words, after
    a character is put in the last element of data, the `putIndex` will wrap from
    7 (`BUFFER_SIZE-1`) to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Graphically, this looks like [Figure 10-3](#figure10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10003](image_fi/501621c10/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: A circular buffer in action'
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation is going to contain a deliberate nasty mistake, so we can
    look at techniques and procedures for finding such mistakes in a small, controlled
    program. I’ll show the symptoms of the bug, the diagnostic techniques used to
    locate it, and the fix as we go through the program.
  prefs: []
  type: TYPE_NORMAL
- en: The first time I encountered a problem like this was about 30 years ago. It
    wasn’t in a 200-line demonstration program; it was in the BSD Unix kernel in a
    serial module with tens of thousands of lines. It occurred about once every three
    to seven days randomly and took three engineers two months to find it. To make
    matters worse, it was processor-dependent and didn’t occur on the VAX processor
    that ran the original BSD.
  prefs: []
  type: TYPE_NORMAL
- en: The top-level program (the sender) puts data in the buffer. The lower-level
    interrupt routine (the receiver) removes data from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pseudocode, the sender’s job is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And the receiver’s job is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sending Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use a circular buffer, we have to go back to sending one character at a
    time with another version of `myPutchar`. Let’s look at the code doing the sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning, we wait until there is room for at least one character in
    the buffer 1. Then we dump the character in the buffer 2. The `putIndex` advances
    by one and wraps back to 0 if necessary 3.The number of characters in the buffer
    has increased, so we increment the `nCharacters` count in the buffer structure
    4. Finally, we enable the interrupt 5. If we are transmitting, the interrupt may
    already be enabled. Enabling it again won’t cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt Routine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interrupt routine reads the data from the buffer and transmits it to the
    UART. If a character is in the buffer, the routine removes it and sends it to
    the UART. If nothing is in the buffer, the routine turns off the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to see whether the device has run out of data. If it has, we
    shut down the interrupt until we get more data from the upper level 1. Then we
    send the character 2, move the `getIndex` up one, and wrap if needed 3. Next,
    we let the upper layer know we have one less character 4. Finally, we shut down
    the interrupt if this was the last character 5.
  prefs: []
  type: TYPE_NORMAL
- en: Full Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 10-2](#listing10-2) shows the complete program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: 10.serial.buffer.bad/src/main.c*'
  prefs: []
  type: TYPE_NORMAL
- en: The Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we run the program, we expect to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There is no pattern to when this issue will occur, other than that the more
    data we send to the buffer, the more likely we are to have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: With this tiny program, replicating that problem in the field is going to be
    difficult because it requires very precise timing. It’s more likely that after
    implementing and testing this code, we would incorporate the module in another
    program that would make the timing more likely. Timing bugs are notoriously difficult
    to cause on demand, but there is one in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the busier the system is, the more likely it is that the problem
    will happen. Plus, we have another clue—we haven’t been able to catch it in the
    act, but afterward we looked at the debugger and discovered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In a correctly working program, both of these conditions can never be true.
    There are two ways of attacking this problem. The first is to instrument the code
    and try to find out what is going on. The second is to perform very detailed analysis
    of any data shared between the upper and lower layers and the code that manipulates
    this data. Let’s do both.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting the Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Instrumenting* the code means putting in temporary debugging statements that
    will help find a problem. With most code, this means writing `printf` statements
    to output intermediate data that we can check as the program progresses. Sometimes
    data is printed to a logfile that can be analyzed after the problem occurs. Neither
    of these options is viable for our embedded program. We can’t use `printf` because
    the output would go to the serial console, and that’s the code with the bug. We
    can’t write a logfile because we don’t have a filesystem to write logging information
    to.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a log buffer that will store the last 100 events. When we encounter
    a problem, we can go back and look at the events to see what led up to the problem.
    The log records the relevant data (`getIndex`, `putIndex`, `nCharacters`) and
    the line number of the call to the event-logging code.
  prefs: []
  type: TYPE_NORMAL
- en: When the problem occurs and we get a chance to stop the program in the debugger,
    we can look through the log. If we are lucky, we should be able to find a few
    log entries where at line *X* the buffer information was consistent and at line
    *Y* it was screwed up, which reveals that the problem occurred between lines *X*
    and *Y*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-3](#listing10-3) shows the code to record an event. Add this code
    after the other definitions and variable declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: The event recorder'
  prefs: []
  type: TYPE_NORMAL
- en: This event recorder contains the same type of bug we’re trying to find, but
    for now, we’ll assume that it works well enough for us to locate the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to put in a few calls to the `debugEvent` function to see whether
    we can spot the error. Since `nCharacters` is driving us nuts, we put a call to
    `debugEvent` before and after each operation we perform on `nCharacters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We also put a consistency check at the beginning of `myPutchar` to make sure
    the `buffer` is sane. Specifically, if we see the condition where the `buffer`
    is inconsistent (`nCharacters == 0` and `getIndex != putIndex`), we invoke the
    `Error_Handler` function to stop the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start the program under the debugger with a breakpoint at `Error_Handler`
    and see if we can catch the error. Eventually, we hit the breakpoint and, using
    the debugger, examine the `debugEvents`. Looking back through the traces using
    the debugger, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 119: `nCharacters == 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 89: `nCharacters == 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 91: `nCharacters == 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 121: `nCharacters == 4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why did `nCharacters` jump by 2 between the last two events?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the relevant lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Something is wrong with line 90 or 120, which also tells us something important.
    After line 119 and before line 121, an interrupt occurred. We’ve now pinpointed
    the error to a couple lines of code and an interrupt. Let’s shift gears and use
    code analysis to reach the same conclusion. We’re exploring both methods because
    sometimes one method works and the other doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The other way to figure out the problem is to analyze what is going on and
    try to identify potential problem spots. The analysis starts by identifying the
    shared data between the upper and lower layers—in other words, the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Neither `putIndex` nor `getIndex` should cause a problem, since they’re used
    by only one layer each (the upper and lower layer, respectively). The `data` array
    is shared by both layers, but it’s written by the upper layer and read by the
    lower level, so each layer has a distinct job when it comes to that array. In
    addition, `putIndex` controls the portion of the array the upper layer uses, and
    `getIndex` controls the portion the lower layer uses. They point to different
    elements of the array, and nothing going into or out of `data` could affect the
    indices or character counter. The `data` array is not the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that’s left is `nCharacters`, which the upper layer increments and the
    lower level decrements, so there are two potential problem lines. One is in the
    interrupt routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And the other is in `myPutchar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These are the same two lines our instrumented code indicated might be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Closely Examining the Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see exactly what happens when the following line is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the assembly code (comments added) for this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This code loads the value of `nCharacters` into register `r3`, increments it,
    and sticks it back in `nCharacters`. Interrupts can happen at any time, like right
    after the value is loaded into `r3` 1, which causes the following to happen (assuming
    `nCharacters` is 3):'
  prefs: []
  type: TYPE_NORMAL
- en: At line 406, register `r3` gets the value of `nCharacters` (`r3 == 3`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just before the instruction at line 407, an interrupt occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interrupt routine reads `nCharacters` (it’s 3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It decrements it, so the value of `nCharacters` is now 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interrupt routine completes and returns control to line 407.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instruction at line 407 adds 1 to register `r3` and sticks the result in
    `r2` (`r3` contains 3, `r2` contains 4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line 409 stores the value of `r2` into `nCharacters`, which should be 3, but
    it’s now 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At line 407, the program assumes that `r3` has the correct value of `nCharacters`,
    but it doesn’t.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The register `r3` doesn’t have the correct value of `nCharacters` because an
    interrupt occurred at just the right time and the variable was modified. We failed
    to protect the consistency of shared data. The upper layer was modifying `nCharacters`
    while the lower layer was modifying it *at the same time*.
  prefs: []
  type: TYPE_NORMAL
- en: If the interrupt occurs between some other instructions, the problem does not
    occur. This problem is random and happens infrequently, making it one of the more
    difficult problems to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the Problem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The solution is to prevent the interrupt routine from modifying `nCharacters`
    while we are modifying it. To do that, we turn off interrupts before the increment
    and turn them on afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Keep the amount of time interrupts are turned off short. If interrupts are turned
    off for a long period of time, you might miss an interrupt and drop data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interrupt routine, we decrement `nCharacters`, so don’t we need to protect
    that with a `__disable_irq` and an `__enable_irq`? We don’t, because when an interrupt
    occurs, the system automatically performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It disables interrupts for this level interrupt and lower. Higher-level interrupts
    can interrupt our interrupt routine, but lower ones cannot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It saves the state of the machine, including all general-purpose registers and
    status registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls the interrupt function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the interrupt routine returns, the system then performs these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It restores the state of the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It turns the interrupts back on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns control to the upper-level code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lot of bookkeeping needs to be done at the start and end of an interrupt routine.
    Fortunately, the designers of the ARM processor family decided to do it all in
    hardware. Other processors may not be so nice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interrupts allow you to respond to input and output requests in real time. They
    also allow you to screw up your program in strange and random ways. Be sure to
    keep interrupt routines and code that accesses shared data as simple and clear
    as possible. Spending extra time making sure that interrupt-related code is written
    properly will save you a tremendous amount of debugging time later.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an interrupt routine that reads characters from the serial port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an interrupt routine to service a button push and change the message when
    it occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the HAL library and find out how `__disable_irq` is implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
