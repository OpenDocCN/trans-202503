## 附录 F。选定练习的解决方案

## 第五章

1.  解决方案可以在本书源代码分发中的`fileio/atomic_append.c`文件中找到。以下是运行此程序时看到的结果示例：

    ```
    $ `ls -l f1 f2`
    -rw-------    1 mtk      users     2000000 Jan  9 11:14 f1
    -rw-------    1 mtk      users     1999962 Jan  9 11:14 f2
    ```

    因为*lseek()*和*write()*的组合不是原子性的，程序的一个实例有时会覆盖另一个实例写入的字节。因此，文件`f2`的内容少于 200 万字节。

1.  对*dup()*的调用可以重写为：

    ```
    fd = fcntl(oldfd, F_DUPFD, 0);
    ```

    对*dup2()*的调用可以重写为：

    ```
    if (oldfd == newfd) {                /* oldfd == newfd is a special case */
        if (fcntl(oldfd, F_GETFL) == -1) {                /* Is oldfd valid? */
            errno = EBADF;
            fd = -1;
        } else {
            fd = oldfd;
        }
    } else {
        close(newfd);
        fd = fcntl(oldfd, F_DUPFD, newfd);
    }
    ```

1.  第一个要意识到的点是，由于*fd2*是*fd1*的副本，它们共享一个单一的打开文件描述符，因此共享一个文件偏移量。然而，因为*fd3*是通过单独的*open()*调用创建的，所以它有一个单独的文件偏移量。

    +   第一次*write()*之后，文件内容为`Hello`。

    +   由于*fd2*与*fd1*共享一个文件偏移量，因此第二次*write()*调用会将文本追加到现有文本中，得到`Hello, world`。

    +   *lseek()*调用调整了*fd1*和*fd2*共享的单个文件偏移量，使其指向文件的开始，因此第三次*write()*调用覆盖了现有文本的一部分，结果为`HELLO, world`。

    +   *fd3*的文件偏移量迄今为止没有被修改，因此指向文件的开始。因此，最终的*write()*调用将文件内容更改为`Gidday world`。

    运行本书源代码分发中的程序`fileio/multi_descriptors.c`以查看这些结果。

## 第六章

1.  由于数组*mbuf*没有初始化，它是未初始化数据段的一部分。因此，不需要磁盘空间来存储该变量。相反，它在程序加载时分配（并初始化为 0）。

1.  本书源代码分发中的`proc/bad_longjmp.c`文件提供了*longjmp()*使用不当的示例。

1.  本书源代码分发中的`proc/setenv.c`文件提供了*setenv()*和*unsetenv()*的示例实现。

## 第八章

1.  两个*getpwnam()*调用在构建*printf()*输出字符串之前执行，并且由于*getpwnam()*将其结果返回到一个静态分配的缓冲区，因此第二次调用会覆盖第一次调用返回的结果。

## 第九章

1.  在考虑以下内容时，请记住，更改有效用户 ID 总是也会更改文件系统用户 ID。

    1.  *real=2000, effective=2000, saved=2000, file-system=2000*

    1.  *real=1000, effective=2000, saved=2000, file-system=2000*

    1.  *real=1000, effective=2000, saved=0, file-system=2000*

    1.  *real=1000, effective=0, saved=0, file-system=2000*

    1.  *real=1000, effective=2000, saved=3000, file-system=2000*

1.  严格来说，这样的进程是没有特权的，因为它的有效用户 ID 非零。然而，一个没有特权的进程可以使用 *setuid()*、*setreuid()*、*seteuid()* 或 *setresuid()* 调用，将其有效用户 ID 设置为与实际用户 ID 或保存的设置用户 ID 相同的值。因此，该进程可以使用这些调用中的一个来重新获得特权。

1.  以下代码展示了每个系统调用的步骤。

    ```
    e = geteuid();     /* Save initial value of effective user ID */

    setuid(getuid());                         /* Suspend privileges */
    setuid(e);                                /* Resume privileges */
    /* Can't permanently drop the set-user-ID identity with setuid() */

    seteuid(getuid());                        /* Suspend privileges */
    seteuid(e);                               /* Resume privileges */
    /* Can't permanently drop the set-user-ID identity with seteuid() */

    setreuid(-1, getuid());                   /* Temporarily drop privileges */
    setreuid(-1, e);                          /* Resume privileges */
    setreuid(getuid(), getuid());             /* Permanently drop privileges */

    setresuid(-1, getuid(), -1);              /* Temporarily drop privileges */
    setresuid(-1, e, -1);                     /* Resume privileges */
    setresuid(getuid(), getuid(), getuid());  /* Permanently drop privileges */
    ```

1.  除了 *setuid()*，其他的答案与前一个练习相同，只不过我们可以将变量 *e* 的值替换为 0。对于 *setuid()*，如下所示：

    ```
    /* (a) Can't suspend and resume privileges with setuid() */

    setuid(getuid());          /* (b) Permanently drop privileges */
    ```

## 第十章

1.  最大的无符号 32 位整数值是 4,294,967,295。除以每秒 100 个时钟滴答声后，这相当于略多于 497 天。除以 100 万（`CLOCKS_PER_SEC`）后，这相当于 71 分钟 35 秒。

## 第十二章

1.  解决方案可以在本书的源代码分发包中的文件 `sysinfo/procfs_user_exe.c` 中找到。

## 第十三章

1.  这段语句确保写入 *stdio* 缓冲区的数据被刷新到磁盘。*fflush()* 调用将 *fp* 的 *stdio* 缓冲区刷新到内核缓冲区缓存中。随后传递给 *fsync()* 的参数是 *fp* 所对应的文件描述符；因此，该调用将该文件描述符的（最近填充的）内核缓冲区刷新到磁盘。

1.  当标准输出发送到终端时，它是行缓冲的，因此 *printf()* 调用的输出会立即显示，并紧接着是 *write()* 的输出。当标准输出发送到磁盘文件时，它是块缓冲的。因此，*printf()* 的输出会保存在 *stdio* 缓冲区中，只有在程序退出时（即在 *write()* 调用之后）才会刷新。 (包含本练习代码的完整程序可在本书的源代码分发包中的文件 `filebuff/mix23_linebuff.c` 中找到。)

## 第十五章

1.  *stat()* 系统调用不会更改任何文件的时间戳，因为它所做的只是从文件 i-node 获取信息（而且没有 *最后 i-node 访问* 时间戳）。

1.  GNU C 库提供了这样一个函数，名为 *euidaccess()*，位于库的源文件 `sysdeps/posix/euidaccess.c` 中。

1.  为了做到这一点，我们必须使用两个 *umask()* 调用，具体如下：

    ```
    mode_t currUmask;

    currUmask = umask(0);       /* Retrieve current umask, set umask to 0 */
    umask(currUmask);           /* Restore umask to previous value */
    ```

    ### 注意

    然而，请注意，这个解决方案不是线程安全的，因为线程共享进程的 umask 设置。

1.  解决方案可以在本书的源代码分发包中的文件 `files/chiflag.c` 中找到。

## 第十八章

1.  使用*ls -li*显示可执行文件在每次编译后具有不同的 i 节点编号。发生的情况是，编译器删除（取消链接）任何与目标可执行文件同名的现有文件，然后创建一个具有相同名称的新文件。取消链接可执行文件是允许的。文件名会立即删除，但文件本身在执行该文件的进程终止之前依然存在。

1.  文件`myfile`是在子目录`test`中创建的。*symlink()*调用在父目录中创建了一个相对链接。尽管看起来是这样，但这是一个悬挂链接，因为它是相对于链接文件的位置解释的，因此指向了父目录中一个不存在的文件。因此，*chmod()*失败并显示错误`ENOENT`（“没有这样的文件或目录”）。 （包含此练习代码的完整程序可以在本书源代码分发包中的文件`dirs_links/bad_symlink.c`中找到。）

1.  解决方案可以在本书源代码分发包中的文件`dirs_links/list_files_readdir_r.c`中找到。

1.  解决方案可以在本书源代码分发包中的文件`dirs_links/file_type_stats.c`中找到。

1.  使用*fchdir()*更加高效。如果我们在循环中反复执行此操作，那么通过*fchdir()*我们可以在执行循环之前调用一次*open()*，而使用*chdir()*时，我们可以将*getcwd()*调用放在循环外。然后，我们比较反复调用*fchdir(fd)*和*chdir(buf)*之间的差异。调用*chdir()*的代价较高，有两个原因：将*buf*参数传递给内核需要在用户空间和内核空间之间进行较大的数据传输，并且每次调用时，*buf*中的路径名必须解析为相应的目录 i 节点。（内核对目录项信息的缓存减少了第二点所需的工作量，但仍然需要进行一些工作。）

## 第二十章

1.  解决方案可以在本书源代码分发包中的文件`signals/ignore_pending_sig.c`中找到。

1.  解决方案可以在本书源代码分发包中的文件`signals/siginterrupt.c`中找到。

## 第二十二章

1.  与大多数 UNIX 实现一样，Linux 在实时信号之前交付标准信号（SUSv3 并不要求如此）。这是有道理的，因为一些标准信号表示程序应该尽快处理的关键条件（例如硬件异常）。

1.  在这个程序中，将*sigsuspend()*和信号处理程序替换为*sigwaitinfo()*提供了 25%到 40%的速度提升。（具体数字会根据不同的内核版本略有不同。）

## 第二十三章

1.  使用*clock_nanosleep()*的修改版程序已在本书的源代码分发包中的文件`timers/t_clock_nanosleep.c`中提供。

1.  解决方案已在本书的源代码分发包中的文件`timers/ptmr_null_evp.c`中提供。

## 第二十四章

1.  第一次*fork()*调用创建了一个新的子进程。父进程和子进程都继续执行第二次*fork()*，因此每个进程都会创建一个新的进程，总共创建了四个进程。所有四个进程继续执行下一个*fork()*，每个进程都会创建一个新的子进程。结果，总共创建了七个新的进程。

1.  解决方案已在本书的源代码分发包中的文件`procexec/vfork_fd_test.c`中提供。

1.  如果我们调用*fork()*，然后让子进程调用*raise()*发送一个信号，例如`SIGABRT`，这将生成一个核心转储文件， closely mirror 父进程在*fork()*时的状态。*gdb gcore*命令允许我们对程序执行类似的操作，而无需更改源代码。

1.  在父进程中添加一个相反的*kill()*调用：

    ```
    if (kill(childPid, SIGUSR1) == -1)
        errExit("kill")
    ```

    并且在子进程中，添加一个相反的*sigsuspend()*调用：

    ```
    sigsuspend(&origMask);          /* Unblock SIGUSR1, wait for signal */
    ```

## 第二十五章

1.  假设使用的是二进制补码架构，其中-1 由所有位都为 1 的位模式表示，那么父进程将看到一个退出状态 255（最低有效的 8 位全部为 1，这也是父进程在调用*wait()*时所返回的内容）。(*exit(-1)*的调用通常是程序员的错误，源于与用于指示系统调用失败的-1 返回值的混淆。)

## 第二十六章

1.  解决方案已在本书的源代码分发包中的文件`procexec/orphan.c`中提供。

## 第二十七章

1.  *execvp()*函数首先因没有执行权限而无法执行`dir1`中的文件`xyz`。因此，它继续在`dir2`中查找，并成功执行了`xyz`。

1.  解决方案已在本书的源代码分发包中的文件`procexec/execlp.c`中提供。

1.  脚本指定了*cat*程序作为其解释器。*cat*程序通过打印文件内容来“解释”文件——在这种情况下启用了*-n*（行号）选项（就像我们输入了命令*cat -n ourscript*）。因此，我们会看到如下内容：

    ```
    1  #!/bin/cat -n
         2  Hello world
    ```

1.  两次连续调用*fork()*会产生总共三个进程，它们之间的关系是父进程、子进程和孙进程。创建了孙进程后，子进程立即退出，并通过父进程中的*waitpid()*调用被收割。由于被孤儿化，孙进程被*init*（进程 ID 为 1）收养。程序不需要执行第二次*wait()*调用，因为*init*会在孙进程终止时自动收割僵尸进程。这个代码序列的一个可能用途就是：如果我们需要创建一个子进程，但之后不能等待它，那么这个序列可以确保不会产生僵尸进程。一个这样的需求示例是，父进程执行某个程序，该程序并不保证执行*wait*（而且我们不想依赖设置`SIGCHLD`的处理方式为`SIG_IGN`，因为 SUSv3 对*exec()*之后忽略的`SIGCHLD`的处理方式没有明确规定）。

1.  给*printf()*的字符串不包含换行符，因此在*execlp()*调用之前，输出不会被刷新。*execlp()*会覆盖现有程序的数据段（以及堆和栈），这些段包含*stdio*缓冲区，因此未刷新的输出会丢失。

1.  `SIGCHLD`会传递给父进程。如果`SIGCHLD`处理程序尝试执行*wait()*，那么该调用会返回一个错误（`ECHILD`），表示没有子进程的状态可以返回。（这假设父进程没有其他已终止的子进程。如果有，则*wait()*会阻塞；或者如果使用了带有`WNOHANG`标志的*waitpid()*，*waitpid()*会返回 0。）如果程序在调用*system()*之前为`SIGCHLD`设置了处理程序，就会出现这种情况。

## 第二十九章

1.  有两种可能的结果（都由 SUSv3 允许）：线程死锁，在尝试与自身连接时被阻塞，或者*pthread_join()*调用失败，返回错误`EDEADLK`。在 Linux 上，会发生后一种行为。给定一个线程 ID 在*tid*中，我们可以使用以下代码来防止这种情况的发生：

    ```
    if (!pthread_equal(tid, pthread_self()))
       pthread_join(tid, NULL);
    ```

1.  在主线程终止后，*threadFunc()*将继续使用主线程栈上的存储，可能导致不可预知的结果。

## 第三十一章

1.  解决方案已在本书源代码发布包中的`threads/one_time_init.c`文件中提供。

## 第三十三章

1.  由于子进程终止而生成的`SIGCHLD`信号是进程导向的。它可能会被传递给任何未阻塞该信号的线程（不一定是调用了*fork()*的线程）。

## 第三十四章

1.  假设该程序是一个 Shell 管道的一部分：

    ```
    $ `./ourprog | grep '```*`某个字符串`*```'`
    ```

    问题在于*grep*将与*ourprog*处于同一进程组中，因此*killpg()*调用也会终止*grep*进程。这可能不是预期的行为，并且可能会让用户困惑。解决方案是使用*setpgid()*确保子进程被放入各自的新组（第一个子进程的进程 ID 可以用作该组的进程组 ID），然后发送信号到该进程组。这也不再需要父进程使其自己对信号免疫。

1.  如果在再次发送`SIGTSTP`信号之前解除对该信号的屏蔽，则会存在一个小的时间窗口（在调用*sigprocmask()*和*raise()*之间），在此期间，如果用户再次输入暂停字符（*Control-Z*），则进程会在处理程序中被停止。因此，需要发送两个`SIGCONT`信号来恢复进程。

## 第三十五章

1.  解决方案已在本书的源代码分发包中的`procpri/demo_sched_fifo.c`文件中提供。

## 第三十六章

1.  解决方案已在本书的源代码分发包中的`procres/rusage_wait.c`文件中提供。

1.  解决方案已在本书的源代码分发包中的`procres`子目录下的`rusage.c`和`print_rusage.c`文件中提供。

## 第三十七章

1.  解决方案已在本书的源代码分发包中的`daemons/t_syslog.c`文件中提供。

## 第三十八章

1.  每当一个非特权用户修改文件时，内核会清除该文件的设置用户 ID 权限位。如果启用了组执行权限位，设置组 ID 权限位也会被清除。（如第 55.4 节所述，设置组 ID 位开启且组执行位*关闭*的组合与设置组 ID 程序无关；相反，它用于启用强制锁定，因此修改此类文件不会禁用设置组 ID 位。）清除这些位确保了，如果程序文件可由任意用户写入，则该文件不能被修改后仍然保留给予执行该文件的用户特权的能力。一个特权的（`CAP_FSETID`）进程可以修改文件而不清除这些权限位。

## 第四十四章

1.  解决方案已在本书的源代码分发包中的`pipes/change_case.c`文件中提供。

1.  它创建了一个竞争条件。假设在服务器看到文件结束标志和关闭文件读取描述符之间，客户端打开了 FIFO 进行写入（这将成功且不会阻塞），然后在服务器关闭读取描述符之后向 FIFO 写入数据。此时，客户端将收到`SIGPIPE`信号，因为没有进程打开 FIFO 进行读取。或者，客户端可能能够在服务器关闭读取描述符之前同时打开 FIFO 并向其写入数据。在这种情况下，客户端的数据将丢失，并且它不会收到服务器的响应。作为进一步的练习，您可以通过对服务器进行建议的修改，并创建一个专用客户端，该客户端反复打开服务器的 FIFO，向服务器发送消息，关闭服务器的 FIFO，并读取服务器的响应（如果有的话），来演示这些行为。

1.  一种可能的解决方案是在客户端 FIFO 的*open()*操作上设置定时器，使用*alarm()*，如第 23.3 节所述。该解决方案的缺点是服务器仍然会在超时期间延迟。另一种可能的解决方案是使用`O_NONBLOCK`标志打开客户端 FIFO。如果失败，则服务器可以假定客户端行为异常。后一种解决方案还需要对客户端进行更改，确保它在向服务器发送请求之前先打开其 FIFO（同样使用`O_NONBLOCK`标志）。为了方便起见，客户端应关闭 FIFO 文件描述符的`O_NONBLOCK`标志，以便后续的*read()*调用可以阻塞。最后，可以为该应用程序实现并发服务器解决方案，主服务器进程为每个客户端创建一个子进程来发送响应消息。（在这种简单应用程序的情况下，这将是一个相当耗费资源的解决方案。）

    该服务器未处理的其他条件仍然存在。例如，它没有处理序列号溢出或恶意客户端请求大量序列号以产生溢出的情况。服务器也没有处理客户端指定负值作为序列长度的可能性。此外，恶意客户端可以创建其回复 FIFO，然后打开 FIFO 进行读写，并在向服务器发送请求之前向其中填充数据；因此，服务器能够成功打开回复 FIFO，但在尝试写入回复时将会阻塞。作为进一步的练习，您可以尝试设计策略来处理这些可能性。

    在第 44.8 节中，我们还提到过另一个适用于示例 44-7 中服务器的限制：如果客户端发送了包含错误字节数的消息，那么服务器在读取所有后续客户端消息时会步调不一致。处理此问题的一种简单方法是放弃使用固定长度的消息，转而使用定界符字符。

## 第四十五章

1.  解决方案可以在本书的源代码分发包中的`svipc/t_ftok.c`文件中找到。

## 第四十六章

1.  值 0 是一个有效的消息队列标识符，但 0 不能作为消息类型使用。

## 第四十七章

1.  解决方案可以在本书的源代码分发包中的`svsem/event_flags.c`文件中找到。

1.  预留操作可以通过从 FIFO 中读取一个字节来实现。相反，释放操作可以通过向 FIFO 写入一个字节来实现。条件预留操作可以通过非阻塞读取 FIFO 中的一个字节来实现。

## 第四十八章

1.  由于`for`循环增量步骤中的*shmp->cnt*值的访问不再受到信号量的保护，因此写入者更新该值与读取者获取该值之间存在竞争条件。

1.  解决方案可以在本书的源代码分发包中的`svshm/svshm_mon.c`文件中找到。

## 第四十九章

1.  解决方案可以在本书的源代码分发包中的`mmap/mmcopy.c`文件中找到。

## 第五十章

1.  解决方案可以在本书的源代码分发包中的`vmem/madvise_dontneed.c`文件中找到。

## 第五十二章

1.  解决方案可以在本书的源代码分发包中的`pmsg/mq_notify_sigwaitinfo.c`文件中找到。

1.  将*buffer*设置为全局变量是不安全的。一旦在*threadFunc()*中重新启用消息通知，就有可能在*threadFunc()*仍在执行时生成第二个通知。这个第二个通知可能会启动第二个线程，在第一个线程执行的同时运行*threadFunc()*。两个线程都会尝试使用相同的全局*buffer*，结果不可预测。请注意，这里的行为是依赖于实现的。SUSv3 允许实现按顺序将通知发送到同一线程。然而，也可以允许在多个线程中发送通知，这些线程可以并发执行，这也是 Linux 的实现方式。

## 第五十三章

1.  解决方案可以在本书的源代码分发包中的`psem/psem_timedwait.c`文件中找到。

## 第五十五章

1.  以下内容适用于 Linux 上的*flock()*：

    1.  一系列共享锁可能会导致等待放置独占锁的进程发生饥饿现象。

    1.  关于哪个进程被授予锁，并没有规则。实质上，锁会授予下一个被调度的进程。如果该进程恰好获得了共享锁，那么所有请求共享锁的其他进程也将能够同时获得它们的请求。

1.  *flock()*系统调用不会检测死锁。这适用于大多数*flock()*实现，除了那些通过*fcntl()*实现*flock()*的情况。

1.  除了早期的（1.2 及更早版本的）Linux 内核之外，两种类型的锁是独立操作的，并且互不影响。

## 第五十七章

1.  在 Linux 上，*sendto()*调用会失败并返回错误`EPERM`。在一些其他 UNIX 系统上，会出现不同的错误。其他一些 UNIX 实现并不强制执行此约束，允许已连接的 UNIX 域数据报套接字接收来自其他发送方的数据报。

## 第五十九章

1.  解决方案已在本书源代码分发中的`sockets`子目录下的`read_line_buf.h`和`read_line_buf.c`文件中提供。

1.  解决方案已在本书源代码分发中的`sockets`子目录下的`is_seqnum_v2_sv.c`、`is_seqnum_v2_cl.c`和`is_seqnum_v2.h`文件中提供。

1.  解决方案已在本书源代码分发中的`sockets`子目录下的`unix_sockets.h`、`unix_sockets.c`、`us_xfr_v2.h`、`us_xfr_v2_sv.c`和`us_xfr_v2_cl.c`文件中提供。

1.  在互联网域中，来自非对等套接字的数据报会被默默丢弃。

## 第六十章

1.  解决方案已在本书源代码分发中的`sockets/is_echo_v2_sv.c`文件中提供。

## 第六十一章

1.  由于 TCP 套接字的发送和接收缓冲区大小有限，如果客户端发送大量数据，可能会填满这些缓冲区，此时进一步的*write()*会（永久性地）阻塞客户端，直到它读取到服务器的响应。

1.  解决方案已在本书源代码分发中的`sockets/sendfile.c`文件中提供。

## 第六十二章

1.  如果*tcgetattr()*应用于一个不指向终端的文件描述符，则会失败。

1.  解决方案已在本书源代码分发中的`tty/ttyname.c`文件中提供。

## 第六十三章

1.  解决方案已在本书源代码分发中的`altio/select_mq.c`文件中提供。

1.  会导致竞争条件。假设发生以下事件序列：（a）在*select()*通知程序自管道有数据后，它执行适当的操作以响应信号；（b）另一个信号到达，处理程序向自管道写入一个字节并返回；（c）主程序清空自管道。因此，程序会错过在步骤（b）中传递的信号。

1.  *epoll_wait()*调用会阻塞，即使兴趣列表为空。这在多线程程序中非常有用，在这种程序中，一个线程可能会将描述符添加到*epoll*兴趣列表，而另一个线程则会在*epoll_wait()*调用中被阻塞。

1.  连续的*epoll_wait()*调用会循环遍历准备好的文件描述符列表。这很有用，因为它有助于防止文件描述符饥饿，如果*epoll_wait()*总是（例如）返回最小编号的准备好的文件描述符，并且该文件描述符始终有输入可用，就可能发生饥饿。

## 第六十四章

1.  首先，子 shell 进程终止，然后是*script*父进程终止。由于终端处于原始模式，*Control-D*字符不会被终端驱动程序解释，而是作为字面字符传递给*script*父进程，后者将其写入伪终端主设备。伪终端从设备处于规范模式，因此*Control-D*字符被视为文件结束符，这导致子 shell 的下一个*read()*返回 0，从而导致 shell 终止。shell 的终止关闭了唯一一个指向伪终端从设备的文件描述符。因此，父进程*script*的下一次*read()*会失败，并返回错误`EIO`（或在其他一些 UNIX 实现中为文件结束符），然后该进程终止。

1.  解决方案在本书的源代码分发包中的文件`pty/unbuffer.c`中提供。
