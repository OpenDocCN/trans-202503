- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEIGHBORS
    AND NEIGHBORHOODS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Almost every algorithm in this book requires interacting with a node’s *neighbors*.
    The idea of a neighbor is intuitively quite familiar; in an undirected graph,
    the neighbors of a given node are those nodes with which it shares an edge. The
    terminology for neighbors is a little more complex in directed graphs, where there
    are different types of neighbors depending on whether the edge is incoming or
    outgoing.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the set of neighbors for a given node is a foundational step in
    most graph algorithms, such as searching for paths through a new graph, and many
    real-world tasks. When planning a trip through a transportation network, for example,
    we might ask which cities we can reach directly from the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces the formal definition of neighbors and presents some
    basic functions we’ll use throughout the book. It also introduces two example
    neighbor-based metrics: a node’s degree and its clustering coefficient. These
    metrics provide insights about a node’s neighborhood that help us analyze the
    characteristics of graphs. A node’s degree tells us its number of connections
    and its clustering coefficient tells us about the interconnectedness of its neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Undirected Graphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many metrics and algorithms require determining the set of nodes in immediate
    proximity to a given node *v*. In an undirected graph, the *neighbors* of node
    *v* are all nodes connected to *v* by an edge. [Figure 2-1](#fig2-1) shows an
    example graph and lists the neighbors for each node. Node 0 has three neighbors
    (1, 3, and 4), while node 3 has only one neighbor (0).
  prefs: []
  type: TYPE_NORMAL
- en: '![Six nodes are labeled 0 through 5\. Each node is a circle and edges are lines
    joining a pair of circles. Each node also lists its set of neighbors. For example,
    node 0 is labeled with the set {1, 3, 4}.](../images/f02001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: An undirected graph
    with neighbors listed for each node</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can add a short helper function to our <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class to compute the set of neighbors in an undirected graph, as shown in [Listing
    2-1](#list2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Determining the
    set of neighboring nodes in an undirected graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function
    in [Listing 2-1](#list2-1) creates an empty <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    data structure, then iterates through each of the node’s edges and adds the corresponding
    neighbor to the set.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a graph representing a social network, where each person is a node
    and an undirected edge between node *v* and node *u* indicates those two people
    are friends. We might use a node’s neighbors to compose a guest list for a party,
    or to model how a rumor spreads within the network.
  prefs: []
  type: TYPE_NORMAL
- en: As another application of determining a node’s neighbors, consider the age-old
    question, “Who was in a movie with that particular star?” This is a question we
    will consider in more detail later in the chapter. We can build a co-occurrence
    graph that represents which actors appear together in a movie. Each node represents
    a single person. An edge indicates that two people have appeared in the same movie
    together. Since this relationship is always symmetric, we use an undirected graph
    to model these co-occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Directed Graphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In directed graphs, we could consider several types of nodes to be neighbors:
    the nodes at the end of outgoing edges from *v*, the nodes at the beginning of
    incoming edges to *v*, or the nodes on either side of a directed edge. To resolve
    this ambiguity, we divide neighbors for such graphs into two main types. *In-neighbors*
    are all nodes that have edges with *v* as the destination; in other words, the
    edge is incoming from node *v*’s perspective. In a directed social network where
    friendships are not symmetrical, for example, *v*’s in-neighbors are the friends
    who would tell them the latest gossip. *Out-neighbors* are all nodes to which
    *v* has an outgoing edge, representing the friends to which *v* would pass gossip.'
  prefs: []
  type: TYPE_NORMAL
- en: The code we add to <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class for computing out-neighbors in a directed graph is identical to the code
    presented in [Listing 2-1](#list2-1) for undirected graphs, except for the name
    of the function, as shown in [Listing 2-2](#list2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Determining the
    set of out-neighbors in a directed graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_out_neighbors()</samp>
    function iterates through all the edges and collects the destination nodes in
    a set that it then returns. The social equivalent would be compiling a list of
    people to whom one person sends messages.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the code for computing the set of in-neighbors requires us to search
    through every node in the graph, because we do not maintain lists of edges pointing
    *into* a given node, as shown in [Listing 2-3](#list2-3). This code is called
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class so that
    it has access to the full list of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Determining the
    set of in-neighbors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Like other neighbor algorithms, the code constructs the neighbors from an initially
    empty set. The function iterates over each node and checks whether the target
    node has an entry in that node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    dictionary ❶. If the target node has an entry in the node’s edges dictionary,
    the neighbor is added to the set.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we run [Listing 2-3](#list2-3) on an undirected graph? Not only
    does the function not fail, but it also produces the correct set of neighbors.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp> function
    considers the same neighboring nodes as the code in [Listing 2-1](#list2-1), but
    from the opposite side of the edge. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp>
    is significantly less efficient than <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    on an undirected graph because it iterates over all nodes in the graph and not
    just the ones connected to the target node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Self-Loops</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One additional complexity when defining neighbors is the potential for *self-loops*,
    in which an edge links a node to itself. For example, in [Figure 2-2](#fig2-2),
    node 1 has an edge to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four nodes. Node 1 has an arrow from the node back to itself.](../images/f02002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: A graph with a
    self-loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Self-loops work like circular roads that return to their starting points. More
    topically, we can visualize them in the context of my conversations about this
    very book. If we use a weighted graph to represent the number of conversations
    I had with various people, the largest weighted edge would be a self-loop indicating
    the number of times I mumbled to myself while trying to work something out.
  prefs: []
  type: TYPE_NORMAL
- en: In the adjacency list representation, a self-loop is represented by the inclusion
    of an edge whose destination matches its origin. In the adjacency matrix representation,
    a self-loop for node *v* is represented by a nonzero value along the diagonal
    of the matrix (row = *v*, column = *v*).
  prefs: []
  type: TYPE_NORMAL
- en: If node *v* has a self-loop, we consider it a neighbor of itself. In the case
    of a directed graph, this means node *v* is both its own in-neighbor and its own
    out-neighbor, since the edge starts and ends at node *v*.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we use the common computer science convention of allowing
    self-loops only in directed graphs. While many algorithms can handle undirected
    graphs with self-loops, and most of the rest can easily be adapted to do so, these
    loops often do not make sense in the context of the problems that the undirected
    graphs are modeling. For example, the graph-coloring problem examined in [Chapter
    16](chapter16.xhtml) requires us to assign different colors to any two nodes connected
    by an edge. Self-loops make no sense in such a problem formulation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Degree</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One useful statistic for understanding a node’s connectivity is its *degree*,
    the number of times edges connect to a node. [Figure 2-3](#fig2-3) shows an example
    undirected graph where each node is labeled with its degree. Node 0 has a degree
    of 3, while node 5 has a degree of 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with six nodes labeled with their degrees. Node zero is connected
    to nodes one, three, and four and labeled with degree 3.](../images/f02003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: An undirected graph
    with each node’s degree shown</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In social networks, a node’s degree would indicate the number of friends that
    person has. We can use this as a rough proxy for how popular or well-connected
    that person is.
  prefs: []
  type: TYPE_NORMAL
- en: From a mathematical standpoint, edges forming self-loops in undirected graphs
    are counted twice for the degree, since they contact the node on each end. While
    we do not use self-loops in undirected graphs for the algorithms in this book,
    we will include this check for completeness when computing degree in [Chapter
    18](chapter18.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In directed graphs, we break the concept of degrees into two separate measures,
    as we do for neighbors. A node’s *out-degree* measures the number of connections
    out of that node, while its *in-degree* measures the number of edges from other
    nodes into the given node. In a social network, your in-degrees and out-degrees
    could represent the number of people with whom you share news and the number of
    people who share news with you, respectively. Good confidants are friends with
    a high in-degree and a low out-degree. Good sources of gossip have both a high
    in-degree, to collect tidbits, and a high out-degree, indicating their willingness
    to pass those tidbits along.
  prefs: []
  type: TYPE_NORMAL
- en: Edges forming self-loops in directed graphs have the same *origin* and *destination*.
    They count once toward the in-degree and once toward the out-degree. For example,
    [Figure 2-4](#fig2-4) shows a directed graph and the degrees for each node. The
    left-hand side of the figure shows each node’s out-degree, while the right-hand
    side shows their in-degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two graphs with six nodes each. In both, node 0 has outgoing arrows to nodes
    1 and 3 and an incoming arrow from node 4\. In the graph on the left, node 0 has
    a label of 2\. In the graph on the right, Node 0 has a label of 1.](../images/f02004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: A directed graph
    labeling each node’s out-degree (a) and in-degree (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Computing a node’s in-degree or out-degree in a connected graph requires counting
    the number of incoming or outgoing edges. To do so, we can adapt the neighbor
    computation code from the previous section by keeping a counter instead of building
    a set.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Clustering Coefficient</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *clustering coefficient* of a node (sometimes called the *local clustering
    coefficient*) is a metric that characterizes how interconnected the node’s neighbors
    are with each other. In the context of a social network, the clustering coefficient
    effectively asks, “To what extent are my friends also friends with each other?”
    At zero, the metric indicates that none of our friends like each other, leading
    to extremely awkward parties. At the other extreme, a value of one indicates that
    every one of our friends is connected to every other friend.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, the clustering coefficient for a node *v* in an undirected graph is
    the fraction of possible edges among *v*’s neighbors that exist. We find the set
    of all neighbors (all nodes that share an edge with *v*), count how many of those
    neighbors share an edge with each other, and divide that by the total number of
    possible edges within that set. If node *v* has *k* neighbors, there could be
    up to *k* (*k* – 1) / 2 possible edges between them.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes with one or fewer neighbors need special treatment because their neighbors
    have zero possible connections. If someone has no friends, it makes no sense to
    compute the percentage of their friends who like each other. For simplicity, we
    return a value of 0 in these cases, reflecting the lack of local connections.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a function to compute the clustering coefficient of a given node
    with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp> in an undirected
    graph, as shown in [Listing 2-4](#list2-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Code to compute
    the local clustering coefficient</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    function starts by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    function ❶ from [Listing 2-1](#list2-1) to generate the set of all neighboring
    nodes. It then uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to check each unique pair of neighbors. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over the node’s neighbors, and the second iterates over the neighbor’s
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: For each edge that includes the neighboring node, the code checks that the node
    on the other side of the edge has an index greater than the current neighbor node
    and is also a neighbor of the original node ❷. The first check is necessary to
    avoid double-counting the neighbors. Undirected edges appear twice in the adjacency
    lists but should be counted only once. Each edge (*u*, *v*) is counted only when
    *u* < *v*. If the edge passes this test, it is counted.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    function finishes by returning the fraction of total possible edges among neighbors
    that are observed, taking care to avoid a divide-by-zero if a node has one or
    zero neighbors ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](#fig2-5) shows an example graph that lists the clustering coefficient
    for each node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each node in this six-node graph is labeled with its clustering coefficient.
    Node 0 is connected to nodes 1, 3, and 4\. Of those neighbors, only nodes 1 and
    4 share a connection. node 0 has a coefficient of 1/3.](../images/f02005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: A graph with clustering
    coefficients</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Node 0 has three neighbors (1, 3, and 4), which can have three edges among themselves,
    but only a single pair of its neighbors (1 and 4) are connected, giving it a clustering
    coefficient of 1/3\. In contrast, node 5 has two neighbors that share an edge,
    giving it a clustering coefficient of 1\. Node 3 has only one neighbor and is
    therefore assigned a value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Computing the Average
    Clustering Coefficient</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The clustering coefficient tells us only about the characteristics of the graph
    around a single node. We can extend the insights provided by computing the *average
    local clustering coefficient* for all nodes of the graph, which provides a numerical
    measure of the local interconnectedness of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate this measure for an undirected graph by computing the clustering
    coefficient for each neighbor, then taking the average, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ave_clustering_coefficient()</samp>
    function loops through each node, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    on that node, and adds the result to a running total. As long as the function
    has seen at least one node, it returns the total divided by the number of nodes.
    For example, the graph in [Figure 2-5](#fig2-5) has a local clustering coefficient
    of approximately 0.5278.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Limitations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The clustering coefficient only provides information about the neighboring nodes’
    connectivity relative to a single given node, without telling us anything about
    those nodes’ connectivity in general. For example, consider the graph in [Figure
    2-6](#fig2-6). Node 0 has a clustering coefficient of 1, indicating that all its
    neighbors are mutually connected. However, this doesn’t tell us anything about
    the network one step farther away, much less *all* its neighbors’ connections.
  prefs: []
  type: TYPE_NORMAL
- en: '![A six-node graph. Node 0 is connected directly to nodes 1 and 2\. Nodes 3,
    4, and 5 all connect to node 1 and to each other; they are shaded to indicate
    they are not part of node 0’s clustering coefficient calculation.]](../images/f02006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The interconnections
    of node 0 and its immediate neighbors versus those neighbors’ connections</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-6](#fig2-6), node 1 has many additional connections that are not
    considered by the clustering coefficient because they are not directly connected
    to node 0’s neighbors. These connections are shown in gray, while immediate neighbors
    are shown in black. In this case, node 1 is part of two different sets of interconnected
    nodes, {0, 1, 2} and {1, 3, 4, 5}.
  prefs: []
  type: TYPE_NORMAL
- en: In our social network example, this means that the clustering coefficient cannot
    tell us about our friends’ friends. Our friends may get along with each other
    but also be part of other groups. Practically speaking, the local clustering coefficient
    can tell us if the people we invited to our party will get along, but it cannot
    tell us whether there is a bigger party they’ll go to instead. For example, if
    both nodes 0 and 4 from [Figure 2-6](#fig2-6) throw a party, node 1 would enjoy
    either event but would have more friends at node 4’s party.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Generating Neighborhood Subgraphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can extend the idea of neighbors to determine a *neighborhood subgraph* in
    an undirected graph, which includes both the neighboring nodes and the edges between
    them. We define two types of neighborhoods in undirected graphs depending on whether
    we want to include the original node. An *open-neighborhood* subgraph of node
    *v* consists of the neighbors of *v* and the edges between them. A *closed-neighborhood*
    subgraph of node *v* consists of node *v* and all its neighbors, as well as the
    edges between those nodes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can create a function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class to generate the open- or closed-neighborhood subgraph around a given node
    (with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>) in an undirected
    graph. This function operates by determining the neighboring nodes and using them
    to seed a new graph, then adding the appropriate edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_undirected_neighborhood_subgraph()</samp>
    function starts by checking if the graph is undirected and, if not, raising a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueError</samp> ❶. While this
    is not strictly necessary and the code will produce some results for directed
    graphs, it helps ensure the function is used as designed. Next, the code extracts
    the target node’s set of neighbors with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    function from [Listing 2-1](#list2-1) ❷. This set, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>,
    comprises all the nodes that will be used in the subgraph. If the subgraph is
    a closed-neighborhood subgraph, the code adds the target node itself to that set.
  prefs: []
  type: TYPE_NORMAL
- en: The code for generating neighborhood subgraphs is complicated slightly by the
    way the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class indexes
    the nodes. Since our graph uses numeric indices in the range [0, |*V* | – 1],
    where |*V* | is the number of nodes, any subgraph might use different indices
    for a given node. To account for this, the code builds a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">index_map</samp>
    that maps the old node index to the new node index ❸. This allows the generated
    subgraph to use numeric indices without gaps. As we will see later in [Figure
    2-8](#fig2-8), we can use alternate information, like the label, to preserve the
    identities of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code creates the new graph, using a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to do so. This code mirrors the local clustering coefficient code from [Listing
    2-4](#list2-4). The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>,
    while the second iterates over that node’s edges. By testing that the neighboring
    node’s index (<samp class="SANS_TheSansMonoCd_W5Regular_11">edge.to_node</samp>)
    is greater than the index of the current node <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>,
    the function guarantees it will insert each undirected edge only once ❹. A new
    edge is added only if both nodes are in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>
    and the other node has not already been processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function
    handles correctly inserting the undirected edge using the new node indices.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider what happens when we build a neighborhood subgraph from the graph
    in [Figure 2-7](#fig2-7). Returning to the earlier example of the movie star network,
    this graph could represent the seven stars (Alice, Bob, Carl, Dan, Edward, Fiona,
    and Gwen) who appear in the world-famous *Graph Theory* series of action thrillers:
    *Graph Theory* (with stars Alice and Bob), *Graph Theory 2: A New Node* (with
    stars Bob and Carl), *Graph Theory 3: The Lost Edge* (with stars Bob, Fiona, and
    Gwen), and so forth. Each node is labeled with the first letter of the star’s
    name and maps their connections to their co-stars.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with seven nodes. Node 1 is connected to nodes 0, 2, 5, and 6.](../images/f02007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: An undirected graph
    representing the stars of the</samp> <samp class="SANS_Futura_Std_Book_11">Graph
    Theory</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">series</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To understand more about the appearances of Bob and his co-stars, we create
    a closed-neighborhood subgraph around Bob (node 1). This represents the stars
    with whom Bob has shared the screen and captures the interactions among them.
    [Figure 2-8](#fig2-8) shows the operation to build this graph. The left column
    shows the full graph, with the current node being processed indicated by a dashed
    circle, and the right column shows the new subgraph at that point. As noted earlier,
    the subgraph’s nodes use different indices; in this case, we might store the star’s
    name in the node’s label.
  prefs: []
  type: TYPE_NORMAL
- en: '![Six rows indicating the steps of the neighborhood construction algorithm,
    labeled with letters a through f from top to bottom.](../images/f02008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The steps to construct
    a closed-neighborhood subgraph around Bob</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-8(a)](#fig2-8) begins by creating a new graph containing just Bob
    and his co-stars. The set of neighbors includes everyone with whom Bob has appeared
    on-screen. Alice is included from their appearance together in the original *Graph
    Theory* film, while the links to stars Fiona and Gwen come from the third, and
    best reviewed, installment in the series.'
  prefs: []
  type: TYPE_NORMAL
- en: The indexing also changes in the new graph. As shown in the figure, three of
    the people are given the same indices (nodes 0, 1, and 2), while two are assigned
    new indices (5 and 6). The node index for Fiona changes from 5 to 3 in the subgraph,
    and from 6 to 4 for Gwen. In [Appendix A](appendix_A.xhtml), we’ll discuss how
    to expand the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> structure
    to use string-based labels, which obviate the need for this index remapping.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the new graph, we iterate one by one through the people under
    consideration (Bob and his co-stars) and add new edges to the subgraph. When considering
    node 0 in [Figure 2-8(b)](#fig2-8), we add only one of their two edges, (0, 1).
    This is because both Alice and Bob are being considered. In contrast, Edward (node
    4) was only in the disastrous spin-off attempt *The Golden Vertex* with Alice.
    Since Edward never appeared on-screen with Bob, he is not part of Bob’s neighborhood
    subgraph.
  prefs: []
  type: TYPE_NORMAL
- en: When we get to Bob, who represents the franchise staple, we add edges to three
    new co-stars in [Figure 2-8(c)](#fig2-8). We do not add an edge back to Alice
    because we have already processed that node and its edges. The code continues
    through Carl in [Figure 2-8(d)](#fig2-8), Fiona in [Figure 2-8(e)](#fig2-8), and
    Gwen in [Figure 2-8(f)](#fig2-8). Since Edward and Dan didn’t co-star with Bob,
    they are not in the list of neighbors and are never considered. The final subgraph
    is shown on the right-hand side of [Figure 2-8(f)](#fig2-8).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A graph’s neighbors provide fundamental information about the local structure
    and interconnections around a given node. For the most part, the formal definitions
    of these terms are conveniently intuitive. When traversing a graph, we ask which
    nodes are neighbors of the current node and are thus reachable. Neighbors will
    form the basis of our discussion of graph search algorithms in later chapters,
    as many of these algorithms share the core loop of iterating over a node’s edges
    and seeing which other nodes share them.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts like a node’s degree and its local clustering coefficient provide concrete
    metrics about its immediate neighbors and neighborhood. These example metrics
    are only a fraction of the multitude of ways to quantify the properties of a graph.
    Numerous metrics have been developed to analyze the properties of real-world graphs,
    from their level of interconnectedness to their width. A comprehensive review
    of all graph metrics is well outside the scope of this book, but upcoming chapters
    discuss some additional analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we consider another foundational graph algorithm concept:
    paths. Paths provide a description of movements throughout the graph and allow
    us to record how to traverse from one node to another.'
  prefs: []
  type: TYPE_NORMAL
