- en: 9. hardware hacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The biggest barrier to hacking is often the fear that you’ll break something
    while poking around. But you have to break eggs to make an omelet; likewise, you
    have to be willing to sacrifice devices to hack a system. Fortunately, acquiring
    multiple copies of a mass-produced piece of hardware is easy. I often do a bit
    of dumpster diving or check classified advertisements to get sample units for
    research purposes. I generally try to start with three copies: one to tear apart
    and never put back together, one to probe, and one to keep relatively pristine.
    I use the pristine copy to sanity-check whether a certain behavior is due to my
    probing or just how the hardware behaves.'
  prefs: []
  type: TYPE_NORMAL
- en: My typical approach to any hardware hack is first getting the device open and
    then getting a probe in just the right spot without affecting the device’s functionality.
    When you’re looking inside computer chips, that’s virtually the entire challenge.
    The first hack in this chapter is an example of silicon hacking, and you’ll see
    that once the package is off and you’re staring at naked silicon, an attacker
    has a profound advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Some hardware hacks require more system engineering, particularly when you want
    to reverse engineer and repur-pose a device. In these situations, I tend to develop
    additional bespoke tools that allow me to tweak and observe a system in close
    to real time, or at least as fast as I can type commands, to minimize the time
    spent validating hypotheses. The goal is to make the primary limitation how fast
    you can think of ideas to test, not how long it takes to upload a change to test
    those ideas. The second hack in this chapter talks about reverse engineering a
    relatively simple System-on-Chip (SoC) device found inside common SD memory cards
    and some tools I developed to aid that process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some hacks inevitably push the boundaries of the law. The third hack
    in this chapter talks about NeTV, a system I developed that takes a new look at
    the High-Definition Content Protection (HDCP) encryption standard, which secures
    most HDMI video links. NeTV is a hack on both a legal issue and a hardware system.
    It works around the thorny problems presented by the DMCA by reinterpreting the
    HDCP standard to enable a man-in-the-middle (MITM) attack to change video data
    without circumventing encryption. No circumvention, no DMCA problem. Hacks often
    push the boundary of what’s legal and what’s been tested in the courts. Just like
    any other system, the legal system can also be hacked, and one key takeaway from
    this chapter is how to think of laws as just another constraint to work with on
    the way to achieving a particular goal.
  prefs: []
  type: TYPE_NORMAL
- en: The final hack in this chapter combines hardware penetration, tool creation,
    and legal considerations to reverse engineer a complex mobile phone SoC. That’s
    another project I worked on with xobs, and once again, building bespoke hacking
    tools was invaluable because it allowed us to experiment with the system as it
    ran.
  prefs: []
  type: TYPE_NORMAL
- en: '**HACKING THE PIC18F1320**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping a secret is a common challenge for any security system. To solve this
    challenge, security system designers frequently hide secrets inside silicon chips
    because the chips’ rugged epoxy packages and tiny geometries are difficult to
    penetrate and inspect.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds good in theory but is problematic in practice. Chip designers make
    mistakes, and when a chip has a problem, the designers need a way to open it up
    and investigate. This situation is so common that there are commercial services
    that specialize in opening up chips expressly for that purpose. Called *failure
    analysis services*, they’ve mastered several techniques for removing tough epoxy
    from chips.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of years before my crash course in setting up a Chinese supply chain
    with Chumby, I decided it would be fun to demonstrate how simple hacking a chip
    can be if you’re aware of failure analysis services. At the time, Microchip’s
    PIC series of microcontrollers was quite ubiquitous, so I decided to have a go
    at a popular PIC model. PICs typically have *configuration fuses*, which you can
    activate to prevent certain regions of memory from being read or written to. But
    there’s often a legitimate need to read the contents of a secured, programmed
    PIC. For instance, a company that loses either the documentation for a product
    or the personnel that originally created the codes for a secured PIC would be
    stuck without a way to read the chip. This is a problem when a company needs to
    revise or upgrade a legacy line of products.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to figure out how to dump the memory from a secured PIC. Knowing I’d
    have to break a few eggs to make this omelet, I scored four PIC18F1320s from a
    friend and started stripping them down. Here’s what I found.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0282-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A PIC18F1320 in its native state*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decapping the IC**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, I had to take the top off so I could see the silicon under the hood.
    Many homebrew techniques for decapping a chip typically involve applying fuming
    nitric or sulfuric acid, but those aren’t compounds you’d want to keep at home,
    nor are they easy to obtain. Nitric acid, in particular, is an important compound
    for explosives fabrication. So, I’ve found the easiest and most reliable way to
    decap a chip is to just send it to a failure analysis lab. For about $50, you
    can have a decapped part in two days.
  prefs: []
  type: TYPE_NORMAL
- en: I decapped three parts for this project. Two were *functionally decapped* (silicon
    revealed with the device still in its lead frame, fully functional), and the last
    was *fully decapped* (just a bare silicon die with no package). I had one die
    fully decapped because my inspection microscope had a very short working distance
    at the highest magnifications, and the remaining epoxy from the package would
    have interfered with the lens.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A functionally decapped PIC18F1320.'
  prefs: []
  type: TYPE_NORMAL
- en: The little raised square in the middle (it’s goldish in real life) is the silicon
    chip.*
  prefs: []
  type: TYPE_NORMAL
- en: '**Taking a Closer Look**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With my decapped ICs in hand, I did a sweep around one of the dies with the
    microscope and noticed several prominent features. Because physics is the same
    everywhere, most of the fine-grained structure in a silicon chip looks pretty
    much the same, no matter who makes the chip. These constraints propagate their
    way up to the system level, and with a bit of training, you can read a silicon
    chip like a book.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0283-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*My best guess at what various structures in this chip do. I could be wrong.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One set of structures grabbed my attention immediately: there were metal shields
    over some transistors, following a regular pattern that had about the right number
    of devices to account for all the security bits. Full-metal shields covering a
    device are very rare in silicon, so they’re like a big X marking the spot where
    something very important is kept.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0284-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Zooming in on the metal shields*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Erasing the Flash Memory**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shields were significant because of some interesting facts about flash memory
    technology, which this PIC device used to store the security fuse information,
    as well as the internal program code. Flash technology uses a floating-gate transistor
    structure very similar to old *UV-erasable programmable read-only memory (UV-EPROM)*
    technologies like the ceramic-packaged 2716 chips from the 1970s, which had quartz
    windows so they could be erased.
  prefs: []
  type: TYPE_NORMAL
- en: In both flash and UV-EPROM devices, data is written when electrons tunnel into
    a floating gate, where the electrons remain for decades. The extra electrons in
    the floating gate create a measurable offset in the characteristics of the storage
    transistor. The difference is that flash memory can withdraw the stored electrons
    (erase the device) using only electrical pulses, while a UV-EPROM requires energetic
    photons to knock the electrons out of the floating gate. The UV light required
    to accomplish this is typically on a wavelength of around 250 nm. You need expensive
    quartz optics to manipulate this wavelength of UV without excessive loss, making
    it a bit difficult to harness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the important conclusion I drew from these facts: flash devices can
    usually *also* be erased using UV light since they have a similar transistor structure
    to UV-EPROM devices. The encapsulation around a flash device normally prevents
    any UV light from effectively reaching the die, but since the PIC devices had
    the plastic around them removed, I could attempt to apply UV light and see what
    happened.'
  prefs: []
  type: TYPE_NORMAL
- en: I performed a simple experiment by programming the PIC device with a ramping
    pattern, where I stored the hexadecimal numbers from 0x00 to 0xFF over and over
    again. Then, I tossed the PIC into my UV-EPROM eraser to bake for ... oh, about
    the length of a good long shower and some email checking. When I took the device
    out of the eraser, the flash memory was indeed blanked to its normal all 1s state,
    and the security fuses were unaffected. After baking a few more PIC devices in
    the eraser, I found that if I didn’t bake a PIC long enough, I got odd readings
    out of the array I wrote to, such as all 0s, a phenomenon that I still don’t understand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Erasing the Security Bits**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Clearly, the metal shields over the security fuses were there to thwart attempts
    to selectively erase the security fuses while leaving the flash memory array unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0286-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A diagram showing how the shields got in the way of the fuse bits, and how
    to work around them*'
  prefs: []
  type: TYPE_NORMAL
- en: My problem was that for the flash memory transistor to be erased, high-intensity
    UV light needed to strike the floating gate. The metal shield effectively reflected
    all incident light, so the light never reached the gate. But I knew there was
    a refraction index mismatch between the optically clear protective dielectric
    layer of silicon dioxide covering the chip and the silicon proper, meaning light
    at certain angles would reflect off of the smooth silicon surface. For an example
    of this reflective effect, jump in a swimming pool, go under water, and look up
    at where the water and air meet. The water should look highly reflective at an
    oblique angle because the refractive index mismatch between water and air causes
    total internal reflection of light.
  prefs: []
  type: TYPE_NORMAL
- en: 'I planned to use this reflection to bounce the UV light off the oxide to hit
    the metal shield and bounce back onto the floating gate. By angling the PIC inside
    the ROM eraser, I thought I could get enough light to bounce into the flash memory
    transistor region and erase the security bits. After a couple of attempts using
    bits and bobs of material to fix the angle of the chip, I developed a simple technique
    that worked surprisingly well: shoving the chip into the antistatic foam liner
    of the UV eraser at an angle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0287-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The chip in the UV eraser’s antistatic foam*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protecting the Other Data**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: That technique didn’t protect the flash data I wanted to keep, though. To avoid
    erasing this data, I made a hard mask out of a very carefully cut piece of electrical
    tape and stuck that mask to the surface of the die using a steady hand, two tweezers,
    and a microscope. The electrical tape blocked the UV light from directly hitting
    the flash code memory regions and somewhat absorbed light bounced back from the
    silicon substrate.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0287-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The die in its package, with electrical tape over the flash ROM array*'
  prefs: []
  type: TYPE_NORMAL
- en: This mask allowed me to reset only the security fuses without impacting the
    flash code array too much. The following screenshots show the array memory status
    according to the programming and readback tool I was using.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0288-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*My PIC programmer workspace, showing the device settings before erasure The
    device settings after erasure*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0288-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The device settings after erasure*'
  prefs: []
  type: TYPE_NORMAL
- en: In the before shot, note the settings of the security fuses in the Configuration
    Bits window and the values programmed in the flash ROM, shown in the Program Memory
    window. In the after shot, the security fuses switch to being disabled, while
    the flash ROM contents in the Program Memory window read identically to what was
    programmed in previously. A different part of the code array was actually still
    erased, but I could probably have fixed that by cutting a bigger piece of electrical
    tape.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve heard reports that since this hack was published, Microchip started putting
    metal shields over the code memory array as well as the fuses, making it a bit
    more difficult to pull off this trick. Still, this hack underscores the fact that
    quite often, the hardest part of silicon hacking is removing the outer package,
    and fortunately, there are cheap, if obscure, services available to assist with
    that problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**HACKING SD CARDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Years later, I found myself hacking into yet another interesting device with
    flash memory: an SD card. I’d already torn down SD cards when investigating a
    batch of potentially fake cards that found their way into Chumby production units,
    which I discuss in “[Fake MicroSD Cards](ch05.xhtml#ch00lev1sec99)” on [page 156](ch05.xhtml#page_156).
    This time, my intent was to figure out how to get an SD card to do something it
    wasn’t made to do. This particular hack was another team effort with my friend
    xobs, and it was funded by DARPA’s Cyber Fast Track (CFT) initiative. The brainchild
    of uberhacker .mudge (one of the original crew of L0pht), CFT was a hack on the
    US government to make it smarter about innovation, particularly on matters related
    to internet security. We pulled it off around the same time we were working on
    Novena and I was collaborating with Jie Qi on Chibitronics.'
  prefs: []
  type: TYPE_NORMAL
- en: xobs and I discovered that some SD cards contain vulnerabilities that allow
    arbitrary code execution on the memory cards themselves. We also found that similar
    classes of vulnerabilities exist in related devices like USB flash drives and
    solid-state drives. On the dark side, code execution on a memory card enables
    MITM attacks where the card seems to behave one way but in fact does something
    else as an attacker intercepts and manipulates communications between the card
    and the device using it. On the light side, however, this vulnerability also gives
    hardware enthusiasts access to a very cheap and ubiquitous source of microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0290-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Some of the eggs—or rather, SD cards—we cracked open to find the vulnerability*'
  prefs: []
  type: TYPE_NORMAL
- en: '**How SD Cards Work**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand the hack, you need to know how SD cards are structured. The information
    I’m about to explain applies to all *managed flash* devices, which includes microSD,
    SD, and MMC, as well as the eMMC and iNAND devices typically soldered onto the
    mainboards of smartphones to store the operating system and other private user
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flash memory is billed as a contiguous, reliable storage medium, and it’s really
    cheap—so cheap that the premise is literally too good to be true. In reality,
    all flash memory is riddled with defects, without exception. It crafts the illusion
    of reliability through sophisticated error correction and badblock management
    functions. This system is the result of a constant arms race between the engineers
    and mother nature: every time the fabrication process shrinks transistors, memory
    becomes cheaper but more unreliable. Likewise, with every generation of chips,
    engineers create more sophisticated and complicated algorithms to compensate for
    nature’s propensity for entropy and randomness at the atomic scale.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These algorithms are too complicated and too device-specific to be run at the
    application or operating system level, so every flash memory disk ships with a
    reasonably powerful microcontroller to run a custom set of disk abstraction algorithms.
    Even tiny microSD cards contain not one, but *at least* two, chips: a controller
    and at least one flash chip. (High-density cards stack multiple flash dies.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0291-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Inside a microSD card. The small square in the upper-right corner is a microcontroller
    SoC mounted on top of the larger flash memory chip that it manages.*'
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, the quality of the flash chip(s) integrated into memory cards
    varies widely. The chip could be anything from high-grade, factory-new silicon
    to material with more than 80 percent bad sectors. If you’re concerned about e-waste,
    you may (or may not) be pleased to know that memory card vendors commonly use
    recycled flash chips salvaged from discarded parts. Larger vendors tend to offer
    more consistent quality, but even the largest players staunchly reserve the right
    to mix and match flash memory chips with different controllers yet sell the assembly
    as the same part number. That’s a nightmare if you’re dealing with implementation-specific
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: A memory card’s embedded microcontroller is often a heavily modified Intel 8051
    or ARM CPU that approaches 100 MHz performance levels and has several hardware
    accelerators on-die. Amazingly, adding these controllers to a memory card only
    costs about $0.15 to $0.30, particularly for companies that can fab both the flash
    memory and the controllers in the same business unit. Even more interestingly,
    due to the high cost of testing chips at the wafer level, it’s probably net cheaper
    to add a microcontroller that manages bad blocks, rather than thoroughly test
    and characterize each raw flash memory chip. And in fact, managed flash devices
    tend to be cheaper per bit than raw flash chips, despite the extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Every flash implementation has unique algorithmic requirements, multiplying
    the number of hardware abstraction layers a microcontroller must handle. This
    complexity inevitably leads to bugs, meaning indelibly burning a static body of
    code into on-chip ROM just isn’t feasible, particularly for third-party controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, a firmware loading and update mechanism is virtually mandatory. End users
    are rarely exposed to this process since it all happens in the factory, but the
    mechanism exists. While exploring the electronics markets in China, I’ve seen
    shopkeepers burn firmware onto a card that “expands” the card’s capacity. In other
    words, they load firmware that reports the capacity of a card as much larger than
    the actual available storage. The fact that this is possible at the point of sale
    indicates the update mechanism is likely not well secured.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Engineering the Card’s Microcontroller**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: xobs and I discovered an example of this vulnerability while exploring memory
    cards using AppoTech’s AX211 and AX215 microcontrollers. We discovered a simple
    “knock” sequence transmitted over manufacturer-reserved commands (a command named
    `CMD63` followed by the bytes `A`, `P`, `P`, `O`) that dropped the controller
    into a firmware loading mode. After receiving the knock sequence, the card accepted
    the next 512 bytes and ran the data as code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The AppoTech chips I describe here technically integrate sufficient functionality
    that in an academic sense, they’re not mere microcontrollers; they’re full SoCs.
    But it’s just* weird *to me to refer to the AppoTech as an SoC, so I won’t. It
    will always be a microcontroller to me!*'
  prefs: []
  type: TYPE_NORMAL
- en: The AppoTech system on this particular memory card also used an 8051 microcontroller.
    From the knock sequence beachhead, we used a combination of analyzing code with
    IDA, the interactive disassembler, and *fuzzing* (that is, giving the microcontroller
    invalid or random input to see how it responds) to reverse engineer most of the
    8051’s function-specific registers. That allowed us to develop novel applications
    for the controller without the manufacturer’s proprietary documentation. We did
    most of this work with the Novena laptop hardware I described in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: As I alluded at the beginning of this chapter, we developed several bespoke
    tools to help us reverse engineer the SD card. One of the more interesting tools
    we (and by we, I mean primarily xobs) made is an interactive REPL (read-evaluate-print-loop)
    shell for executing arbitrary code on the SD card. The following listing shows
    what that environment looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From inside this environment, we could run programs in a debugger, get a list
    of available commands and what they did by entering `help`, and disassemble sections
    of code by entering `disasm`. Although it took a lot of time to develop an interactive
    tool with such a rich feature set, the effort quickly paid off because we could
    test complex hypotheses using automated fuzzing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The code upload size was limited to 512 bytes, which meant we had to partition
    the REPL environment between the host Novena computer and the target device.[*](footnote.xhtml#fn26)
    For example, disassembling a particular region of memory breaks down to a script
    executed on the host side that drives issue requests to the AX211 to dump the
    requested portion of memory, followed by the disassembly algorithm running on
    the host ARM CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0295-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Partitioning the SD debugger functions between the host and the target*'
  prefs: []
  type: TYPE_NORMAL
- en: The tool we built started with an SD physical emulation layer, which I’ll refer
    to as *PHY*. We used the FPGA built into the Novena to present a GPIO-like register
    API for the SD host PHY. There was one register for data output, one register
    for data input, and one register to bitwise set the data direction. The AX211
    card was attached to the FPGA via a custom flex-circuit adapter.[*](footnote.xhtml#fn27)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0296-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A flex-circuit adapter plugged into a Novena*'
  prefs: []
  type: TYPE_NORMAL
- en: The SD commands were received on the AX211 and processed by a hardware state
    machine attached to the embedded 8051 CPU. The state machine handled receiving
    the data, plus it computed and checked the cyclic redundancy code for error detection.
    Once a complete packet was received by the state machine, an interrupt notified
    the 8051 of the packet’s arrival.
  prefs: []
  type: TYPE_NORMAL
- en: We hijacked the interrupt processing mechanism and remapped the default handler
    to our own 512-byte code stub. That allowed us to define a novel set of SD commands
    that we used to implement the callback functions our REPL environment needed,
    like `peek`, `poke`, `jump`, NAND register manipulation, and so on. These callbacks
    were also an ideal hook for implementing an MITM attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0297-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The callback functions for the REPL, displayed in IDA*'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know how many other manufacturers leave their firmware updating sequences
    unsecured. AppoTech is a relatively minor player in the SD controller world; a
    handful of companies that you’ve probably never heard of also produce SD controllers,
    including Alcor Micro, Skymedi, Phison, and SMI. Of course, there are also SanDisk
    and Samsung. Each has different mechanisms and methods for loading and updating
    firmware. But I know of at least one Samsung eMMC implementation using an ARM
    instruction set that had a bug requiring a firmware updater to be pushed to Android
    devices, indicating yet another potentially promising venue for further discovery.
  prefs: []
  type: TYPE_NORMAL
- en: '**Potential Security Issues**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a security perspective, our findings indicated that while memory cards
    look inert, they run code that could be modified to perform MITM attacks that
    are difficult to detect. There’s no standard protocol or method to inspect and
    attest to the contents of the code running on the memory card’s microcontroller.
    If you’re using an SD card in a high-risk, high-sensitivity situation, don’t assume
    that running a `security-erase` command (or some other secure erase tool) on a
    card will guarantee the complete erasure of sensitive data. If you really need
    data to disappear, I recommend disposing of your memory card through total physical
    destruction. Grind it up with a mortar and pestle if you have to.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Resource for Hobbyists**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a DIY and hacker perspective, our findings suggested a potentially interesting
    source of cheap and powerful microcontrollers for use in simple projects. An Arduino
    clone—with an 8-bit, 16 MHz microcontroller—will set you back around $20\. A microSD
    card with several gigabytes of memory and a microcontroller with several times
    the performance costs a fraction of the price. While SD cards are admittedly I/O-limited,
    some clever hacking of the microcontroller in an SD card could make for a very
    economical and compact data logging solution for I2C or SPI-based sensors.
  prefs: []
  type: TYPE_NORMAL
- en: '**HACKING HDCP-SECURED LINKS TO ALLOW CUSTOM OVERLAYS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “That’s neat, but is it legal?” is a frequently asked question I get when hacking.
    Just as engineered systems have hacks, legal systems have loopholes. Some legal
    loopholes exist by design; others are unintentional. Either way, they can provide
    vital breathing room for innovation. When contemplating a hack, I consider legal
    issues as I do engineering constraints, similar to having to fit something within
    a case of a certain height or run for a certain length of time on a given battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Around 2011, when I was still at Chumby, we were puzzling about how to drive
    adoption in the face of the iPhone and Android phones consuming the market niche
    we hoped to occupy. Cost was an eternal barrier for user adoption, and the integral
    LCD in a chumby was by far the highest-cost item. Our then-CEO, Steve Tomlin,
    observed that the biggest screen in the house had yet to become connected to the
    internet in any meaningful way. And so this question was posed to me: could we
    find a way to kill two birds with one stone, removing the screen from our bill
    of materials while bringing TVs into the internet age? This was before products
    like the Google Chromecast or the Logitech Revue were introduced on the market.'
  prefs: []
  type: TYPE_NORMAL
- en: It occurred to us that we could pack a cheap computer into a stick that plugs
    into an HDMI port. This solves the problem of getting chumby onto a TV screen,
    but then you’re not watching your favorite movies or TV shows when the chumby
    is selected. We figured what people really wanted was some way to watch TV and
    have, say, Twitter or Facebook notifications pop up onscreen, too.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is simple enough. Take the existing output from a cable box, Blu-ray
    player, or AV receiver; feed it into a box that blends in chumby content; and
    pass the resulting video on to a TV. But due to the ubiquitous application of
    HDCP encryption over digital video feeds, it is legally perilous to remix content
    if you do it the wrong way. Figuring out the right way to do it is how NeTV was
    born.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0300-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A NeTV sporting the Chumby logo*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0300-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Inside the NeTV*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background and Context**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NeTV was my response to the challenge of remixing existing video with internet
    content while staying within legal boundaries, aided by the public release of
    the master key to HDCP in September 2010\. To help you understand this hack, let’s
    start with a little background on HDCP.
  prefs: []
  type: TYPE_NORMAL
- en: High-bandwidth Digital Content Protection is a pixel-level encryption system
    used to encrypt video transmissions over HDMI. HDCP puts broadcasters and studios
    in control of the screens their content plays on, as those companies use the encryption
    as a copyright control mechanism. HDCP restricts legitimate content manipulation
    like picture-in-picture displays, content overlays, and third-party filtering
    and image modification. Combine HDCP with the DMCA, which criminalizes the circumvention
    of copyright control, and you’ll realize that when watching certain videos, it’s
    illegal to modify content on your own screen. That’s why there are few HDMI video
    mixing solutions that actually operate on broadcast or movie content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, I had four goals for NeTV: enable consumer-side content remixing,
    allow users to eliminate ads or replace them with ads relevant to themselves,
    create an interactive TV experience, and make something compatible with any TV.
    To accomplish those goals, I designed NeTV as a man in the middle to take data
    from, say, a Blu-ray player, and apply the master key to give users a custom overlay.
    There are many applications for video overlays, but the basic scenario is that
    while you’re enjoying content X, you’d also like to be aware of content Y. Combining
    the two content sources requires a video overlay mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: With my MITM attack, NeTV overlaid a WebKit browser (the engine Safari and Chrome
    use) over any video feed. A concrete use case for this technology is overlaying
    Twitter feeds as news crawlers across a TV show to watch community commentary
    in real time on the same screen you’re watching the show on. Some TV programs
    attempt to incorporate Twitter feeds already, but they’ve only done so on the
    source side; users can only watch hashtags the show displays. With this hack,
    however, the same broadcast program (say, a political debate) could have a very
    different viewing experience based on which hashtag is keyed into the viewer’s
    Twitter crawler.
  prefs: []
  type: TYPE_NORMAL
- en: The simple fact that a trivial video overlay is an interesting topic illustrates
    the distortion of traditional rights and freedoms brought about by the DMCA. Unlike
    the HDCP strippers people speculated would come out of the master key’s release,
    however, my hack never decrypted the original video data it operated on. Thus,
    it didn’t circumvent copyright, and the DMCA couldn’t apply to it. Loophole found!
  prefs: []
  type: TYPE_NORMAL
- en: '**How NeTV Worked**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, I released the exploit as an entirely open source project,[*](footnote.xhtml#fn28)
    including the hardware and the Verilog implementation of the Spartan-6 FPGA I
    used to create the TMDS-compatible source and sink. TMDS is the signaling standard
    used by HDMI and DVI. The basic pipeline within the FPGA deserializes incoming
    video and reserializes it to the output. In this trivial mode, NeTV is simply
    a signal amplifier for the video: encrypted pixels in, encrypted pixels out—no
    decryption and no video manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: NeTV could mix a user-generated content stream over an encrypted video feed
    because HDCP encrypts without validation. In other words, if a man in the middle
    tampers with the encrypted feed, the receiver simply accepts the tampered pixels
    as valid data, decrypts them, and presents them to the user. The lack of link
    verification is intentional and necessary. The natural bit error rate of HD video
    links is atrocious, but the human eye won’t detect bit errors even on the level
    of 1 in every 10,000 bits. (At high error rates, users see a “sparkle” or “snow”
    on the screen, but the image is largely intact.) Allowing some pixel-level corruption
    keeps consumer costs low. Otherwise, much higher-quality cables would be required
    along with FEC techniques to achieve a bit error rate compatible with strict cryptographic
    verification techniques like full-frame hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, NeTV’s prime challenge is to derive a keystream identical and synchronized
    to the transmitter’s keystream, encrypt the user-generated content with this keystream,
    and selectively swap the transmitter’s pixels on the fly for user-encrypted pixels.
    If everything lines up, the receiver will decrypt an image that appears to be
    a perfect overlay of user-generated content on top of the original video feed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0303-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A high-level conceptual diagram of how NeTV worked*'
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE OVERLAY
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To generate the user overlay content, we connected a tiny embedded Linux computer
    to an FPGA. From the Linux computer’s standpoint, the FPGA emulates a parallel
    RGB LCD that you can access by using the frame buffer at */dev/fb0* (the filepath
    for the first frame buffer in Linux). The Linux computer would automatically launch
    a WebKit browser full-screen at boot, thus filling */dev/fb0* with the user’s
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The system selected which pixel to swap by observing the color of the WebKit
    overlay’s video, a trick known as *chroma keying*. The overlay video wasn’t encrypted
    and was generated by the user, so looking at the color of the overlay video was
    perfectly legal. Other more expressive and aesthetically appealing pixel-combining
    methods like alpha blending, however, would have required decrypting the original
    video, which would have been illegal.
  prefs: []
  type: TYPE_NORMAL
- en: If the overlay video matched a certain chroma key color (in this case, a specific
    shade of bright pink), the incoming video was displayed; otherwise, the overlay
    video was displayed. Following this system, users could create transparent “holes”
    in the custom UI to show the original video underneath. Since the UI was rendered
    by a WebKit browser, users could implement chroma keying by simply setting the
    background color in the CSS of the UI pages to that magic shade of pink. With
    those settings, the default state of a web page would be transparent, and all
    items rendered on top of it were opaque, so long as the UI elements avoided the
    chroma key color and turned off enhancements like anti-aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: CRAFTING A KEYSTREAM
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Of course, the chroma keying happened in the encrypted domain. Thus, the FPGA’s
    second job was to snoop the HDMI link and craft a keystream identical to the transmitter’s.
    First, the FPGA observed an I2C link found on HDMI known as the *data display
    channel* (DDC). The DDC enables monitors to report their capability records (called
    *extended display identification data,* or EDID) and is also where the encryption
    keys are exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: By observing the key exchange handshake between the transmitter and the receiver,
    NeTV could mathematically extract the transmitter’s and receiver’s private keys
    with the help of the HDCP master key. Once the private-key vectors were derived,
    they could be multiplied exactly as they’d be in the source or sink to derive
    the shared secret, called Km. When that shared secret was written into the FPGA’s
    HDCP engine, the cipher state was ready to go, allowing NeTV to encrypt overlays
    on the video transmitted between the video source and the video display device.
  prefs: []
  type: TYPE_NORMAL
- en: 'By considering legal constraints as just another engineering constraint, I
    was able to create a completely new device that proves a point: it’s incorrect
    to automatically equate hacks that work around a DRM system with attempts to circumvent
    copyright. NeTV never decrypts previously encrypted video and can’t operate without
    an existing, valid HDCP link, making it a bona fide, non-infringing, commercially
    useful application of the HDCP master key.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0305-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A more detailed block diagram showing how NeTV’s FPGA worked*'
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve seen examples of different hardware hacking approaches
    and techniques, from physical penetration to system-level tool building and analysis
    to treating legal constraints as engineering problems. In “[Who Are the Shanzhai?](ch04.xhtml#ch00lev1sec73)”
    on [page 122](ch04.xhtml#page_122), I discussed the legal approach of a project,
    codenamed Fernvale, to reverse engineer a mobile phone chipset. In addition to
    thinking about law as engineers, xobs and I had to pull out all the stops and
    apply every technical skill at our disposal to reverse engineer such a complex
    system. The rest of this chapter dives into some of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**HACKING A SHANZHAI PHONE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When xobs and I worked on Fernvale, our goal was to make a new platform derived
    from the hardware in my $12 gongkai phone and repatriate technical information
    into the open source IP system. We had no documentation whatsoever for some parts
    of the chip we wanted to reverse, but that didn’t deter us. We navigated complex
    legal waters and created our own custom scripting language to program the chip’s
    firmware to avoid subconscious plagiarism.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the firmware, though, the hardware reverse-engineering task was
    fairly straightforward. The documents we scavenged gave us a notion of the chip’s
    pinout, and the pin naming scheme was sufficiently descriptive that I could apply
    common sense and experience to guess how to connect the chip. For ambiguous areas,
    I buzzed out some stripped-down phones with a multimeter or stared at them under
    a microscope to determine connectivity. In the worst cases, I’d probe a live phone
    with an oscilloscope to make sure I understood the connections correctly. The
    more difficult question was how to architect the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**The System Architecture**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We weren’t gunning to build a phone, but rather something closer to Particle’s
    Spark Core (since reborn as the Photon), a generic System-on-Module type of single-board
    computer built for Internet of Things applications. In fact, our original renderings
    and pinouts were designed to be compatible with the Spark ecosystem of hardware
    extensions, until we realized the gongkai phone’s MT6260 microcontroller just
    had too many interesting peripherals to fit into such a small footprint.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0307-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Early sketches of the Fernvale PCB*'
  prefs: []
  type: TYPE_NORMAL
- en: We settled eventually on a single-sided core PCB that we called the Fernvale
    Frond, which embedded the microUSB, microSD, battery, camera, speaker, and Bluetooth
    functionality (as well as the obligatory buttons and LED) on one board. The Frond
    turned out slim and small, at 3.5 mm thick, 57 mm long, and 35 mm wide. We included
    holes to mount a partial set of pin headers, spaced for Arduino compatibility,
    although the board could only be plugged into 3.3 V–compatible Arduino devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0308-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The actual implementation of the Fernvale Frond, pictured with an Arduino
    Uno for size reference*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We broke the remaining peripherals out to a pair of connectors: one dedicated
    to GSM-related signals (GSM is the protocol for 2G cell phone networks) and the
    other to UI-related peripherals. We called the GSM board the Fernvale Spore and
    the UI board the Fernvale Blade. We split GSM into a module with many choices
    for the RF frontend to make GSM a bona fide user-installed feature, thus pushing
    the regulatory and emissions issue down to the user level. Splitting the UI-related
    features out to another board also reduced the cost of the core module and let
    users try the Frond in numerous scenarios without being locked into a particular
    LCD or button arrangement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0309-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A Fernvale system diagram, showing the features of each of the three boards*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inside the MT6260**'
  prefs: []
  type: TYPE_NORMAL
- en: I had some X-rays taken of the MT6260 to help us identify fake components. We
    had to source our MT6260s on the gray market, and we wanted to guard against being
    sold empty epoxy blocks or remarked versions of other chips. The MT6260 has -DA
    and -A variants, where the difference is how much on-chip flash memory is included.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0310-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*An X-ray of the MT6260 chip.'
  prefs: []
  type: TYPE_NORMAL
- en: Look carefully to spot outlines of multiple ICs among the wire bonds.*
  prefs: []
  type: TYPE_NORMAL
- en: To our surprise, this $3 chip didn’t contain a single IC, but rather a set of
    at least four (possibly five) chips integrated into a single multichip module
    (MCM) containing hundreds of wire bonds. I remember back when the Pentium Pro’s
    dual-die package came out in the late 1990s. It sparked arguments over yield costs
    of MCMs versus using a single big die; generally, MCMs were considered exotic
    and expensive.
  prefs: []
  type: TYPE_NORMAL
- en: I also remember at the same time Krste Asanović, then a professor at the MIT
    Artificial Intelligence Lab and later at UC Berkeley, told me that the future
    of electronics wasn’t system-on-a-chip devices, but rather “system-mostly-on-a-chip”
    devices. The root of his claim was that the economics of adding in mask layers
    to merge DRAM, flash, analog, RF, and digital into a single process wasn’t favorable;
    bonding multiple dies together into a single package was cheaper and easier.
  prefs: []
  type: TYPE_NORMAL
- en: It’s still a race between the cost impact (in terms of both the per-unit cost
    and nonrecurring engineering costs) of adding more process steps in the semiconductor
    fab, and the yield impact, relative reworkability, and lower nonrecurring engineering
    cost of assembling modules. Single-chip, System-on-Chip devices were the zeitgeist
    when Krste made that observation and they still kind of are, so it was interesting
    to see a significant data point validating his insight.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the internal structure of the chip was also helpful in reverse
    engineering the system. Knowing that MediaTek was simply combining several chips
    together in a single package shed much-needed light on the purpose and organization
    of their APIs. It also tipped us off that certain elements of the system would
    be reused across several product categories and generations, so we knew we could
    draw meaningful conclusions from documentation on older or related chips. When
    you’re piecing together a puzzle this complex, every clue helps, including those
    gained by just looking at the physical structure of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Engineering the Boot Structure**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Shanzhai engineers in China seem to have access to just enough documentation
    to assemble a phone and customize its UI, but not enough to do a full OS port.
    After looking at enough phones, I eventually realized that all phones based on
    a particular chipset will have the same backdoor codes, and their GUIs are often
    inconsistent with the implemented hardware. For example, the $12 phone I tore
    down in [Chapter 4](ch04.xhtml#ch04) prompted me to plug headphones into the headphone
    jack for the FM radio to work, yet it has no headphone jack.
  prefs: []
  type: TYPE_NORMAL
- en: To make Fernvale accessible to engineers in the West through open source licensing,
    we had to reconstruct everything from scratch, including the toolchain, the firmware
    flashing tool, the OS, and the applications. But all the Chinese phone implementations
    simply relied on MediaTek’s proprietary toolchain, meaning we had to do some reverse
    engineering to figure out the boot process and firmware upload protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'My first step in reversing a chip is always to dump the ROM, if possible. We
    found exactly one phone model with an external ROM that we could desolder (it
    used the -D ROMless variant of the chip), and we read its data using a conventional
    ROM reader. We saw very little ciphertext in the ROM, but there was a lot of compressed
    data. Here is a page from our notes after we did a static analysis on the ROM
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The hexadecimal numbers on the left are memory addresses, and the text on the
    right describes what xobs and I thought was stored at each address. One concern
    about reverse engineering an SoC is it has an internal boot ROM that always runs
    before code is loaded from an external device. That internal ROM can also have
    signature and security checks that prevent tampering with the external code.
  prefs: []
  type: TYPE_NORMAL
- en: To determine how hard reverse engineering this system would be, we wanted to
    quickly figure out how much code was running inside the CPU before jumping to
    external boot code. A Tek MDO4104B-6 oscilloscope let us accomplish that task
    in just a couple of hours.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0313-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Screenshot from the Tek MDO4104B-6.'
  prefs: []
  type: TYPE_NORMAL
- en: The top quarter shows a zoomed-out view of the entire capture.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the SPI ROM accesses are punctuated with console output.*
  prefs: []
  type: TYPE_NORMAL
- en: This particular oscilloscope has the uncanny ability to perform post-capture
    analysis on deep, high-resolution analog traces and output the result as digital
    data. For example, we could simply probe around the chip with a multimeter while
    cycling power until we saw something that looked like an RS-232 encoded signal,
    and then run a post-capture analysis to extract any ASCII text that was coded
    in the analog traces. Likewise, if we captured SPI traces, the oscilloscope could
    extract ROM access patterns through a similar method. By looking at the timing
    of text emissions versus SPI ROM address patterns, we quickly determined that
    if the internal boot ROM did any verification, it was minimal and nothing approaching
    the computational complexity of RSA encryption.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we needed to speed up our measure-modify-test loop. Desoldering
    the ROM, sticking it in a burner, and resoldering it to the board were going to
    get old really fast. Fortunately, we’d implemented a NAND flash ROM emulator (we
    lovingly shortened that to ROMulator) on Novena, which we previously used to reverse
    engineer the AX211 contained in certain SD cards. We just reused that codebase
    and made an SPI ROMulator. We hacked up a GPBB and its corresponding FPGA code
    to add the ability to swap between the original boot SPI ROM and a dual-ported
    64kiB emulator region that was also memory-mapped into the Novena Linux host’s
    address space. Then, we plugged the phone into the laptop and put the ROMulator
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0314-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*A block diagram of the SPI ROMulator FPGA*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0315-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*There’s a phone in my Novena! What’s that doing there?*'
  prefs: []
  type: TYPE_NORMAL
- en: With the address stream determined by the Tek oscilloscope, some rapid ROM patching
    by the ROMulator, and hints of a SHA-1 function existing in the ROM via a static
    code analysis using IDA, we determined that the initial bootloader (which we called
    the 1bl), was hash-checked using a SHA-1 appendix.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The assembly for a hash function tends to have a very distinctive shape, or
    set of instructions, and a given hash also has some amount of magic numbers unique
    to it. Given those facts, when trying to reverse an authentication method, one
    of the first things a hacker does is use IDA to search for such constants near
    a function with the shape of the hash function in question.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Beachhead**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step was to create a small interactive shell we could use as a beachhead
    for running experiments on the target hardware. Just as he did for the SD card
    reverse engineering project, xobs created a compact REPL environment, called Fernly,
    that supported commands like peeking at memory, writing data, and dumping CPU
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the ROMulator to make the emulated ROM appear as a 64kiB memory-mapped
    window on a Linux host enabled useful POSIX abstractions like the `mmap()` function,
    the `open()` function (via */dev/mem*), the `read()` function, and the `write()`
    function to access the emulated ROM. xobs used these abstractions to create an
    I/O target for radare2, a portable reverse engineering framework. The I/O target
    automatically updated the SHA-1 hash every time we made changes in the 1bl code
    space. With that system in place, we could do cute things like interactively patch
    and disassemble code within the emulated ROM space.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0316-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Patching some code in the ROM*'
  prefs: []
  type: TYPE_NORMAL
- en: We also wired up the power switch of the phone to an FPGA I/O. That allowed
    us to write automated scripts that toggled the power on the phone while updating
    the ROM contents so we could automatically fuzz unknown hardware blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Attaching a Debugger**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We had to take an unconventional approach to attach a debugger to the code in
    the ROM, because locating critical blocks was difficult, and JTAG was multiplexed
    with critical functions on the target device. xobs emulated the ARM core and used
    his Fernly shell to reflect virtual loads and stores to the live target. We were
    able to attach a remote debugger to the emulated core that way, bypassing the
    need for JTAG entirely. That also let us use cross-platform tools like IDA on
    x86 for the reversing UI.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of this debugging technique was QEMU, a multiplatform system emulator.
    QEMU supports emulating ARM targets, specifically the ARMv5 chip our target device
    used. We made a new virtual machine type, called Fernvale, that implemented part
    of the observed hardware on the target and simply passed unknown memory accesses
    directly to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fernly shell was stripped down to support only three commands: write, read,
    and zero-memory. The write command pokes a byte, word, or dword of data into RAM
    on the live target. A read command reads a byte, word, or dword from the live
    target. The zero-memory command is an optimization, as the operating system writes
    large quantities of zeros across a large memory area.'
  prefs: []
  type: TYPE_NORMAL
- en: We also hooked and emulated the serial port registers, allowing a host system
    to display serial data as if it were printed on the target device. Finally, we
    emulated SPI, IRAM, and PSRAM as they’d appear on the real device. Other areas
    of memory were either trapped and funneled to the actual device or left unmapped
    and reported as errors by QEMU.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0318-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The architecture of the debugger*'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the debugger was a multistage process. First, we primed the actual
    MT6260 target with the Fernly shell environment. Then, we booted the QEMU virtual
    ARM CPU with a version of the original vendor image primed with a known register
    state at a convenient point in the boot process. At this point, code execution
    proceeded on the virtual machine until a load or store was performed to an unknown
    address. On that load or store, virtual machine execution paused while a query
    was sent to the real MT6260 via the Fernly shell interface. The load or store
    was then executed on the real machine, which would relay the results of the load
    or store to the virtual machine so execution could resume.
  prefs: []
  type: TYPE_NORMAL
- en: We couldn’t run Fernly directly from the SPI ROM because the vendor binary’s
    initialization routine modified SPI ROM timings. But of course Fernly would have
    crashed if a store happened to land somewhere inside its memory footprint. To
    avoid the possibility of a load or store overwriting the Fernly shell code, we
    hid the code in a region of IRAM that was trapped and emulated. Emulating the
    target CPU let us attach a remote debugger like IDA via GDB over TCP. The debugger
    had complete control over the emulated CPU and could access its emulated RAM.
    Here is an example of the output of the hybrid QEMU/live-target debug harness.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the trapped serial writes appearing on the console, plus a
    log of the writes and reads executed by the emulated ARM CPU as they were relayed
    to the live target running the reduced Fernly shell. This was our beachhead.
  prefs: []
  type: TYPE_NORMAL
- en: From there, xobs and I discovered the offsets of a few IP blocks that were reused
    from previous known MediaTek chips by searching for their “signature” in memory.
    A signature could be as simple as the power-on default register values, or something
    more complex, like changes in bit patterns due to the side effects of bit set
    or clear registers located at offsets within the IP block’s address space. Following
    the signatures helped us find the register offsets of several peripherals and
    generate a memory map.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Starting Address** | **Ending Address** | **Size of Region** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x00000000` | `0x0fffffff` | `0x0fffffff` | `PSRAM map, repeated and mirrored
    at 0x00800000 offsets` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10000000` | `0x1fffffff` | `0x0fffffff` | `Memory-mapped SPI chip` |'
  prefs: []
  type: TYPE_TB
- en: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x70000000` | `0x7000cfff` | `0xcfff` | `On-chip SRAM (maybe cache?)` |'
  prefs: []
  type: TYPE_TB
- en: '| `??????????` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x80000000` | `0x80000008` | `0x08` | `Config block (chip version, etc.)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x82200000` | `??????????` | `??????????` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0x83000000` | `??????????` | `??????????` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0000000` | `0xa0000008` | `0x08` | `Config block (mirror?)` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10010000` | `??????????` | `??????????` | `(?SPI mode?) ????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10020000` | `0xa0020e10` | `0x0e10` | `GPIO control block` |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0030000` | `0xa0030040` | `0x40` | `WDT block` |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | `   + 0x08 -> WDT register (?)    + 0x18 -> Boot src (?)` |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0030800` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0040000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0050000` | `??????????` | `??????????` | `????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0060000` | `??????????` | `??????????` | `?? Possible IRQs at 0xa0060200
    ??` |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0070000` | `==========` | `==========` | `== Empty (all zeroes) ===========`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0080000` | `0xa008005c` | `0x5c` | `UART1 block` |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa0090000` | `0xa009005c` | `0x5c` | `UART2 block` |'
  prefs: []
  type: TYPE_TB
- en: '| `0xa00a0000` | `??????????` | `??????????` | `?????????????????????????????????`
    |'
  prefs: []
  type: TYPE_TB
- en: This memory map shows what content is stored at different address ranges on
    the chip. For instance, the second address range in the map (0x10000000 to 0x1FFFFFFF)
    consisted of 0x0FFFFFFF bytes corresponding to a memory-mapped SPI chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Booting an OS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After finding the register offsets, we progressed rapidly on many fronts, but
    our goal (to port NuttX, a BSD-based real-time operating system, to the device)
    remained elusive. There was no documentation on the interrupt controller within
    the canon of shanzhai datasheets. We found the routines that installed the interrupt
    handlers through static analysis of the binaries, but we couldn’t determine the
    address offsets of the interrupt controller itself.
  prefs: []
  type: TYPE_NORMAL
- en: All we could do was open the MediaTek codebase and refer to the header file
    that contained the register offsets and bit definitions of the interrupt controller.
    This fit within our self-imposed limitations to not breach copyright, because
    facts are not copyrightable. I describe the legal reasoning behind this idea in
    [Chapter 4](ch04.xhtml#ch04), under “[Dealing with Copyrights](ch04.xhtml#ch00lev1sec82)”
    on [page 138](ch04.xhtml#page_138). After looking up those facts, we created our
    own custom scripting language, called Scriptic, to avoid unconsciously plagiarizing
    anything from the existing codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a New Toolchain**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Requiring users to own a Novena ROMulator to hack on Fernvale wasn’t a scalable
    solution, however. To round out the story, we created a complete developer toolchain.
    The compiler was fairly cut-and-dried; many standard compilers support ARM as
    a target, including clang and GCC. But making open tools for flashing the MT6260
    was much trickier. All the existing tools we knew supported the protocol version
    required by the MT6260 were proprietary Windows programs. That meant we had to
    reverse engineer the MediaTek flashing protocol and write our own open source
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a blank, unfused MT6260 shows up as */dev/ttyUSB0* when you plug
    it into a Linux host. In other words, it shows up as an emulated serial device
    over USB. That took care of the lower-level details of sending and receiving bytes
    to the device, leaving us to reverse engineer the protocol layer.
  prefs: []
  type: TYPE_NORMAL
- en: xobs located the internal boot ROM of the MT6260 and performed static code analysis
    to learn more about the protocol. He also did some static analysis on MediaTek’s
    flashing tool and captured live traces using a USB protocol analyzer to clarify
    the remaining details. Here is a summary of the commands he extracted, as we used
    in our open version of the USB flashing tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is just a C `enum` structure, making it a very geeky way of specifying
    a mapping of numbers to command meanings. For example, `mtk_cmd_old_write16` is
    command 0xA1, `mtk_command_old_read16` is command 0xA2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fernvale Results**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After about a year of on-and-off effort between work on the Novena and Chibitronics
    campaigns, we were able to boot a port of NuttX on the MT6260, supporting a minimal
    set of hardware peripherals. It was enough for us to roughly reproduce the functionality
    of an AVR used in an Arduino-like context, but not much more.
  prefs: []
  type: TYPE_NORMAL
- en: xobs and I presented our results at the 31st Chaos Communication Congress (CCC),
    and events actually took an unexpected twist as we wrote our proposal. The week
    before submission, we learned that MediaTek released the LinkIT ONE development
    platform, based on the MT2502A, in conjunction with Seeed Studios. The LinkIT
    ONE is an Internet of Things platform made for entrepreneurs and hobbyists. It’s
    integrated into the Arduino framework and features an open API that enables the
    full functionality of the chip, including GSM functions. But the core OS that
    boots on the MT2502A in the LinkIT ONE is still proprietary, and you can’t access
    the hardware without going through the API calls provided by the Arduino shim.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, it’s still going to be a while before we can port a reasonable
    fraction of the MT6260’s features into the open source domain. It’s quite possible
    we’ll never be able to do a blob-free implementation of the GSM call functions,
    as those are controlled by a DSP unit that’s even more obscure and undocumented
    than the MT6260\. Given the robust functionality of the LinkIT ONE compared to
    Fernvale, we decided to leave the question of whether there was value in continuing
    the effort to reverse engineer the MT6260 to the open source community. In the
    end, there was a lot of enthusiasm for the project, but not a lot of action. The
    LinkIT ONE’s introduction took a lot of wind out of the sails of the Fernvale
    project, which has since been effectively retired.
  prefs: []
  type: TYPE_NORMAL
- en: This is, in fact, the fate of most open source projects. There are dozens, if
    not hundreds, of open source operating systems but only one Linux. The truth is
    that there are far more interesting ideas than capable developers to execute them.
    For an open source project to catch fire and become self-sustaining, it has to
    not only pass the minimum viable product (MVP) stage but also meet a receptive
    audience with a real need for the project. Sometimes your project strikes a chord,
    and a huge community pushes it forward. Other times, you get a lot of nice, helpful
    onlookers who nod appreciatively but are unwilling or too busy with day jobs to
    jump in. And still other times, you yell into a void or, worse, get torn to shreds
    on some internet forum about how flawed and pointless your project is.
  prefs: []
  type: TYPE_NORMAL
- en: '**CLOSING THOUGHTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the nature of open source projects, I tend to take a page from my startup
    days and follow a “fail forward fast” philosophy. Try a bunch of different things,
    see what sticks, learn from your mistakes, and try again. It’s important not to
    get too wedded to any one idea, especially if the idea isn’t working out. Finally,
    you’ll find it helps to be more about the journey than the destination. Fernvale
    was most certainly an epic journey; xobs and I learned a lot, honed a set of tools
    and skills that we continue to use to this day for other projects, and most importantly,
    had a lot of fun.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a look at another kind of hacking that will
    become increasingly relevant to all of us over the coming decades—that of biological
    systems.
  prefs: []
  type: TYPE_NORMAL
