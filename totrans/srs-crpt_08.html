<html><head></head><body>
<h2 class="h2" id="ch7"><span epub:type="pagebreak" id="page_127"/><span class="big">7</span><br/>KEYED HASHING</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">The hash functions discussed in <a href="ch06.xhtml#ch6">Chapter 6</a> take a message and return its hash value—typically a short string of 256 or 512 bits. Anyone can compute the hash value of a message and verify that a particular message hashes to a particular value because there’s no secret value involved, but sometimes you don’t want to let just anyone do that. That’s where <em>keyed</em> hash functions come in, or hashing with secret keys.</p>
<p class="indent">Keyed hashing forms the basis of two types of important cryptographic algorithms: <em>message authentication codes (MACs)</em>, which authenticate a message and protect its integrity, and <em>pseudorandom functions (PRFs)</em>, which produce random-looking hash-sized values. We’ll look at how and why MACs and PRFs are similar in the first section of this chapter; then we’ll review <span epub:type="pagebreak" id="page_128"/>how real MACs and PRFs work. Some MACs and PRFs are based on hash functions, some are based on block ciphers, and still others are original designs. Finally, we’ll review examples of attacks on otherwise secure MACs.</p>
<h3 class="h3" id="lev1sec45">Message Authentication Codes (MACs)</h3>
<p class="noindent">A MAC protects a message’s integrity and authenticity by creating a value <em>T</em> = <strong>MAC</strong>(<em>K</em>, <em>M</em>), called the authentication tag of the message, <em>M</em> (often confusingly called the MAC of <em>M</em>). Just as you can decrypt a message if you know a cipher’s key, you can validate that a message has not been modified if you know a MAC’s key.</p>
<p class="indent">For example, say Alex and Bill share a key, <em>K</em>, and Alex sends a message, <em>M</em>, to Bill along with its authentication tag, <em>T</em> = <strong>MAC</strong>(<em>K</em>, <em>M</em>). Upon receiving the message and its authentication tag, Bill recomputes <strong>MAC</strong>(<em>K</em>, <em>M</em>) and checks that it is equal to the authentication tag received. Because only Alex could have computed this value, Bill knows that the message wasn’t corrupted in transit (confirming integrity), whether accidentally or maliciously, and that Alex sent that message (confirming authenticity).</p>
<h4 class="h4" id="lev2sec85"><em>MACs in Secure Communication</em></h4>
<p class="noindent">Secure communication systems often combine a cipher and a MAC to protect a message’s confidentiality, integrity, and authenticity. For example, the protocols in Internet Protocol Security (IPSec), Secure Shell (SSH), and Transport Layer Security (TLS) generate a MAC for each network packet transmitted.</p>
<p class="indent">Not all communication systems use MACs. Sometimes an authentication tag can add unacceptable overhead to each packet, typically in the range of 64 to 128 bits. For example, the 3G and 4G mobile telephony standards encrypt packets encoding voice calls but they don’t authenticate them. An attacker can modify the encrypted audio signal and the recipient wouldn’t notice. Thus, if an attacker damages an encrypted voice packet, it will decrypt to noise, which would sound like static.</p>
<h4 class="h4" id="lev2sec86"><em>Forgery and Chosen-Message Attacks</em></h4>
<p class="noindent">What does it mean for a MAC to be secure? First of all, as with a cipher, the secret key should remain secret. If a MAC is secure, an attacker shouldn’t be able to create a tag of some message if they don’t know the key. Such a made-up message/tag pair is called a <em>forgery</em>, and recovering a key is just a specific case of a more general class of attacks called <em>forgery attacks</em>. The security notion that posits that forgeries should be impossible to find is called <em>unforgeability</em>. Obviously, it should be impossible to recover the secret key from a list of tags; otherwise, attackers could forge tags using the key.</p>
<p class="indent">What can an attacker do to break a MAC? In other words, what’s the attack model? The most basic model is the <em>known-message attack</em>, which passively collects messages and their associated tags (for example, by eavesdropping on a network). But real attackers often launch more powerful <span epub:type="pagebreak" id="page_129"/>attacks because they can often choose the messages to be authenticated, and therefore get the MAC of the message they want. The standard model is therefore that of <em>chosen-message</em> <em>attacks</em>, wherein attackers get tags for messages of their choice.</p>
<h4 class="h4" id="lev2sec87"><em>Replay Attacks</em></h4>
<p class="noindent">MACs aren’t safe from attacks involving <em>replays</em> of tags. For example, if you were to eavesdrop on Alex and Bill’s communications, you could capture a message and its tag sent by Alex to Bill, and later send them again to Bill pretending to be Alex. To prevent such <em>replay attacks</em>, protocols include a message number in each message. This number is incremented for each new message and authenticated along with the message. The receiving party gets messages numbered 1, 2, 3, 4, and so on. Thus, if an attacker tries to send message number 1 again, the receiver will notice that this message is out of order and that it’s a potential replay of the earlier message number 1.</p>
<h3 class="h3" id="lev1sec46">Pseudorandom Functions (PRFs)</h3>
<p class="noindent">A PRF is a function that uses a secret key to return <strong>PRF</strong>(<em>K</em>, <em>M</em>), such that the output looks random. Because the key is secret, the output values are unpredictable to an attacker.</p>
<p class="indent">Unlike MACs, PRFs are not meant to be used on their own but as part of a cryptographic algorithm or protocol. For example, PRFs can be used to create block ciphers within the Feistel construction discussed in <a href="ch04.xhtml#lev1sec28">“How to Construct Block Ciphers”</a> on page 55. Key derivation schemes use PRFs to generate cryptographic keys from a master key or a password, and identification schemes use PRFs to generate a response from a random challenge. (Basically, a server sends a random challenge message, <em>M</em>, and the client returns <strong>PRF</strong>(<em>K</em>, <em>M</em>) in its response to prove that it knows <em>K</em>.) The 4G telephony standard uses a PRF to authenticate a SIM card and its service provider, and a similar PRF also serves to generate the encryption key and MAC key to be used during a phone call. The TLS protocol uses a PRF to generate key material from a master secret as well as session-specific random values. There’s even a PRF in the noncryptographic <code>hash()</code> function built into the Python language to compare objects.</p>
<h4 class="h4" id="lev2sec88"><em>PRF Security</em></h4>
<p class="noindent">In order to be secure, a pseudorandom function should have no pattern that sets its outputs apart from truly random values. An attacker who doesn’t know the key, <em>K</em>, shouldn’t be able to distinguish the outputs of <strong>PRF</strong>(<em>K</em>, <em>M</em>) from random values. Viewed differently, an attacker shouldn’t have any means of knowing whether they’re talking to a PRF algorithm or to a random function. The erudite phrase for that security notion is <em>indistinguishability from a</em> <em>random</em> <em>function</em>. (To learn more about the theoretical foundations of PRFs, see Volume 1, Section 3.6 of Goldreich’s <em>Foundations of Cryptography</em>.)</p>
<h4 class="h4" id="lev2sec89"><span epub:type="pagebreak" id="page_130"/><em>Why PRFs Are Stronger Than MACs</em></h4>
<p class="noindent">PRFs and MACs are both keyed hashes, but PRFs are fundamentally stronger than MACs, largely because MACs have weaker security requirements. Whereas a MAC is considered secure if tags can’t be forged—that is, if the MAC’s outputs can’t be guessed—a PRF is only secure if its outputs are indistinguishable random strings, which is a stronger requirement. If a PRF’s outputs can’t be distinguished from random strings, the implication is that their values can’t be guessed; in other words, any secure PRF is also a secure MAC.</p>
<p class="indentb">The converse is not true, however: a secure MAC isn’t necessarily a secure PRF. For example, say you start with a secure PRF, <strong>PRF1</strong>, and you want to build a second PRF, <strong>PRF2</strong>, from it, like this:</p>
<p class="center"><strong>PRF2</strong>(<em>K</em>, <em>M</em>) = <strong>PRF1</strong>(<em>K</em>, <em>M</em>) || 0</p>
<p class="indentt">Because <strong>PRF2</strong>’s output is defined as <strong>PRF1</strong>’s output followed by one 0 bit, it doesn’t look as random as a true random string, and you can distinguish its outputs by that last 0 bit. Hence, <strong>PRF2</strong> is not a secure PRF. However, because <strong>PRF1</strong> is secure, <strong>PRF2</strong> would still make a secure MAC. Why? Because if you were able to forge a tag, <em>T</em> = <strong>PRF2</strong>(<em>K</em>, <em>M</em>), for some <em>M</em>, then you’d also be able to forge a tag for <strong>PRF1</strong>, which we know to be impossible in the first place because PRF1 is a secure MAC. Thus, PRF2 is a keyed hash that’s a secure MAC but not a secure PRF.</p>
<p class="indent">But don’t worry: you won’t find such MAC constructions in real applications. In fact, many of the MACs deployed or standardized are also secure PRFs and are often used as either. For example, TLS uses the algorithm HMAC-SHA-256 both as a MAC and as a PRF.</p>
<h3 class="h3" id="lev1sec47">Creating Keyed Hashes from Unkeyed Hashes</h3>
<p class="noindent">Throughout the history of cryptography, MACs and PRFs have rarely been designed from scratch but rather have been built from existing algorithms, usually hash functions of block ciphers. One seemingly obvious way to produce a keyed hash function would be to feed an (unkeyed) hash function a key and a message, but that’s easier said than done, as I discuss next.</p>
<h4 class="h4" id="lev2sec90"><em>The Secret-Prefix Construction</em></h4>
<p class="noindent">The first technique we’ll examine, called the <em>secret-prefix construction</em>, turns a normal hash function into a keyed hash one by prepending the key to the message and returning <strong>Hash</strong>(<em>K</em> || <em>M</em>). Although this approach is not always wrong, it can be insecure when the hash function is vulnerable to length-extension attacks (as discussed in <a href="ch06.xhtml#lev2sec83">“The Length-Extension Attack”</a> on page 125) and when the hash supports keys of different lengths.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_131"/>Insecurity Against Length-Extension Attacks</h5>
<p class="noindent">Recall from <a href="ch06.xhtml#ch6">Chapter 6</a> that hash functions of the SHA-2 family allow attackers to compute the hash of a partially unknown message when given a hash of a shorter version of that message. In formal terms, the <em>length-extension</em> attack allows attackers to compute <strong>Hash</strong>(<em>K</em> || <em>M</em><sub>1</sub> || <em>M</em><sub>2</sub>) given only <strong>Hash</strong>(<em>K</em> || <em>M</em><sub>1</sub>) and neither <em>M</em><sub>1</sub> nor <em>K</em>. These functions allow attackers to forge valid MAC tags for free because they’re not supposed to be able to guess the MAC of <em>M</em><sub>1</sub> || <em>M</em><sub>2</sub> given only the MAC of <em>M</em><sub>1</sub>. This fact makes the secret-prefix construction as insecure as a MAC and PRF when, for example, it’s used with SHA-256 or SHA-512. It is a weakness of Merkle–Damgård to allow length-extension attacks, and none of the SHA-3 finalists do. The ability to thwart length-extension attacks was mandatory for SHA-3 submissions.</p>
<h5 class="h5">Insecurity with Different Key Lengths</h5>
<p class="noindent">The secret-prefix construction is also insecure when it allows the use of keys of different lengths. For example, if the key <em>K</em> is the 24-bit hexa­decimal string 123abc and <em>M</em> is def00, then <strong>Hash</strong>() will process the value <em>K</em> || <em>M</em> = 123abcdef00. If <em>K</em> is instead the 16-bit string 123a and <em>M</em> is bcdef000, then <strong>Hash</strong>() will process <em>K</em> || <em>M</em> = 123abcdef00, too. Therefore, the result of the secret-prefix construction <strong>Hash</strong>(<em>K</em> || <em>M</em>) will be the same for both keys.</p>
<p class="indent">This problem is independent of the underlying hash and can be fixed by hashing the key’s length along with the key and the message, for example, by encoding the key’s bit length as a 16-bit integer, <em>L</em>, and then hashing <strong>Hash</strong>(<em>L</em> || <em>K</em> || <em>M</em>). But you shouldn’t have to do this. Modern hash functions such as BLAKE2 and SHA-3 include a keyed mode that avoids those pitfalls and yields a secure PRF, and thus a secure MAC as well.</p>
<h4 class="h4" id="lev2sec91"><em>The Secret-Suffix Construction</em></h4>
<p class="noindent">Instead of hashing the key before the message as in the secret-prefix construction, we can hash it <em>after</em>. And that’s exactly how the <em>secret-suffix construction</em> works: by building a PRF from a hash function as <strong>Hash</strong>(<em>M</em> || <em>K</em>).</p>
<p class="indent">Putting the key at the end makes quite a difference. For one thing, the length-extension attack that works against secret-prefix MACs won’t work against the secret suffix. Applying length extension to a secret-suffix MAC, you’d get <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>K</em> || <em>M</em><sub>2</sub>) from <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>K</em>), but that wouldn’t be a valid attack because <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>K</em> || <em>M</em><sub>2</sub>) isn’t a valid secret-suffix MAC; the key needs to be at the end.</p>
<p class="indent">However, the secret-suffix construction is weaker against another type of attack. Say you’ve got a collision for the hash <strong>Hash</strong>(<em>M</em><sub>1</sub>) = <strong>Hash</strong>(<em>M</em><sub>2</sub>), where <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub> are two distinct messages, possibly of different sizes. In the case of a hash function such as SHA-256, this implies that <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>K</em>) and <strong>Hash</strong>(<em>M</em><sub>2</sub> || <em>K</em>) will be equal too, because internally <em>K</em> will be processed based on the data hashed previously, namely <strong>Hash</strong>(<em>M</em><sub>1</sub>), equal to <strong>Hash</strong>(<em>M</em><sub>2</sub>). Hence, you’d get the same hash value whether you hash <em>K</em> after <em>M</em><sub>1</sub> or after <em>M</em><sub>2</sub>, regardless of the value of <em>K</em>.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_132"/>To exploit this property, an attacker would:</p>
<ol>
<li class="noindent"><p class="list">Find two colliding messages, <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub></p></li>
<li class="noindent"><p class="list">Request the MAC tag of <em>M</em><sub>1</sub> <strong>Hash</strong>(<em>M</em><sub>1</sub> || <em>K</em>)</p></li>
<li class="noindent"><p class="list">Guess that <strong>Hash</strong>(<em>M</em><sub>2</sub> || <em>K</em>) is the same, thereby forging a valid tag and breaking the MAC’s security</p></li>
</ol>
<h4 class="h4" id="lev2sec92"><em>The HMAC Construction</em></h4>
<p class="noindent">The hash-based MAC (HMAC) construction allows us to build a MAC from a hash function, which is more secure than either secret prefix or secret suffix. HMAC yields a secure PRF as long as the underlying hash is collision resistant, but even if that’s not the case, HMAC will still yield a secure PRF if the hash’s compression function is a PRF. The secure communication protocols IPSec, SSH, and TLS have all used HMAC. (You’ll find HMAC specifications in NIST’s FIPS 198-1 standard and in RFC 2104.)</p>
<p class="indentb">HMAC uses a hash function, <strong>Hash</strong>, to compute a MAC tag, as shown in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> and according to the following expression:</p>
<p class="center"><strong>Hash</strong>((<em>K</em> ⊕ <em>opad</em>) <strong>Hash</strong>((<em>K</em> ⊕ <em>ipad</em>) <em>M</em>))</p>
<p class="indentt">The term <em>opad</em> (outer padding) is a string (<em>5c5c5c … 5c</em>) that is as long as <strong>Hash</strong>’s block size. The key, <em>K</em>, is usually shorter than one block that is filled with 00 bytes and XORed with <em>opad</em>. For example, if <em>K</em> is the 1-byte string <em>00</em>, then <em>K</em> ⊕ <em>opad</em> = <em>opad</em>. (The same is true if <em>K</em> is the all-zero string of any length up to a block’s length.) <em>K</em> ⊕ <em>opad</em> is the first block processed by the outer call to <strong>Hash</strong>—namely, the leftmost <strong>Hash</strong> in the preceding equation, or the bottom hash in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>.</p>
<p class="indent">The term <em>ipad</em> (inner padding) is a string (<em>363636</em> … <em>36</em>) that is as long as the <strong>Hash</strong>’s block size and that is also completed with 00 bytes. The resulting block is the first block processed by the inner call to <strong>Hash</strong>—namely, the rightmost <strong>Hash</strong> in the equation, or the top hash in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>.</p>
<div class="image"><img src="../images/f07-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig1"/><em>Figure 7-1: The HMAC hash-based MAC construction</em></p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_133"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The envelope method is an even more secure construction than secret prefix and secret suffix. It’s expressed as <strong>Hash</strong></em>(K || M || K), <em>something called a <em>sandwich MAC</em>, but it’s theoretically less secure than HMAC.</em></p>
</div>
<p class="indent">If SHA-256 is the hash function used as <strong>Hash</strong>, then we call the HMAC instance HMAC-SHA-256. More generally, we call HMAC-<em>Hash</em> an HMAC instance using the hash function <em>Hash</em>. That means if someone asks you to use HMAC, you should always ask, “Which hash function?”</p>
<h4 class="h4" id="lev2sec93"><em>A Generic Attack Against Hash-Based MACs</em></h4>
<p class="noindent">There is one attack that works against all MACs based on an iterated hash function. Recall the attack in <a href="ch07.xhtml#lev2sec91">“The Secret-Suffix Construction”</a> on page 131 where we used a hash collision to get a collision of MACs. You can use the same strategy to attack a secret-prefix MAC or HMAC, though the consequences are less devastating.</p>
<p class="indent">To illustrate the attack, consider the secret-prefix MAC <strong>Hash</strong>(<em>K</em> || <em>M</em>), as shown in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>. If the digest is <em>n</em> bits, you can find two messages, <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub>, such that <strong>Hash</strong>(<em>K</em> || <em>M</em><sub>1</sub>) = <strong>Hash</strong>(<em>K</em> || <em>M</em><sub>2</sub>), by requesting approximately 2<sup><em>n</em></sup><sup>/2</sup> MAC tags to the system holding the key. (Recall the birthday attack from <a href="ch06.xhtml#ch6">Chapter 6</a>.) If the hash lends itself to length extension, as SHA-256 does, you can then use <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub> to forge MACs by choosing some arbitrary data, <em>M</em><sub>3</sub>, and then querying the MAC oracle for <strong>Hash</strong>(<em>K</em> || <em>M</em><sub>1</sub> || <em>M</em><sub>3</sub>), which is the MAC of message <em>M</em><sub>1</sub> || <em>M</em><sub>3</sub>. As it turns out, this is also the MAC of message <em>M</em><sub>2</sub> || <em>M</em><sub>3</sub>, because the hash’s internal state of <em>M</em><sub>1</sub> and <em>M</em><sub>3</sub> and <em>M</em><sub>2</sub> and <em>M</em><sub>3</sub> is the same, and you’ve successfully forged a MAC tag. (The effort becomes infeasible as <em>n</em> grows beyond, say, 128 bits.)</p>
<div class="image"><img src="../images/f07-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig2"/><em>Figure 7-2: The principle of the generic forgery attack on hash-based MACs</em></p>
<p class="indentt">This attack will work even if the hash function is not vulnerable to length extension, and it will work for HMAC, too. The cost of the attack depends on both the size of the chaining value and the MAC’s length: if a MAC’s chaining value is 512 bits and its tags are 128 bits, a 2<sup>64</sup> computation would find a MAC collision but probably not a collision in the internal state, since finding such a collision would require 2<sup>512/2</sup> = 2<sup>256</sup> operations on average.</p>
<h3 class="h3" id="lev1sec48"><span epub:type="pagebreak" id="page_134"/>Creating Keyed Hashes from Block Ciphers: CMAC</h3>
<p class="noindent">Recall from <a href="ch06.xhtml#ch6">Chapter 6</a> that the compression functions in many hash functions are built on block ciphers. For example, HMAC-SHA-256 PRF is a series of calls to SHA-256’s compression function, which itself is a block cipher that repeats a sequence of rounds. In other words, HMAC-SHA-256 is a block cipher inside a compression function inside a hash inside the HMAC construction. So why not use a block cipher directly rather than build such a layered construction?</p>
<p class="indent"><em>CMAC</em> (which stands for <em>cipher-based MAC</em>) is such a construction: it creates a MAC given only a block cipher, such as AES. Though less popular than HMAC, CMAC is deployed in many systems, including the Internet Key Exchange (IKE) protocol, which is part of the IPSec suite. IKE, for example, generates key material using a construction called AES-CMAC-PRF-128 as a core algorithm (or CMAC based on AES with 128-bit output). CMAC is specified in RFC 4493.</p>
<h4 class="h4" id="lev2sec94"><em>Breaking CBC-MAC</em></h4>
<p class="noindent">CMAC was designed in 2005 as an improved version of <em>CBC-MAC</em>, a simpler block cipher–based MAC derived from the cipher block chaining (CBC) block cipher mode of operation (see <a href="ch04.xhtml#lev1sec31">“Modes of Operation”</a> on page 65).</p>
<p class="indent">CBC-MAC, the ancestor of CMAC, is simple: to compute the tag of a message, <em>M</em>, given a block cipher, <strong>E</strong>, you encrypt <em>M</em> in CBC mode with an all-zero initial value (IV) and discard all but the last ciphertext block. That is, you compute <em>C</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>1</sub>), <em>C</em><sub>2</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>2</sub> ⊕ <em>C</em><sub>1</sub>), <em>C</em><sub>3</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>3</sub> ⊕ <em>C</em><sub>2</sub>), and so on for each of <em>M</em>’s blocks and keep only the last <em>C</em><sub><em>i</em></sub>, your CBC-MAC tag for <em>M</em>—simple, and simple to attack.</p>
<p class="indent">To understand why CBC-MAC is insecure, consider the CBC-MAC tag, <em>T</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>1</sub>), of a single-block message, <em>M</em><sub>1</sub>, and the tag, <em>T</em><sub>2</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>2</sub>), of another single-block message, <em>M</em><sub>2</sub>. Given these two pairs, (<em>M</em><sub>1</sub>, <em>T</em><sub>1</sub>) and (<em>M</em><sub>2</sub>, <em>T</em><sub>2</sub>), you can deduce that <em>T</em><sub>2</sub> is also the tag of the two-block message <em>M</em><sub>1</sub> || (<em>M</em><sub>2</sub> ⊕ <em>T</em><sub>1</sub>). Indeed, if you apply CBC-MAC to <em>M</em><sub>1</sub> || (<em>M</em><sub>2</sub> ⊕ <em>T</em><sub>1</sub>) and compute <em>C</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>M</em><sub>1</sub>) = <em>T</em><sub>1</sub> followed by <em>C</em><sub>2</sub> = <strong>E</strong>(<em>K</em>, (<em>M</em><sub>2</sub> ⊕ <em>T</em><sub>1</sub>) ⊕ <em>T</em><sub>1</sub>) = <strong>E</strong>(<em>K</em>, <em>M</em><sub>2</sub>) = <em>T</em><sub>2</sub>, you can create a third message/tag pair from two message/tag pairs without knowing the key. That is, you can forge CBC-MAC tags, thereby breaking CBC-MAC’s security.</p>
<h4 class="h4" id="lev2sec95"><em>Fixing CBC-MAC</em></h4>
<p class="noindent">CMAC fixes CBC-MAC by processing the last block using a different key from the preceding blocks. To do this, CMAC first derives two keys, <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, from the main key, <em>K</em>, such that <em>K</em>, <em>K</em><sub>1</sub>, and <em>K</em><sub>2</sub> will be distinct. In CMAC, the last block is processed using either <em>K</em><sub>1</sub> or <em>K</em><sub>2</sub>, while the preceding blocks use <em>K</em>.</p>
<p class="indent">To determine <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, CMAC first computes a temporary value, <em>L</em> = <strong>E</strong>(0, <em>K</em>), where 0 acts as the key of the block cipher and <em>K</em> acts as the plaintext block. Then CMAC sets the value of <em>K</em><sub>1</sub> equal to (<em>L</em> &lt;&lt; 1) if <em>L</em>’s <span epub:type="pagebreak" id="page_135"/>most significant bit (MSB) is 0, or equal to (<em>L</em> &lt;&lt; 1) ⊕ 87 if <em>L</em>’s MSB is 1. (The number 87 is carefully chosen for its mathematical properties when data blocks are 128 bits; a value other than 87 is needed when blocks aren’t 128 bits.)</p>
<p class="indent">The value of <em>K</em><sub>2</sub> is set equal to (<em>K</em><sub>1</sub> &lt;&lt; 1) if <em>K</em><sub>1</sub>’s MSB is 0, or <em>K</em><sub>2</sub> = (<em>K</em><sub>1</sub> &lt;&lt; 1) ⊕ 87 otherwise.</p>
<p class="indent">Given <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, CMAC works like CBC-MAC, except for the last block. If the final message chunk <em>M</em><sub><em>n</em></sub> is exactly the size of a block, CMAC returns the value <strong>E</strong>(<em>K</em>, <em>M</em><sub><em>N</em></sub> ⊕ <em>C</em><sub><em>n</em></sub> <sub>− 1</sub> ⊕ <em>K</em><sub>1</sub>) as a tag, as shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>. But if <em>M</em><sub><em>N</em></sub> has fewer bits than a block, CMAC pads it with a 1 bit and zeros, and returns the value <strong>E</strong>(<em>K</em>, <em>M</em><sub><em>n</em></sub> ⊕ <em>C</em><sub><em>n</em> − 1</sub> ⊕ <em>K</em><sub>2</sub>) as a tag, as shown in <a href="ch07.xhtml#ch7fig4">Figure 7-4</a>. Notice that the first case uses only <em>K</em><sub>1</sub> and the second only <em>K</em><sub>2</sub>, but both use only the main key <em>K</em> to process the message chunks that precede the final one.</p>
<div class="image"><img src="../images/f07-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig3"/><em>Figure 7-3: The CMAC block cipher–based MAC construction when the message is a sequence of integral blocks</em></p>
<div class="image"><img src="../images/f07-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig4"/><em>Figure 7-4: The CMAC block cipher–based MAC construction when the last block of the message has to be padded with a 1 bit and zeros to fill a block</em></p>
<p class="indentt">Note that unlike the CBC encryption mode, CMAC does not take an IV as a parameter and is deterministic: CMAC will always return the same tag for a given message, <em>M</em>, because the computation of <strong>CMAC</strong>(<em>M</em>) is not randomized—and that’s fine, because unlike encryption, MAC computation doesn’t have to be randomized to be secure, which eliminates the burden of having to choose random IV.</p>
<h3 class="h3" id="lev1sec49">Dedicated MAC Designs</h3>
<p class="noindent">You’ve seen how to recycle hash functions and block ciphers to build PRFs that are secure as long as their underlying hash or cipher is secure. Schemes such as HMAC and CMAC simply combine available hash functions or block ciphers to yield a secure PRF or MAC. Reusing available algorithms is convenient, but is it the most efficient approach?</p>
<p class="indent">Intuitively, PRFs and MACs should require less work than unkeyed hash functions in order to be secure—their use of a secret key prevents attackers from playing with the algorithm because they don’t have the key. Also, PRFs and MACs only expose a short tag to attackers, unlike block ciphers, which expose a ciphertext that is as long as the message. Hence, PRFs and MACs <span epub:type="pagebreak" id="page_136"/>should not need the whole power of hash functions or block ciphers, which is the point of <em>dedicated design</em>—that is, algorithms created solely to serve as PRFs and/or MACs.</p>
<p class="indent">The sections that follow focus on two such algorithms that are widely used: Poly1305 and SipHash. I’ll explain their design principles and why they are likely secure.</p>
<h4 class="h4" id="lev2sec96"><em>Poly1305</em></h4>
<p class="noindent">The Poly1305 algorithm (pronounced <em>poly</em>-<em>thirteen</em>-<em>o-five</em>) was designed in 2005 by Daniel J. Bernstein (creator of the Salsa20 stream cipher discussed in <a href="ch05.xhtml#ch5">Chapter 5</a> and the ChaCha cipher that inspired the BLAKE and BLAKE2 hash functions discussed in <a href="ch06.xhtml#ch6">Chapter 6</a>). Poly1305 is optimized to be super fast on modern CPUs, and as I write this, it is used by Google to secure HTTPS (HTTP over TLS) connections and by OpenSSH, among many other applications. Unlike Salsa20, the design of Poly1305 is built on techniques dating back to the 1970s—namely, universal hash functions and the Wegman–Carter construction.</p>
<h5 class="h5">Universal Hash Functions</h5>
<p class="noindent">The Poly1305 MAC uses a <em>universal hash function</em> internally that is much weaker than a cryptographic hash function, but also much faster. Universal hash functions don’t have to be collision resistant, for example. That means less work is required to achieve their security goals.</p>
<p class="indent">Like a PRF, a universal hash is parameterized by a secret key: given a message, <em>M</em>, and key, <em>K</em>, we write <strong>UH</strong>(<em>K</em>, <em>M</em>), which is the computation of the output of a universal hash function, denoted <strong>UH</strong>. A universal hash function has only one security requirement: for any two messages, <em>M</em><sub>1</sub> and <em>M</em><sub>2</sub>, the probability that <strong>UH</strong>(<em>K</em>, <em>M</em><sub>1</sub>) = <strong>UH</strong>(<em>K</em>, <em>M</em><sub>2</sub>) must be negligible for a random key, <em>K</em>. Unlike a PRF, a universal hash doesn’t need to be pseudorandom; there simply should be no pair (<em>M</em><sub>1</sub>, <em>M</em><sub>2</sub>) that gives the same hash for many different keys. Because their security requirements are easier to satisfy, fewer operations are required and therefore universal hash functions are considerably faster than PRFs.</p>
<p class="indent">You can use a universal hash as a MAC to authenticate no more than one message, however. For example, consider the universal hash used in Poly1305, called a <em>polynomial-evaluation</em> hash. (See the seminal 1974 article “Codes Which Detect Deception” by Gilbert, MacWilliams, and Sloane for more on this notion.) This kind of polynomial-evaluation hash is parameterized by a prime number, <em>p</em>, and takes as input a key consisting of two numbers, <em>R</em> and <em>K</em>, in the range [1, <em>p</em>] and a message, <em>M</em>, consisting of <em>n</em> blocks (<em>M</em><sub>1</sub>, <em>M</em><sub>2</sub>, … , <em>M</em><sub><em>n</em></sub>). The output of the universal hash is then computed as the following:</p>
<p class="center"><strong>UH</strong>(<em>R</em>, <em>K</em>, <em>M</em>) = <em>R</em> + <em>M</em><sub>1</sub><em>K</em> + <em>M</em><sub>3</sub><em>K</em><sup>2</sup> + <em>M</em><sub>3</sub><em>K</em><sup>3</sup> + … + <em>M<sub>n</sub>K<sup>n</sup></em> mod <em>p</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_137"/>The plus sign (+) denotes the addition of positive integers, <em>K</em><sup><em>i</em></sup> is the number <em>K</em> raised to the power <em>i</em>, and “mod <em>p</em>” denotes the reduction modulo <em>p</em> of the result (that is, the remainder of the division of the result by <em>p</em>; for example, 12 mod 10 = 2, 10 mod 10 = 0, 8 mod 10 = 8, and so on).</p>
<p class="indent">Because we want the hash to be as fast as possible, universal hash-based MACs often work with message blocks of 128 bits and with a prime number, <em>p</em>, that is slightly larger than 2<sup>128</sup>, such as 2<sup>128</sup> + 51. The 128-bit width allows for very fast implementations by efficiently using the 32- and 64-bit arithmetic units of common CPUs.</p>
<h5 class="h5">Potential Vulnerabilities</h5>
<p class="noindent">Universal hashes have one weakness: because a universal hash is only able to securely authenticate one message, an attacker could break the preceding polynomial-evaluation MAC by requesting the tags of only two messages. Specifically, they could request the tags for a message where <em>M</em><sub>1</sub> = <em>M</em><sub>2</sub> = … = 0 (that is, whose tag is <strong>UH</strong>(<em>R</em>, <em>K</em>, 0) = <em>R</em>) and then use the tags to find the secret value <em>R</em>. Alternatively, they could request the tags for a message where <em>M</em><sub>1</sub> = 1 and where <em>M</em><sub>2</sub> = <em>M</em><sub>3</sub> = … = 0 (that is, whose tag is <em>T</em> = <em>R</em> + <em>K</em>), which would allow them to find <em>K</em> by subtracting <em>R</em> from <em>T</em>. Now the attacker knows the whole key (<em>R</em>, <em>K</em>) and they can forge MACs for any message.</p>
<p class="indent">Fortunately, there’s a way to go from single-message security to multi-message security.</p>
<h5 class="h5">Wegman–Carter MACs</h5>
<p class="noindentb">The trick to authenticating multiple messages using a universal hash function arrived thanks to IBM researchers Wegman and Carter and their 1981 paper “New Hash Functions and Their Use in Authentication and Set Equality.” The so-called Wegman–Carter construction builds a MAC from a universal hash function and a PRF, using two keys, <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, and it returns</p>
<p class="center"><strong>MAC</strong>(<em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>, <em>N</em>, <em>M</em>) = <strong>UH</strong>(<em>K</em><sub>1</sub>, <em>M</em>) + <strong>PRF</strong>(<em>K</em><sub>2</sub>, <em>N</em>)</p>
<p class="noindentt">where <em>N</em> is a nonce that should be unique for each key, <em>K</em><sub>2</sub>, and where <strong>PRF</strong>’s output is as large as that of the universal hash function <strong>UH</strong>. By adding these two values, <strong>PRF</strong>’s strong pseudorandom output masks the cryptographic weakness of <strong>UH</strong>. You can see this as the encryption of the universal hash’s result, where the PRF acts as a stream cipher and prevents the preceding attack by making it possible to authenticate multiple messages with the same key, <em>K</em><sub>1</sub>.</p>
<p class="indent">To recap, the Wegman–Carter construction <strong>UH</strong>(<em>K</em><sub>1</sub>, <em>M</em>) + <strong>PRF</strong>(<em>K</em><sub>2</sub>, <em>N</em>) gives a secure MAC if we assume the following:</p>
<ul>
<li class="noindent"><strong>UH</strong> is a secure universal hash.</li>
<li class="noindent"><strong>PRF</strong> is a secure PRF.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_138"/>Each nonce <em>N</em> is used only once for each key <em>K</em><sub>2</sub>.</li>
<li class="noindent">The output values of <strong>UH</strong> and <strong>PRF</strong> are long enough to ensure high enough security.</li>
</ul>
<p class="indentt">Now let’s see how Poly1305 leverages the Wegman–Carter construction to build a secure and fast MAC.</p>
<h5 class="h5">Poly1305-AES</h5>
<p class="noindent">Poly1305 was initially proposed as Poly1305-AES, combining the Poly1305 universal hash with the AES block cipher. Poly1305-AES is much faster than HMAC-based MACs, or even than CMACs, since it only computes one block of AES and processes the message in parallel through a series of simple arithmetic operations.</p>
<p class="indentb">Given a 128-bit <em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>, and <em>N</em>, and message, <em>M</em>, Poly1305-AES returns the following:</p>
<p class="center"><strong>Poly 1305</strong>(<em>K</em><sub>1</sub>, <em>M</em>) + <strong>AES</strong>(<em>K</em><sub>2</sub>, <em>N</em>) mod 2<sup>128</sup></p>
<p class="indent">The mod 2<sup>128</sup> reduction ensures that the result fits in 128 bits. The message <em>M</em> is parsed as a sequence of 128-bit blocks (<em>M</em><sub>1</sub>, <em>M</em><sub>2</sub>, … , <em>M</em><sub><em>n</em></sub>), and a 129th bit is appended to each block’s most significant bit to make all blocks 129 bits long. (If the last block is smaller than 16 bytes, it’s padded with a 1 bit followed by 0 bits before the final 129th bit.) Next, Poly1305 evaluates the polynomial to compute the following:</p>
<p class="center"><strong>Poly 1305</strong>(<em>K</em><sub>1</sub>, <em>M</em>) = <em>M</em><sub>1</sub><em>K</em><sub>1</sub><sup><em>i</em></sup> + <em>M</em><sub>2</sub><em>K</em><sub>1</sub><sup><em>n</em> − 1</sup> + … +<em>M<sub>n</sub>K</em><sub>1</sub> mod 2<sup>130</sup> − 5</p>
<p class="indent">The result of this expression is an integer that is at most 129-bits long. When added to the 128-bit value <strong>AES</strong>(<em>K</em><sub>2</sub>, <em>N</em>), the result is reduced modulo 2<sup>128</sup> to produce a 128-bit MAC.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>AES isn’t a PRF; instead, it’s a pseudorandom permutation (PRP). However, that doesn’t matter much here because the Wegman–Carter construction works with a PRP as well as with a PRF. This is because if you’re given a function that is either a PRF of a PRP, it’s hard to determine whether it’s a PRF of a PRP just by looking at the function’s output values.</em></p>
</div>
<p class="indent">The security analysis of Poly1305-AES (see “The Poly1305-AES Message-Authentication Code” at <em><a href="http://cr.yp.to/mac/poly1305-20050329.pdf">http://cr.yp.to/mac/poly1305-20050329.pdf</a></em>) shows that Poly1305-AES is 128-bit secure as long as AES is a secure block cipher—and, of course, as long as everything is implemented correctly, as with any cryptographic algorithm.</p>
<p class="indent">The Poly1305 universal hash can be combined with algorithms other than AES. For example, Poly1305 was used with the stream cipher ChaCha (see RFC 7539, “ChaCha20 and Poly1305 for IETF Protocols”). There’s no doubt that Poly1305 will keep being used wherever a fast MAC is needed.</p>
<h4 class="h4" id="lev2sec97"><span epub:type="pagebreak" id="page_139"/><em>SipHash</em></h4>
<p class="noindent">Although Poly1305 is fast and secure, it has several downsides. For one, its polynomial evaluation is difficult to implement efficiently, especially in the hands of many who are unfamiliar with the associated mathematical notions. (See examples at <em><a href="https://github.com/floodyberry/poly1305-donna/">https://github.com/floodyberry/poly1305-donna/</a></em>). Second, on its own, it’s secure for only one message unless you use the Wegman–Carter construction. But in that case, it requires a nonce, and if the nonce is repeated, the algorithm becomes insecure. Finally, Poly1305 is optimized for long messages, but it’s overkill if you process only small messages (say, fewer than 128 bytes). In such cases, SipHash is the solution.</p>
<p class="indent">I designed SipHash in 2012 with Dan Bernstein initially to address a noncryptographic problem: denial-of-service attacks on hash tables. Hash tables are data structures used to efficiently store elements in programming languages. Prior to the advent of SipHash, hash tables relied on noncryptographic keyed hash functions for which collisions were easy to find, and it was easy to exploit a remote system using a hash table by slowing it down with a denial-of-service attack. We determined that a PRF would address this problem and thus set out to design SipHash, a PRF suitable for hash tables. Because hash tables process mostly short inputs, SipHash is optimized for short messages. However, SipHash can be used for more than hash tables: it’s a full-blown PRF and MAC that shines where most inputs are short.</p>
<h5 class="h5">How SipHash Works</h5>
<p class="noindent">SipHash uses a trick that makes it more secure than basic sponge functions: instead of XORing message blocks only once before the permutation, SipHash XORs them before and after the permutation, as shown in <a href="ch07.xhtml#ch7fig5">Figure 7-5</a>. The 128-bit key of SipHash is seen as two 64-bit words, <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>, XORed to a 256-bit fixed initial state that is seen as four 64-bit words. Next, the keys are discarded, and computing SipHash boils down to iterating through a core function called SipRound and then XORing message chunks to modify the four-word internal state. Finally, SipHash returns a 64-bit tag by XORing the four-state words together.</p>
<div class="image"><img src="../images/f07-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch7fig5"/><em>Figure 7-5: SipHash-2-4 processing a 15-byte message (a block,</em> M<sub>1</sub>, of 8 bytes and a block, M<sub>2</sub>, of 7 bytes, plus 1 byte of padding)</p>
<p class="indent"><span epub:type="pagebreak" id="page_140"/>The SipRound function uses a bunch of XORs together with additions and word rotations to make the function secure. SipRound transforms a state of four 64-bit words (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>) by performing the following operations, top to bottom. The operations on the left and right are independent and can be carried out in parallel:</p>
<div class="image1"><img src="../images/f0140-01.jpg" alt="image"/></div>
<p class="indent">Here, <em>a</em> += <em>b</em> is shorthand for <em>a</em> = <em>a</em> + <em>b</em>, and <em>b</em> &lt;&lt;&lt; = 13 is shorthand for <em>b</em> = <em>b</em> &lt;&lt;&lt; 13 (the 64-bit word <em>b</em> left-rotated 13 bits.)</p>
<p class="indent">These simple operations on 64-bit words are almost all you need to implement in order to compute SipHash—although you won’t have to implement it yourself. You can find readily available implementations in most languages, including C, Go, Java, JavaScript, and Python.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>We write</em> <strong>SipHash</strong>-x-y <em>as the SipHash version, meaning it makes</em> x <em>SipRounds between each message block injection and then</em> y <em>rounds. More rounds require more operations, which slows down operations but also increases security. The default version is SipHash-2-4 (simply noted as SipHash), and it has so far resisted cryptanalysis. However, you may want to be conservative and opt for SipHash-4-8 instead, which makes twice as many rounds and is therefore twice as slow.</em></p>
</div>
<h3 class="h3" id="lev1sec50">How Things Can Go Wrong</h3>
<p class="noindent">Like ciphers and unkeyed hash functions, MACs and PRFs that are secure on paper can be vulnerable to attacks when used in a real setting, against realistic attackers. Let’s see two examples.</p>
<h4 class="h4" id="lev2sec98"><em>Timing Attacks on MAC Verification</em></h4>
<p class="noindent"><em>Side-channel attacks</em> target the implementation of a cryptographic algorithm rather than the algorithm itself. In particular, <em>timing attacks</em> use an algorithm’s execution time to determine secret information, such as keys, plaintext, and secret random values. As you might imagine, variable-time string comparison induces vulnerabilities not only in MAC verification, but also in many other cryptographic and security functionalities.</p>
<p class="indent"><span epub:type="pagebreak" id="page_141"/>MACs can be vulnerable to timing attacks when a remote system verifies tags in a period of time that depends on the tag’s value, thereby allowing an attacker to determine the correct message tag by trying many incorrect ones to determine the one that takes the longest amount of time to complete. The problem occurs when a server compares the correct tag with an incorrect one by comparing the two strings byte per byte, in order, until the bytes differ. For example, the Python code in <a href="ch07.xhtml#ch7list1">Listing 7-1</a> compares two strings byte per byte, in variable time: if the first bytes differ, the function will return after only one comparison; if the strings <code>x</code> and <code>y</code> are identical, the function will make <code>n</code> comparisons against the length of the strings.</p>
<pre>def compare_mac(x, y, n):<br/>    for i in range(n):<br/>        if x[i] != y[i]:<br/>            return False<br/>    return True</pre>
<p class="figcap"><a id="ch7list1"/><em>Listing 7-1: Comparison of two</em> n-<em>byte strings, taking variable time</em></p>
<p class="indentt">To demonstrate the vulnerability of the <code>verify_mac()</code> function, let’s write a program that measures the execution time of 100000 calls to <code>verify_mac()</code>, first with identical 10-byte <code>x</code> and <code>y</code> values and then with <code>x</code> and <code>y</code> values that differ in their third byte. We should expect the latter comparison to take noticeably less time than the former because <code>verify_mac()</code> will compare fewer bytes than the identical <code>x</code> and <code>y</code> would, as shown in <a href="ch07.xhtml#ch7list2">Listing 7-2</a>.</p>
<pre>from time import time<br/><br/>MAC1 = '0123456789abcdef'<br/>MAC2 = '01X3456789abcdef'<br/>TRIALS = 100000<br/><br/># each call to verify_mac() will look at all eight bytes<br/>start = time()<br/>for i in range(TRIALS):<br/>    compare_mac(MAC1, MAC1, len(MAC1))<br/>end = time()<br/>print('%0.5f' % (end-start))<br/><br/># each call to verify_mac() will look at three bytes<br/>start = time()<br/>for i in range(TRIALS):<br/>    compare_mac(MAC1, MAC2, len(MAC1))<br/>end = time()<br/>print('%0.5f' % (end-start))</pre>
<p class="figcap"><a id="ch7list2"/><em>Listing 7-2: Measuring timing differences when executing <span class="literalcaption">compare_mac()</span> from <a href="ch07.xhtml#ch7list1">Listing 7-1</a></em></p>
<p class="indentt">In my test environment, typical execution of the program in <a href="ch07.xhtml#ch7list2">Listing 7-2</a> prints execution times of around 0.215 and 0.095 seconds, respectively. That difference is significant enough for you to identify what’s happening <span epub:type="pagebreak" id="page_142"/>within the algorithm. Now move the difference to other offsets in the string, and you’ll observe different execution times for different offsets. If <code>MAC1</code> is the correct MAC tag and <code>MAC2</code> is the one tried by the attacker, you can easily identify the position of the first difference, which is the number of correctly guessed bytes.</p>
<p class="indent">Of course, if execution time doesn’t depend on a secret timing, timing attacks won’t work, which is why implementers strive to write <em>constant-time</em> implementations—that is, code that takes exactly the same time to complete for any secret input value. For example, the C function in <a href="ch07.xhtml#ch7list3">Listing 7-3</a> compares two buffers of <code>size</code> bytes in constant time: the temporary variable <code>result</code> will be nonzero if and only if there’s a difference somewhere in the two buffers.</p>
<pre>int cmp_const(const void *a, const void *b, const size_t size) <br/>{<br/>  const unsigned char *_a = (const unsigned char *) a;<br/>  const unsigned char *_b = (const unsigned char *) b;<br/>  unsigned char result = 0;<br/>  size_t i;<br/><br/>  for (i = 0; i &lt; size; i++) {<br/>    result |= _a[i] ^ _b[i];<br/>  }<br/><br/>  return result; /* returns 0 if *a and *b are equal, nonzero otherwise */<br/>}</pre>
<p class="figcap"><a id="ch7list3"/><em>Listing 7-3: Constant-time comparison of two buffers, for safer MAC verification</em></p>
<h4 class="h4" id="lev2sec99"><em>When Sponges Leak</em></h4>
<p class="noindent">Permutation-based algorithms like SHA-3 and SipHash are simple, easy to implement, and come with compact implementations, but they’re fragile in the face of side-channel attacks that recover a snapshot of the system’s state. For example, if a process can read the RAM and registers’ values at any time, or read a core dump of the memory, an attacker can determine the internal state of SHA-3 in MAC mode, or the internal state of SipHash, and then compute the reverse of the permutation to recover the initial secret state. They can then forge tags for any message, breaking the MAC’s security.</p>
<p class="indent">Fortunately, this attack will not work against compression function–based MACs such as HMAC-SHA-256 and keyed BLAKE2 because the attacker would need a snapshot of memory at the exact time when the key is used. The upshot is that if you’re in an environment where parts of a process’s memory may leak, you can use a MAC based on a noninvertible transform compression function rather than a permutation.</p>
<h3 class="h3" id="lev1sec51"><span epub:type="pagebreak" id="page_143"/>Further Reading</h3>
<p class="noindent">The venerable HMAC deserves more attention than I have space for here, and even more for the train of thought that led to its wide adoption, and eventually to its demise when combined with a weak hash function. I recommend the 1996 paper “Keying Hash Functions for Message Authentication” by Bellare, Canetti, and Krawczyk, which introduced HMAC and its cousin NMAC, and the 2006 follow-up paper by Bellare called “New Proofs for NMAC and HMAC: Security Without Collision-Resistance,” which proves that HMAC doesn’t need a collision-resistant hash, but only a hash with a compression function that is a PRF. On the offensive side, the 2007 paper “Full Key-Recovery Attacks on HMAC/NMAC-MD4 and NMAC-MD5” by Fouque, Leurent, and Nguyen shows how to attack HMAC and NMAC when they’re built on top of a brittle hash function such as MD4 or MD5. (By the way, HMAC-MD5 and HMAC-SHA-1 aren’t totally broken, but the risk is high enough.)</p>
<p class="indent">The Wegman–Carter MACs are also worth more attention, both for their practical interest and underlying theory. The seminal papers by Wegman and Carter are available at <em><a href="http://cr.yp.to/bib/entries.html">http://cr.yp.to/bib/entries.html</a></em>. Other state-of-the-art designs include UMAC and VMAC, which are among the fastest MACs on long messages.</p>
<p class="indent">One type of MAC not discussed in this chapter is <em>Pelican</em>, which uses the AES block cipher reduced to four rounds (down from 10 in the full block cipher) to authenticate chunks of messages within a simplistic construction, as described in <em><a href="https://eprint.iacr.org/2005/088/">https://eprint.iacr.org/2005/088/</a></em>. Pelican is more of a curiosity, though, and it’s rarely used in practice.</p>
<p class="indent">Last but not least, if you’re interested in finding vulnerabilities in cryptographic software, look for uses of CBC-MAC, or for weaknesses caused by HMAC handling keys of arbitrary sizes—taking <strong>Hash</strong>(<em>K</em>) as the key rather than <em>K</em> if <em>K</em> is too long, thus making <em>K</em> and <strong>Hash</strong>(<em>K</em>) <em>equivalent keys</em>. Or just look for systems than don’t use MAC when they should—a frequent occurrence.</p>
<p class="indent">In <a href="ch08.xhtml#ch8">Chapter 8</a>, we’ll look at how to combine MACs with ciphers to protect a message’s authenticity, integrity, <em>and</em> confidentiality. We’ll also look at how to do it without MACs, thanks to authenticated ciphers, which are ciphers that combine the functionality of a basic cipher with that of a MAC by returning a tag along with each ciphertext.<span epub:type="pagebreak" id="page_144"/></p>
</body></html>