- en: Chapter 37. Daemons
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第37章 守护进程
- en: This chapter examines the characteristics of daemon processes and looks at the
    steps required to turn a process into a daemon. We also look at how to log messages
    from a daemon using the *syslog* facility.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论守护进程的特点，并介绍将进程转变为守护进程所需的步骤。我们还将探讨如何使用*syslog*功能记录守护进程的消息。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'A *daemon* is a process with the following characteristics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*守护进程*是具有以下特点的进程：'
- en: It is long-lived. Often, a daemon is created at system startup and runs until
    the system is shut down.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是长期运行的。通常，守护进程在系统启动时创建，并在系统关闭时停止。
- en: It runs in the background and has no controlling terminal. The lack of a controlling
    terminal ensures that the kernel never automatically generates any job-control
    or terminal-related signals (such as `SIGINT, SIGTSTP`, and `SIGHUP`) for a daemon.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在后台运行，没有控制终端。没有控制终端确保内核不会自动为守护进程生成任何作业控制或终端相关的信号（如`SIGINT, SIGTSTP`和`SIGHUP`）。
- en: 'Daemons are written to carry out specific tasks, as illustrated by the following
    examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是为执行特定任务而编写的，以下是几个例子：
- en: '*cron*: a daemon that executes commands at a scheduled time.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cron*：一个在预定时间执行命令的守护进程。'
- en: '*sshd*: the secure shell daemon, which permits logins from remote hosts using
    a secure communications protocol.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sshd*：安全外壳守护进程，允许使用安全通信协议从远程主机登录。'
- en: '*httpd*: the HTTP server daemon (Apache), which serves web pages.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*httpd*：HTTP服务器守护进程（Apache），负责提供网页服务。'
- en: '*inetd*: the Internet superserver daemon (described in [The *inetd* (Internet
    Superserver) Daemon](ch60.html#the_inetd_open_parenthesis_internet_supe "The inetd
    (Internet Superserver) Daemon")), which listens for incoming network connections
    on specified TCP/IP ports and launches appropriate server programs to handle these
    connections.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*inetd*：互联网超级服务器守护进程（详见[The *inetd* (Internet Superserver) Daemon](ch60.html#the_inetd_open_parenthesis_internet_supe
    "The inetd (Internet Superserver) Daemon")），它监听指定的TCP/IP端口上的传入网络连接，并启动相应的服务器程序来处理这些连接。'
- en: Many standard daemons run as privileged processes (i.e., effective user ID of
    0), and thus should be coded following the guidelines provided in [Chapter 38](ch38.html
    "Chapter 38. Writing Secure Privileged Programs").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准守护进程作为特权进程运行（即有效用户ID为0），因此应按照[第38章](ch38.html "Chapter 38. Writing Secure
    Privileged Programs")中提供的指南进行编写。
- en: It is a convention (not universally observed) that daemons have names ending
    with the letter *d*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程的命名惯例（虽然不是普遍遵守）通常以字母*d*结尾。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, certain daemons are run as *kernel threads*. The code of such daemons
    is part of the kernel, and they are typically created during system startup. When
    listed using *ps(1)*, the names of these daemons are surrounded by square brackets
    (`[]`). One example of a kernel thread is *pdflush*, which periodically flushes
    dirty pages (e.g., pages from the buffer cache) to disk.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，某些守护进程作为*内核线程*运行。这些守护进程的代码是内核的一部分，通常在系统启动时创建。当使用*ps(1)*列出时，这些守护进程的名称会被方括号（`[]`）括起来。一个内核线程的例子是*pdflush*，它定期将脏页面（例如，缓冲区缓存中的页面）刷新到磁盘。
- en: Creating a Daemon
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建守护进程
- en: 'To become a daemon, a program performs the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为守护进程，一个程序需要执行以下步骤：
- en: 'Perform a *fork()*, after which the parent exits and the child continues. (As
    a consequence, the daemon becomes a child of the *init* process.) This step is
    done for two reasons:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行*fork()*，然后父进程退出，子进程继续运行。（因此，守护进程成为*init*进程的子进程。）此步骤有两个原因：
- en: Assuming the daemon was started from the command line, the parent’s termination
    is noticed by the shell, which then displays another shell prompt and leaves the
    child to continue in the background.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设守护进程是从命令行启动的，那么父进程的终止会被shell察觉，随后显示另一个shell提示符，并让子进程继续在后台运行。
- en: The child process is guaranteed not to be a process group leader, since it inherited
    its process group ID from its parent and obtained its own unique process ID, which
    differs from the inherited process group ID. This is required in order to be able
    to successfully perform the next step.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程保证不成为进程组的领导者，因为它从父进程继承了进程组ID，并获得了自己的唯一进程ID，这与继承的进程组ID不同。这样才能顺利执行下一步。
- en: The child process calls *setsid()* ([Sessions](ch34.html#sessions "Sessions"))
    to start a new session and free itself of any association with a controlling terminal.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程调用*setsid()*（[会话](ch34.html#sessions "Sessions")）来启动一个新会话，并与控制终端断开关联。
- en: 'If the daemon never opens any terminal devices thereafter, then we don’t need
    to worry about the daemon reacquiring a controlling terminal. If the daemon might
    later open a terminal device, then we must take steps to ensure that the device
    does not become the controlling terminal. We can do this in two ways:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果守护进程此后永远不会打开任何终端设备，那么我们不需要担心守护进程重新获取控制终端。如果守护进程可能在之后打开终端设备，那么我们必须采取措施确保该设备不会成为控制终端。我们可以通过两种方式来实现这一点：
- en: Specify the `O_NOCTTY` flag on any *open()* that may apply to a terminal device.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何可能应用于终端设备的*open()*操作中，指定`O_NOCTTY`标志。
- en: Alternatively, and more simply, perform a second *fork()* after the *setsid()*
    call, and again have the parent exit and the (grand)child continue. This ensures
    that the child is not the session leader, and thus, according to the System V
    conventions for the acquisition of a controlling terminal (which Linux follows),
    the process can never reacquire a controlling terminal ([Controlling Terminals
    and Controlling Processes](ch34.html#controlling_terminals_and_controlling_pr
    "Controlling Terminals and Controlling Processes")).
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，更简单地，在*setsid()*调用后执行第二次*fork()*，并且再次让父进程退出，(孙)子进程继续执行。这可以确保子进程不是会话领导进程，因此，根据System
    V关于获取控制终端的约定（Linux遵循该约定），该进程永远无法重新获取控制终端（[控制终端和控制进程](ch34.html#controlling_terminals_and_controlling_pr
    "控制终端和控制进程")）。
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On implementations following the BSD conventions, a process can obtain a controlling
    terminal only through an explicit *ioctl()* `TIOCSCTTY` operation, and so this
    second *fork()* has no effect with regard to the acquisition of a controlling
    terminal, but the superfluous *fork()* does no harm.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在遵循BSD约定的实现中，进程只能通过显式的*ioctl()* `TIOCSCTTY`操作来获取控制终端，因此第二次*fork()*不会影响控制终端的获取，但多余的*fork()*不会造成任何
    harm。
- en: 'Clear the process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")), to ensure that, when the daemon
    creates files and directories, they have the requested permissions.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除进程的umask（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")），以确保当守护进程创建文件和目录时，它们具有所请求的权限。
- en: 'Change the process’s current working directory, typically to the root directory
    (`/`). This is necessary because a daemon usually runs until system shutdown;
    if the daemon’s current working directory is on a file system other than the one
    containing `/`, then that file system can’t be unmounted ([Unmounting a File System:
    *umount()* and *umount2()*](ch14.html#unmounting_a_file_system_colon_umount_op
    "Unmounting a File System: umount() and umount2()")). Alternatively, the daemon
    can change its working directory to a location where it does its job or a location
    defined in its configuration file, as long as we know that the file system containing
    this directory never needs to be unmounted. For example, *cron* places itself
    in `/var/spool/cron`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改进程的当前工作目录，通常是根目录(`/`)。这是必要的，因为守护进程通常会一直运行直到系统关机；如果守护进程的当前工作目录位于一个不同于包含`/`的文件系统中，那么该文件系统无法被卸载（[卸载文件系统：*umount()*
    和 *umount2()*](ch14.html#unmounting_a_file_system_colon_umount_op "卸载文件系统：umount()
    和 umount2()")）。或者，守护进程可以将其工作目录更改为它执行工作的地方或其配置文件中定义的某个位置，只要我们知道包含该目录的文件系统不需要被卸载。例如，*cron*
    将自己放置在`/var/spool/cron`。
- en: Close all open file descriptors that the daemon has inherited from its parent.
    (A daemon may need to keep certain inherited file descriptors open, so this step
    is optional, or open to variation.) This is done for a variety of reasons. Since
    the daemon has lost its controlling terminal and is running in the background,
    it makes no sense for the daemon to keep file descriptors 0, 1, and 2 open if
    these refer to the terminal. Furthermore, we can’t unmount any file systems on
    which the long-lived daemon holds files open. And, as usual, we should close unused
    open file descriptors because file descriptors are a finite resource.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭守护进程从其父进程继承的所有打开的文件描述符。（守护进程可能需要保持某些继承的文件描述符打开，因此此步骤是可选的，或者可以有所变化。）这样做有多种原因。由于守护进程已经失去了控制终端并在后台运行，所以如果文件描述符0、1和2指向终端，守护进程保持这些文件描述符打开是没有意义的。此外，我们无法卸载守护进程保持打开文件的文件系统。而且，通常情况下，我们应该关闭不再使用的打开文件描述符，因为文件描述符是有限的资源。
- en: Note
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations (e.g., Solaris 9 and some of the recent BSD releases)
    provide a function named *closefrom(n)* (or similar), which closes all file descriptors
    greater than or equal to *n*. This function isn’t available on Linux.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些 UNIX 实现（例如，Solaris 9 和一些近期的 BSD 版本）提供一个名为 *closefrom(n)*（或类似）的函数，它关闭所有大于或等于
    *n* 的文件描述符。这个函数在 Linux 上不可用。
- en: 'After having closed file descriptors 0, 1, and 2, a daemon normally opens `/dev/null`
    and uses *dup2()* (or similar) to make all those descriptors refer to this device.
    This is done for two reasons:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭了文件描述符 0、1 和 2 后，守护进程通常会打开 `/dev/null`，并使用 *dup2()*（或类似）将所有这些描述符指向这个设备。这么做有两个原因：
- en: It ensures that if the daemon calls library functions that perform I/O on these
    descriptors, those functions won’t unexpectedly fail.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保如果守护进程调用执行 I/O 操作的库函数，这些函数不会因为描述符的问题而意外失败。
- en: It prevents the possibility that the daemon later opens a file using descriptor
    1 or 2, which is then written to—and thus corrupted—by a library function that
    expects to treat these descriptors as standard output and standard error.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它防止守护进程稍后打开一个文件，使用描述符 1 或 2，这样就会被一个库函数写入，从而导致这些描述符的标准输出和标准错误被破坏。
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`/dev/null` is a virtual device that always discards the data written to it.
    When we want to eliminate the standard output or error of a shell command, we
    can redirect it to this file. Reads from this device always return end-of-file.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/dev/null` 是一个虚拟设备，它总是丢弃写入的数据。当我们想要消除一个 shell 命令的标准输出或错误时，可以将其重定向到这个文件。对这个设备的读取总是返回文件末尾。'
- en: We now show the implementation of a function, *becomeDaemon()*, that performs
    the steps described above in order to turn the caller into a daemon.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了一个函数的实现，*becomeDaemon()*，它执行上面描述的步骤，将调用者转换为守护进程。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: The *becomeDaemon()* function takes a bit-mask argument, *flags*, that allows
    the caller to selectively inhibit some of the steps, as described in the comments
    in the header file in [Example 37-1](ch37.html#header_file_for_become_underscore_daemon
    "Example 37-1. Header file for become_daemon.c").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*becomeDaemon()* 函数接受一个位掩码参数，*flags*，允许调用者选择性地禁止一些步骤，具体如 [示例 37-1](ch37.html#header_file_for_become_underscore_daemon
    "示例 37-1. become_daemon.c 的头文件") 中头文件的注释所述。'
- en: Example 37-1. Header file for `become_daemon.c`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 37-1. `become_daemon.c` 的头文件
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The implementation of the *becomeDaemon()* function is shown in [Example 37-2](ch37.html#creating_a_daemon_process
    "Example 37-2. Creating a daemon process").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*becomeDaemon()* 函数的实现见 [示例 37-2](ch37.html#creating_a_daemon_process "示例 37-2.
    创建守护进程")。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library provides a nonstandard function, *daemon()*, that turns the
    caller into a daemon. The *glibc daemon()* function doesn’t have an equivalent
    of the *flags* argument of our *becomeDaemon()* function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库提供了一个非标准函数，*daemon()*，它将调用者转换为守护进程。*glibc daemon()* 函数没有相当于我们 *becomeDaemon()*
    函数中的 *flags* 参数。
- en: Example 37-2. Creating a daemon process
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 37-2. 创建守护进程
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we write a program that makes the call *becomeDaemon(0)* and then sleeps
    for a while, we can use *ps(1)* to look at some of the attributes of the resulting
    process:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写一个程序，调用 *becomeDaemon(0)* 后再睡一段时间，我们可以使用 *ps(1)* 查看结果进程的一些属性：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t show the source code for `daemons/test_become_daemon.c`, since it is
    trivial, but the program is provided in the source code distribution for this
    book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有展示 `daemons/test_become_daemon.c` 的源代码，因为它很简单，但该程序已包含在本书的源代码分发包中。
- en: In the output of *ps*, the `?` under the *TT* heading indicates that the process
    has no controlling terminal. From the fact that the process ID is not the same
    as the session ID (SID), we can also see that the process is not the leader of
    its session, and so won’t reacquire a controlling terminal if it opens a terminal
    device. This is as things should be for a daemon.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ps* 的输出中，*TT* 头下的 `?` 表示该进程没有控制终端。从进程 ID 与会话 ID (SID) 不同这一点，我们还可以看出该进程不是其会话的领导者，因此即使它打开一个终端设备，也不会重新获得控制终端。对于守护进程来说，情况应当如此。
- en: Guidelines for Writing Daemons
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写守护进程的指南
- en: As previously noted, a daemon typically terminates only when the system shuts
    down. Many standard daemons are stopped by application-specific scripts executed
    during system shutdown. Those daemons that are not terminated in this fashion
    will receive a `SIGTERM` signal, which the *init* process sends to all of its
    children during system shutdown. By default, `SIGTERM` terminates a process. If
    the daemon needs to perform any cleanup before terminating, it should do so by
    establishing a handler for this signal. This handler must be designed to perform
    such cleanup quickly, since *init* follows up the `SIGTERM` signal with a `SIGKILL`
    signal after 5 seconds. (This doesn’t mean that the daemon can perform 5 seconds’
    worth of CPU work; *init* signals all of the processes on the system at the same
    time, and they may all be attempting to clean up within that 5 seconds.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，守护进程通常只有在系统关闭时才会终止。许多标准守护进程在系统关闭时会被由特定应用执行的脚本停止。那些没有以这种方式终止的守护进程会收到`SIGTERM`信号，这是*init*进程在系统关闭时发送给其所有子进程的信号。默认情况下，`SIGTERM`会终止一个进程。如果守护进程在终止之前需要执行任何清理工作，它应该通过为该信号建立一个处理程序来实现。这个处理程序必须设计得能够快速完成清理，因为*init*在5秒后会跟进发送`SIGKILL`信号。（这并不意味着守护进程可以执行5秒的CPU工作；*init*会同时向系统中的所有进程发送信号，它们可能都会在这5秒内尝试进行清理。）
- en: Since daemons are long-lived, we must be particularly wary of possible memory
    leaks ([Implementation of *malloc()* and *free()*](ch07.html#implementation_of_malloc_open_parenthesi
    "Implementation of malloc() and free()")) and file descriptor leaks (where an
    application fails to close all of the file descriptors it opens). If such bugs
    affect a daemon, the only remedy is to kill it and restart it after (fixing the
    bug).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于守护进程的生命周期较长，我们必须特别小心可能出现的内存泄漏（[*malloc()* 和 *free()* 的实现](ch07.html#implementation_of_malloc_open_parenthesi
    "Implementation of malloc() and free()")）和文件描述符泄漏（应用程序未能关闭其打开的所有文件描述符）。如果这些 bug
    影响到守护进程，唯一的解决办法就是杀死该进程并在修复 bug 后重新启动它。
- en: Many daemons need to ensure that just one instance of the daemon is active at
    one time. For example, it makes no sense to have two copies of the *cron* daemon
    both trying to execute scheduled jobs. In [Running Just One Instance of a Program](ch55.html#running_just_one_instance_of_a_program
    "Running Just One Instance of a Program"), we look at a technique for achieving
    this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程需要确保一次只有一个实例在运行。例如，让两个*cron*守护进程都尝试执行定时任务是没有意义的。在[只运行一个程序实例](ch55.html#running_just_one_instance_of_a_program
    "Running Just One Instance of a Program")中，我们探讨了一种实现这一目标的技术。
- en: Using `SIGHUP` to Reinitialize a Daemon
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`SIGHUP`重新初始化守护进程
- en: 'The fact that many daemons should run continuously presents a couple of programming
    hurdles:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程需要持续运行，这就提出了几个编程上的难题：
- en: Typically, a daemon reads operational parameters from an associated configuration
    file on startup. Sometimes, it is desirable to be able to change these parameters
    “on the fly,” without needing to stop and restart the daemon.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，守护进程在启动时会从关联的配置文件中读取操作参数。有时，可能希望能够在运行时动态改变这些参数，而无需停止和重新启动守护进程。
- en: 'Some daemons produce log files. If the daemon never closes the log file, then
    it may grow endlessly, eventually clogging the file system. (In [Creating and
    Removing (Hard) Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()"), we noted that even
    if we remove the last name of a file, the file continues to exist as long as any
    process has it open.) What we need is a way of telling the daemon to close its
    log file and open a new file, so that we can rotate log files as required.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一些守护进程会生成日志文件。如果守护进程从不关闭日志文件，那么日志文件可能会不断增长，最终导致文件系统堵塞。（在[创建和删除（硬）链接：*link*()
    和 *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h "Creating and
    Removing (Hard) Links: link() and unlink()")中，我们提到过，即使我们删除文件的最后一个名称，只要有任何进程打开该文件，文件仍然会存在。）我们需要的是一种方法来告诉守护进程关闭日志文件并打开一个新文件，这样我们就可以根据需要旋转日志文件。'
- en: The solution to both of these problems is to have the daemon establish a handler
    for `SIGHUP`, and perform the required steps upon receipt of this signal. In [Controlling
    Terminals and Controlling Processes](ch34.html#controlling_terminals_and_controlling_pr
    "Controlling Terminals and Controlling Processes"), we noted that `SIGHUP` is
    generated for the controlling process on disconnection of a controlling terminal.
    Since a daemon has no controlling terminal, the kernel never generates this signal
    for a daemon. Therefore, daemons can use `SIGHUP` for the purpose described here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题的解决方案是让守护进程为`SIGHUP`信号建立一个处理程序，并在接收到该信号后执行所需的步骤。在[控制终端和控制进程](ch34.html#controlling_terminals_and_controlling_pr
    "控制终端和控制进程")中，我们提到，`SIGHUP`信号是在控制终端断开连接时生成的，因为守护进程没有控制终端，所以内核不会为守护进程生成此信号。因此，守护进程可以将`SIGHUP`用于这里描述的目的。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The *logrotate* program can be used to automate rotation of daemon log files.
    See the *logrotate(8)* manual page for details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*logrotate*程序可用于自动轮转守护进程的日志文件。有关详细信息，请参阅*logrotate(8)*手册页。'
- en: '[Example 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "Example 37-3. Using
    SIGHUP to reinitialize a daemon") provides an example of how a daemon can employ
    `SIGHUP`. This program establishes a handler for `SIGHUP` ![](figs/web/U002.png),
    becomes a daemon ![](figs/web/U003.png), opens the log file ![](figs/web/U004.png),
    and reads its configuration file ![](figs/web/U005.png). The `SIGHUP` handler
    ![](figs/web/U001.png) just sets a global flag variable, *hupReceived*, which
    is checked by the main program. The main program sits in a loop, printing a message
    to the log file every 15 seconds ![](figs/web/U008.png). The calls to *sleep()*
    ![](figs/web/U006.png) in this loop are intended to simulate some sort of processing
    performed by a real application. After each return from *sleep()* in this loop,
    the program checks to see whether *hupReceived* has been set ![](figs/web/U007.png);
    if so, it reopens the log file, rereads the configuration file, and clears the
    *hupReceived* flag.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "示例 37-3. 使用SIGHUP重新初始化守护进程")提供了一个守护进程如何使用`SIGHUP`的示例。这个程序建立了一个`SIGHUP`信号的处理程序
    ![](figs/web/U002.png)，然后成为守护进程 ![](figs/web/U003.png)，打开日志文件 ![](figs/web/U004.png)，并读取其配置文件
    ![](figs/web/U005.png)。`SIGHUP`信号处理程序 ![](figs/web/U001.png) 仅设置了一个全局标志变量，*hupReceived*，该变量由主程序检查。主程序在一个循环中运行，每15秒打印一条信息到日志文件
    ![](figs/web/U008.png)。循环中的*sleep()*调用 ![](figs/web/U006.png) 用于模拟真实应用程序的某些处理。每次从*sleep()*返回时，程序都会检查*hupReceived*是否已设置
    ![](figs/web/U007.png)；如果是，它会重新打开日志文件，重新读取配置文件，并清除*hupReceived*标志。'
- en: For brevity, the functions *logOpen()*, *logClose()*, *logMessage()*, and *readConfigFile()*
    are omitted from [Example 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo
    "Example 37-3. Using SIGHUP to reinitialize a daemon"), but are provided with
    the source code distribution of this book. The first three functions do what we
    would expect from their names. The *readConfigFile()* function simply reads a
    line from the configuration file and echoes it to the log file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，*logOpen()*, *logClose()*, *logMessage()*和*readConfigFile()*函数在[示例 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo
    "示例 37-3. 使用SIGHUP重新初始化守护进程")中被省略，但它们随本书的源代码分发。前三个函数的功能符合它们的名称。*readConfigFile()*函数只是读取配置文件中的一行并将其回显到日志文件中。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'Some daemons use an alternative method to reinitialize themselves on receipt
    of `SIGHUP`: they close all files and then restart themselves with an *exec()*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些守护进程在接收到`SIGHUP`信号时使用另一种方法来重新初始化自己：它们关闭所有文件，然后通过*exec()*重新启动自己。
- en: 'The following is an example of what we might see when running the program in
    [Example 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "Example 37-3. Using
    SIGHUP to reinitialize a daemon"). We begin by creating a dummy configuration
    file and then launching the daemon:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行程序时可能看到的示例，来自[示例 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "示例 37-3. 使用SIGHUP重新初始化守护进程")。我们首先创建一个虚拟的配置文件，然后启动守护进程：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we modify the configuration file and rename the log file before sending
    `SIGHUP` to the daemon:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们修改配置文件并重命名日志文件，然后向守护进程发送`SIGHUP`信号：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of *ls* shows that we have both an old and a new log file. When
    we use *cat* to view the contents of the old log file, we see that even after
    the *mv* command was used to rename the file, the daemon continued to log messages
    there. At this point, we could delete the old log file if we no longer need it.
    When we look at the new log file, we see that the configuration file has been
    reread:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*ls* 命令的输出显示我们有一个旧日志文件和一个新日志文件。当我们使用 *cat* 查看旧日志文件的内容时，我们发现即使在使用 *mv* 命令重命名文件后，守护进程仍然继续在该文件中记录日志消息。此时，如果不再需要该旧日志文件，我们可以删除它。当我们查看新日志文件时，我们看到配置文件已经重新读取：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that a daemon’s log and configuration files are typically placed in standard
    directories, not in the `/tmp` directory, as is done in the program in [Example 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo
    "Example 37-3. Using SIGHUP to reinitialize a daemon"). By convention, configuration
    files are placed in `/etc` or one of its subdirectories, while log files are often
    placed in `/var/log`. Daemon programs commonly provide command-line options to
    specify alternative locations instead of the defaults.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，守护进程的日志和配置文件通常放置在标准目录中，而不是像[示例 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo
    "示例 37-3. 使用 SIGHUP 重新初始化守护进程")中的程序那样放在 `/tmp` 目录中。按照惯例，配置文件放置在 `/etc` 或其子目录中，而日志文件通常放在
    `/var/log` 中。守护进程程序通常提供命令行选项，以便指定替代位置，而不是使用默认位置。
- en: Example 37-3. Using `SIGHUP` to reinitialize a daemon
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 37-3. 使用 `SIGHUP` 重新初始化守护进程
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logging Messages and Errors Using *syslog*
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 *syslog* 记录消息和错误
- en: When writing a daemon, one problem we encounter is how to display error messages.
    Since a daemon runs in the background, we can’t display messages on an associated
    terminal, as we would typically do with other programs. One possible alternative
    is to write messages to an application-specific log file, as is done in the program
    in [Example 37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "Example 37-3. Using
    SIGHUP to reinitialize a daemon"). The main problem with this approach is that
    it is difficult for a system administrator to manage multiple application log
    files and monitor them all for error messages. The *syslog* facility was devised
    to address this problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写守护进程时，我们遇到的一个问题是如何显示错误消息。由于守护进程在后台运行，我们无法像其他程序那样在关联的终端上显示消息。一个可能的替代方法是将消息写入特定于应用程序的日志文件，就像在[示例
    37-3](ch37.html#using_sighup_to_reinitialize_a_daemo "示例 37-3. 使用 SIGHUP 重新初始化守护进程")中的程序那样。这个方法的主要问题是，系统管理员很难管理多个应用程序的日志文件并同时监控这些日志中的错误消息。*syslog*
    功能就是为了解决这个问题而设计的。
- en: Overview
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: The *syslog* facility provides a single, centralized logging facility that can
    be used to log messages by all applications on the system. An overview of this
    facility is provided in [Figure 37-1](ch37.html#overview_of_system_logging "Figure 37-1. Overview
    of system logging").
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog* 功能提供了一个单一的、集中式的日志记录功能，供系统上的所有应用程序使用。有关该功能的概述请参见[图 37-1](ch37.html#overview_of_system_logging
    "图 37-1. 系统日志概述")。'
- en: '![Overview of system logging](figs/web/37-1_DAEMON-syslog-scale90.png.jpg)Figure 37-1. Overview
    of system logging'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![系统日志概述](figs/web/37-1_DAEMON-syslog-scale90.png.jpg)图 37-1. 系统日志概述'
- en: 'The *syslog* facility has two principal components: the *syslogd* daemon and
    the *syslog(3)* library function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog* 功能有两个主要组件：*syslogd* 守护进程和 *syslog(3)* 库函数。'
- en: 'The *System Log* daemon, *syslogd*, accepts log messages from two different
    sources: a UNIX domain socket, `/dev/log`, which holds locally produced messages,
    and (if enabled) an Internet domain socket (UDP port 514), which holds messages
    sent across a TCP/IP network. (On some other UNIX implementations, the *syslog*
    socket is located at `/var/run/log`.)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统日志* 守护进程，*syslogd*，接受来自两个不同来源的日志消息：一个是 UNIX 域套接字 `/dev/log`，用于存储本地生成的消息，另一个是（如果启用）互联网域套接字（UDP
    端口 514），用于存储通过 TCP/IP 网络发送的消息。（在其他某些 UNIX 实现中，*syslog* 套接字位于 `/var/run/log`。）'
- en: Each message processed by *syslogd* has a number of attributes, including a
    *facility*, which specifies the type of program generating the message, and a
    *level*, which specifies the severity (priority) of the message. The *syslogd*
    daemon examines the *facility* and *level* of each message, and then passes it
    along to any of several possible destinations according to the dictates of an
    associated configuration file, `/etc/syslog.conf`. Possible destinations include
    a terminal or virtual console, a disk file, a FIFO, one or more (or all) logged-in
    users, or a process (typically another *syslogd* daemon) on another system connected
    via a TCP/IP network. (Sending the message to a process on another system is useful
    for reducing administrative overhead by consolidating messages from multiple systems
    to a single location.) A single message may be sent to multiple destinations (or
    none at all), and messages with different combinations of *facility* and *level*
    can be targeted to different destinations or to different instances of destinations
    (i.e., different consoles, different disk files, and so on).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每条由*syslogd*处理的消息都有若干属性，包括一个*facility*，它指定生成该消息的程序类型，以及一个*level*，它指定消息的严重性（优先级）。*syslogd*守护进程检查每条消息的*facility*和*level*，然后根据相关配置文件`/etc/syslog.conf`的规定将其传递给多个可能的目的地。可能的目的地包括终端或虚拟控制台、磁盘文件、FIFO、一个或多个（或所有）登录的用户，或通过TCP/IP网络连接的另一系统上的进程（通常是另一个*syslogd*守护进程）。将消息发送到另一个系统上的进程对于通过将来自多个系统的消息集中到一个位置来减少管理开销非常有用。一条消息可以被发送到多个目的地（或完全不发送），并且具有不同*facility*和*level*组合的消息可以定向到不同的目的地或不同实例的目的地（即，不同的控制台、不同的磁盘文件等）。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sending *syslog* messages to another system via a TCP/IP network can also help
    in detecting system break-ins. Break-ins often leave traces in the system log,
    but attackers usually try to cover up their activities by erasing log records.
    With remote logging, an attacker would need to break into another system in order
    to do that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TCP/IP网络将*syslog*消息发送到另一个系统，也有助于检测系统入侵。入侵通常会在系统日志中留下痕迹，但攻击者通常会通过删除日志记录来掩盖他们的活动。使用远程日志记录，攻击者需要侵入另一个系统才能做到这一点。
- en: The *syslog(3)* library function can be used by any process to log a message.
    This function, which we describe in detail in a moment, uses its supplied arguments
    to construct a message in a standard format that is then placed on the `/dev/log`
    socket for reading by *syslogd*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog(3)*库函数可以被任何进程用来记录消息。这个函数，我们稍后会详细描述，使用其提供的参数构造一个标准格式的消息，然后将其放置在`/dev/log`套接字中，供*syslogd*读取。'
- en: An alternative source of the messages placed on `/dev/log` is the *Kernel Log*
    daemon, *klogd*, which collects kernel log messages (produced by the kernel using
    its *printk()* function). These messages are collected using either of two equivalent
    Linux-specific interfaces—the `/proc/kmsg` file and the *syslog(2)* system call—and
    then placed on `/dev/log` using the *syslog(3)* library function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将消息放置到`/dev/log`的来源是*内核日志*守护进程*klogd*，它收集内核日志消息（由内核使用*printk()*函数生成）。这些消息通过两种等效的Linux特有接口收集——`/proc/kmsg`文件和*syslog(2)*系统调用——然后使用*syslog(3)*库函数将它们放置到`/dev/log`。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although *syslog(2)* and *syslog(3)* share the same name, they perform quite
    different tasks. An interface to *syslog(2)* is provided in *glibc* under the
    name *klogctl()*. Unless explicitly indicated otherwise, when we refer to *syslog()*
    in this section, we mean *syslog(3)*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*syslog(2)*和*syslog(3)*共享相同的名称，但它们执行的任务是完全不同的。*syslog(2)*的接口在*glibc*中提供，名为*klogctl()*。除非另有明确说明，本节中提到的*syslog()*指的是*syslog(3)*。
- en: The *syslog* facility originally appeared in 4.2BSD, but is now provided on
    most UNIX implementations. SUSv3 has standardized *syslog(3)* and related functions,
    but leaves the implementation and operation of *syslogd*, as well as the format
    of the `syslog.conf` file, unspecified. The Linux implementation of *syslogd*
    differs from the original BSD facility in permitting some extensions to the message-processing
    rules that can be specified in `syslog.conf`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog*功能最初出现在4.2BSD中，但现在在大多数UNIX实现中都可以找到。SUSv3已对*syslog(3)*及相关函数进行了标准化，但未指定*syslogd*的实现和操作方式，以及`syslog.conf`文件的格式。Linux对*syslogd*的实现与原始BSD功能有所不同，允许在`syslog.conf`中指定某些消息处理规则的扩展。'
- en: The `syslog` API
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`syslog` API'
- en: 'The *syslog* API consists of three main functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog* API由三个主要函数组成：'
- en: The *openlog()* function establishes default settings that apply to subsequent
    calls to *syslog()*. The use of *openlog()* is optional. If it is omitted, a connection
    to the logging facility is established with default settings on the first call
    to *syslog()*.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*openlog()* 函数建立默认设置，这些设置适用于后续对 *syslog()* 的调用。使用 *openlog()* 是可选的。如果省略它，则在第一次调用
    *syslog()* 时，连接日志设施并使用默认设置。'
- en: The *syslog()* function logs a message.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*syslog()* 函数记录一条消息。'
- en: The *closelog()* function is called after we have finished logging messages,
    to disestablish the connection with the log.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*closelog()* 函数在完成日志记录后调用，用于断开与日志的连接。'
- en: None of these functions returns a status value. In part, this is because system
    logging should always be available (the system administrator is soon likely to
    notice if it is not). Furthermore, if an error occurs with system logging, there
    is typically little that the application can usefully do to report it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都不返回状态值。部分原因是系统日志应该始终可用（系统管理员很快会注意到如果它不可用）。此外，如果系统日志发生错误，应用程序通常也无力有效地报告它。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library also provides the function *void vsyslog(int priority, const
    char *format, va_list args)*. This function performs the same task as *syslog()*,
    but takes an argument list previously processed by the *stdarg(3)* API. (Thus,
    *vsyslog()* is to *syslog()* what *vprintf()* is to *printf()*.) SUSv3 doesn’t
    specify *vsyslog()*, and it is not available on all UNIX implementations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库还提供了 *void vsyslog(int priority, const char *format, va_list args)* 函数。这个函数执行与
    *syslog()* 相同的任务，但接受一个由 *stdarg(3)* API 之前处理过的参数列表。（因此，*vsyslog()* 对 *syslog()*
    就像 *vprintf()* 对 *printf()*。）SUSv3 没有指定 *vsyslog()*，并且并非所有 UNIX 实现都提供此函数。
- en: Establishing a connection to the system log
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 建立与系统日志的连接
- en: The *openlog()* function optionally establishes a connection to the system log
    facility and sets defaults that apply to subsequent *syslog()* calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*openlog()* 函数可选择性地建立与系统日志设施的连接，并设置适用于后续 *syslog()* 调用的默认值。'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *ident* argument is a pointer to a string that is included in each message
    written by *syslog()*; typically, the program name is specified for this argument.
    Note that *openlog()* merely copies the value of this pointer. As long as it continues
    to call *syslog()*, the application should ensure that the referenced string is
    not later changed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*ident* 参数是指向字符串的指针，该字符串包含在 *syslog()* 写入的每条消息中；通常，这个参数指定程序名称。请注意，*openlog()*
    仅仅复制这个指针的值。只要它继续调用 *syslog()*，应用程序应确保引用的字符串在后续不会被修改。'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If *ident* is specified as `NULL`, then, like some other implementations, the
    *glibc syslog* implementation automatically uses the program name as the *ident*
    value. However, this feature is not required by SUSv3, and is not provided on
    some implementations. Portable applications should avoid reliance on it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *ident* 被指定为 `NULL`，则与一些其他实现类似，*glibc syslog* 实现会自动使用程序名称作为 *ident* 值。然而，SUSv3
    并未要求此功能，且某些实现不提供此功能。便携式应用程序应避免依赖此功能。
- en: 'The *log_options* argument to *openlog()* is a bit mask created by ORing together
    any of the following constants:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*openlog()* 的 *log_options* 参数是通过将以下常量进行或运算生成的位掩码：'
- en: '`LOG_CONS`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_CONS`'
- en: If there is an error sending to the system logger, then write the message to
    the system console (`/dev/console`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送到系统日志程序时发生错误，则将消息写入系统控制台（`/dev/console`）。
- en: '`LOG_NDELAY`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_NDELAY`'
- en: Open the connection to the logging system (i.e., the underlying UNIX domain
    socket, `/dev/log`) immediately. By default (`LOG_ODELAY`), the connection is
    opened only when (and if) the first message is logged with *syslog()*. The `O_NDELAY`
    flag is useful in programs that need to precisely control when the file descriptor
    for `/dev/log` is allocated. One example of such a requirement is in a program
    that calls *chroot()*. After a *chroot()* call, the `/dev/log` pathname will no
    longer be visible, and so an *openlog()* call specifying `LOG_NDELAY` must be
    performed before the *chroot()*. The *tftpd* (Trivial File Transfer) daemon is
    an example of a program that uses `LOG_NDELAY` for this purpose.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 立即打开与日志系统的连接（即，底层的 UNIX 域套接字 `/dev/log`）。默认情况下（`LOG_ODELAY`），只有在第一次使用 *syslog()*
    记录消息时才会打开连接。如果需要精确控制何时分配 `/dev/log` 的文件描述符，`O_NDELAY` 标志很有用。一种需要此功能的情况是调用 *chroot()*
    的程序。在 *chroot()* 调用后，`/dev/log` 路径将不再可见，因此必须在 *chroot()* 之前执行指定 `LOG_NDELAY` 的
    *openlog()* 调用。*tftpd*（Trivial File Transfer）守护进程就是使用 `LOG_NDELAY` 达到这一目的的程序之一。
- en: '`LOG_NOWAIT`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_NOWAIT`'
- en: Don’t *wait()* for any child process that may have been created in order to
    log the message. On implementations that create a child process for logging messages,
    `LOG_NOWAIT` is needed if the caller is also creating and waiting for children,
    so that *syslog()* doesn’t attempt to wait for a child that has already been reaped
    by the caller. On Linux, `LOG_NOWAIT` has no effect, since no child processes
    are created when logging a message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要*wait()*任何可能已经创建的子进程以记录消息。在需要为日志消息创建子进程的实现中，如果调用者同时创建并等待子进程，则需要`LOG_NOWAIT`，以避免*syslog()*试图等待一个已经被调用者收割的子进程。在Linux上，`LOG_NOWAIT`没有效果，因为在记录消息时不会创建任何子进程。
- en: '`LOG_ODELAY`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_ODELAY`'
- en: This flag is the converse of `LOG_NDELAY`—connecting to the logging system is
    delayed until the first message is logged. This is the default, and need not be
    specified.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志是`LOG_NDELAY`的反义操作——连接到日志系统的过程会延迟，直到记录了第一条消息。这是默认行为，无需显式指定。
- en: '`LOG_PERROR`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_PERROR`'
- en: Write messages to standard error as well as to the system log. Typically, daemon
    processes close standard error or redirect it to `/dev/null`, in which case, `LOG_PERROR`
    is not useful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息写入标准错误，并同时写入系统日志。通常，守护进程会关闭标准错误或将其重定向到`/dev/null`，在这种情况下，`LOG_PERROR`就没有用处。
- en: '`LOG_PID`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_PID`'
- en: Log the caller’s process ID with each message. Employing `LOG_PID` in a server
    that forks multiple children allows us to distinguish which process logged a particular
    message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用者的进程ID与每条消息一起记录。将`LOG_PID`应用于一个产生多个子进程的服务器时，可以帮助我们区分哪个进程记录了特定的消息。
- en: All of the above constants are specified in SUSv3, except `LOG_PERROR`, which
    appears on many (but not all) other UNIX implementations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有常量都在SUSv3中进行了规定，除了`LOG_PERROR`，该常量出现在许多（但不是所有）其他UNIX实现中。
- en: The *facility* argument to *openlog()* specifies the default *facility* value
    to be used in subsequent calls to *syslog()*. Possible values for this argument
    are listed in [Table 37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*openlog()*的*facility*参数指定在后续的*syslog()*调用中要使用的默认*facility*值。此参数的可能值列在[表37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()")中。'
- en: The majority of the *facility* values in [Table 37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()")
    appear in SUSv3, as indicated by the *SUSv3* column of the table. Exceptions are
    `LOG_AUTHPRIV` and `LOG_FTP`, which appear on only a few other UNIX implementations,
    and `LOG_SYSLOG`, which appears on most implementations. The `LOG_AUTHPRIV` value
    is useful for logging messages containing passwords or other sensitive information
    to a different location than `LOG_AUTH`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[表37-1](ch37.html#facility_values_for_openlog_open_parenth "Table 37-1. facility
    values for openlog() and the priority argument of syslog()")中的大多数*facility*值出现在SUSv3中，如表格中的*SUSv3*列所示。例外情况是`LOG_AUTHPRIV`和`LOG_FTP`，它们只出现在少数其他UNIX实现中，而`LOG_SYSLOG`则出现在大多数实现中。`LOG_AUTHPRIV`值对于将包含密码或其他敏感信息的日志消息记录到不同的位置（而不是`LOG_AUTH`）非常有用。'
- en: The `LOG_KERN` *facility* value is used for kernel messages. Log messages for
    this facility can’t be generated from the user-space programs. The `LOG_KERN`
    constant has the value 0\. If it is used in a *syslog()* call, the 0 translates
    to “use the default level.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_KERN` *facility*值用于内核消息。此类消息无法由用户空间程序生成。`LOG_KERN`常量的值为0。如果在*syslog()*调用中使用，它的0会转换为“使用默认级别”。'
- en: Table 37-1. *facility* values for *openlog()* and the *priority* argument of
    *syslog()*
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表37-1. *openlog()*的*facility*值和*syslog()*的*priority*参数
- en: '| Value | Description | SUSv3 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 | SUSv3 |'
- en: '| --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `LOG_AUTH` | Security and authorization messages (e.g., *su*) | • |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_AUTH` | 安全性和授权消息（例如，*su*） | • |'
- en: '| `LOG_AUTHPRIV` | Private security and authorization messages |   |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_AUTHPRIV` | 私密安全和授权消息 |   |'
- en: '| `LOG_CRON` | Messages from the *cron* and *at* daemons | • |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_CRON` | 来自*cron*和*at*守护进程的消息 | • |'
- en: '| `LOG_DAEMON` | Messages from other system daemons | • |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_DAEMON` | 来自其他系统守护进程的消息 | • |'
- en: '| `LOG_FTP` | Messages from the *ftp* daemon (*ftpd*) |   |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_FTP` | 来自*ftp*守护进程（*ftpd*）的消息 |   |'
- en: '| `LOG_KERN` | Kernel messages (can’t be generated from a user process) | •
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_KERN` | 内核消息（无法由用户进程生成） | • |'
- en: '| `LOG_LOCAL0` | Reserved for local use (also `LOG_LOCAL1` to `LOG_LOCAL7`)
    | • |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_LOCAL0` | 保留用于本地使用（同样适用于`LOG_LOCAL1`至`LOG_LOCAL7`） | • |'
- en: '| `LOG_LPR` | Messages from the line printer system (*lpr*, *lpd*, *lpc*) |
    • |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_LPR` | 来自行式打印机系统（*lpr*，*lpd*，*lpc*）的消息 | • |'
- en: '| `LOG_MAIL` | Messages from the mail system | • |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_MAIL` | 来自邮件系统的消息 | • |'
- en: '| `LOG_NEWS` | Messages related to Usenet network news | • |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_NEWS` | 与Usenet网络新闻相关的消息 | • |'
- en: '| `LOG_SYSLOG` | Internal messages from the *syslogd* daemon |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_SYSLOG` | 来自*syslogd*守护进程的内部消息 |   |'
- en: '| `LOG_USER` | Messages generated by user processes (default) | • |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_USER` | 用户进程生成的消息（默认） | • |'
- en: '| `LOG_UUCP` | Messages from the UUCP system | • |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_UUCP` | 来自UUCP系统的消息 | • |'
- en: Logging a message
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记录消息
- en: To write a log message, we call *syslog()*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入日志消息，我们调用*syslog()*。
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *priority* argument is created by ORing together a *facility* value and
    a *level* value. The *facility* indicates the general category of the application
    logging the message, and is specified as one of the values listed in [Table 37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()").
    If omitted, the *facility* defaults to the value specified in a previous *openlog()*
    call, or to `LOG_USER` if that call was omitted. The *level* value indicates the
    severity of the message, and is specified as one of the values in [Table 37-2](ch37.html#level_values_for_the_priority_argument_o
    "Table 37-2. level values for the priority argument of syslog() (from highest
    to lowest severity)"). All of the *level* values listed in this table appear in
    SUSv3.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*priority*参数是通过将*facility*值和*level*值按位或（OR）组合起来创建的。*facility*表示记录消息的应用程序的通用类别，并作为[表37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()")中列出的值之一进行指定。如果省略，*facility*将默认为先前*openlog()*调用中指定的值，或者如果该调用被省略，则默认为`LOG_USER`。*level*值表示消息的严重性，并作为[表37-2](ch37.html#level_values_for_the_priority_argument_o
    "Table 37-2. level values for the priority argument of syslog() (from highest
    to lowest severity)")中的值之一进行指定。此表中列出的所有*level*值都出现在SUSv3中。'
- en: Table 37-2. *level* values for the *priority* argument of *syslog()* (from highest
    to lowest severity)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表37-2. *syslog()*的*priority*参数的*level*值（从最高到最低严重性）
- en: '| Value | Description |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOG_EMERG` | Emergency or panic condition (system is unusable) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_EMERG` | 紧急或危急情况（系统无法使用） |'
- en: '| `LOG_ALERT` | Condition requiring immediate action (e.g., corrupt system
    database) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_ALERT` | 需要立即采取行动的情况（例如，损坏的系统数据库） |'
- en: '| `LOG_CRIT` | Critical condition (e.g., error on disk device) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_CRIT` | 严重条件（例如，磁盘设备错误） |'
- en: '| `LOG_ERR` | General error condition |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_ERR` | 一般错误条件 |'
- en: '| `LOG_WARNING` | Warning message |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_WARNING` | 警告消息 |'
- en: '| `LOG_NOTICE` | Normal condition that may require special handling |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_NOTICE` | 可能需要特别处理的正常情况 |'
- en: '| `LOG_INFO` | Informational message |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_INFO` | 信息性消息 |'
- en: '| `LOG_DEBUG` | Debugging message |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `LOG_DEBUG` | 调试消息 |'
- en: The remaining arguments to *syslog()* are a format string and corresponding
    arguments in the manner of *printf()*. One difference from *printf()* is that
    the format string doesn’t need to include a terminating newline character. Also,
    the format string may include the 2-character sequence `%m`, which is replaced
    by the error string corresponding to the current value of *errno* (i.e., the equivalent
    of *strerror(errno)*).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog()*的其余参数是格式化字符串及其相应参数，类似于*printf()*。与*printf()*的一个不同之处在于，格式化字符串不需要包含终止的换行符。此外，格式化字符串可以包含2个字符的序列`%m`，它会被与当前*errno*值对应的错误字符串替换（即相当于*strerror(errno)*）。'
- en: 'The following code demonstrates the use of *openlog()* and *syslog()*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了*openlog()*和*syslog()*的使用：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since no *facility* is specified in the first *syslog()* call, the default specified
    by *openlog()* (`LOG_LOCAL0`) is used. In the second *syslog()* call, explicitly
    specifying `LOG_USER` overrides the default established by *openlog()*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在第一次*syslog()*调用中未指定*facility*，因此使用*openlog()*指定的默认值（`LOG_LOCAL0`）。在第二次*syslog()*调用中，显式指定`LOG_USER`会覆盖由*openlog()*建立的默认值。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From the shell, we can use the *logger(1)* command to add entries to the system
    log. This command allows specification of the *level* (*priority*) and *ident*
    (*tag*) to be associated with the logged messages. For further details, see the
    *logger(1)* manual page. The *logger* command is (weakly) specified in SUSv3,
    and a version of this command is provided on most UNIX implementations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shell中，我们可以使用*logger(1)*命令将条目添加到系统日志中。该命令允许指定与日志消息关联的*level*（*priority*）和*ident*（*tag*）。有关更多详细信息，请参阅*logger(1)*手册页。*logger*命令（弱规范）在SUSv3中有所规定，并且该命令的版本在大多数UNIX实现中都可用。
- en: 'It is an error to use *syslog()* to write some user-supplied string in the
    following manner:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*syslog()*以以下方式写入用户提供的字符串是一个错误：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The problem with this code is that it leaves the application open to so-called
    *format-string attacks*. If the user-supplied string contains format specifiers
    (e.g., `%s`), then the results are unpredictable and, from a security point of
    view, potentially dangerous. (The same observation applies to the use of the conventional
    *printf()* function.) We should instead rewrite the above call as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，它让应用程序容易受到所谓的 *格式字符串攻击*。如果用户提供的字符串包含格式说明符（例如 `%s`），那么结果是不可预测的，并且从安全角度来看，可能是危险的。（同样的观察适用于传统的
    *printf()* 函数的使用。）我们应该将上面的调用重写为如下：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Closing the log
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭日志
- en: When we have finished logging, we can call *closelog()* to deallocate the file
    descriptor used for the `/dev/log` socket.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成日志记录时，可以调用 *closelog()* 来释放用于 `/dev/log` 套接字的文件描述符。
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since a daemon typically keeps a connection open to the system log continuously,
    it is common to omit calling *closelog()*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于守护进程通常会持续保持与系统日志的连接，因此通常省略调用 *closelog()*。
- en: Filtering log messages
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤日志消息
- en: The *setlogmask()* function sets a mask that filters the messages written by
    *syslog()*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*setlogmask()* 函数设置一个掩码，用于过滤 *syslog()* 写入的消息。'
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns previous log priority mask
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 返回之前的日志优先级掩码
- en: Any message whose *level* is not included in the current mask setting is discarded.
    The default mask value allows all severity levels to be logged.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其 *level* 不在当前掩码设置中的消息都会被丢弃。默认的掩码值允许记录所有严重性级别的消息。
- en: 'The macro `LOG_MASK()` (defined in `<syslog.h>`) converts the *level* values
    of [Table 37-2](ch37.html#level_values_for_the_priority_argument_o "Table 37-2. level
    values for the priority argument of syslog() (from highest to lowest severity)")
    to bit values suitable for passing to *setlogmask()*. For example, to discard
    all messages except those with priorities of `LOG_ERR` and above, we would make
    the following call:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 宏 `LOG_MASK()`（在 `<syslog.h>` 中定义）将 [表 37-2](ch37.html#level_values_for_the_priority_argument_o
    "表 37-2. syslog() 优先级参数的 level 值（从最高到最低严重性）") 中的 *level* 值转换为适合传递给 *setlogmask()*
    的位值。例如，要丢弃除 `LOG_ERR` 及以上优先级的所有消息，我们可以进行如下调用：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `LOG_MASK()` macro is specified by SUSv3\. Most UNIX implementations (including
    Linux) also provide the unspecified macro `LOG_UPTO()`, which creates a bit mask
    filtering all messages of a certain *level* and above. Using this macro, we can
    simplify the previous *setlogmask()* call to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_MASK()` 宏由 SUSv3 定义。大多数 UNIX 实现（包括 Linux）还提供了未指定的宏 `LOG_UPTO()`，该宏创建一个位掩码，过滤掉某个特定*级别*及以上的所有消息。使用此宏，我们可以简化之前的
    *setlogmask()* 调用，改为如下：'
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `/etc/syslog.conf` File
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`/etc/syslog.conf` 文件'
- en: 'The `/etc/syslog.conf` configuration file controls the operation of the *syslogd*
    daemon. This file consists of rules and comments (starting with a `#` character).
    Rules have the following general form:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/syslog.conf` 配置文件控制 *syslogd* 守护进程的操作。该文件由规则和注释（以 `#` 字符开头）组成。规则的一般形式如下：'
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Together, the *facility* and *level* are referred to as the *selector*, since
    they select the messages to which the rule applies. These fields are strings corresponding
    to the values listed in [Table 37-1](ch37.html#facility_values_for_openlog_open_parenth
    "Table 37-1. facility values for openlog() and the priority argument of syslog()")
    and [Table 37-2](ch37.html#level_values_for_the_priority_argument_o "Table 37-2. level
    values for the priority argument of syslog() (from highest to lowest severity)").
    The *action* specifies where to send the messages matching this *selector*. White
    space separates the *selector* and the *action* parts of a rule. The following
    are examples of rules:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*facility* 和 *level* 一起被称为 *selector*，因为它们选择应用规则的消息。这些字段是与 [表 37-1](ch37.html#facility_values_for_openlog_open_parenth
    "表 37-1. openlog() 和 syslog() 的优先级参数的 facility 值") 和 [表 37-2](ch37.html#level_values_for_the_priority_argument_o
    "表 37-2. syslog() 优先级参数的 level 值（从最高到最低严重性）") 中列出的值对应的字符串。*action* 指定将匹配此 *selector*
    的消息发送到何处。空格分隔规则的 *selector* 部分和 *action* 部分。以下是规则的示例：'
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first rule says that messages from all facilities (`*`) with a *level* of
    `err` (`LOG_ERR`) or higher should be sent to the `/dev/tty10` console device.
    The second rule says that authorization facility (`LOG_AUTH`) messages with a
    *level* of `notice` (`LOG_NOTICE`) or higher should be sent to any consoles or
    terminals where *root* is logged in. This particular rule would allow a logged-in
    *root* user to immediately see messages about failed *su* attempts, for example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则表示来自所有设施（`*`）且*level*为`err`（`LOG_ERR`）或更高的消息应发送到`/dev/tty10`控制台设备。第二条规则表示来自授权设施（`LOG_AUTH`）且*level*为`notice`（`LOG_NOTICE`）或更高的消息应发送到任何*root*登录的控制台或终端。这个特定的规则允许已登录的*root*用户立即看到有关失败的*su*尝试的消息，例如。
- en: The last rule demonstrates several of the more advanced features of rule syntax.
    A rule can contain multiple selectors separated by semicolons. The first selector
    specifies *all* messages, using the `*` wildcard for *facility* and `debug` for
    *level*, meaning all messages of level `debug` (the lowest level) and higher.
    (On Linux, as on some other UNIX implementations, it is possible to specify *level*
    as `*`, with the same meaning as `debug`. However, this feature is not available
    to all *syslog* implementations.) Normally, a rule that contains multiple selectors
    matches messages corresponding to any of the selectors, but specifying a *level*
    of `none` has the effect of *excluding* all messages belonging to the corresponding
    *facility*. Thus, this rule sends all messages except those for the `mail` and
    `news` facilities to the file `/var/log/messages`. The hyphen (`-`) preceding
    the name of this file specifies that a sync to the disk does not occur on each
    write to the file (refer to [Controlling Kernel Buffering of File I/O](ch13.html#controlling_kernel_buffering_of_file_i_s
    "Controlling Kernel Buffering of File I/O")). This means that writes are faster,
    but some data may be lost if the system crashes soon after the write.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条规则展示了规则语法的多个高级特性。一条规则可以包含多个由分号分隔的选择器。第一个选择器指定*所有*消息，使用`*`通配符表示*facility*，并使用`debug`表示*level*，这意味着所有`debug`级别（最低级别）及以上的消息。（在Linux上，像某些其他UNIX实现一样，可以将*level*指定为`*`，其含义与`debug`相同。然而，并非所有*syslog*实现都支持此特性。）通常，包含多个选择器的规则会匹配与任何选择器对应的消息，但指定*level*为`none`的规则会*排除*所有属于相应*facility*的消息。因此，这条规则将所有消息（除了`mail`和`news`设施的消息）发送到文件`/var/log/messages`。文件名前的连字符（`-`）指定每次写入文件时不会同步到磁盘（参见[控制内核文件I/O缓冲](ch13.html#controlling_kernel_buffering_of_file_i_s
    "Controlling Kernel Buffering of File I/O")）。这意味着写入速度更快，但如果系统在写入后立即崩溃，某些数据可能会丢失。
- en: 'Whenever we change the `syslog.conf` file, we must ask the daemon to reinitialize
    itself from this file in the usual fashion:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们更改`syslog.conf`文件时，必须按照常规方式要求守护进程从该文件重新初始化：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Further features of the `syslog.conf` rule syntax allow for much more powerful
    rules than we have shown. Full details are provided in the *syslog.conf(5)* manual
    page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`syslog.conf`规则语法的其他特性允许创建比我们展示的更强大的规则。完整的细节请参考*syslog.conf(5)*手册页。'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A daemon is a long-lived process that has no controlling terminal (i.e., it
    runs in the background). Daemons perform specific tasks, such as providing a network
    login facility or serving web pages. To become a daemon, a program performs a
    standard sequence of steps, including calls to *fork()* and *setsid()*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是一个没有控制终端（即在后台运行）的长时间运行的进程。守护进程执行特定任务，例如提供网络登录功能或提供网页服务。为了成为一个守护进程，程序执行一系列标准步骤，包括调用*fork()*和*setsid()*。
- en: Where appropriate, daemons should correctly handle the arrival of the `SIGTERM`
    and `SIGHUP` signals. The `SIGTERM` signal should result in an orderly shutdown
    of the daemon, while the `SIGHUP` signal provides a way to trigger the daemon
    to reinitialize itself by rereading its configuration file and reopening any log
    files it may be using.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的情况下，守护进程应正确处理`SIGTERM`和`SIGHUP`信号的到达。`SIGTERM`信号应导致守护进程有序关闭，而`SIGHUP`信号则提供了一种通过重新读取配置文件并重新打开可能正在使用的任何日志文件来触发守护进程重新初始化的方式。
- en: The *syslog* facility provides a convenient way for daemons (and other applications)
    to log error and other messages to a central location. These messages are processed
    by the *syslogd* daemon, which redistributes the messages according to the dictates
    of the `syslogd.conf` configuration file. Messages may be redistributed to a number
    of targets, including terminals, disk files, logged-in users, and, via a TCP/IP
    network, to other processes on remote hosts (typically other *syslogd* daemons).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog* 功能为守护进程（以及其他应用程序）提供了一种方便的方式，将错误和其他消息记录到一个中央位置。这些消息由 *syslogd* 守护进程处理，按照
    `syslogd.conf` 配置文件的指示重新分发消息。消息可以被重新分发到多个目标，包括终端、磁盘文件、已登录用户，并通过 TCP/IP 网络发送到远程主机上的其他进程（通常是其他
    *syslogd* 守护进程）。'
- en: Further information
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: Perhaps the best source of further information about writing daemons is the
    source code of various existing daemons.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 也许关于编写守护进程的最佳信息来源是各种现有守护进程的源代码。
- en: Exercise
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program (similar to *logger(1)*) that uses *syslog(3)* to write arbitrary
    messages to the system log file. As well as accepting a single command-line argument
    containing the message to be logged, the program should permit an option to specify
    the *level* of the message.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序（类似于 *logger(1)*），使用 *syslog(3)* 将任意消息写入系统日志文件。除了接受包含要记录消息的单个命令行参数外，程序还应该允许指定消息的
    *级别* 选项。
