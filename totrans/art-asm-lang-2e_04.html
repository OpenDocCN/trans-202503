<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;PROCEDURES AND UNITS"><div class="titlepage"><div><div><h1 class="title"><a id="procedures_and_units"/>Chapter 5. PROCEDURES AND UNITS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e22151"/><img alt="PROCEDURES AND UNITS" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>In a procedural programming language, the basic unit of code is the <span class="emphasis"><em>procedure</em></span>. A procedure is a set of instructions that compute some value or take some action (such as printing or reading a character value). This chapter discusses how HLA implements procedures. It begins by discussing HLA's high-level syntax for procedure declarations and invocations, but it also describes the low-level implementation of procedures at the machine level. At this point, you should be getting comfortable with assembly language programming, so it's time to start presenting "pure" assembly language rather than continuing to rely on HLA's high-level syntax as a crutch.<a class="indexterm" id="IDX-CHP-5-0001"/><a class="indexterm" id="IDX-CHP-5-0002"/><a class="indexterm" id="IDX-CHP-5-0003"/><a class="indexterm" id="IDX-CHP-5-0004"/><a class="indexterm" id="IDX-CHP-5-0005"/></p><div class="sect1" title="5.1 Procedures"><div class="titlepage"><div><div><h1 class="title"><a id="procedures"/>5.1 Procedures</h1></div></div></div><p>Most procedural programming languages implement procedures using the call/return mechanism. That is, some code calls a procedure, the procedure does its thing, and then the procedure returns to the caller. The call and return instructions provide the 80x86's <span class="emphasis"><em>procedure invocation mechanism</em></span>. The calling code calls a procedure with the <code class="literal">call</code> instruction and the procedure returns to the caller with the <code class="literal">ret</code> instruction. For example, the following 80x86 instruction calls the HLA Standard Library <code class="literal">stdout.newln</code> routine:<sup>[<a class="footnote" href="#ftn.CHP-5-FN-1" id="CHP-5-FN-1">70</a>]</sup><a class="indexterm" id="IDX-CHP-5-0006"/><a class="indexterm" id="IDX-CHP-5-0007"/></p><a id="I_programlisting5_d1e22218"/><pre class="programlisting">call stdout.newln;</pre><p>The <code class="literal">stdout.newln</code> procedure prints a newline sequence to the console device and returns control to the instruction immediately following the <code class="literal">call stdout.newln;</code> instruction.</p><p>Alas, the HLA Standard Library does not supply all the routines you will ever need. Most of the time you'll have to write your own procedures. To do this, you will use HLA's procedure-declaration facilities. A basic HLA procedure declaration takes the following form:</p><a id="I_programlisting5_d1e22230"/><pre class="programlisting">procedure <em class="replaceable"><code>ProcName</code></em>;
          &lt;&lt; Local declarations &gt;&gt;
     begin <em class="replaceable"><code>ProcName</code></em>;
          &lt;&lt; Procedure statements &gt;&gt;
     end <em class="replaceable"><code>ProcName</code></em>;</pre><p>Procedure declarations appear in the declaration section of your program. That is, anywhere you can put a <code class="literal">static</code>, <code class="literal">const</code>, <code class="literal">type</code>, or other declaration section, you may place a procedure declaration. In the syntax example above, <em class="replaceable"><code>ProcName</code></em> represents the name of the procedure you wish to define. This can be any valid (and unique) HLA identifier. Whatever identifier follows the <code class="literal">procedure</code> reserved word must also follow the <code class="literal">begin</code> and <code class="literal">end</code> reserved words in the procedure. As you've probably noticed, a procedure declaration looks a whole lot like an HLA program. In fact, the only difference (so far) is the use of the <code class="literal">procedure</code> reserved word rather than the <code class="literal">program</code> reserved word.</p><p>Here is a concrete example of an HLA procedure declaration. This procedure stores zeros into the 256 double words that EBX points at upon entry into the procedure:</p><a id="I_programlisting5_d1e22273"/><pre class="programlisting">procedure zeroBytes;
begin zeroBytes;

     mov( 0, eax );
     mov( 256, ecx );
     repeat
          mov( eax, [ebx] );
          add( 4, ebx );
          dec( ecx );

     until( @z );  // That is, until ecx=0.

end zeroBytes;</pre><p>You can use the 80x86 <code class="literal">call</code> instruction to call this procedure. When, during program execution, the code falls into the <code class="literal">end zeroBytes;</code> statement, the procedure returns to whoever called it and begins executing the first instruction beyond the <code class="literal">call</code> instruction. The program in <a class="xref" href="ch05.html#example_of_a_simple_procedure" title="Example 5-1. Example of a simple procedure">Example 5-1</a> provides an example of a call to the <code class="literal">zeroBytes</code> routine.<a class="indexterm" id="IDX-CHP-5-0008"/></p><div class="example"><a id="example_of_a_simple_procedure"/><p class="title">Example 5-1. Example of a simple procedure</p><div class="example-contents"><pre class="programlisting">program zeroBytesDemo;
#include( "stdlib.hhf" )


    procedure zeroBytes;
    begin zeroBytes;

        mov( 0, eax );
        mov( 256, ecx );
        repeat

            mov( eax, [ebx] );  // Zero out current dword.
            add( 4, ebx );      // Point ebx at next dword.
            dec( ecx );         // Count off 256 dwords.

        until( ecx = 0 );       // Repeat for 256 dwords.

    end zeroBytes;

static
    dwArray: dword[256];

begin zeroBytesDemo;

    lea( ebx, dwArray );
    call zeroBytes;

end zeroBytesDemo;</pre></div></div><p>As you may have noticed when calling HLA Standard Library procedures, you don't have to use the <code class="literal">call</code> instruction to call HLA procedures. There is nothing special about the HLA Standard Library procedures versus your own procedures. Although the formal 80x86 mechanism for calling procedures is to use the <code class="literal">call</code> instruction, HLA provides a high-level extension that lets you call a procedure by simply specifying the procedure's name followed by an empty set of parentheses.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-2" id="CHP-5-FN-2">71</a>]</sup> For example, either of the following statements will call the HLA Standard Library <code class="literal">stdout.newln</code> procedure:</p><a id="I_programlisting5_d1e22318"/><pre class="programlisting">call stdout.newln;
stdout.newln();</pre><p>Likewise, either of the following statements will call the <code class="literal">zeroBytes</code> procedure in <a class="xref" href="ch05.html#example_of_a_simple_procedure" title="Example 5-1. Example of a simple procedure">Example 5-1</a>:<a class="indexterm" id="IDX-CHP-5-0009"/><a class="indexterm" id="IDX-CHP-5-0010"/><a class="indexterm" id="IDX-CHP-5-0011"/><a class="indexterm" id="IDX-CHP-5-0012"/><a class="indexterm" id="IDX-CHP-5-0013"/><a class="indexterm" id="IDX-CHP-5-0014"/></p><a id="I_programlisting5_d1e22353"/><pre class="programlisting">call zeroBytes;
zeroBytes();</pre><p>The choice of calling mechanism is strictly up to you. Most people, however, find the high-level syntax easier to read.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-1" id="ftn.CHP-5-FN-1">70</a>] </sup>Normally you would call <code class="literal">newln</code> using the high-level <code class="literal">newln()</code>; syntax, but the <code class="literal">call</code> instruction works as well.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-2" id="ftn.CHP-5-FN-2">71</a>] </sup>This assumes that the procedure does not have any parameters.</p></div></div></div>
<div class="sect1" title="5.2 Saving the State of the Machine"><div class="titlepage"><div><div><h1 class="title"><a id="saving_the_state_of_the_machine"/>5.2 Saving the State of the Machine</h1></div></div></div><p>Take a look at the program in <a class="xref" href="ch05s02.html#program_with_an_unintended_infinite_loop" title="Example 5-2. Program with an unintended infinite loop">Example 5-2</a>. This section of code attempts to print 20 lines of 40 spaces and an asterisk. Unfortunately, there is a subtle bug that creates an infinite loop. The main program uses the <code class="literal">repeat..until</code> loop to call <code class="literal">PrintSpaces</code> 20 times. <code class="literal">PrintSpaces</code> uses ECX to count off the 40 spaces it prints. <code class="literal">PrintSpaces</code> returns with ECX containing 0. The main program then prints an asterisk and a newline, decrements ECX, and then repeats because ECX isn't 0 (it will always contain $FFFF_FFFF at this point).</p><p>The problem here is that the <code class="literal">PrintSpaces</code> subroutine doesn't preserve the ECX register. Preserving a register means you save it upon entry into the subroutine and restore it before leaving. Had the <code class="literal">PrintSpaces</code> subroutine preserved the contents of the ECX register, the program in <a class="xref" href="ch05s02.html#program_with_an_unintended_infinite_loop" title="Example 5-2. Program with an unintended infinite loop">Example 5-2</a> would have functioned properly.</p><div class="example"><a id="program_with_an_unintended_infinite_loop"/><p class="title">Example 5-2. Program with an unintended infinite loop</p><div class="example-contents"><pre class="programlisting">program nonWorkingProgram;
#include( "stdlib.hhf" );


    procedure PrintSpaces;
    begin PrintSpaces;

        mov( 40, ecx );
        repeat

            mov( ' ', al );
            stdout.putc( al );  // Print 1 of 40 spaces.
            dec( ecx );         // Count off 40 spaces.

        until( ecx = 0 );

    end PrintSpaces;

begin nonWorkingProgram;

    mov( 20, ecx );
    repeat

        PrintSpaces();
        stdout.put( '*', nl );
        dec( ecx );

    until( ecx = 0 );

end nonWorkingProgram;</pre></div></div><p>You can use the 80x86's <code class="literal">push</code> and <code class="literal">pop</code> instructions to preserve register values while you need to use them for something else. Consider the following code for <code class="literal">PrintSpaces</code>:<a class="indexterm" id="IDX-CHP-5-0015"/><a class="indexterm" id="IDX-CHP-5-0016"/><a class="indexterm" id="IDX-CHP-5-0017"/><a class="indexterm" id="IDX-CHP-5-0018"/><a class="indexterm" id="IDX-CHP-5-0019"/><a class="indexterm" id="IDX-CHP-5-0020"/><a class="indexterm" id="IDX-CHP-5-0021"/><a class="indexterm" id="IDX-CHP-5-0022"/><a class="indexterm" id="IDX-CHP-5-0023"/></p><a id="I_programlisting5_d1e22442"/><pre class="programlisting">procedure PrintSpaces;
    begin PrintSpaces;

        push( eax );
        push( ecx );
        mov( 40, ecx );
        repeat

            mov( ' ', al );
            stdout.putc( al );  // Print 1 of 40 spaces.
            dec( ecx );         // Count off 40 spaces.

        until( ecx = 0 );
        pop( ecx );
        pop( eax );

    end PrintSpaces;</pre><p>Note that <code class="literal">PrintSpaces</code> saves and restores EAX and ECX (because this procedure modifies these registers). Also, note that this code pops the registers off the stack in the reverse order that it pushed them. The last-in, first-out operation of the stack imposes this ordering.</p><p>Either the caller (the code containing the <code class="literal">call</code> instruction) or the callee (the subroutine) can take responsibility for preserving the registers. In the example above, the callee preserved the registers. The example in <a class="xref" href="ch05s02.html#demonstration_of_caller_register_preserv" title="Example 5-3. Demonstration of caller register preservation">Example 5-3</a> shows what this code might look like if the caller preserves the registers:</p><div class="example"><a id="demonstration_of_caller_register_preserv"/><p class="title">Example 5-3. Demonstration of caller register preservation</p><div class="example-contents"><pre class="programlisting">program callerPreservation;
#include( "stdlib.hhf" );


    procedure PrintSpaces;
    begin PrintSpaces;

        mov( 40, ecx );
        repeat

            mov( ' ', al );
            stdout.putc( al );  // Print 1 of 40 spaces.
            dec( ecx );         // Count off 40 spaces.

        until( ecx = 0 );

    end PrintSpaces;
begin callerPreservation;

    mov( 20, ecx );
    repeat

        push( eax );
        push( ecx );
        PrintSpaces();
        pop( ecx );
        pop( eax );
        stdout.put( '*', nl );
        dec( ecx );

    until( ecx = 0 );

end callerPreservation;</pre></div></div><p>There are two advantages to callee preservation: space and maintainability. If the callee (the procedure) preserves all affected registers, then there is only one copy of the <code class="literal">push</code> and <code class="literal">pop</code> instructions, those the procedure contains. If the caller saves the values in the registers, the program needs a set of <code class="literal">push</code> and <code class="literal">pop</code> instructions around every call. Not only does this make your programs longer, it also makes them harder to maintain. Remembering which registers to push and pop on each procedure call is not easily done.</p><p>On the other hand, a subroutine may unnecessarily preserve some registers if it preserves all the registers it modifies. In the examples above, the code needn't save EAX. Although <code class="literal">PrintSpaces</code> changes AL, this won't affect the program's operation. If the caller is preserving the registers, it doesn't have to save registers it doesn't care about (see the program in <a class="xref" href="ch05s02.html#demonstrating_that_caller_preservation_n" title="Example 5-4. Demonstrating that caller preservation need not save all registers">Example 5-4</a>).</p><div class="example"><a id="demonstrating_that_caller_preservation_n"/><p class="title">Example 5-4. Demonstrating that caller preservation need not save all registers</p><div class="example-contents"><pre class="programlisting">program callerPreservation2;
#include( "stdlib.hhf" );


    procedure PrintSpaces;
    begin PrintSpaces;

        mov( 40, ecx );
        repeat

            mov( ' ', al );
            stdout.putc( al );  // Print 1 of 40 spaces.
            dec( ecx );         // Count off 40 spaces.

        until( ecx = 0 );

    end PrintSpaces;

begin callerPreservation2;

    mov( 10, ecx );
    repeat

        push( ecx );
        PrintSpaces();
        pop( ecx );
        stdout.put( '*', nl );
        dec( ecx );

    until( ecx = 0 );


    mov( 5, ebx );
    while( ebx &gt; 0 ) do

        PrintSpaces();

        stdout.put( ebx, nl );
        dec( ebx );

    endwhile;


    mov( 110, ecx );
    for( mov( 0, eax );  eax &lt; 7; inc( eax )) do

        PrintSpaces();

        stdout.put( eax, " ", ecx, nl );
        dec( ecx );

    endfor;

end callerPreservation2;</pre></div></div><p>This example in <a class="xref" href="ch05s02.html#demonstrating_that_caller_preservation_n" title="Example 5-4. Demonstrating that caller preservation need not save all registers">Example 5-4</a> provides three different cases. The first loop (<code class="literal">repeat..until</code>) preserves only the ECX register. Modifying the AL register won't affect the operation of this loop. Immediately after the first loop, this code calls <code class="literal">PrintSpaces</code> again in the <code class="literal">while</code> loop. However, this code doesn't save EAX or ECX because it doesn't care if <code class="literal">PrintSpaces</code> changes them.</p><p>One big problem with having the caller preserve registers is that your program may change over time. You may modify the calling code or the procedure to use additional registers. Such changes, of course, may change the set of registers that you must preserve. Worse still, if the modification is in the subroutine itself, you will need to locate <span class="emphasis"><em>every</em></span> call to the routine and verify that the subroutine does not change any registers the calling code uses.</p><p>Preserving registers isn't all there is to preserving the environment. You can also push and pop variables and other values that a subroutine might change. Because the 80x86 allows you to push and pop memory locations, you can easily preserve these values as well.</p></div>
<div class="sect1" title="5.3 Prematurely Returning from a Procedure"><div class="titlepage"><div><div><h1 class="title"><a id="prematurely_returning_from_a_procedure"/>5.3 Prematurely Returning from a Procedure</h1></div></div></div><p>The HLA <code class="literal">exit</code> and <code class="literal">exitif</code> statements let you return from a procedure without having to fall into the corresponding <code class="literal">end</code> statement in the procedure. These statements behave a whole lot like the <code class="literal">break</code> and <code class="literal">breakif</code> statements for loops, except that they transfer control to the bottom of the procedure rather than out of the current loop. These statements are quite useful in many cases.<a class="indexterm" id="IDX-CHP-5-0024"/><a class="indexterm" id="IDX-CHP-5-0025"/><a class="indexterm" id="IDX-CHP-5-0026"/><a class="indexterm" id="IDX-CHP-5-0027"/><a class="indexterm" id="IDX-CHP-5-0028"/></p><p>The syntax for these two statements is the following:</p><a id="I_programlisting5_d1e22555"/><pre class="programlisting">exit <em class="replaceable"><code>procedurename</code></em>;
exitif( <em class="replaceable"><code>boolean_expression</code></em> ) <em class="replaceable"><code>procedurename</code></em>;</pre><p>The <em class="replaceable"><code>procedurename</code></em> operand is the name of the procedure you wish to exit. If you specify the name of your main program, the <code class="literal">exit</code> and <code class="literal">exitif</code> statements will terminate program execution (even if you're currently inside a procedure rather than the body of the main program).</p><p>The <code class="literal">exit</code> statement immediately transfers control out of the specified procedure or program. The conditional <code class="literal">exitif</code> statement first tests the boolean expression and exits if the result is true. It is semantically equivalent to the following:</p><a id="I_programlisting5_d1e22585"/><pre class="programlisting">if( <em class="replaceable"><code>boolean_expression</code></em> ) then

               exit <em class="replaceable"><code>procedurename</code></em>;

          endif;</pre><p>Although the <code class="literal">exit</code> and <code class="literal">exitif</code> statements are invaluable in many cases, you should avoid using them without careful consideration. If a simple <code class="literal">if</code> statement will let you skip the rest of the code in your procedure, then by all means use the <code class="literal">if</code> statement. Procedures that contain a lot of <code class="literal">exit</code> and <code class="literal">exitif</code> statements will be harder to read, understand, and maintain than procedures without these statements (after all, the <code class="literal">exit</code> and <code class="literal">exitif</code> statements are really nothing more than <code class="literal">goto</code> statements, and you've probably heard already about the problems with <code class="literal">goto</code>s). <code class="literal">exit</code> and <code class="literal">exitif</code> are convenient when you have to return from a procedure inside a sequence of nested control structures, and slapping an <code class="literal">if..endif</code> around the remaining code in the procedure is impractical.</p></div>
<div class="sect1" title="5.4 Local Variables"><div class="titlepage"><div><div><h1 class="title"><a id="local_variables"/>5.4 Local Variables</h1></div></div></div><p>HLA procedures, like procedures and functions in most high-level languages, let you declare <span class="emphasis"><em>local variables</em></span>. Local variables are generally accessible only within the procedure; they are not accessible by the code that calls the procedure. Local variable declarations are identical to variable declarations in your main program except, of course, you declare the variables in the procedure's declaration section rather than the main program's declaration section. Actually, you may declare anything in the procedure's declaration section that is legal in the main program's declaration section, including constants, types, and even other procedures.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-3" id="CHP-5-FN-3">72</a>]</sup> In this section, however, we'll concentrate on local variables.<a class="indexterm" id="IDX-CHP-5-0029"/><a class="indexterm" id="IDX-CHP-5-0030"/></p><p>Local variables have two important attributes that differentiate them from the variables in your main program (that is, <span class="emphasis"><em>global</em></span> variables): <span class="emphasis"><em>lexical scope</em></span> and <span class="emphasis"><em>lifetime</em></span>. Lexical scope, or just <span class="emphasis"><em>scope</em></span>, determines where an identifier is usable in your program. Lifetime determines when a variable has memory associated with it and is capable of storing data. Because these two concepts differentiate local and global variables, it is wise to spend some time discussing them.<a class="indexterm" id="IDX-CHP-5-0031"/><a class="indexterm" id="IDX-CHP-5-0032"/></p><p>Perhaps the best place to start when discussing the scope and lifetimes of local variables is with the scope and lifetimes of global variables—those variables you declare in your main program. Until now, the only rule you've had to follow concerning the declaration of your variables has been "you must declare all variables that you use in your programs." The position of the HLA declaration section with respect to the program statements automatically enforces the other major rule, which is "you must declare all variables before their first use." With the introduction of procedures, it is now possible to violate this rule because (1) procedures may access global variables, and (2) procedure declarations may appear anywhere in a declaration section, even before some variable declarations. The program in <a class="xref" href="ch05s04.html#demonstration_of_global_scope" title="Example 5-5. Demonstration of global scope">Example 5-5</a> demonstrates this source code organization.</p><div class="example"><a id="demonstration_of_global_scope"/><p class="title">Example 5-5. Demonstration of global scope</p><div class="example-contents"><pre class="programlisting">program demoGlobalScope;
#include( "stdlib.hhf" );

static
    AccessibleInProc: char;


    procedure aProc;
    begin aProc;

        mov( 'a', AccessibleInProc );

    end aProc;


static
    InaccessibleInProc: char;


begin demoGlobalScope;


    mov( 'b', InaccessibleInProc );
    aProc();
    stdout.put
    (
        "AccessibleInProc   = '", AccessibleInProc,   "'" nl
        "InaccessibleInProc = '", InaccessibleInProc, "'" nl
    );



end demoGlobalScope;</pre></div></div><p>This example demonstrates that a procedure can access global variables in the main program as long as you declare those global variables before the procedure. In this example, the <code class="literal">aProc</code> procedure cannot access the <code class="literal">InaccessibleInProc</code> variable because its declaration appears after the procedure declaration. However, <code class="literal">aProc</code> may reference <code class="literal">AccessibleInProc</code> because its declaration appears before the <code class="literal">aProc</code> procedure.</p><p>A procedure can access any <code class="literal">static</code>, <code class="literal">storage</code>, or <code class="literal">readonly</code> object exactly the same way the main program accesses such variables—by referencing the name. Although a procedure may access global <code class="literal">var</code> objects, a different syntax is necessary, and you need to learn a little more before you will understand the purpose of the additional syntax (for more details, please consult the HLA reference manual).</p><p>Accessing global objects is convenient and easy. Unfortunately, as you've probably learned when studying high-level language programming, accessing global objects makes your programs harder to read, understand, and maintain. Like most introductory programming texts, this book discourages the use of global variables within procedures. Accessing global variables within a procedure is sometimes the best solution to a given problem. However, such (legitimate) access typically occurs only in advanced programs involving multiple threads of execution or in other complex systems. Because it is unlikely you would be writing such code at this point, it is equally unlikely that you will absolutely need to access global variables in your procedures, so you should carefully consider your options before doing so.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-4" id="CHP-5-FN-4">73</a>]</sup></p><p>Declaring local variables in your procedures is very easy; you use the same declaration sections as the main program: <code class="literal">static</code>, <code class="literal">readonly</code>, <code class="literal">storage</code>, and <code class="literal">var</code>. The same rules and syntax for the declaration sections and the access of variables you declare in these sections apply in your procedure. The example code in <a class="xref" href="ch05s04.html#example_of_a_local_variable_in_a_procedu" title="Example 5-6. Example of a local variable in a procedure">Example 5-6</a> demonstrates the declaration of a local variable.</p><div class="example"><a id="example_of_a_local_variable_in_a_procedu"/><p class="title">Example 5-6. Example of a local variable in a procedure</p><div class="example-contents"><pre class="programlisting">program demoLocalVars;
#include( "stdlib.hhf" );

    // Simple procedure that displays 0..9 using
    // a local variable as a loop control variable.

    procedure CntTo10;
    var
        i: int32;

    begin CntTo10;

        for( mov( 0, i ); i &lt; 10; inc( i )) do

            stdout.put( "i=" , i, nl );

        endfor;

    end CntTo10;


begin demoLocalVars;

    CntTo10();

end demoLocalVars;</pre></div></div><p>Local variables in a procedure are accessible only within that procedure.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-5" id="CHP-5-FN-5">74</a>]</sup> Therefore, the variable <code class="literal">i</code> in procedure <code class="literal">CntTo10</code> in <a class="xref" href="ch05s04.html#example_of_a_local_variable_in_a_procedu" title="Example 5-6. Example of a local variable in a procedure">Example 5-6</a> is not accessible in the main program.</p><p>For local variables, HLA relaxes the rule that identifiers must be unique in a program. In an HLA program, all identifiers must be unique within a given <span class="emphasis"><em>scope</em></span>. Therefore, all global names must be unique with respect to one another. Similarly, all local variables within a given procedure must have unique names <span class="emphasis"><em>but only with respect to other local symbols in that same procedure</em></span>. In particular, a local name may be the same as a global name. When this occurs, HLA creates two separate variables. Within the scope of the procedure, any reference to the common name accesses the local variable; outside that procedure, any reference to the common name references the global identifier. Although the quality of the resultant code is questionable, it is perfectly legal to have a global identifier named <code class="literal">MyVar</code> with the same local name in two or more different procedures. The procedures each have their own local variant of the object, which is independent of <code class="literal">MyVar</code> in the main program. <a class="xref" href="ch05s04.html#local_variables_need_not_have_globally_u" title="Example 5-7. Local variables need not have globally unique names.">Example 5-7</a> provides an example of an HLA program that demonstrates this feature.</p><div class="example"><a id="local_variables_need_not_have_globally_u"/><p class="title">Example 5-7. Local variables need not have globally unique names.</p><div class="example-contents"><pre class="programlisting">program demoLocalVars2;
#include( "stdlib.hhf" );

static
    i:  uns32 := 10;
    j:  uns32 := 20;

    // The following procedure declares i and j
    // as local variables, so it does not have access
    // to the global variables by the same name.

    procedure First;
    var
        i:int32;
        j:uns32;

    begin First;

        mov( 10, j );
        for( mov( 0, i ); i &lt; 10; inc( i )) do

            stdout.put( "i=", i," j=", j, nl );
            dec( j );

        endfor;

    end First;

    // This procedure declares only an i variable.
    // It cannot access the value of the global i
    // variable but it can access the value of the
    // global j object because it does not provide
    // a local variant of j.

    procedure Second;
    var
        i:uns32;

    begin Second;

        mov( 10, j );
        for( mov( 0, i ); i &lt; 10; inc( i )) do

            stdout.put( "i=", i," j=", j, nl );
            dec( j );

        endfor;

    end Second;


begin demoLocalVars2;

    First();
    Second();

    // Because the calls to First and Second have not
    // modified variable i, the following statement
    // should print "i=10". However, because the Second
    // procedure manipulated global variable j, this
    // code will print "j=0" rather than "j=20".

    stdout.put(  "i=", i, " j=", j, nl );

end demoLocalVars2;</pre></div></div><p>There are good and bad points to be made about reusing global names within a procedure. On the one hand, there is the potential for confusion. If you use a name like <code class="literal">ProfitsThisYear</code> as a global symbol and you reuse that name within a procedure, someone reading the procedure might think that the procedure refers to the global symbol rather than the local symbol. On the other hand, simple names like <code class="literal">i</code>, <code class="literal">j</code>, and <code class="literal">k</code> are nearly meaningless (almost everyone expects the program to use them as loop-control variables or for other local uses), so reusing these names as local objects is probably a good idea. From a software engineering perspective, it is probably a good idea to keep all variables names that have a very specific meaning (like <code class="literal">ProfitsThisYear</code>) unique throughout your program. General names that have a nebulous meaning (like <code class="literal">index</code> and <code class="literal">counter</code> and names like <code class="literal">i</code>, <code class="literal">j</code>, or <code class="literal">k</code>) will probably be okay to reuse as global variables.<a class="indexterm" id="IDX-CHP-5-0033"/><a class="indexterm" id="IDX-CHP-5-0034"/></p><p>There is one last point to make about the scope of identifiers in an HLA program: variables in separate procedures are separate, even if they have the same name. The <code class="literal">First</code> and <code class="literal">Second</code> procedures in <a class="xref" href="ch05s04.html#local_variables_need_not_have_globally_u" title="Example 5-7. Local variables need not have globally unique names.">Example 5-7</a>, for example, share the same name (<code class="literal">i</code>) for a local variable. However, the <code class="literal">i</code> in <code class="literal">First</code> is a completely different variable from the <code class="literal">i</code> in <code class="literal">Second</code>.</p><p>The second major attribute that differentiates local variables from global variables is <span class="emphasis"><em>lifetime</em></span>. The lifetime of a variable spans from the point when the program first allocates storage for a variable to the point when the program deallocates the storage for that variable. Note that lifetime is a dynamic attribute (controlled at runtime), whereas scope is a static attribute (controlled at compile time). In particular, a variable can actually have several lifetimes if the program repeatedly allocates and then deallocates the storage for that variable.</p><p>Global variables always have a single lifetime that spans from the moment when the main program first begins execution to the point when the main program terminates. Likewise, all static objects have a single lifetime that spans the execution of the program (remember, static objects are those you declare in the <code class="literal">static</code>, <code class="literal">readonly</code>, or <code class="literal">storage</code> sections). This is true even within procedures. So there is no difference between the lifetime of a local static object and the lifetime of a global static object. Variables you declare in the <code class="literal">var</code> section, however, are a different matter. HLA's <code class="literal">var</code> objects use <span class="emphasis"><em>automatic storage allocation</em></span>. Automatic storage allocation means that the procedure automatically allocates storage for a local variable upon entry into a procedure. Similarly, the program deallocates storage for automatic objects when the procedure returns to its caller. Therefore, the lifetime of an automatic object is from the point of the execution of the first statement in a procedure to the point when it returns to its caller.<a class="indexterm" id="IDX-CHP-5-0035"/></p><p>Perhaps the most important thing to note about automatic variables is that you cannot expect them to maintain their values between calls to the procedure. Once the procedure returns to its caller, the storage for the automatic variable is lost and, therefore, the value is lost as well. Thus, <span class="emphasis"><em>you must always assume that a local</em></span> <em class="replaceable"><code>var</code></em> <span class="emphasis"><em>object is uninitialized upon entry into a procedure</em></span>, even if you know you've called the procedure before and the previous procedure invocation initialized that variable. Whatever value the last call stored into the variable was lost when the procedure returned to its caller. If you need to maintain the value of a variable between calls to a procedure, you should use one of the static variable declaration types.</p><p>Given that automatic variables cannot maintain their values across procedure calls, you might wonder why you would want to use them at all. However, there are several benefits to automatic variables that static variables do not have. The biggest disadvantage to static variables is that they consume memory even when the (only) procedure that references them is not running. Automatic variables, on the other hand, consume storage only while their associated procedure is executing. Upon return, the procedure returns any automatic storage it allocated back to the system for reuse by other procedures. You'll see some additional advantages to automatic variables later in this chapter.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-3" id="ftn.CHP-5-FN-3">72</a>] </sup>Strictly speaking, this is not true. You may not declare external objects within a procedure. External objects are the subject of <a class="xref" href="ch05s24.html" title="5.24 Units and the external Directive">5.24 Units and the external Directive</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-4" id="ftn.CHP-5-FN-4">73</a>] </sup>Note that this argument against accessing global variables does not apply to other global symbols. It is perfectly reasonable to access global constants, types, procedures, and other objects in your programs.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-5" id="ftn.CHP-5-FN-5">74</a>] </sup>Strictly speaking, this is not true. However, accessing nonlocal <code class="literal">var</code> objects is beyond the scope of this text. See the HLA documentation for more details.</p></div></div></div>
<div class="sect1" title="5.5 Other Local and Global Symbol Types"><div class="titlepage"><div><div><h1 class="title"><a id="other_local_and_global_symbol_types"/>5.5 Other Local and Global Symbol Types</h1></div></div></div><p>As the previous section notes, HLA procedures let you declare constants, values, types, and almost everything else legal in the main program's declaration section. The same rules for scope apply to these identifiers. Therefore, you can reuse constant names, procedure names, type names, and the like in local declarations.</p><p>Referencing global constants, values, and types does not present the same software engineering problems that occur when you reference global variables. The problem with referencing global variables is that a procedure can change the value of a global variable in a nonobvious way. This makes programs more difficult to read, understand, and maintain because you can't often tell that a procedure is modifying memory by looking only at the call to that procedure. Constants, values, types, and other nonvariable objects don't suffer from this problem because you cannot change them at runtime. Therefore, the pressure to avoid global objects at nearly all costs doesn't apply to nonvariable objects.</p><p>Having said that it's okay to access global constants, types, and so on, it's also worth pointing out that you should declare these objects locally within a procedure if the only place your program references such objects is within that procedure. Doing so will make your programs a little easier to read because the person reading your code won't have to search all over the place for the symbol's definition.</p></div>
<div class="sect1" title="5.6 Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="parameters"/>5.6 Parameters</h1></div></div></div><p>Although many procedures are totally self-contained, most procedures require some input data and return some data to the caller. Parameters are values that you pass to and from a procedure. In straight assembly language, passing parameters can be a real chore. Fortunately, HLA provides a high-level-language-like syntax for procedure declarations and for procedure calls involving parameters. This section presents HLA's high-level parameter syntax. Later sections in this chapter deal with the low-level mechanisms for passing parameters in pure assembly code.</p><p>The first thing to consider when discussing parameters is <span class="emphasis"><em>how</em></span> we pass them to a procedure. If you are familiar with Pascal or C/C++, you've probably seen two ways to pass parameters: pass by value and pass by reference. HLA certainly supports these two parameter-passing mechanisms. However, HLA also supports pass by value/result, pass by result, pass by name, and pass by lazy evaluation. Of course, HLA is assembly language, so it is possible to pass parameters in HLA using any scheme you can dream up (at least, any scheme that is possible at all on the CPU). However, HLA provides special high-level syntax for pass by value, reference, value/result, result, name, and lazy evaluation.<a class="indexterm" id="IDX-CHP-5-0036"/></p><p>Because pass by value/result, result, name, and lazy evaluation are somewhat advanced, this book will not deal with those parameter-passing mechanisms. If you're interested in learning more about these parameter-passing schemes, see the HLA reference manual or check out the electronic versions of this text at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>.</p><p>Another concern you will face when dealing with parameters is <span class="emphasis"><em>where</em></span> you pass them. There are many different places to pass parameters; in this section we'll pass procedure parameters on the stack. You don't really need to concern yourself with the details because HLA abstracts them away for you; however, do keep in mind that procedure calls and procedure parameters make use of the stack. Therefore, whatever you push on the stack immediately before a procedure call is not going to be on the top of the stack upon entry into the procedure.</p><div class="sect2" title="5.6.1 Pass by Value"><div class="titlepage"><div><div><h2 class="title"><a id="pass_by_value"/>5.6.1 Pass by Value</h2></div></div></div><p>A parameter passed by value is just that—the caller passes a value to the procedure. Pass-by-value parameters are input-only parameters. That is, you can pass them to a procedure, but the procedure cannot return values through them. Given the HLA procedure call<a class="indexterm" id="IDX-CHP-5-0037"/><a class="indexterm" id="IDX-CHP-5-0038"/></p><a id="I_programlisting5_d1e22939"/><pre class="programlisting">CallProc(I);</pre><p>if you pass <code class="literal">I</code> by value, then <code class="literal">CallProc</code> does not change the value of <code class="literal">I</code>, regardless of what happens to the parameter inside <code class="literal">CallProc</code>.</p><p>Because you must pass a copy of the data to the procedure, you should use this method only for passing small objects like bytes, words, and double words. Passing large arrays and records by value is very inefficient (because you must create and pass a copy of the object to the procedure).</p><p>HLA, like Pascal and C/C++, passes parameters by value unless you specify otherwise. The following is what a typical function looks like with a single pass-by-value parameter.</p><a id="I_programlisting5_d1e22959"/><pre class="programlisting">procedure PrintNSpaces( N:uns32 );
    begin PrintNSpaces;

        push( ecx );
        mov( N, ecx );
        repeat

            stdout.put( ' ' );  // Print 1 of N spaces.
            dec( ecx );         // Count off N spaces.

        until( ecx = 0 );
        pop( ecx );

    end PrintNSpaces;</pre><p>The parameter <code class="literal">N</code> in <code class="literal">PrintNSpaces</code> is known as a <span class="emphasis"><em>formal parameter</em></span>. Anywhere the name <code class="literal">N</code> appears in the body of the procedure, the program references the value passed through <code class="literal">N</code> by the caller.</p><p>The calling sequence for <code class="literal">PrintNSpaces</code> can be any of the following:</p><a id="I_programlisting5_d1e22983"/><pre class="programlisting">PrintNSpaces( <em class="replaceable"><code>constant</code></em> );
PrintNSpaces( <em class="replaceable"><code>reg32</code></em> );
PrintNSpaces( <em class="replaceable"><code>uns32_variable</code></em> );</pre><p>Here are some concrete examples of calls to <code class="literal">PrintNSpaces</code>:</p><a id="I_programlisting5_d1e23000"/><pre class="programlisting">PrintNSpaces( 40 );
PrintNSpaces( eax );
PrintNSpaces( SpacesToPrint );</pre><p>The parameter in the calls to <code class="literal">PrintNSpaces</code> is known as an <span class="emphasis"><em>actual parameter</em></span>. In the examples above, <code class="literal">40</code>, <code class="literal">eax</code>, and <code class="literal">SpacesToPrint</code> are the actual parameters.</p><p>Note that pass-by-value parameters behave exactly like local variables you declare in the <code class="literal">var</code> section with the single exception that the procedure's caller initializes these local variables before it passes control to the procedure.</p><p>HLA uses positional parameter notation just as most high-level languages do. Therefore, if you need to pass more than one parameter, HLA will associate the actual parameters with the formal parameters by their position in the parameter list. The following <code class="literal">PrintNChars</code> procedure demonstrates a simple procedure that has two parameters:<a class="indexterm" id="IDX-CHP-5-0039"/></p><a id="I_programlisting5_d1e23032"/><pre class="programlisting">procedure PrintNChars( N:uns32; c:char );
    begin PrintNChars;

        push( ecx );
        mov( N, ecx );
        repeat

            stdout.put( c );    // Print 1 of N characters.
            dec( ecx );         // Count off N characters.

        until( ecx = 0 );
        pop( ecx );

    end PrintNChars;</pre><p>The following is an invocation of the <code class="literal">PrintNChars</code> procedure that will print 20 asterisk characters:</p><a id="I_programlisting5_d1e23039"/><pre class="programlisting">PrintNChars( 20, '*' );</pre><p>Note that HLA uses semicolons to separate the formal parameters in the procedure declaration, and it uses commas to separate the actual parameters in the procedure invocation (Pascal programmers should be comfortable with this notation). Also note that each HLA formal parameter declaration takes the following form:</p><a id="I_programlisting5_d1e23043"/><pre class="programlisting"><em class="replaceable"><code>parameter_identifier</code></em> : <em class="replaceable"><code>type_identifier</code></em></pre><p>In particular, note that the parameter type has to be an identifier. None of the following are legal parameter declarations because the data type is not a single identifier:</p><a id="I_programlisting5_d1e23051"/><pre class="programlisting">PtrVar: pointer to uns32
ArrayVar: uns32[10]
recordVar: record i:int32; u:uns32; endrecord
DynArray: array.dArray( uns32, 2 )</pre><p>However, don't get the impression that you cannot pass pointer, array, record, or dynamic array variables as parameters. The trick is to declare a data type for each of these types in the <code class="literal">type</code> section. Then you can use a single identifier as the type in the parameter declaration. The following code fragment demonstrates how to do this with the four data types above:</p><a id="I_programlisting5_d1e23059"/><pre class="programlisting">type
     uPtr:        pointer to uns32;
     uArray10:    uns32[10];
     recType:     record i:int32; u:uns32; endrecord
     dType:       array.dArray( uns32, 2 );

     procedure FancyParms
     (
          PtrVar:   uPtr;
          ArrayVar: uArray10;
          recordVar:recType;
          DynArray: dType
     );
     begin FancyParms;
          .
          .
          .
     end FancyParms;</pre><p>By default, HLA assumes that you intend to pass a parameter by value. HLA also lets you explicitly state that a parameter is a value parameter by prefacing the formal parameter declaration with the <code class="literal">val</code> keyword. The following is a version of the <code class="literal">PrintNSpaces</code> procedure that explicitly states that <code class="literal">N</code> is a pass-by-value parameter:<a class="indexterm" id="IDX-CHP-5-0040"/></p><a id="I_programlisting5_d1e23077"/><pre class="programlisting">procedure PrintNSpaces( val N:uns32 );
    begin PrintNSpaces;

        push( ecx );
        mov( N, ecx );
        repeat

            stdout.put( ' ' );  // Print 1 of N spaces.
            dec( ecx );         // Count off N spaces.

        until( ecx = 0 );
        pop( ecx );

    end PrintNSpaces;</pre><p>Explicitly stating that a parameter is a pass-by-value parameter is a good idea if you have multiple parameters in the same procedure declaration that use different passing mechanisms.</p><p>When you pass a parameter by value and call the procedure using the HLA high-level language syntax, HLA will automatically generate code that will make a copy of the actual parameter's value and copy this data into the local storage for that parameter (that is, the formal parameter). For small objects, pass by value is probably the most efficient way to pass a parameter. For large objects, however, HLA must generate code that copies each and every byte of the actual parameter into the formal parameter. For large arrays and records, this can be a very expensive operation.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-6" id="CHP-5-FN-6">75</a>]</sup> Unless you have specific semantic concerns that require you to pass a large array or record by value, you should use pass by reference or some other parameter-passing mechanism for arrays and records.</p><p>When passing parameters to a procedure, HLA checks the type of each actual parameter and compares this type to the corresponding formal parameter. If the types do not agree, HLA then checks to see if either the actual or the formal parameter is a byte, word, or double-word object and the other parameter is 1, 2, or 4 bytes in length (respectively). If the actual parameter does not satisfy either of these conditions, HLA reports a parameter-type mismatch error. If, for some reason, you need to pass a parameter to a procedure using a different type than the procedure calls for, you can always use the HLA type-coercion operator to override the type of the actual parameter.<a class="indexterm" id="IDX-CHP-5-0041"/><a class="indexterm" id="IDX-CHP-5-0042"/><a class="indexterm" id="IDX-CHP-5-0043"/><a class="indexterm" id="IDX-CHP-5-0044"/></p></div><div class="sect2" title="5.6.2 Pass by Reference"><div class="titlepage"><div><div><h2 class="title"><a id="pass_by_reference"/>5.6.2 Pass by Reference</h2></div></div></div><p>To pass a parameter by reference, you must pass the address of a variable rather than its value. In other words, you must pass a pointer to the data. The procedure must dereference this pointer to access the data. Passing parameters by reference is useful when you must modify the actual parameter or when you pass large data structures between procedures.</p><p>To declare a pass-by-reference parameter, you must preface the formal parameter declaration with the <code class="literal">var</code> keyword. The following code fragment demonstrates this:</p><a id="I_programlisting5_d1e23119"/><pre class="programlisting">procedure UsePassByReference( var PBRvar: int32 );
     begin UsePassByReference;
          .
          .
          .
     end UsePassByReference;</pre><p>Calling a procedure with a pass-by-reference parameter uses the same syntax as pass by value except that the parameter has to be a memory location; it cannot be a constant or a register. Furthermore, the type of the memory location must exactly match the type of the formal parameter. The following are legal calls to the procedure above (assuming <code class="literal">i32</code> is an <code class="literal">int32</code> variable):</p><a id="I_programlisting5_d1e23129"/><pre class="programlisting">UsePassByReference( i32 );
UsePassByReference( (type int32 [ebx] ) );</pre><p>The following are all illegal <code class="literal">UsePassbyReference</code> invocations (assuming <code class="literal">charVar</code> is of type <code class="literal">char</code>):</p><a id="I_programlisting5_d1e23142"/><pre class="programlisting">UsePassByReference( 40 );           // Constants are illegal.
UsePassByReference( EAX );          // Bare registers are illegal.
UsePassByReference( charVar );      // Actual parameter type must match
                                    // the formal parameter type.</pre><p>Unlike the high-level languages Pascal and C++, HLA does not completely hide the fact that you are passing a pointer rather than a value. In a procedure invocation, HLA will automatically compute the address of a variable and pass that address to the procedure. Within the procedure itself, however, you cannot treat the variable like a value parameter (as you could in most high-level languages). Instead, you treat the parameter as a double-word variable containing a pointer to the specified data. You must explicitly dereference this pointer when accessing the parameter's value. The example appearing in <a class="xref" href="ch05s06.html#accessing_pass-by-reference_parameters" title="Example 5-8. Accessing pass-by-reference parameters">Example 5-8</a> provides a simple demonstration of this.</p><div class="example"><a id="accessing_pass-by-reference_parameters"/><p class="title">Example 5-8. Accessing pass-by-reference parameters</p><div class="example-contents"><pre class="programlisting">program PassByRefDemo;
#include( "stdlib.hhf" );

var
    i:  int32;
    j:  int32;

    procedure pbr( var a:int32; var b:int32 );
    const
        aa: text := "(type int32 [ebx])";
        bb: text := "(type int32 [ebx])";

    begin pbr;

        push( eax );
        push( ebx );        // Need to use ebx to dereference a and b.

        // a = −1;

        mov( a, ebx );      // Get ptr to the "a" variable.
        mov( −1, aa );      // Store −1 into the "a" parameter.

        // b = −2;

        mov( b, ebx );      // Get ptr to the "b" variable.
        mov( −2, bb );      // Store −2 into the "b" parameter.

        // Print the sum of a+b.
        // Note that ebx currently contains a pointer to "b".

        mov( bb, eax );
        mov( a, ebx );      // Get ptr to "a" variable.
        add( aa, eax );
        stdout.put( "a+b=", (type int32 eax), nl );

    end pbr;

begin PassByRefDemo;

    // Give i and j some initial values so
    // we can see that pass by reference will
    // overwrite these values.

    mov( 50, i );
    mov( 25, j );

    // Call pbr passing i and j by reference

    pbr( i, j );

    // Display the results returned by pbr.

    stdout.put
    (
        "i=  ", i, nl,
        "j=  ", j, nl
    );

end PassByRefDemo;</pre></div></div><p>Passing parameters by reference can produce some peculiar results in some rare circumstances. Consider the <code class="literal">pbr</code> procedure in <a class="xref" href="ch05s06.html#accessing_pass-by-reference_parameters" title="Example 5-8. Accessing pass-by-reference parameters">Example 5-8</a>. Were you to modify the call in the main program to be <code class="literal">pbr(i,i)</code> rather than <code class="literal">pbr(i,j)</code>;, the program would produce the following nonintuitive output:<a class="indexterm" id="IDX-CHP-5-0045"/></p><a id="I_programlisting5_d1e23172"/><pre class="programlisting">a+b=−4
i=  −2;
j=  25;</pre><p>The reason this code displays <code class="literal">a+b=−4</code> rather than the expected <code class="literal">a+b=−3</code> is because the <code class="literal">pbr(i,i);</code> call passes the same actual parameter for <code class="literal">a</code> and <code class="literal">b</code>. As a result, the <code class="literal">a</code> and <code class="literal">b</code> reference parameters both contain a pointer to the same memory location—that of the variable <code class="literal">i</code>. In this case, <code class="literal">a</code> and <code class="literal">b</code> are <span class="emphasis"><em>aliases</em></span> of one another. Therefore, when the code stores −2 at the location pointed at by <code class="literal">b</code>, it overwrites the −1 stored earlier at the location pointed at by <code class="literal">a</code>. When the program fetches the value pointed at by <code class="literal">a</code> and <code class="literal">b</code> to compute their sum, both <code class="literal">a</code> and <code class="literal">b</code> point at the same value, which is −2. Summing −2 + −2 produces the −4 result that the program displays. This nonintuitive behavior is possible anytime you encounter aliases in a program. Passing the same variable as two different reference parameters probably isn't very common. But you could also create an alias if a procedure references a global variable and you pass that same global variable by reference to the procedure (this is a good example of yet one more reason why you should avoid referencing global variables in a procedure).<a class="indexterm" id="IDX-CHP-5-0046"/><a class="indexterm" id="IDX-CHP-5-0047"/></p><p>Pass by reference is usually less efficient than pass by value. You must dereference all pass-by-reference parameters on each access; this is slower than simply using a value because it typically requires at least two instructions. However, when passing a large data structure, pass by reference is faster because you do not have to copy the large data structure before calling the procedure. Of course, you'd probably need to access elements of that large data structure (for example, an array) using a pointer, so very little efficiency is lost when you pass large arrays by reference.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-6" id="ftn.CHP-5-FN-6">75</a>] </sup>Note to C/C++ programmers: HLA does not automatically pass arrays by reference. If you specify an array type as a formal parameter, HLA will emit code that makes a copy of each and every byte of that array when you call the associated procedure.</p></div></div></div>
<div class="sect1" title="5.7 Functions and Function Results"><div class="titlepage"><div><div><h1 class="title"><a id="functions_and_function_results"/>5.7 Functions and Function Results</h1></div></div></div><p>Functions are procedures that return some result to the caller. In assembly language, there are very few syntactical differences between a procedure and a function, which is why HLA doesn't provide a specific declaration for a function. Nevertheless, although there is very little <span class="emphasis"><em>syntactical</em></span> difference between assembly procedures and functions, there are some <span class="emphasis"><em>semantic</em></span> differences. That is, although you can declare them the same way in HLA, you use them differently.<a class="indexterm" id="IDX-CHP-5-0048"/></p><p>Procedures are a sequence of machine instructions that fulfill some task. The end result of the execution of a procedure is the accomplishment of that activity. Functions, on the other hand, execute a sequence of machine instructions specifically to compute some value to return to the caller. Of course, a function can perform some activity as well and procedures can undoubtedly compute some values, but the main difference is that the purpose of a function is to return some computed result; procedures don't have this requirement.</p><p>A good example of a procedure is the <code class="literal">stdout.puti32</code> procedure. This procedure requires a single <code class="literal">int32</code> parameter. The purpose of this procedure is to print the decimal conversion of this integer value to the standard output device. Note that <code class="literal">stdout.puti32</code> doesn't return any kind of value that is usable by the calling program.<a class="indexterm" id="IDX-CHP-5-0049"/></p><p>A good example of a function is the <code class="literal">cs.member</code> function. This function expects two parameters: The first is a character value and the second is a character set value. This function returns true (1) in EAX if the character is a member of the specified character set. It returns false if the character parameter is not a member of the character set.</p><p>Logically, the fact that <code class="literal">cs.member</code> returns a usable value to the calling code (in EAX) while <code class="literal">stdout.puti32</code> does not is a good example of the main difference between a function and a procedure. So, in general, a procedure becomes a function by virtue of the fact that you explicitly decide to return a value somewhere upon procedure return. No special syntax is needed to declare and use a function. You still write the code as a procedure.</p><div class="sect2" title="5.7.1 Returning Function Results"><div class="titlepage"><div><div><h2 class="title"><a id="returning_function_results"/>5.7.1 Returning Function Results</h2></div></div></div><p>The 80x86's registers are the most common place to return function results. The <code class="literal">cs.member</code> routine in the HLA Standard Library is a good example of a function that returns a value in one of the CPU's registers. It returns true (1) or false (0) in the EAX register. By convention, programmers try to return 8-, 16-, and 32-bit (nonreal) results in the AL, AX, and EAX registers, respectively.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-7" id="CHP-5-FN-7">76</a>]</sup> This is where most high-level languages return these types of results.</p><p>Of course, there is nothing particularly sacred about the AL/AX/EAX register. You could return function results in any register if it is more convenient to do so. However, if you don't have a good reason for not using AL/AX/EAX, then you should follow the convention. Doing so will help others understand your code better because they will generally assume that your functions return small results in the AL/AX/EAX register set.</p><p>If you need to return a function result that is larger than 32 bits, you obviously must return it somewhere other than in EAX (which can hold only 32-bit values). For values slightly larger than 32 bits (e.g., 64 bits or maybe even as many as 128 bits), you can split the result into pieces and return those parts in two or more registers. It is common to see programs returning 64-bit values in the EDX:EAX register pair (for example, the HLA Standard Library <code class="literal">stdin.geti64</code> function returns a 64-bit integer in the EDX:EAX register pair).<a class="indexterm" id="IDX-CHP-5-0050"/></p><p>If you need to return a large object as a function result, say an array of 1,000 elements, you obviously are not going to be able to return the function result in the registers. There are two common ways to deal with large function return results: Either pass the return value as a reference parameter or allocate storage on the heap (using <code class="literal">mem.alloc</code>) for the object and return a pointer to it in a 32-bit register. Of course, if you return a pointer to storage you've allocated on the heap, the calling program must free this storage when it has finished with it.</p></div><div class="sect2" title="5.7.2 Instruction Composition in HLA"><div class="titlepage"><div><div><h2 class="title"><a id="instruction_composition_in_hla"/>5.7.2 Instruction Composition in HLA</h2></div></div></div><p>Several HLA Standard Library functions allow you to call them as operands of other instructions. For example, consider the following code fragment:</p><a id="I_programlisting5_d1e23323"/><pre class="programlisting">if( cs.member( al, {'a'..'z'}) ) then
     .
     .
     .
endif;</pre><p>As your high-level language experience (and HLA experience) should suggest, this code calls the <code class="literal">cs.member</code> function to check to see if the character in AL is a lowercase alphabetic character. If the <code class="literal">cs.member</code> function returns true, then this code fragment executes the <code class="literal">then</code> section of the <code class="literal">if</code> statement; however, if <code class="literal">cs.member</code> returns false, this code fragment skips the <code class="literal">if..then</code> body. There is nothing spectacular here except for the fact that HLA doesn't support function calls as boolean expressions in the <code class="literal">if</code> statement (look back at <a class="xref" href="ch01.html" title="Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE">Chapter 1</a> to see the complete set of allowable expressions). How then, does this program compile and run, producing the intuitive results?</p><p>The next section describes how you can tell HLA that you want to use a function call in a boolean expression. However, to understand how this works, you need to first learn about <span class="emphasis"><em>instruction composition</em></span> in HLA.<a class="indexterm" id="IDX-CHP-5-0051"/></p><p>Instruction composition lets you use one instruction as the operand of another. For example, consider the <code class="literal">mov</code> instruction. It has two operands: a source operand and a destination operand. Instruction composition lets you substitute a valid 80x86 machine instruction for either (or both) operands. The following is a simple example:</p><a id="I_programlisting5_d1e23364"/><pre class="programlisting">mov( mov( 0, eax ), ebx );</pre><p>Of course, the immediate question is, "What does this mean?" To understand what is going on, you must first realize that most instructions "return" a value to the compiler while they are being compiled. For most instructions, the value they "return" is their destination operand. Therefore, <code class="literal">mov( 0, eax );</code> returns the string <code class="literal">eax</code> to the compiler during compilation because EAX is the destination operand. Most of the time, specifically when an instruction appears on a line by itself, the compiler ignores the returned string result. However, HLA uses this string result whenever you supply an instruction in place of some operand; specifically, HLA uses that string as the operand in place of the instruction. Therefore, the <code class="literal">mov</code> instruction above is equivalent to the following two-instruction sequence:</p><a id="I_programlisting5_d1e23377"/><pre class="programlisting">mov( 0, eax );     // HLA compiles interior instructions first.
     mov( eax, ebx );   // HLA substituted "eax" for "mov( 0, eax )"</pre><p>When processing composed instructions (that is, instruction sequences that have other instructions as operands), HLA always works in a "left-to-right then depth-first (inside-out)" manner. To make sense of this, consider the following instructions:</p><a id="I_programlisting5_d1e23381"/><pre class="programlisting">add( sub( mov( i, eax ), mov( j, ebx )), mov( k, ecx ));</pre><p>To interpret what is happening here, begin with the source operand. It consists of the following:</p><a id="I_programlisting5_d1e23386"/><pre class="programlisting">sub( mov( i, eax ), mov( j, ebx ))</pre><p>The source operand for this instruction is <code class="literal">mov( i, eax</code> ) and this instruction does not have any composition, so HLA emits this instruction and returns its destination operand (<code class="literal">eax</code>) for use as the source to the <code class="literal">sub</code> instruction. This effectively gives us the following:</p><a id="I_programlisting5_d1e23399"/><pre class="programlisting">sub( eax, mov( j, ebx ))</pre><p>Now HLA compiles the instruction that appears as the destination operand (<code class="literal">mov( j, ebx )</code>) and returns its destination operand (<code class="literal">ebx</code>) to substitute for this <code class="literal">mov</code> in the <code class="literal">sub</code> instruction. This yields the following:</p><a id="I_programlisting5_d1e23415"/><pre class="programlisting">sub( eax, ebx )</pre><p>This is a complete instruction, without composition, that HLA can compile. So it compiles this instruction and returns its destination operand (<code class="literal">ebx</code>) as the string result to substitute for the <code class="literal">sub</code> in the original <code class="literal">add</code> instruction. So the original <code class="literal">add</code> instruction now becomes</p><a id="I_programlisting5_d1e23431"/><pre class="programlisting">add( ebx, mov( k, ecx ));</pre><p>HLA next compiles the <code class="literal">mov</code> instruction appearing in the destination operand. It returns its destination operand as a string that HLA substitutes for the <code class="literal">mov</code>, finally yielding the simple instruction</p><a id="I_programlisting5_d1e23441"/><pre class="programlisting">add( ebx, ecx );</pre><p>The compilation of the original <code class="literal">add</code> instruction, therefore, yields the following instruction sequence:<a class="indexterm" id="IDX-CHP-5-0052"/></p><a id="I_programlisting5_d1e23454"/><pre class="programlisting">mov( i, eax );
     mov( j, ebx );
     sub( eax, ebx );
     mov( k, ecx );
     add( ebx, ecx );</pre><p>Whew! It's rather difficult to look at the original instruction and easily see that this sequence is the result. As you can see in this example, <span class="emphasis"><em>overzealous use of instruction composition can produce nearly unreadable programs</em></span>. You should be very careful about using instruction composition in your programs. With only a few exceptions, writing a composed instruction sequence makes your program harder to read.</p><p>Note that the excessive use of instruction composition may make errors in your program difficult to decipher. Consider the following HLA statement:</p><a id="I_programlisting5_d1e23463"/><pre class="programlisting">add( mov( eax, i ), mov( ebx, j ) );</pre><p>This instruction composition yields the following 80x86 instruction sequence:</p><a id="I_programlisting5_d1e23467"/><pre class="programlisting">mov( eax, i );
          mov( ebx, j );
          add( i, j );</pre><p>Of course, the compiler will complain that you're attempting to add one memory location to another. However, the instruction composition effectively masks this fact and makes it difficult to comprehend the cause of the error message. Moral of the story: Avoid using instruction composition unless it really makes your program easier to read. The few examples in this section demonstrate how <span class="emphasis"><em>not</em></span> to use instruction composition.</p><p>There are two main areas where using instruction composition can help make your programs more readable. The first is in HLA's high-level language control structures. The other is in procedure parameters. Although instruction composition is useful in these two cases (and probably a few others as well), this doesn't give you a license to use extremely convoluted instructions like the <code class="literal">add</code> instruction in the previous example. Instead, most of the time you will use a single instruction or a function call in place of a single operand in a high-level language boolean expression or in a procedure/function parameter.</p><p>While we're on the subject, exactly what does a procedure call return as the string that HLA substitutes for the call in an instruction composition? For that matter, what do statements like <code class="literal">if..endif</code> return? How about instructions that don't have a destination operand? Well, function return results are the subject of the next section, so you'll read about that in a few moments. As for all the other statements and instructions, you should check out the HLA reference manual. It lists each instruction and its returns value. The returns value is the string that HLA will substitute for the instruction when it appears as the operand to another instruction. Note that many HLA statements and instructions return the empty string as their returns value (by default, so do procedure calls). If an instruction returns the empty string as its composition value, then HLA will report an error if you attempt to use it as the operand of another instruction. For example, the <code class="literal">if..then..endif</code> statement returns the empty string as its returns value, so you may not bury an <code class="literal">if..then..endif</code> inside another instruction.<a class="indexterm" id="IDX-CHP-5-0053"/><a class="indexterm" id="IDX-CHP-5-0054"/><a class="indexterm" id="IDX-CHP-5-0055"/></p></div><div class="sect2" title="5.7.3 The HLA @returns Option in Procedures"><div class="titlepage"><div><div><h2 class="title"><a id="the_hla_at_the_rate_returns_option_in_pr"/>5.7.3 The HLA @returns Option in Procedures</h2></div></div></div><p>HLA procedure declarations allow a special option that specifies the string to use when a procedure invocation appears as the operand of another instruction: the <code class="literal">@returns</code> option. The syntax for a procedure declaration with the <code class="literal">@returns</code> option is as follows:</p><a id="I_programlisting5_d1e23516"/><pre class="programlisting">procedure <em class="replaceable"><code>ProcName</code></em> ( <em class="replaceable"><code>optional_parameters</code></em> );  @returns( <em class="replaceable"><code>string_constant</code></em> );
      &lt;&lt; Local declarations &gt;&gt;
 begin <em class="replaceable"><code>ProcName</code></em>;
      &lt;&lt; Procedure statements &gt;&gt;
 end <em class="replaceable"><code>ProcName</code></em>;</pre><p>If the <code class="literal">@returns</code> option is not present, HLA assigns the empty string to the <code class="literal">@returns</code> value for the procedure. This effectively makes it illegal to use that procedure invocation as the operand to another instruction.</p><p>The <code class="literal">@returns</code> option requires a single-string expression surrounded by parentheses. HLA will substitute this string constant for the procedure call if it ever appears as the operand of another instruction. Typically this string constant is a register name; however, any text that would be legal as an instruction operand is okay here. For example, you could specify memory addresses or constants. For purposes of clarity, you should always specify the location of a function's return value in the <code class="literal">@returns</code> parameter.</p><p>As an example, consider the following boolean function that returns true or false in the EAX register if the single-character parameter is an alphabetic character:<sup>[<a class="footnote" href="#ftn.CHP-5-FN-8" id="CHP-5-FN-8">77</a>]</sup></p><a id="I_programlisting5_d1e23557"/><pre class="programlisting">procedure IsAlphabeticChar( c:char ); @returns( "EAX" );
begin IsAlphabeticChar;

     // Note that cs.member returns true/false in eax.

     cs.member( c, {'a'..'z', 'A'..'Z'} );

end IsAlphabeticChar;</pre><p>Once you tack the <code class="literal">@returns</code> option on the end of this procedure declaration, you can legally use a call to <code class="literal">IsAlphabeticChar</code> as an operand to other HLA statements and instructions:</p><a id="I_programlisting5_d1e23567"/><pre class="programlisting">mov( IsAlphabeticChar( al ), ebx );
          .
          .
          .
     if( IsAlphabeticChar( ch ) ) then
          .
          .
          .
     endif;</pre><p>The last example above demonstrates that, via the <code class="literal">@returns</code> option, you can embed calls to your own functions in the boolean expression field of various HLA statements. Note that the code above is equivalent to:</p><a id="I_programlisting5_d1e23574"/><pre class="programlisting">IsAlphabeticChar( ch );
     if( eax ) then
          .
          .
          .
     endif;</pre><p>Not all HLA high-level language statements expand composed instructions before the statement. For example, consider the following <code class="literal">while</code> statement:</p><a id="I_programlisting5_d1e23582"/><pre class="programlisting">while( IsAlphabeticChar( ch ) ) do
          .
          .
          .
     endwhile;</pre><p>This code does not expand to the following:</p><a id="I_programlisting5_d1e23586"/><pre class="programlisting">IsAlphabeticChar( ch );
     while( eax ) do
          .
          .
          .
     endwhile;</pre><p>Instead, the call to <code class="literal">IsAlphabeticChar</code> expands inside the <code class="literal">while</code>'s boolean expression so that the program calls this function on each iteration of the loop.</p><p>You should exercise caution when entering the <code class="literal">@returns</code> parameter. HLA does not check the syntax of the string parameter when it is compiling the procedure declaration (other than to verify that it is a string constant). Instead, HLA checks the syntax when it replaces the function call with the <code class="literal">@returns</code> string. So if you had specified <code class="literal">eaz</code> instead of <code class="literal">eax</code> as the <code class="literal">@returns</code> parameter for <code class="literal">IsAlphabeticChar</code> in the previous examples, HLA would not have reported an error until you actually used <code class="literal">IsAlphabeticChar</code> as an operand. Then of course, HLA would complain about the illegal operand, and it's not at all clear what the problem is by looking at the <code class="literal">IsAlphabeticChar</code> invocation. So take special care not to introduce typographical errors into the <code class="literal">@returns</code> string; figuring out such errors later can be very difficult.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-7" id="ftn.CHP-5-FN-7">76</a>] </sup>In <a class="xref" href="ch06.html" title="Chapter 6. ARITHMETIC">Chapter 6</a> you'll see where most programmers return real results.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-8" id="ftn.CHP-5-FN-8">77</a>] </sup>Before you run off and actually use this function in your own programs, note that the HLA Standard Library provides the <code class="literal">char.isAlpha</code> function that provides this test. See the HLA documentation for more details.</p></div></div></div>
<div class="sect1" title="5.8 Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="recursion"/>5.8 Recursion</h1></div></div></div><p><span class="emphasis"><em>Recursion</em></span> occurs when a procedure calls itself. The following, for example, is a recursive procedure:<a class="indexterm" id="IDX-CHP-5-0056"/></p><a id="I_programlisting5_d1e23636"/><pre class="programlisting">procedure Recursive;
begin Recursive;

     Recursive();

end Recursive;</pre><p>Of course, the CPU will never return from this procedure. Upon entry into <code class="literal">Recursive</code>, this procedure will immediately call itself again, and control will never pass to the end of the procedure. In this particular case, runaway recursion results in an infinite loop.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-9" id="CHP-5-FN-9">78</a>]</sup></p><p>Like a looping structure, recursion requires a termination condition in order to stop infinite recursion. <code class="literal">Recursive</code> could be rewritten with a termination condition as follows:</p><a id="I_programlisting5_d1e23651"/><pre class="programlisting">procedure Recursive;
begin Recursive;

     dec( eax );
     if( @nz ) then

         Recursive();

     endif;

end Recursive;</pre><p>This modification to the routine causes <code class="literal">Recursive</code> to call itself the number of times appearing in the EAX register. On each call, <code class="literal">Recursive</code> decrements the EAX register by 1 and then calls itself again. Eventually, <code class="literal">Recursive</code> decrements EAX to 0 and returns from each call until it returns to the original caller.</p><p>So far, however, there hasn't been a real need for recursion. After all, you could efficiently code this procedure as follows:</p><a id="I_programlisting5_d1e23666"/><pre class="programlisting">procedure Recursive;
begin Recursive;

     repeat
          dec( eax );
     until( @z );

end Recursive;</pre><p>Both examples would repeat the body of the procedure the number of times passed in the EAX register.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-10" id="CHP-5-FN-10">79</a>]</sup> As it turns out, there are only a few recursive algorithms that you cannot implement in an iterative fashion. However, many recursively implemented algorithms are more efficient than their iterative counterparts, and most of the time the recursive form of the algorithm is much easier to understand.</p><p>The quicksort algorithm is probably the most famous algorithm that usually appears in recursive form. An HLA implementation of this algorithm appears in <a class="xref" href="ch05s08.html#recursive_quicksort_program" title="Example 5-9. Recursive quicksort program">Example 5-9</a>.<a class="indexterm" id="IDX-CHP-5-0057"/></p><div class="example"><a id="recursive_quicksort_program"/><p class="title">Example 5-9. Recursive quicksort program</p><div class="example-contents"><pre class="programlisting">program QSDemo;
#include( "stdlib.hhf" );

type
    ArrayType:  uns32[ 10 ];

static
    theArray:   ArrayType := [1,10,2,9,3,8,4,7,5,6];


    procedure quicksort( var a:ArrayType; Low:int32; High:int32 );
    const
        i:      text := "(type int32 edi)";
        j:      text := "(type int32 esi)";
        Middle: text := "(type uns32 edx)";
        ary:    text := "[ebx]";

    begin quicksort;

        push( eax );
        push( ebx );
        push( ecx );
        push( edx );
        push( esi );
        push( edi );

        mov( a, ebx );      // Load BASE address of "a" into ebx.

        mov( Low, edi);     // i := Low;
        mov( High, esi );   // j := High;

        // Compute a pivotal element by selecting the
        // physical middle element of the array.

        mov( i, eax );
        add( j, eax );
        shr( 1, eax );
        mov( ary[eax*4], Middle );  // Put middle value in edx.

        // Repeat until the edi and esi indexes cross one
        // another (edi works from the start towards the end
        // of the array, esi works from the end towards the
        // start of the array).

        repeat

            // Scan from the start of the array forward
            // looking for the first element greater or equal
            // to the middle element).

            while( Middle &gt; ary[i*4] ) do

                inc( i );

            endwhile;

            // Scan from the end of the array backwards looking
            // for the first element that is less than or equal
            // to the middle element.

            while( Middle &lt; ary[j*4] ) do

                dec( j );

            endwhile;

            // If we've stopped before the two pointers have
            // passed over one another, then we've got two
            // elements that are out of order with respect
            // to the middle element, so swap these two elements.

            if( i &lt;= j ) then

                mov( ary[i*4], eax );
                mov( ary[j*4], ecx );
                mov( eax, ary[j*4] );
                mov( ecx, ary[i*4] );
                inc( i );
                dec( j );

            endif;

        until( i &gt; j );

        // We have just placed all elements in the array in
        // their correct positions with respect to the middle
        // element of the array. So all elements at indexes
        // greater than the middle element are also numerically
        // greater than this element. Likewise, elements at
        // indexes less than the middle (pivotal) element are
        // now less than that element. Unfortunately, the
        // two halves of the array on either side of the pivotal
        // element are not yet sorted. Call quicksort recursively
        // to sort these two halves if they have more than one
        // element in them (if they have zero or one elements, then
        // they are already sorted).

        if( Low &lt; j ) then

            quicksort( a, Low, j );

        endif;
        if( i &lt; High ) then

quicksort( a, i, High );

        endif;

        pop( edi );
        pop( esi );
        pop( edx );
        pop( ecx );
        pop( ebx );
        pop( eax );

    end quicksort;

begin QSDemo;

    stdout.put( "Data before sorting: " nl );
    for( mov( 0, ebx ); ebx &lt; 10; inc( ebx )) do

        stdout.put( theArray[ebx*4]:5 );

    endfor;
    stdout.newln();

    quicksort( theArray, 0, 9 );

    stdout.put( "Data after sorting: " nl );
    for( mov( 0, ebx ); ebx &lt; 10; inc( ebx )) do

        stdout.put( theArray[ebx*4]:5 );

    endfor;
    stdout.newln();

end QSDemo;</pre></div></div><p>Note that this quicksort procedure uses registers for all nonparameter local variables. Also note how quicksort uses <code class="literal">text</code> constant definitions to provide more readable names for the registers. This technique can often make an algorithm easier to read; however, one must take care when using this trick not to forget that those registers are being used.<a class="indexterm" id="IDX-CHP-5-0058"/><a class="indexterm" id="IDX-CHP-5-0059"/><a class="indexterm" id="IDX-CHP-5-0060"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-9" id="ftn.CHP-5-FN-9">78</a>] </sup>Well, not really infinite. The stack will overflow and Windows, Mac OS X, FreeBSD, or Linux will raise an exception at that point.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-10" id="ftn.CHP-5-FN-10">79</a>] </sup>The latter version will do it considerably faster because it doesn't have the overhead of the <code class="literal">call</code>/<code class="literal">ret</code> instructions.</p></div></div></div>
<div class="sect1" title="5.9 Forward Procedures"><div class="titlepage"><div><div><h1 class="title"><a id="forward_procedures"/>5.9 Forward Procedures</h1></div></div></div><p>As a general rule, HLA requires that you declare all symbols before their first use in a program.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-11" id="CHP-5-FN-11">80</a>]</sup> Therefore, you must define all procedures before their first call. There are two reasons this isn't always practical: mutual recursion (two procedures call each other) and source code organization (you prefer to place a procedure in your code after the point where you've first called it). Fortunately, HLA lets you use a <span class="emphasis"><em>forward procedure definition</em></span> to declare a procedure <span class="emphasis"><em>prototype</em></span>. Forward declarations let you define a procedure before you actually supply the code for that procedure.<a class="indexterm" id="IDX-CHP-5-0061"/></p><p>A forward procedure declaration is a familiar procedure declaration that uses the reserved word <code class="literal">forward</code> in place of the procedure's declaration section and body. The following is a forward declaration for the quicksort procedure appearing in the last section:</p><a id="I_programlisting5_d1e23733"/><pre class="programlisting">procedure quicksort( var a:ArrayType; Low:int32; High:int32 ); forward;</pre><p>A forward declaration in an HLA program is a promise to the compiler that the actual procedure declaration will appear, exactly as stated in the forward declaration, at a later point in the source code.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-12" id="CHP-5-FN-12">81</a>]</sup> The forward declaration must have the same parameters, they must be passed the same way, and they must all have the same types as the formal parameters in the procedure.</p><p>Routines that are mutually recursive (that is, procedure <code class="literal">A</code> calls procedure <code class="literal">B</code> and procedure <code class="literal">B</code> calls procedure <code class="literal">A</code>) require at least one forward declaration, because you may declare only one of procedure <code class="literal">A</code> or <code class="literal">B</code> before the other. In practice, however, mutual recursion (direct or indirect) doesn't occur very frequently, so you'll rarely forward declarations for this purpose.</p><p>In the absence of mutual recursion, it is always possible to organize your source code so that each procedure declaration appears before its first invocation. What's possible and what's desired are two different things, however. You might want to group a related set of procedures at the beginning of your source code and a different set of procedures toward the end of your source code. This logical grouping, by function rather than by invocation, may make your programs much easier to read and understand. However, this organization may also yield code that attempts to call a procedure before its declaration. No sweat; just use a forward procedure definition to resolve the problem.<a class="indexterm" id="IDX-CHP-5-0062"/><a class="indexterm" id="IDX-CHP-5-0063"/><a class="indexterm" id="IDX-CHP-5-0064"/></p><p>One major difference between the forward definition and the actual procedure declaration has to do with the procedure options. Some options, like <code class="literal">@returns</code>, may appear only in the forward declaration (if a <code class="literal">forward</code> declaration is present). Other options may appear only in the actual procedure declaration (we haven't covered any of the other procedure options, so don't worry about them just yet). If your procedure requires an <code class="literal">@returns</code> option, the <code class="literal">@returns</code> option must appear before the <code class="literal">forward</code> reserved word. For example:</p><a id="I_programlisting5_d1e23793"/><pre class="programlisting">procedure IsItReady( valueToTest: dword ); @returns( "eax" ); forward;</pre><p>The <code class="literal">@returns</code> option must not also appear in the actual procedure declaration later in your source file.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-11" id="ftn.CHP-5-FN-11">80</a>] </sup>There are a few minor exceptions to this rule, but it is certainly true for procedure calls.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-12" id="ftn.CHP-5-FN-12">81</a>] </sup>Actually, <code class="literal">exactly</code> is too strong a word. You will see some exceptions in a moment.</p></div></div></div>
<div class="sect1" title="5.10 HLA v2.0 Procedure Declarations"><div class="titlepage"><div><div><h1 class="title"><a id="hla_v2.0_procedure_declarations"/>5.10 HLA v2.0 Procedure Declarations</h1></div></div></div><p>HLA v2.0 and later support an alternate procedure declaration syntax that is similar to constant, type, and variable declarations. Though this book tends to prefer the original procedure declaration syntax (which HLA v2.0 and later still support), you will see examples of the new syntax in code that exists out in the real world; therefore, this section provides a brief discussion of the new procedure declaration syntax.</p><p>The new HLA v2.0 procedure declaration syntax uses the <code class="literal">proc</code> keyword to begin a procedure declaration section (similar to <code class="literal">var</code> or <code class="literal">static</code> beginning a variable declaration section). Within a <code class="literal">proc</code> section, procedure declarations take one of these forms:</p><a id="I_programlisting5_d1e23819"/><pre class="programlisting"><em class="replaceable"><code>procname</code></em>:procedure( <em class="replaceable"><code>parameters</code></em> );
begin <em class="replaceable"><code>procname</code></em>;
    &lt;&lt; body &gt;&gt;
end <em class="replaceable"><code>procname</code></em>;
<em class="replaceable"><code>procname</code></em>:procedure( <em class="replaceable"><code>parameters</code></em> ) {<em class="replaceable"><code>options</code></em>};
begin <em class="replaceable"><code>procname</code></em>;
    &lt;&lt; body &gt;&gt;
end <em class="replaceable"><code>procname</code></em>;
<em class="replaceable"><code>procname</code></em>:procedure( <em class="replaceable"><code>parameters</code></em> ); <em class="replaceable"><code>external</code></em>;
<em class="replaceable"><code>procname</code></em>:procedure( <em class="replaceable"><code>parameters</code></em> ) { <em class="replaceable"><code>options</code></em> }; <em class="replaceable"><code>external</code></em>;</pre><p>Please see the HLA v2.0 (or later) reference manual for more details concerning this alternate procedure declaration syntax. Just be aware of its existence in case you come across it while reading example HLA code you've gotten from some other source.<a class="indexterm" id="IDX-CHP-5-0065"/><a class="indexterm" id="IDX-CHP-5-0066"/><a class="indexterm" id="IDX-CHP-5-0067"/><a class="indexterm" id="IDX-CHP-5-0068"/><a class="indexterm" id="IDX-CHP-5-0069"/><a class="indexterm" id="IDX-CHP-5-0070"/><a class="indexterm" id="IDX-CHP-5-0071"/><a class="indexterm" id="IDX-CHP-5-0072"/><a class="indexterm" id="IDX-CHP-5-0073"/><a class="indexterm" id="IDX-CHP-5-0074"/><a class="indexterm" id="IDX-CHP-5-0075"/><a class="indexterm" id="IDX-CHP-5-0076"/></p></div>
<div class="sect1" title="5.11 Low-Level Procedures and the call Instruction"><div class="titlepage"><div><div><h1 class="title"><a id="low-level_procedures_and_the_call_instru"/>5.11 Low-Level Procedures and the call Instruction</h1></div></div></div><p>The 80x86 <code class="literal">call</code> instruction does two things. First, it pushes the address of the instruction immediately following the <code class="literal">call</code> onto the stack; then it transfers control to the address of the specified procedure. The value that <code class="literal">call</code> pushes onto the stack is known as the <span class="emphasis"><em>return address</em></span>. When the procedure wants to return to the caller and continue execution with the first statement following the <code class="literal">call</code> instruction, the procedure simply pops the return address off the stack and jumps (indirectly) to that address. Most procedures return to their caller by executing a <code class="literal">ret</code> (return) instruction. The <code class="literal">ret</code> instruction pops a return address off the stack and transfers control indirectly to the address it pops off the stack.<a class="indexterm" id="IDX-CHP-5-0077"/></p><p>By default, the HLA compiler automatically places a <code class="literal">ret</code> instruction (along with a few other instructions) at the end of each HLA procedure you write. This is why you haven't had to explicitly use the <code class="literal">ret</code> instruction up to this point. To disable the default code generation in an HLA procedure, specify the following options when declaring your procedures:</p><a id="I_programlisting5_d1e23967"/><pre class="programlisting">procedure <em class="replaceable"><code>ProcName</code></em>; @noframe; @nodisplay;
begin <em class="replaceable"><code>ProcName</code></em>;
     .
     .
     .
end <em class="replaceable"><code>ProcName</code></em>;</pre><p>The <code class="literal">@noframe</code> and <code class="literal">@nodisplay</code> clauses are examples of procedure <span class="emphasis"><em>options</em></span>. HLA procedures support several such options, including <code class="literal">@returns</code>, <code class="literal">@noframe</code>, <code class="literal">@nodisplay</code>, and <code class="literal">@noalignstack</code>. You'll see the purpose of <code class="literal">@noalignstack</code> and a couple of other procedure options in Section 5.14. These procedure options may appear in any order following the procedure name (and parameters, if any). Note that <code class="literal">@noframe</code> and <code class="literal">@nodisplay</code> (as well as <code class="literal">@noalignstack</code>) may appear only in an actual procedure declaration. You cannot specify these options in a forward declaration.</p><p>The <code class="literal">@noframe</code> option tells HLA that you don't want the compiler to automatically generate entry and exit code for the procedure. This tells HLA not to automatically generate the <code class="literal">ret</code> instruction (along with several other instructions).</p><p>The <code class="literal">@nodisplay</code> option tells HLA that it should not allocate storage in procedure's local variable area for a <span class="emphasis"><em>display</em></span>. The display is a mechanism you use to access nonlocal <code class="literal">var</code> objects in a procedure. Therefore, a display is necessary only if you nest procedures in your programs. This book will not consider the display or nested procedures; for more details on the display and nested procedures see the appropriate chapter in the electronic edition appearing at <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> or <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>, or check out the HLA reference manual. Until then, you can safely specify the <code class="literal">@nodisplay</code> option on all your procedures. Indeed, for all of the procedures appearing in this chapter up to this point, specifying the <code class="literal">@nodisplay</code> option makes a lot of sense because none of those procedures actually use the display. Procedures that have the <code class="literal">@nodisplay</code> option are a tiny bit faster and a tiny bit shorter than those procedures that do not specify this option.<a class="indexterm" id="IDX-CHP-5-0078"/><a class="indexterm" id="IDX-CHP-5-0079"/></p><p>The following is an example of the minimal procedure:</p><a id="I_programlisting5_d1e24055"/><pre class="programlisting">procedure minimal; @nodisplay; @noframe; @noalignstack;
begin minimal;

     ret();

end minimal;</pre><p>If you call this procedure with the <code class="literal">call</code> instruction, <code class="literal">minimal</code> will simply pop the return address off the stack and return back to the caller. You should note that a <code class="literal">ret</code> instruction is absolutely necessary when you specify the <code class="literal">@noframe</code> procedure option.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-13" id="CHP-5-FN-13">82</a>]</sup> If you fail to put the <code class="literal">ret</code> instruction in the procedure, the program will not return to the caller upon encountering the <code class="literal">end minimal;</code> statement. Instead, the program will fall through to whatever code happens to follow the procedure in memory. The example program in <a class="xref" href="ch05s11.html#effect_of_a_missing_ret_instruction_in_a" title="Example 5-10. Effect of a missing ret instruction in a procedure">Example 5-10</a> demonstrates this problem.</p><div class="example"><a id="effect_of_a_missing_ret_instruction_in_a"/><p class="title">Example 5-10. Effect of a missing <code class="literal">ret</code> instruction in a procedure</p><div class="example-contents"><pre class="programlisting">program missingRET;
#include( "stdlib.hhf" );

    // This first procedure has the @noframe
    // option but does not have a ret instruction.

    procedure firstProc; @noframe; @nodisplay;
    begin firstProc;

        stdout.put( "Inside firstProc" nl );

    end firstProc;


    // Because the procedure above does not have a
    // ret instruction, it will "fall through" to
    // the following instruction. Note that there
    // is no call to this procedure anywhere in
    // this program.

    procedure secondProc; @noframe; @nodisplay;
    begin secondProc;

        stdout.put( "Inside secondProc" nl );
        ret();

end secondProc;


begin missingRET;

    // Call the procedure that doesn't have
    // a ret instruction.

    call firstProc;

end missingRET;</pre></div></div><p>Although this behavior might be desirable in certain rare circumstances, it usually represents a defect in most programs. Therefore, if you specify the <code class="literal">@noframe</code> option, always remember to explicitly return from the procedure using the <code class="literal">ret</code> instruction.<a class="indexterm" id="IDX-CHP-5-0080"/><a class="indexterm" id="IDX-CHP-5-0081"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-13" id="ftn.CHP-5-FN-13">82</a>] </sup>Strictly speaking, this isn't true. But some mechanism that pops the return address off the stack and jumps to the return address is necessary in the procedure's body.</p></div></div></div>
<div class="sect1" title="5.12 Procedures and the Stack"><div class="titlepage"><div><div><h1 class="title"><a id="procedures_and_the_stack"/>5.12 Procedures and the Stack</h1></div></div></div><p>Because procedures use the stack to hold the return address, you must exercise caution when pushing and popping data within a procedure. Consider the following simple (and defective) procedure:</p><a id="I_programlisting5_d1e24114"/><pre class="programlisting">procedure MessedUp; @noframe; @nodisplay;
begin MessedUp;

     push( eax );
     ret();

end MessedUp;</pre><p>At the point the program encounters the <code class="literal">ret</code> instruction, the 80x86 stack takes the form shown in <a class="xref" href="ch05s12.html#stack_contents_before_ret_in_messedup_pr" title="Figure 5-1. Stack contents before ret in MessedUp procedure">Figure 5-1</a>.</p><div class="figure"><a id="stack_contents_before_ret_in_messedup_pr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24132"/><img alt="Stack contents before ret in MessedUp procedure" src="tagoreillycom20100401nostarchimages578001.png"/></div></div><p class="title">Figure 5-1. Stack contents before <code class="literal">ret</code> in <code class="literal">MessedUp</code> procedure</p></div><p>The <code class="literal">ret</code> instruction isn't aware that the value on the top of stack is not a valid address. It simply pops whatever value is on the top of the stack and jumps to that location. In this example, the top of stack contains the saved EAX value. Because it is very unlikely that EAX contains the proper return address (indeed, there is about a one in four billion chance it is correct), this program will probably crash or exhibit some other undefined behavior. Therefore, you must take care when pushing data onto the stack within a procedure that you properly pop that data prior to returning from the procedure.<a class="indexterm" id="IDX-CHP-5-0082"/><a class="indexterm" id="IDX-CHP-5-0083"/><a class="indexterm" id="IDX-CHP-5-0084"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you do not specify the <code class="literal">@noframe</code> option when writing a procedure, HLA automatically generates code at the beginning of the procedure that pushes some data onto the stack. Therefore, unless you understand exactly what is going on and you've taken care of this data HLA pushes on the stack, you should never execute the bare <code class="literal">ret</code> instruction inside a procedure that does not have the <code class="literal">@noframe</code> option. Doing so will attempt to return to the location specified by this data (which is not a return address) rather than properly returning to the caller. In procedures that do not have the <code class="literal">@noframe</code> option, use the <code class="literal">exit</code> or <code class="literal">exitif</code> statement to return from the procedure.</p></div><p>Popping extra data off the stack prior to executing the <code class="literal">ret</code> statement can also create havoc in your programs. Consider the following defective procedure:</p><a id="I_programlisting5_d1e24184"/><pre class="programlisting">procedure messedUpToo; @noframe; @nodisplay;
begin messedUpToo;

     pop( eax );
     ret();

end messedUpToo;</pre><p>Upon reaching the <code class="literal">ret</code> instruction in this procedure, the 80x86 stack looks something like that shown in <a class="xref" href="ch05s12.html#stack_contents_before_ret_in_messeduptoo" title="Figure 5-2. Stack contents before ret in messedUpToo">Figure 5-2</a>.</p><div class="figure"><a id="stack_contents_before_ret_in_messeduptoo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24201"/><img alt="Stack contents before ret in messedUpToo" src="tagoreillycom20100401nostarchimages578003.png"/></div></div><p class="title">Figure 5-2. Stack contents before <code class="literal">ret</code> in <code class="literal">messedUpToo</code></p></div><p>Once again, the <code class="literal">ret</code> instruction blindly pops whatever data happens to be on the top of the stack and attempts to return to that address. Unlike the previous example, where it was very unlikely that the top of stack contained a valid return address (because it contained the value in EAX), there is a small possibility that the top of stack in this example actually <span class="emphasis"><em>does</em></span> contain a return address. However, this will not be the proper return address for the <code class="literal">messedUpToo</code> procedure; instead, it will be the return address for the procedure that called <code class="literal">messedUpToo</code>. To understand the effect of this code, consider the program in <a class="xref" href="ch05s12.html#effect_of_popping_too_much_data_off_the" title="Example 5-11. Effect of popping too much data off the stack">Example 5-11</a>.</p><div class="example"><a id="effect_of_popping_too_much_data_off_the"/><p class="title">Example 5-11. Effect of popping too much data off the stack</p><div class="example-contents"><pre class="programlisting">program extraPop;
#include( "stdlib.hhf" );


    // Note that the following procedure pops
    // excess data off the stack (in this case,
    // it pops messedUpToo's return address).

    procedure messedUpToo; @noframe; @nodisplay;
    begin messedUpToo;

        stdout.put( "Entered messedUpToo" nl );
        pop( eax );
        ret();

    end messedUpToo;



    procedure callsMU2; @noframe; @nodisplay;
    begin callsMU2;

        stdout.put( "calling messedUpToo" nl );
        messedUpToo();

        // Because messedUpToo pops extra data
        // off the stack, the following code
        // never executes (because the data popped
        // off the stack is the return address that
        // points at the following code).

        stdout.put( "Returned from messedUpToo" nl );
        ret();

    end callsMU2;


begin extraPop;

    stdout.put( "Calling callsMU2" nl );
    callsMU2();
    stdout.put( "Returned from callsMU2" nl );

end extraPop;</pre></div></div><p>Because a valid return address is sitting on the top of the stack, you might think that this program will actually work (properly). However, note that when returning from the <code class="literal">messedUpToo</code> procedure, this code returns directly to the main program rather than to the proper return address in the <code class="literal">callsMU2</code> procedure. Therefore, all code in the <code class="literal">callsMU2</code> procedure that follows the call to <code class="literal">messedUpToo</code> does not execute. When reading the source code, it may be very difficult to figure out why those statements are not executing because they immediately follow the call to the <code class="literal">messedUpToo</code> procedure. It isn't clear, unless you look very closely, that the program is popping an extra return address off the stack and therefore doesn't return to <code class="literal">callsMU2</code> but rather returns directly to whoever calls <code class="literal">callsMU2</code>. Of course, in this example it's fairly easy to see what is going on (because this example is a demonstration of this problem). In real programs, however, determining that a procedure has accidentally popped too much data off the stack can be much more difficult. Therefore, you should always be careful about pushing and popping data in a procedure. You should always verify that there is a one-to-one relationship between the pushes in your procedures and the corresponding pops.<a class="indexterm" id="IDX-CHP-5-0085"/></p></div>
<div class="sect1" title="5.13 Activation Records"><div class="titlepage"><div><div><h1 class="title"><a id="activation_records"/>5.13 Activation Records</h1></div></div></div><p>Whenever you call a procedure, there is certain information the program associates with that procedure call. The return address is a good example of some information the program maintains for a specific procedure call. Parameters and automatic local variables (that is, those you declare in the <code class="literal">var</code> section) are additional examples of information the program maintains for each procedure call. <span class="emphasis"><em>Activation record</em></span> is the term we'll use to describe the information the program associates with a specific call to a procedure.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-14" id="CHP-5-FN-14">83</a>]</sup><a class="indexterm" id="IDX-CHP-5-0086"/></p><p>Activation record is an appropriate name for this data structure. The program creates an activation record when calling (activating) a procedure and the data in the structure is organized in a manner identical to records. Perhaps the only thing unusual about an activation record (when comparing it to a standard record) is that the base address of the record is in the middle of the data structure, so you must access fields of the record at positive and negative offsets.<a class="indexterm" id="IDX-CHP-5-0087"/><a class="indexterm" id="IDX-CHP-5-0088"/></p><p>Construction of an activation record begins in the code that calls a procedure. The caller pushes the parameter data (if any) onto the stack. Then the execution of the <code class="literal">call</code> instruction pushes the return address onto the stack. At this point, construction of the activation record continues within the procedure itself. The procedure pushes registers and other important state information and then makes room in the activation record for local variables. The procedure must also update the EBP register so that it points at the base address of the activation record.<a class="indexterm" id="IDX-CHP-5-0089"/></p><p>To see what a typical activation record looks like, consider the following HLA procedure declaration:</p><a id="I_programlisting5_d1e24296"/><pre class="programlisting">procedure ARDemo( i:uns32; j:int32; k:dword ); @nodisplay;
var
     a:int32;
     r:real32;
     c:char;
     b:boolean;
     w:word;
begin ARDemo;
     .
     .
     .
end ARDemo;</pre><p>Whenever an HLA program calls this <code class="literal">ARDemo</code> procedure, it begins by pushing the data for the parameters onto the stack. The calling code will push the parameters onto the stack in the order they appear in the parameter list, from left to right. Therefore, the calling code first pushes the value for the <code class="literal">i</code> parameter, then it pushes the value for the <code class="literal">j</code> parameter, and it finally pushes the data for the <code class="literal">k</code> parameter. After pushing the parameters, the program calls the <code class="literal">ARDemo</code> procedure. Immediately upon entry into the <code class="literal">ARDemo</code> procedure, the stack contains these four items arranged as shown in <a class="xref" href="ch05s13.html#stack_organization_immediately_upon_entr" title="Figure 5-3. Stack organization immediately upon entry into ARDemo">Figure 5-3</a>.</p><p>The first few instructions in <code class="literal">ARDemo</code> (note that it does not have the <code class="literal">@noframe</code> option) will push the current value of EBP onto the stack and then copy the value of ESP into EBP. Next, the code drops the stack pointer down in memory to make room for the local variables. This produces the stack organization shown in <a class="xref" href="ch05s13.html#activation_record_for_ardemo" title="Figure 5-4. Activation record for ARDemo">Figure 5-4</a>.</p><div class="figure"><a id="stack_organization_immediately_upon_entr"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24336"/><img alt="Stack organization immediately upon entry into ARDemo" src="tagoreillycom20100401nostarchimages578005.png"/></div></div><p class="title">Figure 5-3. Stack organization immediately upon entry into <code class="literal">ARDemo</code></p></div><div class="figure"><a id="activation_record_for_ardemo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24346"/><img alt="Activation record for ARDemo" src="tagoreillycom20100401nostarchimages578007.png"/></div></div><p class="title">Figure 5-4. Activation record for <code class="literal">ARDemo</code></p></div><p>To access objects in the activation record you must use offsets from the EBP register to the desired object. The two items of immediate interest to you are the parameters and the local variables. You can access the parameters at positive offsets from the EBP register; you can access the local variables at negative offsets from the EBP register, as <a class="xref" href="ch05s13.html#offsets_of_objects_in_the_ardemo_activat" title="Figure 5-5. Offsets of objects in the ARDemo activation record">Figure 5-5</a> shows.<a class="indexterm" id="IDX-CHP-5-0090"/></p><p>Intel specifically reserves the EBP (Extended Base Pointer) register for use as a pointer to the base of the activation record. This is why you should never use the EBP register for general calculations. If you arbitrarily change the value in the EBP register, you will lose access to the current procedure's parameters and local variables.</p><div class="figure"><a id="offsets_of_objects_in_the_ardemo_activat"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24367"/><img alt="Offsets of objects in the ARDemo activation record" src="tagoreillycom20100401nostarchimages578009.png.jpg"/></div></div><p class="title">Figure 5-5. Offsets of objects in the <code class="literal">ARDemo</code> activation record</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-14" id="ftn.CHP-5-FN-14">83</a>] </sup><span class="emphasis"><em>Stack frame</em></span> is another term many people use to describe the activation record.</p></div></div></div>
<div class="sect1" title="5.14 The Standard Entry Sequence"><div class="titlepage"><div><div><h1 class="title"><a id="the_standard_entry_sequence"/>5.14 The Standard Entry Sequence</h1></div></div></div><p>The caller of a procedure is responsible for pushing the parameters onto the stack. Of course, the <code class="literal">call</code> instruction pushes the return address onto the stack. It is the procedure's responsibility to construct the rest of the activation record. You can accomplish this by using the following "standard entry sequence" code:<a class="indexterm" id="IDX-CHP-5-0091"/></p><a id="I_programlisting5_d1e24383"/><pre class="programlisting">push( ebp );         // Save a copy of the old ebp value.
 mov( esp, ebp );     // Get pointer to base of activation record into ebp.
 sub( <em class="replaceable"><code>NumVars</code></em>, esp ); // Allocate storage for local variables.</pre><p>If the procedure doesn't have any local variables, the third instruction above, <code class="literal">sub(</code> <em class="replaceable"><code>NumVars</code></em><code class="literal">, esp );</code>, isn't necessary. <em class="replaceable"><code>NumVars</code></em> represents the number of <span class="emphasis"><em>bytes</em></span> of local variables needed by the procedure. This is a constant that should be a multiple of 4 (so the ESP register remains aligned on a double-word boundary). If the number of bytes of local variables in the procedure is not a multiple of 4, you should round the value up to the next higher multiple of 4 before subtracting this constant from ESP. Doing so will slightly increase the amount of storage the procedure uses for local variables but will not otherwise affect the operation of the procedure.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>If the <code class="literal">NumVars</code> constant is not a multiple of 4, subtracting this value from ESP (which, presumably, contains a double-word-aligned pointer) will virtually guarantee that all future stack accesses are misaligned because the program almost always pushes and pops double-word values. This will have a very negative performance impact on the program. Worse still, many OS API calls will fail if the stack is not double-word aligned upon entry into the operating system. Therefore, you must always ensure that your local variable allocation value is a multiple of 4.</p></div><p>Because of the problems with a misaligned stack, by default HLA will also emit a fourth instruction as part of the standard entry sequence. The HLA compiler actually emits the following standard entry sequence for the <code class="literal">ARDemo</code> procedure defined earlier:<a class="indexterm" id="IDX-CHP-5-0092"/><a class="indexterm" id="IDX-CHP-5-0093"/><a class="indexterm" id="IDX-CHP-5-0094"/></p><a id="I_programlisting5_d1e24430"/><pre class="programlisting">push( ebp );
          mov( esp, ebp );
          sub( 12, esp );          // Make room for ARDemo's local variables.
          and( $FFFF_FFFC, esp );  // Force dword stack alignment.</pre><p>The <code class="literal">and</code> instruction at the end of this sequence forces the stack to be aligned on a 4-byte boundary (it reduces the value in the stack pointer by 1, 2, or 3 if the value in ESP is not a multiple of 4). Although the <code class="literal">ARDemo</code> entry code correctly subtracts 12 from ESP for the local variables (12 is both a multiple of 4 and the number of bytes of local variables), this leaves ESP double-word aligned only if it was double-word aligned immediately upon entry into the procedure. Had the caller messed with the stack and left ESP containing a value that was not a multiple of 4, subtracting 12 from ESP would leave ESP containing an unaligned value. The <code class="literal">and</code> instruction in the sequence above, however, guarantees that ESP is dword aligned regardless of ESP's value upon entry into the procedure. The few bytes and CPU cycles needed to execute this instruction would pay off handsomely if ESP was not double-word aligned.</p><p>Although it is always safe to execute the <code class="literal">and</code> instruction in the standard entry sequence, it might not be necessary. If you always ensure that ESP contains a double-word-aligned value, the <code class="literal">and</code> instruction in the standard entry sequence above is unnecessary. Therefore, if you've specified the <code class="literal">@noframe</code> procedure option, you don't have to include that instruction as part of the entry sequence.</p><p>If you haven't specified the <code class="literal">@noframe</code> option (that is, you're letting HLA emit the instructions to construct the standard entry sequence for you), you can still tell HLA not to emit the extra <code class="literal">and</code> instruction if you're sure the stack will be double-word aligned whenever someone calls the procedure. To do this, use the <code class="literal">@noalignstack</code> procedure option. For example:</p><a id="I_programlisting5_d1e24465"/><pre class="programlisting">procedure NASDemo( i:uns32; j:int32; k:dword ); @noalignstack;
var
     LocalVar:int32;
begin NASDemo;
     .
     .
     .
end NASDemo;</pre><p>HLA emits the following entry sequence for the procedure above:</p><a id="I_programlisting5_d1e24470"/><pre class="programlisting">push( ebp );
          mov( esp, ebp );
          sub( 4, esp );</pre></div>
<div class="sect1" title="5.15 The Standard Exit Sequence"><div class="titlepage"><div><div><h1 class="title"><a id="the_standard_exit_sequence"/>5.15 The Standard Exit Sequence</h1></div></div></div><p>Before a procedure returns to its caller, it needs to clean up the activation record. Although it is possible to share the cleanup duties between the procedure and the procedure's caller, Intel has included some features in the instruction set that allows the procedure to efficiently handle all the cleanup chores itself. Standard HLA procedures and procedure calls, therefore, assume that it is the procedure's responsibility to clean up the activation record (including the parameters) when the procedure returns to its caller.<a class="indexterm" id="IDX-CHP-5-0095"/></p><p>If a procedure does not have any parameters, the exit sequence is very simple. It requires only three instructions:</p><a id="I_programlisting5_d1e24482"/><pre class="programlisting">mov( ebp, esp );    // Deallocate locals and clean up stack.
pop( ebp );         // Restore pointer to caller's activation record.
ret();              // Return to the caller.</pre><p>If the procedure has some parameters, then a slight modification to the standard exit sequence is necessary in order to remove the parameter data from the stack. Procedures with parameters use the following standard exit sequence:</p><a id="I_programlisting5_d1e24486"/><pre class="programlisting">mov( ebp, esp );    // Deallocate locals and clean up stack.
pop( ebp );         // Restore pointer to caller's activation record.
ret( <em class="replaceable"><code>ParmBytes</code></em> );   // Return to the caller and pop the parameters.</pre><p>The <em class="replaceable"><code>ParmBytes</code></em> operand of the <code class="literal">ret</code> instruction is a constant that specifies the number of bytes of parameter data to remove from the stack after the return instruction pops the return address. For example, the <code class="literal">ARDemo</code> example code in the previous sections has three double-word parameters. Therefore, the standard exit sequence would take the following form:</p><a id="I_programlisting5_d1e24502"/><pre class="programlisting">mov( ebp, esp );
pop( ebp );
ret( 12 );</pre><p>If you've declared your parameters using HLA syntax (that is, a parameter list follows the procedure declaration), then HLA automatically creates a local constant in the procedure, <code class="literal">_parms_</code>, that is equal to the number of bytes of parameters in that procedure. Therefore, rather than counting the number of parameter bytes yourself, you can use the following standard exit sequence for any procedure that has parameters:</p><a id="I_programlisting5_d1e24509"/><pre class="programlisting">mov( ebp, esp );
pop( ebp );
ret( _parms_ );</pre><p>Note that if you do not specify a byte constant operand to the <code class="literal">ret</code> instruction, the 80x86 will not pop the parameters off the stack upon return. Those parameters will still be sitting on the stack when you execute the first instruction following the <code class="literal">call</code> to the procedure. Similarly, if you specify a value that is too small, some of the parameters will be left on the stack upon return from the procedure. If the <code class="literal">ret</code> operand you specify is too large, the <code class="literal">ret</code> instruction will actually pop some of the caller's data off the stack, usually with disastrous consequences.<a class="indexterm" id="IDX-CHP-5-0096"/><a class="indexterm" id="IDX-CHP-5-0097"/></p><p>If you wish to return early from a procedure that doesn't have the <code class="literal">@noframe</code> option, and you don't particularly want to use the <code class="literal">exit</code> or <code class="literal">exitif</code> statement, you must execute the standard exit sequence to return to the caller. A simple <code class="literal">ret</code> instruction is insufficient because local variables and the old EBP value are probably sitting on the top of the stack.<a class="indexterm" id="IDX-CHP-5-0098"/></p></div>
<div class="sect1" title="5.16 Low-Level Implementation of Automatic (Local) Variables"><div class="titlepage"><div><div><h1 class="title"><a id="low-level_implementation_of_automatic_op"/>5.16 Low-Level Implementation of Automatic (Local) Variables</h1></div></div></div><p>Your program accesses local variables in a procedure using negative offsets from the activation record base address (EBP). Consider the following HLA procedure (which admittedly doesn't do much other than demonstrate the use of local variables):</p><a id="I_programlisting5_d1e24558"/><pre class="programlisting">procedure LocalVars; @nodisplay;
var
     a:int32;
     b:int32;
begin LocalVars;

     mov( 0, a );
     mov( a, eax );
     mov( eax, b );

end LocalVars;</pre><p>The activation record for <code class="literal">LocalVars</code> appears in <a class="xref" href="ch05s16.html#activation_record_for_the_localvars_proc" title="Figure 5-6. Activation record for the LocalVars procedure">Figure 5-6</a>.</p><div class="figure"><a id="activation_record_for_the_localvars_proc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e24573"/><img alt="Activation record for the LocalVars procedure" src="tagoreillycom20100401nostarchimages578011.png"/></div></div><p class="title">Figure 5-6. Activation record for the <code class="literal">LocalVars</code> procedure</p></div><p>The HLA compiler emits code that is roughly equivalent to the following for the body of this procedure:<sup>[<a class="footnote" href="#ftn.CHP-5-FN-15" id="CHP-5-FN-15">84</a>]</sup><a class="indexterm" id="IDX-CHP-5-0099"/><a class="indexterm" id="IDX-CHP-5-0100"/></p><a id="I_programlisting5_d1e24589"/><pre class="programlisting">mov( 0, (type dword [ebp-4]));
          mov( [ebp-4], eax );
          mov( eax, [ebp-8] );</pre><p>You could actually type these statements into the procedure yourself and they would work. Of course, using memory references like <code class="literal">[ebp-4]</code> and <code class="literal">[ebp-8]</code> rather than <code class="literal">a</code> or <code class="literal">b</code> makes your programs very difficult to read and understand. Therefore, you should always declare and use HLA symbolic names rather than offsets from EBP.</p><p>The standard entry sequence for this <code class="literal">LocalVars</code> procedure will be:<sup>[<a class="footnote" href="#ftn.CHP-5-FN-16" id="CHP-5-FN-16">85</a>]</sup></p><a id="I_programlisting5_d1e24616"/><pre class="programlisting">push( ebp );
          mov( esp, ebp );
          sub( 8, esp );</pre><p>This code subtracts 8 from the stack pointer because there are 8 bytes of local variables (two double-word objects) in this procedure. Unfortunately, as the number of local variables increases, especially if those variables have different types, computing the number of bytes of local variables becomes rather tedious. Fortunately, for those who wish to write the standard entry sequence themselves, HLA automatically computes this value for you and creates a constant, <code class="literal">_vars_</code>, that specifies the number of bytes of local variables.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-17" id="CHP-5-FN-17">86</a>]</sup> Therefore, if you intend to write the standard entry sequence yourself, you should use the <code class="literal">_vars_</code> constant in the <code class="literal">sub</code> instruction when allocating storage for the local variables:</p><a id="I_programlisting5_d1e24634"/><pre class="programlisting">push( ebp );
          mov( esp, ebp );
          sub( _vars_, esp );</pre><p>Now that you've seen how assembly language allocates and deallocates storage for local variables, it's easy to understand why automatic (<code class="literal">var</code>) variables do not maintain their values between two calls to the same procedure. Because the memory associated with these automatic variables is on the stack, when a procedure returns to its caller the caller can push other data onto the stack, obliterating the values previously held on the stack. Furthermore, intervening calls to other procedures (with their own local variables) may wipe out the values on the stack. Also, upon reentry into a procedure, the procedure's local variables may correspond to different physical memory locations; hence the values of the local variables would not be in their proper locations.</p><p>One big advantage to automatic storage is that it efficiently shares a fixed pool of memory among several procedures. For example, if you call three procedures in a row, like so:<a class="indexterm" id="IDX-CHP-5-0101"/><a class="indexterm" id="IDX-CHP-5-0102"/><a class="indexterm" id="IDX-CHP-5-0103"/><a class="indexterm" id="IDX-CHP-5-0104"/></p><a id="I_programlisting5_d1e24663"/><pre class="programlisting">ProcA();
          ProcB();
          ProcC();</pre><p>the first procedure (<code class="literal">ProcA</code> in the code above) allocates its local variables on the stack. Upon return, <code class="literal">ProcA</code> deallocates that stack storage. Upon entry into <code class="literal">ProcB</code>, the program allocates storage for <code class="literal">ProcB</code>'s local variables <span class="emphasis"><em>using the same memory locations just freed by</em></span> <code class="literal">ProcA</code>. Likewise, when <code class="literal">ProcB</code> returns and the program calls <code class="literal">ProcC</code>, <code class="literal">ProcC</code> uses the same stack space for its local variables that <code class="literal">ProcB</code> recently freed up. This memory reuse makes efficient use of the system resources and is probably the greatest advantage to using automatic (<code class="literal">var</code>) variables.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-15" id="ftn.CHP-5-FN-15">84</a>] </sup>This ignores the code associated with the standard entry and exit sequences.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-16" id="ftn.CHP-5-FN-16">85</a>] </sup>This code assumes that ESP is dword aligned upon entry so the <code class="literal">and( $FFFF_FFFC, esp );</code> instruction is unnecessary.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-17" id="ftn.CHP-5-FN-17">86</a>] </sup>HLA even rounds this constant up to the next even multiple of 4 so you don't have to worry about stack alignment.</p></div></div></div>
<div class="sect1" title="5.17 Low-Level Parameter Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="low-level_parameter_implementation"/>5.17 Low-Level Parameter Implementation</h1></div></div></div><p>Earlier, when discussing HLA's high-level parameter passing mechanism, there were several questions concerning parameters. Some important questions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Where is the data coming from?</p></li><li class="listitem"><p>What mechanism do you use to pass and return data?</p></li><li class="listitem"><p>How much data are you passing?</p></li></ul></div><p>In this section we will take another look at the two most common parameter-passing mechanisms: pass by value and pass by reference. We will discuss three popular places to pass parameters by reference or by value: in the registers, on the stack, and in the code stream. The amount of parameter data has a direct bearing on where and how to pass it. The following sections take up these issues.</p><div class="sect2" title="5.17.1 Passing Parameters in Registers"><div class="titlepage"><div><div><h2 class="title"><a id="passing_parameters_in_registers"/>5.17.1 Passing Parameters in Registers</h2></div></div></div><p>Having touched on <span class="emphasis"><em>how</em></span> to pass parameters to a procedure in Section 5.6, the next thing to discuss is <span class="emphasis"><em>where</em></span> to pass parameters. Where you pass parameters depends on the size and number of those parameters. If you are passing a small number of bytes to a procedure, then the registers are an excellent place to pass parameters to a procedure. If you are passing a single parameter to a procedure, you should use the following registers for the accompanying data types.</p><a id="I_programlisting5_d1e24729"/><pre class="programlisting">Data Size          Pass in this Register
Byte:                     al
Word:                     ax
Double Word:              eax
Quad Word:                edx:eax</pre><p>This is not a hard-and-fast rule. If you find it more convenient to pass 16-bit values in the SI or BX register, then do so. However, most programmers use the registers above to pass parameters.<a class="indexterm" id="IDX-CHP-5-0105"/><a class="indexterm" id="IDX-CHP-5-0106"/></p><p>If you are passing several parameters to a procedure in the 80x86's registers, you should probably use up the registers in the following order:</p><a id="I_programlisting5_d1e24741"/><pre class="programlisting">First                                      Last
          eax, edx, ecx, esi, edi, ebx</pre><p>In general, you should avoid using the EBP register. If you need more than six double words, perhaps you should pass your values elsewhere. This choice of priorities is not completely arbitrary. Many high-level languages will attempt to pass parameters in the EAX, EDX, and ECX registers (generally in that order). Furthermore, the Intel ABI (application binary interface) allows high-level language procedures to use EAX, EDX, and ECX without preserving their values. Hence, these three registers are a great place to pass parameters because a lot of code assumes their values are modified across procedure calls.<a class="indexterm" id="IDX-CHP-5-0107"/><a class="indexterm" id="IDX-CHP-5-0108"/></p><p>As an example, consider the following <code class="literal">strfill( s,c )</code>; procedure that copies the character <code class="literal">c</code> (passed by value in AL) to each character position in <code class="literal">s</code> (passed by reference in EDI) up to a zero-terminating byte:</p><a id="I_programlisting5_d1e24762"/><pre class="programlisting">// strfill-  Overwrites the data in a string with a character.
//
//     EDI-  Pointer to zero-terminated string (e.g., an HLA string)
//      AL-  Character to store into the string

procedure strfill; @nodisplay;
begin strfill;

     push( edi );  // Preserve this because it will be modified.
     while( (type char [edi] ) &lt;&gt; #0 ) do

          mov( al, [edi] );
          inc( edi );

     endwhile;
     pop( edi );

end strfill;</pre><p>To call the <code class="literal">strfill</code> procedure you would load the address of the string data into EDI and the character value into AL prior to the call. The following code fragment demonstrates a typical call to <code class="literal">strfill</code>.</p><a id="I_programlisting5_d1e24772"/><pre class="programlisting">mov( s, edi );  // Get ptr to string data into edi (assumes s:string).
mov( ' ', al );
strfill();</pre><p>Don't forget that HLA string variables are pointers. This example assumes that <code class="literal">s</code> is an HLA string variable and therefore contains a pointer to a zero-terminated string. Thus, the <code class="literal">mov( s, edi );</code> instruction loads the address of the zero-terminated string into the EDI register (hence this code passes the address of the string data to <code class="literal">strfill</code>, that is, it passes the string by reference).</p><p>One way to pass parameters in the registers is to simply load them with the appropriate values prior to a call and then reference those registers within the procedure. This is the traditional mechanism for passing parameters in registers in an assembly language program. HLA, being somewhat more high-level than traditional assembly language, provides a formal parameter declaration syntax that lets you tell HLA you're passing certain parameters in the general-purpose registers. This declaration syntax is the following:</p><a id="I_programlisting5_d1e24788"/><pre class="programlisting"><em class="replaceable"><code>parmName</code></em>: <em class="replaceable"><code>parmType</code></em> in <em class="replaceable"><code>reg</code></em></pre><p>Where <em class="replaceable"><code>parmName</code></em> is the parameter's name, <em class="replaceable"><code>parmType</code></em> is the type of the object, and <em class="replaceable"><code>reg</code></em> is one of the 80x86's general-purpose 8-, 16-, or 32-bit registers. The size of the parameter's type must be equal to the size of the register or HLA will report an error. Here is a concrete example:</p><a id="I_programlisting5_d1e24808"/><pre class="programlisting">procedure HasRegParms( count: uns32 in ecx; charVal:char in al );</pre><p>One nice feature to this syntax is that you can call a procedure that has register parameters exactly like any other procedure in HLA using the high-level syntax. For example:</p><a id="I_programlisting5_d1e24812"/><pre class="programlisting">HasRegParms( ecx, bl );</pre><p>If you specify the same register as an actual parameter that you've declared for the formal parameter, HLA does not emit any extra code; it assumes that the parameter's value is already in the appropriate register. For example, in the call above, the first actual parameter is the value in ECX; because the procedure's declaration specifies that first parameter is in ECX, HLA will not emit any code. On the other hand, the second actual parameter is in BL, but the procedure will expect this parameter value in AL. Therefore, HLA will emit a <code class="literal">mov( bl, al );</code> instruction prior to calling the procedure so that the value is in the proper register upon entry to the procedure.</p><p>You can also pass parameters by reference in a register. Consider the following declaration:</p><a id="I_programlisting5_d1e24821"/><pre class="programlisting">procedure HasRefRegParm( var myPtr:uns32 in edi );</pre><p>A call to this procedure always requires some memory operand as the actual parameter. HLA will emit the code to load the address of that memory object into the parameter's register (EDI in this case). Note that when passing reference parameters, the register must be a 32-bit general-purpose register because addresses are 32 bits long. Here's an example of a call to <code class="literal">HasRefRegParm</code>:<a class="indexterm" id="IDX-CHP-5-0109"/><a class="indexterm" id="IDX-CHP-5-0110"/><a class="indexterm" id="IDX-CHP-5-0111"/><a class="indexterm" id="IDX-CHP-5-0112"/></p><a id="I_programlisting5_d1e24851"/><pre class="programlisting">HasRefRegParm( x );</pre><p>HLA will emit either a <code class="literal">mov( &amp;x, edi);</code> or <code class="literal">lea( edi, x);</code> instruction to load the address of <code class="literal">x</code> into the EDI registers prior to the <code class="literal">call</code> instruction.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-18" id="CHP-5-FN-18">87</a>]</sup></p><p>If you pass an anonymous memory object (for example, <code class="literal">[edi]</code> or <code class="literal">[ecx]</code>) as a parameter to <code class="literal">HasRefRegParm</code>, HLA will not emit any code if the memory reference uses the same register that you declare for the parameter (i.e., <code class="literal">[edi]</code>). It will use a simple <code class="literal">mov</code> instruction to copy the actual address into EDI if you specify an indirect addressing mode using a register other than EDI (e.g., <code class="literal">[ecx]</code>). It will use a <code class="literal">lea</code> instruction to compute the effective address of the anonymous memory operand if you use a more complex addressing mode like <code class="literal">[edi+ecx*4+2]</code>.<a class="indexterm" id="IDX-CHP-5-0113"/></p><p>Within the procedure's code, HLA creates text equates for those register parameters that map their names to the appropriate register. In the <code class="literal">HasRegParms</code> example, any time you reference the <code class="literal">count</code> parameter, HLA substitutes <code class="literal">ecx</code> for <code class="literal">count</code>. Likewise, HLA substitutes <code class="literal">al</code> for <code class="literal">charVal</code> throughout the procedure's body. Because these names are aliases for the registers, you should take care to always remember that you cannot use ECX and AL independently of these parameters. It would be a good idea to place a comment next to each use of these parameters to remind the reader that <code class="literal">count</code> is equivalent to ECX and <code class="literal">charVal</code> is equivalent to AL.</p></div><div class="sect2" title="5.17.2 Passing Parameters in the Code Stream"><div class="titlepage"><div><div><h2 class="title"><a id="passing_parameters_in_the_code_stream"/>5.17.2 Passing Parameters in the Code Stream</h2></div></div></div><p>Another place where you can pass parameters is in the code stream immediately after the <code class="literal">call</code> instruction. Consider the following <code class="literal">print</code> routine that prints a literal string constant to the standard output device:</p><a id="I_programlisting5_d1e24947"/><pre class="programlisting">call print;
          byte "This parameter is in the code stream.",0;</pre><p>Normally, a subroutine returns control to the first instruction immediately following the <code class="literal">call</code> instruction. Were that to happen here, the 80x86 would attempt to interpret the ASCII codes for "This . . . ." as an instruction. This would produce undesirable results. Fortunately, you can skip over this string when returning from the subroutine.</p><p>So how do you gain access to these parameters? Easy. The return address on the stack points at them. Consider the implementation of <code class="literal">print</code> appearing in <a class="xref" href="ch05s17.html#print_procedure_implementation_open_pare" title="Example 5-12. Print procedure implementation (using code stream parameters)">Example 5-12</a>.</p><div class="example"><a id="print_procedure_implementation_open_pare"/><p class="title">Example 5-12. Print procedure implementation (using code stream parameters)</p><div class="example-contents"><pre class="programlisting">program printDemo;
#include( "stdlib.hhf" );

    // print-
    //
    //  This procedure writes the literal string
    //  immediately following the call to the
    //  standard output device. The literal string
    //  must be a sequence of characters ending with
    //  a zero byte (i.e., a C string, not an HLA
    //  string).

    procedure print; @noframe; @nodisplay;
    const

        // RtnAdrs is the offset of this procedure's
        // return address in the activation record.

        RtnAdrs:text := "(type dword [ebp+4])";

    begin print;

        // Build the activation record (note the
        // @noframe option above).

        push( ebp );
        mov( esp, ebp );

        // Preserve the registers this function uses.

        push( eax );
        push( ebx );

        // Copy the return address into the ebx
        // register. Because the return address points
        // at the start of the string to print, this
        // instruction loads ebx with the address of
        // the string to print.

        mov( RtnAdrs, ebx );

        // Until we encounter a zero byte, print the
        // characters in the string.

        forever

            mov( [ebx], al );   // Get the next character.
            breakif( !al );     // Quit if it's zero.
            stdout.putc( al );  // Print it.
            inc( ebx );         // Move on to the next char.

        endfor;

        // Skip past the zero byte and store the resulting
        // address over the top of the return address so
        // we'll return to the location that is one byte
        // beyond the zero-terminating byte of the string.

        inc( ebx );
        mov( ebx, RtnAdrs );

        // Restore eax and ebx.

        pop( ebx );
        pop( eax );

        // Clean up the activation record and return.

        pop( ebp );
        ret();

    end print;


begin printDemo;

    // Simple test of the print procedure

    call print;
    byte "Hello World!", 13, 10, 0 ;

end printDemo;</pre></div></div><p>Besides showing how to pass parameters in the code stream, the <code class="literal">print</code> routine also exhibits another concept: <span class="emphasis"><em>variable-length parameters</em></span>. The string following the <code class="literal">call</code> can be any practical length. The zero terminating byte marks the end of the parameter list. There are two easy ways to handle variable-length parameters: Either use some special terminating value (like 0) or pass a special length value that tells the subroutine how many parameters you are passing. Both methods have their advantages and disadvantages. Using a special value to terminate a parameter list requires that you choose a value that never appears in the list. For example, <code class="literal">print</code> uses 0 as the terminating value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes this isn't a limitation. Specifying a special-length parameter is another mechanism you can use to pass a variable-length parameter list. While this doesn't require any special codes or limit the range of possible values that can be passed to a subroutine, setting up the length parameter and maintaining the resulting code can be a real nightmare.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-19" id="CHP-5-FN-19">88</a>]</sup><a class="indexterm" id="IDX-CHP-5-0114"/><a class="indexterm" id="IDX-CHP-5-0115"/><a class="indexterm" id="IDX-CHP-5-0116"/></p><p>Despite the convenience afforded by passing parameters in the code stream, there are some disadvantages to passing parameters there. First, if you fail to provide the exact number of parameters the procedure requires, the subroutine will get confused. Consider the <code class="literal">print</code> example. It prints a string of characters up to a zero-terminating byte and then returns control to the first instruction following the zero-terminating byte. If you leave off the zero-terminating byte, the <code class="literal">print</code> routine happily prints the following opcode bytes as ASCII characters until it finds a zero byte. Because zero bytes often appear in the middle of an instruction, the <code class="literal">print</code> routine might return control into the middle of some other instruction. This will probably crash the machine. Inserting an extra 0, which occurs more often than you might think, is another problem programmers have with the <code class="literal">print</code> routine. In such a case, the <code class="literal">print</code> routine would return upon encountering the first zero byte and attempt to execute the following ASCII characters as machine code. Once again, this usually crashes the machine. These are the some of the reasons why the HLA <code class="literal">stdout.put</code> code does <span class="emphasis"><em>not</em></span> pass its parameters in the code stream. Problems notwithstanding, however, the code stream is an efficient place to pass parameters whose values do not change.<a class="indexterm" id="IDX-CHP-5-0117"/><a class="indexterm" id="IDX-CHP-5-0118"/></p></div><div class="sect2" title="5.17.3 Passing Parameters on the Stack"><div class="titlepage"><div><div><h2 class="title"><a id="passing_parameters_on_the_stack"/>5.17.3 Passing Parameters on the Stack</h2></div></div></div><p>Most high-level languages use the stack to pass parameters because this method is fairly efficient. By default, HLA also passes parameters on the stack. Although passing parameters on the stack is slightly less efficient than passing those parameters in registers, the register set is very limited and you can pass only a few value or reference parameters through registers. The stack, on the other hand, allows you to pass a large amount of parameter data without any difficulty. This is the principal reason that most programs pass their parameters on the stack.<a class="indexterm" id="IDX-CHP-5-0119"/><a class="indexterm" id="IDX-CHP-5-0120"/></p><p>HLA typically passes parameters you specify using the high-level procedure call syntax on the stack. For example, suppose you define <code class="literal">strfill</code> from earlier as follows:</p><a id="I_programlisting5_d1e25051"/><pre class="programlisting">procedure strfill( s:string; chr:char );</pre><p>Calls of the form <code class="literal">strfill( s, ' ' );</code> will pass the value of <code class="literal">s</code> (which is an address) and a space character on the 80x86 stack. When you specify a call to <code class="literal">strfill</code> in this manner, HLA automatically pushes the parameters for you, so you don't have to push them onto the stack yourself. Of course, if you choose to do so, HLA will let you manually push the parameters onto the stack prior to the call.</p><p>To manually pass parameters on the stack, push them immediately before calling the subroutine. The subroutine then reads this data from the stack memory and operates on it appropriately. Consider the following HLA procedure call:</p><a id="I_programlisting5_d1e25066"/><pre class="programlisting">CallProc(i,j,k);</pre><p>HLA pushes parameters onto the stack in the order that they appear in the parameter list.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-20" id="CHP-5-FN-20">89</a>]</sup> Therefore, the 80x86 code that HLA emits for this subroutine call (assuming you're passing the parameters by value) is:</p><a id="I_programlisting5_d1e25074"/><pre class="programlisting">push( i );
          push( j );
          push( k );
          call CallProc;</pre><p>Upon entry into <code class="literal">CallProc</code>, the 80x86's stack looks like that shown in <a class="xref" href="ch05s17.html#stack_layout_upon_entry_into_callproc" title="Figure 5-7. Stack layout upon entry into CallProc">Figure 5-7</a>.</p><div class="figure"><a id="stack_layout_upon_entry_into_callproc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e25088"/><img alt="Stack layout upon entry into CallProc" src="tagoreillycom20100401nostarchimages578013.png.jpg"/></div></div><p class="title">Figure 5-7. Stack layout upon entry into <code class="literal">CallProc</code></p></div><p>You could gain access to the parameters passed on the stack by removing the data from the stack, as the following code fragment demonstrates:</p><a id="I_programlisting5_d1e25096"/><pre class="programlisting">// Note: To extract parameters off the stack by popping, it is very important
// to specify both the @nodisplay and @noframe procedure options.

static
     RtnAdrs: dword;
     p1Parm: dword;
     p2Parm: dword;
     p3Parm: dword;

procedure CallProc( p1:dword; p2:dword; p3:dword ); @nodisplay; @noframe;
begin CallProc;

     pop( RtnAdrs );
     pop( p3Parm );
     pop( p2Parm );
     pop( p1Parm );
     push( RtnAdrs );
          .
          .
          .
     ret();

end CallProc;</pre><p>As you can see from this code, it first pops the return address off the stack and into the <code class="literal">RtnAdrs</code> variable; then it pops (in reverse order) the values of the <code class="literal">p1</code>, <code class="literal">p2</code>, and <code class="literal">p3</code> parameters; finally, it pushes the return address back onto the stack (so the <code class="literal">ret</code> instruction will operate properly). Within the <code class="literal">CallProc</code> procedure, you may access the <code class="literal">p1Parm</code>, <code class="literal">p2Parm</code>, and <code class="literal">p3Parm</code> variables to use the <code class="literal">p1</code>, <code class="literal">p2</code>, and <code class="literal">p3</code> parameter values.</p><p>There is, however, a better way to access procedure parameters. If your procedure includes the standard entry and exit sequences, then you may directly access the parameter values in the activation record by indexing off the EBP register. Consider the layout of the activation record for <code class="literal">CallProc</code> that uses the following declaration:</p><a id="I_programlisting5_d1e25143"/><pre class="programlisting">procedure CallProc( p1:dword; p2:dword; p3:dword ); @nodisplay; @noframe;
begin CallProc;

     push( ebp );     // This is the standard entry sequence.
     mov( esp, ebp ); // Get base address of A.R. into ebp.
          .
          .
          .</pre><p>Take a look at the stack immediately after the execution of <code class="literal">mov( esp, ebp );</code> in <code class="literal">CallProc</code>. Assuming you've pushed three double-word parameters onto the stack, it should look something like that shown in <a class="xref" href="ch05s17.html#activation_record_for_callproc_after_sta" title="Figure 5-8. Activation record for CallProc after standard entry sequence execution">Figure 5-8</a>.</p><div class="figure"><a id="activation_record_for_callproc_after_sta"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e25161"/><img alt="Activation record for CallProc after standard entry sequence execution" src="tagoreillycom20100401nostarchimages578015.png"/></div></div><p class="title">Figure 5-8. Activation record for <code class="literal">CallProc</code> after standard entry sequence execution</p></div><p>Now you can access the parameters by indexing off the EBP register:</p><a id="I_programlisting5_d1e25168"/><pre class="programlisting">mov( [ebp+16], eax );   // Accesses the first parameter.
          mov( [ebp+12], ebx );   // Accesses the second parameter.
          mov( [ebp+8], ecx );    // Accesses the third parameter.</pre><p>Of course, as with local variables, you'd never really access the parameters in this way. You can use the formal parameter names (<code class="literal">p1</code>, <code class="literal">p2</code>, and <code class="literal">p3</code>), and HLA will substitute a suitable <code class="literal">[ebp+displacement]</code> memory address. Even though you shouldn't actually access parameters using address expressions like <code class="literal">[ebp+12]</code>, it's important to understand their relationship to the parameters in your procedures.</p><p>Other items that often appear in the activation record are register values that your procedure preserves. The most rational place to preserve registers in a procedure is in the code immediately following the standard entry sequence. In a standard HLA procedure (one where you do not specify the <code class="literal">@noframe</code> option), this simply means that the code that preserves the registers should appear first in the procedure's body. Likewise, the code to restore those register values should appear immediately before the <code class="literal">end</code> clause for the procedure.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-21" id="CHP-5-FN-21">90</a>]</sup><a class="indexterm" id="IDX-CHP-5-0121"/><a class="indexterm" id="IDX-CHP-5-0122"/></p><div class="sect3" title="5.17.3.1 Accessing Value Parameters on the Stack"><div class="titlepage"><div><div><h3 class="title"><a id="accessing_value_parameters_on_the_stack"/>5.17.3.1 Accessing Value Parameters on the Stack</h3></div></div></div><p>Accessing parameters passed by value is no different from accessing a local <code class="literal">var</code> object. As long as you've declared the parameter in a formal parameter list and the procedure executes the standard entry sequence upon entry into the program, all you need do is specify the parameter's name to reference the value of that parameter. <a class="xref" href="ch05s17.html#demonstration_of_value_parameters" title="Example 5-13. Demonstration of value parameters">Example 5-13</a> provides an example program whose procedure accesses a parameter the main program passes to it by value.</p><div class="example"><a id="demonstration_of_value_parameters"/><p class="title">Example 5-13. Demonstration of value parameters</p><div class="example-contents"><pre class="programlisting">program AccessingValueParameters;
#include( "stdlib.hhf" )

    procedure ValueParm( theParameter: uns32 ); @nodisplay;
    begin ValueParm;

        mov( theParameter, eax );
        add( 2, eax );
        stdout.put
        (
            "theParameter + 2 = ",
            (type uns32 eax),
            nl
        );

    end ValueParm;


begin AccessingValueParameters;

    ValueParm( 10 );
    ValueParm( 135 );

end AccessingValueParameters;</pre></div></div><p>Although you could access the value of <code class="literal">theParameter</code> using the anonymous address <code class="literal">[EBP+8]</code> within your code, there is absolutely no good reason for doing so. If you declare the parameter list using the HLA high-level language syntax, you can access the value parameter by specifying its name within the procedure.<a class="indexterm" id="IDX-CHP-5-0123"/></p></div><div class="sect3" title="5.17.3.2 Passing Value Parameters on the Stack"><div class="titlepage"><div><div><h3 class="title"><a id="passing_value_parameters_on_the_stack"/>5.17.3.2 Passing Value Parameters on the Stack</h3></div></div></div><p>As <a class="xref" href="ch05s17.html#demonstration_of_value_parameters" title="Example 5-13. Demonstration of value parameters">Example 5-13</a> demonstrates, passing a value parameter to a procedure is very easy. Just specify the value in the actual parameter list as you would for a high-level language call. Actually, the situation is a little more complicated than this. Passing value parameters is easy if you're passing constant, register, or variable values. It gets a little more complex if you need to pass the result of some expression. This section deals with the different ways you can pass a parameter by value to a procedure.<a class="indexterm" id="IDX-CHP-5-0124"/></p><p>Of course, you do not have to use the HLA high-level syntax to pass value parameters to a procedure. You can push these values on the stack yourself. Because many times it is more convenient or more efficient to manually pass the parameters, describing how to do this is a good place to start.</p><p>As noted earlier in this chapter, when passing parameters on the stack you push the objects in the order they appear in the formal parameter list (from left to right). When passing parameters by value, you should push the values of the actual parameters onto the stack. The program in <a class="xref" href="ch05s17.html#manually_passing_parameters_on_the_stack" title="Example 5-14. Manually passing parameters on the stack">Example 5-14</a> demonstrates how to do this.</p><div class="example"><a id="manually_passing_parameters_on_the_stack"/><p class="title">Example 5-14. Manually passing parameters on the stack</p><div class="example-contents"><pre class="programlisting">program ManuallyPassingValueParameters;
#include( "stdlib.hhf" )

    procedure ThreeValueParms( p1:uns32; p2:uns32; p3:uns32 ); @nodisplay;
    begin ThreeValueParms;

        mov( p1, eax );
        add( p2, eax );
        add( p3, eax );
        stdout.put
        (
            "p1 + p2 + p3 = ",
            (type uns32 eax),
            nl
        );

    end ThreeValueParms;


static
    SecondParmValue:uns32 := 25;

begin ManuallyPassingValueParameters;

    pushd( 10 );                // Value associated with p1
    pushd( SecondParmValue);    // Value associated with p2
    pushd( 15 );                // Value associated with p3
    call ThreeValueParms;

end ManuallyPassingValueParameters;</pre></div></div><p>Note that if you manually push the parameters onto the stack as this example does, you must use the <code class="literal">call</code> instruction to call the procedure. If you attempt to use a procedure invocation of the form <code class="literal">ThreeValueParms();</code>, then HLA will complain about a mismatched parameter list. HLA won't realize that you've manually pushed the parameters (as far as HLA is concerned, those pushes appear to preserve some other data).</p><p>Generally, there is little reason to manually push a parameter onto the stack if the actual parameter is a constant, a register value, or a variable. HLA's high-level syntax handles most such parameters for you. There are several instances, however, where HLA's high-level syntax won't work. The first such example is passing the result of an arithmetic expression as a value parameter. Because runtime arithmetic expressions don't exist in HLA, you will have to manually compute the result of the expression and pass that value yourself. There are two possible ways to do this: calculate the result of the expression and manually push that result onto the stack, or compute the result of the expression into a register and pass the register as a parameter to the procedure. The program in <a class="xref" href="ch05s17.html#passing_the_result_of_some_arithmetic_ex" title="Example 5-15. Passing the result of some arithmetic expression as a parameter">Example 5-15</a> demonstrates these two mechanisms.</p><div class="example"><a id="passing_the_result_of_some_arithmetic_ex"/><p class="title">Example 5-15. Passing the result of some arithmetic expression as a parameter</p><div class="example-contents"><pre class="programlisting">program PassingExpressions;
#include( "stdlib.hhf" )

    procedure ExprParm( exprValue:uns32 ); @nodisplay;
    begin ExprParm;

        stdout.put( "exprValue = ", exprValue, nl );

    end ExprParm;


static
    Operand1: uns32 := 5;
    Operand2: uns32 := 20;

begin PassingExpressions;

    // ExprParm( Operand1 + Operand2 );
    //
    //  Method one: Compute the sum and manually
    //  push the sum onto the stack.

    mov( Operand1, eax );
    add( Operand2, eax );
    push( eax );
    call ExprParm;

    //  Method two: Compute the sum in a register and
    //  pass the register using the HLA high-level
    //  language syntax.

    mov( Operand1, eax );
    add( Operand2, eax );
    ExprParm( eax );

end PassingExpressions;</pre></div></div><p>The examples up to this point in this section have made an important assumption: that the parameter you are passing is a double-word value. The calling sequence changes somewhat if you're passing parameters that are not 4-byte objects. Because HLA can generate relatively inefficient code when passing objects that are not 4 bytes long, manually passing such objects is a good idea if you want to have the fastest possible code.<a class="indexterm" id="IDX-CHP-5-0125"/></p><p>HLA requires that all value parameters be a multiple of 4 bytes long.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-22" id="CHP-5-FN-22">91</a>]</sup> If you pass an object that is less than 4 bytes long, HLA requires that you <span class="emphasis"><em>pad</em></span> the parameter data with extra bytes so that you always pass an object that is at least 4 bytes in length. For parameters that are larger than 4 bytes, you must ensure that you pass a multiple of 4 bytes as the parameter value, adding extra bytes at the high-order end of the object to pad it, as necessary.<a class="indexterm" id="IDX-CHP-5-0126"/></p><p>Consider the following procedure prototype:</p><a id="I_programlisting5_d1e25308"/><pre class="programlisting">procedure OneByteParm( b:byte );</pre><p>The activation record for this procedure appears in <a class="xref" href="ch05s17.html#onebyteparm_activation_record" title="Figure 5-9. OneByteParm activation record">Figure 5-9</a>.</p><div class="figure"><a id="onebyteparm_activation_record"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e25319"/><img alt="OneByteParm activation record" src="tagoreillycom20100401nostarchimages578017.png"/></div></div><p class="title">Figure 5-9. <code class="literal">OneByteParm</code> activation record</p></div><p>As you can see, there are 4 bytes on the stack associated with the <code class="literal">b</code> parameter, but only 1 of the 4 bytes contains valid data (the L.O. byte). The remaining 3 bytes are just padding, and the procedure should ignore these bytes. In particular, you should never assume that these extra bytes contain 0s or some other consistent value. Depending on the type of parameter you pass, HLA's automatic code generation may or may not push 0 bytes as the extra data on the stack.<a class="indexterm" id="IDX-CHP-5-0127"/><a class="indexterm" id="IDX-CHP-5-0128"/><a class="indexterm" id="IDX-CHP-5-0129"/><a class="indexterm" id="IDX-CHP-5-0130"/></p><p>When passing a byte parameter to a procedure, HLA will automatically emit code that pushes 4 bytes onto the stack. Because HLA's parameter-passing mechanism guarantees not to disturb any register or other values, HLA sometimes generates more code than is actually needed to pass a byte parameter. For example, if you decide to pass the AL register as the byte parameter, HLA will emit code that pushes the EAX register onto the stack. This single push instruction is a very efficient way to pass AL as a 4-byte parameter object. On the other hand, if you decide to pass the AH register as the byte parameter, pushing EAX won't work because this would leave the value in AH at offset EBP+9 in the activation record shown in <a class="xref" href="ch05s17.html#onebyteparm_activation_record" title="Figure 5-9. OneByteParm activation record">Figure 5-9</a>. Unfortunately, the procedure expects this value at offset EBP+8, so simply pushing EAX won't do the job. If you pass AH, BH, CH, or DH as a byte parameter, HLA emits code like the following:<a class="indexterm" id="IDX-CHP-5-0131"/></p><a id="I_programlisting5_d1e25360"/><pre class="programlisting">sub( 4, esp );    // Make room for the parameter on the stack.
mov( ah, [esp] ); // Store ah into the L.O. byte of the parameter.</pre><p>As you can clearly see, passing one of the H registers as a byte parameter is less efficient than passing one of the L registers. So you should attempt to use the L registers whenever possible if passing an 8-bit register as a parameter.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-23" id="CHP-5-FN-23">92</a>]</sup> Note, by the way, that there is very little you can do about the efficiency issue, even if you manually pass the parameters.<a class="indexterm" id="IDX-CHP-5-0132"/></p><p>If the byte parameter you decide to pass is a variable rather than a register, HLA generates decidedly worse code. For example, suppose you call <code class="literal">OneByteParm</code> as follows:</p><a id="I_programlisting5_d1e25378"/><pre class="programlisting">OneByteParm( <em class="replaceable"><code>uns8Var</code></em> );</pre><p>For this call, HLA will emit code similar to the following to push this single-byte parameter:</p><a id="I_programlisting5_d1e25385"/><pre class="programlisting">push( eax );
push( eax );
mov( <em class="replaceable"><code>uns8Var</code></em>, al );
mov( al, [esp+4] );
pop( eax );</pre><p>As you can plainly see, this is a lot of code to pass a single byte onto the stack! HLA emits this much code because (1) it guarantees not to disturb any registers, and (2) it doesn't know whether <em class="replaceable"><code>uns8Var</code></em> is the last variable in allocated memory. You can generate much better code if you don't have to enforce either of these two constraints.</p><p>If you have a spare 32-bit register lying around (especially one of EAX, EBX, ECX, or EDX), then you can pass a byte parameter onto the stack using only two instructions. Move (or move with zero/sign extension) the byte value into the register and then push the register onto the stack. For the current call to <code class="literal">OneByteParm</code>, the calling sequence would look like the following if EAX is available:</p><a id="I_programlisting5_d1e25401"/><pre class="programlisting">mov( <em class="replaceable"><code>uns8Var</code></em>, al );
push( eax );
call OneByteParm;</pre><p>If only ESI or EDI is available, you could use code like this:</p><a id="I_programlisting5_d1e25408"/><pre class="programlisting">movzx( <em class="replaceable"><code>uns8Var</code></em>, esi );
push( esi );
call OneByteParm;</pre><p>Another trick you can use to pass the parameter with only a single <code class="literal">push</code> instruction is to coerce the byte variable to a double-word object. For example:</p><a id="I_programlisting5_d1e25418"/><pre class="programlisting">push( (type dword <em class="replaceable"><code>uns8Var</code></em>));
call OneByteParm;</pre><p>This last example is very efficient. Note that it pushes the first 3 bytes of whatever value happens to follow <em class="replaceable"><code>uns8Var</code></em> in memory as the padding bytes. HLA doesn't use this technique because there is a (very tiny) chance that using this scheme will cause the program to fail. If it turns out that the <em class="replaceable"><code>uns8Var</code></em> object is the last byte of a given page in memory and the next page of memory is unreadable, the <code class="literal">push</code> instruction will cause a memory access exception. To be on the safe side, the HLA compiler does not use this scheme. However, if you always ensure that the actual parameter you pass in this fashion is not the last variable you declare in a <code class="literal">static</code> section, then you can get away with code that uses this technique. Because it is nearly impossible for the byte object to appear at the last accessible address on the stack, it is probably safe to use this technique with <code class="literal">var</code> objects.<a class="indexterm" id="IDX-CHP-5-0133"/><a class="indexterm" id="IDX-CHP-5-0134"/></p><p>When passing word parameters on the stack, you must also ensure that you include padding bytes so that each parameter consumes a multiple of 4 bytes. You can use the same techniques we use to pass bytes, except, of course, there are two valid bytes of data to pass instead of one. For example, you could use either of the following two schemes to pass a word object <code class="literal">w</code> to a <code class="literal">OneWordParm</code> procedure:<a class="indexterm" id="IDX-CHP-5-0135"/><a class="indexterm" id="IDX-CHP-5-0136"/></p><a id="I_programlisting5_d1e25473"/><pre class="programlisting">mov( w, ax );
push( eax );
call OneWordParm;


push( (type dword w) );
call OneWordParm;</pre><p>When passing large objects by value on the stack (e.g., records and arrays), you do not have to ensure that each element or field of the object consumes a multiple of 4 bytes; all you need to do is ensure that the entire data structure consumes a multiple of 4 bytes on the stack. For example, if you have an array of ten 3-byte elements, the entire array will need 2 bytes of padding (10 * 3 is 30 bytes, which is not divisible by 4, but 10 * 3 + 2 is 32, which is divisible by 4). HLA does a fairly good job of passing large data objects by value to a procedure. For larger objects, you should use the HLA high-level language procedure invocation syntax unless you have some special requirements. Of course, if you want efficient operation, you should try to avoid passing large data structures by value.</p><p>By default, HLA guarantees that it won't disturb the values of any registers when it emits code to pass parameters to a procedure. Sometimes this guarantee isn't necessary. For example, if you are returning a function result in EAX and you are not passing a parameter to a procedure in EAX, there really is no reason to preserve EAX upon entry into the procedure. Rather than generating some crazy code like the following to pass a byte parameter,</p><a id="I_programlisting5_d1e25480"/><pre class="programlisting">push( eax );
          push( eax );
          mov( <em class="replaceable"><code>uns8Var</code></em>, al );
          mov( al, [esp+4] );
          pop( eax );</pre><p>HLA could generate much better code if it knows that it can use EAX (or some other register) as follows.</p><a id="I_programlisting5_d1e25487"/><pre class="programlisting">mov( <em class="replaceable"><code>uns8Var</code></em>, al );
          push( eax );</pre><p>You can use the <code class="literal">@use</code> procedure option to tell HLA that it can modify a register's value if doing so would improve the code it generates when passing parameters. The syntax for this option is:<a class="indexterm" id="IDX-CHP-5-0137"/><a class="indexterm" id="IDX-CHP-5-0138"/><a class="indexterm" id="IDX-CHP-5-0139"/></p><a id="I_programlisting5_d1e25512"/><pre class="programlisting">@use <em class="replaceable"><code>reg32</code></em>;</pre><p>The <em class="replaceable"><code>reg32</code></em> operand can be EAX, EBX, ECX, EDX, ESI, or EDI. You'll obtain the best results if this register is one of EAX, EBX, ECX, or EDX. You should note that you cannot specify EBP or ESP here (because the procedure already uses those registers).</p><p>The <code class="literal">@use</code> procedure option tells HLA that it's okay to modify the value of the register you specify as an operand. Therefore, if HLA can generate better code by not preserving that register's value, it will do so. For example, when the <code class="literal">@use eax;</code> option is provided for the <code class="literal">OneByteParm</code> procedure given earlier, HLA will only emit the two instructions immediately above rather than the five-instruction sequence that preserves EAX.</p><p>You must exercise care when specifying the <code class="literal">@use</code> procedure option. In particular, you should not be passing any parameters in the same register you specify in the <code class="literal">@use</code> option (because HLA may inadvertently scramble the parameter's value if you do this). Likewise, you must ensure that it's really okay for the procedure to change the register's value. As noted above, the best choice for an <code class="literal">@use</code> register is EAX when the procedure is returning a function result in EAX (because, clearly, the caller will not expect the procedure to preserve EAX).</p><p>If your procedure has a <code class="literal">forward</code> or <code class="literal">external</code> declaration (see <a class="xref" href="ch05s24.html" title="5.24 Units and the external Directive">5.24 Units and the external Directive</a>), the <code class="literal">@use</code> option must appear only in the <code class="literal">forward</code> or <code class="literal">external</code> definition, not in the actual procedure declaration. If no such procedure prototype appears, then you must attach the <code class="literal">@use</code> option to the procedure declaration.</p><p>Here's an example:</p><a id="I_programlisting5_d1e25570"/><pre class="programlisting">procedure OneByteParm( b:byte ); @nodisplay; @use EAX;
begin OneByteParm;

     &lt;&lt; Do something with b. &gt;&gt;

end OneByteParm;
     .
     .
     .
static
     byteVar:byte;
          .
          .
          .
     OneByteParm( byteVar );</pre><p>This call to <code class="literal">OneByteParm</code> emits the following instructions:</p><a id="I_programlisting5_d1e25577"/><pre class="programlisting">mov( <em class="replaceable"><code>uns8Var</code></em>, al );
push( eax );
call OneByteParm;</pre></div><div class="sect3" title="5.17.3.3 Accessing Reference Parameters on the Stack"><div class="titlepage"><div><div><h3 class="title"><a id="accessing_reference_parameters_on_the_st"/>5.17.3.3 Accessing Reference Parameters on the Stack</h3></div></div></div><p>Because HLA passes the address for reference parameters, accessing the reference parameters within a procedure is slightly more difficult than accessing value parameters because you have to dereference the pointers to the reference parameters. Unfortunately, HLA's high-level syntax for procedure declarations and invocations does not (and cannot) abstract this detail away for you. You will have to manually dereference these pointers yourself. This section reviews how you do this.<a class="indexterm" id="IDX-CHP-5-0140"/><a class="indexterm" id="IDX-CHP-5-0141"/></p><p>In <a class="xref" href="ch05s17.html#accessing_a_reference_parameter" title="Example 5-16. Accessing a reference parameter">Example 5-16</a> the <code class="literal">RefParm</code> procedure has a single pass-by-reference parameter. A pass-by-reference parameter is always a pointer to an object of the type specified by the parameter's declaration. Therefore, <code class="literal">theParameter</code> is actually an object of type <code class="literal">pointer to uns32</code> rather than an <code class="literal">uns32</code> value. In order to access the value associated with <code class="literal">theParameter</code>, this code has to load that double-word address into a 32-bit register and access the data indirectly. The <code class="literal">mov( theParameter, eax );</code> instruction in <a class="xref" href="ch05s17.html#accessing_a_reference_parameter" title="Example 5-16. Accessing a reference parameter">Example 5-16</a> fetches this pointer into the EAX register, and then procedure <code class="literal">RefParm</code> uses the <code class="literal">[eax]</code> addressing mode to access the actual value of <code class="literal">theParameter</code>.</p><div class="example"><a id="accessing_a_reference_parameter"/><p class="title">Example 5-16. Accessing a reference parameter</p><div class="example-contents"><pre class="programlisting">program AccessingReferenceParameters;
#include( "stdlib.hhf" )

    procedure RefParm( var theParameter: uns32 ); @nodisplay;
    begin RefParm;

        // Add 2 directly to the parameter passed by
        // reference to this procedure.

        mov( theParameter, eax );
        add( 2, (type uns32 [eax]) );

        // Fetch the value of the reference parameter
        // and print its value.

        mov( [eax], eax );
        stdout.put
        (
            "theParameter now equals ",
            (type uns32 eax),
            nl
        );

    end RefParm;


static
    p1: uns32 := 10;
    p2: uns32 := 15;

begin AccessingReferenceParameters;

    RefParm( p1 );
    RefParm( p2 );

    stdout.put( "On return, p1=", p1, " and p2=", p2, nl );

end AccessingReferenceParameters;</pre></div></div><p>Because this procedure accesses the data of the actual parameter, adding 2 to this data affects the values of the variables passed to the <code class="literal">RefParm</code> procedure from the main program. Of course, this should come as no surprise because these are the standard semantics for pass-by-reference parameters.<a class="indexterm" id="IDX-CHP-5-0142"/><a class="indexterm" id="IDX-CHP-5-0143"/><a class="indexterm" id="IDX-CHP-5-0144"/></p><p>As you can see, accessing (small) pass-by-reference parameters is a little less efficient than accessing value parameters because you need an extra instruction to load the address into a 32-bit pointer register (not to mention you have to reserve a 32-bit register for this purpose). If you access reference parameters frequently, these extra instructions can really begin to add up, reducing the efficiency of your program. Furthermore, it's easy to forget to dereference a reference parameter and use the address of the value in your calculations (this is especially true when passing double-word parameters, like the <code class="literal">uns32</code> parameter in the example above, to your procedures). Therefore, unless you really need to affect the value of the actual parameter, you should use pass by value to pass small objects to a procedure.</p><p>Passing large objects, like arrays and records, is where using reference parameters becomes efficient. When passing these objects by value, the calling code has to make a copy of the actual parameter; if the actual parameter is a large object, the copy process can be very inefficient. Because computing the address of a large object is just as efficient as computing the address of a small scalar object, there is no efficiency loss when passing large objects by reference. Within the procedure, you must still dereference the pointer to access the object, but the efficiency loss due to indirection is minimal when you contrast this with the cost of copying that large object. The program in <a class="xref" href="ch05s17.html#passing_an_array_of_records_by_referenci" title="Example 5-17. Passing an array of records by referencing">Example 5-17</a> demonstrates how to use pass by reference to initialize an array of records.</p><div class="example"><a id="passing_an_array_of_records_by_referenci"/><p class="title">Example 5-17. Passing an array of records by referencing</p><div class="example-contents"><pre class="programlisting">program accessingRefArrayParameters;
#include( "stdlib.hhf" )

const
    NumElements := 64;

type
    Pt: record

            x:uns8;
            y:uns8;

        endrecord;

    Pts: Pt[NumElements];


    procedure RefArrayParm( var ptArray: Pts ); @nodisplay;
    begin RefArrayParm;

        push( eax );
        push( ecx );
        push( edx );

        mov( ptArray, edx );    // Get address of parameter into edx.

        for( mov( 0, ecx ); ecx &lt; NumElements; inc( ecx )) do

            // For each element of the array, set the x field
            // to (ecx div 8) and set the y field to (ecx mod 8).

            mov( cl, al );
            shr( 3, al );     // ecx div 8.
            mov( al, (type Pt [edx+ecx*2]).x );

            mov( cl, al );
            and( %111, al );  // ecx mod 8.
            mov( al, (type Pt [edx+ecx*2]).y );

        endfor;
        pop( edx );
        pop( ecx );
        pop( eax );

    end RefArrayParm;


static
    MyPts: Pts;

begin accessingRefArrayParameters;

    // Initialize the elements of the array.

    RefArrayParm( MyPts );


    // Display the elements of the array.

    for( mov( 0, ebx ); ebx &lt; NumElements; inc( ebx )) do

        stdout.put
        (
            "RefArrayParm[",
            (type uns32 ebx):2,
            "].x=",
            MyPts.x[ ebx*2 ],

            "   RefArrayParm[",
            (type uns32 ebx):2,
            "].y=",
            MyPts.y[ ebx*2 ],
            nl
        );

    endfor;

end accessingRefArrayParameters;</pre></div></div><p>As you can see from this example, passing large objects by reference is relatively efficient. Other than tying up the EDX register throughout the <code class="literal">RefArrayParm</code> procedure, plus a single instruction to load EDX with the address of the reference parameter, the <code class="literal">RefArrayParm</code> procedure doesn't require many more instructions than the same procedure where you would pass the parameter by value.<a class="indexterm" id="IDX-CHP-5-0145"/></p></div><div class="sect3" title="5.17.3.4 Passing Reference Parameters on the Stack"><div class="titlepage"><div><div><h3 class="title"><a id="passing_reference_parameters_on_the_stac"/>5.17.3.4 Passing Reference Parameters on the Stack</h3></div></div></div><p>HLA's high-level syntax often makes passing reference parameters a breeze. All you need to do is specify the name of the actual parameter you wish to pass in the procedure's parameter list. HLA will automatically emit some code that will compute the address of the specified actual parameter and push this address onto the stack. However, like the code HLA emits for value parameters, the code HLA generates to pass the address of the actual parameter on the stack may not be the most efficient possible. Therefore, if you want to write fast code, you may want to manually write the code to pass reference parameters to a procedure. This section discusses how to do exactly that.<a class="indexterm" id="IDX-CHP-5-0146"/><a class="indexterm" id="IDX-CHP-5-0147"/></p><p>Whenever you pass a static object as a reference parameter, HLA generates very efficient code to pass the address of that parameter to the procedure. As an example, consider the following code fragment:</p><a id="I_programlisting5_d1e25698"/><pre class="programlisting">procedure HasRefParm( var d:dword );
          .
          .
          .
     static
          FourBytes:dword;

     var
          v: dword[2];
          .
          .
          .
     HasRefParm( FourBytes );
          .
          .
          .</pre><p>For the call to the <code class="literal">HasRefParm</code> procedure, HLA emits the following instruction sequence:<a class="indexterm" id="IDX-CHP-5-0148"/><a class="indexterm" id="IDX-CHP-5-0149"/><a class="indexterm" id="IDX-CHP-5-0150"/></p><a id="I_programlisting5_d1e25714"/><pre class="programlisting">pushd( &amp;FourBytes );
call HasRefParm;</pre><p>You really aren't going to be able to do substantially better than this if you are passing your reference parameters on the stack. So if you're passing static objects as reference parameters, HLA generates fairly good code, and you should stick with the high-level syntax for the procedure call.</p><p>Unfortunately, when passing automatic (<code class="literal">var</code>) objects or indexed variables as reference parameters, HLA needs to compute the address of the object at runtime. This may require the use of the <code class="literal">lea</code> instruction. Unfortunately, the <code class="literal">lea</code> instruction requires a 32-bit register, and HLA promises not to disturb the values in any registers when it automatically generates code for you.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-24" id="CHP-5-FN-24">93</a>]</sup> Therefore, HLA needs to preserve the value in whatever register it uses when it computes an address via <code class="literal">lea</code> to pass a parameter by reference. The following example shows you the code that HLA actually emits:<a class="indexterm" id="IDX-CHP-5-0151"/></p><a id="I_programlisting5_d1e25744"/><pre class="programlisting">// Call to the HasRefParm procedure:

          HasRefParm( v[ebx*4] );

// HLA actually emits the following code for the above call:

          push( eax );
          push( eax );
          lea( eax, v[ebx*4] );
          mov( eax, [esp+4] );
          pop( eax );
          call HasRefParm;</pre><p>As you can see, this is quite a bit of code, especially if you have a 32-bit register available and you don't need to preserve that register's value. The following is a better code sequence given the availability of EAX.</p><a id="I_programlisting5_d1e25748"/><pre class="programlisting">lea( eax, v[ebx*4] );
          push( eax );
          call HasRefParm;</pre><p>Remember, when passing an actual parameter by reference, you must compute the address of that object and push the address onto the stack. For simple static objects you can use the address-of operator (<code class="literal">&amp;</code>) to easily compute the address of the object and push it onto the stack; however, for indexed and automatic objects, you will probably need to use the <code class="literal">lea</code> instruction to compute the address of the object. Here are some examples that demonstrate this using the <code class="literal">HasRefParm</code> procedure from the previous examples:<a class="indexterm" id="IDX-CHP-5-0152"/><a class="indexterm" id="IDX-CHP-5-0153"/><a class="indexterm" id="IDX-CHP-5-0154"/></p><a id="I_programlisting5_d1e25779"/><pre class="programlisting">static
     i:    int32;
     Ary:  int32[16];
     iptr: pointer to int32 := &amp;i;

var
     v:    int32;
     AV:   int32[10];
     vptr: pointer to int32;
      .
      .
      .
     lea( eax, v );
     mov( eax, vptr );
      .
      .
      .
// HasRefParm( i );

     push( &amp;i );               // Simple static object, so just use &amp;.
     call HasRefParm;

// HasRefParm( Ary[ebx] );     // Pass element of Ary by reference.

     lea( eax, Ary[ ebx*4 ]);  // Must use lea for indexed addresses.
     push( eax );
     call HasRefParm;

// HasRefParm( *iptr );  -- Pass object pointed at by iptr

     push( iptr );             // Pass address (iptr's value) on stack.
     call HasRefParm;

// HasRefParm( v );

     lea( eax, v );            // Must use lea to compute the address
     push( eax );              // of automatic vars passed on stack.
     call HasRefParm;

// HasRefParm( AV[ esi ] );  -- Pass element of AV by reference.

     lea( eax, AV[ esi*4] );   // Must use lea to compute address of the
     push( eax );              // desired element.
     call HasRefParm;

// HasRefParm( *vptr );  -- Pass address held by vptr...

     push( vptr );             // Just pass vptr's value as the specified
     call HasRefParm;          // address.</pre><p>If you have an extra register to spare, you can tell HLA to use that register when computing the address-of reference parameters (without emitting the code to preserve that register's value). The <code class="literal">@use</code> option will tell HLA that it's okay to use the specified register without preserving its value. As noted in the section on value parameters, the syntax for this procedure option is:<a class="indexterm" id="IDX-CHP-5-0155"/><a class="indexterm" id="IDX-CHP-5-0156"/><a class="indexterm" id="IDX-CHP-5-0157"/><a class="indexterm" id="IDX-CHP-5-0158"/><a class="indexterm" id="IDX-CHP-5-0159"/><a class="indexterm" id="IDX-CHP-5-0160"/><a class="indexterm" id="IDX-CHP-5-0161"/></p><a id="I_programlisting5_d1e25819"/><pre class="programlisting">@use <em class="replaceable"><code>reg32</code></em>;</pre><p>where <em class="replaceable"><code>reg32</code></em> may be any of EAX, EBX, ECX, EDX, ESI, or EDI. Because reference parameters always pass a 32-bit value, all of these registers are equivalent as far as HLA is concerned (unlike value parameters that may prefer the EAX, EBX, ECX, or EDX register). Your best choice would be EAX if the procedure is not passing a parameter in the EAX register and the procedure is returning a function result in EAX; otherwise, any currently unused register will work fine.</p><p>With the <code class="literal">@use eax</code>; option, HLA emits the shorter code given in the previous examples. It does not emit all the extra instructions needed to preserve EAX's value. This makes your code much more efficient, especially when passing several parameters by reference or when calling procedures with reference parameters several times.</p></div><div class="sect3" title="5.17.3.5 Passing Formal Parameters as Actual Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="passing_formal_parameters_as_actual_para"/>5.17.3.5 Passing Formal Parameters as Actual Parameters</h3></div></div></div><p>The examples in the previous two sections show how to pass static and automatic variables as parameters to a procedure, either by value or by reference. There is one situation that these examples don't handle properly: the case when you are passing a formal parameter in one procedure as an actual parameter to another procedure. The following simple example demonstrates the different cases that can occur for pass-by-value and pass-by-reference parameters:</p><a id="I_programlisting5_d1e25839"/><pre class="programlisting">procedure p1( val v:dword;  var r:dword );
     begin p1;
           .
           .
           .
     end p1;

     procedure p2( val v2:dword; var r2:dword );
     begin p2;

          p1( v2, r2 );    // (1) First call to p1
          p1( r2, v2 );    // (2) Second call to p1

     end p2;</pre><p>In the statement labeled <code class="literal">(1)</code> above, procedure <code class="literal">p2</code> calls procedure <code class="literal">p1</code> and passes its two formal parameters as parameters to <code class="literal">p1</code>. Note that this code passes the first parameter of both procedures by value, and it passes the second parameter of both procedures by reference. Therefore, in statement <code class="literal">(1)</code>, the program passes the <code class="literal">v2</code> parameter into <code class="literal">p2</code> by value and passes it on to <code class="literal">p1</code> by value; likewise, the program passes <code class="literal">r2</code> in by reference and it passes the value onto <code class="literal">p1</code> by reference.</p><p>Because <code class="literal">p2</code>'s caller passes <code class="literal">v2</code> in by value and <code class="literal">p2</code> passes this parameter to <code class="literal">p1</code> by value, all the code needs to do is make a copy of <code class="literal">v2</code>'s value and pass this on to <code class="literal">p1</code>. The code to do this is nothing more than a single <code class="literal">push</code> instruction. For example:</p><a id="I_programlisting5_d1e25898"/><pre class="programlisting">push( v2 );
     &lt;&lt; Code to handle r2 &gt;&gt;
     call p1;</pre><p>As you can see, this code is identical to passing an automatic variable by value. Indeed, it turns out that the code you need to write to pass a value parameter to another procedure is identical to the code you would write to pass a local automatic variable to that other procedure.</p><p>Passing <code class="literal">r2</code> in statement <code class="literal">(1)</code> above requires a little more thought. You do not take the address of <code class="literal">r2</code> using the <code class="literal">lea</code> instruction as you would a value parameter or an automatic variable. When passing <code class="literal">r2</code> on through to <code class="literal">p1</code>, the author of this code probably expects the <code class="literal">r</code> formal parameter to contain the address of the variable whose address <code class="literal">p2</code>'s caller passed into <code class="literal">p2</code>. In plain English, this means that <code class="literal">p2</code> must pass the address of <code class="literal">r2</code>'s actual parameter on through to <code class="literal">p1</code>. Because the <code class="literal">r2</code> parameter is a double-word value containing the address of the corresponding actual parameter, this means that the code must pass the double-word value of <code class="literal">r2</code> on to <code class="literal">p1</code>. The complete code for statement <code class="literal">(1)</code> above looks like the following:</p><a id="I_programlisting5_d1e25954"/><pre class="programlisting">push( v2 );   // Pass the value passed in through v2 to p1.
     push( r2 );   // Pass the address passed in through r2 to p1.
     call p1;</pre><p>The important thing to note in this example is that passing a formal reference parameter (<code class="literal">r2</code>) as an actual reference parameter (<code class="literal">r</code>) does not involve taking the address of the formal parameter (<code class="literal">r2</code>). <code class="literal">p2</code>'s caller has already done this; <code class="literal">p2</code> simply passes this address on through to <code class="literal">p1</code>.</p><p>In the second call to <code class="literal">p1</code> in the example above (<code class="literal">2</code>), the code swaps the actual parameters so that the call to <code class="literal">p1</code> passes <code class="literal">r2</code> by value and <code class="literal">v2</code> by reference. Specifically, <code class="literal">p1</code> expects <code class="literal">p2</code> to pass it the value of the double-word object associated with <code class="literal">r2</code>; likewise, it expects <code class="literal">p2</code> to pass it the address of the value associated with <code class="literal">v2</code>.</p><p>To pass the value of the object associated with <code class="literal">r2</code>, your code must dereference the pointer associated with <code class="literal">r2</code> and directly pass the value. Here is the code HLA automatically generates to pass <code class="literal">r2</code> as the first parameter to <code class="literal">p1</code> in statement <code class="literal">(2)</code>:</p><a id="I_programlisting5_d1e26028"/><pre class="programlisting">sub( 4, esp );      // Make room on stack for parameter.
     push( eax );        // Preserve eax's value.
     mov( r2, eax );     // Get address-of object passed in to p2.
     mov( [eax], eax );  // Dereference to get the value of this object.
     mov( eax, [esp+4]); // Put value-of parameter into its location on stack.
     pop( eax );         // Restore original eax value.</pre><p>As usual, HLA generates a little more code than may be necessary because it won't destroy the value in the EAX register (you may use the <code class="literal">@use</code> procedure option to tell HLA that it's okay to use EAX's value, thereby reducing the code it generates). You can write more efficient code if a register is available to use in this sequence. If EAX is unused, you could trim this down to the following:</p><a id="I_programlisting5_d1e26035"/><pre class="programlisting">mov( r2, eax );     // Get the pointer to the actual object.
     pushd( [eax] );     // Push the value of the object onto the stack.</pre><p>Because you can treat value parameters exactly like local (automatic) variables, you use the same code to pass <code class="literal">v2</code> by reference to <code class="literal">p1</code> as you would to pass a local variable in <code class="literal">p2</code> to <code class="literal">p1</code>. Specifically, you use the <code class="literal">lea</code> instruction to compute the address of the value in the <code class="literal">v2</code>. The code HLA automatically emits for statement <code class="literal">(2)</code> above preserves all registers and takes the following form (same as passing an automatic variable by reference):</p><a id="I_programlisting5_d1e26061"/><pre class="programlisting">push( eax );        // Make room for the parameter.
     push( eax );        // Preserve eax's value.
     lea( eax, v2 );     // Compute address of v2's value.
     mov( eax, [esp+4]); // Store away address as parameter value.
     pop( eax );         // Restore eax's value.</pre><p>Of course, if you have a register available, you can improve on this code. Here's the complete code that corresponds to statement <code class="literal">(2)</code> above:</p><a id="I_programlisting5_d1e26068"/><pre class="programlisting">mov( r2, eax );     // Get the pointer to the actual object.
     pushd( [eax] );     // Push the value of the object onto the stack.
     lea( eax, v2 );     // Push the address of v2 onto the stack.
     push( eax );
     call p1;</pre></div><div class="sect3" title="5.17.3.6 HLA Hybrid Parameter-Passing Facilities"><div class="titlepage"><div><div><h3 class="title"><a id="hla_hybrid_parameter-passing_facilities"/>5.17.3.6 HLA Hybrid Parameter-Passing Facilities</h3></div></div></div><p>Like control structures, HLA provides a high-level language syntax for procedure calls that is convenient to use and easy to read. However, this high-level language syntax is sometimes inefficient and may not provide the capabilities you need (for example, you cannot specify an arithmetic expression as a value parameter as you can in high-level languages). HLA lets you overcome these limitations by writing low-level ("pure") assembly language code. Unfortunately, low-level code is harder to read and maintain than procedure calls that use high-level syntax. Furthermore, it's quite possible that HLA generates perfectly fine code for certain parameters, while only one or two parameters present a problem. Fortunately, HLA provides a hybrid syntax for procedure calls that allows you to use both high-level and low-level syntax as appropriate for a given actual parameter. This lets you use high-level syntax where appropriate and then drop down into pure assembly language to pass those special parameters that HLA's high-level language syntax cannot handle efficiently (if at all).<a class="indexterm" id="IDX-CHP-5-0162"/><a class="indexterm" id="IDX-CHP-5-0163"/></p><p>Within an actual parameter list (using the high-level language syntax), if HLA encounters <code class="literal">#{</code> followed by a sequence of statements and a closing <code class="literal">}#</code>, HLA will substitute the instructions between the braces in place of the code it would normally generate for that parameter. For example, consider the following code fragment:</p><a id="I_programlisting5_d1e26091"/><pre class="programlisting">procedure HybridCall( i:uns32; j:uns32 );
begin HybridCall;
     .
     .
     .
end HybridCall;
      .
      .
      .

     // Equivalent to HybridCall( 5, i+j );

     HybridCall
     (
          5,
          #{
               mov( i, eax );
               add( j, eax );
               push( eax );
          }#
     );</pre><p>The call to <code class="literal">HybridCall</code> immediately above is equivalent to the following "pure" assembly language code.</p><a id="I_programlisting5_d1e26098"/><pre class="programlisting">pushd( 5 );
     mov( i, eax );
     add( j, eax );
     push( eax );
     call HybridCall;</pre><p>As a second example, consider the example from the previous section:</p><a id="I_programlisting5_d1e26102"/><pre class="programlisting">procedure p2( val v2:dword; var r2:dword );
     begin p2;

          p1( v2, r2 );    // (1) First call to p1
          p1( r2, v2 );    // (2) Second call to p1

     end p2;</pre><p>HLA generates exceedingly mediocre code for the second call to <code class="literal">p1</code> in this example. If efficiency is important in the context of this procedure call, and you have a free register available, you might want to rewrite this code as follows:<sup>[<a class="footnote" href="#ftn.CHP-5-FN-25" id="CHP-5-FN-25">94</a>]</sup></p><a id="I_programlisting5_d1e26115"/><pre class="programlisting">procedure p2( val v2:dword; var r2:dword );
     begin p2;

          p1( v2, r2 );    // (1) First call to p1
          p1               // (2) Second call to p1
          (                //     This code assumes eax is free.
               #{
                    mov( r2, eax );
                    pushd( [eax] );
               }#,

               #{
                    lea( eax, v2 );
                    push( eax );
               }#
          );

     end p2;</pre><p>Note that specifying the <code class="literal">@use reg;</code> option tells HLA that the register is always available for use wherever you call a procedure. If there is one case where the procedure's invocation must preserve the specified register, then you cannot use the <code class="literal">@use</code> option to generate better code. However, you may use the hybrid parameter-passing mechanism on a case-by-base basis to improve the performance of those particular calls.</p></div><div class="sect3" title="5.17.3.7 Mixing Register and Stack-Based Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="mixing_register_and_stack-based_paramete"/>5.17.3.7 Mixing Register and Stack-Based Parameters</h3></div></div></div><p>You can mix register parameters and standard (stack-based) parameters in the same high-level procedure declaration. For example:<a class="indexterm" id="IDX-CHP-5-0164"/><a class="indexterm" id="IDX-CHP-5-0165"/><a class="indexterm" id="IDX-CHP-5-0166"/></p><a id="I_programlisting5_d1e26141"/><pre class="programlisting">procedure HasBothRegAndStack( var dest:dword in edi; count:un32 );</pre><p>When constructing the activation record, HLA ignores the parameters you pass in registers and processes only those parameters you pass on the stack. Therefore, a call to the <code class="literal">HasBothRegAndStack</code> procedure will push only a single parameter onto the stack (<code class="literal">count</code>). It will pass the <code class="literal">dest</code> parameter in the EDI register. When this procedure returns to its caller, it will remove only 4 bytes of parameter data from the stack.</p><p>Note that when you pass a parameter in a register, you should avoid specifying that same register in the <code class="literal">@use</code> procedure option. In the example above, HLA might not generate any code whatsoever at all for the <code class="literal">dest</code> parameter (because the value is already in EDI). Had you specified <code class="literal">@use edi;</code> and HLA decided it was okay to disturb EDI's value, this would destroy the parameter value in EDI; that won't actually happen in this particular example (because HLA never uses a register to pass a double-word value parameter like <code class="literal">count</code>), but keep this issue in mind.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-18" id="ftn.CHP-5-FN-18">87</a>] </sup>The choice of instructions is dictated by whether <code class="literal">x</code> is a static variable (<code class="literal">mov</code> for static objects, <code class="literal">lea</code> for other objects).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-19" id="ftn.CHP-5-FN-19">88</a>] </sup>This is especially true if the parameter list changes frequently.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-20" id="ftn.CHP-5-FN-20">89</a>] </sup>This assumes, of course, that you don't instruct HLA otherwise. It is possible to tell HLA to reverse the order of the parameters on the stack. See the electronic edition for more details.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-21" id="ftn.CHP-5-FN-21">90</a>] </sup>Note that if you use the <code class="literal">exit</code> statement to exit a procedure, you must duplicate the code to pop the register values and place this code immediately before the <code class="literal">exit</code> clause. This is a good example of a maintenance nightmare and is also a good reason why you should have only one exit point in your program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-22" id="ftn.CHP-5-FN-22">91</a>] </sup>This applies only if you use the HLA high-level-language syntax to declare and access parameters in your procedures. Of course, if you manually push the parameters yourself and you access the parameters inside the procedure using an addressing mode like <code class="literal">[ebp+8]</code>, then you can pass any size object you choose. Of course, keep in mind that most operating systems expect the stack to be dword aligned, so parameters you push should be a multiple of 4 bytes long.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-23" id="ftn.CHP-5-FN-23">92</a>] </sup>Or better yet, pass the parameter directly in the register if you are writing the procedure yourself.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-24" id="ftn.CHP-5-FN-24">93</a>] </sup>This isn't entirely true. You'll see the exception in <a class="xref" href="ch12.html" title="Chapter 12. CLASSES AND OBJECTS">Chapter 12</a>. Also, using the @use procedure option tells HLA that it's okay to modify the value in one of the registers.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-25" id="ftn.CHP-5-FN-25">94</a>] </sup>Of course, you could also use the <code class="literal">@use eax</code>; procedure option to achieve the same effect in this example.</p></div></div></div>
<div class="sect1" title="5.18 Procedure Pointers"><div class="titlepage"><div><div><h1 class="title"><a id="procedure_pointers"/>5.18 Procedure Pointers</h1></div></div></div><p>The 80x86 <code class="literal">call</code> instruction allows three basic forms: direct calls (via a procedure name), indirect calls through a 32-bit general-purpose register, and indirect calls through a double-word pointer variable. The <code class="literal">call</code> instruction supports the following (low-level) syntax:<a class="indexterm" id="IDX-CHP-5-0167"/></p><a id="I_programlisting5_d1e26184"/><pre class="programlisting">call Procname;     // Direct call to procedure Procname (or Stmt label).
call( Reg32 );     // Indirect call to procedure whose address appears
                   // in the Reg32 general-purpose 32-bit register.
call( dwordVar );  // Indirect call to the procedure whose address
                   // appears in the dwordVar double word variable.</pre><p>The first form we've been using throughout this chapter, so there is little need to discuss it here. The second form, the register indirect call, calls the procedure whose address is held in the specified 32-bit register. The address of a procedure is the byte address of the first instruction to execute within that procedure. Remember, on a Von Neumann architecture machine (like the 80x86), the system stores machine instructions in memory along with other data. The CPU fetches the instruction opcode values from memory prior to executing them. When you execute the register indirect <code class="literal">call</code> instruction, the 80x86 first pushes the return address onto the stack and then begins fetching the next opcode byte (instruction) from the address specified by the register's value.</p><p>The third form of the call instruction above fetches the address of some procedure's first instruction from a double-word variable in memory. Although this instruction suggests that the call uses the displacement-only addressing mode, you should realize that any legal memory addressing mode is legal here; for example, <code class="literal">call( procPtrTable[ebx*4] );</code> is perfectly legitimate; this statement fetches the double word from the array of double words (<code class="literal">procPtrTable</code>) and calls the procedure whose address is the value contained within that double word.</p><p>HLA treats procedure names like static objects. Therefore, you can compute the address of a procedure by using the address-of (<code class="literal">&amp;</code>) operator along with the procedure's name or by using the <code class="literal">lea</code> instruction. For example, <code class="literal">&amp;Procname</code> is the address of the very first instruction of the <code class="literal">Procname</code> procedure. So all three of the following code sequences wind up calling the <code class="literal">Procname</code> procedure:</p><a id="I_programlisting5_d1e26216"/><pre class="programlisting">call Procname;
      .
      .
      .
     mov( &amp;Procname, eax );
     call( eax );
      .
      .
      .
     lea( eax, Procname );
     call( eax );</pre><p>Because the address of a procedure fits in a 32-bit object, you can store such an address into a double-word variable; in fact, you can initialize a double-word variable with the address of a procedure using code like the following:</p><a id="I_programlisting5_d1e26220"/><pre class="programlisting">procedure p;
     begin p;
     end p;
      .
      .
      .
static
     ptrToP: dword := &amp;p;
      .
      .
      .
     call( ptrToP );  // Calls the p procedure if ptrToP has not changed.</pre><p>Because the use of procedure pointers occurs frequently in assembly language programs, HLA provides a special syntax for declaring procedure pointer variables and for calling procedures indirectly through such pointer variables. To declare a procedure pointer in an HLA program, you can use a variable declaration like the following:</p><a id="I_programlisting5_d1e26224"/><pre class="programlisting">static
     <em class="replaceable"><code>procPtr</code></em>: procedure;</pre><p>Note that this syntax uses the keyword <code class="literal">procedure</code> as a data type. It follows the variable name and a colon in one of the variable declaration sections (<code class="literal">static</code>, <code class="literal">readonly</code>, <code class="literal">storage</code>, or <code class="literal">var</code>). This sets aside exactly 4 bytes of storage for the <em class="replaceable"><code>procPtr</code></em> variable. To call the procedure whose address is held by <em class="replaceable"><code>procPtr</code></em>, you can use either of the following two forms:</p><a id="I_programlisting5_d1e26254"/><pre class="programlisting">call( <em class="replaceable"><code>procPtr</code></em> );    // Low-level syntax
     <em class="replaceable"><code>procPtr</code></em>();          // High-level language syntax</pre><p>Note that the high-level syntax for an indirect procedure call is identical to the high-level syntax for a direct procedure call. HLA can figure out whether to use a direct call or an indirect call by the type of the identifier. If you've specified a variable name, HLA assumes it needs to use an indirect call; if you specify a procedure name, HLA uses a direct call.</p><p>Like all pointer objects, you should not attempt to indirectly call a procedure through a pointer variable unless you've initialized that variable with an appropriate address. There are two ways to initialize a procedure pointer variable: <code class="literal">static</code> and <code class="literal">readonly</code> objects allow an initializer, or you can compute the address of a routine (as a 32-bit value) and store that 32-bit address directly into the procedure pointer at runtime. The following code fragment demonstrates both ways you can initialize a procedure pointer:</p><a id="I_programlisting5_d1e26272"/><pre class="programlisting">static
     ProcPointer: procedure := &amp;p;    // Initialize ProcPointer with
                                      // the address of p.
      .
      .
      .
     ProcPointer();            // First invocation calls p.

     mov( &amp;q, ProcPointer );   // Reload ProcPointer with the address of q.
      .
      .
      .
     ProcPointer();            // This invocation calls the q procedure.</pre><p>Procedure pointer variable declarations also allow the declaration of parameters. To declare a procedure pointer with parameters, you must use a declaration like the following:</p><a id="I_programlisting5_d1e26276"/><pre class="programlisting">static
     p:procedure( i:int32; c:char );</pre><p>This declaration states that <code class="literal">p</code> is a 32-bit pointer that contains the address of a procedure requiring two parameters. If desired, you could also initialize this variable <code class="literal">p</code> with the address of some procedure by using a static initializer. For example:</p><a id="I_programlisting5_d1e26286"/><pre class="programlisting">static
     p:procedure( i:int32; c:char ) := &amp;<em class="replaceable"><code>SomeProcedure</code></em>;</pre><p>Note that <em class="replaceable"><code>SomeProcedure</code></em> must be a procedure whose parameter list exactly matches <code class="literal">p</code>'s parameter list (i.e., two value parameters, the first is an <code class="literal">int32</code> parameter and the second is a <code class="literal">char</code> parameter). To indirectly call this procedure, you could use either of the following sequences:<a class="indexterm" id="IDX-CHP-5-0168"/></p><a id="I_programlisting5_d1e26310"/><pre class="programlisting">push( <em class="replaceable"><code>Value_for_i</code></em> );
     push( <em class="replaceable"><code>Value_for_c</code></em> );
     call( p );</pre><p>or</p><a id="I_programlisting5_d1e26321"/><pre class="programlisting">p( <em class="replaceable"><code>Value_for_i</code></em>, <em class="replaceable"><code>Value_for_c</code></em> );</pre><p>The high-level language syntax has the same features and restrictions as the high-level syntax for a direct procedure call. The only difference is the actual <code class="literal">call</code> instruction HLA emits at the end of the calling sequence.</p><p>Although all the examples in this section use <code class="literal">static</code> variable declarations, don't get the idea that you can declare simple procedure pointers only in the <code class="literal">static</code> or other variable declaration sections. You can also declare procedure pointer types in the <code class="literal">type</code> section, and you can declare procedure pointers as fields of a <code class="literal">record</code> or a <code class="literal">union</code>. Assuming you create a type name for a procedure pointer in the <code class="literal">type</code> section, you can even create arrays of procedure pointers. The following code fragments demonstrate some of the possibilities:</p><a id="I_programlisting5_d1e26355"/><pre class="programlisting">type
     pptr:     procedure;
     prec:     record
                    p:pptr;
                    &lt;&lt; Other fields &gt;&gt;
               endrecord;
static
     p1:pptr;
     p2:pptr[2]
     p3:prec;
      .
      .
      .
     p1();
     p2[ebx*4]();
     p3.p();</pre><p>One very important thing to keep in mind when using procedure pointers is that HLA does not (and cannot) enforce strict type checking on the pointer values you assign to a procedure pointer variable. In particular, if the parameter lists do not agree between the declarations of the pointer variable and the procedure whose address you assign to the pointer variable, the program will probably crash when you attempt to call the mismatched procedure indirectly through the pointer using the high-level syntax. Like the low-level "pure" procedure calls, it is your responsibility to ensure that the proper number and types of parameters are on the stack prior to the call.</p></div>
<div class="sect1" title="5.19 Procedural Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="procedural_parameters"/>5.19 Procedural Parameters</h1></div></div></div><p>One place where procedure pointers are quite invaluable is in parameter lists. Selecting one of several procedures to call by passing the address of some procedure is a common operation. Therefore, HLA lets you declare procedure pointers as parameters.</p><p>There is nothing special about a procedure parameter declaration. It looks exactly like a procedure variable declaration except it appears within a parameter list rather than within a variable declaration section. The following are some typical procedure prototypes that demonstrate how to declare such parameters:</p><a id="I_programlisting5_d1e26366"/><pre class="programlisting">procedure p1( procparm: procedure ); forward;
     procedure p2( procparm: procedure( i:int32 ) ); forward;
     procedure p3( val procparm: procedure ); forward;</pre><p>The last example above is identical to the first. It does point out, though, that you generally pass procedural parameters by value. This may seem counterintuitive because procedure pointers are addresses and you will need to pass an address as the actual parameter; however, a pass-by-reference procedure parameter means something else entirely. Consider the following (legal!) declaration:<a class="indexterm" id="IDX-CHP-5-0169"/></p><a id="I_programlisting5_d1e26377"/><pre class="programlisting">procedure p4( var procPtr:procedure ); forward;</pre><p>This declaration tells HLA that you are passing a procedure <span class="emphasis"><em>variable</em></span> by reference to <code class="literal">p4</code>. The address HLA expects must be the address of a procedure pointer variable, not a procedure.</p><p>When passing a procedure pointer by value, you may specify either a procedure variable (whose value HLA passes to the actual procedure) or a procedure pointer constant. A procedure pointer constant consists of the address-of operator (<code class="literal">&amp;</code>) immediately followed by a procedure name. Passing procedure constants is probably the most convenient way to pass procedural parameters. For example, the following calls to the <code class="literal">Plot</code> routine might plot out the function passed as a parameter from −2 to +2.</p><a id="I_programlisting5_d1e26395"/><pre class="programlisting">Plot( &amp;sineFunc );
     Plot( &amp;cosFunc  );
     Plot( &amp;tanFunc  );</pre><p>Note that you cannot pass a procedure as a parameter by simply specifying the procedure's name. That is, <code class="literal">Plot( sineFunc )</code>; will not work. Simply specifying the procedure name doesn't work because HLA will attempt to directly call the procedure whose name you specify (remember, a procedure name inside a parameter list invokes instruction composition). If you did not specify a parameter list—or at least an empty pair of parentheses—after the parameter/procedure's name, HLA would generate a syntax error message. Moral of the story: Don't forget to preface procedure parameter constant names with the address-of operator (<code class="literal">&amp;</code>).</p></div>
<div class="sect1" title="5.20 Untyped Reference Parameters"><div class="titlepage"><div><div><h1 class="title"><a id="untyped_reference_parameters"/>5.20 Untyped Reference Parameters</h1></div></div></div><p>Sometimes you will want to write a procedure to which you pass a generic memory object by reference without regard to the type of that memory object. A classic example is a procedure that zeros out some data structure. Such a procedure might have the following prototype:</p><a id="I_programlisting5_d1e26411"/><pre class="programlisting">procedure ZeroMem( var mem:byte; count:uns32 );</pre><p>This procedure would zero out <code class="literal">count</code> bytes starting at the address the first parameter specifies. The problem with this procedure prototype is that HLA will complain if you attempt to pass anything other than a byte object as the first parameter. Of course, you can overcome this problem using type coercion like the following, but if you call this procedure several times with a lot of different data types, then the following coercion operator is rather tedious to use:</p><a id="I_programlisting5_d1e26418"/><pre class="programlisting">ZeroMem( (type byte MyDataObject), @size( MyDataObject ));</pre><p>Of course, you can always use hybrid parameter passing or manually push the parameters yourself, but these solutions are even more tedious than using the type coercion operation. Fortunately, HLA provides a convenient solution: untyped reference parameters.<a class="indexterm" id="IDX-CHP-5-0170"/></p><p>Untyped reference parameters are exactly that—pass-by-reference parameters for which HLA doesn't bother to compare the type of the actual parameter against the type of the formal parameter. With an untyped reference parameter, the call to <code class="literal">ZeroMem</code> above would take the following form:</p><a id="I_programlisting5_d1e26430"/><pre class="programlisting">ZeroMem( MyDataObject, @size( MyDataObject ));</pre><p><code class="literal">MyDataObject</code> could be any type, and multiple calls to <code class="literal">ZeroMem</code> could pass different typed objects without any objections from HLA.</p><p>To declare an untyped reference parameter, you specify the parameter using the normal syntax except that you use the reserved word <code class="literal">var</code> in place of the parameter's type. This <code class="literal">var</code> keyword tells HLA that any variable object is legal for that parameter. Note that you must pass untyped reference parameters by reference, so the <code class="literal">var</code> keyword must precede the parameter's declaration as well. Here's the correct declaration for the <code class="literal">ZeroMem</code> procedure using an untyped reference parameter:</p><a id="I_programlisting5_d1e26453"/><pre class="programlisting">procedure ZeroMem( var mem:var; count:uns32 );</pre><p>With this declaration, HLA will compute the address of whatever memory object you pass as an actual parameter to <code class="literal">ZeroMem</code> and pass this on the stack.</p></div>
<div class="sect1" title="5.21 Managing Large Programs"><div class="titlepage"><div><div><h1 class="title"><a id="managing_large_programs"/>5.21 Managing Large Programs</h1></div></div></div><p>Most assembly language source files are not standalone programs. In general, you will call various standard library or other routines that are not defined in your main program. For example, you've probably noticed by now that the 80x86 doesn't provide any machine instructions like <code class="literal">read</code>, <code class="literal">write</code>, or <code class="literal">put</code> for doing I/O operations. Of course, you can write your own procedures to accomplish this. Unfortunately, writing such routines is a complex task, and beginning assembly language programmers are not ready for such tasks. That's where the HLA Standard Library comes in. This is a package of procedures you can call to perform simple I/O operations like <code class="literal">stdout.put</code>.<a class="indexterm" id="IDX-CHP-5-0171"/></p><p>The HLA Standard Library contains hundreds of thousands of lines of source code. Imagine how difficult programming would be if you had to merge these hundreds of thousands of lines of code into your simple programs! Imagine how slow compiling your programs would be if you had to compile those hundreds of thousands of lines with each program you write. Fortunately, you don't have to do this.</p><p>For small programs, working with a single source file is fine. For large programs, this gets very cumbersome (consider the example above of having to include the entire HLA Standard Library into each of your programs). Furthermore, once you've debugged and tested a large section of your code, continuing to assemble that same code when you make a small change to some other part of your program is a waste of time. The HLA Standard Library, for example, takes several minutes to assemble, even on a fast machine. Imagine having to wait 20 or 30 minutes on a fast PC to assemble a program to which you've made a one-line change!<a class="indexterm" id="IDX-CHP-5-0172"/></p><p>As for high-level languages, the solution is <span class="emphasis"><em>separate compilation</em></span>. First, you break up your large source files into manageable chunks. Then you compile the separate files into object code modules. Finally, you link the object modules together to form a complete program. If you need to make a small change to one of the modules, you only need to reassemble that one module; you do not need to reassemble the entire program.<a class="indexterm" id="IDX-CHP-5-0173"/></p><p>The HLA Standard Library works in precisely this way. The Standard Library is already compiled and ready to use. You simply call routines in the Standard Library and link your code with the Standard Library using a <span class="emphasis"><em>linker</em></span> program. This saves considerable time when developing a program that uses the Standard Library code. Of course, you can easily create your own object modules and link them together with your code. You could even add new routines to the Standard Library so they will be available for use in future programs you write.<a class="indexterm" id="IDX-CHP-5-0174"/></p><p>"Programming in the large" is the term software engineers have coined to describe the processes, methodologies, and tools for handling the development of large software projects. While everyone has their own idea of what "large" is, separate compilation is one of the more popular techniques that support "programming in the large." The following sections describe the tools HLA provides for separate compilation and how to effectively employ these tools in your programs.<a class="indexterm" id="IDX-CHP-5-0175"/></p></div>
<div class="sect1" title="5.22 The #include Directive"><div class="titlepage"><div><div><h1 class="title"><a id="the_number_symble_include_directive"/>5.22 The #include Directive</h1></div></div></div><p>The <code class="literal">#include</code> directive, when encountered in a source file, switches program input from the current file to the file specified in the parameter list of the <code class="literal">#include</code> directive. This allows you to construct text files containing common constants, types, source code, and other HLA items and include such files into the assembly of several separate programs. The syntax for the <code class="literal">#include</code> directive is:<a class="indexterm" id="IDX-CHP-5-0176"/><a class="indexterm" id="IDX-CHP-5-0177"/><a class="indexterm" id="IDX-CHP-5-0178"/><a class="indexterm" id="IDX-CHP-5-0179"/></p><a id="I_programlisting5_d1e26537"/><pre class="programlisting">#include( "<em class="replaceable"><code>Filename</code></em>" )</pre><p><em class="replaceable"><code>Filename</code></em> must be a valid filename. HLA merges the specified file into the compilation at the point of the <code class="literal">#include</code> directive. Note that you can nest <code class="literal">#include</code> statements inside files you include. That is, a file being included into another file during assembly may itself include a third file. In fact, the <span class="emphasis"><em>stdlib.hhf</em></span> header file you see in most example programs is really nothing more than a bunch of <code class="literal">#include</code> statements (see <a class="xref" href="ch05s22.html#the_original_stdlib.hhf_header_file" title="Example 5-18. The original stdlib.hhf header file">Example 5-18</a> for the original <span class="emphasis"><em>stdlib.hhf</em></span> source code; note that this file is considerably different today, but the concept is still the same).</p><div class="example"><a id="the_original_stdlib.hhf_header_file"/><p class="title">Example 5-18. The original <span class="emphasis"><em>stdlib.hhf</em></span> header file</p><div class="example-contents"><pre class="programlisting">#include( "hla.hhf" )
#include( "x86.hhf" )
#include( "misctypes.hhf" )
#include( "hll.hhf" )

#include( "excepts.hhf" )
#include( "memory.hhf" )

#include( "args.hhf" )
#include( "conv.hhf" )
#include( "strings.hhf" )
#include( "cset.hhf" )
#include( "patterns.hhf" )
#include( "tables.hhf" )
#include( "arrays.hhf" )
#include( "chars.hhf" )

#include( "math.hhf" )
#include( "rand.hhf" )

#include( "stdio.hhf" )
#include( "stdin.hhf" )
#include( "stdout.hhf" )</pre></div></div><p>By including <span class="emphasis"><em>stdlib.hhf</em></span> in your source code, you automatically include all the HLA library modules. It's often more efficient (in terms of compile time and size of code generated) to provide only those <code class="literal">#include</code> statements for the modules you actually need in your program. However, including <span class="emphasis"><em>stdlib.hhf</em></span> is extremely convenient and takes up less space in this text, which is why most programs appearing in this text use <span class="emphasis"><em>stdlib.hhf</em></span>.</p><p>Note that the <code class="literal">#include</code> directive does not need to end with a semicolon. If you put a semicolon after the <code class="literal">#include</code>, that semicolon becomes part of the source file and is the first character following the included source during compilation. HLA generally allows spare semicolons in various parts of the program, so you will sometimes see an <code class="literal">#include</code> statement ending with a semicolon. In general, though, you should not get in the habit of putting semicolons after <code class="literal">#include</code> statements because there is the slight possibility this could create a syntax error in certain circumstances.</p><p>Using the <code class="literal">#include</code> directive by itself does not provide separate compilation. You <span class="emphasis"><em>could</em></span> use the <code class="literal">#include</code> directive to break up a large source file into separate modules and join these modules together when you compile your file. The following example would include the <code class="literal">printf.hla</code> and <code class="literal">putc.hla</code> files during the compilation of your program:</p><a id="I_programlisting5_d1e26617"/><pre class="programlisting">#include( "printf.hla" )
     #include( "putc.hla" )</pre><p>Now your program <code class="literal">will</code> benefit from the modularity gained by this approach. Alas, you will not save any development time. The <code class="literal">#include</code> directive inserts the source file at the point of the <code class="literal">#include</code> during compilation, exactly as though you had typed that code yourself. HLA still has to compile the code, and that takes time. Were you to include all the files for the Standard Library routines in this manner, your compilations would take <span class="emphasis"><em>forever</em></span>.</p><p>In general, you should <span class="emphasis"><em>not</em></span> use the <code class="literal">#include</code> directive to include source code as shown above.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-26" id="CHP-5-FN-26">95</a>]</sup> Instead, you should use the <code class="literal">#include</code> directive to insert a common set of constants, types, external procedure declarations, and other such items into a program. Typically an assembly language include file does <span class="emphasis"><em>not</em></span> contain any machine code (outside of a macro; see <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a> for details). The purpose of using <code class="literal">#include</code> files in this manner will become clearer after you see how the external declarations work.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-26" id="ftn.CHP-5-FN-26">95</a>] </sup>There is nothing wrong with this, other than the fact that it does not take advantage of separate compilation.</p></div></div></div>
<div class="sect1" title="5.23 Ignoring Duplicate #include Operations"><div class="titlepage"><div><div><h1 class="title"><a id="ignoring_duplicate_number_symble_include"/>5.23 Ignoring Duplicate #include Operations</h1></div></div></div><p>As you begin to develop sophisticated modules and libraries, you eventually discover a big problem: Some header files will need to include other header files (e.g., the <span class="emphasis"><em>stdlib.hhf</em></span> header file includes all the other Standard Library header files). Well, this isn't actually a big problem, but a problem will occur when one header file includes another, and that second header file includes another, and that third header file includes another, and . . . that last header file includes the first header file. Now <span class="emphasis"><em>this</em></span> is a big problem.</p><p>There are two problems with a header file indirectly including itself. First, this creates an infinite loop in the compiler. The compiler will happily go on about its business including all these files over and over again until it runs out of memory or some other error occurs. Clearly this is not a good thing. The second problem that occurs (usually before the first problem) is that the second time HLA includes a header file, it starts complaining bitterly about duplicate symbol definitions. After all, the first time it reads the header file it processes all the declarations in that file; the second time around it views all those symbols as duplicate symbols.<a class="indexterm" id="IDX-CHP-5-0180"/><a class="indexterm" id="IDX-CHP-5-0181"/></p><p>HLA provides a special include directive that eliminates this problem: <code class="literal">#includeonce</code>. You use this directive exactly like you use the <code class="literal">#include</code> directive. For example:</p><a id="I_programlisting5_d1e26684"/><pre class="programlisting">#includeonce( "myHeaderFile.hhf" )</pre><p>If <span class="emphasis"><em>myHeaderFile.hhf</em></span> directly or indirectly includes itself (with a <code class="literal">#includeonce</code> directive), then HLA will ignore the new request to include the file. Note, however, that if you use the <code class="literal">#include</code> directive, rather than <code class="literal">#includeonce</code>, HLA will include the file a second time. This was done in case you really do need to include a header file twice.</p><p>The bottom line is this: You should always use the <code class="literal">#includeonce</code> directive to include header files you've created. In fact, you should get in the habit of always using <code class="literal">#includeonce</code>, even for header files created by others (the HLA Standard Library already has provisions to prevent recursive includes, so you don't have to worry about using <code class="literal">#includeonce</code> with the Standard Library header files).</p><p>There is another technique you can use to prevent recursive includes—using conditional compilation. <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a>, the chapter on macros and the HLA Compile-Time Language, discusses this option.</p></div>
<div class="sect1" title="5.24 Units and the external Directive"><div class="titlepage"><div><div><h1 class="title"><a id="units_and_the_external_directive"/>5.24 Units and the external Directive</h1></div></div></div><p>Technically, the <code class="literal">#include</code> directive provides you with all the facilities you need to create modular programs. You can create several modules, each containing some specific routine, and include those modules, as necessary, in your assembly language programs using <code class="literal">#include</code>. However, HLA provides a better way: external and public symbols.<a class="indexterm" id="IDX-CHP-5-0182"/></p><p>One major problem with the <code class="literal">#include</code> mechanism is that once you've debugged a routine, including it into a compilation still wastes time because HLA must recompile bug-free code every time you assemble the main program. A much better solution would be to preassemble the debugged modules and link the object code modules together. This is what the <code class="literal">external</code> directive allows you to do.</p><p>To use the <code class="literal">external</code> facilities, you must create at least two source files. One file contains a set of variables and procedures used by the second. The second file uses those variables and procedures without knowing how they're implemented. The only problem is that if you create two separate HLA programs, the linker will get confused when you try to combine them. This is because both HLA programs have their own main program. Which main program does the OS run when it loads the program into memory? To resolve this problem, HLA uses a different type of compilation module, the <code class="literal">unit</code>, to compile programs without a main program. The syntax for an HLA <code class="literal">unit</code> is actually simpler than that for an HLA program; it takes the following form:</p><a id="I_programlisting5_d1e26750"/><pre class="programlisting">unit <em class="replaceable"><code>unitname</code></em>;

     &lt;&lt; declarations &gt;&gt;

end <em class="replaceable"><code>unitname</code></em>;</pre><p>With one exception (the <code class="literal">var</code> section), anything that can go in the declaration section of an HLA <code class="literal">program</code> can go into the declaration section of an HLA <code class="literal">unit</code>. Notice that a <code class="literal">unit</code> does not have a <code class="literal">begin</code> clause and there are no program statements in the unit;<sup>[<a class="footnote" href="#ftn.CHP-5-FN-27" id="CHP-5-FN-27">96</a>]</sup> a unit contains only declarations.<a class="indexterm" id="IDX-CHP-5-0183"/></p><p>In addition to the fact that a unit does not contain a main program section, there is one other difference between units and programs. Units cannot have a <code class="literal">var</code> section. This is because the <code class="literal">var</code> section declares automatic variables that are local to the main program's source code. Because there is no "main program" associated with a unit, <code class="literal">var</code> sections are illegal.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-28" id="CHP-5-FN-28">97</a>]</sup></p><p>To demonstrate, consider the two modules in <a class="xref" href="ch05s24.html#example_of_a_simple_hla_unit" title="Example 5-19. Example of a simple HLA unit">Example 5-19</a> and <a class="xref" href="ch05s24.html#main_program_that_references_external_ob" title="Example 5-20. Main program that references external objects">Example 5-20</a>.</p><div class="example"><a id="example_of_a_simple_hla_unit"/><p class="title">Example 5-19. Example of a simple HLA unit</p><div class="example-contents"><pre class="programlisting">unit Number1;

static
    Var1:   uns32;
    Var2:   uns32;

    procedure Add1and2;
    begin Add1and2;

        push( eax );
        mov( Var2, eax );
        add( eax, Var1 );

    end Add1and2;

end Number1;</pre></div></div><div class="example"><a id="main_program_that_references_external_ob"/><p class="title">Example 5-20. Main program that references external objects</p><div class="example-contents"><pre class="programlisting">program main;
#include( "stdlib.hhf" );

begin main;

    mov( 2, Var2 );
    mov( 3, Var1 );
    Add1and2();
    stdout.put( "Var1=", Var1, nl );

end main;</pre></div></div><p>The main program references <code class="literal">Var1</code>, <code class="literal">Var2</code>, and <code class="literal">Add1and2</code>, yet these symbols are external to this program (they appear in unit <code class="literal">Number1</code>). If you attempt to compile the main program as it stands, HLA will complain that these three symbols are undefined.<a class="indexterm" id="IDX-CHP-5-0184"/><a class="indexterm" id="IDX-CHP-5-0185"/></p><p>Therefore, you must declare them external with the <code class="literal">external</code> option. An external procedure declaration looks just like a forward declaration except you use the reserved word <code class="literal">external</code> rather than <code class="literal">forward</code>. To declare external static variables, simply follow those variables' declarations with the reserved word <code class="literal">external</code>. The program in <a class="xref" href="ch05s24.html#modified_main_program_with_external_decl" title="Example 5-21. Modified main program with external declarations">Example 5-21</a> is a modification to the program in <a class="xref" href="ch05s24.html#main_program_that_references_external_ob" title="Example 5-20. Main program that references external objects">Example 5-20</a> that includes the external declarations.</p><div class="example"><a id="modified_main_program_with_external_decl"/><p class="title">Example 5-21. Modified main program with external declarations</p><div class="example-contents"><pre class="programlisting">program main;
#include( "stdlib.hhf" );

    procedure Add1and2; external;

static
    Var1: uns32; external;
    Var2: uns32; external;

begin main;

    mov( 2, Var2 );
    mov( 3, Var1 );
    Add1and2();
    stdout.put( "Var1=", Var1, nl );

end main;</pre></div></div><p>If you attempt to compile this second version of <code class="literal">main</code> using the typical HLA compilation command <code class="literal">HLA main2.hla</code>, you will be somewhat disappointed. This program will actually compile without error. However, when HLA attempts to link this code it will report that the symbols <code class="literal">Var1</code>, <code class="literal">Var2</code>, and <code class="literal">Add1and2</code> are undefined. This happens because you haven't compiled and linked in the associated unit with this main program. Before you try that and discover that it still doesn't work, you should know that all symbols in a unit, by default, are <span class="emphasis"><em>private</em></span> to that unit. This means that those symbols are inaccessible in code outside that unit unless you explicitly declare those symbols as <span class="emphasis"><em>public</em></span> symbols. To declare symbols as public, you simply put external declarations for those symbols in the unit before the actual symbol declarations. If an external declaration appears in the same source file as the actual declaration of a symbol, HLA assumes that the name is needed externally and makes that symbol a public (rather than private) symbol. The unit in <a class="xref" href="ch05s24.html#correct_number1_unit_with_external_decla" title="Example 5-22. Correct Number1 unit with external declarations">Example 5-22</a> is a correction to the <code class="literal">Number1</code> unit that properly declares the external objects.</p><div class="example"><a id="correct_number1_unit_with_external_decla"/><p class="title">Example 5-22. Correct <code class="literal">Number1</code> unit with external declarations</p><div class="example-contents"><pre class="programlisting">unit Number1;

static
    Var1:   uns32; external;
    Var2:   uns32; external;

    procedure Add1and2; external;

static
    Var1:   uns32;
    Var2:   uns32;


    procedure Add1and2;
    begin Add1and2;

        push( eax );
        mov( Var2, eax );
        add( eax, Var1 );

    end Add1and2;

end Number1;</pre></div></div><p>It may seem redundant declaring these symbols twice as occurs in <a class="xref" href="ch05s24.html#modified_main_program_with_external_decl" title="Example 5-21. Modified main program with external declarations">Example 5-21</a> and <a class="xref" href="ch05s24.html#correct_number1_unit_with_external_decla" title="Example 5-22. Correct Number1 unit with external declarations">Example 5-22</a>, but you'll soon see that you don't normally write the code this way.</p><p>If you attempt to compile the <code class="literal">main</code> program or the <code class="literal">Number1</code> unit using the typical HLA statement, that is,</p><a id="I_programlisting5_d1e26912"/><pre class="programlisting">HLA main2.hla
HLA unit2.hla</pre><p>you'll quickly discover that the linker still returns errors. It returns an error on the compilation of <span class="emphasis"><em>main2.hla</em></span> because you still haven't told HLA to link in the object code associated with <span class="emphasis"><em>unit2.hla</em></span>. Likewise, the linker complains if you attempt to compile <code class="literal">unit2.hla</code> by itself because it can't find a main program. The simple solution is to compile both of these modules together with the following single command:</p><a id="I_programlisting5_d1e26925"/><pre class="programlisting">HLA main2.hla unit2.hla</pre><p>This command will properly compile both modules and link together their object code.</p><p>Unfortunately, the command above defeats one of the major benefits of separate compilation. When you issue this command it will compile both <code class="literal">main2</code> and <code class="literal">unit2</code> prior to linking them together. Remember, a major reason for separate compilation is to reduce compilation time on large projects. While the above command is convenient, it doesn't achieve this goal.</p><p>To separately compile the two modules you must run HLA separately on them. Of course, you saw earlier that attempting to compile these modules separately produced linker errors. To get around this problem, you need to compile the modules without linking them. The <code class="literal">-c</code> (compile-only) HLA command-line option achieves this. To compile the two source files without running the linker, you would use the following commands:</p><a id="I_programlisting5_d1e26943"/><pre class="programlisting">HLA -c main2.hla
HLA -c unit2.hla</pre><p>This produces two object code files, <code class="literal">main2.obj</code> and <code class="literal">unit2.obj</code>, that you can link together to produce a single executable. You could run the linker program directly, but an easier way is to use the HLA compiler to link the object modules together for you:</p><a id="I_programlisting5_d1e26953"/><pre class="programlisting">HLA main2.obj unit2.obj</pre><p>Under Windows, this command produces an executable file named <span class="emphasis"><em>main2.exe</em></span>;<sup>[<a class="footnote" href="#ftn.CHP-5-FN-29" id="CHP-5-FN-29">98</a>]</sup> under Linux, Mac OS X, and FreeBSD this command produces a file named <span class="emphasis"><em>main2</em></span>. You could also type the following command to compile the main program and link it with a previously compiled <span class="emphasis"><em>unit2</em></span> object module:</p><a id="I_programlisting5_d1e26973"/><pre class="programlisting">HLA main2.hla unit2.obj</pre><p>In general, HLA looks at the suffixes of the filenames following the HLA commands. If the filename doesn't have a suffix, HLA assumes it to be <span class="emphasis"><em>.HLA</em></span>. If the filename has a suffix, then HLA will do the following with the file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the suffix is <span class="emphasis"><em>.HLA</em></span>, HLA will compile the file with the HLA compiler.</p></li><li class="listitem"><p>If the suffix is <span class="emphasis"><em>.ASM</em></span>, HLA will assemble the file with MASM (or some other default assembler such as FASM, NASM, or TASM under Windows) or Gas (Linux/Mac OS X/FreeBSD).</p></li><li class="listitem"><p>If the suffix is .<span class="emphasis"><em>OBJ</em></span> or .<span class="emphasis"><em>LIB</em></span> (Windows), or .<span class="emphasis"><em>o</em></span> or .<span class="emphasis"><em>a</em></span> (Linux/Mac OS X/FreeBSD), then HLA will link that module with the rest of the compilation.</p></li></ul></div><div class="sect2" title="5.24.1 Behavior of the external Directive"><div class="titlepage"><div><div><h2 class="title"><a id="behavior_of_the_external_directive"/>5.24.1 Behavior of the external Directive</h2></div></div></div><p>Whenever you declare a symbol using the <code class="literal">external</code> directive, keep in mind several limitations of <code class="literal">external</code> objects:<a class="indexterm" id="IDX-CHP-5-0186"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Only one <code class="literal">external</code> declaration of an object may appear in a given source file. That is, you cannot define the same symbol twice as an <code class="literal">external</code> object.</p></li><li class="listitem"><p>Only <code class="literal">procedure</code>, <code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code> variable objects can be external. <code class="literal">var</code>, <code class="literal">type</code>, <code class="literal">const</code>, and parameter objects cannot be external.</p></li><li class="listitem"><p><code class="literal">external</code> objects must appear at the global declaration level. You cannot declare <code class="literal">external</code> objects within a procedure or other nested structure.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-30" id="CHP-5-FN-30">99</a>]</sup></p></li><li class="listitem"><p><code class="literal">external</code> objects publish their name globally. Therefore, you must carefully choose the names of your <code class="literal">external</code> objects so they do not conflict with other symbols.</p></li></ul></div><p>This last point is especially important to keep in mind. HLA links your modules using a linker. At each step in this process, your choice of external names could create problems for you.</p><p>Consider the following HLA external/public declaration:</p><a id="I_programlisting5_d1e27080"/><pre class="programlisting">static
          extObj:          uns32; external;
          extObj:          uns32;
          localObject:     uns32;</pre><p>When you compile a program containing these declarations, HLA automatically generates a "munged" name for the <code class="literal">localObject</code> variable that probably won't ever have any conflicts with system-global external symbols.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-31" id="CHP-5-FN-31">100</a>]</sup> Whenever you declare an external symbol, however, HLA uses the object's name as the default external name. This can create some problems if you inadvertently use some global name as your variable name.</p><p>To get around the problem of conflicting external names, HLA supports an additional syntax for the <code class="literal">external</code> option that lets you explicitly specify the external name. The following example demonstrates this extended syntax:</p><a id="I_programlisting5_d1e27102"/><pre class="programlisting">static
     c: char; external( "var_c" );
     c: char;</pre><p>If you follow the <code class="literal">external</code> keyword with a string constant enclosed by parentheses, HLA will continue to use the declared name (<code class="literal">c</code> in this example) as the identifier within your HLA source code. Externally (i.e., in the assembly code) HLA will substitute the name <code class="literal">var_c</code> whenever you reference <code class="literal">c</code>. This feature helps you avoid problems with the misuse of assembler reserved words, or other global symbols, in your HLA programs.<a class="indexterm" id="IDX-CHP-5-0187"/></p><p>You should also note that this feature of the <code class="literal">external</code> option lets you create <span class="emphasis"><em>aliases</em></span>. For example, you may want to refer to an object by the name <code class="literal">StudentCount</code> in one module while referring to the object as <code class="literal">PersonCount</code> in another module (you might do this because you have a general library module that deals with counting people and you want to use the object in a program that deals only with students). Using a declaration like the following lets you do this:<a class="indexterm" id="IDX-CHP-5-0188"/></p><a id="I_programlisting5_d1e27139"/><pre class="programlisting">static
     StudentCount: uns32; external( "PersonCount" );</pre><p>Of course, you've already seen some of the problems you might encounter when you start creating aliases. So you should use this capability sparingly in your programs. Perhaps a more reasonable use of this feature is to simplify certain OS APIs. For example, the Win32 API uses some really long names for certain procedure calls. You can use the <code class="literal">external</code> directive to provide a more meaningful name than the standard one the operating system specifies.</p></div><div class="sect2" title="5.24.2 Header Files in HLA"><div class="titlepage"><div><div><h2 class="title"><a id="header_files_in_hla"/>5.24.2 Header Files in HLA</h2></div></div></div><p>HLA's technique of using the same <code class="literal">external</code> declaration to define public as well as external symbols may seem somewhat counterintuitive. Why not use a <code class="literal">public</code> reserved word for public symbols and the <code class="literal">external</code> keyword for external definitions? Well, as counterintuitive as HLA's external declarations may seem, they are founded on decades of solid experience with the C/C++ programming language that uses a similar approach to public and external symbols.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-32" id="CHP-5-FN-32">101</a>]</sup> Combined with a <span class="emphasis"><em>header file</em></span>, HLA's external declarations make large-program maintenance a breeze.<a class="indexterm" id="IDX-CHP-5-0189"/></p><p>An important benefit of the <code class="literal">external</code> directive (versus separate <code class="literal">public</code> and <code class="literal">external</code> directives) is that it lets you minimize duplication of effort in your source files. Suppose, for example, you want to create a module with a bunch of support routines and variables for use in several different programs (e.g., the HLA Standard Library). In addition to sharing some routines and some variables, suppose you want to share constants, types, and other items as well.</p><p>The <code class="literal">#include</code> file mechanism provides a perfect way to handle this. You simply create a <code class="literal">#include</code> file containing the constants, macros, and <code class="literal">external</code> definitions and include this file in the module that implements your routines and in the modules that use those routines (see <a class="xref" href="ch05s24.html#using_header_files_in_hla_programs" title="Figure 5-10. Using header files in HLA programs">Figure 5-10</a>).</p><div class="figure"><a id="using_header_files_in_hla_programs"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e27203"/><img alt="Using header files in HLA programs" src="tagoreillycom20100401nostarchimages578019.png"/></div></div><p class="title">Figure 5-10. Using header files in HLA programs</p></div><p>A typical header file contains only <code class="literal">const</code>, <code class="literal">val</code>, <code class="literal">type</code>, <code class="literal">static</code>, <code class="literal">readonly</code>, <code class="literal">storage</code>, and procedure prototypes (plus a few others we haven't look at yet, like macros). Objects in the <code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code> sections, as well as all procedure declarations, are always <code class="literal">external</code> objects. In particular, you should not put any <code class="literal">var</code> objects in a header file, nor should you put any nonexternal variables or procedure bodies in a header file. If you do, HLA will make duplicate copies of these objects in the different source files that include the header file. Not only will this make your programs larger, but it will cause them to fail under certain circumstances. For example, you generally put a variable in a header file so you can share the value of that variable among several different modules. However, if you fail to declare that symbol as external in the header file and just put a standard variable declaration there, each module that includes the source file will get its own separate variable—the modules will not share a common variable.</p><p>If you create a standard header file, containing <code class="literal">const</code>, <code class="literal">val</code>, and <code class="literal">type</code> declarations and external objects, you should always be sure to include that file in the declaration section of all modules that need the definitions in the header file. Generally, HLA programs include all their header files in the first few statements after the <code class="literal">program</code> or <code class="literal">unit</code> header.</p><p>This text adopts the HLA Standard Library convention of using an <span class="emphasis"><em>.hhf</em></span> suffix for HLA header files (<span class="emphasis"><em>hhf</em></span> stands for <span class="emphasis"><em>HLA header file</em></span>).</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-27" id="ftn.CHP-5-FN-27">96</a>] </sup>Of course, units may contain procedures and those procedures may have statements, but the unit itself does not have any executable instructions associated with it.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-28" id="ftn.CHP-5-FN-28">97</a>] </sup>Procedures in the unit may have their own <code class="literal">var</code> sections, but the procedure's declaration section is separate from the unit's declaration section.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-29" id="ftn.CHP-5-FN-29">98</a>] </sup>If you want to explicitly specify the name of the output file, HLA provides a command-line option to achieve this. You can get a menu of all legal command-line options by entering the command <code class="literal">HLA -?</code>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-30" id="ftn.CHP-5-FN-30">99</a>] </sup>There are a few exceptions, but you cannot declare external procedures or variables except at the global level.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-31" id="ftn.CHP-5-FN-31">100</a>] </sup>Typically, HLA creates a name like <span class="emphasis"><em>001A_localObject</em></span> out of <span class="emphasis"><em>localObject</em></span>. This is a legal MASM identifier, but it is not likely it will conflict with any other global symbols when HLA compiles the program with MASM.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-32" id="ftn.CHP-5-FN-32">101</a>] </sup>Actually, C/C++ is a little different. All global symbols in a module are assumed to be public unless explicitly declared private. HLA's approach (forcing the declaration of public items via <code class="literal">external</code>) is a little safer.</p></div></div></div>
<div class="sect1" title="5.25 Namespace Pollution"><div class="titlepage"><div><div><h1 class="title"><a id="namespace_pollution"/>5.25 Namespace Pollution</h1></div></div></div><p>One problem with creating libraries with a lot of different modules is namespace pollution. A typical library module will have a <code class="literal">#include</code> file associated with it that provides external definitions for all the routines, constants, variables, and other symbols provided in the library. Whenever you want to use some routines or other objects from the library, you would typically <code class="literal">#include</code> the library's header file in your project. As your libraries get larger and you add declarations in the header file, it becomes likely that the names you've chosen for your library's identifiers will conflict with names you want to use in your current project. This is known as <span class="emphasis"><em>namespace pollution</em></span>: library header files pollute the namespace with names you typically don't need in order to gain easy access to the few routines in the library you actually use. Most of the time those names don't harm anything—unless you want to use those names for your own purposes.<a class="indexterm" id="IDX-CHP-5-0190"/></p><p>HLA requires that you declare all external symbols at the global (<code class="literal">program/unit</code>) level. You cannot, therefore, include a header file with external declarations within a procedure. Thus, there will be no naming conflicts between external library symbols and symbols you declare locally within a procedure; the conflicts will occur only between the external symbols and your global symbols. While this is a good argument for avoiding global symbols as much as possible in your program, the fact remains that most symbols in an assembly language program will have global scope. So another solution is necessary.<a class="indexterm" id="IDX-CHP-5-0191"/><a class="indexterm" id="IDX-CHP-5-0192"/><a class="indexterm" id="IDX-CHP-5-0193"/></p><p>HLA's solution is to put most of the library names in a <code class="literal">namespace</code> declaration section. A <code class="literal">namespace</code> declaration encapsulates all declarations and exposes only a single name (the <code class="literal">namespace</code> identifier) at the global level. You access the names within the namespace by using the familiar dot notation (see the discussion of namespaces in <a class="xref" href="ch04s34.html" title="4.34 Namespaces">4.34 Namespaces</a>). This reduces the effect of namespace pollution from many dozens or hundreds of names down to a single name.<a class="indexterm" id="IDX-CHP-5-0194"/></p><p>Of course, one disadvantage of using a <code class="literal">namespace</code> declaration is that you have to type a longer name in order to reference a particular identifier in that namespace (that is, you have to type the <code class="literal">namespace</code> identifier, a period, and then the specific identifier you wish to use). For a few identifiers you use frequently, you might elect to leave those identifiers outside of any <code class="literal">namespace</code> declaration. For example, the HLA Standard Library does not define the symbol <code class="literal">nl</code> within a namespace. However, you want to minimize such declarations in your libraries to avoid conflicts with names in your own programs. Often, you can choose a <code class="literal">namespace</code> identifier to complement your routine names. For example, the HLA Standard Library's string copy routine was named after the equivalent C Standard Library function, <code class="literal">strcpy</code>. HLA's version is <code class="literal">str.cpy</code>. The actual function name is <code class="literal">cpy</code>; it happens to be a member of the <code class="literal">str namespace</code>, hence the full name <code class="literal">str.cpy</code>, which is very similar to the comparable C function. The HLA Standard Library contains several examples of this convention. The <code class="literal">arg.c</code> and <code class="literal">arg.v</code> functions are another pair of such identifiers (corresponding to the C identifiers <code class="literal">argc</code> and <code class="literal">argv</code>).<a class="indexterm" id="IDX-CHP-5-0195"/><a class="indexterm" id="IDX-CHP-5-0196"/><a class="indexterm" id="IDX-CHP-5-0197"/></p><p>Using a <code class="literal">namespace</code> in a header file is no different than using a <code class="literal">namespace</code> in a <code class="literal">program</code> or <code class="literal">unit</code>, though you do not normally put actual procedure bodies in a <code class="literal">namespace</code>. Here's an example of a typical header file containing a <code class="literal">namespace</code> declaration:</p><a id="I_programlisting5_d1e27407"/><pre class="programlisting">// myHeader.hhf -
//
// Routines supported in the myLibrary.lib file

namespace myLib;

     procedure func1; external;
     procedure func2; external;
     procedure func3; external;

end myLib;</pre><p>Typically, you would compile each of the functions (<code class="literal">func1..func3</code>) as separate units (so each has its own object file and linking in one function doesn't link them all). Here's a sample <code class="literal">unit</code> declaration for one of these functions:</p><a id="I_programlisting5_d1e27417"/><pre class="programlisting">unit func1Unit;
#includeonce( "myHeader.hhf" )

procedure myLib.func1;
begin func1;

     &lt;&lt; Code for func1 &gt;&gt;

end func1;

end func1Unit;</pre><p>You should notice two important things about this unit. First, you do not put the actual <code class="literal">func1</code> procedure code within a <code class="literal">namespace</code> declaration block. By using the identifier <code class="literal">myLib.func1</code> as the procedure's name, HLA automatically realizes that this procedure declaration belongs in a namespace. The second thing to note is that you do not preface <code class="literal">func1</code> with <code class="literal">myLib.</code> after the <code class="literal">begin</code> and <code class="literal">end</code> clauses in the procedure. HLA automatically associates the <code class="literal">begin</code> and <code class="literal">end</code> identifiers with the <code class="literal">procedure</code> declaration, so it knows that these identifiers are part of the <code class="literal">myLib</code> namespace and it doesn't make you type the whole name again.</p><p>Important note: When you declare external names within a namespace, as was done in <code class="literal">func1Unit</code> previously, HLA uses only the function name (<code class="literal">func1</code> in this example) as the external name. This creates a namespace pollution problem in the external namespace. For example, if you have two different namespaces, <code class="literal">myLib</code> and <code class="literal">yourLib</code>, and they both define a <code class="literal">func1</code> procedure, the linker will complain about a duplicate definition for <code class="literal">func1</code> if you attempt to use functions from both these library modules. There is an easy workaround to this problem: Use the extended form of the <code class="literal">external</code> directive to explicitly supply an external name for all external identifiers appearing in a <code class="literal">namespace</code> declaration. For example, you could solve this problem with the following simple modification to the <span class="emphasis"><em>myHeader.hhf</em></span> file above:</p><a id="I_programlisting5_d1e27486"/><pre class="programlisting">// myHeader.hhf -
//
// Routines supported in the myLibrary.lib file

namespace myLib;

     procedure func1; external( "myLib_func1" );
     procedure func2; external( "myLib_func2" );
     procedure func3; external( "myLib_func3" );

end myLib;</pre><p>This example demonstrates an excellent convention you should adopt: When exporting names from a namespace, always supply an explicit external name and construct that name by concatenating the <code class="literal">namespace</code> identifier with an underscore and the object's internal name.</p><p>The use of <code class="literal">namespace</code> declarations does not completely eliminate the problems of namespace pollution (after all, the namespace identifier is still a global object, as anyone who has included <span class="emphasis"><em>stdlib.hhf</em></span> and attempted to define a <code class="literal">cs</code> variable can attest), but <code class="literal">namespace</code> declarations come pretty close to eliminating this problem. Therefore, you should use <code class="literal">namespace</code> everywhere practical when creating your own libraries.</p></div>
<div class="sect1" title="5.26 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id4"/>5.26 For More Information</h1></div></div></div><p>The electronic edition of this book found at <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> or <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> contains a whole "volume" on advanced and intermediate procedures. The information in this chapter was taken from the introductory and intermediate chapters in the electronic edition. While the information appearing in this chapter covers 99 percent of the material assembly programmers typically use, there is additional information on procedures and parameters that you may find interesting. In particular, the electronic edition covers additional parameter-passing mechanisms (pass by value/result, pass by result, pass by name, and pass by lazy evaluation) and goes into greater detail about the places you can pass parameters. The electronic version of this text also covers iterators, thunks, and other advanced procedure types. You should also check out the HLA documentation for more details on HLA's procedure facilities. Finally, a good compiler construction textbook will cover additional details about runtime support for procedures.</p><p>This chapter discussed only 32-bit near procedures (appropriate for operating systems like Windows, Mac OS X, FreeBSD, and Linux). For information about procedures in 16-bit code (including near and far procedures), check out the 16-bit edition of this book, also found at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>.</p><p>HLA supports the ability to nest procedures; that is, you can declare a procedure in the declaration section of some other procedure and use <span class="emphasis"><em>displays</em></span> and <span class="emphasis"><em>static links</em></span> to access automatic variables in the enclosing procedures. HLA also supports advanced parameter-pointer facilities. This text does not discuss these features because they're somewhat advanced and very few assembly language programmers take advantage of these facilities in their programs. However, these features are very handy in certain situations. Once you're comfortable with procedures and assembly language programming in general, you should read about HLA's facilities for nested procedures in the HLA documentation and in the chapters on intermediate and advanced procedures in the electronic version of this book found at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a>.</p><p>Finally, the examples given for the code that HLA generates when passing parameters using the high-level syntax are incomplete. Over time, HLA has improved the quality of the code it generates when passing parameters on the stack. If you would like to see the type of code HLA generates for a particular parameter call sequence, you should supply the <code class="literal">-sourcemode</code>, <code class="literal">-h</code>, and <code class="literal">-s</code> command-line parameters to HLA and view the corresponding assembly language file that HLA emits (which will be a pseudo-HLA source file showing you the low-level code that HLA produces).</p></div></body></html>