- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: MUSIC**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'In this chapter, we’ll continue exploring randomness in art with sound and
    music. We’ll begin generating sound via random samples, random walks through frequency
    space, and random walks up and down a musical scale. These projects will prepare
    us for the chapter’s most ambitious experiment: evolving pleasant melodies from
    scratch. While we can’t really quantify such a melody, that won’t stop us from
    trying.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索声音和音乐中的随机性。我们将开始通过随机样本、频率空间中的随机漫步以及在音乐音阶上的上下随机漫步来生成声音。这些项目将为本章最具雄心的实验做准备：从零开始演化出悦耳的旋律。虽然我们无法真正量化这样的旋律，但这并不会阻止我们尝试。
- en: '**Creating Random Sounds**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建随机声音**'
- en: At first blush, generating a random sound seems straightforward. For instance,
    if we have some way of creating a sound file, like a WAV (*.wav* file extension),
    it follows that we should just need random sound samples at a specified playback
    rate—right? Let’s implement this, as it will introduce us to the audio tools we
    need for this section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，生成随机声音似乎很简单。例如，如果我们有某种方法来创建声音文件，比如 WAV（*.wav* 文件扩展名），那么我们应该只需要以指定的播放速率获取随机声音样本——对吧？让我们实现这个，它将引导我们使用本节所需的音频工具。
- en: 'WAV files are easy to read and write via SciPy’s `wavfile` module. To write
    a WAV file, we need two things: a specified sampling rate and the samples themselves
    in some range that programs like `mplayer` or Audacity will understand.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: WAV 文件可以通过 SciPy 的 `wavfile` 模块轻松读取和写入。要写入 WAV 文件，我们需要两样东西：指定的采样率以及样本本身，它们必须在一些范围内，这些程序如
    `mplayer` 或 Audacity 可以理解。
- en: We measure the sampling rate, the speed with which the samples are played back,
    in samples per second. The higher the sampling rate, the better the audio quality.
    A sampling rate of 22,050 Hz (cycles per second) is sufficient for our purposes.
    This is half the rate of a compact disc.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以每秒样本数来衡量采样率，即样本播放的速度。采样率越高，音频质量越好。22,050 Hz（每秒周期数）的采样率对于我们的目的来说足够了。这是 CD
    的一半采样率。
- en: The samples are quantized voltages, a continuous range partitioned into a specified
    number of discrete steps, with each discrete value specifying a particular analog
    voltage level. The discrete samples correspond to the output audio waveform. Samples
    are usually 16-bit signed integers, but we’ll work with 32-bit floating-point
    samples in the range [–1, 1]. Most audio programs will have little difficulty
    with floating-point samples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样本是量化的电压，表示一个连续范围被划分为指定数量的离散步骤，每个离散值指定一个特定的模拟电压水平。离散样本对应于输出的音频波形。样本通常是 16
    位有符号整数，但我们将使用范围在 [–1, 1] 之间的 32 位浮动点样本。大多数音频程序处理浮动点样本时不会遇到困难。
- en: To make random sounds, we need to generate random samples, set up the WAV output,
    and write the samples to disk for playback. Let’s give it a go and hear what happens.
    The code we want is in *random_sounds.py*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制造随机声音，我们需要生成随机样本，设置 WAV 输出，并将样本写入磁盘以供播放。让我们尝试一下，看看会发生什么。我们想要的代码在 *random_sounds.py*
    文件中。
- en: 'Let’s run it first:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先运行一下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Play the three-second output file, *tmp.wav*. I recommend turning down the volume
    first. Did you hear what you expected to? Consider [Listing 8-1](ch08.xhtml#ch08list01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 播放三秒的输出文件 *tmp.wav*。我建议你先调低音量。你听到了你预期的声音吗？可以考虑查看[清单 8-1](ch08.xhtml#ch08list01)。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-1: Generating random samples*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-1：生成随机样本*'
- en: I excluded the usual message about the proper form for the command line to focus
    on the relevant code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了关于命令行格式的常见信息，专注于相关的代码。
- en: First, we import `wavwrite` from SciPy. I renamed `write` as `wavwrite` to clarify
    what the function does. Ignore the `WriteOutputWav` function for a moment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 SciPy 导入 `wavwrite`。我将 `write` 重命名为 `wavwrite`，以澄清这个函数的作用。暂时忽略 `WriteOutputWav`
    函数。
- en: The main part of the file fixes the sampling `rate` and reads the duration in
    seconds from the command line, along with the output WAV filename (`oname`), before
    calculating `nsamples`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的主要部分固定了采样 `rate`，并从命令行读取秒数的持续时间，以及输出的 WAV 文件名（`oname`），然后计算 `nsamples`。
- en: If the samples are played at a given `rate`, and we want a total `duration`
    in seconds, then the product, rounded to an integer, provides us with the number
    of samples we must generate. The `samples` are randomly selected in [–1, 1) using
    NumPy’s pseudorandom generator. There’s no point in using `RE` here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本以给定的 `rate` 播放，并且我们想要一个总的 `duration`（秒数），那么乘积（四舍五入为整数）将为我们提供必须生成的样本数。`samples`
    是在 [–1, 1) 范围内使用 NumPy 的伪随机生成器随机选择的。在这里使用 `RE` 没有意义。
- en: All that remains is to use `WriteOutputWav` to create the output WAV file. We’ll
    use this function for all the experiments in this section. The first line rescales
    the samples to be in the range [0, 1], which lets us be a bit freer with how we
    generate samples. The second line changes from [0, 1] to [–1, 1], the valid range
    for floating-point samples. The last line uses `wavwrite` to dump the WAV file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是使用 `WriteOutputWav` 来创建输出的 WAV 文件。我们将在本节的所有实验中使用这个函数。第一行将样本缩放到 [0, 1] 的范围，这样我们可以在生成样本时更加灵活。第二行将范围从
    [0, 1] 转换到 [–1, 1]，这是浮点样本的有效范围。最后一行使用 `wavwrite` 将 WAV 文件写出。
- en: The output of *random_sounds.py* is so grating due to how humans perceive sound.
    We like sound that is represented as nice collections of sine waves summed together;
    in other words, tones with a fundamental frequency and overtones (harmonics).
    A random collection of unrelated samples can be represented only by summing a
    large number of sine waves.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*random_sounds.py* 的输出之所以让人感到刺耳，是因为人类对声音的感知方式。我们喜欢那些由一组漂亮的正弦波叠加而成的声音；换句话说，就是有基频和谐波的音调。一个随机的、无关的样本集合只能通过叠加大量正弦波来表示。'
- en: '[Figure 8-1](ch08.xhtml#ch08fig01) shows a sine wave at 440 Hz on the left
    and random noise on the right.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](ch08.xhtml#ch08fig01) 显示了左侧的 440 Hz 正弦波和右侧的随机噪声。'
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig01.jpg)'
- en: '*Figure 8-1: Top left: a sine wave; top right: random noise; bottom left: the
    frequency spectrum of the sine wave; bottom right: random noise*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：左上：一个正弦波；右上：随机噪声；左下：正弦波的频率谱；右下：随机噪声*'
- en: The top of [Figure 8-1](ch08.xhtml#ch08fig01) shows the actual sound samples
    over time. The bottom shows the frequency spectrum, the strength of the various
    sine waves that go into the signal, so the *x*-axis is no longer time but frequency.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](ch08.xhtml#ch08fig01) 的顶部显示了实际的声音样本随时间的变化。底部显示了频谱，即信号中各个正弦波的强度，因此 *x*
    轴不再是时间，而是频率。'
- en: The sine wave is, fundamentally, a single frequency at 440 Hz. The energy at
    other frequencies is likely due to an imperfect approximation of the pure sine
    wave. The vertical scale is logarithmic, meaning there is very little energy outside
    of 440 Hz. The random noise spectrum, however, is roughly uniform over the entire
    frequency range up to 8,000 Hz, reflecting the number of sine waves that must
    be summed to approximate the random signal. The *x*-axis is similarly logarithmic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波从根本上来说是一个频率为 440 Hz 的单一波形。其他频率的能量很可能是由于对纯正弦波的不完美近似所导致的。垂直刻度是对数标度，这意味着在 440
    Hz 之外几乎没有能量。然而，随机噪声的频谱在整个频率范围内（直到 8,000 Hz）大致均匀，反映了必须叠加的正弦波的数量，以近似随机信号。*x* 轴同样是对数刻度。
- en: The following two sections explore other approaches to random sound generation,
    both utilizing the idea of a random walk—not in space, but in frequency. We’ll
    produce sound using the sum of sine waves. The first section pays no attention
    to the mix of frequencies, while the second uses frequencies from the notes of
    a C major scale.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个部分探讨了生成随机声音的其他方法，均利用了随机游走的思想——不是在空间中，而是在频率上。我们将通过正弦波的叠加来产生声音。第一部分不关注频率的混合，而第二部分使用了
    C 大调音阶中的音符频率。
- en: '***Sine Waves***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正弦波***'
- en: If we add two sine waves with different frequencies, they merge to become a
    new wave. Where the two sine waves are positive, they reinforce each other, and
    the resulting wave is more positive. When one is positive and the other negative,
    they cancel each other. For example, consider [Figure 8-2](ch08.xhtml#ch08fig02).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个不同频率的正弦波相加，它们会合并成一个新的波形。两个正弦波都为正时，它们会相互加强，结果波形会更为积极。当一个为正，另一个为负时，它们会相互抵消。例如，考虑
    [图 8-2](ch08.xhtml#ch08fig02)。
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig02.jpg)'
- en: '*Figure 8-2: Two sine waves (left) and their sum (right)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：两个正弦波（左）及其和（右）*'
- en: On the left are two sine waves with frequencies in the ratio of 3:1\. On the
    right is the sum of the two sine waves on the left. Sum enough waves and any desired
    output waveform is possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是两个频率比为 3:1 的正弦波，右侧是左边两个正弦波的叠加。叠加足够多的波形，任何所需的输出波形都是可能的。
- en: 'The code in *sine_walker.py* creates a collection of random walkers that each
    generate 0.5-second sine waves before altering the frequency used for the next
    0.5 seconds. For each 0.5-second block of time, the final wave is the sum of all
    the walkers. Let’s run the code and then walk through it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*sine_walker.py* 中的代码创建了一组随机游走者，每个游走者生成 0.5 秒的正弦波，然后改变频率以用于下一个 0.5 秒的时间段。对于每个
    0.5 秒的时间块，最终的波形是所有游走者的波形之和。我们来运行代码并逐步解析：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should produce a 5-second output file consisting of three independent sine
    wave random walks. Give *walk.wav* a listen; it reminds me of sound effects in
    1950s science fiction movies.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个 5 秒的输出文件，包含三个独立的正弦波随机游走。听一听 *walk.wav*；它让我想起了 1950 年代科幻电影中的音效。
- en: 'The *sine_walker.py* file parses the command line and then configures the values
    we need for the random walks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*sine_walker.py* 文件解析命令行参数，然后配置我们需要的随机游走值：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we use `nsamples` to define `samples`, which holds all output. The next
    two lines define `dur`, the step duration, and `step_samp`, the number of samples
    in a step. Each sine wave, for a specific frequency, creates this many samples.
    Next, `fstep` sets the step size in Hertz, and `freq` is a vector of initial frequencies
    in [40, 840) Hertz. The double-definition handles the case where there’s only
    one walker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `nsamples` 定义 `samples`，它保存所有输出。接下来的两行定义了 `dur`，即步长的持续时间，和 `step_samp`，即每个步长中的样本数量。每个正弦波对应一个特定的频率，生成这些样本数。接下来，`fstep`
    设置步长频率，`freq` 是一个初始频率的向量，范围为 [40, 840) 赫兹。双重定义处理了只有一个游走者的情况。
- en: We then loop until we have generated all samples. Each step is 0.5 seconds long,
    and each walker generates a sine wave with `step_samp` samples using its current
    frequency and a randomly chosen amplitude. We sum the walkers and assign the summed
    wave to the next 0.5 second’s worth of samples; see [Listing 8-2](ch08.xhtml#ch08list02).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们循环直到生成所有样本。每个步长为 0.5 秒，每个游走者使用其当前频率和随机选择的振幅生成一个正弦波，包含 `step_samp` 个样本。我们将所有游走者的波形加和，并将合成后的波形分配到下一个
    0.5 秒的样本中；参见 [列表 8-2](ch08.xhtml#ch08list02)。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-2: Generating sine wave walks*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：生成正弦波游走*'
- en: A `while` loop runs over all the output samples ➊. The next `for` loop ➋ is
    over all walkers for the current step. A random value decides whether to increment,
    decrement, or leave each walker’s frequency unchanged. Then a quick check with
    `min` and `max` keeps the frequency in the range [100, 4000].
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环遍历所有输出样本 ➊。接下来的 `for` 循环 ➋ 遍历当前步长的所有游走者。随机值决定是否增加、减少或保持每个游走者的频率不变。然后使用
    `min` 和 `max` 快速检查，确保频率在 [100, 4000] 范围内。'
- en: A sine wave can be written as *y* = *A* sin *ωx* for amplitude *A* and frequency
    *ω* (omega). We select a random amplitude ➌ and use it to create a step’s worth
    of samples that are added to any existing samples, `t`, thereby summing across
    all the walkers for the current step.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波可以写作 *y* = *A* sin *ωx*，其中 *A* 为振幅，*ω* 为频率（ω）。我们随机选择一个振幅 ➌，并用它创建步长的样本，这些样本会被加到现有的样本
    `t` 中，从而将所有游走者的结果加总在当前步长内。
- en: Each step’s waveform begins at zero amplitude because the sine function starts
    at zero. Therefore, we want the end of the previous step to also be at zero amplitude.
    The second `while` loop ➍ attempts to scan from the end of the step waveform to
    find a sample reasonably close to zero.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步长的波形从零振幅开始，因为正弦函数从零开始。因此，我们希望前一步的结束位置也在零振幅处。第二个 `while` 循环 ➍ 尝试从步长波形的末尾扫描，找到一个接近零的样本。
- en: Finally, we place the samples for the step in the output `samples` vector ➎
    if they fit. When `samples` is full, it’s clipped to keep samples above the 10th
    percentile and below the 90th, and then written to disk via `WriteOutputWav`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将步长的样本放入输出 `samples` 向量 ➎，如果它们适合的话。当 `samples` 满了时，进行剪辑，以保持样本位于第 10 百分位和第
    90 百分位之间，然后通过 `WriteOutputWav` 写入磁盘。
- en: Generate a 15-second or longer sample with one walker. Do you hear the walk?
    It might help to temporarily set `amp=1` to make each step equally loud. Use an
    app on your smartphone to show the frequency spectrum in real time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个游走者生成一个 15 秒或更长的样本。你能听到这个游走吗？可能有助于暂时将 `amp=1` 设置为使每个步长的音量相同。你也可以用智能手机上的应用程序实时显示频率谱。
- en: What happens if you add more walkers? Examine the waveform for 50 walkers using
    a program like Audacity. It should start to resemble noise with little structure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你增加更多的游走者会发生什么？使用像 Audacity 这样的程序查看 50 个游走者的波形。它应该开始呈现出噪音的特征，结构较少。
- en: Making strange sounds with arbitrary combinations of sine waves is fun, but
    let’s see if we can be more musical in our approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用任意组合的正弦波发出奇怪的声音很有趣，但让我们看看是否能采用更具音乐性的方式。
- en: '***C Major Scale***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C大调音阶***'
- en: 'The sine walker stepped in frequency by a fixed interval of 5 Hz. The code
    in *note_walker.py* is nearly identical to that in *sine_walker.py*, but instead
    of altering the frequency of the sine waves by a constant number of Hertz, the
    walk takes place over the frequencies of the notes in a C major scale:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦步进器的频率按固定的5 Hz间隔逐步变化。*note_walker.py*中的代码与*sine_walker.py*中的几乎相同，但不同之处在于，正弦波的频率不是按常数赫兹变化，而是依照C大调音阶中的音符频率逐步变化：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this list, middle C is 261.63 Hz, and A above middle C is 440 Hz. The *note_walker.py*
    file uses the same command line as *sine_walker.py*. Read through the code and
    give it a go. Is the result the same as *sine_walker.py*? What instrument does
    the output remind you of?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，中央C的频率是261.63 Hz，中央C之上的A音是440 Hz。*note_walker.py*文件使用的命令行与*sine_walker.py*相同。仔细阅读代码并尝试一下。结果和*sine_walker.py*一样吗？输出的声音让你想起了什么乐器？
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Electronic oscillators of various frequencies pieced together with other circuits
    to modulate the resulting final waveform were the backbone of early analog music
    synthesizers. We can emulate an analog synthesizer in software; see* [https://github.com/yuma-m/synthesizer](https://github.com/yuma-m/synthesizer).
    *It’s Python based, and the page provides complete instructions for installing
    dependencies. The examples on the GitHub page use sine waves as the base waveform,
    just as we used here.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*各种频率的电子振荡器与其他电路组合，以调制最终波形，是早期模拟音乐合成器的核心。我们可以通过软件模拟模拟合成器；参考* [https://github.com/yuma-m/synthesizer](https://github.com/yuma-m/synthesizer)。*它基于Python，并且页面提供了安装依赖的完整说明。GitHub页面上的示例使用正弦波作为基本波形，就像我们在这里使用的一样。*'
- en: Let’s make the leap from randomly varying sine waves to evolving a melody from
    scratch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从随机变化的正弦波跃升到从头开始演化旋律。
- en: '**Generating Melodies**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生成旋律**'
- en: We’ll use swarms in the service of generating melodies, with the goal of creating
    a “pleasant” sounding melody from a clean slate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用群体搜索来生成旋律，目标是从零开始创作出一首“悦耳”的旋律。
- en: First, we’ll set up our environment. Then we’ll learn how to use the program
    *melody_maker.py* to generate melodies. Finally, we’ll walk through the essential
    parts of the code. The objective function is quite a bit more complicated than
    what we’ve worked with previously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置好我们的环境。接着，我们将学习如何使用程序*melody_maker.py*来生成旋律。最后，我们将逐步讲解代码的关键部分。目标函数比我们之前处理过的要复杂得多。
- en: '***Swarm Search***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***群体搜索***'
- en: 'We’ll use MIDI files in this section instead of directly generating WAV files.
    *MIDI (Musical Instrument Digital Interface)* is the standard format for digital
    music. It can be complicated, but our use is as simple as it gets: a single melody
    line. Therefore, for us, MIDI becomes a NumPy vector of pairs of numbers, the
    first a note number (60 is middle C), and then a duration where the ratio between
    the durations marks whole, half, quarter, eighth notes, and so on.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用MIDI文件，而不是直接生成WAV文件。*MIDI（数字音乐仪器接口）*是数字音乐的标准格式。它可能有些复杂，但我们的使用方式简单至极：只有一条旋律线。因此，对于我们来说，MIDI变成了一个NumPy向量，由一对数字组成，第一个是音符编号（60是中央C），接着是时值，其中各时值的比例表示全音符、半音符、四分音符、八分音符，等等。
- en: The melodies we evolve are expressed, ultimately, as MIDI files. Therefore,
    we need additional software beyond the usual toolkit to play MIDI files, work
    with MIDI files in code, and turn a MIDI file into an image of the musical score.
    Let’s install `wildmidi`, `midiutil`, and `musescore3`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演变出的旋律最终以MIDI文件的形式表示。因此，我们需要一些额外的软件，超出常规工具包的范畴，来播放MIDI文件、在代码中处理MIDI文件，并将MIDI文件转化为乐谱图像。让我们安装
    `wildmidi`、`midiutil` 和 `musescore3`。
- en: 'Install `wildmidi` with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `wildmidi`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `wildmidi` add-on plays MIDI files (*.mid*) from the command line. For macOS
    and Windows, see the main website at *[https://github.com/Mindwerks/wildmidi/releases](https://github.com/Mindwerks/wildmidi/releases)*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`wildmidi` 插件可以从命令行播放MIDI文件 (*.mid*)。对于macOS和Windows，请查看官方网站 *[https://github.com/Mindwerks/wildmidi/releases](https://github.com/Mindwerks/wildmidi/releases)*。'
- en: 'We need `midiutil` to work with MIDI files in Python:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `midiutil` 来在Python中处理MIDI文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `midiutil` library reads and writes MIDI files, though we’ll only ever write
    them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`midiutil` 库用于读取和写入MIDI文件，尽管我们只会写入文件。'
- en: 'Finally, to generate sheet music of our evolved melodies, we will need `musescore3`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了生成我们演变出的旋律的乐谱，我们需要 `musescore3`：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Versions for macOS and Windows are available from the main site (*[https://musescore.org/en/download](https://musescore.org/en/download)*).
    If `musescore3` is not found, install the latest version (`musescore4`) and update
    *melody_maker.py* accordingly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 和 Windows 的版本可以从主站下载 (*[https://musescore.org/en/download](https://musescore.org/en/download)*)。如果找不到
    `musescore3`，请安装最新版本（`musescore4`），并相应地更新 *melody_maker.py*。
- en: Once everything’s installed, we’re good to go. If you didn’t install `musescore3`,
    the code will still run, but you won’t get to see the final result visually.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有东西都安装好，我们就可以开始了。如果你没有安装 `musescore3`，代码仍然可以运行，但你将无法看到最终的视觉效果。
- en: '#### ***The melody_maker.py code***'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***melody_maker.py 代码***'
- en: 'The code we need to evolve melodies is in *melody_maker.py*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用来生成旋律的代码在 *melody_maker.py* 文件中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Many command line arguments are familiar or self-evident, like the number of
    notes in the melody. The `mode` argument refers to the musical mode or scale we
    want to use. Traditionally, there are seven modes, all of which are supported,
    plus the blues and the pentatonic (rock) scales. The other modes use their classical
    Greek names, or `major` or `minor` for standard major and minor keys. The mode
    names are in [Table 8-1](ch08.xhtml#ch08tab01) along with a sequence of intervals
    and words often associated with the mode. The intervals of [Table 8-1](ch08.xhtml#ch08tab01)
    refer to the steps between the notes of the scale with `H` a half step (semitone)
    and `W` a whole step (tone).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行参数都很熟悉或不言而喻，比如旋律中的音符数量。`mode` 参数表示我们想要使用的音乐模式或音阶。传统上，有七种模式，所有这些都支持，包括蓝调和五声音阶（摇滚）。其他模式使用它们的古典希腊名字，或者使用
    `major` 或 `minor` 来表示标准的大调和小调。模式的名称在 [表 8-1](ch08.xhtml#ch08tab01) 中列出，附有一系列音程和通常与该模式相关的词汇。[表
    8-1](ch08.xhtml#ch08tab01) 中的音程表示音阶中音符之间的步伐，其中 `H` 代表半音（半音程），`W` 代表全音（全音程）。
- en: '**Table 8-1:** The Modes, Intervals, and Characteristics'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 模式、音程和特征'
- en: '| **Mode** | **Intervals** | **Characteristics** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **音程** | **特征** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Ionian (major) | `W W H W W W H` | Bright, positive, strong, simple |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Ionian (major) | `W W H W W W H` | 明亮、积极、强烈、简单 |'
- en: '| Aeolian (minor) | `W H W W H W W` | Sad |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Aeolian (minor) | `W H W W H W W` | 悲伤 |'
- en: '| Dorian | `W H W W W H W` | Light, cool, jazzy |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Dorian | `W H W W W H W` | 轻盈、凉爽、爵士感 |'
- en: '| Lydian | `W W W H W W H` | Bright, airy, sharp |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Lydian | `W W W H W W H` | 明亮、通透、尖锐 |'
- en: '| Mixolydian | `W W H W W H W` | Celtic |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Mixolydian | `W W H W W H W` | 凯尔特风格 |'
- en: '| Phrygian | `H W W W H W W` | Dark, depressing |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Phrygian | `H W W W H W W` | 阴郁、压抑 |'
- en: '| Locrian | `H W W H W W W` | Darker still, “evil” |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Locrian | `H W W H W W W` | 更加阴暗，“邪恶” |'
- en: 'For example, if the first note of a candidate melody is middle C (MIDI note
    60), and the desired mode is `major`, then the notes of the scale are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果候选旋律的第一个音符是中音 C（MIDI 音符 60），并且所需的模式是 `major`，那么音阶的音符是：
- en: '![Image](../images/f0246-01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0246-01.jpg)'
- en: The objective function will score a candidate melody, in part, by how closely
    it follows the desired scale.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数会部分通过旋律与目标音阶的匹配度来打分。
- en: If you’re not familiar with music, scales, or music theory of any kind, have
    no fear. All we need to know is that there are different scales, or different
    sets of intervals between notes, that, when played, affect the sound of the melody.
    For example, melodies in a major scale (Ionian mode) sound bright, while those
    in a minor key (Aeolian mode) tend to sound sad. These rules are not hard and
    fast—just guidelines. We’ll generate many melodies in different modes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉音乐、音阶或任何音乐理论，别担心。我们需要知道的是，音阶或音符之间的间隔不同，这些间隔在演奏时会影响旋律的音色。例如，大调音阶（Ionian
    模式）中的旋律听起来明亮，而小调音阶（Aeolian 模式）中的旋律通常听起来悲伤。这些规则并非硬性规定——只是一些指导原则。我们会在不同的模式下生成许多旋律。
- en: 'Let’s run *melody_maker.py*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 *melody_maker.py*：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I didn’t specify a seed, so your run will be entirely different. The output
    tells us about the search, then spits out a long string of integers and floats.
    This is the evolved melody as written to the output MIDI file, which is in the
    *tmp* directory along with several other files, including a NumPy vector, a Python
    pickle file, and the score (`score.png`). The melody is in pairs, so the first
    note is (63,0.9), a dotted eighth note E-flat above middle C.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有指定种子，因此你的运行结果会完全不同。输出会告诉我们搜索的过程，然后输出一串长长的整数和浮动数字。这就是进化后的旋律，已写入输出的 MIDI 文件中，该文件位于
    *tmp* 目录下，此外还有其他文件，包括一个 NumPy 向量、一个 Python pickle 文件和乐谱（`score.png`）。旋律是成对的，所以第一个音符是
    (63,0.9)，即中音 C 上方的附点八分音符 E-flat。
- en: The output MIDI file is in *tmp* as well. Play it with `wildmidi`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的 MIDI 文件也在 *tmp* 文件夹中。可以用 `wildmidi` 播放它。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where `BARE` is replaced by whatever swarm algorithm we select. I chose `mixolydian`
    for the mode, so, in theory, the melody should sound somewhat “celtic.” Does it?
    I really don’t know.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`BARE`会被我们选择的任何群体算法替代。我选择了`mixolydian`作为调式，因此，理论上，这个旋律应该听起来有些“凯尔特风格”。真的像吗？我其实并不知道。
- en: The evolved melody is in *score.png*; see [Figure 8-3](ch08.xhtml#ch08fig03).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 演化后的旋律在*score.png*中；请参见[图8-3](ch08.xhtml#ch08fig03)。
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig03.jpg)'
- en: '*Figure 8-3: An evolved melody*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：演化后的旋律*'
- en: I glossed over the objective function value for the returned melody. We’ll explore
    that in more detail when we glance at the code. However, as with all our optimization
    experiments, lower is better.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我略过了返回旋律的目标函数值。我们将在稍后查看代码时更详细地探讨这一点。不过，就像我们所有的优化实验一样，越小越好。
- en: Try experimenting with melodies, modes, algorithms, swarm sizes, and iterations
    of different lengths. More iterations generally lead to better performance, which
    should mean a better sounding melody, or, at least, a melody more faithful to
    the desired mode.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实验不同的旋律、调式、算法、群体大小和不同长度的迭代次数。更多的迭代通常会带来更好的性能，这应该意味着更好听的旋律，或者至少是更符合期望调式的旋律。
- en: You might wish to run the examples in *melody_examples*. The file works as a
    shell script
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望运行*melody_examples*中的示例。该文件作为一个shell脚本运行。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and produces directories *ex0* through *ex8* inside *example_melodies* using
    different swarm algorithms and modes. I fixed the seeds, so you’ll hear what I
    heard, which hints at the range of possible outcomes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并在*example_melodies*内生成从*ex0*到*ex8*的目录，使用不同的群体算法和调式。我固定了种子，因此你会听到我听到的旋律，这也暗示了可能的结果范围。
- en: The following sections experiment with *melody_maker.py*. The first queries
    the melodies as they evolve, the second focuses on the algorithms to understand
    what sort of melodies they favor, and the last builds a library of melodies in
    four modes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分实验了*melody_maker.py*。第一个部分查询旋律在进化过程中是如何变化的，第二部分则专注于算法，以了解它们偏好的旋律类型，最后一部分构建了一个包含四种调式的旋律库。
- en: '**Evolving a Melody**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**旋律的演化**'
- en: Let’s evolve a melody in a major scale using bare-bones PSO. This experiment
    aims to listen to the melody as it evolves. It should go from erratic and far
    from the desired mode to a tune that a beginning piano student might play (or
    so I’ve been told).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用基础的PSO算法来演化一个大调旋律。这个实验的目的是在旋律进化的过程中聆听它。旋律应该从不稳定且远离目标调式的状态，逐渐发展为一个初学者钢琴学生可能演奏的曲调（或者是我被告知的那样）。
- en: The file *evolve.py* runs *melody_maker.py* to evolve a major scale melody of
    20 notes using 20 particles and bare-bones PSO. The generator and seed are fixed;
    all that changes between runs is the number of iterations, which vary from a low
    of 1 to a high of 50,000, as in [Figure 8-4](ch08.xhtml#ch08fig04).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*evolve.py*运行*melody_maker.py*，使用20个粒子和基础PSO算法演化一个包含20个音符的大调旋律。生成器和种子是固定的；不同的只是迭代次数，从1次到50,000次不等，正如[图8-4](ch08.xhtml#ch08fig04)所示。
- en: The fixed seed means that the best melody found for 10 iterations passed through
    the best found in 1 iteration. Each higher number of iterations tells us where
    any earlier iteration would have ended if it were left to run. In other words,
    the same initial configuration is allowed to evolve for a varying number of iterations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 固定的种子意味着10次迭代找到的最佳旋律通过了1次迭代找到的最佳旋律。每次更高的迭代次数告诉我们，如果早期的迭代继续进行，会在哪个位置结束。换句话说，允许相同的初始配置进行不同次数的迭代。
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/08fig04.jpg)'
- en: '*Figure 8-4: Progressive melodies. From top: 1, 1,000, 10,000, and 50,000 iterations.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-4：逐步演化的旋律。从上到下：1次、1,000次、10,000次和50,000次迭代。*'
- en: 'The directory *evolve_results* contains the MIDI files and score images for
    each number of iterations: 1, 10, 100, 1,000, 5,000, 10,000, and 50,000\. I recommend
    using `wildmidi` to play the files. How does the melody found after 1 iteration
    of the swarm compare to that after 50,000? [Figure 8-4](ch08.xhtml#ch08fig04)
    shows the score for select melodies by iteration. While the early melodies are
    a mess, there is little change—other than the key—between the melody after 10,000
    iterations and after 50,000.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目录*evolve_results*包含每种迭代次数（1、10、100、1,000、5,000、10,000和50,000）的MIDI文件和乐谱图像。我推荐使用`wildmidi`来播放这些文件。在1次迭代和50,000次迭代后的旋律相比，如何？[图8-4](ch08.xhtml#ch08fig04)展示了不同迭代次数下的选择旋律乐谱。虽然早期的旋律杂乱无章，但在10,000次迭代和50,000次迭代后的旋律变化不大——除了调性之外几乎没有变化。
- en: The objective function value, which we have yet to understand, decreases as
    the number of iterations increases. This is, of course, all it can do, but the
    rate at which it decreases levels off after 1,000 iterations. The slight change
    in the score between 10,000 iterations and 50,000 implies that we may not want
    to run the search for too long, as we risk eliminating potentially exciting melodies
    in the process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数值我们尚未理解，但它随着迭代次数的增加而减少。当然，这就是它所能做到的，但它的下降速度在1000次迭代后开始趋于平缓。10,000次迭代和50,000次迭代之间分数的微小变化意味着我们可能不想让搜索运行得太长时间，因为这样有可能在过程中错过一些潜在的令人兴奋的旋律。
- en: What, precisely, happens when a melody evolves? Swarm algorithms are initialized
    randomly over an appropriate range of MIDI note numbers and durations. The selected
    musical mode effectively alters the objective function used by the swarm as it
    searches. While the swarm search includes randomness, it is the initial configuration
    of the swarm that most strongly influences the final result—at least, that’s what
    I think is happening. The combination of initial swarm configuration, algorithm
    approach, and randomness leads to convergence on a melody that more or less fits
    the objective function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当旋律进化时，究竟发生了什么？群体算法会在合适的MIDI音符号码和时值范围内随机初始化。选定的音乐模式有效地改变了群体在搜索过程中使用的目标函数。尽管群体搜索包含随机性，但最强烈影响最终结果的是群体的初始配置——至少，我认为是这样。初始群体配置、算法方法和随机性的结合导致收敛到一个或多或少符合目标函数的旋律。
- en: '**Exploring the Algorithms**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**探索算法**'
- en: The *algorithms.py* file runs *melody_maker.py* 10 times for each of the 7 swarm
    algorithms we’ve used throughout the book. Each run generates a 36-note melody
    in the Lydian mode utilizing a swarm of 20 particles and 10,000 iterations. You
    can run this file to produce output in the *algorithms* directory. Alternatively,
    since the seed values are fixed, you can listen to the seven MP3 files that concatenate
    the output by algorithm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*algorithms.py* 文件会对我们在整本书中使用的7个群体算法中的每一个运行 *melody_maker.py* 10次。每次运行都会生成一个36音符的旋律，采用利底亚模式，使用20个粒子和10,000次迭代。你可以运行这个文件，生成输出到
    *algorithms* 目录中。或者，由于种子值是固定的，你也可以听七个MP3文件，这些文件将按算法顺序连接输出。'
- en: Even though the algorithms are tasked with the same overall goal—learning a
    melody in the Lydian mode—hopefully the resulting melodies reveal distinctions
    between the algorithms. Let’s see whether it matters which swarm algorithm we
    use, and whether some produce “nicer” results than others.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些算法的任务是相同的——学习一个利底亚模式的旋律——但希望最终的旋律能够揭示出各个算法之间的区别。让我们看看使用哪种群体算法是否重要，以及是否有些算法生成的结果比其他算法“更好”。
- en: 'I listened to all the MP3 files (made by using `wildmidi`’s `-o` option followed
    by `lame`) and ranked the resulting melodies by how nice I thought they sounded.
    Here’s my ranking from best to worst, including ties where I couldn’t choose one
    algorithm over another:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我听了所有的MP3文件（使用`wildmidi`的`-o`选项和`lame`生成的）并根据我认为它们的音质对旋律进行了排名。以下是我从最好到最差的排名，包括我无法选择一个算法而导致的并列：
- en: Bare-bones PSO
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化版PSO
- en: Genetic algorithm, PSO
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遗传算法，PSO
- en: Differential evolution, Jaya
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 差分进化，Jaya
- en: GWO
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GWO
- en: Random optimization
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机优化
- en: Your ranking might be different, but I suspect you’ll agree that bare-bones
    PSO works best in this case and random optimization is the worst. Both GWO and
    random optimization produce rushed output; the melodies play faster, so the resulting
    MP3 files are about 30 seconds shorter than the other algorithms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你的排名可能不同，但我猜你会同意，在这种情况下简化版PSO表现最佳，而随机优化最差。GWO和随机优化都生成匆忙的输出；旋律播放得更快，因此生成的MP3文件比其他算法短大约30秒。
- en: We’ll perform one more experiment before exploring the code in which we use
    the “best” algorithm, bare-bones PSO, to create a library of songs in different
    modes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨代码之前，我们将进行另一个实验，使用“最佳”算法——简化版PSO，来创建一个不同模式的歌曲库。
- en: '**Building a Library of Melodies**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建旋律库**'
- en: 'The file *songs.py* is similar to *algorithms.py*, but uses bare-bones PSO
    repeatedly to generate 36-note melodies in four modes: major, minor, Dorian, and
    blues. In this case, there are 32 particles in the swarm and 30,000 iterations.
    The code takes some time to run, so I created MP3 files of the output: *major.mp3*,
    *minor.mp3*, *dorian.mp3*, and *blues.mp3*. Give them a listen while keeping the
    descriptions of [Table 8-1](ch08.xhtml#ch08tab01) in mind. If you agree with them,
    it means the objective function has at least captured something of the modes,
    if not much of what makes a good melody.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*songs.py*与*algorithms.py*相似，但使用简化版的PSO算法反复生成36个音符的旋律，涵盖四种调式：大调、小调、多利安调式和蓝调。在这种情况下，群体中有32个粒子，共进行30,000次迭代。代码运行需要一些时间，因此我为输出创建了MP3文件：*major.mp3*、*minor.mp3*、*dorian.mp3*和*blues.mp3*。在聆听时，请牢记[表8-1](ch08.xhtml#ch08tab01)中的描述。如果你认同这些描述，意味着目标函数至少在某种程度上捕捉到了这些调式的特点，即使它可能没有捕捉到完美的旋律特征。
- en: '***Implementation***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现***'
- en: 'The time has come to explore *melody_maker.py*. At a high level, it’s no different
    from any of the other swarm optimization experiments: we parse the command line,
    initialize swarm framework objects, and call `Optimize` to perform the search.
    The result is then converted into a MIDI file object and written to disk.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索*melody_maker.py*了。从高层次看，它与其他所有的群体优化实验没有什么不同：我们解析命令行，初始化群体框架对象，然后调用`Optimize`来执行搜索。最终结果会被转换成MIDI文件对象并写入磁盘。
- en: Let’s understand the structure of the swarm—the mapping between particle position
    and melody—and then walk through the objective function class, as that’s the heart
    of the process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下群体的结构——粒子位置与旋律之间的映射关系——然后再深入了解目标函数类，因为它是整个过程的核心。
- en: If we want *n* notes in a melody, each particle becomes a 2*n*-element vector,
    a collection of *n* pairs, (MIDI note number, duration). MIDI note numbers are
    restricted (see `MusicBounds`) to [57, 81] with 57 interpreted as a rest. Again,
    middle C on the piano is note 60, and each increment or decrement corresponds
    to a semitone. Durations are integers that we multiply by 0.3 when creating the
    MIDI file to control the tempo. The ratio between the notes matters so that duration
    4 is twice as long as duration 2, and so on. Particles, then, *are* the melody
    under consideration, and the search seeks to find, given the random initial collection
    of melodies and the particulars of the selected algorithm, a best melody as decided
    by the objective function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在旋律中有*n*个音符，每个粒子就变成一个2*n*元素的向量，包含*n*对数据，（MIDI音符号，时长）。MIDI音符号是有限制的（参见`MusicBounds`），范围为[57,
    81]，其中57表示休止符。再次强调，钢琴上的中音C是音符60，每次增减一个单位对应半音的变化。时长是整数，当我们创建MIDI文件时，会将其乘以0.3来控制节奏。音符之间的比例是重要的，因此时长为4的音符是时长为2的音符的两倍，依此类推。因此，粒子就是我们正在考虑的旋律，搜索的目标是根据随机生成的旋律集合和选定算法的细节，找到由目标函数决定的最佳旋律。
- en: 'Everything depends on the `MusicObjective` class. It’s rather elaborate, with
    more than 150 lines of code. I’ll start at the end, the `Evaluate` method, and
    then fill in the pieces—standard top-down design. Recall, the swarm uses the score
    to decide the quality of the melody. The lower it is, the better. Here’s the code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都依赖于`MusicObjective`类。它相当复杂，有超过150行代码。我会从最后开始，首先讲解`Evaluate`方法，然后再逐步补充其他部分——标准的自上而下设计。回顾一下，群体使用得分来判断旋律的质量，得分越低越好。下面是代码：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The score is a multipart function of the output from the `Distance`, `Durations`,
    `Intervals`, and `Leaps` methods. The respective values are summed but not equally
    weighted so that the output of `Distance` is four times as important as the output
    from the `Leaps` method. Each part of the final score is in the range [0, 1],
    with lower being better.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 得分是输出的多部分函数，涉及`Distance`、`Durations`、`Intervals`和`Leaps`方法。各部分的值被求和，但并不等权重，`Distance`方法的输出是`Leaps`方法输出的四倍重要。最终得分的每个部分都在[0,
    1]范围内，越低越好。
- en: The `Distance` method measures the Hamming distance between the notes of the
    current melody (particle) and the notes expected for a melody in the given mode.
    The `ModeNotes` method returns two binary vectors where a 1 indicates that the
    corresponding note is in the mode. The first vector is for the current melody,
    and the second includes the notes in that mode, assuming the first note of the
    melody to be the root. In other words, `ModeNotes` returns two binary numbers
    expressed as vectors of 0s and 1s. The Hamming distance between two binary numbers
    is the number of differing bits. For example, the Hamming distance between 10110111
    and 10100101 is 2 because two corresponding bit positions differ. The `Distance`
    method scales the Hamming distance by the number of notes to return a value in
    [0, 1]; it’s deemed the most important part of the objective function because
    a good melody in a specified mode should consist mostly of notes in that mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distance`方法测量当前旋律（粒子）中的音符和给定音阶中预期旋律音符之间的汉明距离。`ModeNotes`方法返回两个二进制向量，其中1表示对应音符在音阶中。第一个向量是当前旋律，第二个包括该音阶中的音符，假设旋律的第一个音符是根音。换句话说，`ModeNotes`返回两个以0和1表示的二进制数字作为向量。两个二进制数之间的汉明距离是不同的位数。例如，10110111和10100101之间的汉明距离为2，因为有两个对应的位不同。`Distance`方法通过音符的数量对汉明距离进行缩放，返回一个[0,
    1]区间的值；它被认为是目标函数中最重要的部分，因为一个好的指定音阶旋律应该主要由该音阶中的音符组成。'
- en: The `Durations` method is an ad hoc measure using a scaled root squared error
    distance between the count of the different note durations in the melody and the
    preferred favoring of quarter and half notes. The idea is to minimize dotted notes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Durations`方法是一个临时度量，使用旋律中不同音符持续时间的计数与偏好四分音符和二分音符的预期混合之间的根平方误差距离。目的是最小化附点音符。'
- en: The `Intervals` method is another ad hoc metric that looks at the spacing from
    one note in the melody to the next. We humans generally prefer major or minor
    thirds and fifths, meaning the interval from note *i* to note *i* + 1 should be
    3, 4, or 7 semitones.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intervals`方法是另一个临时度量，它考察旋律中一个音符与下一个音符之间的间距。我们人类通常偏好大三度、小三度和纯五度，这意味着从音符*i*到音符*i*
    + 1的间隔应该是3、4或7个半音。'
- en: Finally, `Leaps` tries to minimize leaps, or intervals between notes that exceed
    5 semitones. This competes with what `Intervals` is measuring, but `Leaps` is
    weighted half as much.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Leaps`尝试最小化跳跃，即音符之间超过5个半音的间隔。它与`Intervals`测量的内容存在竞争关系，但`Leaps`的权重是`Intervals`的一半。
- en: Now that we have a high-level understanding of what the objective function measures,
    let’s look at the corresponding code and its essential parts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对目标函数的作用有了高层次的理解，让我们看一下对应的代码及其核心部分。
- en: '**Distance**'
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**距离**'
- en: 'The `Distance` method uses the Hamming distance between the notes of the melody
    and the notes that should be in the melody if it conforms to the desired mode.
    Here’s the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distance`方法使用旋律音符与符合期望音阶的旋律音符之间的汉明距离。以下是代码：'
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ModeNotes` method, not shown, returns two lists where each element is 1
    if the corresponding note is in the melody (`A`) or belongs in the melody given
    the mode (`B`). The versions in `a` and `b` cover the given melody’s range.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModeNotes`方法（未显示）返回两个列表，其中每个元素如果对应的音符在旋律中（`A`）或属于给定音阶的旋律（`B`），则值为1。`a`和`b`中的版本覆盖了给定旋律的范围。'
- en: The `score` variable holds the Hamming distance between `a` and `b`. The Hamming
    distance is the number of mismatched bit positions. Scaling by the length of the
    melody transforms the count into a fraction of the melody, [0, 1], which is returned.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`变量保存`a`和`b`之间的汉明距离。汉明距离是指不匹配的位数。通过旋律的长度进行缩放，将计数转化为旋律的一个分数值[0, 1]，并返回该值。'
- en: '**Durations**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**持续时间**'
- en: 'The `Durations` method calculates a score reflecting how closely the distribution
    of note durations matches the ad hoc predefined “best” mix that favors quarter
    and half notes. In code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Durations`方法计算一个评分，反映音符持续时间的分布与临时预定义的“最佳”混合（偏好四分音符和二分音符）之间的匹配程度。以下是代码：'
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we set `d` to the durations of the current melody so that `bincount`
    can create the corresponding distribution, `b`, which is scaled to a probability.
    The desired mix of note durations is in `a` and likewise scaled to be a probability.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`d`设置为当前旋律的持续时间，以便`bincount`可以创建相应的分布`b`，并将其缩放为概率。所期望的音符持续时间混合存储在`a`中，并同样缩放为概率。
- en: The sum of the squared distance between the two distributions is returned as
    the duration score.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个分布之间平方距离的总和作为持续时间评分。
- en: '**Intervals**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**音程**'
- en: 'The interval between two notes is measured in semitones. The `Intervals` method
    counts the number of major thirds (4 semitones), minor thirds (3 semitones), and
    fifths (7 semitones) in the melody and transforms those numbers into a score.
    In code this becomes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个音符之间的音程是用半音来衡量的。`音程`方法计算旋律中大三度（4 个半音）、小三度（3 个半音）和五度（7 个半音）的数量，并将这些数字转化为分数。在代码中，这变成了：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code examines each pair of notes in the melody. We use the difference in
    semitones to count the number of thirds and fifths. We then assign `w` the weighted
    mean of these counts where, by fiat, I’m favoring thirds over fifths by 3 to 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查旋律中的每一对音符。我们使用半音的差异来计算三度和五度的数量。然后，我们将 `w` 赋值为这些计数的加权平均数，其中，按照规定，我偏爱三度而非五度，比例为
    3:1。
- en: The higher `w` is, the more the melody conforms to the desired interval arrangement;
    therefore, subtract the scaled `w` score from 1 to minimize.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`w` 的值越高，旋律越符合期望的音程排列；因此，从 1 中减去缩放后的 `w` 分数以进行最小化。'
- en: '**Leaps**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**跳跃**'
- en: 'The final part of the objective function score is `Leaps`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数评分的最后一部分是 `跳跃`：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A leap is any difference between a pair of notes that exceeds 5 semitones, either
    up or down. Smaller distances imply a smoother melody. We return the fraction
    of the melody that are leaps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃是指两个音符之间的音程差超过 5 个半音，无论是向上还是向下。较小的音程意味着旋律更加平滑。我们返回旋律中包含跳跃的部分。
- en: Why use these components in the objective function and not others? No reason
    other than a perusal of thoughts on what makes a good melody mentions some of
    these. Music is subjective, and it isn’t possible to create an objective objective
    function. “Exercises” on [page 254](ch08.xhtml#ch00lev1_53) asks you to think
    of other terms that might fit well in `MusicObjective`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在目标函数中使用这些组件而不是其他组件？没有特别的理由，仅仅是因为在对什么构成好旋律的思考中提到了其中一些。音乐是主观的，不可能创建一个完全客观的目标函数。
    [第 254 页](ch08.xhtml#ch00lev1_53)上的“练习”要求你思考其他可能适合 `MusicObjective` 的术语。
- en: '**GENERATIVE AI**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成式 AI**'
- en: The discussions of generative art and music in [Chapters 7](ch07.xhtml) and
    [8](ch08.xhtml) make no mention of artificial intelligence, and thus are incomplete.
    However, throwing AI into the mix would turn these chapters into a book. Instead,
    I’ll point you toward AI-based examples of generative art and music. Most of these
    use *generative adversarial networks*, *deep style transfer*, *variational autoencoders*,
    or related techniques that depend on deep neural networks to either sample from
    some learned representation space or merge features from embedded representations
    to build new output from multiple inputs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](ch07.xhtml)和[第 8 章](ch08.xhtml)中关于生成艺术和音乐的讨论没有提到人工智能，因此这些内容是不完整的。然而，将人工智能引入其中会使这些章节变成一本书。因此，我会引导你去了解基于
    AI 的生成艺术和音乐实例。大多数这些实例使用*生成对抗网络*、*深度风格迁移*、*变分自编码器*或相关技术，这些技术依赖于深度神经网络来从某个学习的表示空间中采样，或将嵌入表示中的特征融合起来，从多个输入构建新的输出。'
- en: 'If you want to explore what AI can do in this area, *[https://aiartists.org](https://aiartists.org)*
    is a good place to start and has links to artists and tools to make AI-based art
    and music. A fun, advanced approach to evolutionary algorithms and music is found
    in Al Biles’ GenJam at *[https://genjam.org](https://genjam.org)*. I recommend
    the video examples, especially the TEDx talk demonstrating and explaining the
    system. We’ve witnessed an explosion of powerful AI-based text, image, and video
    generation systems, including Stable Diffusion, DALL-E 2, and ChatGPT. New systems
    and updates appear weekly, but these should get you started:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索人工智能在这一领域的应用，* [https://aiartists.org](https://aiartists.org)* 是一个很好的起点，并且提供了通向艺术家和工具的链接，这些工具可以用来创作基于
    AI 的艺术和音乐。Al Biles 的 GenJam 提供了一种有趣的、先进的进化算法和音乐方法，网址是 *[https://genjam.org](https://genjam.org)*。我推荐观看视频示例，特别是
    TEDx 演讲，它展示并解释了这个系统。我们已经目睹了强大的基于 AI 的文本、图像和视频生成系统的爆发，包括 Stable Diffusion、DALL-E
    2 和 ChatGPT。新系统和更新每周都会出现，但这些应该足以让你入门：
- en: '**DALL-E 2**   *[https://openai.com/dall-e-2](https://openai.com/dall-e-2)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**DALL-E 2**   *[https://openai.com/dall-e-2](https://openai.com/dall-e-2)*'
- en: '**Stable Diffusion**   *[https://beta.dreamstudio.ai/](https://beta.dreamstudio.ai/)*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stable Diffusion**   *[https://beta.dreamstudio.ai/](https://beta.dreamstudio.ai/)*'
- en: '**ChatGPT**   *[https://openai.com/blog/chatgpt](https://openai.com/blog/chatgpt)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**ChatGPT**   *[https://openai.com/blog/chatgpt](https://openai.com/blog/chatgpt)*'
- en: '**Exercises**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Like generative art, there’s no end to what we can do with generative music.
    Here are some exercises related to this chapter’s experiments.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 像生成艺术一样，生成音乐也没有尽头。以下是与本章实验相关的一些练习。
- en: Alter the clipping range in *sine_walker.py*. How does this affect the overall
    sound? What does the waveform look like in Audacity?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*sine_walker.py*中的裁剪范围。这会如何影响整体声音？在Audacity中，波形是什么样子的？
- en: 'You can change the key in *note_walker.py* by altering the frequency table.
    For example, to change from C major to D minor, flatten the B notes: 246.94 →
    233.08, 493.88 → 466.16, and 987.77 → 932.33.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过更改频率表来改变*note_walker.py*中的调性。例如，要从C大调改为D小调，可以将B音符降低：246.94 → 233.08，493.88
    → 466.16，987.77 → 932.33。
- en: The last argument to `addProgramChange` in *melody_maker*’s `StoreMelody` function
    specifies the MIDI instrument number. The default is 0 for an acoustic piano.
    Change this number using the *MIDI_instruments.txt* list. For example, try 30
    for a distorted electric guitar or 13 for a xylophone. The oboe, barely breathing,
    is 68\. Or go for broke with 114, steel drums.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addProgramChange`函数的最后一个参数在*melody_maker*的`StoreMelody`函数中指定了MIDI乐器编号。默认值是0，表示声学钢琴。可以通过修改*MIDI_instruments.txt*列表来更改此数字。例如，试试30代表失真电吉他，13代表木琴。几乎无法听到气息的双簧管是68。或者，尝试114，钢鼓，放手一搏。'
- en: Alter *melody_maker*’s objective function weighting in the `Evaluate` method.
    Does it sound as nice if all components are weighted the same? What happens if
    you reverse the weighting?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*melody_maker*的目标函数加权，在`Evaluate`方法中进行。若所有组件的加权相同，效果如何？如果反转加权会发生什么？
- en: What other terms can you add to *melody_maker*’s objective function?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能在*melody_maker*的目标函数中添加其他术语吗？
- en: '**Summary**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced us to randomness in generative music beginning with
    audio and a random walk of sine waves to produce otherworldly sound effects. Restricting
    the frequencies to those of a musical scale transformed the odd sounds into something
    akin to a pipe organ.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了生成音乐中的随机性，从音频和随机行走的正弦波开始，产生了其他worldly的音效。将频率限制在音乐音阶内，使这些奇怪的声音转变成类似管风琴的音响。
- en: We closed the chapter by evolving melodies from scratch using swarm intelligence
    and evolutionary algorithms. We were moderately successful in that the evolved
    melodies did, for the most part, conform to the desired musical mode. Along the
    way, we saw an example of how to create simple MIDI files in code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾我们通过群体智能和进化算法从零开始演化旋律。我们在一定程度上取得了成功，演化出的旋律大多数符合预期的音乐调式。在这个过程中，我们还看到如何通过代码创建简单的MIDI文件。
- en: 'We’ll change gears in the next chapter to explore randomness in an entirely
    different domain: recovering a signal from a small collection of measurements.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将转换话题，探索随机性在一个完全不同领域中的应用：从少量测量数据中恢复信号。
