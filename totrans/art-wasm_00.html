<html><head></head><body><div id="sbo-rt-content"><section epub:type="introduction">
<header><h1 class="FrontmatterTitleIntroduction" id="fm-501737f07-0001"><span epub:type="pagebreak" title="xix" id="Page_xix"/>Introduction</h1></header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">Welcome to <em>The Art of WebAssembly</em>. This book teaches you how to read, write, and understand WebAssembly at the virtual machine level. It will help you learn how WebAssembly interacts with JavaScript, the web browser, and the embedding environment. By the end, you’ll comprehend what WebAssembly is, its ideal use cases, and how to write WebAssembly that performs at near-native speeds.</p>
<h2 id="h1-501737f07-0001">Who Should Read This Book</h2>
<p class="BodyFirst">This book is for web developers interested in understanding when and why to use WebAssembly. If you truly want to grasp WebAssembly, you need to learn it in detail. Several books have been written on various WebAssembly toolchains. This book is not specific to writing C/C++ or Rust, or any other <span epub:type="pagebreak" title="xx" id="Page_xx"/>language for WebAssembly; instead, it explores WebAssembly’s mechanisms and capabilities.</p>
<p>This book is for users who want to understand what WebAssembly is, what it can do, and how to use it best. WebAssembly can perform better and create smaller downloads and memory footprints than JavaScript. But developing high-performing WebAssembly applications requires more than simply writing an app in a language like C++/Rust or AssemblyScript and compiling it in WebAssembly. To build an application that executes two or three times as fast as its JavaScript equivalent, you’ll need to know how WebAssembly works at a deeper level.</p>
<p>Readers should have a basic familiarity with web technologies, such as JavaScript, HTML, and CSS, but don’t need to be experts in any of them. In its current incarnation, it isn’t easy to use WebAssembly without understanding the web and how it works. I don’t explain the basics of a web page, but I also don’t assume readers have much knowledge of how the web works either.</p>
<h2 id="h1-501737f07-0002">Why Users Are Interested in WebAssembly</h2>
<p class="BodyFirst">At the first WebAssembly summit, Ashley Williams (<a href="http://www.twitter.com/@ag_dubs">@ag_dubs</a>) presented the result of her Twitter polls asking WebAssembly users why they were interested in the technology. Here are the results:</p>
<ul>
<li>Multi-language, 40.1 percent</li>
<li>Smaller faster code, 36.8 percent</li>
<li>Sandboxed (security), 17.3 percent</li>
</ul>
<p>She then asked users who were interested in WebAssembly for its support of multiple languages why that was so:</p>
<ul>
<li>JavaScript doesn’t meet my needs, 43.5 percent</li>
<li>Reuse of existing libraries, 40.8 percent</li>
<li>Preexisting app distro (distribution), 8.1 percent</li>
</ul>
<p>Of those users who thought JavaScript didn’t meet their needs, she asked why:</p>
<ul>
<li>Performance is bad or inconsistent, 42 percent</li>
<li>The ecosystem doesn’t meet my needs, 17.4 percent</li>
<li>I don’t like or understand it, 31.3 percent</li>
</ul>
<p>You can watch her talk, “Why the #wasmsummit Website Isn’t Written in Wasm,” on YouTube at <a href="https://www.youtube.com/watch?v=J5Rs9oG3FdI" class="LinkURL">https://www.youtube.com/watch?v=J5Rs9oG3FdI</a>.</p>
<p>Although these polls weren’t scientific, they’re still rather illuminating. For one, if you combine the first and third poll users interested in using WebAssembly to improve an app’s performance, the total is more than 55 percent. Improving your code’s performance with WebAssembly is unquestionably possible. But to really utilize WebAssembly isn’t magic; you just need to know what you’re doing. By the end of this book, you’ll know enough about WebAssembly to drastically improve the performance of your web apps.</p>
<h2 id="h1-501737f07-0003"><span epub:type="pagebreak" title="xxi" id="Page_xxi"/>Why the World Needs WebAssembly</h2>
<p class="BodyFirst">I’ve been developing web applications since the mid-1990s. Initially, web pages were no more than documents with images. That changed with the emergence of Java and JavaScript. At the time, JavaScript was a toy language that could add rollover effects to buttons on your web pages. Java was the real deal, and the Java virtual machine (JVM) was an exciting technology. But Java never reached its full potential on the web platform. Java requires a plug-in, and the plug-in technology eventually fell out of fashion when it became a security and malware nightmare.</p>
<p>Unfortunately, Java is a proprietary technology, which prevented its direct integration into the web browser. However, WebAssembly is different in that it wasn’t created unilaterally by a single technology company. WebAssembly began its life as a collaboration between many hardware and software vendors, such as Google, Mozilla, Microsoft, and Apple. It’s available without a plug-in in every modern web browser. You can use it to write hardware-independent software using Node.js. Because it’s not proprietary, any hardware or software platform can use it without royalty or permission. It fulfills the 1990s-era dream of <em>one binary to rule them all</em>.</p>
<h2 id="h1-501737f07-0004">What’s in This Book</h2>
<p class="BodyFirst">In this book, we will walk you through how WebAssembly works at a low level by introducing you to WebAssembly Text format. We will cover many low-level topics and take some time to show you how WebAssembly works with JavaScript in Node.js and web-based applications. The book is intended to be read in order, with concepts building on each other. There are also references throughout the book to code examples that can be found at <a href="https://wasmbook.com" class="LinkURL">https://wasmbook.com</a>. </p>
<p class="ListHead"><b>Chapter 1: An Introduction to WebAssembly</b></p>
<ol class="none">
<li>We go into detail about what WebAssembly is, what it isn’t, and when best to use it. You’re introduced to WebAssembly Text (WAT), which allows you to understand how WebAssembly works at the lowest level. We also set up the environment you’ll use to follow along with the examples in the book. </li>
</ol>
<p class="ListHead"><b>Chapter 2: WebAssembly Text Basics</b></p>
<ol class="none">
<li>We cover the basics of WAT and how it relates to high-level languages that deploy to WebAssembly. You’ll write your first WAT program, and we’ll discuss fundamentals like variable use and control flow. </li>
</ol>
<p class="ListHead"><b>Chapter 3: Functions and Tables</b></p>
<ol class="none">
<li>We discuss creating functions in WebAssembly modules and calling them from JavaScript. You’ll build a program to check for prime numbers to illustrate these concepts. We investigate calling functions from tables and performance implications.</li>
</ol>
<p class="ListHead"><b><span epub:type="pagebreak" title="xxii" id="Page_xxii"/>Chapter 4: Low-Level Bit Manipulation</b></p>
<ol class="none">
<li>You learn about the low-level concepts you can use to improve your WebAssembly modules’ performance, such as number systems, bit masking, and 2s complement.</li>
</ol>
<p class="ListHead"><b>Chapter 5: Strings in WebAssembly</b></p>
<ol class="none">
<li>WebAssembly doesn’t have a built-in string data type, so in this chapter you will learn how strings are represented in WebAssembly, and how to manipulate them.</li>
</ol>
<p class="ListHead"><b>Chapter 6: Linear Memory</b></p>
<ol class="none">
<li>You’re introduced to linear memory and how WebAssembly modules use it to share large data sets with JavaScript or an alternative embedding environment. We start creating an object collision program that sets objects moving randomly and checks for object collisions, which we then use throughout the book. </li>
</ol>
<p class="ListHead"><b>Chapter 7: Web Applications</b></p>
<ol class="none">
<li>You learn how to create a simple web application using HTML, CSS, JavaScript, and WebAssembly.</li>
</ol>
<p class="ListHead"><b>Chapter 8: Working with the Canvas</b></p>
<ol class="none">
<li>We discuss how to use the HTML canvas with WebAssembly to create lightning-fast web animations. We use the canvas to improve our object collision application. </li>
</ol>
<p class="ListHead"><b>Chapter 9: Optimizing Performance</b></p>
<ol class="none">
<li>You learn how WebAssembly works well for computationally intensive tasks, such as collision detection. You spend some time using Chrome and Firefox profilers and other optimization tools to improve our applications’ performance.</li>
</ol>
<p class="ListHead"><b>Chapter 10: Debugging WebAssembly</b></p>
<ol class="none">
<li>We will cover debugging basics such as logging to the console using alerts and stack traces. You will also learn how to use the debuggers in Chrome and Firefox to step through our WebAssembly code.</li>
</ol>
<p class="ListHead"><b>Chapter 11: AssemblyScript</b></p>
<ol class="none">
<li>We discuss using WAT to understand high-level languages by using it to evaluate AssemblyScript, a high-level language designed to deploy to WebAssembly in an efficient way.</li>
</ol>
</section>
</div></body></html>