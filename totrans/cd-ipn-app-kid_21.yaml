- en: '**18**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GAME STATE, MENUS, SOUNDS, AND SPECIAL EFFECTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add the concept of *state* to Schoolhouse Skateboarder.
    The state of a game is what mode the game is in, such as whether the game is running
    or has ended and is waiting to start again. Up until this point, the game was
    always running, and it immediately started over when it ended. Keeping track of
    the game’s state will allow us to add a simple menu system to show when the game
    is over. We’ll also add some sounds to the game and create some special effects
    using a particle emitter.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING GAME STATE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: GAME STATE, MENUS, SOUNDS, AND SPECIAL EFFECTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add the concept of *state* to Schoolhouse Skateboarder.
    The state of a game is what mode the game is in, such as whether the game is running
    or has ended and is waiting to start again. Up until this point, the game was
    always running, and it immediately started over when it ended. Keeping track of
    the game’s state will allow us to add a simple menu system to show when the game
    is over. We’ll also add some sounds to the game and create some special effects
    using a particle emitter.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING GAME STATE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add the concept of *state* to Schoolhouse Skateboarder.
    The state of a game is what mode the game is in, such as whether the game is running
    or has ended and is waiting to start again. Up until this point, the game was
    always running, and it immediately started over when it ended. Keeping track of
    the game’s state will allow us to add a simple menu system to show when the game
    is over. We’ll also add some sounds to the game and create some special effects
    using a particle emitter.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING GAME STATE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll add the concept of *state* to Schoolhouse Skateboarder.
    The state of a game is what mode the game is in, such as whether the game is running
    or has ended and is waiting to start again. Up until this point, the game was
    always running, and it immediately started over when it ended. Keeping track of
    the game’s state will allow us to add a simple menu system to show when the game
    is over. We’ll also add some sounds to the game and create some special effects
    using a particle emitter.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING GAME STATE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING GAME STATE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we’ll create an enum that lists the various states the game can be in.
    Add this new enum inside the GameScene class, just after the BrickLevel enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this enum is placed inside the GameScene class because it won’t be
    needed by any other class outside of GameScene . Unlike the enum we created for
    BrickLevel , this enum doesn’t have a raw value. This enum just contains the cases
    we need to create a GameState data type, and we don’t need to associate any values
    with each case. When the app is first started, the state will be notRunning .
    While the game is being played, the state will be running . When the game has
    ended and is waiting to start over, the state will be set back to notRunning .
    Putting these states in an enum makes it easier to expand the game in the future
    and add more states. For example, if we added a pause button, we could add a paused
    case to this enum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a class property to track the current value of the game’s state.
    We’ll call it gameState and put it in the GameScene class just after the brickLevel
    declaration, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: This new variable, gameState , will track what state the game is in. We set
    its initial value to notRunning since that’s the state we want the game to be
    in when the app first starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game starts, we need to set our gameState to running . Add this line
    to the startGame() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'And when the game ends, we want to make sure we set the state back to notRunning
    . Add this line to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a variable to keep track of our game’s state, we need to do
    something with it. If you run the game right now, you’ll see that a new game still
    starts immediately after the current game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the game to actually stop, first remove the startGame() method call
    from the gameOver() method so it doesn’t automatically start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the game now, a new game will not automatically start when the skater
    falls off the screen. Instead, the bricks will continue moving. To make game updates
    stop when the game is over, add this code to the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now our game loop won’t do anything unless the game is running. This is because
    the method ends at the return keyword and all the following code won’t be executed.
    Run the game again, and you should see everything stop when the skater falls down
    or gets pushed off the screen. This isn’t a very friendly game-over screen, though.
    We need to add a menu system to tell the player that the game is over and let
    them know they can tap to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A MENU SYSTEM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add two menu screens to the game: one that appears at the start of the
    game to instruct the player to tap to play and another that appears at the end
    of the game to let them know the game is over.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: To add the menu screens, we’ll create a new class called MenuLayer . Then we’ll
    create one MenuLayer object for each screen, so we’ll end up with two MenuLayer
    objects in total. The class will be a subclass of SKSpriteNode , and we’ll use
    it to display messages on the screen, such as “Tap to play” or “Game Over!” This
    MenuLayer class will essentially be our menu system for the game. [Figure 18-1](text00030.html#ch18fig1)
    shows how our completed menu screens will look.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00315.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-1: The “Tap to play” menu layer will be shown when the app is first
    run, and the “Game Over!” layer will be shown once the game ends.*'
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Menu screens usually have multiple options for the user to pick from, but ours
    will just be used to display simple messages. If we were going to add an option
    such as the ability to turn sounds on or off, this menu layer would be a good
    place to do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE MENULAYER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the MenuLayer class, create a new class by right-clicking (or CONTROL
    -clicking) the *SchoolhouseSkateboarder* folder in the Project navigator and selecting
    **New File…** . Choose the iOS Source template called Cocoa Touch Class. Name
    the new class MenuLayer , make it a subclass of SKSpriteNode, and choose the default
    file location to create the new file. Your new class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like when we created the Skater class, the first thing we need to do is
    change the import statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new method inside the MenuLayer class that will allow us to display
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will be used to present messages—such as “Game Over!”—in a menu
    layer. It will also allow us, if we wish, to display the player’s score, which
    we’ve defined as an optional. First, let’s add the code that creates the main
    message label. Add this code inside the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: This code should look familiar because it’s very similar to the code we wrote
    in the setUpLabels() method in the GameScene class to create the score labels.
    At ➊ , we create a label using the message parameter that was passed in to the
    method as the text to display. Next we determine the starting position of the
    label. We’ll use an action to animate the label moving from the left side of the
    screen to the center of the screen. In order to do that, we need to first set
    its position off the screen to the left.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we use -frame.width as the x-position to set the label one full screen’s
    width to the left. At ➌ , we use frame.height / 2.0 as the y-position to set the
    label vertically in the center of the screen. We also want this label to be centered
    horizontally within its frame, so that when we move the label to the middle of
    the screen, it will be perfectly centered. To do this, we set the label’s horizontalAlignmentMode
    to .center at ➍ . Now that we’ve positioned the label, we set its font, font size,
    and zPosition and add it as a child of the MenuLayer .
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Actions to Animate the Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a reason we gave the label an x-position to place it off to the left
    side of the screen and a y-position to place it vertically in the middle of the
    screen. We want to add some flair by having the label zoom onto the screen! Add
    this animation code to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ calculates the final x-position where the label should move in
    order to end up at the center of the screen. The line at ➋ creates a new object
    called an SKAction . In SpriteKit, you can use an SKAction to do a huge number
    of interesting things with nodes—everything from spinning around and fading out
    to moving along a path. Here we’re using moveTo(x:duration:) , which creates an
    action to move a node to a new x-position. We pass in the finalX position that
    we calculated before and give it a duration value. The duration value tells the
    action how long the animation should take. We want the label to zoom onto the
    screen pretty fast, so we set a short duration of 0.3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ tells the message label to run this action. Actions that
    you create describe what a node should do, but nothing will happen until you tell
    a node to run that action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-1](text00030.html#ch18tab1) describes some common action methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-1:** Common SKAction Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '| **SKAction method** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '| move(to:duration:) | Moves the node to a new location |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(x:duration:) | Moves the node to a new x-position, keeping the same
    y-position |'
  prefs: []
  type: TYPE_TB
- en: '| moveTo(y:duration:) | Moves the node to a new y-position, keeping the same
    x-position |'
  prefs: []
  type: TYPE_TB
- en: '| move(by:duration) | Moves the node by a given amount from its current location
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(toAngle:duration:) | Rotates the node to a new angle |'
  prefs: []
  type: TYPE_TB
- en: '| rotate(byAngle:duration:) | Rotates the node by a given angle amount |'
  prefs: []
  type: TYPE_TB
- en: '| resize(toWidth:height:duration:) | Resizes the node to a new width and height
    |'
  prefs: []
  type: TYPE_TB
- en: '| resize(byWidth:height:duration:) | Resizes the node by the amounts given
    |'
  prefs: []
  type: TYPE_TB
- en: '| scale(to:duration:) | Scales the node to a new scale; for example, if the
    node was originally at a scale of 1.0 (the default), scaling it to 2.0 would double
    its size |'
  prefs: []
  type: TYPE_TB
- en: '| fadeIn(withDuration:) | Fades in the node |'
  prefs: []
  type: TYPE_TB
- en: '| fadeOut(withDuration:) | Fades out the node |'
  prefs: []
  type: TYPE_TB
- en: '| playSoundFileNamed(_:waitForCompletion:) | Plays a sound file, such as a
    .wav file |'
  prefs: []
  type: TYPE_TB
- en: '| sequence(_:) | Sequences multiple actions together |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there’s quite a lot you can do with an SKAction ! You’ll notice
    that many of the SKAction methods have a *to* version and a *by* version, such
    as move(to:duration:) and move(by:duration:) . The *to* version of an action just
    does the action no matter what the state of the node was originally. For instance,
    if you want to move a sprite to a new location, say to the middle of the screen,
    you would use the *to* version and set the new location. The node will move to
    the location regardless of whether it was originally offscreen, onscreen, or to
    the left or right of the new location. If you want to make the node move according
    to where it is already positioned, you would use the *by* version of the action.
    For instance, if you wanted to make a sprite move 50.0 to the right of its current
    position, you would use move(by:duration:) with an x amount of 50.0 .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the message label set up, let’s add the code to optionally
    display a score label so the player can see their final score at the end of each
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionally Showing a Score Label**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our display(message:score:) method, the score parameter is optional. So
    we need to check if it exists before we can display the player’s score on the
    game-over screen. If the score was passed in and is not nil , then we’ll show
    a score label that animates in from the right side of the screen. If the score
    parameter doesn’t exist, then the score label won’t be created. Add this code
    to the display(message:score:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*MenuLayer.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the score label is practically identical to the code for the message
    label. The only difference is that the label is first positioned with an x-position
    just off the right edge of the menu layer ➊ and a y-position that is just below
    the message label ➋ . Just like the messageLabel object, after the scoreLabel
    object is created and added as a child of the MenuLayer class, it’s animated to
    the center of the screen via an SKAction ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE MENU LAYERS WHEN NEEDED**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the MenuLayer class set up, we need to actually use it to
    make the menu layers. The first time we want to show a menu layer is right when
    the application starts. We don’t want the game to just automatically start anymore.
    Instead, we want the player to see a menu screen asking them to tap the screen
    to start playing. So, in the didMove(to:) method of the GameScene , *remove* the
    line of code that calls the startGame() method, and add this code in its place
    to display a menu layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: This code makes a new MenuLayer object with the message “Tap to play” displayed
    in its label. Now, instead of the game starting right away, this message will
    be displayed. The line at ➊ creates a UIColor using black as a starting point
    and then applies an alpha component of 0.4 to it. *Alpha* sets how transparent
    something is on a scale from 0.0 to 1.0 . If we set an alpha of 0.0 , then the
    color would be fully invisible or transparent. An alpha of 0.5 makes a color half
    transparent, like a sheer fabric. An alpha of 1.0 means that the color is completely
    opaque—not transparent at all. For the menu layer, setting a partially transparent
    background color will make it look like the menu text is on top of the game. This
    line just sets up the UIColor . In order to actually make the screen darken, we
    need to apply the color to the MenuLayer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ creates a new MenuLayer object by passing in the color we created
    and setting the object’s size equal to the size of the scene’s frame . This makes
    the menu layer as big as the game scene so it can completely cover it when shown.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ sets the anchorPoint of the menu layer node to (0.0, 0.0) . As
    you learned in [Chapter 14](text00026.html#ch14) , these coordinates set the anchor
    point in the node’s lower-left corner. Next we set the position of the menu layer
    to (0.0, 0.0) as well. Because the menu layer and the scene are the same size,
    we can ensure that the menu layer fits perfectly over the scene by pinning both
    the anchor point and the position at (0.0, 0.0) .
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ calls the display(message:score:) method on our new menuLayer
    . We pass it the string "Tap to play" for the message that will animate onto the
    screen, and we pass nil for the score . We don’t want this screen to display a
    score, because the player doesn’t have one yet. Run the game now, and you should
    see the “Tap to play” menu layer appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other time we need to display a menu layer: when the game ends.
    Add the following code to the gameOver() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: This menu layer is just like the one we created for the start of the game, except
    it has a different message ➊ and we pass in the player’s score ➋ . So when the
    game ends, the screen will display both the “Game Over!” message and the score
    the player achieved in that game.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING THE MENU LAYER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: When the player taps on the screen while on the “Tap to play” menu, we want
    the game to start playing. However, our game is still set up only to make the
    skater jump when the player taps on the screen. Let’s update the handleTap(_:)
    method so that the skater jumps only when the game is running and, if a menu is
    being shown, the menu disappears and a new game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the handleTap(_:) method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: First, we wrap the jumping code inside an if statement that makes sure the gameState
    is equal to .running ➊ . If the game is not running, then the skater shouldn’t
    jump!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add an else block ➋ to handle what should happen when the player taps
    but the game is not running. Right now we have only two game states, running and
    notRunning . So if the game is not running, it must be showing a menu layer.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this else block, we need to get a reference to the menu layer by asking
    the scene for its child node by name. Both times when we created a new MenuLayer
    object, we set its name property to "menuLayer" so that we could retrieve it by
    this name using the childNode(withName:) method. We do that here with an if-let
    statement ➌ . Inside the if-let statement, we remove the menu from its parent
    ➍ , which will make the menu disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to close out this else block, we call startGame() ➎ . That should do
    it—run the game now, and you should have a fully functioning menu system!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING SOUNDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: While our new menu system has improved our game a lot, we can make it even more
    fun for players by adding some cool sound effects. Adding sound effects to a SpriteKit
    game is easy. It takes only one line of code to play a sound, and the right sound
    effects can really bring a game to life. But first we need to add the sound files
    to the project. We’ve prepared a couple of *.wav* files—one to play when the player
    jumps, and one to play when the player collects a gem.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE SOUND FILES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Download the sound files you’ll need from the book’s web page at [*https://www.nostarch.com/iphoneappsforkids/*](https://www.nostarch.com/iphoneappsforkids/)
    . Once the download is complete, you’ll have a folder named *ch18-sounds* inside
    your *Downloads* folder with all the files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: To add the sound files to your project, you’ll need to drag them from Finder
    into Xcode and drop them in the Project navigator, near *Assets.xcassets* . Once
    you drop them, an Import Options window will pop up. Make sure **Copy items if
    needed** is checked, as shown in [Figure 18-2](text00030.html#ch18fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-2: Import options for the sound files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see two new files in the Project navigator: *jump.wav* and *gem.wav*
    . Now that the sound files have been added to the project, they are ready to be
    used in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE SOUNDS AT THE RIGHT TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s add the code to play *jump.wav* when the player jumps. Add this
    line of code to the handleTap(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Since we already have a spot in the code where the player taps to make the skater
    jump, all we do is run an action on the scene to play the right sound file. The
    SKAction method playSoundFileNamed(_:waitForCompletion:) is given the name of
    the *.wav* file to play. We set waitForCompletion to false . This property would
    only matter if we were sequencing multiple actions together. Since we aren’t in
    this case, we set it to false . You’ll see an example of sequencing multiple actions
    together when we create a particle emitter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To play *gem.wav* when the player collects a gem, add this line of code to
    the didBegin(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the player collects a gem by touching it, in addition to getting 50
    extra points, they’ll hear the gem sound play. Run the game and see how it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHOOTING SPARKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to learn about something that will make our game even more exciting:
    particle emitters. A *particle emitter* is used in games to create special effects—snow,
    rain, fire, explosions, and more! You add a particle emitter to a game scene,
    and it shoots out (or emits) particles. The particles can be any image, such as
    a snowflake, a blob, or a bit of fire, and the particle emitter will shoot them
    out in whatever speed, direction, and quantity you tell it to. For example, to
    create an explosion, you can tell a particle emitter to emit fire particles in
    all directions at once. Or you can tell a particle emitter to emit snowflakes
    that drift downward from the entire top edge of the screen. For Schoolhouse Skateboarder,
    we’ll add a particle emitter that shoots sparks out from the bottom of the skateboard
    whenever the skater lands on the ground, because that’ll look cool.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Xcode has a fantastic built-in way to create particle emitters. CONTROL
    -click the *SchoolhouseSkateboarder* folder in the Project navigator and choose
    **New File…** . Then select **iOS** , scroll down to find the Resource section,
    choose **SpriteKit Particle File** , and click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will ask you which particle template to use. There are a handful of templates
    to choose from, and each one will give you a pretty good starting point for the
    type of effect you want to create. Since we’re making sparks for the skateboard,
    pick **Spark** and then click **Next** .
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode asks for a filename, change it to *sparks.sks* , make sure your project
    folder is already selected, and then click **Create** .
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should see a particle emitter shooting out sparks in every direction!
    This is the built-in particle editor, and we’ll use it to make these sparks look
    more like sparks that might shoot out from the wheels of the skateboard. First,
    as shown in [Figure 18-3](text00030.html#ch18fig3) , make sure the utility pane
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-3: Displaying the particle editor utility pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the fun of the particle editor is that you can play around with the
    settings and see what interesting emitters you can make. For the skateboard sparks,
    we’ve already done this and found some settings that look right. Update the emitter’s
    values in the right pane so they match [Table 18-2](text00030.html#ch18tab2) .
    For any values not listed in the table, make no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-2:** Particle Emitter Settings to Create Skateboard Sparks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Birthrate | 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Emitter, Maximum | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | 0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | 75 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | –3 |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | 0.1 |'
  prefs: []
  type: TYPE_TB
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done making the value changes for this emitter, it should look like
    [Figure 18-4](text00030.html#ch18fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: It’s amazing how many different special effects you can create with a particle
    emitter just by tweaking these settings. [Table 18-3](text00030.html#ch18tab3)
    explains what each setting does.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-4: Sparks emitter settings*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 18-3:** Particle Emitter Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Setting** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Can be set so that the emitter may be accessed later via childNode(withName:)
    . |'
  prefs: []
  type: TYPE_TB
- en: '| Background | Can be set in the .sks editor to make it easier to see the particle
    emitter you’re working on. This color is ignored when you create the emitter in
    your game code. |'
  prefs: []
  type: TYPE_TB
- en: '| Texture | The image file that should be used as the particles. SpriteKit
    will provide a basic spark.png image as the default when you create a new spark
    particle emitter, but you can use any image you want. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Start | How long, in seconds, each particle should be visible after
    it is emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime, Range | The amount of variation in a particle’s lifetime. A value
    of 0 means all particles have the lifetime specified in “Lifetime, Start,” whereas
    a value of 1.0 means that particle lifetimes are allowed to vary, randomly, by
    up to 1.0 second. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, X | The range of x-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same x-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    an x-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Y | The range of y-positions where the particles should spawn.
    A value of 0 means the particles will all spawn from the exact same y-position.
    A value of 100.0 means the particles should be allowed to spawn randomly over
    a y-position range of 100.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Position Range, Z | The range of z-position spawning for particles. Apple
    has marked this property as *deprecated* , which means it’s an old property that
    should no longer be used. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Start | The angle at which to shoot the particles out, in degrees,
    where 0 is straight to the right, 90 is up, 180 is left, 270 is down, and 360
    is right. Any valid CGFloat value may be used for the angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Angle, Range | The amount of variation in the emission angle. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Start | The speed at which the particles should be emitted. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed, Range | The amount of variation in emission speed. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, X | How much the particles should speed up in the x-direction
    after they’re emitted. A positive value means to accelerate to the right, and
    a negative value means to accelerate to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| Acceleration, Y | How much the particles should speed up in the y-direction
    after they’re emitted. A positive value means to accelerate upward, and a negative
    value means to accelerate downward. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Start | How transparent the particles should be when they’re emitted.
    Valid values are any CGFloat between 0.0 and 1.0 , where 0.0 means completely
    transparent, and 1.0 means completely opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Range | The amount of variation in alpha transparency. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha, Speed | How quickly the alpha transparency should change over the
    particle’s lifetime. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Start | The starting scale, or size, of the particles. A value of
    1.0 means normal-sized, not scaled up or down at all. A value of 2.0 means double-sized,
    0.5 means half-sized, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Range | The amount of variation in particle scale, or size. |'
  prefs: []
  type: TYPE_TB
- en: '| Scale, Speed | How quickly the scale of the particles should change. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Start | The rotation of the particles. For a texture like the *spark.png*
    default texture, rotation won’t be noticeable. But if you used the *skater.png*
    image as the texture, you would notice that 0.0 is right side up, and 180.0 is
    upside down. Any valid CGFloat value is allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Range | The amount of variation in particle rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation, Speed | How quickly the rotation of the particles should change.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Color Ramp | How the tint color of each particle should change over the particle’s
    lifetime. You can specify that the particles should start off as green, for example,
    turn blue, and then end up yellow before finally disappearing. |'
  prefs: []
  type: TYPE_TB
- en: '| Blend Mode | Allows you to set how the colors of overlapping particles should
    be blended together. |'
  prefs: []
  type: TYPE_TB
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that when you chose the Spark template, a new image file
    was added to the Project navigator, *spark.png* . This is the default image of
    a single spark that’s used by a sparks emitter. You can change the image in the
    emitter settings and have an emitter that shoots flowers or anything you want.
    But for now, we’ll leave it as sparks.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project navigator, also notice there is a *sparks.sks* file. This file
    describes the emitter we just created. So to use this emitter in our game, we
    just have to write some code that references this file. Switch to *Skater.swift*
    and add the following method inside the Skater class below the existing setupPhysicsBody()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: This code references the *sparks.sks* file that we created by looking it up
    in the project’s *bundle* —the grouping of files and assets that make up the project—and
    uses it to create an emitter, or SKEmitterNode , called sparksNode . In order
    to access the *sparks.sks* file, which is part of the project, we need to get
    a reference ➊ to the application’s main bundle, where all the files in the project
    will be. Once we have the bundle , we call its path(forResource:ofType:) method
    ➋ to get the file location, or path, of the *sparks.sks* file. The line at ➌ creates
    an SKEmitterNode named sparksNode with the help of the *sparks.sks* file we created,
    by calling NSKeyedUnarchiver.unarchiveObject(withFile:) . This function can convert
    certain files, such as *.sks* files, into Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sparksNode is created, we set its position ➍ and then add it as a child
    of the skater sprite ➎ . Since this emitter will be a child of the skater sprite,
    it will move around with the skater as if it were glued to her. More importantly,
    it’s very easy to position the emitter so that it’s on the bottom of the skater
    sprite. We simply set its position to (0.0, -50.0) , which places it on the bottom
    middle of the skater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like any other SpriteKit node, once we’re done with the emitter, we should
    remove it. This sparks emitter should take only half a second or less to finish
    shooting a few sparks. After that, we need to remove it so it’s not taking up
    memory and other system resources. Add this code to the new createSparks() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we used actions to animate some labels and play some sounds. There’s
    another cool thing we can do with actions: we can sequence them together. That
    means we can have a node automatically perform a series of actions, one after
    the other. We’ll make some variables first to store the actions we want to sequence
    in order to make the code easier to read. The line at ➊ creates waitAction using
    SKAction.wait(forDuration:) , which tells the node to wait for 0.5 seconds before
    moving on to the next action. The line at ➋ creates our next action, removeAction
    , which tells the node to remove itself from its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➌ creates a waitThenRemove action, which is a sequence of those
    other two actions. To create a sequence action, we call SKAction.sequence() and
    pass it an array of SKAction s. Since we already created waitAction and removeAction
    , we simply put them in an array using square brackets, like this: [waitAction,
    removeAction] . We only need two actions in our sequence, but there is no limit
    to how many actions you can string together this way. Finally, we simply tell
    the sparksNode to run that sequence of actions ➍ , and we’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Particle emitters, once created and added to the scene, are always emitting
    particles. Any actions you perform on an emitter will happen in addition to what
    the node is already doing, which in this case is emitting sparks. So if you animated
    a particle emitter to move across the screen, you wouldn’t be changing the way
    the particles behave, you’d just be changing where the particles are emitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to create sparks for the skateboard, we just need to
    add the code to decide when to actually call this createSparks() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to *GameScene.swift* , and update the first half of the didBegin(_:)
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have code to determine when the skater hits the ground, we
    just added an if statement to check if:'
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is *not* already on the ground (notice the exclamation point before
    skater.isOnGround , meaning we’re checking if she is not on the ground since !
    reverses the meaning of a Boolean value).
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: • The skater is going down, not up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Since the skater’s physics body is an optional and we can’t compare an optional
    to a number like 100.0 , we first need to unwrap the skater body’s y velocity,
    as shown at ➊ . Next, the line at ➋ checks that the skater is not already on the
    ground and that her y velocity is less than 100.0 . If both of these are true,
    then we call the skater’s createSparks() method ➌ in order to show the sparks
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: We check which direction the skater sprite is moving by looking at her physics
    body’s velocity in the dy direction. For velocity, dx means the horizontal direction
    (positive values are right and negative values are left), and dy means the vertical
    direction (positive values are up and negative values are down). To check if the
    skater is going down, technically we should check if her y velocity is less than
    0.0 . But we are checking if it is less than 100.0 , because sometimes when she
    first hits the bricks, her y velocity is slightly positive as she bounces off
    the bricks. So using a check for velocityY < 100.0 ensures we’ll always see the
    sparks when she hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: If both of the if conditions are met, then sparks will fly off of the skater’s
    skateboard, as shown in [Figure 18-5](text00030.html#ch18fig5) .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00322.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 18-5: Sparks fly!*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game now, and enjoy the cool-looking sparks whenever the skater lands
    on the ground!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Schoolhouse Skateboarder is now complete! Remember that the final project
    files are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    , *so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of ways to make a game more professional.
    You learned about game state and why it’s important to keep track of what state
    your game is in. You added a simple menu system to the game and used actions to
    animate the labels. Then you learned how to add sound effects to your game. Finally,
    you learned about particle emitters and used one to shoot sparks from the bottom
    of the skateboard.
  prefs: []
  type: TYPE_NORMAL
