- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEGOTIATE
    AUTHENTICATION AND OTHER SECURITY PACKAGES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two previous chapters covered the two main network authentication protocols
    in Windows, NTLM and Kerberos. However, Windows supports several more packages
    for performing authentication. In this chapter, we’ll briefly cover some of these
    other security packages.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll begin by providing more detail about how applications and security packages
    can use buffers to pass data back and forth using the SSPI APIs. This will help
    you understand some of the packages’ quirks. Then we’ll examine the Negotiate
    security package, as well as the less common secure channel and CredSSP packages.
    I’ll give a quick overview of some additional configuration options you have when
    setting up a network authentication context and finish up with a description of
    what happens when you want to use network authentication inside a process with
    a lowbox token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Security Buffers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, I’ve implied that using the SSPI APIs is simple: you generate a client
    authentication token, pass it to the server application, update the server authentication
    context, receive a token in response, and repeat the process until the authentication
    is complete. However, because of the complexity of the supported network authentication
    protocols, these APIs can accept and return more than just an authentication token.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication context, encryption, and signature APIs accept arrays of
    generic *security buffer* structures as parameters. This security buffer structure,
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">SecBuffer</samp> in the native
    SDK, is wrapped by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityBuffer</samp>
    class in the PowerShell module. Each security buffer structure contains a field
    that determines what type of data the buffer represents and a sized memory buffer
    for the contents. You can create a buffer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaSecurityBuffer</samp>
    PowerShell command, specifying the type and contents of the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify either a byte array or a string when initializing the data.
    You also specify a type for the buffer. The following is a short list of the most
    important buffer types you’ll encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Empty  </samp>Contains no data;
    sometimes used as a placeholder for a return value
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data  </samp>Contains initialized
    data; used to pass and return data, such as a message to encrypt
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Token  </samp>Contains a token;
    used to pass and return authentication tokens and signatures
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PkgParams  </samp>Contains additional
    configuration parameters for the security package
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamHeader  </samp>Contains the
    header of a streaming protocol
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamTrailer  </samp>Contains
    the trailer of a streaming protocol
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stream  </samp>Contains the data
    of a streaming protocol
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Extra  </samp>Contains extra data
    generated by the security package
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChannelBindings  </samp>Contains
    the channel binding data
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use security buffers as either input or output, depending on the security
    package’s requirements and the API used. If you want to define an output-only
    buffer, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    parameter when creating the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you may want to pass an initialized buffer whose contents the package
    shouldn’t modify. To indicate this, the APIs specify two additional flags you
    can add to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnly  </samp>The buffer is
    read-only but is not part of the signature.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnlyWithChecksum  </samp>The
    buffer is read-only and should be part of the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You specify these additional flags using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> parameter
    when creating a buffer, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Whether the difference between the two read-only flags is honored depends on
    the security package. For example, NTLM ignores the difference and always adds
    a read-only buffer to the signature, while Kerberos adds the buffer as part of
    the signature only if the buffer you supply has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp>
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with
    an Authentication Context</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The SSPI APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell commands take two lists of security buffers: one to use as input to
    the API and one to use as output. You can specify the list of these buffers using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InputBuffer</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OutputBuffer</samp> parameters, as shown
    in [Listing 15-1](chapter15.xhtml#Lis15-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: Using input and output buffers with an authentication context'
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows a hypothetical use of input and output buffers during authentication.
    (You’ll see actual examples over the course of this chapter.) This example assumes
    you’ve already set up a client authentication context as <samp class="SANS_TheSansMonoCd_W5Regular_11">$client</samp>
    and a server authentication token as <samp class="SANS_TheSansMonoCd_W5Regular_11">$token</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We first create one input buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>
    containing a string ❶. The contents of the buffer depend on the package you’re
    using; normally, the API’s documentation will tell you what you need to specify.
    Next, we create an output buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>,
    allocating a maximum buffer size of 100 bytes ❷. We then update the client context,
    passing it the server authentication token and the input and output buffers ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The command will add the token as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    type buffer to the start of the input list, and will also append any channel bindings
    specified when creating the context. Therefore, the input buffer list passed in
    this case would contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>
    buffer. Sometimes the package doesn’t want you to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer; in that case, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoToken</samp>
    parameter to exclude it from the input list.
  prefs: []
  type: TYPE_NORMAL
- en: The command also automatically adds the output <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer for the new authentication token to the output list. If the API call succeeds,
    it will assign the contents of this buffer to the context’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    property. It’s not normally necessary to exclude that buffer from the output,
    so the command doesn’t give you that option.
  prefs: []
  type: TYPE_NORMAL
- en: After a successful call, we check the output buffer, which has been updated.
    Certain packages might change an output buffer’s type, size, and contents. For
    instance, the type in this example has been changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Extra</samp>. We can convert
    the buffer back to a byte array using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>
    command. Displaying the output shows that the 100-byte buffer we’ve created now
    has only 4 valid bytes. The security package initialized these 4 bytes and updated
    the structure’s length accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with
    Signing and Sealing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter,
    you can specify buffers during signing and sealing operations when calling the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    PowerShell commands, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>.
    The underlying APIs take only a single list of buffers to use for both the input
    and output. In [Listing 15-2](chapter15.xhtml#Lis15-2), we encrypt a buffer containing
    an additional header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: Encrypting a message with buffers'
  prefs: []
  type: TYPE_NORMAL
- en: We first create the header buffer, marking it as read-only with a checksum.
    By marking it as read-only, we ensure that the contents won’t be encrypted but
    will still be included in the signature. Next, we create the data buffer from
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: We then pass the buffers to <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>.
    This command returns the signature for the encryption operation and updates the
    encrypted data in place. When dumping the buffers, we can see that the header
    is still unencrypted even though the data buffer has been encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decrypt the buffer using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    in a manner similar to how we encrypted the buffer: by passing the buffers and
    the signature to the command. Once the buffer is decrypted, we can convert it
    back to a string. If the signature for the buffers isn’t valid, the command will
    throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to use security buffers for the SSPI APIs, let’s look
    at the Negotiate protocol, which allows Windows to automatically select the best
    authentication protocol to use based on what credentials are available to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Negotiate Protocol</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens if you don’t know what types of network authentication the server
    supports? You might first try using Kerberos and then, if it isn’t supported,
    switch to NTLM. But that’s not a very efficient use of resources. Also, if Microsoft
    were to later introduce a new, more secure authentication protocol, you’d have
    to update your application to support it. The *Negotiate* protocol solves both
    problems by allowing a client and server to negotiate the best available network
    authentication protocol. Microsoft’s implementation of Negotiate is based on the
    *Simple and Protected Negotiation Mechanism (SPNEGO)* protocol, defined in RFC4178.
  prefs: []
  type: TYPE_NORMAL
- en: To select the Negotiate protocol, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negotiate</samp>
    package in both the client and the server authentication context. The first token
    generated by a client authentication context contains a list of the authentication
    protocols the client supports. In its ASN.1 structure, it can also embed the first
    authentication token for whichever of the supported authentication protocols the
    client would prefer to use. For example, it might embed an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    NEGOTIATE</samp> token. In [Listing 15-3](chapter15.xhtml#Lis15-3), we initialize
    the Negotiate client authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-3: Initializing the Negotiate client authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the credentials for using the Negotiate security package ❶, then
    continue as normal by creating the context. In the formatted token, we first see
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO Init</samp>, which indicates
    that this is an initialization token ❷. Following the header is the list of supported
    authentication protocols, or *security mechanisms* ❸. The list is sorted in descending
    order of preference, so in this case, the client prefers NTLM over Kerberos. You
    won’t see Kerberos in the list unless you’re on a domain-joined system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice the mechanism list contains two types of Kerberos. The presence
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Microsoft Kerberos</samp>
    identifier is due to a bug in Windows 2000: the value <samp class="SANS_TheSansMonoCd_W5Regular_11">113554</samp>
    in the identifier, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1BB92</samp>
    in hexadecimal, was truncated to 16 bits, resulting in the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0xBB92</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">48018</samp>. Microsoft has left
    this mistake for backward compatibility reasons, and the two values represent
    the same Kerberos authentication protocol. Microsoft also defines an extended
    negotiation protocol, the fourth mechanism in this list, but we won’t discuss
    it here.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the list of supported protocols is an authentication token ❹. In this
    case, the client has chosen to send the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    NEGOTIATE</samp> token.
  prefs: []
  type: TYPE_NORMAL
- en: The server authentication context can select the most appropriate authentication
    protocol it supports. Most commonly, it will use the protocol that is the client’s
    preferred choice, determined by the ordering of the list of supported authentication
    protocols. However, it can also ignore the client’s preference and request a different
    authentication protocol if desired. It sends the selected authentication protocol
    and any further authentication tokens to the client. This authentication exchange
    process continues until either an error occurs or the process is complete. [Listing
    15-4](chapter15.xhtml#Lis15-4) shows how the server responds to the client’s request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-4: Continuing the Negotiate authentication on the server'
  prefs: []
  type: TYPE_NORMAL
- en: We first pass the client authentication token to the server authentication context
    that we create. In the formatted output, we can see that it’s an <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO
    Response</samp>, and that the server has opted to use NTLM. The response has a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp> flag, which indicates
    that the negotiation is currently incomplete. Following that is the authentication
    token, which, as expected, is now an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    CHALLENGE</samp> token.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 15-5](chapter15.xhtml#Lis15-5), we complete the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-5: Completing the Negotiate authentication'
  prefs: []
  type: TYPE_NORMAL
- en: The next client authentication token sent is the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp> token ❶. Note that the supported authentication protocol field
    is not present. This is only required in the initial server token, and it’s omitted
    from subsequent tokens.
  prefs: []
  type: TYPE_NORMAL
- en: In normal NTLM authentication, the authentication would typically complete at
    this point. However, in Negotiate authentication, the client’s state is considered
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Incomplete</samp> until we generate
    a final server token and update the client with this token, which then marks the
    state as <samp class="SANS_TheSansMonoCd_W5Regular_11">Completed</samp> ❷. We
    can then query the final package using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PackageName</samp>
    property ❸, which shows that we negotiated NTLM.
  prefs: []
  type: TYPE_NORMAL
- en: To negotiate the use of Kerberos, the protocol acts in a similar manner. But
    as Kerberos needs an SPN to function, you must specify the target name using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> parameter when creating
    the client authentication context; otherwise, the protocol will select NTLM. The
    output of the Kerberos authentication will replace the NTLM tokens with Kerberos
    AP-REQ and AP-REP tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the Negotiate protocol, let’s discuss a few less common
    security packages that you might encounter during an analysis of a Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Less Common Security Packages</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve covered the three main security packages you’re most likely to use on
    Windows: NTLM, Kerberos, and Negotiate. But there are a few other security packages
    that have important functions, even if you’re less likely to use them directly.
    We won’t spend very much time discussing these, but I’ll give you a quick example
    of each so that you understand their purpose and function.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secure Channel</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sending sensitive information (like user credentials) unencrypted over the internet
    is generally considered a bad idea. Several network protocols can encrypt network
    traffic, but by far the most common is *Transport Layer Security (TLS)*, which
    was once called *Secure Sockets Layer (SSL)* and was originally developed by Netscape
    in the mid-1990s to secure HTTP connections. A variant of TLS, the *Datagram Transport
    Layer Security (DTLS)* protocol, can encrypt traffic from unreliable protocols,
    such as the *User Datagram Protocol (UDP)*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Secure channel* is an implementation of TLS provided as a security package,
    and you can access it through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp>
    package using the same SSPI APIs as for other network authentication protocols.
    While you can use secure channel as a TLS or DTLS encryption layer for network
    traffic, you can also use it to provide client authentication facilities to a
    server through client certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through a simple example of how to use the package. [Listing 15-6](chapter15.xhtml#Lis15-6)
    starts by setting up the client credentials handle and the client authentication
    context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-6: Setting up the secure channel client authentication context'
  prefs: []
  type: TYPE_NORMAL
- en: When setting up the context, you need to specify a target name, which is typically
    the DNS name of the server. The protocol uses this target name to verify that
    the server has a valid certificate for that name. TLS connections can also be
    cached, so the protocol can check whether an existing cache entry exists for the
    target name. In this case, the name won’t matter because we specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ManualCredValidation</samp> request attribute,
    which disables the server certificate checks so that we can use a self-signed
    certificate for the server.
  prefs: []
  type: TYPE_NORMAL
- en: We then format the authentication token, which displays the TLS protocol’s simple
    record structure (shown in [Figure 15-1](chapter15.xhtml#fig15-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The TLS record
    structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The record structure contains a 5-byte header consisting of a record type, the
    major and minor versions of the protocol, and a data length. The header is followed
    by a list of bytes whose interpretation depends on the record type. In [Listing
    15-6](chapter15.xhtml#Lis15-6), the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>,
    a record used during the connection setup to negotiate the encryption protocol
    to use, exchange certificates, and communicate the encryption keys. Its version
    is 3.3, which corresponds to TLS 1.2\. (The designers of the protocol considered
    TLS to be a minor addition to SSL 3.0, so they increased only its minor version
    number.)
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 15-7](chapter15.xhtml#Lis15-7), we generate an X.509 certificate
    and finish setting up the server side of the secure channel authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-7: Initializing a security channel server context and completing
    authentication'
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking whether we have a certificate whose subject name is the
    DNS name we specified when creating the client authentication context ❶. PowerShell
    exposes the system’s certificate store via the *Cert* drive provider. In this
    case, we check only the current user’s personal certificate store for a matching
    certificate.
  prefs: []
  type: TYPE_NORMAL
- en: If the certificate doesn’t already exist, we create a new one using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-SelfSignedCertificate</samp> command
    with the DNS name as the subject, storing it in the current user’s personal store
    ❷. This certificate isn’t trusted for the TLS certificate chain. You could add
    the new certificate to *Cert:\CurrentUser\Root*, which would make it trusted;
    however, it’s safer to just disable the certificate checking in the client for
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: To use the certificate for the server, we need to create a set of secure channel
    credentials, specifying the certificate for use by the server ❸. Note that the
    certificate must have an associated private key for the server to use. If you
    pick a certificate without the private key, this line of code will generate an
    error. We can use the credentials to create a handle and, from that, the server
    authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we exchange tokens between the server and client authentication context
    until the authentication completes ❹. Of course, in a real application this process
    would exchange the tokens over a network connection, but for the sake of simplicity,
    we ignore the network entirely here.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do anything else, we can inspect the negotiated security information,
    as shown in [Listing 15-8](chapter15.xhtml#Lis15-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-8: Inspecting the connection information'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectionInfo</samp>
    property returns the negotiated protocol and encryption algorithms. In this case,
    we’ve negotiated TLS 1.2 using the AES256 encryption algorithm, SHA384 for integrity,
    and elliptic curve Diffie-Hellman to exchange an ephemeral encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: We can also query the server’s certificate. This should match the one we used
    in the server’s credentials. As we specified manual credential validation, we
    can check whether the certificate is valid; if we hadn’t requested manual validation,
    the handshake process would have generated an error. Finally, we can also query
    the server’s connection information to double-check that it’s the same as the
    client’s.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve set up the connection, but we have yet to transfer a single
    byte of user data to the server. [Listing 15-9](chapter15.xhtml#Lis15-9) shows
    how to encrypt and decrypt application data sent over the network connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-9: Encrypting and decrypting application data'
  prefs: []
  type: TYPE_NORMAL
- en: Secure channel requires passing four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command ❶. The first buffer is for the TLS record header. It needs to be of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeader</samp> and should be
    of a size queried from the context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeaderSize</samp>
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The second buffer is for the data to encrypt and must be of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>.
    There is a maximum allowed size for this buffer, which you can query using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamMaxMessageSize</samp> property.
    The maximum size is typically 16KB, so the 4 bytes we use here should fall well
    within the limit. If the application data to encrypt is larger than the maximum
    size, you’ll need to fragment the data into smaller parts.
  prefs: []
  type: TYPE_NORMAL
- en: The third buffer will contain the stream trailer, which must be of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailer</samp> and of size <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailerSize</samp>. The final buffer
    is an empty one. The secure channel package doesn’t seem to use the buffer to
    store anything, but you must pass it, or the call will fail.
  prefs: []
  type: TYPE_NORMAL
- en: We can now encrypt the data by passing all four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command ❷. One important thing to note is that you should also pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp> parameter. Any generated
    signature will be part of the generated protocol data, not returned separately,
    so there is no need for the command to automatically handle the signature.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the encryption is that the header, data, and trailer buffers are
    populated with the data required to transmit the application data to the server.
    We need to concatenate the buffers together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>
    command ❸. In this case, we already know that the data generated is a TLS record,
    so we can use the authentication context commands to inspect its structure. We
    can see that the record type is now <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>
    ❹, whereas in [Listing 15-6](chapter15.xhtml#Lis15-6) the record type was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>
    indicates that this is an encrypted data record.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to decrypt the data on the server. To do so, we again need four
    buffers; however, their configuration is slightly different. For decryption, we
    must place the entire TLS record in the first buffer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    type ❺. The next three buffers can be empty; they’ll be populated during decryption
    with the appropriate parts of the message.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    command, again specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp>
    parameter, as the signature is part of the protocol ❻. When checking the data
    buffer, which was originally empty, we now find it’s populated with the original
    unencrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve made secure channel look easy to use, but it’s much more complex than shown
    here. For example, you’ll have to deal with out-of-band alerts, which indicate
    problems with the connection. I recommend that you use an existing class (such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>, which comes
    with .NET) to add TLS support to your application unless there’s a niche feature
    not exposed that you need to use.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the TLS protocol verifies only the server in the secure channel
    connection, using the X.509 certificate; however, the server can request that
    the client also present a valid certificate for verification purposes. To require
    the client to send a certificate, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    request attribute when creating the server authentication context. By default,
    secure channel will try to find a suitable certificate for the user on the client,
    but you can override this search by setting an explicit certificate when generating
    the client’s credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The server can query for the client’s certificate using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteCertificate</samp>
    property on the server authentication context. Note that secure channel doesn’t
    validate the contents of the client certificate by default; doing so is up to
    the server application. The only thing secure channel guarantees is that the client
    can prove they have the corresponding private key for the certificate. If the
    server is part of an enterprise network, it’s possible to add an identity certificate
    to Active Directory so that the client certificate can be mapped to a user account
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object can be
    queried for the user’s identity without any further authentication.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CredSSP</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final security package we’ll look at is *CredSSP*, an authentication protocol
    developed by Microsoft to improve the security of remote desktop connections to
    Windows machines. [Figure 15-2](chapter15.xhtml#fig15-2) shows the original remote
    desktop implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The original remote
    desktop implementation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the original implementation, a client would connect to the server using a
    client application ❶. The RDP server would then create a LogonUI for the user
    that displayed the normal Windows logon user interface and replicate this LogonUI
    over RDP, so the user would get the same UI on their client machine. The user
    could then enter their username and password into the LogonUI ❷, which would follow
    the interactive authentication process outlined in [Chapter 12](chapter12.xhtml)
    to verify the user’s credentials ❸ and create their desktop.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to implementing a remote desktop has several security problems.
    First, it performs no verification of the client; this allows anyone to connect,
    then try to guess a user’s password or exploit some bug in the LogonUI to get
    access to the server. Second, starting up a desktop session for the user interface
    is quite an expensive operation; it’s easy to make enough connections to a remote
    desktop server to exhaust the machine’s resources and cause a denial-of-service
    condition. Finally, there is a risk of the user having their credentials phished
    by providing them to a malicious remote server they were tricked into connecting
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s solution to these problems is *Network Level Authentication (NLA)*.
    NLA is available in Windows Vista onward, and it is the default authentication
    mechanism used when enabling remote desktop connections. NLA avoids the previously
    discussed problems by integrating authentication into the Remote Desktop Protocol
    and verifying that the user has valid credentials before starting a desktop session.
    This confirms the identity of the client, prevents the expensive operation of
    setting up the desktop until authentication succeeds, and allows the user to avoid
    disclosing their credentials to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The CredSSP package implements NLA. It provides TLS for network-level encryption
    (based on secure channel), and a separate *TS Service Security Package (TSSSP)*
    that uses the Negotiate protocol to authenticate the user, as well as to derive
    a session key to encrypt the user’s credentials when sending them to the server.
    [Figure 15-3](chapter15.xhtml#fig15-3) shows an overview of using NLA to connect
    to a remote desktop server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A remote desktop
    connection using Network Level Authentication</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, instead of immediately making a connection, the user provides their credentials
    to the remote desktop client ❶. This typically consists of their username and
    password for the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: The client then makes a connection to the remote server, using the CredSSP package
    to protect the network traffic with TLS ❷. The server sets up a corresponding
    CredSSP authentication context to implement this communication. Next, its CredSSP
    context uses the TSSSP package to verify the client based on an existing network
    authentication protocol, such as NTLM or Kerberos ❸. If this verification step
    fails, the server can close the connection before creating an expensive desktop.
  prefs: []
  type: TYPE_NORMAL
- en: You might expect the server to create the user’s desktop immediately once the
    network authentication is complete, but there’s an additional wrinkle introduced
    when connecting to a remote desktop. Normally, when you use a network authentication
    protocol such as NTLM or Kerberos, the created logon session on the server can
    access only local resources, as the user’s credentials are stored on the client
    computer only. This is the double hop problem I mentioned in [Chapter 13](chapter13.xhtml)
    when discussing NTLM domain network authentication.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is fine if the remote desktop user is accessing a resource locally
    on the server. But when using a remote desktop, users typically expect to be able
    to perform single sign-on to other machines on the network to continue to work
    from that remote desktop session. To solve the single sign-on problem, the client’s
    CredSSP context delegates the user’s credentials to the server ❹. It encrypts
    these credentials using the negotiated session key from the network authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Because the session key for the authentication is derived from the password,
    a malicious server can’t use NTLM relay or forward a Kerberos ticket and then
    capture the credentials, as they won’t be able to decrypt them. Once the LSA has
    a copy of the credentials, the remote user can use them to connect to other network
    services as if they have authenticated interactively.
  prefs: []
  type: TYPE_NORMAL
- en: While CredSSP was designed for use with remote desktop connections, you’ll also
    find it’s used for other purposes that require credential delegation. For example,
    in PowerShell, it’s possible to use CredSSP over the WinRM protocol, used for
    PowerShell remoting. This allows you to create a remote PowerShell session that
    has the client’s credentials and can connect to other systems on the network.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide an example of using CredSSP, as for the most part it looks like
    the TLS connection you saw when testing secure channel. Instead, let’s cover a
    few final authentication topics I haven’t yet mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote Credential Guard and Restricted
    Admin Mode</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might notice a problem with delegating your credentials to the remote desktop
    server. With NLA, you can be confident that the server can verify your credentials,
    but if an attacker has compromised the server, they could harvest the credentials
    once they’re decrypted during the authentication process. Perhaps an attacker
    is waiting for you to connect to the server with your privileged domain administrator
    credentials. Also, there’s a chance that the server will leave your credentials
    lying around in the LSASS process’s memory even after you’ve logged off the system,
    meaning a malicious attacker can pick them up later.
  prefs: []
  type: TYPE_NORMAL
- en: Windows provides two optional features to mitigate the risk of a compromised
    server. The first is *Remote Credential Guard*, which works with Kerberos authentication
    to avoid directly delegating the user’s credentials. Using Remote Credential Guard,
    the client can generate new Kerberos tickets on demand to access resources. This
    allows the client to connect to other systems from a remote desktop as if they
    had delegated their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly for security, this channel to create new tickets exists only while
    the client is connected to the server. If they disconnect, the server can no longer
    create new tickets, although any client that is already authenticated will likely
    stay that way. This means the machine must be actively compromised while the privileged
    user is authenticated to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to perform some setup steps in your domain to enable Remote Credential
    Guard. The setup is out of scope for this section, but if the feature has been
    enabled, you can use it with the remote desktop client by running the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second security feature is *Restricted Admin mode*. Its big difference from
    Remote Credential Guard is that when a user authenticates to a server, it creates
    the logon session without the user’s network credentials. Instead, the session
    is assigned network credentials for the computer account on the server. Therefore,
    the logon session is primarily useful only if the user wants to perform tasks
    locally; they won’t be able to connect to network resources as themselves unless
    they explicitly provide their credentials to the remote server. However, this
    feature ensures that there are no privileged credentials to steal if the server
    is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Restricted Admin mode, first add a DWORD registry key value named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DisableRestrictedAdmin</samp> to
    *HKLM\System\CurrentControlSet\Control\Lsa* and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    Then you can enable the mode when executing the client with the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One advantage of these two security features (above and beyond the restrictions
    they place on credential delegation) is that they allow the remote desktop client
    to use single sign-on authentication based on the current user’s credentials stored
    in the LSA logon session. This is because neither feature requires the plaintext
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Credential Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One annoyance of using a remote desktop connection is having to enter your password
    every time you want to connect. This seems unavoidable, as you must provide the
    account password to the server to allow single sign-on to function from the remote
    desktop server. However, the LSA supports a feature to save the account password
    for subsequent authentication to save you typing it in again. One place where
    this feature is used is when you type in your credentials; you’ll see a “Remember
    me” checkbox in the dialog, as shown in [Figure 15-4](chapter15.xhtml#fig15-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: Entering and saving
    your credentials</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you check the box and successfully authenticate, the dialog in which to enter
    the server’s name should change slightly the next time you open it ([Figure 15-5](chapter15.xhtml#fig15-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: Connection dialog
    with saved credentials</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see that the dialog gives you the option to edit or delete saved
    credentials for this server.
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy for the client to store the user’s password directly to a file
    on disk, but that wouldn’t be very secure. Instead, it uses a service provided
    by the LSA known as the *credential manager*. The service can store domain passwords
    for easy reuse, although Microsoft doesn’t recommend this practice. To demonstrate
    how credentials get stored, [Listing 15-10](chapter15.xhtml#Lis15-10) first uses
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Credential</samp> PowerShell
    command, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CredRead</samp>
    Win32 API, to read the credentials for the remote desktop client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-10: Getting the credentials for a remote desktop client'
  prefs: []
  type: TYPE_NORMAL
- en: The credentials are stored by target name, which for domain credentials is the
    SPN for the service (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">TERMSRV/primarydc.domain.local</samp>).
    When looking up credentials you also need to specify the type, which in this case
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainPassword</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ve formatted the output to show only the username and password. However,
    you might notice a problem: the password column is empty. This is an intentional
    behavior of the service. If the credentials represent a domain password, the password
    won’t be returned unless the caller is running within the LSA process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is fine for its intended purpose: to use in security packages
    that are running inside the LSA. For example, CredSSP can check whether the user
    has a credential for the target remote desktop service based on its SPN and use
    it to read the user’s password to automatically authenticate. The service stores
    the credentials in individual files in the user’s profile, as illustrated in [Listing
    15-11](chapter15.xhtml#Lis15-11).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-11: Viewing the user’s credential files'
  prefs: []
  type: TYPE_NORMAL
- en: Each file is encrypted using a per-user key through the Data Protection API
    (DPAPI), which I mentioned in [Chapter 10](chapter10.xhtml). This means we should
    be able to decrypt our own credential files using the DPAPI, through the .NET
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp> class. [Listing
    15-12](chapter15.xhtml#Lis15-12) enumerates the current user’s credential files
    and tries to decrypt each one using <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-12: Attempting to decrypt the user’s credential files'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, every file returns the same error: <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    data is invalid</samp>. While it is encrypted using the user’s DPAPI key, the
    LSA sets a special flag in the binary data that indicates that only code running
    in the LSA can decrypt it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to decrypt the files successfully: for example, you could
    inject code into the LSA process and decrypt them from there, or you could derive
    the DPAPI key using the user’s password and the values from the SECURITY database
    registry key and decrypt them yourself. If you want to go down the latter route,
    I’d suggest checking out existing tooling such as Mimikatz, which already implements
    this functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to decrypting the files was introduced in Windows Vista. A
    special token privilege, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    allows a process to be considered trusted by the LSA when accessing select credential
    manager APIs. The most interesting of these select APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>,
    which will back up all of a user’s credentials into a file that can later be used
    to restore the credentials if needed. The backup also contains any protected password
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-13](chapter15.xhtml#Lis15-13) shows how to back up a user’s credentials
    from the credential manager. You must run these commands as an administrator,
    as you need to access a privileged process to get a token with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    which is only granted to select process types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-13: Backing up a user’s credentials from the credential manager'
  prefs: []
  type: TYPE_NORMAL
- en: We first open the privileged Winlogon process and take a copy of its primary
    token ❶. Next, we get a copy of the user token we want to back up, which in this
    case is the current process token ❷. We can then impersonate the token we duplicated
    from Winlogon ❸, enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup-Win32Credential</samp>
    PowerShell command, which calls the underlying <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The command returns a byte array containing the backup. The byte array is in
    a proprietary format, so we select all its Unicode strings and look for any that
    start with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Domain:</samp>
    ❹. We can see the stored remote desktop service credentials, including the name
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: The credential manager is a better place than a user-accessible file to store
    credentials for use by LSA security packages such as NTLM, Kerberos, and CredSSP.
    However, that doesn’t mean you should use it. While disclosing the credentials
    takes some work, like any protection mechanism, it must at some point provide
    the unencrypted values, which an attacker can then extract.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Request Attribute Flags</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a client or server authentication context, you can specify a
    set of request attribute flags to change the behavior of the authentication. We’ve
    already seen support for signing and sealing, as well as delegation and mutual
    authentication, in the previous chapters. Still, it’s worth highlighting a few
    other flags that Kerberos and NTLM support.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Sessions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if you don’t know a user account on the target server? SSPI supports the
    concept of an *anonymous session*, also referred to as a *NULL session*. In an
    anonymous session, the authenticating user doesn’t need any credentials to generate
    the authentication tokens. The server will process the authentication as usual,
    but it will generate a token for the *ANONYMOUS LOGON* user. This allows a network
    protocol to always require authentication, simplifying the protocol, and to then
    enforce access based on the identity of the authenticated user. You can specify
    an anonymous session by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>
    request attribute flag when creating the client authentication context, as in
    [Listing 15-14](chapter15.xhtml#Lis15-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-14: Adding the NullSession request attribute flag'
  prefs: []
  type: TYPE_NORMAL
- en: If you then perform local NTLM network authentication, you should notice a change
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM AUTHENTICATE</samp>
    token, shown in [Listing 15-15](chapter15.xhtml#Lis15-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-15: The NTLM AUTHENTICATE token in an anonymous session'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> flag
    set ❶. Also, the LM response is a single zero byte, and the NT response is missing
    ❷. Querying the process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object shows that it’s the anonymous user’s ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In Kerberos, the anonymous authentication token looks like that for NTLM, as
    shown in [Listing 15-16](chapter15.xhtml#Lis15-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-16: Sending an anonymous Kerberos AP-REQ message'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends an AP-REQ message with a ticket and authenticator containing
    empty values. If you see this message in a network capture, you can be certain
    the client is establishing an anonymous session.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identity Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you perform a network authentication, the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object is an Impersonation-level token. If the server can pass the impersonation
    checks described in [Chapter 4](chapter4.xhtml), it can now access that user’s
    resources. What if we don’t want the server to be able to use our identity to
    access resources? In this case, we can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp>
    request attribute flag, as shown in [Listing 15-17](chapter15.xhtml#Lis15-17),
    to allow the server to receive only an Identification-level impersonation token,
    rather than a full Impersonation-level token.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-17: Adding the Identify request attribute flag'
  prefs: []
  type: TYPE_NORMAL
- en: This will prevent the server from using our identity to access resources, but
    still allow it to check who has authenticated. If we then rerun the authentication,
    we should notice a change in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp> token, as shown in [Listing 15-18](chapter15.xhtml#Lis15-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-18: Examining the flags in the NTLM AUTHENTICATE token and displaying
    the created token’s impersonation level'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token’s flags now include an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp>
    flag ❶. This indicates to the server that the client wants to allow the use of
    an Identification-level token only. When we get the token from the server authentication
    context and format it, we can see that the impersonation level is indeed set to
    Identification ❷.
  prefs: []
  type: TYPE_NORMAL
- en: As with <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> request attribute
    flag will work with Kerberos as well. [Listing 15-19](chapter15.xhtml#Lis15-19)
    shows that specifying this flag results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp>
    flag being set in the AP-REQ authenticator’s GSSAPI <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-19: The Identity flag in an AP-REQ GSSAPI checksum'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Network Authentication with a Lowbox
    Token</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a process is running with a lowbox token (described in [Chapter 4](chapter4.xhtml)),
    the LSA enforces restrictions on the use of network authentication. This is to
    make it harder for the sandbox application to abuse network authentication to
    get access to the user’s logon session credentials and, through them, access their
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the lowbox process can create a client authentication context, however,
    it can generate authentication tokens in only the following three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Using logon session credentials with the Enterprise Authentication capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using logon session credentials to a known web proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using explicit credentials, such as a username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss each of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with
    the Enterprise Authentication Capability</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *enterprise authentication capability*, represented by the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp>,
    can be granted when a lowbox token is created. With this capability, the lowbox
    process can use the user’s logon session credentials to generate any supported
    network authentication tokens, such as those for NTLM or Kerberos, without restriction.
  prefs: []
  type: TYPE_NORMAL
- en: The enterprise authentication capability is designed for enterprises to use
    in their internal applications. Outside of enterprises, the primary means of deploying
    lowbox processes is via the Microsoft App Store, which has restricted the use
    of this capability in the application submission guidelines. If you apply to the
    Microsoft store with an application that uses the enterprise authentication capability,
    it must pass an extra review and might be rejected. However, if you’re creating
    the lowbox token outside of a store application for testing purposes, there is
    no restriction, as demonstrated in [Listing 15-20](chapter15.xhtml#Lis15-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-20: Testing the lowbox enterprise authentication capability'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a lowbox <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object without the capability ❶. When we create the client authentication context
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>,
    we get an error ❷. This error comes from the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    API, which PowerShell calls behind the scenes. Next, we create the lowbox token
    with the capability ❸. This time, we can successfully create a client authentication
    context and format the client authentication token ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication to
    a Known Web Proxy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The lowbox process can generate tokens for authentication to web proxies, which
    commonly require that a domain user can access the internet. To support this use
    case, you can perform network authentication with the user’s logon session credentials
    if the target name is set to the address of an approved proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say the target name is <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/proxy.mineral.local</samp>.
    The system administrator must configure the proxy address either through the group
    policy or by using a *Proxy Auto-Configuration (PAC)* script, which makes sure
    that a web request with an arbitrary proxy configuration won’t pass the LSA’s
    checks. [Listing 15-21](chapter15.xhtml#Lis15-21) demonstrates the use of a web
    proxy target name to allow network authentication. You must have configured a
    system web proxy for this script to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-21: Testing lowbox web proxy authentication'
  prefs: []
  type: TYPE_NORMAL
- en: First, we query for the proxy setting using the <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp>
    .NET class ❶. We then build the target SPN with an HTTP service class and the
    proxy address ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the lowbox token ❸. Notice that we haven’t specified the enterprise
    authentication capability. We create the client authentication context and use
    the target SPN ❹. The initial authentication succeeds, and we can perform the
    client authentication to the target proxy.
  prefs: []
  type: TYPE_NORMAL
- en: This proxy authentication is considered secure because the service should check
    the target name before permitting the authentication. If the lowbox process generates
    the authentication for the proxy SPN but then sends it to an SMB server, the authentication
    process should fail. For Kerberos authentication, the SPN selects the key to use
    for the ticket, so an incorrect SPN should make the ticket fail to decrypt if
    sent to the wrong service.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with
    Explicit Credentials</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final option, shown in [Listing 15-22](chapter15.xhtml#Lis15-22), is to
    specify explicit credentials when creating the credentials handle provided to
    the client authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-22: Initializing the client authentication context with explicit
    credentials'
  prefs: []
  type: TYPE_NORMAL
- en: To initialize the client authentication context, you still need to provide a
    target SPN ❶. However, you don’t need to specify a known proxy, as the target
    can be any service or host. In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/
    localhost</samp> SPN.
  prefs: []
  type: TYPE_NORMAL
- en: When in a lowbox token sandbox, you can act as a server for network authentication,
    as it’s possible to get a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for a different user. However, unless the token’s user exactly matches
    the caller’s user and lowbox package SID, the returned token is set to the Identification
    level, which prevents it from being abused to elevate privileges. The restriction
    on the impersonation level applies even if the lowbox token has the enterprise
    authentication capability, as this grants access to the client authentication
    context only.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Authentication Audit Event Log</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s wrap up our discussion of authentication with an overview of the auditing
    data generated during interactive and network authentication. When you’re monitoring
    an enterprise network, you might want to know which users have attempted to authenticate
    to the Windows system. By analyzing the audit log, you can identify their successful
    and unsuccessful authentication attempts to a machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the authentication audit log records in the same security event
    log we inspected in [Chapter 9](chapter9.xhtml) when discussing object audit events.
    We can use a similar technique of filtering the log by event ID to get the events
    we’re interested in. Here are some event IDs for important authentication events:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4624  </samp>An account logged
    on successfully.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4625  </samp>An account failed
    to log on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4634</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>An
    account logged off.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the information these events provide. [Listing 15-23](chapter15.xhtml#Lis15-23)
    starts by querying the security event log for the successful logon event, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4624</samp>. Run this command as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-23: A log record for a successful interactive authentication event'
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows an example entry for a successful authentication event. On
    a frequently used system there are likely to be many such entries, so pick just
    one to inspect.
  prefs: []
  type: TYPE_NORMAL
- en: The event records contain a lot of information, some of which might not be populated
    for certain logon types. Each entry starts with information about the user account
    that has made the authentication request. For an interactive authentication, you’ll
    likely find this to be a privileged account, such as the *SYSTEM* computer account.
    Next comes information about the logon, including the logon type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    indicates interactive. Some other logon types are network (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>),
    batch (<samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>), service (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and remote interactive (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp>). This section also indicates
    whether Restricted Admin mode was used for the authentication and whether the
    session the event represents is elevated. It’s followed by an indication of the
    token’s impersonation level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section contains the details of the logon session created for
    the successful authentication, including the user’s SID, name, and domain. As
    this is an elevated interactive authentication, we see two logon IDs: one for
    the session itself and one for the linked, non-elevated logon session created
    for UAC.'
  prefs: []
  type: TYPE_NORMAL
- en: Next come the details of the process making the authentication request. In this
    example, it’s the process that called <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>.
    The final two sections contain network authentication information and additional
    details that didn’t fit into other categories. Part of the detailed authentication
    information is the security package used for the authentication. In this case,
    Negotiate was used, so it will have chosen the best authentication protocol for
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see the same type of event record generated regardless of whether authentication
    occurred through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    or through network authentication. For example, if the event is for an NTLM network
    authentication, you should see something like [Listing 15-24](chapter15.xhtml#Lis15-24)
    in the detailed authentication information section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-24: The detailed information for a successful NTLM network authentication'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at a failed authentication event. [Listing 15-25](chapter15.xhtml#Lis15-25)
    queries for events with an ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">4625</samp>,
    as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-25: A failed authentication event log record'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, I’ve highlighted just one record. It has many of the same sections
    as for a successful authentication, so I’ve removed anything that appears in both
    types of record.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the sections shown here contains details on the user account that
    failed to authenticate. The SID entry isn’t guaranteed to be valid; for example,
    in this case, the SID does not represent the *alice* user. Next, we get more details
    about the failure, starting with a text version of the error, followed by the
    status, which here is an NT status code of <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>.
    The sub-status code provides more detail; in this case, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>,
    which indicates that the user did not provide a valid password. Other sub-status
    codes you might encounter include <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>,
    if the user doesn’t exist, and <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCOUNT_DISABLED</samp>,
    if the user’s account has been disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll look at a log-off event, generated when a logon session is deleted.
    This typically occurs when no <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    objects that reference the logon session remain. Run the command in [Listing 15-26](chapter15.xhtml#Lis15-26)
    as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-26: A log-off authentication event log record'
  prefs: []
  type: TYPE_NORMAL
- en: This event log record is much simpler than those for successful or failed authentication.
    It contains just the subject information, including the username and domain. To
    match a successful authentication event to the corresponding log-off event, you
    can compare the logon IDs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish with some worked examples using the commands you’ve learned about
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifying the Reason
    for an Authentication Failure</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I noted in the previous section that you’ll see two status codes in the event
    log when an authentication process fails: there’s the main status, typically <samp
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>, and a sub-status,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>.
    Unfortunately, the event log automatically converts only the main status code
    to a string, then typically generates a generic “The username or password is incorrect”
    message that isn’t very helpful in diagnosing authentication failures. Let’s write
    a quick script to analyze the event log records and convert the sub-status codes
    to messages automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: One immediate problem we must solve is how to get the sub-status code from the
    event log record. You could try to manually parse it from the text message. However,
    you’ll see different messages for different languages, and you might not be able
    to rely on the presence of a text string such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>.
    The event log record, however, does contain all its important information as separate
    properties, and you can query for these using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp>
    property on the event log record object. [Listing 15-27](chapter15.xhtml#Lis15-27)
    shows the output generated by such a query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-27: Displaying an event log’s record properties'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the list of properties contains only the values, with no indication
    of the properties’ names. We want the property with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>,
    which might always be at the same index in the properties list, but there is no
    guarantee that will always be the case. So, to get this information we must manually
    inspect the XML that stores the event log’s properties. We can request this by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToXml</samp> method on
    the record. [Listing 15-28](chapter15.xhtml#Lis15-28) shows how to extract named
    properties from an event log record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-28: Extracting the named event log record properties'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-EventLogProperty</samp>
    function, which will convert each record to a new object. We need to extract an
    event log record’s XML and then parse it into an XML document ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EventData</samp>
    XML element stores the properties, so we use the object model PowerShell provides
    to extract each element and build a hash table from the property name and body
    text ❷. We then convert the hash table to a custom PowerShell object to make it
    easier to query.
  prefs: []
  type: TYPE_NORMAL
- en: When inspecting the new object’s properties, we find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>
    property is now easily accessible ❸. There are some limitations with our approach;
    for example, we haven’t converted the failure reason from a resource identifier
    to a string ❹. However, we don’t need the failure reason, as we can get the message
    from the status code if we want it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s expand our code to extract the sub-status for authentication failures
    ([Listing 15-29](chapter15.xhtml#Lis15-29)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-29: Parsing authentication failure properties and converting their
    sub-status codes'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function that converts the record properties into a simpler
    authentication failure object ❶. We pull out only the timestamp, the username,
    and the domain name, and then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>
    property to its NT status name ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We then perform two failed authentications to generate some entries in the event
    log ❸. We filter the log to return only authentication failure records, then convert
    the records in the pipeline ❹. In the generated output, we can see two entries.
    The first has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>
    as the sub-status, indicating that the user was valid but the password was not.
    The second has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>,
    which indicates that the user doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Secure Channel
    to Extract a Server’s TLS Certificate</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s walk through a simple example of how to use the secure channel authentication
    protocol. We’ll make a TCP connection to a secure web server and extract its server
    certificate, then use it to retrieve details about the organization that might
    own the server and whether the certificate is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are likely much better ways of getting the server’s certificate
    than the approach taken in this example. For example, most web browsers will allow
    you to display and export the certificate by browsing to the server. However,
    that wouldn’t help you learn much about how secure channel works. To get started,
    copy the contents of [Listing 15-30](chapter15.xhtml#Lis15-30) into the script
    file *get_server_cert.ps1*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-30: A script for reading a TLS server certificate'
  prefs: []
  type: TYPE_NORMAL
- en: We first define a couple of parameters, for the hostname of the server and the
    optional TCP port ❶. HTTPS uses the well-known port 443; however, TLS is not restricted
    to only that port, so you can change it if you want to target a different service.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a couple of functions. The first one, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>,
    converts a TCP client object to a <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryReader</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryWriter</samp> ❷. The TLS
    protocol has a relatively simple binary record structure, so using these classes
    makes it easier to parse the network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: The second function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-TlsRecordToken</samp>,
    reads a single TLS record from the server and returns it as an authentication
    token ❸. We first read the 5-byte header from the record and extract the data’s
    length, then we read the data from the stream. Because TCP is a streaming protocol,
    there is no guarantee that all the required data will be returned in a single
    read, so you’ll have to perform the read in a loop until you’ve received everything
    you need ❹.
  prefs: []
  type: TYPE_NORMAL
- en: We now enter the body of the script. We start by making a TCP connection to
    the hostname and TCP port provided as arguments to the script ❺. We then convert
    the socket to the reader and writer objects. Next, we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp>
    credentials and client context ❻, setting the client context target to the hostname
    and enabling manual credential validation, as we don’t really care if the server
    certificate is invalid for the purposes of this example.
  prefs: []
  type: TYPE_NORMAL
- en: We can now loop until the client context has completed authentication ❼. If
    there is a token to send to the server, we convert it to bytes and write it to
    the TCP socket ❽. As we saw earlier, the TLS client and server can generate more
    than one TLS record, which the context must handle before generating a new token.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve sent the client authentication token, we can read the next TLS record
    from the server and update the client ❾. This loop will carry on until either
    the authentication completes successfully or an exception stops the script. Finally,
    we can return the server’s certificate from the script ❿.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-31](chapter15.xhtml#Lis15-31) shows how to use the script we wrote.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-31: Getting the server certificate for <samp class="SANS_Futura_Std_Book_11">www.microsoft.com</samp>
    and exporting it to a file'
  prefs: []
  type: TYPE_NORMAL
- en: You call the script by providing the hostname of the server. Optionally, you
    could specify the TCP port, but in this case, we use port 443, better known as
    HTTPS, which is the script’s default. The returned certificate is an object you
    can inspect using PowerShell. You can also export the certificate to a file using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Export-Certificate</samp> command.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began by describing security buffers and how they’re used to pass
    information back and forth with the SSPI APIs during network authentication and
    the encryption and signing processes. It then provided an overview of the Negotiate
    authentication protocol, which allows network authentication to take place when
    both parties aren’t sure ahead of time what authentication protocol to use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at some less commonly used security packages, secure channel
    and CredSSP. These have specific niches but also more complex usage compared to
    NTLM or Kerberos. We also discussed anonymous and identity network authentication
    in NTLM and Kerberos and covered network authentication inside a lowbox token
    sandbox (and I described how I circumvented this authentication multiple times).
  prefs: []
  type: TYPE_NORMAL
- en: The chapter finished with an overview of the security audit events generated
    when a user authenticates. You learned about the different event types used to
    describe whether a user’s authentication succeeded or failed, and saw how to use
    these to figure out which users have attempted to authenticate to a workstation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Final Thoughts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we wrap up this final chapter, I hope you’ll apply the information you’ve
    learned here about the internals of Windows security to your own endeavors. I’ve
    covered many areas in detail, ranging from the Security Reference Monitor and
    tokens to access checking and authentication, providing examples to demonstrate
    important topics.
  prefs: []
  type: TYPE_NORMAL
- en: However, I wasn’t able to provide scripts to demonstrate every permutation of
    the features we discussed. For that reason, I recommend checking the help feature
    for the various commands provided with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module and experimenting with their use. If you perform tests against a Windows
    virtual machine, there is little you can damage. (In fact, if your system develops
    a blue screen of death while you’re experimenting, it might be a good idea to
    dig into why, as you might have found a security vulnerability.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this chapter are some additional reference materials: [Appendix A](appendix-A.xhtml)
    contains a walkthrough for setting up a domain network for testing, and [Appendix
    B](appendix-B.xhtml) contains a list of SDDL aliases.'
  prefs: []
  type: TYPE_NORMAL
