- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEGOTIATE
    AUTHENTICATION AND OTHER SECURITY PACKAGES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">协商认证与其他安全包</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The two previous chapters covered the two main network authentication protocols
    in Windows, NTLM and Kerberos. However, Windows supports several more packages
    for performing authentication. In this chapter, we’ll briefly cover some of these
    other security packages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的两章介绍了Windows中的两种主要网络认证协议：NTLM和Kerberos。然而，Windows还支持其他多个用于执行认证的包。在这一章中，我们将简要介绍一些其他的安全包。
- en: I’ll begin by providing more detail about how applications and security packages
    can use buffers to pass data back and forth using the SSPI APIs. This will help
    you understand some of the packages’ quirks. Then we’ll examine the Negotiate
    security package, as well as the less common secure channel and CredSSP packages.
    I’ll give a quick overview of some additional configuration options you have when
    setting up a network authentication context and finish up with a description of
    what happens when you want to use network authentication inside a process with
    a lowbox token.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先提供更多关于应用程序和安全包如何使用缓冲区通过SSPI API来传递数据的细节。这将帮助您理解一些包的特殊性。然后，我们将检查协商安全包，以及不太常见的安全通道和CredSSP包。我将简要概述设置网络认证上下文时的其他配置选项，并最后描述在使用低框令牌的进程中使用网络认证时发生的情况。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Security Buffers</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全缓冲区</samp>
- en: 'So far, I’ve implied that using the SSPI APIs is simple: you generate a client
    authentication token, pass it to the server application, update the server authentication
    context, receive a token in response, and repeat the process until the authentication
    is complete. However, because of the complexity of the supported network authentication
    protocols, these APIs can accept and return more than just an authentication token.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我暗示使用SSPI API是简单的：您生成客户端认证令牌，将其传递给服务器应用程序，更新服务器认证上下文，接收响应中的令牌，并重复此过程，直到认证完成。然而，由于支持的网络认证协议的复杂性，这些API不仅可以接受和返回认证令牌。
- en: 'The authentication context, encryption, and signature APIs accept arrays of
    generic *security buffer* structures as parameters. This security buffer structure,
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">SecBuffer</samp> in the native
    SDK, is wrapped by the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityBuffer</samp>
    class in the PowerShell module. Each security buffer structure contains a field
    that determines what type of data the buffer represents and a sized memory buffer
    for the contents. You can create a buffer using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaSecurityBuffer</samp>
    PowerShell command, specifying the type and contents of the buffer:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 认证上下文、加密和签名的API接受作为参数的通用*安全缓冲区*结构数组。这个安全缓冲区结构，在原生SDK中称为<samp class="SANS_TheSansMonoCd_W5Regular_11">SecBuffer</samp>，在PowerShell模块中被<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SecurityBuffer</samp>类封装。每个安全缓冲区结构包含一个字段，用于确定缓冲区所代表的数据类型，以及一个用于存储内容的固定大小内存缓冲区。您可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-LsaSecurityBuffer</samp> PowerShell命令创建缓冲区，指定缓冲区的类型和内容：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can specify either a byte array or a string when initializing the data.
    You also specify a type for the buffer. The following is a short list of the most
    important buffer types you’ll encounter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化数据时，您可以指定字节数组或字符串。您还需要为缓冲区指定类型。以下是您将遇到的一些最重要的缓冲区类型的简短列表：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Empty  </samp>Contains no data;
    sometimes used as a placeholder for a return value
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Empty  </samp>不包含数据；有时作为返回值的占位符使用
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data  </samp>Contains initialized
    data; used to pass and return data, such as a message to encrypt
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data  </samp>包含初始化数据；用于传递和返回数据，例如要加密的消息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Token  </samp>Contains a token;
    used to pass and return authentication tokens and signatures
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Token  </samp>包含令牌；用于传递和返回认证令牌及签名
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PkgParams  </samp>Contains additional
    configuration parameters for the security package
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">PkgParams  </samp>包含安全包的附加配置参数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamHeader  </samp>Contains the
    header of a streaming protocol
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">流头  </samp>包含流协议的头部
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">StreamTrailer  </samp>Contains
    the trailer of a streaming protocol
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">流尾  </samp>包含流协议的尾部
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stream  </samp>Contains the data
    of a streaming protocol
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">流  </samp>包含流协议的数据
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Extra  </samp>Contains extra data
    generated by the security package
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">额外  </samp>包含安全包生成的额外数据
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChannelBindings  </samp>Contains
    the channel binding data
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">通道绑定  </samp>包含通道绑定数据
- en: 'You can use security buffers as either input or output, depending on the security
    package’s requirements and the API used. If you want to define an output-only
    buffer, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    parameter when creating the buffer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据安全包的要求和使用的 API，选择将安全缓冲区作为输入或输出。如果你想定义一个仅输出的缓冲区，可以在创建缓冲区时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    参数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sometimes you may want to pass an initialized buffer whose contents the package
    shouldn’t modify. To indicate this, the APIs specify two additional flags you
    can add to the type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望传递一个初始化的缓冲区，其内容不应被安全包修改。为了表示这一点，API 指定了两个可以添加到类型中的额外标志：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnly  </samp>The buffer is
    read-only but is not part of the signature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">只读  </samp>缓冲区是只读的，但不是签名的一部分。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnlyWithChecksum  </samp>The
    buffer is read-only and should be part of the signature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOnlyWithChecksum  </samp>缓冲区是只读的，并且应作为签名的一部分。
- en: 'You specify these additional flags using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> parameter
    when creating a buffer, as in the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建缓冲区时，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> 参数来指定这些额外的标志，如下例所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whether the difference between the two read-only flags is honored depends on
    the security package. For example, NTLM ignores the difference and always adds
    a read-only buffer to the signature, while Kerberos adds the buffer as part of
    the signature only if the buffer you supply has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp>
    flag.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 是否遵守两个只读标志之间的差异取决于安全包。例如，NTLM 忽略差异，并始终将只读缓冲区添加到签名中，而 Kerberos 只有在你提供的缓冲区具有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadOnlyWithChecksum</samp> 标志时，才将缓冲区作为签名的一部分添加。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with
    an Authentication Context</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用带有身份验证上下文的缓冲区</samp>
- en: 'The SSPI APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell commands take two lists of security buffers: one to use as input to
    the API and one to use as output. You can specify the list of these buffers using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">InputBuffer</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OutputBuffer</samp> parameters, as shown
    in [Listing 15-1](chapter15.xhtml#Lis15-1).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp>
    PowerShell 命令使用的 SSPI API 接受两个安全缓冲区列表：一个作为 API 的输入，另一个作为输出。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">InputBuffer</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputBuffer</samp> 参数指定这些缓冲区的列表，如
    [Listing 15-1](chapter15.xhtml#Lis15-1) 所示。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 15-1: Using input and output buffers with an authentication context'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-1：在身份验证上下文中使用输入和输出缓冲区
- en: This listing shows a hypothetical use of input and output buffers during authentication.
    (You’ll see actual examples over the course of this chapter.) This example assumes
    you’ve already set up a client authentication context as <samp class="SANS_TheSansMonoCd_W5Regular_11">$client</samp>
    and a server authentication token as <samp class="SANS_TheSansMonoCd_W5Regular_11">$token</samp>.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例显示了在身份验证过程中使用输入和输出缓冲区的假设用法。（你将在本章的后续内容中看到实际的示例。）此示例假设你已将客户端身份验证上下文设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">$client</samp>，并将服务器身份验证令牌设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">$token</samp>。
- en: We first create one input buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>
    containing a string ❶. The contents of the buffer depend on the package you’re
    using; normally, the API’s documentation will tell you what you need to specify.
    Next, we create an output buffer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>,
    allocating a maximum buffer size of 100 bytes ❷. We then update the client context,
    passing it the server authentication token and the input and output buffers ❸.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>的输入缓冲区，其中包含一个字符串❶。缓冲区的内容取决于所使用的包；通常，API文档会告诉你需要指定的内容。接下来，我们创建一个类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>的输出缓冲区，分配最大缓冲区大小为100字节❷。然后，我们更新客户端上下文，传递服务器身份验证令牌以及输入和输出缓冲区❸。
- en: The command will add the token as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    type buffer to the start of the input list, and will also append any channel bindings
    specified when creating the context. Therefore, the input buffer list passed in
    this case would contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>
    buffer. Sometimes the package doesn’t want you to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer; in that case, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoToken</samp>
    parameter to exclude it from the input list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会将令牌作为<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>类型的缓冲区添加到输入列表的开头，并且还会附加在创建上下文时指定的任何通道绑定。因此，在这种情况下，传递的输入缓冲区列表将包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>缓冲区，后跟<samp class="SANS_TheSansMonoCd_W5Regular_11">PkgParams</samp>缓冲区。有时包可能不希望你包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>缓冲区；在这种情况下，你可以指定<samp class="SANS_TheSansMonoCd_W5Regular_11">NoToken</samp>参数以将其从输入列表中排除。
- en: The command also automatically adds the output <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    buffer for the new authentication token to the output list. If the API call succeeds,
    it will assign the contents of this buffer to the context’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    property. It’s not normally necessary to exclude that buffer from the output,
    so the command doesn’t give you that option.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令还会自动将输出<samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>缓冲区添加到输出列表中，以存储新的身份验证令牌。如果API调用成功，它将把该缓冲区的内容分配给上下文的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>属性。通常不需要将该缓冲区从输出中排除，因此命令不会提供这个选项。
- en: After a successful call, we check the output buffer, which has been updated.
    Certain packages might change an output buffer’s type, size, and contents. For
    instance, the type in this example has been changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Extra</samp>. We can convert
    the buffer back to a byte array using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>
    command. Displaying the output shows that the 100-byte buffer we’ve created now
    has only 4 valid bytes. The security package initialized these 4 bytes and updated
    the structure’s length accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用后，我们检查已更新的输出缓冲区。某些包可能会更改输出缓冲区的类型、大小和内容。例如，当前例子中，类型已从<samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>更改为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Extra</samp>。我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>命令将缓冲区转换回字节数组。显示输出表明我们创建的100字节缓冲区现在只有4个有效字节。安全包初始化了这4个字节，并相应地更新了结构的长度。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Buffers with
    Signing and Sealing</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用带签名和封装的缓冲区</samp>
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> parameter,
    you can specify buffers during signing and sealing operations when calling the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp>
    PowerShell commands, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>.
    The underlying APIs take only a single list of buffers to use for both the input
    and output. In [Listing 15-2](chapter15.xhtml#Lis15-2), we encrypt a buffer containing
    an additional header.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 参数，你可以在调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp> PowerShell
    命令时，指定在签名和密封操作期间使用的缓冲区，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>。底层
    API 只接受一单一的缓冲区列表，供输入和输出使用。在[示例 15-2](chapter15.xhtml#Lis15-2)中，我们加密了一个包含附加头的缓冲区。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 15-2: Encrypting a message with buffers'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-2：使用缓冲区加密消息
- en: We first create the header buffer, marking it as read-only with a checksum.
    By marking it as read-only, we ensure that the contents won’t be encrypted but
    will still be included in the signature. Next, we create the data buffer from
    a string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建头部缓冲区，并通过校验和将其标记为只读。通过将其标记为只读，我们确保其内容不会被加密，但仍会被包含在签名中。接下来，我们从字符串中创建数据缓冲区。
- en: We then pass the buffers to <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>.
    This command returns the signature for the encryption operation and updates the
    encrypted data in place. When dumping the buffers, we can see that the header
    is still unencrypted even though the data buffer has been encrypted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将缓冲区传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>。该命令返回加密操作的签名，并原地更新加密数据。当转储缓冲区时，我们可以看到，尽管数据缓冲区已被加密，但头部仍未加密。
- en: 'We can decrypt the buffer using <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    in a manner similar to how we encrypted the buffer: by passing the buffers and
    the signature to the command. Once the buffer is decrypted, we can convert it
    back to a string. If the signature for the buffers isn’t valid, the command will
    throw an error.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    解密缓冲区，方法与我们加密缓冲区时类似：通过将缓冲区和签名传递给命令。一旦缓冲区被解密，我们可以将其转换回字符串。如果缓冲区的签名无效，命令将抛出错误。
- en: Now that you know how to use security buffers for the SSPI APIs, let’s look
    at the Negotiate protocol, which allows Windows to automatically select the best
    authentication protocol to use based on what credentials are available to the
    caller.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何为 SSPI API 使用安全缓冲区了，接下来我们来看一下 Negotiate 协议，它允许 Windows 根据调用者的可用凭证自动选择最佳的认证协议。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Negotiate Protocol</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">协商协议</samp>
- en: What happens if you don’t know what types of network authentication the server
    supports? You might first try using Kerberos and then, if it isn’t supported,
    switch to NTLM. But that’s not a very efficient use of resources. Also, if Microsoft
    were to later introduce a new, more secure authentication protocol, you’d have
    to update your application to support it. The *Negotiate* protocol solves both
    problems by allowing a client and server to negotiate the best available network
    authentication protocol. Microsoft’s implementation of Negotiate is based on the
    *Simple and Protected Negotiation Mechanism (SPNEGO)* protocol, defined in RFC4178.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道服务器支持哪种类型的网络认证会发生什么？你可能首先尝试使用 Kerberos，如果不支持，再切换到 NTLM。但这并不是一种高效的资源利用方式。而且，如果微软稍后推出一种新的、更安全的认证协议，你将不得不更新你的应用程序以支持它。*Negotiate*
    协议解决了这两个问题，允许客户端和服务器协商使用最佳的网络认证协议。微软实现的 Negotiate 协议基于*简单和保护的协商机制（SPNEGO）*，该协议在
    RFC4178 中定义。
- en: To select the Negotiate protocol, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Negotiate</samp>
    package in both the client and the server authentication context. The first token
    generated by a client authentication context contains a list of the authentication
    protocols the client supports. In its ASN.1 structure, it can also embed the first
    authentication token for whichever of the supported authentication protocols the
    client would prefer to use. For example, it might embed an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    NEGOTIATE</samp> token. In [Listing 15-3](chapter15.xhtml#Lis15-3), we initialize
    the Negotiate client authentication context.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择 Negotiate 协议，请在客户端和服务器的身份验证上下文中都使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Negotiate</samp>
    协议包。客户端身份验证上下文生成的第一个令牌包含客户端支持的身份验证协议列表。在其 ASN.1 结构中，它还可以嵌入客户端首选的任何身份验证协议的第一个身份验证令牌。例如，它可能嵌入一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM NEGOTIATE</samp> 令牌。在 [列表 15-3](chapter15.xhtml#Lis15-3)
    中，我们初始化了 Negotiate 客户端身份验证上下文。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 15-3: Initializing the Negotiate client authentication'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-3：初始化 Negotiate 客户端身份验证
- en: We specify the credentials for using the Negotiate security package ❶, then
    continue as normal by creating the context. In the formatted token, we first see
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO Init</samp>, which indicates
    that this is an initialization token ❷. Following the header is the list of supported
    authentication protocols, or *security mechanisms* ❸. The list is sorted in descending
    order of preference, so in this case, the client prefers NTLM over Kerberos. You
    won’t see Kerberos in the list unless you’re on a domain-joined system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定用于使用 Negotiate 安全协议的凭据 ❶，然后继续按常规方式创建上下文。在格式化的令牌中，我们首先看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO
    Init</samp>，这表明这是一个初始化令牌 ❷。头部之后是支持的身份验证协议列表，或称为*安全机制* ❸。该列表按优先顺序降序排列，因此在这种情况下，客户端更喜欢
    NTLM 而不是 Kerberos。除非你在一个域连接的系统上，否则你不会在列表中看到 Kerberos。
- en: 'You might notice the mechanism list contains two types of Kerberos. The presence
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Microsoft Kerberos</samp>
    identifier is due to a bug in Windows 2000: the value <samp class="SANS_TheSansMonoCd_W5Regular_11">113554</samp>
    in the identifier, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1BB92</samp>
    in hexadecimal, was truncated to 16 bits, resulting in the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0xBB92</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">48018</samp>. Microsoft has left
    this mistake for backward compatibility reasons, and the two values represent
    the same Kerberos authentication protocol. Microsoft also defines an extended
    negotiation protocol, the fourth mechanism in this list, but we won’t discuss
    it here.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到机制列表中包含两种类型的 Kerberos。<samp class="SANS_TheSansMonoCd_W5Regular_11">Microsoft
    Kerberos</samp> 标识符的存在是由于 Windows 2000 的一个 bug：标识符中的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">113554</samp>，或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1BB92</samp>（十六进制），被截断为 16 位，导致值变为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xBB92</samp>，或 <samp class="SANS_TheSansMonoCd_W5Regular_11">48018</samp>。微软出于向后兼容的原因保留了这个错误，这两个值代表同一个
    Kerberos 身份验证协议。微软还定义了一个扩展的协商协议，即此列表中的第四种机制，但我们在这里不讨论它。
- en: Following the list of supported protocols is an authentication token ❹. In this
    case, the client has chosen to send the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    NEGOTIATE</samp> token.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 支持协议列表后面是一个身份验证令牌 ❹。在这种情况下，客户端选择发送初始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    NEGOTIATE</samp> 令牌。
- en: The server authentication context can select the most appropriate authentication
    protocol it supports. Most commonly, it will use the protocol that is the client’s
    preferred choice, determined by the ordering of the list of supported authentication
    protocols. However, it can also ignore the client’s preference and request a different
    authentication protocol if desired. It sends the selected authentication protocol
    and any further authentication tokens to the client. This authentication exchange
    process continues until either an error occurs or the process is complete. [Listing
    15-4](chapter15.xhtml#Lis15-4) shows how the server responds to the client’s request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器身份验证上下文可以选择其支持的最合适的身份验证协议。通常，它将使用客户端首选的协议，这由支持的身份验证协议列表的顺序决定。然而，它也可以忽略客户端的偏好，若需要可以请求其他身份验证协议。它将把选定的身份验证协议和任何进一步的身份验证令牌发送给客户端。这个身份验证交换过程将持续，直到发生错误或过程完成。[列表
    15-4](chapter15.xhtml#Lis15-4) 展示了服务器如何响应客户端的请求。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 15-4: Continuing the Negotiate authentication on the server'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-4：在服务器上继续进行 Negotiate 身份验证
- en: We first pass the client authentication token to the server authentication context
    that we create. In the formatted output, we can see that it’s an <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO
    Response</samp>, and that the server has opted to use NTLM. The response has a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp> flag, which indicates
    that the negotiation is currently incomplete. Following that is the authentication
    token, which, as expected, is now an <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    CHALLENGE</samp> token.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将客户端身份验证令牌传递给我们创建的服务器身份验证上下文。在格式化的输出中，我们可以看到它是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SPNEGO
    响应</samp>，并且服务器选择使用 NTLM。响应中有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp>
    标志，表示协商当前尚未完成。接下来是身份验证令牌，正如预期，它现在是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    挑战</samp> 令牌。
- en: In [Listing 15-5](chapter15.xhtml#Lis15-5), we complete the authentication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 15-5](chapter15.xhtml#Lis15-5) 中，我们完成了身份验证。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 15-5: Completing the Negotiate authentication'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-5：完成 Negotiate 身份验证
- en: The next client authentication token sent is the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp> token ❶. Note that the supported authentication protocol field
    is not present. This is only required in the initial server token, and it’s omitted
    from subsequent tokens.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个发送的客户端身份验证令牌是 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM 身份验证</samp>
    令牌 ❶。请注意，支持的身份验证协议字段没有出现。这个字段只在初始服务器令牌中需要，后续令牌中会省略。
- en: In normal NTLM authentication, the authentication would typically complete at
    this point. However, in Negotiate authentication, the client’s state is considered
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Incomplete</samp> until we generate
    a final server token and update the client with this token, which then marks the
    state as <samp class="SANS_TheSansMonoCd_W5Regular_11">Completed</samp> ❷. We
    can then query the final package using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PackageName</samp>
    property ❸, which shows that we negotiated NTLM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的 NTLM 身份验证中，身份验证通常在此时完成。然而，在 Negotiate 身份验证中，客户端的状态被认为是 <samp class="SANS_TheSansMonoCd_W5Regular_11">不完整</samp>，直到我们生成最终的服务器令牌并使用该令牌更新客户端，这样状态才会被标记为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">完成</samp> ❷。然后，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">PackageName</samp>
    属性 ❸ 查询最终包，这将显示我们协商的是 NTLM。
- en: To negotiate the use of Kerberos, the protocol acts in a similar manner. But
    as Kerberos needs an SPN to function, you must specify the target name using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> parameter when creating
    the client authentication context; otherwise, the protocol will select NTLM. The
    output of the Kerberos authentication will replace the NTLM tokens with Kerberos
    AP-REQ and AP-REP tokens.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要协商使用 Kerberos，协议的工作方式类似。但由于 Kerberos 需要 SPN 才能工作，因此在创建客户端身份验证上下文时，必须使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> 参数指定目标名称；否则，协议将选择 NTLM。Kerberos
    身份验证的输出将用 Kerberos AP-REQ 和 AP-REP 令牌替换 NTLM 令牌。
- en: Now that we’ve covered the Negotiate protocol, let’s discuss a few less common
    security packages that you might encounter during an analysis of a Windows system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Negotiate 协议，接下来让我们讨论一些在分析 Windows 系统时可能遇到的较不常见的安全包。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Less Common Security Packages</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">不常见的安全包</samp>
- en: 'We’ve covered the three main security packages you’re most likely to use on
    Windows: NTLM, Kerberos, and Negotiate. But there are a few other security packages
    that have important functions, even if you’re less likely to use them directly.
    We won’t spend very much time discussing these, but I’ll give you a quick example
    of each so that you understand their purpose and function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在 Windows 上最常用的三种安全包：NTLM、Kerberos 和 Negotiate。但仍有一些其他安全包具有重要功能，即使你不太可能直接使用它们。我们不会花太多时间讨论这些，但我会给你每个包的一个简单示例，让你了解它们的目的和功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Secure Channel</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全通道</samp>
- en: Sending sensitive information (like user credentials) unencrypted over the internet
    is generally considered a bad idea. Several network protocols can encrypt network
    traffic, but by far the most common is *Transport Layer Security (TLS)*, which
    was once called *Secure Sockets Layer (SSL)* and was originally developed by Netscape
    in the mid-1990s to secure HTTP connections. A variant of TLS, the *Datagram Transport
    Layer Security (DTLS)* protocol, can encrypt traffic from unreliable protocols,
    such as the *User Datagram Protocol (UDP)*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网以未加密方式发送敏感信息（如用户凭证）通常被认为是一个坏主意。几种网络协议可以加密网络流量，但迄今为止最常见的是 *传输层安全性（TLS）*，它曾被称为
    *安全套接字层（SSL）*，最初由 Netscape 在 1990 年代中期开发，用于保护 HTTP 连接。TLS 的一种变体，*数据报传输层安全性（DTLS）*
    协议，可以加密来自不可靠协议的流量，如 *用户数据报协议（UDP）*。
- en: '*Secure channel* is an implementation of TLS provided as a security package,
    and you can access it through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp>
    package using the same SSPI APIs as for other network authentication protocols.
    While you can use secure channel as a TLS or DTLS encryption layer for network
    traffic, you can also use it to provide client authentication facilities to a
    server through client certificates.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全通道* 是作为安全包提供的 TLS 实现，你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp>
    包，使用与其他网络认证协议相同的 SSPI API 来访问它。虽然你可以将安全通道用作网络流量的 TLS 或 DTLS 加密层，但你也可以通过客户端证书来为服务器提供客户端认证功能。'
- en: Let’s walk through a simple example of how to use the package. [Listing 15-6](chapter15.xhtml#Lis15-6)
    starts by setting up the client credentials handle and the client authentication
    context.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来演示如何使用该包。[示例 15-6](chapter15.xhtml#Lis15-6) 首先设置客户端凭证句柄和客户端认证上下文。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 15-6: Setting up the secure channel client authentication context'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-6：设置安全通道客户端认证上下文
- en: When setting up the context, you need to specify a target name, which is typically
    the DNS name of the server. The protocol uses this target name to verify that
    the server has a valid certificate for that name. TLS connections can also be
    cached, so the protocol can check whether an existing cache entry exists for the
    target name. In this case, the name won’t matter because we specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ManualCredValidation</samp> request attribute,
    which disables the server certificate checks so that we can use a self-signed
    certificate for the server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置上下文时，你需要指定一个目标名称，这通常是服务器的 DNS 名称。该协议使用此目标名称来验证服务器是否具有该名称的有效证书。TLS 连接也可以被缓存，因此协议可以检查是否已为目标名称存在现有的缓存条目。在这种情况下，名称不会重要，因为我们指定了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ManualCredValidation</samp> 请求属性，禁用了服务器证书检查，以便我们可以使用自签名证书为服务器提供服务。
- en: We then format the authentication token, which displays the TLS protocol’s simple
    record structure (shown in [Figure 15-1](chapter15.xhtml#fig15-1)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们格式化认证令牌，它显示了 TLS 协议的简单记录结构（见 [图 15-1](chapter15.xhtml#fig15-1)）。
- en: '![](../images/Figure15-1.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The TLS record
    structure</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-1：TLS 记录结构</samp>
- en: The record structure contains a 5-byte header consisting of a record type, the
    major and minor versions of the protocol, and a data length. The header is followed
    by a list of bytes whose interpretation depends on the record type. In [Listing
    15-6](chapter15.xhtml#Lis15-6), the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>,
    a record used during the connection setup to negotiate the encryption protocol
    to use, exchange certificates, and communicate the encryption keys. Its version
    is 3.3, which corresponds to TLS 1.2\. (The designers of the protocol considered
    TLS to be a minor addition to SSL 3.0, so they increased only its minor version
    number.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记录结构包含一个 5 字节的头部，包括记录类型、协议的主版本和次版本号，以及数据长度。头部后面是一个字节列表，其解释取决于记录类型。在 [示例 15-6](chapter15.xhtml#Lis15-6)
    中，类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">握手</samp>，这是连接设置过程中使用的记录，用于协商加密协议、交换证书和传输加密密钥。其版本是
    3.3，表示 TLS 1.2。 （协议设计者认为 TLS 是 SSL 3.0 的一个小改动，因此只增加了次版本号。）
- en: In [Listing 15-7](chapter15.xhtml#Lis15-7), we generate an X.509 certificate
    and finish setting up the server side of the secure channel authentication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 15-7](chapter15.xhtml#Lis15-7) 中，我们生成了一个 X.509 证书，并完成了安全通道认证的服务器端设置。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 15-7: Initializing a security channel server context and completing
    authentication'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-7：初始化安全通道服务器上下文并完成认证
- en: We start by checking whether we have a certificate whose subject name is the
    DNS name we specified when creating the client authentication context ❶. PowerShell
    exposes the system’s certificate store via the *Cert* drive provider. In this
    case, we check only the current user’s personal certificate store for a matching
    certificate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否有一个证书，其主题名称为我们在创建客户端认证上下文时指定的 DNS 名称❶。PowerShell 通过 *Cert* 驱动程序暴露系统的证书库。在此案例中，我们仅检查当前用户的个人证书库，查找匹配的证书。
- en: If the certificate doesn’t already exist, we create a new one using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-SelfSignedCertificate</samp> command
    with the DNS name as the subject, storing it in the current user’s personal store
    ❷. This certificate isn’t trusted for the TLS certificate chain. You could add
    the new certificate to *Cert:\CurrentUser\Root*, which would make it trusted;
    however, it’s safer to just disable the certificate checking in the client for
    this example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果证书尚不存在，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-SelfSignedCertificate</samp>
    命令创建一个新的证书，DNS 名称作为主题，并将其存储在当前用户的个人证书库中❷。这个证书不被信任为 TLS 证书链的一部分。你可以将新的证书添加到 *Cert:\CurrentUser\Root*，这样它会被信任；但是，为了本示例的安全起见，最好禁用客户端中的证书检查。
- en: To use the certificate for the server, we need to create a set of secure channel
    credentials, specifying the certificate for use by the server ❸. Note that the
    certificate must have an associated private key for the server to use. If you
    pick a certificate without the private key, this line of code will generate an
    error. We can use the credentials to create a handle and, from that, the server
    authentication context.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用服务器的证书，我们需要创建一套安全通道凭据，指定供服务器使用的证书❸。请注意，证书必须具有与之关联的私钥，服务器才能使用。如果选择了没有私钥的证书，这行代码将会产生错误。我们可以使用凭据创建一个句柄，从而获得服务器认证上下文。
- en: Finally, we exchange tokens between the server and client authentication context
    until the authentication completes ❹. Of course, in a real application this process
    would exchange the tokens over a network connection, but for the sake of simplicity,
    we ignore the network entirely here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在服务器和客户端认证上下文之间交换令牌，直到认证完成❹。当然，在真实的应用中，这一过程会通过网络连接交换令牌，但为了简化起见，我们在这里完全忽略了网络。
- en: Before we do anything else, we can inspect the negotiated security information,
    as shown in [Listing 15-8](chapter15.xhtml#Lis15-8).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行其他操作之前，我们可以检查已协商的安全信息，如[示例 15-8](chapter15.xhtml#Lis15-8)所示。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 15-8: Inspecting the connection information'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-8：检查连接信息
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectionInfo</samp>
    property returns the negotiated protocol and encryption algorithms. In this case,
    we’ve negotiated TLS 1.2 using the AES256 encryption algorithm, SHA384 for integrity,
    and elliptic curve Diffie-Hellman to exchange an ephemeral encryption key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectionInfo</samp> 属性返回已协商的协议和加密算法。在此案例中，我们已协商使用
    AES256 加密算法的 TLS 1.2，使用 SHA384 进行完整性校验，并使用椭圆曲线 Diffie-Hellman 交换临时加密密钥。
- en: We can also query the server’s certificate. This should match the one we used
    in the server’s credentials. As we specified manual credential validation, we
    can check whether the certificate is valid; if we hadn’t requested manual validation,
    the handshake process would have generated an error. Finally, we can also query
    the server’s connection information to double-check that it’s the same as the
    client’s.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查询服务器的证书。该证书应该与我们在服务器凭据中使用的证书匹配。由于我们指定了手动凭据验证，我们可以检查证书是否有效；如果我们没有请求手动验证，握手过程将会产生错误。最后，我们还可以查询服务器的连接信息，以再次确认其与客户端的连接信息一致。
- en: At this point, we’ve set up the connection, but we have yet to transfer a single
    byte of user data to the server. [Listing 15-9](chapter15.xhtml#Lis15-9) shows
    how to encrypt and decrypt application data sent over the network connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经建立了连接，但还没有向服务器传输任何用户数据。[示例 15-9](chapter15.xhtml#Lis15-9) 展示了如何加密和解密通过网络连接发送的应用数据。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 15-9: Encrypting and decrypting application data'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-9：加密和解密应用数据
- en: Secure channel requires passing four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command ❶. The first buffer is for the TLS record header. It needs to be of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeader</samp> and should be
    of a size queried from the context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeaderSize</samp>
    property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安全通道需要将四个缓冲区传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>命令❶。第一个缓冲区是TLS记录头部。它需要是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamHeader</samp>类型，并且应该是通过<samp class="SANS_TheSansMonoCd_W5Regular_11">StreamHeaderSize</samp>属性从上下文查询到的大小。
- en: The second buffer is for the data to encrypt and must be of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>.
    There is a maximum allowed size for this buffer, which you can query using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamMaxMessageSize</samp> property.
    The maximum size is typically 16KB, so the 4 bytes we use here should fall well
    within the limit. If the application data to encrypt is larger than the maximum
    size, you’ll need to fragment the data into smaller parts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个缓冲区是要加密的数据，必须是<samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>类型。这个缓冲区有一个最大允许的大小，您可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamMaxMessageSize</samp>属性查询。最大大小通常为16KB，因此我们在这里使用的4个字节应该远小于限制。如果要加密的应用数据大于最大大小，则需要将数据分成更小的部分。
- en: The third buffer will contain the stream trailer, which must be of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailer</samp> and of size <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailerSize</samp>. The final buffer
    is an empty one. The secure channel package doesn’t seem to use the buffer to
    store anything, but you must pass it, or the call will fail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个缓冲区将包含流尾部，必须是<samp class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailer</samp>类型，并且大小为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">StreamTrailerSize</samp>。最后一个缓冲区是空的。安全通道包似乎并不使用该缓冲区存储任何内容，但您必须传递它，否则调用将失败。
- en: We can now encrypt the data by passing all four buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>
    command ❷. One important thing to note is that you should also pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp> parameter. Any generated
    signature will be part of the generated protocol data, not returned separately,
    so there is no need for the command to automatically handle the signature.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将所有四个缓冲区传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp>命令❷来加密数据。需要注意的一点是，您还应该传递<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp>参数。任何生成的签名将成为生成的协议数据的一部分，而不是单独返回，因此该命令不需要自动处理签名。
- en: The result of the encryption is that the header, data, and trailer buffers are
    populated with the data required to transmit the application data to the server.
    We need to concatenate the buffers together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>
    command ❸. In this case, we already know that the data generated is a TLS record,
    so we can use the authentication context commands to inspect its structure. We
    can see that the record type is now <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>
    ❹, whereas in [Listing 15-6](chapter15.xhtml#Lis15-6) the record type was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>
    indicates that this is an encrypted data record.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的结果是，头部、数据和尾部缓冲区会填充传输应用数据到服务器所需的数据。我们需要使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ConvertFrom-LsaSecurityBuffer</samp>命令❸将缓冲区连接起来。在这种情况下，我们已经知道生成的数据是TLS记录，因此我们可以使用身份验证上下文命令来检查其结构。我们可以看到记录类型现在是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>❹，而在[Listing 15-6](chapter15.xhtml#Lis15-6)中，记录类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Handshake</samp>。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ApplicationData</samp>表明这是一个加密的数据记录。
- en: Now we need to decrypt the data on the server. To do so, we again need four
    buffers; however, their configuration is slightly different. For decryption, we
    must place the entire TLS record in the first buffer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    type ❺. The next three buffers can be empty; they’ll be populated during decryption
    with the appropriate parts of the message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在服务器上解密数据。为此，我们仍然需要四个缓冲区；然而，它们的配置稍有不同。对于解密，我们必须将整个TLS记录放入第一个缓冲区，类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>❺。接下来的三个缓冲区可以为空；它们将在解密过程中填充消息的适当部分。
- en: We pass the buffers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    command, again specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp>
    parameter, as the signature is part of the protocol ❻. When checking the data
    buffer, which was originally empty, we now find it’s populated with the original
    unencrypted data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将缓冲区传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp>
    命令，再次指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">NoSignature</samp> 参数，因为签名是协议的一部分
    ❻。当检查原本为空的数据缓冲区时，我们现在发现它已经填充了原始的未加密数据。
- en: I’ve made secure channel look easy to use, but it’s much more complex than shown
    here. For example, you’ll have to deal with out-of-band alerts, which indicate
    problems with the connection. I recommend that you use an existing class (such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>, which comes
    with .NET) to add TLS support to your application unless there’s a niche feature
    not exposed that you need to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经让安全通道看起来很容易使用，但它比这里展示的要复杂得多。例如，你需要处理带外警报，这些警报表明连接存在问题。除非有未公开的特定功能需要使用，否则我建议你使用现有的类（比如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp>，它是 .NET 的一部分）来为你的应用程序添加
    TLS 支持。
- en: By default, the TLS protocol verifies only the server in the secure channel
    connection, using the X.509 certificate; however, the server can request that
    the client also present a valid certificate for verification purposes. To require
    the client to send a certificate, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp>
    request attribute when creating the server authentication context. By default,
    secure channel will try to find a suitable certificate for the user on the client,
    but you can override this search by setting an explicit certificate when generating
    the client’s credentials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TLS 协议仅验证安全通道连接中的服务器，使用的是 X.509 证书；然而，服务器可以请求客户端也出示有效的证书进行验证。如果需要客户端发送证书，请在创建服务器身份验证上下文时指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MutualAuth</samp> 请求属性。默认情况下，安全通道会尝试在客户端上为用户找到合适的证书，但你可以通过设置显式证书来覆盖这一搜索，从而生成客户端的凭证。
- en: The server can query for the client’s certificate using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteCertificate</samp>
    property on the server authentication context. Note that secure channel doesn’t
    validate the contents of the client certificate by default; doing so is up to
    the server application. The only thing secure channel guarantees is that the client
    can prove they have the corresponding private key for the certificate. If the
    server is part of an enterprise network, it’s possible to add an identity certificate
    to Active Directory so that the client certificate can be mapped to a user account
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object can be
    queried for the user’s identity without any further authentication.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteCertificate</samp>
    属性，在服务器身份验证上下文中查询客户端的证书。请注意，安全通道默认不会验证客户端证书的内容；这项工作由服务器应用程序来完成。安全通道唯一保证的是客户端能够证明自己拥有与证书相对应的私钥。如果服务器是企业网络的一部分，可以将身份证书添加到
    Active Directory 中，这样客户端证书就可以映射到用户账户，并且可以查询 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象以获取用户身份，无需进一步的身份验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CredSSP</samp>
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CredSSP</samp>
- en: The final security package we’ll look at is *CredSSP*, an authentication protocol
    developed by Microsoft to improve the security of remote desktop connections to
    Windows machines. [Figure 15-2](chapter15.xhtml#fig15-2) shows the original remote
    desktop implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最终安全包是*CredSSP*，这是由微软开发的一种身份验证协议，用于提高远程桌面连接到 Windows 计算机的安全性。[图 15-2](chapter15.xhtml#fig15-2)展示了原始的远程桌面实现。
- en: '![](../images/Figure15-2.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-2: The original remote
    desktop implementation</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-2：原始远程桌面实现</samp>
- en: In the original implementation, a client would connect to the server using a
    client application ❶. The RDP server would then create a LogonUI for the user
    that displayed the normal Windows logon user interface and replicate this LogonUI
    over RDP, so the user would get the same UI on their client machine. The user
    could then enter their username and password into the LogonUI ❷, which would follow
    the interactive authentication process outlined in [Chapter 12](chapter12.xhtml)
    to verify the user’s credentials ❸ and create their desktop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始实现中，客户端会使用客户端应用程序 ❶ 连接到服务器。RDP 服务器会为用户创建一个 LogonUI，显示常规的 Windows 登录界面，并通过
    RDP 将此 LogonUI 复制给用户，这样用户就能在客户端机器上看到相同的界面。用户随后可以将用户名和密码输入到 LogonUI ❷ 中，系统会按照 [第
    12 章](chapter12.xhtml) 中概述的交互式身份验证过程来验证用户的凭证 ❸，并创建桌面会话。
- en: This approach to implementing a remote desktop has several security problems.
    First, it performs no verification of the client; this allows anyone to connect,
    then try to guess a user’s password or exploit some bug in the LogonUI to get
    access to the server. Second, starting up a desktop session for the user interface
    is quite an expensive operation; it’s easy to make enough connections to a remote
    desktop server to exhaust the machine’s resources and cause a denial-of-service
    condition. Finally, there is a risk of the user having their credentials phished
    by providing them to a malicious remote server they were tricked into connecting
    to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现远程桌面的方法存在几个安全问题。首先，它没有对客户端进行验证；这使得任何人都可以连接，然后尝试猜测用户密码或利用 LogonUI 中的漏洞来获得服务器访问权限。其次，为用户界面启动桌面会话是一个非常消耗资源的操作；很容易通过建立足够的连接来耗尽远程桌面服务器的资源，导致拒绝服务的情况。最后，用户可能会被钓鱼，通过提供凭证给恶意远程服务器（他们被欺骗连接到该服务器）而导致凭证泄露的风险。
- en: Microsoft’s solution to these problems is *Network Level Authentication (NLA)*.
    NLA is available in Windows Vista onward, and it is the default authentication
    mechanism used when enabling remote desktop connections. NLA avoids the previously
    discussed problems by integrating authentication into the Remote Desktop Protocol
    and verifying that the user has valid credentials before starting a desktop session.
    This confirms the identity of the client, prevents the expensive operation of
    setting up the desktop until authentication succeeds, and allows the user to avoid
    disclosing their credentials to the server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 微软解决这些问题的方法是 *网络级身份验证（NLA）*。NLA 从 Windows Vista 开始提供，并且是启用远程桌面连接时使用的默认身份验证机制。NLA
    通过将身份验证集成到远程桌面协议中，并在启动桌面会话之前验证用户是否具有有效凭证，避免了前面讨论的问题。这可以确认客户端的身份，防止在身份验证成功之前进行消耗资源的桌面设置操作，并且可以让用户避免向服务器泄露其凭证。
- en: The CredSSP package implements NLA. It provides TLS for network-level encryption
    (based on secure channel), and a separate *TS Service Security Package (TSSSP)*
    that uses the Negotiate protocol to authenticate the user, as well as to derive
    a session key to encrypt the user’s credentials when sending them to the server.
    [Figure 15-3](chapter15.xhtml#fig15-3) shows an overview of using NLA to connect
    to a remote desktop server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CredSSP 包实现了 NLA。它为网络级加密提供了 TLS（基于安全通道），并且有一个单独的 *TS 服务安全包（TSSSP）*，该包使用 Negotiate
    协议来验证用户身份，并生成会话密钥以加密用户的凭证，并将其发送到服务器。[图 15-3](chapter15.xhtml#fig15-3) 显示了使用 NLA
    连接远程桌面服务器的概览。
- en: '![](../images/Figure15-3.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-3: A remote desktop
    connection using Network Level Authentication</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-3：使用网络级身份验证的远程桌面连接</samp>
- en: First, instead of immediately making a connection, the user provides their credentials
    to the remote desktop client ❶. This typically consists of their username and
    password for the remote server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户不立即建立连接，而是将凭证提供给远程桌面客户端 ❶。通常，这包括远程服务器的用户名和密码。
- en: The client then makes a connection to the remote server, using the CredSSP package
    to protect the network traffic with TLS ❷. The server sets up a corresponding
    CredSSP authentication context to implement this communication. Next, its CredSSP
    context uses the TSSSP package to verify the client based on an existing network
    authentication protocol, such as NTLM or Kerberos ❸. If this verification step
    fails, the server can close the connection before creating an expensive desktop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端随后使用CredSSP包保护网络流量，并通过TLS与远程服务器建立连接❷。服务器设置相应的CredSSP身份验证上下文以实现这种通信。接下来，它的CredSSP上下文使用TSSSP包基于现有的网络身份验证协议（如NTLM或Kerberos）来验证客户端❸。如果此验证步骤失败，服务器可以在创建昂贵的桌面之前关闭连接。
- en: You might expect the server to create the user’s desktop immediately once the
    network authentication is complete, but there’s an additional wrinkle introduced
    when connecting to a remote desktop. Normally, when you use a network authentication
    protocol such as NTLM or Kerberos, the created logon session on the server can
    access only local resources, as the user’s credentials are stored on the client
    computer only. This is the double hop problem I mentioned in [Chapter 13](chapter13.xhtml)
    when discussing NTLM domain network authentication.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望服务器在网络身份验证完成后立即创建用户的桌面，但在连接到远程桌面时会引入一个额外的问题。通常，当你使用像NTLM或Kerberos这样的网络身份验证协议时，服务器上创建的登录会话只能访问本地资源，因为用户的凭据只存储在客户端计算机上。这就是我在[第13章](chapter13.xhtml)中讨论NTLM域网络身份验证时提到的双重跳跃问题。
- en: This behavior is fine if the remote desktop user is accessing a resource locally
    on the server. But when using a remote desktop, users typically expect to be able
    to perform single sign-on to other machines on the network to continue to work
    from that remote desktop session. To solve the single sign-on problem, the client’s
    CredSSP context delegates the user’s credentials to the server ❹. It encrypts
    these credentials using the negotiated session key from the network authentication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程桌面用户仅访问服务器上的本地资源，这种行为是可以接受的。但在使用远程桌面时，用户通常期望能够通过单点登录访问网络上的其他计算机，继续在该远程桌面会话中工作。为了解决单点登录问题，客户端的CredSSP上下文将用户的凭据委派到服务器❹。它使用网络身份验证中协商的会话密钥加密这些凭据。
- en: Because the session key for the authentication is derived from the password,
    a malicious server can’t use NTLM relay or forward a Kerberos ticket and then
    capture the credentials, as they won’t be able to decrypt them. Once the LSA has
    a copy of the credentials, the remote user can use them to connect to other network
    services as if they have authenticated interactively.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于身份验证的会话密钥是从密码派生的，恶意服务器无法使用NTLM中继或转发Kerberos票证并捕获凭据，因为它们无法解密凭据。一旦LSA拥有凭据副本，远程用户就可以像进行交互式身份验证一样使用它们连接到其他网络服务。
- en: While CredSSP was designed for use with remote desktop connections, you’ll also
    find it’s used for other purposes that require credential delegation. For example,
    in PowerShell, it’s possible to use CredSSP over the WinRM protocol, used for
    PowerShell remoting. This allows you to create a remote PowerShell session that
    has the client’s credentials and can connect to other systems on the network.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CredSSP是为远程桌面连接设计的，但你会发现它也用于其他需要凭据委派的用途。例如，在PowerShell中，可以通过WinRM协议使用CredSSP，该协议用于PowerShell远程执行。这允许你创建一个具有客户端凭据的远程PowerShell会话，并且可以连接到网络上的其他系统。
- en: I won’t provide an example of using CredSSP, as for the most part it looks like
    the TLS connection you saw when testing secure channel. Instead, let’s cover a
    few final authentication topics I haven’t yet mentioned.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供使用CredSSP的示例，因为在大多数情况下，它看起来像你在测试安全通道时看到的TLS连接。相反，让我们讨论一些我尚未提到的最后几个身份验证主题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote Credential Guard and Restricted
    Admin Mode</samp>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">远程凭证保护和受限管理员模式</samp>
- en: You might notice a problem with delegating your credentials to the remote desktop
    server. With NLA, you can be confident that the server can verify your credentials,
    but if an attacker has compromised the server, they could harvest the credentials
    once they’re decrypted during the authentication process. Perhaps an attacker
    is waiting for you to connect to the server with your privileged domain administrator
    credentials. Also, there’s a chance that the server will leave your credentials
    lying around in the LSASS process’s memory even after you’ve logged off the system,
    meaning a malicious attacker can pick them up later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到委派凭据到远程桌面服务器时会遇到一个问题。使用 NLA，你可以确信服务器能够验证你的凭据，但如果攻击者攻破了服务器，他们可以在身份验证过程中凭据被解密时窃取这些凭据。也许攻击者在等待你使用具有特权的域管理员凭据连接到服务器。此外，即使你已经注销系统，服务器可能仍会将你的凭据留在
    LSASS 进程的内存中，这意味着恶意攻击者可以稍后拾取这些凭据。
- en: Windows provides two optional features to mitigate the risk of a compromised
    server. The first is *Remote Credential Guard*, which works with Kerberos authentication
    to avoid directly delegating the user’s credentials. Using Remote Credential Guard,
    the client can generate new Kerberos tickets on demand to access resources. This
    allows the client to connect to other systems from a remote desktop as if they
    had delegated their credentials.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 提供了两个可选功能来减少服务器被攻破的风险。第一个是 *远程凭据保护*，它与 Kerberos 身份验证一起工作，避免直接委派用户的凭据。通过使用远程凭据保护，客户端可以按需生成新的
    Kerberos 票证来访问资源。这使得客户端能够像委派凭据一样，从远程桌面连接到其他系统。
- en: Importantly for security, this channel to create new tickets exists only while
    the client is connected to the server. If they disconnect, the server can no longer
    create new tickets, although any client that is already authenticated will likely
    stay that way. This means the machine must be actively compromised while the privileged
    user is authenticated to be useful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全性至关重要的是，创建新票证的通道仅在客户端连接到服务器时存在。如果客户端断开连接，服务器将无法再创建新票证，尽管任何已认证的客户端可能仍会保持认证状态。这意味着，只有在特权用户已认证且机器被积极攻破的情况下，才有可能获取有用的凭据。
- en: 'You need to perform some setup steps in your domain to enable Remote Credential
    Guard. The setup is out of scope for this section, but if the feature has been
    enabled, you can use it with the remote desktop client by running the following
    command line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在域中执行一些设置步骤以启用远程凭据保护。本节不涉及设置过程，但如果该功能已启用，你可以通过运行以下命令行在远程桌面客户端中使用它：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second security feature is *Restricted Admin mode*. Its big difference from
    Remote Credential Guard is that when a user authenticates to a server, it creates
    the logon session without the user’s network credentials. Instead, the session
    is assigned network credentials for the computer account on the server. Therefore,
    the logon session is primarily useful only if the user wants to perform tasks
    locally; they won’t be able to connect to network resources as themselves unless
    they explicitly provide their credentials to the remote server. However, this
    feature ensures that there are no privileged credentials to steal if the server
    is compromised.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个安全功能是 *限制管理员模式*。与远程凭据保护的最大区别在于，当用户对服务器进行身份验证时，它会创建一个没有用户网络凭据的登录会话。相反，该会话会分配给服务器计算机帐户的网络凭据。因此，该登录会话主要仅在用户希望本地执行任务时有用；除非用户明确向远程服务器提供凭据，否则他们将无法以自己的身份连接到网络资源。然而，该功能确保即使服务器被攻破，也没有特权凭据可以被窃取。
- en: 'To enable Restricted Admin mode, first add a DWORD registry key value named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DisableRestrictedAdmin</samp> to
    *HKLM\System\CurrentControlSet\Control\Lsa* and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    Then you can enable the mode when executing the client with the following command
    line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用限制管理员模式，首先在 *HKLM\System\CurrentControlSet\Control\Lsa* 中添加一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">DisableRestrictedAdmin</samp>
    的 DWORD 注册表键值，并将其设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。然后，你可以通过以下命令行在执行客户端时启用该模式：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One advantage of these two security features (above and beyond the restrictions
    they place on credential delegation) is that they allow the remote desktop client
    to use single sign-on authentication based on the current user’s credentials stored
    in the LSA logon session. This is because neither feature requires the plaintext
    credentials.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Credential Manager</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One annoyance of using a remote desktop connection is having to enter your password
    every time you want to connect. This seems unavoidable, as you must provide the
    account password to the server to allow single sign-on to function from the remote
    desktop server. However, the LSA supports a feature to save the account password
    for subsequent authentication to save you typing it in again. One place where
    this feature is used is when you type in your credentials; you’ll see a “Remember
    me” checkbox in the dialog, as shown in [Figure 15-4](chapter15.xhtml#fig15-4).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-4.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-4: Entering and saving
    your credentials</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: If you check the box and successfully authenticate, the dialog in which to enter
    the server’s name should change slightly the next time you open it ([Figure 15-5](chapter15.xhtml#fig15-5)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-5: Connection dialog
    with saved credentials</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see that the dialog gives you the option to edit or delete saved
    credentials for this server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy for the client to store the user’s password directly to a file
    on disk, but that wouldn’t be very secure. Instead, it uses a service provided
    by the LSA known as the *credential manager*. The service can store domain passwords
    for easy reuse, although Microsoft doesn’t recommend this practice. To demonstrate
    how credentials get stored, [Listing 15-10](chapter15.xhtml#Lis15-10) first uses
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Win32Credential</samp> PowerShell
    command, which calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CredRead</samp>
    Win32 API, to read the credentials for the remote desktop client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 15-10: Getting the credentials for a remote desktop client'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The credentials are stored by target name, which for domain credentials is the
    SPN for the service (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">TERMSRV/primarydc.domain.local</samp>).
    When looking up credentials you also need to specify the type, which in this case
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainPassword</samp>.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ve formatted the output to show only the username and password. However,
    you might notice a problem: the password column is empty. This is an intentional
    behavior of the service. If the credentials represent a domain password, the password
    won’t be returned unless the caller is running within the LSA process.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is fine for its intended purpose: to use in security packages
    that are running inside the LSA. For example, CredSSP can check whether the user
    has a credential for the target remote desktop service based on its SPN and use
    it to read the user’s password to automatically authenticate. The service stores
    the credentials in individual files in the user’s profile, as illustrated in [Listing
    15-11](chapter15.xhtml#Lis15-11).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对于其预期的目的来说是合适的：用于在LSA内部运行的安全包。例如，CredSSP可以根据目标远程桌面服务的SPN检查用户是否有凭证，并使用它读取用户的密码以自动进行身份验证。该服务将凭证存储在用户配置文件中的单独文件中，如[清单15-11](chapter15.xhtml#Lis15-11)所示。
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 15-11: Viewing the user’s credential files'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-11：查看用户的凭证文件
- en: Each file is encrypted using a per-user key through the Data Protection API
    (DPAPI), which I mentioned in [Chapter 10](chapter10.xhtml). This means we should
    be able to decrypt our own credential files using the DPAPI, through the .NET
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp> class. [Listing
    15-12](chapter15.xhtml#Lis15-12) enumerates the current user’s credential files
    and tries to decrypt each one using <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都通过数据保护API（DPAPI）使用每个用户的密钥进行加密，我在[第10章](chapter10.xhtml)中提到过这个。 这意味着我们应该能够使用DPAPI解密自己的凭证文件，通过.NET的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp>类。[清单15-12](chapter15.xhtml#Lis15-12)列举了当前用户的凭证文件，并尝试使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProtectedData</samp>解密每个文件。
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 15-12: Attempting to decrypt the user’s credential files'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-12：尝试解密用户的凭证文件
- en: 'Unfortunately, every file returns the same error: <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    data is invalid</samp>. While it is encrypted using the user’s DPAPI key, the
    LSA sets a special flag in the binary data that indicates that only code running
    in the LSA can decrypt it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每个文件都返回相同的错误：<samp class="SANS_TheSansMonoCd_W5Regular_11">数据无效</samp>。虽然它是使用用户的DPAPI密钥加密的，但LSA会在二进制数据中设置一个特殊的标志，表示只有在LSA中运行的代码才能解密它。
- en: 'There are many ways to decrypt the files successfully: for example, you could
    inject code into the LSA process and decrypt them from there, or you could derive
    the DPAPI key using the user’s password and the values from the SECURITY database
    registry key and decrypt them yourself. If you want to go down the latter route,
    I’d suggest checking out existing tooling such as Mimikatz, which already implements
    this functionality.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以成功解密文件：例如，你可以向LSA进程中注入代码并从那里解密它们，或者你可以使用用户的密码和来自SECURITY数据库注册表项的值推导出DPAPI密钥并自行解密。如果你想走后者的路，我建议你查看现有的工具，如Mimikatz，它已经实现了这个功能。
- en: Another approach to decrypting the files was introduced in Windows Vista. A
    special token privilege, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    allows a process to be considered trusted by the LSA when accessing select credential
    manager APIs. The most interesting of these select APIs is <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>,
    which will back up all of a user’s credentials into a file that can later be used
    to restore the credentials if needed. The backup also contains any protected password
    values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解密文件的另一种方法是在Windows Vista中引入的。一个特殊的令牌权限，<samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>，允许一个进程在访问某些凭证管理器API时被LSA视为可信。最有趣的这些选定API之一是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>，它会将所有用户的凭证备份到一个文件中，日后如果需要可以用来恢复凭证。备份还包含任何受保护的密码值。
- en: '[Listing 15-13](chapter15.xhtml#Lis15-13) shows how to back up a user’s credentials
    from the credential manager. You must run these commands as an administrator,
    as you need to access a privileged process to get a token with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    which is only granted to select process types.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单15-13](chapter15.xhtml#Lis15-13)展示了如何从凭证管理器备份用户的凭证。你必须以管理员身份运行这些命令，因为你需要访问一个特权进程以获得一个带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>的令牌，而这个令牌只授予特定类型的进程。'
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 15-13: Backing up a user’s credentials from the credential manager'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-13：从凭证管理器备份用户的凭证
- en: We first open the privileged Winlogon process and take a copy of its primary
    token ❶. Next, we get a copy of the user token we want to back up, which in this
    case is the current process token ❷. We can then impersonate the token we duplicated
    from Winlogon ❸, enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>,
    and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Backup-Win32Credential</samp>
    PowerShell command, which calls the underlying <samp class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp>
    API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打开特权的Winlogon进程并复制其主令牌 ❶。接下来，我们获取要备份的用户令牌的副本，在这种情况下是当前进程令牌 ❷。然后，我们可以模拟从Winlogon复制的令牌
    ❸，启用<samp class="SANS_TheSansMonoCd_W5Regular_11">SeTrustedCredmanAccessPrivilege</samp>，并调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Backup-Win32Credential</samp> PowerShell命令，该命令调用底层的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CredBackupCredentials</samp> API。
- en: The command returns a byte array containing the backup. The byte array is in
    a proprietary format, so we select all its Unicode strings and look for any that
    start with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Domain:</samp>
    ❹. We can see the stored remote desktop service credentials, including the name
    and password.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 命令返回一个包含备份的字节数组。该字节数组采用专有格式，因此我们选择所有Unicode字符串，并查找以字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">Domain:</samp>
    ❹开头的任何字符串。我们可以看到存储的远程桌面服务凭据，包括名称和密码。
- en: The credential manager is a better place than a user-accessible file to store
    credentials for use by LSA security packages such as NTLM, Kerberos, and CredSSP.
    However, that doesn’t mean you should use it. While disclosing the credentials
    takes some work, like any protection mechanism, it must at some point provide
    the unencrypted values, which an attacker can then extract.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 凭据管理器比用户可访问的文件更适合存储LSA安全包（如NTLM、Kerberos和CredSSP）使用的凭据。然而，这并不意味着你应该使用它。虽然披露凭据需要一定的工作，但像任何保护机制一样，它最终必须提供未加密的值，攻击者可以提取这些值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Request Attribute Flags</samp>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加请求属性标志</samp>
- en: When you create a client or server authentication context, you can specify a
    set of request attribute flags to change the behavior of the authentication. We’ve
    already seen support for signing and sealing, as well as delegation and mutual
    authentication, in the previous chapters. Still, it’s worth highlighting a few
    other flags that Kerberos and NTLM support.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建客户端或服务器认证上下文时，你可以指定一组请求属性标志，以改变认证的行为。我们在前面的章节中已经看到支持签名和封装、委派和互认证的功能。但值得强调的是，Kerberos和NTLM还支持一些其他的标志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Sessions</samp>
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">匿名会话</samp>
- en: What if you don’t know a user account on the target server? SSPI supports the
    concept of an *anonymous session*, also referred to as a *NULL session*. In an
    anonymous session, the authenticating user doesn’t need any credentials to generate
    the authentication tokens. The server will process the authentication as usual,
    but it will generate a token for the *ANONYMOUS LOGON* user. This allows a network
    protocol to always require authentication, simplifying the protocol, and to then
    enforce access based on the identity of the authenticated user. You can specify
    an anonymous session by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>
    request attribute flag when creating the client authentication context, as in
    [Listing 15-14](chapter15.xhtml#Lis15-14).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道目标服务器上的用户帐户怎么办？SSPI支持*匿名会话*的概念，也称为*NULL会话*。在匿名会话中，认证用户不需要任何凭据来生成认证令牌。服务器将像往常一样处理认证，但它将为*ANONYMOUS
    LOGON*用户生成令牌。这允许网络协议始终要求认证，简化协议，并根据认证用户的身份强制执行访问控制。你可以通过在创建客户端认证上下文时使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>请求属性标志来指定匿名会话，如[清单15-14](chapter15.xhtml#Lis15-14)所示。
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 15-14: Adding the NullSession request attribute flag'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-14：添加NullSession请求属性标志
- en: If you then perform local NTLM network authentication, you should notice a change
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM AUTHENTICATE</samp>
    token, shown in [Listing 15-15](chapter15.xhtml#Lis15-15).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你随后执行本地NTLM网络认证，你应该注意到在[清单15-15](chapter15.xhtml#Lis15-15)中显示的<samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp>令牌发生了变化。
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 15-15: The NTLM AUTHENTICATE token in an anonymous session'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-15：匿名会话中的NTLM AUTHENTICATE令牌
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> flag
    set ❶. Also, the LM response is a single zero byte, and the NT response is missing
    ❷. Querying the process’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object shows that it’s the anonymous user’s ❸.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp> 标志 ❶。此外，LM
    响应是一个零字节，而 NT 响应缺失 ❷。查询进程的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象显示它是匿名用户的 ❸。
- en: In Kerberos, the anonymous authentication token looks like that for NTLM, as
    shown in [Listing 15-16](chapter15.xhtml#Lis15-16).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kerberos 中，匿名身份验证令牌的格式与 NTLM 的类似，如 [Listing 15-16](chapter15.xhtml#Lis15-16)
    所示。
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 15-16: Sending an anonymous Kerberos AP-REQ message'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-16：发送匿名 Kerberos AP-REQ 消息
- en: The client sends an AP-REQ message with a ticket and authenticator containing
    empty values. If you see this message in a network capture, you can be certain
    the client is establishing an anonymous session.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送带有空值的票据和认证信息的 AP-REQ 消息。如果你在网络捕获中看到此消息，就可以确定客户端正在建立匿名会话。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identity Tokens</samp>
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">身份令牌</samp>
- en: When you perform a network authentication, the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object is an Impersonation-level token. If the server can pass the impersonation
    checks described in [Chapter 4](chapter4.xhtml), it can now access that user’s
    resources. What if we don’t want the server to be able to use our identity to
    access resources? In this case, we can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp>
    request attribute flag, as shown in [Listing 15-17](chapter15.xhtml#Lis15-17),
    to allow the server to receive only an Identification-level impersonation token,
    rather than a full Impersonation-level token.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行网络身份验证时，最终的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象是一个模拟级别的令牌。如果服务器能够通过
    [第 4 章](chapter4.xhtml) 中描述的模拟检查，它现在可以访问该用户的资源。如果我们不希望服务器使用我们的身份访问资源怎么办？在这种情况下，我们可以指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> 请求属性标志，如 [Listing
    15-17](chapter15.xhtml#Lis15-17) 中所示，允许服务器仅接收一个身份验证级别的模拟令牌，而不是完整的模拟级别令牌。
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 15-17: Adding the Identify request attribute flag'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-17：添加 Identify 请求属性标志
- en: This will prevent the server from using our identity to access resources, but
    still allow it to check who has authenticated. If we then rerun the authentication,
    we should notice a change in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp> token, as shown in [Listing 15-18](chapter15.xhtml#Lis15-18).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止服务器使用我们的身份访问资源，但仍然允许它检查谁已经进行了身份验证。如果我们随后重新进行身份验证，我们应该注意到 <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM
    AUTHENTICATE</samp> 令牌发生了变化，如 [Listing 15-18](chapter15.xhtml#Lis15-18) 中所示。
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 15-18: Examining the flags in the NTLM AUTHENTICATE token and displaying
    the created token’s impersonation level'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-18：检查 NTLM AUTHENTICATE 令牌中的标志，并显示创建的令牌的模拟级别
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    token’s flags now include an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp>
    flag ❶. This indicates to the server that the client wants to allow the use of
    an Identification-level token only. When we get the token from the server authentication
    context and format it, we can see that the impersonation level is indeed set to
    Identification ❷.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp>
    令牌的标志现在包括一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> 标志 ❶。这表示客户端希望仅允许使用身份验证级别令牌。
    当我们从服务器的身份验证上下文中获取令牌并进行格式化时，我们可以看到模拟级别确实设置为身份验证级别 ❷。
- en: As with <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp>, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> request attribute
    flag will work with Kerberos as well. [Listing 15-19](chapter15.xhtml#Lis15-19)
    shows that specifying this flag results in an <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp>
    flag being set in the AP-REQ authenticator’s GSSAPI <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    field.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">NullSession</samp> 类似，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Identify</samp> 请求属性标志也可以与 Kerberos 配合使用。[列表
    15-19](chapter15.xhtml#Lis15-19) 显示，指定此标志会导致在 AP-REQ 验证器的 GSSAPI <samp class="SANS_TheSansMonoCd_W5Regular_11">Checksum</samp>
    字段中设置一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> 标志。
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 15-19: The Identity flag in an AP-REQ GSSAPI checksum'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-19：AP-REQ GSSAPI 校验和中的身份标志
- en: <samp class="SANS_Futura_Std_Bold_B_11">Network Authentication with a Lowbox
    Token</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用低盒令牌的网络认证</samp>
- en: When a process is running with a lowbox token (described in [Chapter 4](chapter4.xhtml)),
    the LSA enforces restrictions on the use of network authentication. This is to
    make it harder for the sandbox application to abuse network authentication to
    get access to the user’s logon session credentials and, through them, access their
    resources.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程使用低盒令牌（在[第 4 章](chapter4.xhtml)中描述）运行时，LSA 强制对网络认证的使用进行限制。这是为了使沙箱应用程序更难滥用网络认证来获取用户的登录会话凭据，并通过这些凭据访问用户资源。
- en: 'If the lowbox process can create a client authentication context, however,
    it can generate authentication tokens in only the following three scenarios:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果低盒进程能够创建客户端认证上下文，它只能在以下三种情况生成认证令牌：
- en: Using logon session credentials with the Enterprise Authentication capability
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用企业认证功能的登录会话凭据
- en: Using logon session credentials to a known web proxy
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知 Web 代理的登录会话凭据
- en: Using explicit credentials, such as a username and password
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式凭据，例如用户名和密码
- en: Let’s discuss each of these scenarios.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这些场景。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with
    the Enterprise Authentication Capability</samp>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用企业认证功能进行认证</samp>
- en: The *enterprise authentication capability*, represented by the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp>,
    can be granted when a lowbox token is created. With this capability, the lowbox
    process can use the user’s logon session credentials to generate any supported
    network authentication tokens, such as those for NTLM or Kerberos, without restriction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*企业认证功能*，由 SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp>
    表示，在创建低盒令牌时可以授予。拥有此功能时，低盒进程可以使用用户的登录会话凭据生成任何支持的网络认证令牌，例如 NTLM 或 Kerberos 令牌，且不受限制。'
- en: The enterprise authentication capability is designed for enterprises to use
    in their internal applications. Outside of enterprises, the primary means of deploying
    lowbox processes is via the Microsoft App Store, which has restricted the use
    of this capability in the application submission guidelines. If you apply to the
    Microsoft store with an application that uses the enterprise authentication capability,
    it must pass an extra review and might be rejected. However, if you’re creating
    the lowbox token outside of a store application for testing purposes, there is
    no restriction, as demonstrated in [Listing 15-20](chapter15.xhtml#Lis15-20).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 企业认证功能旨在供企业在内部应用中使用。对于企业以外的用户，部署低盒进程的主要方式是通过 Microsoft 应用商店，该商店在应用提交指南中限制了此功能的使用。如果你提交的应用使用了企业认证功能，它必须通过额外的审查，可能会被拒绝。然而，如果你在商店应用之外创建低盒令牌进行测试，则没有任何限制，如[列表
    15-20](chapter15.xhtml#Lis15-20)中所示。
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 15-20: Testing the lowbox enterprise authentication capability'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-20：测试低盒企业认证功能
- en: We first create a lowbox <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object without the capability ❶. When we create the client authentication context
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>,
    we get an error ❷. This error comes from the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    API, which PowerShell calls behind the scenes. Next, we create the lowbox token
    with the capability ❸. This time, we can successfully create a client authentication
    context and format the client authentication token ❹.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建没有功能的低盒 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象
    ❶。当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>
    创建客户端身份验证上下文时，我们会遇到错误 ❷。这个错误来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>
    API，这是PowerShell在后台调用的。接下来，我们创建具有功能的低盒令牌 ❸。这一次，我们可以成功创建客户端身份验证上下文并格式化客户端身份验证令牌
    ❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication to
    a Known Web Proxy</samp>
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对已知Web代理的身份验证</samp>
- en: The lowbox process can generate tokens for authentication to web proxies, which
    commonly require that a domain user can access the internet. To support this use
    case, you can perform network authentication with the user’s logon session credentials
    if the target name is set to the address of an approved proxy server.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 低盒进程可以为Web代理生成身份验证令牌，这通常要求域用户可以访问互联网。为了支持此用例，如果目标名称设置为已批准代理服务器的地址，则可以使用用户的登录会话凭据执行网络身份验证。
- en: For example, say the target name is <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/proxy.mineral.local</samp>.
    The system administrator must configure the proxy address either through the group
    policy or by using a *Proxy Auto-Configuration (PAC)* script, which makes sure
    that a web request with an arbitrary proxy configuration won’t pass the LSA’s
    checks. [Listing 15-21](chapter15.xhtml#Lis15-21) demonstrates the use of a web
    proxy target name to allow network authentication. You must have configured a
    system web proxy for this script to work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设目标名称是 <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/proxy.mineral.local</samp>。系统管理员必须通过组策略或使用*代理自动配置（PAC）*脚本来配置代理地址，这可以确保具有任意代理配置的Web请求不会通过LSA的检查。[列表
    15-21](chapter15.xhtml#Lis15-21)展示了如何使用Web代理目标名称来允许网络身份验证。必须已配置系统Web代理才能使此脚本正常工作。
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 15-21: Testing lowbox web proxy authentication'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-21：测试低盒Web代理身份验证
- en: First, we query for the proxy setting using the <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp>
    .NET class ❶. We then build the target SPN with an HTTP service class and the
    proxy address ❷.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WebClient</samp> .NET
    类 ❶ 查询代理设置。然后，我们构建目标SPN，使用HTTP服务类和代理地址 ❷。
- en: Next, we create the lowbox token ❸. Notice that we haven’t specified the enterprise
    authentication capability. We create the client authentication context and use
    the target SPN ❹. The initial authentication succeeds, and we can perform the
    client authentication to the target proxy.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建低盒令牌 ❸。请注意，我们没有指定企业身份验证功能。我们创建客户端身份验证上下文并使用目标SPN ❹。初始身份验证成功，然后我们可以执行客户端对目标代理的身份验证。
- en: This proxy authentication is considered secure because the service should check
    the target name before permitting the authentication. If the lowbox process generates
    the authentication for the proxy SPN but then sends it to an SMB server, the authentication
    process should fail. For Kerberos authentication, the SPN selects the key to use
    for the ticket, so an incorrect SPN should make the ticket fail to decrypt if
    sent to the wrong service.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代理身份验证被认为是安全的，因为服务应在允许身份验证之前检查目标名称。如果低盒进程为代理SPN生成身份验证，但随后将其发送到SMB服务器，则身份验证过程应失败。对于Kerberos身份验证，SPN选择用于票证的密钥，因此如果将错误的SPN发送到错误的服务，票证应无法解密。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication with
    Explicit Credentials</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用显式凭据进行身份验证</samp>
- en: The final option, shown in [Listing 15-22](chapter15.xhtml#Lis15-22), is to
    specify explicit credentials when creating the credentials handle provided to
    the client authentication context.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种选项，如[列表 15-22](chapter15.xhtml#Lis15-22)所示，是在创建提供给客户端身份验证上下文的凭据句柄时指定显式凭据。
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 15-22: Initializing the client authentication context with explicit
    credentials'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-22：使用显式凭据初始化客户端身份验证上下文
- en: To initialize the client authentication context, you still need to provide a
    target SPN ❶. However, you don’t need to specify a known proxy, as the target
    can be any service or host. In this case, we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">CIFS/
    localhost</samp> SPN.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: When in a lowbox token sandbox, you can act as a server for network authentication,
    as it’s possible to get a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for a different user. However, unless the token’s user exactly matches
    the caller’s user and lowbox package SID, the returned token is set to the Identification
    level, which prevents it from being abused to elevate privileges. The restriction
    on the impersonation level applies even if the lowbox token has the enterprise
    authentication capability, as this grants access to the client authentication
    context only.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Authentication Audit Event Log</samp>
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s wrap up our discussion of authentication with an overview of the auditing
    data generated during interactive and network authentication. When you’re monitoring
    an enterprise network, you might want to know which users have attempted to authenticate
    to the Windows system. By analyzing the audit log, you can identify their successful
    and unsuccessful authentication attempts to a machine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the authentication audit log records in the same security event
    log we inspected in [Chapter 9](chapter9.xhtml) when discussing object audit events.
    We can use a similar technique of filtering the log by event ID to get the events
    we’re interested in. Here are some event IDs for important authentication events:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4624  </samp>An account logged
    on successfully.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4625  </samp>An account failed
    to log on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4634</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>An
    account logged off.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the information these events provide. [Listing 15-23](chapter15.xhtml#Lis15-23)
    starts by querying the security event log for the successful logon event, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4624</samp>. Run this command as an administrator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 15-23: A log record for a successful interactive authentication event'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows an example entry for a successful authentication event. On
    a frequently used system there are likely to be many such entries, so pick just
    one to inspect.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The event records contain a lot of information, some of which might not be populated
    for certain logon types. Each entry starts with information about the user account
    that has made the authentication request. For an interactive authentication, you’ll
    likely find this to be a privileged account, such as the *SYSTEM* computer account.
    Next comes information about the logon, including the logon type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    indicates interactive. Some other logon types are network (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>),
    batch (<samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>), service (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and remote interactive (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp>). This section also indicates
    whether Restricted Admin mode was used for the authentication and whether the
    session the event represents is elevated. It’s followed by an indication of the
    token’s impersonation level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section contains the details of the logon session created for
    the successful authentication, including the user’s SID, name, and domain. As
    this is an elevated interactive authentication, we see two logon IDs: one for
    the session itself and one for the linked, non-elevated logon session created
    for UAC.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Next come the details of the process making the authentication request. In this
    example, it’s the process that called <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>.
    The final two sections contain network authentication information and additional
    details that didn’t fit into other categories. Part of the detailed authentication
    information is the security package used for the authentication. In this case,
    Negotiate was used, so it will have chosen the best authentication protocol for
    the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see the same type of event record generated regardless of whether authentication
    occurred through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    or through network authentication. For example, if the event is for an NTLM network
    authentication, you should see something like [Listing 15-24](chapter15.xhtml#Lis15-24)
    in the detailed authentication information section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 15-24: The detailed information for a successful NTLM network authentication'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at a failed authentication event. [Listing 15-25](chapter15.xhtml#Lis15-25)
    queries for events with an ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">4625</samp>,
    as an administrator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 15-25: A failed authentication event log record'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the output, I’ve highlighted just one record. It has many of the same sections
    as for a successful authentication, so I’ve removed anything that appears in both
    types of record.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The first of the sections shown here contains details on the user account that
    failed to authenticate. The SID entry isn’t guaranteed to be valid; for example,
    in this case, the SID does not represent the *alice* user. Next, we get more details
    about the failure, starting with a text version of the error, followed by the
    status, which here is an NT status code of <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>.
    The sub-status code provides more detail; in this case, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>,
    which indicates that the user did not provide a valid password. Other sub-status
    codes you might encounter include <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>,
    if the user doesn’t exist, and <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCOUNT_DISABLED</samp>,
    if the user’s account has been disabled.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的第一个部分包含了无法进行身份验证的用户帐户的详细信息。SID 条目并不保证有效；例如，在这个案例中，SID 并不代表 *alice* 用户。接下来，我们会看到关于失败的更多细节，首先是错误的文本版本，然后是状态代码，这里是一个
    NT 状态码 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>。子状态代码提供了更多细节；在这个案例中，它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>，表示用户没有提供有效的密码。你可能遇到的其他子状态代码包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>，如果用户不存在，和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCOUNT_DISABLED</samp>，如果用户的帐户已被禁用。
- en: Finally, we’ll look at a log-off event, generated when a logon session is deleted.
    This typically occurs when no <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    objects that reference the logon session remain. Run the command in [Listing 15-26](chapter15.xhtml#Lis15-26)
    as an administrator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看一个注销事件，这是在删除登录会话时生成的。通常，当没有任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象引用该登录会话时，就会发生这种情况。以管理员身份运行 [Listing 15-26](chapter15.xhtml#Lis15-26) 中的命令。
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 15-26: A log-off authentication event log record'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-26：注销身份验证事件日志记录
- en: This event log record is much simpler than those for successful or failed authentication.
    It contains just the subject information, including the username and domain. To
    match a successful authentication event to the corresponding log-off event, you
    can compare the logon IDs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件日志记录比成功或失败的身份验证要简单得多。它只包含主体信息，包括用户名和域名。为了将成功的身份验证事件与相应的注销事件匹配，你可以比较登录 ID。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实际示例</samp>
- en: Let’s finish with some worked examples using the commands you’ve learned about
    in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过本章所学的命令来进行一些实际的例子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifying the Reason
    for an Authentication Failure</samp>
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定身份验证失败的原因</samp>
- en: 'I noted in the previous section that you’ll see two status codes in the event
    log when an authentication process fails: there’s the main status, typically <samp
    class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>, and a sub-status,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>.
    Unfortunately, the event log automatically converts only the main status code
    to a string, then typically generates a generic “The username or password is incorrect”
    message that isn’t very helpful in diagnosing authentication failures. Let’s write
    a quick script to analyze the event log records and convert the sub-status codes
    to messages automatically.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我提到，当身份验证过程失败时，你会在事件日志中看到两个状态代码：一个是主要状态，通常是 <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_LOGON_FAILURE</samp>，另一个是子状态，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>。不幸的是，事件日志只会自动将主要状态码转换为字符串，然后通常生成一个通用的“用户名或密码不正确”的消息，这对于诊断身份验证失败并没有太大帮助。让我们写一个简单的脚本来分析事件日志记录，并自动将子状态代码转换为消息。
- en: One immediate problem we must solve is how to get the sub-status code from the
    event log record. You could try to manually parse it from the text message. However,
    you’ll see different messages for different languages, and you might not be able
    to rely on the presence of a text string such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>.
    The event log record, however, does contain all its important information as separate
    properties, and you can query for these using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp>
    property on the event log record object. [Listing 15-27](chapter15.xhtml#Lis15-27)
    shows the output generated by such a query.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 15-27: Displaying an event log’s record properties'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the list of properties contains only the values, with no indication
    of the properties’ names. We want the property with the name <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>,
    which might always be at the same index in the properties list, but there is no
    guarantee that will always be the case. So, to get this information we must manually
    inspect the XML that stores the event log’s properties. We can request this by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToXml</samp> method on
    the record. [Listing 15-28](chapter15.xhtml#Lis15-28) shows how to extract named
    properties from an event log record.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 15-28: Extracting the named event log record properties'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-EventLogProperty</samp>
    function, which will convert each record to a new object. We need to extract an
    event log record’s XML and then parse it into an XML document ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EventData</samp>
    XML element stores the properties, so we use the object model PowerShell provides
    to extract each element and build a hash table from the property name and body
    text ❷. We then convert the hash table to a custom PowerShell object to make it
    easier to query.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: When inspecting the new object’s properties, we find that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>
    property is now easily accessible ❸. There are some limitations with our approach;
    for example, we haven’t converted the failure reason from a resource identifier
    to a string ❹. However, we don’t need the failure reason, as we can get the message
    from the status code if we want it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s expand our code to extract the sub-status for authentication failures
    ([Listing 15-29](chapter15.xhtml#Lis15-29)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 15-29: Parsing authentication failure properties and converting their
    sub-status codes'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function that converts the record properties into a simpler
    authentication failure object ❶. We pull out only the timestamp, the username,
    and the domain name, and then convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubStatus</samp>
    property to its NT status name ❷.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We then perform two failed authentications to generate some entries in the event
    log ❸. We filter the log to return only authentication failure records, then convert
    the records in the pipeline ❹. In the generated output, we can see two entries.
    The first has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_WRONG_PASSWORD</samp>
    as the sub-status, indicating that the user was valid but the password was not.
    The second has <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_NO_SUCH_USER</samp>,
    which indicates that the user doesn’t exist.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Secure Channel
    to Extract a Server’s TLS Certificate</samp>
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s walk through a simple example of how to use the secure channel authentication
    protocol. We’ll make a TCP connection to a secure web server and extract its server
    certificate, then use it to retrieve details about the organization that might
    own the server and whether the certificate is valid.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are likely much better ways of getting the server’s certificate
    than the approach taken in this example. For example, most web browsers will allow
    you to display and export the certificate by browsing to the server. However,
    that wouldn’t help you learn much about how secure channel works. To get started,
    copy the contents of [Listing 15-30](chapter15.xhtml#Lis15-30) into the script
    file *get_server_cert.ps1*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 15-30: A script for reading a TLS server certificate'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We first define a couple of parameters, for the hostname of the server and the
    optional TCP port ❶. HTTPS uses the well-known port 443; however, TLS is not restricted
    to only that port, so you can change it if you want to target a different service.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We then define a couple of functions. The first one, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>,
    converts a TCP client object to a <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryReader</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BinaryWriter</samp> ❷. The TLS
    protocol has a relatively simple binary record structure, so using these classes
    makes it easier to parse the network traffic.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The second function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-TlsRecordToken</samp>,
    reads a single TLS record from the server and returns it as an authentication
    token ❸. We first read the 5-byte header from the record and extract the data’s
    length, then we read the data from the stream. Because TCP is a streaming protocol,
    there is no guarantee that all the required data will be returned in a single
    read, so you’ll have to perform the read in a loop until you’ve received everything
    you need ❹.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We now enter the body of the script. We start by making a TCP connection to
    the hostname and TCP port provided as arguments to the script ❺. We then convert
    the socket to the reader and writer objects. Next, we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schannel</samp>
    credentials and client context ❻, setting the client context target to the hostname
    and enabling manual credential validation, as we don’t really care if the server
    certificate is invalid for the purposes of this example.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We can now loop until the client context has completed authentication ❼. If
    there is a token to send to the server, we convert it to bytes and write it to
    the TCP socket ❽. As we saw earlier, the TLS client and server can generate more
    than one TLS record, which the context must handle before generating a new token.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve sent the client authentication token, we can read the next TLS record
    from the server and update the client ❾. This loop will carry on until either
    the authentication completes successfully or an exception stops the script. Finally,
    we can return the server’s certificate from the script ❿.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-31](chapter15.xhtml#Lis15-31) shows how to use the script we wrote.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 15-31: Getting the server certificate for <samp class="SANS_Futura_Std_Book_11">www.microsoft.com</samp>
    and exporting it to a file'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: You call the script by providing the hostname of the server. Optionally, you
    could specify the TCP port, but in this case, we use port 443, better known as
    HTTPS, which is the script’s default. The returned certificate is an object you
    can inspect using PowerShell. You can also export the certificate to a file using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Export-Certificate</samp> command.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter began by describing security buffers and how they’re used to pass
    information back and forth with the SSPI APIs during network authentication and
    the encryption and signing processes. It then provided an overview of the Negotiate
    authentication protocol, which allows network authentication to take place when
    both parties aren’t sure ahead of time what authentication protocol to use.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at some less commonly used security packages, secure channel
    and CredSSP. These have specific niches but also more complex usage compared to
    NTLM or Kerberos. We also discussed anonymous and identity network authentication
    in NTLM and Kerberos and covered network authentication inside a lowbox token
    sandbox (and I described how I circumvented this authentication multiple times).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The chapter finished with an overview of the security audit events generated
    when a user authenticates. You learned about the different event types used to
    describe whether a user’s authentication succeeded or failed, and saw how to use
    these to figure out which users have attempted to authenticate to a workstation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Final Thoughts</samp>
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we wrap up this final chapter, I hope you’ll apply the information you’ve
    learned here about the internals of Windows security to your own endeavors. I’ve
    covered many areas in detail, ranging from the Security Reference Monitor and
    tokens to access checking and authentication, providing examples to demonstrate
    important topics.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: However, I wasn’t able to provide scripts to demonstrate every permutation of
    the features we discussed. For that reason, I recommend checking the help feature
    for the various commands provided with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module and experimenting with their use. If you perform tests against a Windows
    virtual machine, there is little you can damage. (In fact, if your system develops
    a blue screen of death while you’re experimenting, it might be a good idea to
    dig into why, as you might have found a security vulnerability.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this chapter are some additional reference materials: [Appendix A](appendix-A.xhtml)
    contains a walkthrough for setting up a domain network for testing, and [Appendix
    B](appendix-B.xhtml) contains a list of SDDL aliases.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
