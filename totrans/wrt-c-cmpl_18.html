<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_422" aria-label="422"/>&#13;
<figure class="co-img"><img id="fig-pg422" class="img40" src="../images/pg422.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-40.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_423" aria-label="423"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS AND STRINGS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll implement three new integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>. These are the <i>character types</i>, which have a size of 1 byte. Because your compiler already supports signed and unsigned integers in multiple sizes, you can add these new types with minimal effort. You’ll also add support for string literals and character constants. String literals play a weird role in C: sometimes they behave like compound initializers, and at other times they represent constant <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays. To support the latter case, you’ll store constant strings alongside variables in the symbol table, and you’ll introduce static constants as a top-level construct in TACKY.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_424" aria-label="424"/>At the end of the chapter, we’ll compile “Hello, World!” In <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, we compiled a version of this program that printed one character at a time. This time, we’ll compile a more reasonable version that prints out an entire string. Before we get started, I’ll give you a bit of background information: I’ll first touch on a few notable differences between the character types and the other integers, then describe how strings work in C and assembly.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-137"/><samp class="SANS_Futura_Std_Bold_B_11">Character Traits</samp></h3>&#13;
<p class="TNI">The most surprising thing about the character types is that there are three of them. There’s no distinction between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> or between <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>, but the specifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> refer to two distinct types. Whether “plain” <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is signed or unsigned is implementation-defined. We’ll follow the System V ABI, which specifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is signed.</p>&#13;
<p class="TX">Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> will behave identically in our implementation, the fact that they’re different types has real consequences. For instance, <a href="chapter16.xhtml#list16-1">Listing 16-1</a> is illegal because it declares the same global variable as both a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>.</p>&#13;
<a id="list16-1"/>&#13;
<pre><code>char c;&#13;
signed char c;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Conflicting file scope variable declarations with different character types</samp></p>&#13;
<p class="TX">Declaring a global variable as both an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, on the other hand, is perfectly legal, since both declarations specify the same type.</p>&#13;
<p class="TX">The character types also follow slightly different type conversion rules than the other integer types. When a character is used in a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operation; a bitwise binary operation; or the usual arithmetic conversions, it’s first converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. These conversions are called the <i>integer promotions</i>. (If <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> can’t fit every value of a particular character type, the character is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> instead. In our implementation, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> can hold every value of every character type, so this is a moot point. Of course, we can also ignore the typing rules for operations we haven’t implemented, like unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and the bitwise binary operations; I’m mentioning them here only for the sake of completeness.)</p>&#13;
<p class="TX">There’s one more noteworthy difference between characters and other integers: in C17, there are no scalar constants of character type. Tokens like <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> all have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, despite being called “character constants.” There are constants with <i>wide character types</i> like <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>, which are intended to represent multibyte characters, but we won’t implement them.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>C23 introduces u8 character constants with type unsigned char. These represent 1-byte UTF-8 characters.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_425" aria-label="425"/>&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-138"/><samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp></h3>&#13;
<p class="TNI">Throughout this chapter, I’ll distinguish between string literals and strings. A <i>string literal</i> is an expression that appears in the source code, like <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>. A <i>string</i> is an object that lives in memory—specifically, a null-terminated <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array. Some strings can’t be modified at runtime; I’ll call these <i>constant strings</i>, although this isn’t a standard term.</p>&#13;
<p class="TX">You can use a string literal in two distinct ways. First, it can initialize an array of any character type:</p>&#13;
<pre><code>signed char array[4] = "abc";</code></pre>&#13;
<p class="TX">We’ll include a terminating null byte if there’s space and omit it if there isn’t. This coincides with our usual rules for array initialization: if the initializer is shorter than the target object, we pad out the remainder with zeros. Therefore, the previous declaration is equivalent to:</p>&#13;
<pre><code>signed char array[4] = {'a', 'b', 'c', 0};</code></pre>&#13;
<p class="TX">In <a href="chapter16.xhtml#list16-2">Listing 16-2</a>, on the other hand, we leave out the null byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp> because the array isn’t large enough to include it. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">array2</samp> have identical contents.</p>&#13;
<a id="list16-2"/>&#13;
<pre><code>char array1[3] = "abc";&#13;
char array2[3] = {'a', 'b', 'c'};</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: Using a string literal as an array initializer without the null byte</samp></p>&#13;
<p class="TX">When a string literal appears anywhere other than as an array initializer, it designates a constant string. In this context, string literals act a lot like other expressions of array type. They decay to pointers like other array expressions, so you can subscript them or assign them to <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> objects. The following declaration initializes the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str_ptr</samp> with the address of the first character in the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>:</p>&#13;
<pre><code>char *str_ptr = "abc";</code></pre>&#13;
<p class="TX">String literals are also lvalues, so they support the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator. Here, we use this operator to take the address of the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>, then assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">array_ptr</samp>:</p>&#13;
<pre><code>char (*array_ptr)[4] = &amp;"abc";</code></pre>&#13;
<p class="TX">The only difference from the previous example is that the string literal doesn’t undergo array decay. We end up with a pointer to the whole string, with type <samp class="SANS_TheSansMonoCd_W5Regular_11">char (*)[4]</samp>, instead of a pointer to its first element, with type <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>. In both examples, we treat <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp> like any other expression of array type.</p>&#13;
<p class="TX">Unlike other arrays, constant strings are, well, constant. Attempting to modify them, as in <a href="chapter16.xhtml#list16-3">Listing 16-3</a>, produces undefined behavior.</p>&#13;
<a id="list16-3"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_426" aria-label="426"/>char *ptr = "abc";&#13;
ptr[0] = 'x';</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Illegally modifying a constant string</samp></p>&#13;
<p class="TX">Although this code compiles, it will probably throw a runtime error, because most C implementations—including ours—store constant strings in read-only memory. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier, which we won’t implement, informs the compiler that an object cannot be modified. If <a href="chapter16.xhtml#list16-3">Listing 16-3</a> were part of a real C program, it would be a good idea to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.)</p>&#13;
<p class="TX">Let’s look at one more example, shown in <a href="chapter16.xhtml#list16-4">Listing 16-4</a>, to clarify the difference between string literals that designate constant strings and string literals that initialize arrays.</p>&#13;
<a id="list16-4"/>&#13;
<pre><code>char arr[3] = "abc";&#13;
arr[0] = 'x';</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-4: Legally modifying an array initialized from a string literal</samp></p>&#13;
<p class="TX">Unlike <a href="chapter16.xhtml#list16-3">Listing 16-3</a>, this code is perfectly legal. In <a href="chapter16.xhtml#list16-3">Listing 16-3</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> points to the start of the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>. In <a href="chapter16.xhtml#list16-4">Listing 16-4</a>, on the other hand, we use each character of the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp> to initialize one element of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, which is an ordinary, non-constant <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array.</p>&#13;
<p class="TX">Both cases are easier to understand once we see how they translate to assembly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1"><span id="sec3"/><span id="h1-139"/><samp class="SANS_Futura_Std_Bold_B_11">Working with Strings in Assembly</samp></h3>&#13;
<p class="TNI">We’ll use two different assembly directives to initialize strings in assembly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives both tell the assembler to write an ASCII string to the object file, much like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> tells it to write a quadword. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> will include a terminating null byte and <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> won’t. The three declarations</p>&#13;
<pre><code>static char null_terminated[4] = "abc";&#13;
static char not_null_terminated[3] = "abc";&#13;
static char extra_padding[5] = "abc";</code></pre>&#13;
<p class="BodyContinued">correspond to the assembly in <a href="chapter16.xhtml#list16-5">Listing 16-5</a>.</p>&#13;
<a id="list16-5"/>&#13;
<pre><code>    .data&#13;
null_terminated:&#13;
    .asciz "abc"&#13;
not_null_terminated:&#13;
    .ascii "abc"&#13;
extra_padding:&#13;
    .asciz "abc"&#13;
    .zero 1</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-5: Initializing three static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arrays from string literals in assembly</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_427" aria-label="427"/>Because <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp> is long enough to accommodate a null byte, we initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directive. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">not_null _terminated</samp> so we don’t go past the bounds of the array. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">extra_padding</samp> needs two zero bytes to reach the correct length, we write a null-terminated string, then write an extra zero byte with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> directive. Note that none of these variables needs an <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive. The character types are all 1-byte aligned, so arrays of characters are too. (Array variables containing 16 or more characters are the exception; they’re 16-byte aligned, like all array variables that are 16 bytes or larger.)</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives initialize objects with static storage duration. Next, let’s consider <a href="chapter16.xhtml#list16-6">Listing 16-6</a>, which initializes a non-static array.</p>&#13;
<a id="list16-6"/>&#13;
<pre><code>int main(void) {&#13;
    char letters[6] = "abcde";&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-6: Using a string literal to initialize a non-static array</samp></p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-7">Listing 16-7</a> illustrates one way to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> in assembly, by copying <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcde"</samp> onto the stack one byte at a time.</p>&#13;
<a id="list16-7"/>&#13;
<pre><code>movb    $97,  -8(%rbp)&#13;
movb    $98,  -7(%rbp)&#13;
movb    $99,  -6(%rbp)&#13;
movb    $100, -5(%rbp)&#13;
movb    $101, -4(%rbp)&#13;
movb    $0,   -3(%rbp)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-7: Initializing a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp></p>&#13;
<p class="TX">The characters <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp> have ASCII values <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, respectively. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> starts at stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>, the instructions in <a href="chapter16.xhtml#list16-7">Listing 16-7</a> copy each character to the appropriate location in the array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> suffix in each <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction indicates that it operates on a single byte.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-8">Listing 16-8</a> demonstrates a more efficient approach. We initialize the first 4 bytes of this string with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instructions to initialize the remaining 2 bytes.</p>&#13;
<a id="list16-8"/>&#13;
<pre><code>movl    $1684234849, -8(%rbp)&#13;
movb    $101, -4(%rbp)&#13;
movb    $0,   -3(%rbp)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-8: A more efficient way to initialize a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp></p>&#13;
<p class="TX">We get <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> when we interpret the first 4 bytes of our string as an integer. (I’ll discuss how we get this integer in more detail later in the chapter.) This listing has the same effect as <a href="chapter16.xhtml#list16-7">Listing 16-7</a>, but it saves us a few instructions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_428" aria-label="428"/>Next, let’s look at constant strings. We write these to read-only sections of the object file, just like floating-point constants. On Linux, we store constant strings in <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>; on macOS, we store them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp> section. Consider the code fragment in <a href="chapter16.xhtml#list16-9">Listing 16-9</a>, which returns a pointer to the start of a constant string.</p>&#13;
<a id="list16-9"/>&#13;
<pre><code>return "A profound statement.";</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-9: Returning a pointer to the start of a string</samp></p>&#13;
<p class="TX">We’ll generate a unique label for this string, then define it in the appropriate section. <a href="chapter16.xhtml#list16-10">Listing 16-10</a> gives the resulting assembly.</p>&#13;
<a id="list16-10"/>&#13;
<pre><code>    .section .rodata&#13;
.Lstring.0:&#13;
    .asciz "A profound statement."</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-10: Defining a constant string in assembly</samp></p>&#13;
<p class="TX">Constant strings are always null-terminated, since they don’t need to fit into any particular array dimensions. Once we’ve defined a constant string, we can access it with RIP-relative addressing, like any other static object. In this particular example, we want to return the string’s address, so we’ll load it into RAX with this instruction:</p>&#13;
<pre><code>leaq    .Lstring.0(%rip), %rax</code></pre>&#13;
<p class="TX">Finally, let’s see how to initialize a static pointer with a string literal, like in <a href="chapter16.xhtml#list16-11">Listing 16-11</a>.</p>&#13;
<a id="list16-11"/>&#13;
<pre><code>static char *ptr = "A profound statement.";</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-11: Initializing a static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char *</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">from a string literal</samp></p>&#13;
<p class="TX">We’ll define the string the same way as in <a href="chapter16.xhtml#list16-10">Listing 16-10</a>. However, we can’t load it into <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> with an <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is static, it must be initialized before the program starts. Luckily, the <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive accepts labels as well as constants. <a href="chapter16.xhtml#list16-12">Listing 16-12</a> illustrates how to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> with this directive.</p>&#13;
<a id="list16-12"/>&#13;
<pre><code>    .data&#13;
    .align 8&#13;
ptr:&#13;
    .quad .Lstring.0</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-12: Initializing a static variable with the address of a static constant</samp></p>&#13;
<p class="TX">The directive <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp> tells the assembler and linker to write the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">.Lstring.0</samp>.</p>&#13;
<p class="TX">As a side note, it’s possible to initialize any static pointer this way, not just pointers to strings. While our implementation doesn’t accept expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;x</samp> as static initializers, a more complete compiler might translate</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_429" aria-label="429"/>static int x = 10;&#13;
static int *ptr = &amp;x;</code></pre>&#13;
<p class="BodyContinued">into:</p>&#13;
<pre><code>    .data&#13;
    .align 4&#13;
x:&#13;
    .long 10&#13;
    .align 8&#13;
ptr:&#13;
    .quad x</code></pre>&#13;
<p class="TX">At this point, you know enough about how to use strings in C and assembly to get started. The first step is to extend the lexer to recognize string literals and character constants.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1"><span id="sec4"/><span id="h1-140"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add three new tokens in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> A keyword, used to specify character types</p>&#13;
<p class="RunInPara"><b>Character constants</b> Individual characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp></p>&#13;
<p class="RunInParaL"><b>String literals</b> Sequences of characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, World!"</samp></p>&#13;
<p class="TX">A character constant consists of one character (like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>) or escape sequence (like <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>) wrapped in single quotes. Section 6.4.4.4 of the C standard defines a set of escape sequences to represent special characters. <a href="chapter16.xhtml#tab16-1">Table 16-1</a> lists these escape sequences and their ASCII codes.</p>&#13;
<p class="TT" id="tab16-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Escape Sequences for Special Characters</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">ASCII code</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Single quote</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">39</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Double quote</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">34</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Question mark</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Backslash</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Audible alert</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Backspace</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Form feed</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">New line</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Carriage return</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Horizontal tab</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Vertical tab</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_430" aria-label="430"/>The new line, single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>), and backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) characters can’t appear on their own as character constants and must be escaped. Any other character can be used directly as a character constant as long as it’s in the <i>source character set</i>, the complete set of characters that can appear in a source file.</p>&#13;
<p class="TX">The source character set is implementation-defined, but it has to include at least the <i>basic source character set</i>, which is specified in section 5.2.1 of the C standard. In our implementation, the source character set includes all the printable ASCII characters, plus the required control characters: the new line, horizontal tab, vertical tab, and form feed. You don’t need to explicitly reject characters outside of this set; you can simply assume that they never show up in source files.</p>&#13;
<p class="TX">Some of the characters in <a href="chapter16.xhtml#tab16-1">Table 16-1</a>, like the audible alert (<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>) and backspace (<samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>), aren’t in our source character set, so they can be represented only by escape characters. Other characters, including the double quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>), question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>), form feed, and horizontal and vertical tabs, are in the source character set; they can be escaped in character constants, but they don’t have to be. For example, the character constants <samp class="SANS_TheSansMonoCd_W5Regular_11">'?'</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">'\?'</samp> are equivalent; they both represent the question mark character. The new line, single quote, and backslash are all in the source character set but still need to be escaped.</p>&#13;
<p class="TX">We can recognize character constants with the truly egregious regular expression in <a href="chapter16.xhtml#list16-13">Listing 16-13</a>.</p>&#13;
<a id="list16-13"/>&#13;
<pre><code>'([^'\\\n]|\\['"?\\abfnrtv])'</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-13: The regular expression to recognize a character constant</samp></p>&#13;
<p class="TX">Let’s break this down. The first alternative in the parenthesized expression, the character class <samp class="SANS_TheSansMonoCd_W5Regular_11">[^'\\\n]</samp>, matches any single character except for a single quote, backslash, or new line. We have to escape the backslash, because it’s a control character in PCRE regexes as well as in C string literals. Similarly, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> in this regex to match a literal new line character. The second alternative, <samp class="SANS_TheSansMonoCd_W5Regular_11">\\['"?\\abfnrtv]</samp>, matches an escape sequence. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> matches a single backslash, and the character class that follows includes every character that can follow the backslash in an escape sequence. The whole thing must start and end with single quotes.</p>&#13;
<p class="TX">A string literal consists of a possibly empty sequence of characters and escape sequences, wrapped in double quotes. A single quote can appear on its own in a string literal, but a double quote must be escaped. <a href="chapter16.xhtml#list16-14">Listing 16-14</a> shows the regular expression to recognize a string literal.</p>&#13;
<a id="list16-14"/>&#13;
<pre><code>"([^"\\\n]|\\['"\\?abfnrtv])*"</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-14: The regular expression to recognize a string literal</samp></p>&#13;
<p class="TX">Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">[^"\\\n]</samp> matches any single character except a double quote, backslash, or new line. Like in <a href="chapter16.xhtml#list16-13">Listing 16-13</a>, the second alternative matches every escape sequence. We apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> quantifier to the whole parenthesized <span role="doc-pagebreak" epub:type="pagebreak" id="pg_431" aria-label="431"/>expression because it can repeat zero or more times, and we delimit it all with double quotes.</p>&#13;
<p class="TX">After lexing a string literal or character token, you need to unescape it. In other words, you need to convert every escape sequence in that token to the corresponding ASCII character. You can do that either now or in the parser.</p>&#13;
<p class="TX">The standard defines a few other types of string literals and character constants that we won’t implement. In particular, we won’t support hexadecimal escape sequences like <samp class="SANS_TheSansMonoCd_W5Regular_11">\xff</samp>, octal escape sequences like <samp class="SANS_TheSansMonoCd_W5Regular_11">\012</samp>, or multicharacter constants like <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>. We also won’t support any of the types or constants used for non-ASCII encodings, like wide character types, wide string literals, or UTF-8 string literals.</p>&#13;
<aside class="box" aria-label="box-48"><p class="BoxTitle" id="box-48"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your lexer should reject every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/invalid_lex</samp><samp class="SANS_Futura_Std_Book_11">. These tests include invalid escape sequences, unescaped special characters, and unterminated character constants and string literals. The lexer should successfully process all the other test cases for this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1"><span id="sec5"/><span id="h1-141"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">We’ll extend the AST definition in three ways. First, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> types. Second, we’ll add a new kind of expression to represent string literals. Third, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> AST node to represent constants with character types:</p>&#13;
<pre><code>const = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double) | <b>ConstChar(int) | ConstUChar(int)</b></code></pre>&#13;
<p class="TX">These new constant constructors are a little unusual because they don’t correspond to constant literals that actually appear in C programs. Character constants like <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, so the parser will convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> nodes; it won’t use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> constructors at all. But we’ll need these constructors later, when we pad out partially initialized character arrays during type checking and when we initialize character arrays in TACKY.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-15">Listing 16-15</a> gives the complete AST definition, with this chapter’s changes bolded.</p>&#13;
<a id="list16-15"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_432" aria-label="432"/>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, initializer? init,&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
initializer = SingleInit(exp) | CompoundInit(initializer*)&#13;
type = <b>Char | SChar | UChar |</b> Int | Long | UInt | ULong | Double&#13;
     | FunType(type* params, type ret)&#13;
     | Pointer(type referenced)&#13;
     | Array(type element, int size)&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
<b>    | String(string)</b>&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
    | Dereference(exp)&#13;
    | AddrOf(exp)&#13;
    | Subscript(exp, exp)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)&#13;
      | ConstDouble(double) | <b>ConstChar(int) | ConstUChar(int)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-15: The abstract syntax tree with character types, character constants, and string literals</samp></p>&#13;
<p class="TX">It’s tempting to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, to include string literals, but string literals are distinct enough from other kinds of constants that it’s easiest to define them separately. For example, the type checker will need to handle them differently than other constants when it processes initializers.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_433" aria-label="433"/>&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-160"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type Specifiers</samp></h4>&#13;
<p class="TNI">We’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp>, which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node, to handle character types. I won’t provide the pseudocode for this, because the logic is pretty simple. If <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> appears in a declaration by itself, it specifies the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type. As usual, the order of type specifiers doesn’t matter. It’s illegal for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to appear in a declaration with any other type specifier.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-161"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Character Constants</samp></h4>&#13;
<p class="TNI">The parser should convert each character constant token to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> with the appropriate ASCII value. It should convert the token <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(97)</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(10)</samp>, and so on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2"><span id="sec8"/><span id="h2-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing String Literals</samp></h4>&#13;
<p class="TNI">The parser should unescape string literals if the lexer hasn’t done that already. Each character in the string literal, including characters represented by escape sequences in the original source code, must be represented as a single byte internally. Otherwise, we’ll calculate inaccurate string lengths in the type checker and initialize arrays with incorrect values at runtime.</p>&#13;
<p class="TX">Adjacent string literal tokens should be concatenated into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> AST node. For example, the parser should convert the statement</p>&#13;
<pre><code>return "foo" "bar";</code></pre>&#13;
<p class="BodyContinued">to the AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(String("foobar"))</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp></h4>&#13;
<p class="TNI"><a href="chapter16.xhtml#list16-16">Listing 16-16</a> defines the complete grammar, with this chapter’s changes bolded.</p>&#13;
<a id="list16-16"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; ["=" &lt;initializer&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;declarator&gt; (&lt;block&gt; | ";")&#13;
&lt;declarator&gt; ::= "*" &lt;declarator&gt; | &lt;direct-declarator&gt;&#13;
&lt;direct-declarator&gt; ::= &lt;simple-declarator&gt; [&lt;declarator-suffix&gt;]&#13;
&lt;declarator-suffix&gt; ::= &lt;param-list&gt; | {"[" &lt;const&gt; "]"}+&#13;
&lt;param-list&gt; ::= "(" "void" ")" | "(" &lt;param&gt; {"," &lt;param&gt;} ")"&#13;
&lt;param&gt; ::= {&lt;type-specifier&gt;}+ &lt;declarator&gt;&#13;
&lt;simple-declarator&gt; ::= &lt;identifier&gt; | "(" &lt;declarator&gt; ")"&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" | "double" <b>| </b><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span><b> "char"</b>&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_434" aria-label="434"/>&lt;initializer&gt; ::= &lt;exp&gt; | "{" &lt;initializer&gt; {"," &lt;initializer&gt;} [","] "}"&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;unary-exp&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;unary-exp&gt; ::= &lt;unop&gt; &lt;unary-exp&gt;&#13;
              | "(" {&lt;type-specifier&gt;}+ [&lt;abstract-declarator&gt;] ")" &lt;unary-exp&gt;&#13;
              | &lt;postfix-exp&gt;&#13;
&lt;postfix-exp&gt; ::= &lt;primary-exp&gt; {"[" &lt;exp&gt; "]"}&#13;
&lt;primary-exp&gt; ::= &lt;const&gt; | &lt;identifier&gt; | "(" &lt;exp&gt; ")"<b> | </b><span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span><b> {&lt;string&gt;}+</b>&#13;
                | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;abstract-declarator&gt; ::= "*" [&lt;abstract-declarator&gt;]&#13;
                        | &lt;direct-abstract-declarator&gt;&#13;
&lt;direct-abstract-declarator&gt; ::= "(" &lt;abstract-declarator&gt; ")" {"[" &lt;const&gt; "]"}&#13;
                               | {"[" &lt;const&gt; "]"}+&#13;
&lt;unop&gt; ::= "-" | "~" | "!" | "*" | "&amp;"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; | &lt;double&gt; <b>| </b><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span><b> &lt;char&gt;</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
<b>&lt;string&gt; ::= ? A string token ?</b> <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&lt;int&gt; ::= ? An int token ?&#13;
<b>&lt;char&gt; ::= ? A char token ? </b><span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
&lt;double&gt; ::= ? A floating-point constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-16: The grammar with character types, character constants, and string literals</samp></p>&#13;
<p class="TX">The bolded additions to the grammar correspond to the three changes to the parser we just discussed. The grammar now includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">"char"</samp> type specifier <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;string&gt;</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;char&gt;</samp> tokens <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We recognize a sequence of one or more string literals as a primary expression <span class="CodeAnnotation" aria-label="annotation2">❷</span> and a character token as a constant <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<aside class="box" aria-label="box-49"><p class="BoxTitle" id="box-49"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16 --stage parse</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_435" aria-label="435"/>&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-142"/><samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp></h3>&#13;
<p class="TNI">For the most part, the type checker can treat characters like the other integer types. They follow the same typing rules and support the same operations. The integer promotions are the one exception to this pattern, so we’ll implement them in this section. We’ll also introduce static initializers for the character types.</p>&#13;
<p class="TX">String literals are more challenging to type check, particularly when they appear in initializers. We’ll need to track whether each string should be used directly or converted to a pointer and which strings should be terminated with null bytes. We’ll add a few new constructs to the symbol table to represent each of these cases.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-164"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Characters</samp></h4>&#13;
<p class="TNI">We’ll promote character types to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> as part of the usual arithmetic conversions. <a href="chapter16.xhtml#list16-17">Listing 16-17</a> shows how to perform this promotion in <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>.</p>&#13;
<a id="list16-17"/>&#13;
<pre><code>get_common_type(type1, type2):&#13;
    if type1 is a character type:&#13;
        type1 = Int&#13;
    if type2 is a character type:&#13;
        type2 = Int&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-17: Applying the integer promotions during the usual arithmetic conversions</samp></p>&#13;
<p class="TX">After promoting the types of both operands, we’ll find their common type as usual. We’ll also promote the operands of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operations. <a href="chapter16.xhtml#list16-18">Listing 16-18</a> demonstrates how to promote a negated operand.</p>&#13;
<a id="list16-18"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Unary(Negate, inner) -&gt;&#13;
        typed_inner = typecheck_and_convert(inner, symbols)&#13;
        inner_t = get_type(typed_inner)&#13;
        if inner_t is a pointer type:&#13;
            fail("Can't negate a pointer")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if inner_t is a character type:&#13;
            typed_inner = convert_to(typed_inner, Int)&#13;
        unary_exp = Unary(Negate, typed_inner)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> return set_type(unary_exp, get_type(typed_inner))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-18: Applying the integer promotions to a negation expression</samp></p>&#13;
<p class="TX">First, we make sure the operand isn’t a pointer (we introduced this validation in <span class="Xref-1"><a href="chapter14.xhtml">Chapter 14</a></span>). Then, we apply the integer promotions. We check whether the operand is one of the character types <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if it is, we convert it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp> and then negate the promoted value. The result of the expression has the same type as its promoted operand <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> the same way, so I won’t provide the pseudocode for that here.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_436" aria-label="436"/>We’ll always recognize characters as integer types during type checking. For example, we’ll accept characters as operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> expressions and as indices in pointer arithmetic. Because all integer types are also arithmetic types, we’ll permit implicit conversions between the character types and any other arithmetic type in <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.</p>&#13;
<p class="TX">We’ll add two static initializers for the character types. <a href="chapter16.xhtml#list16-19">Listing 16-19</a> gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>.</p>&#13;
<a id="list16-19"/>&#13;
<pre><code>static_init = IntInit(int) | LongInit(int) | UIntInit(int) | ULongInit(int)&#13;
<b>            | CharInit(int) | UCharInit(int)</b>&#13;
            | DoubleInit(double) | ZeroInit(int bytes)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-19: Adding the static initializers for character types</samp></p>&#13;
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> are both signed types, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp> to initialize both of them. We’ll convert each initializer to the type it initializes according to the type conversion rules we covered in <span class="Xref-1"><a href="chapter11.xhtml">Chapters 11</a></span> and <span class="Xref-1"><a href="chapter12.xhtml">12</a></span>. For example, if an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> is initialized with a value greater than 255, we’ll reduce its value modulo 256.</p>&#13;
<p class="TX">Finally, we’ll make one small, straightforward update to the way we type check compound initializers for non-static arrays. (We’ll handle string literals that initialize arrays as a separate case in the next section.) In the previous chapter, we dealt with partly initialized arrays by padding out the remaining elements with zeros. I suggested writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> helper function to generate these zeroed-out initializers. Now we can extend that function to emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> to zero out elements of character type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-165"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in Expressions</samp></h4>&#13;
<p class="TNI">When we encounter a string literal in an expression, rather than in an array initializer, we’ll annotate it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array of the appropriate size. <a href="chapter16.xhtml#list16-20">Listing 16-20</a> shows how to handle string literals in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.</p>&#13;
<a id="list16-20"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | String(s) -&gt; return set_type(e, Array(Char, length(s) + 1))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-20: Type checking a string literal</samp></p>&#13;
<p class="TX">Note that the array size accounts for a terminating null byte. The type checker already handles implicit conversions from arrays to pointers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>. Now <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will convert string literals to pointers too, since they also have array type.</p>&#13;
<p class="TX">Next, we’ll update the type checker to recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> expressions as lvalues, along with variables, subscript operators, and dereference expressions. This allows programs to take their address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator.</p>&#13;
<p class="TX">That takes care of string literals in ordinary expressions; now we’ll type check string literals in initializers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_437" aria-label="437"/>&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-166"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals Initializing Non-static Variables</samp></h4>&#13;
<p class="TNI">Usually, we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> constructs with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>, which converts values of array type to pointers. This approach correctly handles string literals that initialize pointers. But when a string literal is used to initialize an array, we’ll type check it differently. <a href="chapter16.xhtml#list16-21">Listing 16-21</a> shows how to handle this case.</p>&#13;
<a id="list16-21"/>&#13;
<pre><code>typecheck_init(target_type, init, symbols):&#13;
    match target_type, init with&#13;
    | Array(elem_t, size), SingleInit(String(s)) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if elem_t is not a character type:&#13;
            fail("Can't initialize a non-character type with a string literal")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if length(s) &gt; size:&#13;
            fail("Too many characters in string literal")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return set_type(init, target_type)&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-21: Type checking a string literal that initializes an array</samp></p>&#13;
<p class="TX">First, we make sure the target type is an array of characters, since string literals can’t initialize arrays of any other type <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we validate that the string isn’t too long to initialize the array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we annotate the initializer with the target type <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We’ll use this annotation later to figure out how many null bytes to append to the string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-167"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals Initializing Static Variables</samp></h4>&#13;
<p class="TNI">Our final task is to process string literals that initialize static variables. We’ll need to represent two new kinds of initial values in the symbol table: ASCII strings (which correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives) and the addresses of static objects (which correspond to directives like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp>). We’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> once again to include both kinds of initializers. <a href="chapter16.xhtml#list16-22">Listing 16-22</a> gives the new definition with these two additions bolded.</p>&#13;
<a id="list16-22"/>&#13;
<pre><code>static_init = IntInit(int) | LongInit(int)&#13;
            | UIntInit(int) | ULongInit(int)&#13;
            | CharInit(int) | UCharInit(int)&#13;
            | DoubleInit(double) | ZeroInit(int bytes)&#13;
            <b>| StringInit(string, bool null_terminated)</b>&#13;
<b>            | PointerInit(string name)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-22: Adding the static initializers for strings and pointers</samp></p>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> defines an ASCII string initializer. We’ll use it to initialize both constant strings and character arrays. The <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp> argument specifies whether to include a null byte at the end; we’ll use this argument to choose between the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives during code emission. <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp> initializes a pointer with the address of another static object.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_438" aria-label="438"/>We’ll also start tracking constant strings in the symbol table. <a href="chapter16.xhtml#list16-23">Listing 16-23</a> gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>, which includes constants.</p>&#13;
<a id="list16-23"/>&#13;
<pre><code>identifier_attrs = FunAttr(bool defined, bool global)&#13;
                 | StaticAttr(initial_value init, bool global)&#13;
<b>                 | ConstantAttr(static_init init)</b>&#13;
                 | LocalAttr</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-23: Tracking constants in the symbol table</samp></p>&#13;
<p class="TX">Unlike a variable, which may be uninitialized, tentatively initialized, or initialized with a list of values, a constant is initialized with a single value. It also doesn’t need a <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> flag, since we’ll never define a global constant.</p>&#13;
<p class="TX">Now that we’ve extended <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>, let’s discuss how to process string initializers for both character arrays and <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> pointers.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3"><span id="sec15"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Array with a String Literal</samp></h5>&#13;
<p class="TNI">If a string literal initializes a static array, we first validate the array’s type: we make sure that the array elements have character type and that the array is long enough to contain the string. (This is the same validation we performed for non-static arrays back in <a href="chapter16.xhtml#list16-21">Listing 16-21</a>.) We then convert the string literal to a <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> initializer, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp> flag if the array has enough space for the terminating null byte. We add <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to the initializer list if we need to pad it out with additional null bytes. For example, we’ll convert the declaration</p>&#13;
<pre><code>static char letters[10] = "abc";</code></pre>&#13;
<p class="BodyContinued">to the symbol table entry in <a href="chapter16.xhtml#list16-24">Listing 16-24</a>.</p>&#13;
<a id="list16-24"/>&#13;
<pre><code>name="letters"&#13;
type=Array(Char, 10)&#13;
attrs=StaticAttr(init=Initial([StringInit("abc", True), ZeroInit(6)]),&#13;
                 global=False)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-24: The symbol table entry for an array initialized from a string literal</samp></p>&#13;
<p class="TX">This entry initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>, followed by 6 bytes of zeros.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3"><span id="sec16"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Pointer with a String Literal</samp></h5>&#13;
<p class="TNI">If a string literal initializes a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>, we create two entries in the symbol table. The first defines the string itself, and the second defines the variable that points to that string. Let’s look at an example:</p>&#13;
<pre><code>static char *message = "Hello!";</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_439" aria-label="439"/>First, we generate an identifier for the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>; let’s say this identifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">"string.0"</samp>. Then, we add the entry shown in <a href="chapter16.xhtml#list16-25">Listing 16-25</a> to the symbol table.</p>&#13;
<a id="list16-25"/>&#13;
<pre><code>name="string.0"&#13;
type=Array(Char, 7)&#13;
attrs=ConstantAttr(StringInit("Hello!", True))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-25: Defining a constant string in the symbol table</samp></p>&#13;
<p class="TX">This identifier must be globally unique and must be a syntactically valid label in assembly. In other words, it should follow the same constraints as the identifiers we generate for floating-point constants. Because <a href="chapter16.xhtml#list16-25">Listing 16-25</a> defines a constant string, we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp> construct, and we’ll initialize it with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>.</p>&#13;
<p class="TX">Then, when we add <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> itself to the symbol table, we initialize it with a pointer to the symbol we just added. <a href="chapter16.xhtml#list16-26">Listing 16-26</a> shows the symbol table entry for <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>.</p>&#13;
<a id="list16-26"/>&#13;
<pre><code>name="message"&#13;
type=Pointer(Char)&#13;
attrs=StaticAttr(init=Initial([PointerInit("string.0")]), global=False)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-26: Defining a static pointer to a string in the symbol table</samp></p>&#13;
<p class="TX">If a string literal initializes a pointer to a type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, we throw an error. (Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp> already catches this error in the non-static case.) Even using a string literal to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char *</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char *</samp> is illegal. This is in keeping with the ordinary rules for type conversions: string literals have type <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>, and we can’t implicitly convert from one pointer type to another. By contrast, a string literal can initialize an <i>array</i> of any character type because it’s legal to implicitly convert each individual character from one character type to another.</p>&#13;
<p class="TX">At this point, we have symbol table entries for all the strings that appear in static initializers. During TACKY generation, we’ll add all the other constant strings in the program to the symbol table too.</p>&#13;
<aside class="box" aria-label="box-50"><p class="BoxTitle" id="box-50"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the type checker, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Type checking should fail for all the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/invalid _types</samp><samp class="SANS_Futura_Std_Book_11">. These tests include string literals that initialize arrays of non-character type, assignments to string literals, and implicit conversions between pointers to different character types. Your type checker should successfully process all the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_440" aria-label="440"/>&#13;
<h3 class="H1"><span id="sec17"/><span id="h1-143"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">When we convert a program to TACKY, we can treat characters exactly like all the other integers. In particular, we’ll implement casts to and from character types with the existing type conversion instructions. For example, we’ll implement casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> instruction, and we’ll implement casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>. Processing string literals, however, requires a bit more work.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2"><span id="sec18"/><span id="h2-168"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals as Array Initializers</samp></h4>&#13;
<p class="TNI">In the type checker, we dealt with string literals that initialized static arrays. Now we’ll do the same for arrays with automatic storage duration.</p>&#13;
<p class="TX">As we saw earlier in the chapter, there are two options here. The simpler option is to initialize these arrays one character at a time. The more efficient option is to initialize entire 4- or 8-byte chunks at once. Either way, we’ll copy the string into the array with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions.</p>&#13;
<p class="TX">Let’s walk through both options. We’ll use the initializer from <a href="chapter16.xhtml#list16-6">Listing 16-6</a>, reproduced here, as a running example:</p>&#13;
<pre><code>int main(void) {&#13;
    char letters[6] = "abcde";&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="TX">When we first looked at this example, we learned that the ASCII values of <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>. Using the simple one-byte-at-a-time approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> with the TACKY instructions in <a href="chapter16.xhtml#list16-27">Listing 16-27</a>.</p>&#13;
<a id="list16-27"/>&#13;
<pre><code>CopyToOffset(Constant(ConstChar(97)),  "letters", 0)&#13;
CopyToOffset(Constant(ConstChar(98)),  "letters", 1)&#13;
CopyToOffset(Constant(ConstChar(99)),  "letters", 2)&#13;
CopyToOffset(Constant(ConstChar(100)), "letters", 3)&#13;
CopyToOffset(Constant(ConstChar(101)), "letters", 4)&#13;
CopyToOffset(Constant(ConstChar(0)),   "letters", 5)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-27: Initializing a non-static array in TACKY, one byte at a time</samp></p>&#13;
<p class="TX">Using the more efficient approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> with a single 4-byte integer, followed by 2 individual bytes:</p>&#13;
<pre><code>CopyToOffset(Constant(ConstInt(1684234849)), "letters", 0)&#13;
CopyToOffset(Constant(ConstChar(101)),       "letters", 4)&#13;
CopyToOffset(Constant(ConstChar(0)),         "letters", 5)</code></pre>&#13;
<p class="TX">To come up with the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp>, we take the 4 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> and interpret them as a single little-endian integer. In hexadecimal, these bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x61</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x62</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64</samp>. The first byte in little-endian integers is least significant, so interpreting this byte sequence as an integer <span role="doc-pagebreak" epub:type="pagebreak" id="pg_441" aria-label="441"/>gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64636261</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> in decimal. Whatever language you’re implementing your compiler in, it likely has utility functions to manipulate byte buffers and interpret them as integers, so you won’t need to implement this fiddly logic yourself.</p>&#13;
<p class="TX">To initialize eight characters at once, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>. We need to be careful not to overrun the bounds of the array we’re initializing; in this example, it would be incorrect to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> with two 4-byte integers, because it would clobber neighboring values.</p>&#13;
<p class="TX">It’s up to you which of these approaches to use; they’re both equally correct. In either case, make sure to initialize the correct number of null bytes at the end of the string. In the type checker, you annotated every initializer, including string literals, with type information. Now you’ll use that type information to figure out how many null bytes to include. If a string literal is longer than the array it initializes, copy in only as many characters as the array can hold. In other words, leave off the null byte. If the string literal is too short, copy zeros into the rest of the array.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-169"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in Expressions</samp></h4>&#13;
<p class="TNI">When we encounter a string literal outside of an array initializer, we’ll add it to the symbol table as a constant string. Then, we’ll use its identifier as a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. Let’s revisit <a href="chapter16.xhtml#list16-9">Listing 16-9</a>, which returns a pointer to the first character in a string:</p>&#13;
<pre><code>return "A profound statement.";</code></pre>&#13;
<p class="TX">The parser and type checker transform this into the following AST node:</p>&#13;
<pre><code>Return(AddrOf(String("A profound statement.")))</code></pre>&#13;
<p class="TX">To convert this AST node to TACKY, we first define <samp class="SANS_TheSansMonoCd_W5Regular_11">"A profound statement."</samp> in the symbol table:</p>&#13;
<pre><code>name="string.1"&#13;
type=Array(Char, 22)&#13;
attrs=ConstantAttr(StringInit("A profound statement.", True))</code></pre>&#13;
<p class="TX">This entry is no different from the constant strings we defined in the type checker. It has a globally unique, automatically generated label. It’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array that’s just large enough to contain the whole string, including the terminating null byte. It’s initialized with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp> construct because we’ll ultimately store it in read-only memory.</p>&#13;
<p class="TX">Now we can refer to the identifier we just defined—<samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>, in this example—to load the string’s address:</p>&#13;
<pre><code>GetAddress(Var("string.1"), Var("tmp2"))&#13;
Return(Var("tmp2"))</code></pre>&#13;
<p class="TX">In short, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp> like any other symbol of array type.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_442" aria-label="442"/>&#13;
<h4 class="H2"><span id="sec20"/><span id="h2-170"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants in TACKY</samp></h4>&#13;
<p class="TNI">We need to account for all these new constant strings when we convert entries in the symbol table to top-level TACKY definitions. The assembly AST already has a top-level constant construct. Now we’ll add the corresponding construct to TACKY:</p>&#13;
<pre><code>top_level =<var> --snip--</var> | StaticConstant(identifier, type t, static_init init)</code></pre>&#13;
<p class="TX">When we’re generating top-level TACKY definitions from the symbol table, we’ll generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> for every constant in the symbol table, just like we generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> for each static variable. Make sure to convert function definitions to TACKY before traversing the symbol table; otherwise, you’ll miss the constant strings that get added to the symbol table during this pass.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-28">Listing 16-28</a> summarizes the TACKY IR, with this chapter’s addition bolded.</p>&#13;
<a id="list16-28"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init* init_list)&#13;
          <b>| StaticConstant(identifier, type t, static_init init)</b>&#13;
instruction = Return(val)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
            | DoubleToInt(val src, val dst)&#13;
            | DoubleToUInt(val src, val dst)&#13;
            | IntToDouble(val src, val dst)&#13;
            | UIntToDouble(val src, val dst)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | GetAddress(val src, val dst)&#13;
            | Load(val src_ptr, val dst)&#13;
            | Store(val src, val dst_ptr)&#13;
            | AddPtr(val ptr, val index, int scale, val dst)&#13;
            | CopyToOffset(val src, identifier dst, int offset)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-28: Adding static constants to the TACKY IR</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_443" aria-label="443"/>At this point, your TACKY generation pass should be good to go: it can handle individual characters, string literals that are implicitly converted to pointers, and string literals that initialize arrays.</p>&#13;
<aside class="box" aria-label="box-51"><p class="BoxTitle" id="box-51"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1"><span id="sec21"/><span id="h1-144"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">We won’t do anything too fancy in this stage. First, we’ll convert operations on individual characters to assembly. This will require a few changes to the assembly AST. Then, we’ll handle TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> constructs and add constant strings to the backend symbol table.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2"><span id="sec22"/><span id="h2-171"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Operations on Characters</samp></h4>&#13;
<p class="TNI">Most instructions support 1-byte operands as well as longwords and quadwords. A <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> suffix, like in the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">andb</samp>, indicates that an instruction operates on a single byte. We’ll introduce a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> assembly type to represent this new operand size:</p>&#13;
<pre><code>assembly_type = Byte | <var>--snip--</var></code></pre>&#13;
<p class="TX">We’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> types to <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>. The general-purpose registers have 1-byte aliases too; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp> is the 1-byte alias for RAX. Luckily, our code emission pass already supports these aliases.</p>&#13;
<p class="TX">Aside from adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> type, we’ll need to convert to and from character types correctly. You can zero extend a 1-byte value to a wider type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> instruction. This instruction takes a two-letter suffix, indicating the types of the source and destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbl</samp> instruction extends a byte to a longword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbq</samp> extends a byte to a quadword. (You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwl</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwq</samp> to extend a 2-byte word to a larger type, but we don’t use 2-byte operands.) We’ll represent <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> with the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instruction in the assembly AST, but we’ll add the types of both operands:</p>&#13;
<pre><code>MovZeroExtend(<b>assembly_type src_type, assembly_type dst_type, </b>operand src, operand dst)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_444" aria-label="444"/>If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, we’ll ultimately emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> instruction with the correct suffix. If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, we’ll rewrite this to an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction during the fix-up pass, just like in earlier chapters.</p>&#13;
<p class="TX">To sign extend a byte to a larger type, we’ll use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp> instruction. This instruction also takes a suffix to specify the types of both the source and the destination: <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbl</samp> extends a byte to a longword, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbq</samp> extends a byte to a quadword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp> extends a longword into a quadword. We’ll add type information to this instruction in the assembly AST too:</p>&#13;
<pre><code>Movsx(<b>assembly_type src_type, assembly_type dst_type,</b> operand src, operand dst)</code></pre>&#13;
<p class="TX">You can truncate a larger integer to a single byte with a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction, just like you can truncate a quadword to a longword with <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>. Note that when you copy a value to a register with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction, the register’s upper bytes aren’t zeroed out. This isn’t a problem; whether we’re operating on a single byte or a longword, we use only the part of the register that holds the value itself, and we ignore the register’s upper bytes.</p>&#13;
<aside class="box" aria-label="box-52"><p class="BoxTitle" id="box-52"><samp class="SANS_Dogma_OT_Bold_B_11">CLANG GOES ROGUE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">There is one case where the contents of a register’s upper bytes might matter: when you’re calling a function that was compiled with Clang. If a function argument is narrower than 4 bytes, Clang always has the caller sign extend or zero extend it to 4 bytes. Then, in the callee, it assumes the argument has been extended to 4 bytes already.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This assumption violates the System V ABI, which doesn’t require callers to extend narrow function arguments. Take the following C code:</samp></p>&#13;
<pre><code>int accept_int(int i);&#13;
&#13;
int accept_char(char c) {&#13;
    return accept_int(c);&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">When a function calls</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_char</samp><samp class="SANS_Futura_Std_Book_11">, it passes the parameter</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <samp class="SANS_Futura_Std_Book_11">in the least significant byte of EDI, which has the alias</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%dil</samp><samp class="SANS_Futura_Std_Book_11">. Then, when</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_char</samp> <samp class="SANS_Futura_Std_Book_11">calls</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_int</samp><samp class="SANS_Futura_Std_Book_11">, it passes the 4-byte representation of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp><samp class="SANS_Futura_Std_Book_11">’s value in EDI. If we’re strictly following the ABI, we assume that the 3 highest bytes of EDI are garbage at the start of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_char</samp><samp class="SANS_Futura_Std_Book_11">, so we explicitly sign extend</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <samp class="SANS_Futura_Std_Book_11">before passing it to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_int</samp><samp class="SANS_Futura_Std_Book_11">:</samp></p>&#13;
<pre><code>movsbl  %dil, %edi&#13;
call    accept_int&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">But Clang doesn’t strictly follow the ABI: when optimizations are enabled, it leaves out the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbl</samp> <samp class="SANS_Futura_Std_Book_11">instruction. This means that if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_char</samp><samp class="SANS_Futura_Std_Book_11">’s caller didn’t</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_445" aria-label="445"/><samp class="SANS_Futura_Std_Book_11">already sign extend</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp><samp class="SANS_Futura_Std_Book_11">, we might get the wrong result! This isn’t just a hypothetical concern: ICC, Intel’s legacy C compiler, doesn’t extend narrow arguments, so it’s not ABI-compatible with Clang. (Intel’s newer C compiler, which is built on Clang and LLVM, doesn’t have this problem.)</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">GCC takes the most conservative approach: it has callers extend narrow arguments but doesn’t assume they’ve been extended in the callee. It therefore interoperates correctly with both ICC and Clang.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In Clang’s defense, the ABI isn’t very explicit on this point. Ideally, the maintainers of the System V ABI would either specifically permit what Clang is doing or specifically forbid it.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">So where does that leave us? We’ll follow ICC and not bother to extend narrow arguments. But if you want to make your compiler more robust, you can take GCC’s approach: when you generate assembly code to call a function, zero extend any</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> <samp class="SANS_Futura_Std_Book_11">arguments and sign extend any</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> <samp class="SANS_Futura_Std_Book_11">arguments.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">I learned about this ugly corner case from Peter Cordes’s excellent answer on Stack Overflow (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://stackoverflow.com/a/36760539">https://<wbr/>stackoverflow<wbr/>.com<wbr/>/a<wbr/>/36760539</a></samp><samp class="SANS_Futura_Std_Book_11">). His answer was written in 2016; as of spring 2024, neither the ABI nor Clang’s behavior has changed.</samp></p>&#13;
</aside>&#13;
<p class="TX">Finally, let’s consider how to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and the character types. There’s no assembly instruction to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> directly to a 1-byte integer or vice versa. Instead, we’ll convert to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> as an intermediate step. To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to any character type, we’ll first convert it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and then truncate it, as <a href="chapter16.xhtml#list16-29">Listing 16-29</a> demonstrates.</p>&#13;
<a id="list16-29"/>&#13;
<pre><code>Cvttsd2si(Longword, src, Reg(AX))&#13;
Mov(Byte, Reg(AX), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-29: Converting a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a character type</samp></p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-30">Listing 16-30</a> gives the assembly to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll zero extend it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, then convert the result to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<a id="list16-30"/>&#13;
<pre><code>MovZeroExtend(Byte, Longword, src, Reg(AX))&#13;
Cvtsi2sd(Longword, Reg(AX), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-30: Converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp></p>&#13;
<p class="TX">And to convert either signed character type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll sign extend it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> first, as <a href="chapter16.xhtml#list16-31">Listing 16-31</a> demonstrates.</p>&#13;
<a id="list16-31"/>&#13;
<pre><code>Movsx(Byte, Longword, src, Reg(AX))&#13;
Cvtsi2sd(Longword, Reg(AX), dst)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-31: Converting a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_446" aria-label="446"/>Next, we’ll deal with our second task: converting top-level constants from TACKY to assembly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-172"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants</samp></h4>&#13;
<p class="TNI">Processing a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> is extremely simple: we just convert it to an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>. You’ll also need to convert each constant string in the symbol table to an equivalent entry in the backend symbol table, like you do for variables. When you add a constant string to the backend symbol table, set its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp> attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If your backend symbol table includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> attribute, set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> as well. (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> was an optional addition in <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span>; it tells us when to use local labels during code emission.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2"><span id="sec24"/><span id="h2-173"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion from TACKY to Assembly</samp></h4>&#13;
<p class="TNI"><a href="chapter16.xhtml#list16-32">Listing 16-32</a> shows this chapter’s additions to the assembly AST.</p>&#13;
<a id="list16-32"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = <b>Byte |</b> Longword | Quadword | Double | ByteArray(int size, int alignment)&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)&#13;
          | StaticConstant(identifier name, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(<b>assembly_type src_type, assembly_type dst_type,</b> operand src, operand dst)&#13;
            | MovZeroExtend(<b>assembly_type src_type, assembly_type dst_type, </b>operand src, &#13;
                            operand dst)&#13;
            | Lea(operand src, operand dst)&#13;
            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
unary_operator = Neg | Not | Shr&#13;
binary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier)&#13;
        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP&#13;
    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-32: The assembly AST with byte operands</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_447" aria-label="447"/><a href="chapter16.xhtml#tab16-2">Tables 16-2</a> through <a href="chapter16.xhtml#tab16-5">16-5</a> summarize the latest updates to the conversion from TACKY to assembly, with new constructs and changes to the conversions for existing constructs bolded.</p>&#13;
<p class="TT" id="tab16-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name, t, init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment of t&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">, init)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_448" aria-label="448"/>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF graybg"/>&#13;
<td class="Basic-Table TBF graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB graybg"/>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Movsx(Byte,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Longword,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Cvtsi2sd(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB  graybg" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp></p></td>&#13;
<td class="Basic-Table TBL  graybg"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Cvttsd2si(Longword,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">))<br/>Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(Byte,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cvtsi2sd(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword, Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0),</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src)<br/>JmpCC(L,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Cvtsi2sd(Quadword, src, dst)<br/>Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Mov(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Mov(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Unary(Shr, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Binary(And, Quadword, Imm(1), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Binary(Or, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)<br/>Binary(Add, Double, dst, dst)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(Longword,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Mov(Longword, Reg(&lt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">R</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"/>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), src)<br/>JmpCC(AE,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Cvttsd2si(Quadword, src, dst)<br/>Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Binary(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)<br/>Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))<br/>Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">), dst)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp><br/><samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp><br/><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, 8,<br/>DoubleInit(9223372036854775808.0))</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstChar(int))</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstUChar(int))</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Char</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">SChar</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">UChar</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Next, let’s move on to pseudo-operand replacement and instruction fix-up. The updates to both of these passes are pretty straightforward.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2"><span id="sec25"/><span id="h2-174"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudo-Operand Replacement</samp></h4>&#13;
<p class="TNI">We’ll allocate 1 byte on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> object. We don’t need to worry about rounding these down to the right alignment, because they’re all 1-byte aligned.</p>&#13;
<p class="TX">This pass shouldn’t require any dedicated logic to deal with constant strings. We’ve already recorded that they have static storage duration in the backend symbol table. Now we’ll access them with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands like any other static object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_449" aria-label="449"/>&#13;
<h4 class="H2"><span id="sec26"/><span id="h2-175"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction Fix-Up</samp></h4>&#13;
<p class="TNI">The destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> instruction must be a register, and its source must not be an immediate value. If the size of the source operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instruction is 1 byte and its source or destination is invalid, we rewrite it according to the usual pattern. For instance, we rewrite</p>&#13;
<pre><code>movzbl  $10, -4(%rbp)</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>movb    $10, %r10b&#13;
movzbl  %r10b, %r11d&#13;
movl    %r11d, -4(%rbp)</code></pre>&#13;
<p class="TX">If its source operand is a longword, we replace it with one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions, like in earlier chapters.</p>&#13;
<p class="TX">If the source of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction is an immediate value that can’t fit in a single byte, we’ll reduce it modulo 256. For example, we’ll rewrite</p>&#13;
<pre><code>movb    $258, %al</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>movb    $2, %al</code></pre>&#13;
<p class="TX">This is the same pattern we introduced in <span class="Xref-1"><a href="chapter11.xhtml">Chapter 11</a></span> to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions whose source operands are 8-byte immediate values.</p>&#13;
<aside class="box" aria-label="box-53"><p class="BoxTitle" id="box-53"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1"><span id="sec27"/><span id="h1-145"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">The code emission stage needs to support string constants, pointer initializers, and a handful of other changes. We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> as either an <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> or an <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directive, depending on whether it should include a null byte. Double quotes, backslashes, and new lines in ASCII strings must be escaped. To escape these characters, you can use either the <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> escape sequences or three-digit octal escape sequences that specify their <span role="doc-pagebreak" epub:type="pagebreak" id="pg_450" aria-label="450"/>ASCII values. For example, the ASCII code for the backslash character is <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">134</samp> in octal, so you could represent it with the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\134</samp>. You can escape other special characters too, but you don’t need to. Some escape sequences, like <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>, are valid in C but not assembly, so octal escape sequences are the safest way to escape arbitrary characters.</p>&#13;
<p class="TX">We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive, followed by the label we want to point to. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">UCharInit</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.byte</samp> directive, which works exactly like <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>. When you emit a 1-byte-aligned object, you can either include the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> directive or omit it. Every object is at least 1-byte aligned by definition, so specifying a 1-byte alignment has no effect.</p>&#13;
<p class="TX">On Linux, string constants will live in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp> section along with floating-point constants. On macOS, they’ll live in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp> section. If you use local labels (which begin with a <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix) for floating-point constants, you should use them for string constants too. The logic to add this prefix to <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands won’t change; we’ll still look up each <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand in the backend symbol table and add this prefix if its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> attribute is true.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> instructions should include suffixes to indicate both the source and destination types. Other instructions should include a <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> suffix when they operate on bytes. <a href="chapter16.xhtml#tab16-6">Tables 16-6</a> through <a href="chapter16.xhtml#tab16-6">16-9</a> summarize the latest updates to the code emission pass; new constructs and changes to the way we emit existing constructs are bolded.</p>&#13;
<p class="TT" id="tab16-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL" rowspan="4"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(name, alignment, init)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Linux</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .section .rodata</samp>&#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">  &lt;alignment-directive&gt; &#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:&#13;
</samp> <samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">  &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">macOS (8-byte-aligned numeric constants)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .literal8</samp>&#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .balign 8</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>&#13;
 <samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">  &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">macOS (16-byte-aligned numeric constants)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .literal16</samp>&#13;
<samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .balign 16</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>&#13;
 <samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">  &lt;init&gt;</samp>&#13;
 <samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">  .quad 0</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">macOS (string constants)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .cstring</samp>&#13;
 <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>&#13;
 <samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">  &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-7"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_451" aria-label="451"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Static Initializers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">CharInit(0)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.zero 1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">CharInit(i)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(0)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.zero 1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(i)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, True)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.asciz "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;s&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">"</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, False)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.ascii "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;s&gt;</samp><samp class="SANS_Futura_Std_Heavy_B_11">"</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">PointerInit(label)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_Futura_Std_Heavy_B_11">src_t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">dst_t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">movs</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src_t&gt;&lt;dst_t&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">MovZeroExtend(src_t, dst_t, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">movz</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src_t&gt;&lt;dst_t&gt;   &lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab16-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Suffixes for Assembly Types</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction suffix</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">b</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Your compiler now supports strings and characters! You still need to run this chapter’s tests to make sure you’ve implemented these features correctly, but first, we’ll try out a couple of examples.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1"><span id="sec28"/><span id="h1-146"/><samp class="SANS_Futura_Std_Bold_B_11">Hello Again, World!</samp></h3>&#13;
<p class="TNI">Back in <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, we printed “Hello, World!” one character at a time. Now we can write a more traditional “Hello, World!” program using the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> standard library function, which has the following signature:</p>&#13;
<pre><code>int puts(const char *s);</code></pre>&#13;
<p class="TX">Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>, we’ll declare <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> without it. <a href="chapter16.xhtml#list16-33">Listing 16-33</a> shows our new “Hello, World!” program.</p>&#13;
<a id="list16-33"/>&#13;
<pre><code>int puts(char *c);&#13;
int main(void) {&#13;
    puts("Hello, World!");&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-33: Printing out a string with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">puts</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_452" aria-label="452"/>This code is not entirely legal, since the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> isn’t compatible with the definition in the standard library. However, the program should work correctly in spite of this minor bit of rule breaking. Compile it, then run it to print a message to stdout:</p>&#13;
<pre><code>$ <b>./hello_world</b>&#13;
Hello, World!</code></pre>&#13;
<p class="TX">If you want to get really wild, you can even compile <a href="chapter16.xhtml#list16-34">Listing 16-34</a>, which reads from stdin.</p>&#13;
<a id="list16-34"/>&#13;
<pre><code>int getchar(void);&#13;
int puts(char *c);&#13;
char *strncat(char *s1, char *s2, unsigned long n);&#13;
char *strcat(char *s1, char *s2);&#13;
unsigned long strlen(char *s);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> static char name[30];&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> static char message[40] = "Hello, ";&#13;
&#13;
int main(void) {&#13;
    puts("Please enter your name: ");&#13;
&#13;
    int idx = 0;&#13;
    while (idx &lt; 29) {&#13;
        int c = getchar();&#13;
&#13;
        // treat EOF, null byte, or line break as end of input&#13;
        if (c &lt;= 0 || c == '\n') {&#13;
            break;&#13;
        }&#13;
&#13;
        name[idx] = c;&#13;
        idx = idx + 1;&#13;
    }&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> name[idx] = 0; // add terminating null byte to name&#13;
&#13;
    // append name to message, leaving space for null byte&#13;
    // and exclamation point&#13;
    strncat(message, name, 40 - strlen(message) - 2);&#13;
&#13;
    // append exclamation point&#13;
    strcat(message, "!");&#13;
    puts(message);&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-34: Reading from stdin</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_453" aria-label="453"/>Much like <a href="chapter16.xhtml#list16-33">Listing 16-33</a> declares <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> without the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier, this program declares several library functions without their usual qualifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> to read from stdin one character at a time, since our compiler can’t easily handle most other ways to read from stdin using C standard library functions.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#list16-34">Listing 16-34</a> declares two static arrays: <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is static but has no explicit initializer, it will be initialized with all zeros <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> is initialized with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, "</samp>, and the remainder is filled with null bytes <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> to emit a prompt, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> in a loop to read the user’s response into the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> array, one character at a time. We exit the loop when <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> returns a negative number (which indicates end-of-file or an error), a null byte, or a new line character, or after we’ve read in 29 characters, whichever comes first. (We check whether the result is negative, instead of comparing it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> macro like a normal C program would, because we can’t include <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> is defined.) Reading in at most 29 characters leaves room for a terminating null byte, which we add to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> after exiting the loop <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> appends the user’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>, and the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp> appends an exclamation point. Finally, the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> writes the whole message to stdout. Your compiler should be able to handle this listing; go ahead and give it a try! I’ll use the program to say hello to my dog, Arlo. (I promised him I’d mention him in this book at least once.)</p>&#13;
<pre><code>$ <b>./hello_name</b>&#13;
Please enter your name:&#13;
<b>Arlo</b>&#13;
Hello, Arlo!</code></pre>&#13;
<p class="TX">If this program works correctly, you’re ready to run the full test suite.</p>&#13;
<aside class="box" aria-label="box-54"><p class="BoxTitle" id="box-54"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 16</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid/char_constants</samp> <samp class="SANS_Futura_Std_Book_11">exercise your compiler’s support for character constant tokens. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid/chars</samp> <samp class="SANS_Futura_Std_Book_11">test its support for values of scalar character type, and the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid/strings_as_initializers</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid/strings_as_lvalues</samp> <samp class="SANS_Futura_Std_Book_11">test its support for string literals. As usual, the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_16/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">validate that your compiler handles strings and characters according to the System V ABI.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_454" aria-label="454"/>&#13;
<h3 class="H1"><span id="sec29"/><span id="h1-147"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Your compiler can now process programs that work with text. In this chapter, you learned how to lex string literals and character constants, and you extended the type checker to distinguish between constant strings and string literals that initialize arrays. You also introduced new ways to define constants in the symbol table and the TACKY IR. In the next chapter, you’ll introduce two features that make it easier to dynamically allocate memory: the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>