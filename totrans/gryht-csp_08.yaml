- en: '9'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: AUTOMATING SQLMAP
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 SQLMAP
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: In this chapter, we make tools to automatically exploit SQL injection vectors.
    We use sqlmap—a popular utility you’ll learn about in this chapter—to first find
    and then verify HTTP parameters vulnerable to SQL injection. After that, we combine
    that functionality with the SOAP fuzzer we created in [Chapter 3](index_split_008.html#filepos243384)
    to automatically verify any potential SQL injections in the vulnerable SOAP service.
    sqlmap ships with a REST API, meaning that it uses HTTP GET, PUT, POST, and DELETE
    requests to work with data and special URIs to reference resources in databases.
    We used REST APIs in [Chapter 5](index_split_010.html#filepos420379) when we automated
    Nessus.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们制作了自动化利用 SQL 注入漏洞的工具。我们使用 sqlmap —— 一款流行的工具，你将在本章中学习 —— 来首先找到并验证易受 SQL
    注入攻击的 HTTP 参数。之后，我们将该功能与我们在 [第 3 章](index_split_008.html#filepos243384) 中创建的 SOAP
    fuzzer 结合，自动验证易受攻击的 SOAP 服务中的潜在 SQL 注入漏洞。sqlmap 配备了一个 REST API，这意味着它使用 HTTP GET、PUT、POST
    和 DELETE 请求来处理数据，并通过特殊的 URI 来引用数据库中的资源。我们在 [第 5 章](index_split_010.html#filepos420379)
    中自动化了 Nessus 时也使用了 REST API。
- en: The sqlmap API also uses JSON to read objects in HTTP requests sent to the API
    URLs (known as endpoints in REST parlance). JSON is like XML in that it allows
    two programs to pass data to each other in a standard way, but it’s also much
    less verbose and lighter weight than XML. Normally, sqlmap is used by hand at
    the command line, but driving the JSON API programmatically will allow you to
    automate far more tasks than normal pentesting tools do, from automatically detecting
    a vulnerable parameter to exploiting it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap API 还使用 JSON 来读取发送到 API URL（在 REST 术语中称为端点）的 HTTP 请求中的对象。JSON 类似于 XML，它允许两个程序以标准方式交换数据，但它比
    XML 更简洁、轻量。通常，sqlmap 是通过命令行手动使用的，但通过编程调用 JSON API 可以让你自动化更多任务，比普通的渗透测试工具更高效，从自动检测易受攻击的参数到利用它们。
- en: Written in Python, sqlmap is an actively developed utility available on GitHub
    at [https://github.com/sqlmapproject/sqlmap/](https://github.com/sqlmapproject/sqlmap/).
    You can download sqlmap using git or by downloading a ZIP file of the current
    master branch. Running sqlmap requires you to have Python installed (on most Linux
    distributions, this is usually installed by default).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap 是用 Python 编写的一个积极开发的工具，可在 GitHub 上找到，网址为 [https://github.com/sqlmapproject/sqlmap/](https://github.com/sqlmapproject/sqlmap/)。你可以通过
    git 或下载当前主分支的 ZIP 文件来获取 sqlmap。运行 sqlmap 需要安装 Python（在大多数 Linux 发行版中，通常会默认安装）。
- en: 'If you prefer git, the following command will check out the latest master branch:
    $ git clone https://github.com/sqlmapproject/sqlmap.git If you prefer wget, you
    can download a ZIP archive of the latest master branch, as shown here: $ wget
    https://github.com/sqlmapproject/sqlmap/archive/master.zip'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你偏好 git，以下命令将检出最新的主分支：$ git clone https://github.com/sqlmapproject/sqlmap.git
    如果你偏好 wget，你可以下载最新主分支的 ZIP 压缩包，如下所示：$ wget https://github.com/sqlmapproject/sqlmap/archive/master.zip
- en: $ unzip master.zip In order to follow the examples in this chapter, you should
    also install a JSON serialization framework such as the open source option Json.NET.
    Download it from [https://github.com/JamesNK/Newtonsoft.Json](https://github.com/JamesNK/Newtonsoft.Json)
    or use the NuGet package manager, available in most C# IDEs. We used this library
    before in [Chapter 2](index_split_007.html#filepos114239) and [Chapter 5](index_split_010.html#filepos420379).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: $ unzip master.zip 为了跟随本章的示例，你还应安装一个 JSON 序列化框架，如开源选项 Json.NET。你可以从 [https://github.com/JamesNK/Newtonsoft.Json](https://github.com/JamesNK/Newtonsoft.Json)
    下载，或者使用大多数 C# IDE 中可用的 NuGet 包管理器。我们在 [第 2 章](index_split_007.html#filepos114239)
    和 [第 5 章](index_split_010.html#filepos420379) 中曾使用过此库。
- en: Running sqlmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sqlmap
- en: Most security engineers and pentesters use the Python script sqlmap.py (in the
    root of the sqlmap project or installed system-wide) to drive sqlmap from the
    command line. We will briefly go over how the sqlmap command line tool works before
    jumping into the API. Kali has sqlmap installed so that you can just call sqlmap
    from anywhere on the system. Although the sqlmap command line tool has the same
    overall functionality as the API, it isn’t as easily integrated into other programs
    without invoking the shell. Driving the API programmatically should be safer and
    more flexible than just using the command line tool when integrating with other
    code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数安全工程师和渗透测试人员使用Python脚本sqlmap.py（位于sqlmap项目的根目录或系统范围内安装）从命令行驱动sqlmap。我们将在深入探讨API之前简要介绍sqlmap命令行工具的工作原理。Kali已安装sqlmap，因此你可以在系统的任何位置直接调用sqlmap。虽然sqlmap命令行工具具有与API相同的总体功能，但在与其他代码集成时，直接调用命令行工具并不如通过API编程调用那样安全和灵活。
- en: NOTE
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not running Kali, you may have downloaded sqlmap but not installed
    it on the system. You can still use sqlmap without installing it system-wide by
    changing to the directory that sqlmap is in and calling the sqlmap.py script directly
    with Python using the following code:'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你没有运行Kali，可能已经下载了sqlmap但没有在系统上安装它。你仍然可以通过进入sqlmap所在的目录，并使用以下代码直接通过Python调用sqlmap.py脚本来使用sqlmap，而无需将其系统范围安装：
- en: $ python ./sqlmap.py [.. args ..]
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ python ./sqlmap.py [.. args ..]
- en: A typical sqlmap command might look like the code in [Listing 9-1](#filepos625023).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的sqlmap命令可能如下所示，类似于[清单 9-1](#filepos625023)中的代码。
- en: $ sqlmap ➊--method=GET --level=3 --technique=b ➋--dbms=mysql \
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ sqlmap ➊--method=GET --level=3 --technique=b ➋--dbms=mysql \
- en: ➌-u "http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search"
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌-u "http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search"
- en: 'Listing 9-1: A sample sqlmap command to run against BadStore'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：运行BadStore的示例sqlmap命令
- en: We won’t cover the output of [Listing 9-1](#filepos625023) at the moment, but
    note the syntax of the command. In this listing, the arguments we pass to sqlmap
    tell it that we want it to test a certain URL (hopefully a familiar URL, like
    the one we tested in [Chapter 2](index_split_007.html#filepos114239) with BadStore).
    We tell sqlmap to use GET as the HTTP method ➊ and to use MySQL ➋ payloads specifically
    (rather than include payloads for PostgreSQL or Microsoft SQL Server), followed
    by the URL ➌ we want to test. There is only a small subset of arguments you can
    use with the sqlmap script. If you want to try out other commands manually, you
    can find more detailed information at [https://github.com/sqlmapproject/sqlmap/wiki/Usage/](https://github.com/sqlmapproject/sqlmap/wiki/Usage/).
    We can use the sqlmap REST API to drive the same functionality as the sqlmap command
    in [Listing 9-1](#filepos625023).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前不会涵盖[清单 9-1](#filepos625023)的输出，但请注意命令的语法。在这个清单中，我们传递给sqlmap的参数告诉它我们希望它测试一个特定的URL（最好是一个熟悉的URL，像我们在[第2章](index_split_007.html#filepos114239)中用BadStore测试的那个）。我们告诉sqlmap使用GET作为HTTP方法➊，并专门使用MySQL➋负载（而不是包含PostgreSQL或Microsoft
    SQL Server的负载），然后是我们希望测试的URL➌。你可以使用的sqlmap脚本参数只有一个小子集。如果你想手动尝试其他命令，可以在[https://github.com/sqlmapproject/sqlmap/wiki/Usage/](https://github.com/sqlmapproject/sqlmap/wiki/Usage/)找到更详细的信息。我们可以使用sqlmap
    REST API来实现与[清单 9-1](#filepos625023)中sqlmap命令相同的功能。
- en: When running the sqlmapapi.py API examples, you may need to run the API server
    differently than with the sqlmap utility since it might not be installed like
    the sqlmap.py script, which is callable from the system shell like on Kali. If
    you need to download sqlmap in order to use the sqlmap API, you can find it on
    GitHub ([https://github.com/sqlmapproject/sqlmap/](https://github.com/sqlmapproject/sqlmap/)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行sqlmapapi.py API示例时，你可能需要与sqlmap工具不同的方式来运行API服务器，因为它可能不像sqlmap.py脚本那样安装，可以像在Kali中那样从系统shell调用。如果你需要下载sqlmap以便使用sqlmap
    API，你可以在GitHub上找到它([https://github.com/sqlmapproject/sqlmap/](https://github.com/sqlmapproject/sqlmap/))。
- en: The sqlmap REST API
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap REST API
- en: Official documentation on the sqlmap REST API is a bit bare, but we cover everything
    you need to know to use it efficiently and effectively in this book. First, run
    sqlmapapi.py -–server (located in the root of the sqlmap project directory you
    downloaded earlier) to start the sqlmap API server listening at 127.0.0.1 (on
    port 8775 by default), as shown in [Listing 9-2](#filepos627726).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于sqlmap REST API的官方文档有些简略，但本书涵盖了使用它所需的所有内容。首先，运行sqlmapapi.py --server（位于你之前下载的sqlmap项目目录的根目录）以启动sqlmap
    API服务器，监听127.0.0.1（默认端口为8775），如[清单 9-2](#filepos627726)所示。
- en: $ ./sqlmapapi.py --server
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./sqlmapapi.py --server
- en: '[22:56:24] [INFO] Running REST-JSON API server at ''127.0.0.1:8775''..'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[22:56:24] [INFO] 正在运行REST-JSON API服务器，地址为''127.0.0.1:8775''..'
- en: '[22:56:24] [INFO] Admin ID: 75d9b5817a94ff9a07450c0305c03f4f'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[22:56:24] [INFO] 管理员ID: 75d9b5817a94ff9a07450c0305c03f4f'
- en: '[22:56:24] [DEBUG] IPC database: /tmp/sqlmapipc-34A3Nn'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[22:56:24] [DEBUG] IPC数据库: /tmp/sqlmapipc-34A3Nn'
- en: '[22:56:24] [DEBUG] REST-JSON API server connected to IPC database Listing 9-2:
    Starting the sqlmap server'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[22:56:24] [DEBUG] REST-JSON API服务器已连接至IPC数据库 列表9-2: 启动sqlmap服务器'
- en: sqlmap has several REST API endpoints that we need to create our automated tool.
    In order to use sqlmap, we need to create tasks and then use API requests to act
    on those tasks. Most of the available endpoints use GET requests, which are meant
    to retrieve data. To see what GET API endpoints are available, run rgrep "@get".
    from the root of the sqlmap project directory, as shown in [Listing 9-3](#filepos629313).
    This command lists many of the available API endpoints, which are special URLs
    used in the API for certain actions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap有几个REST API端点，我们需要使用它们来创建自动化工具。为了使用sqlmap，我们需要创建任务，然后使用API请求来处理这些任务。大多数可用的端点使用GET请求，旨在检索数据。要查看可用的GET
    API端点，可以在sqlmap项目根目录下运行rgrep "@get"，如[列表9-3](#filepos629313)所示。此命令列出了许多可用的API端点，它们是API中用于某些操作的特殊URL。
- en: $ rgrep "@get" .
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ rgrep "@get" .
- en: lib/utils/api.py:@get("/task/new➊")
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/task/new➊")
- en: lib/utils/api.py:@get("/task/taskid/delete➋")
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/task/taskid/delete➋")
- en: lib/utils/api.py:@get("/admin/taskid/list")
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/admin/taskid/list")
- en: lib/utils/api.py:@get("/admin/taskid/flush")
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/admin/taskid/flush")
- en: lib/utils/api.py:@get("/option/taskid/list")
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/option/taskid/list")
- en: lib/utils/api.py:@get("/scan/taskid/stop➌")
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@get("/scan/taskid/stop➌")
- en: --snip--
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: 'Listing 9-3: Available sqlmap REST API GET requests'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '列表9-3: 可用的sqlmap REST API GET请求'
- en: Soon we’ll cover how to use the API endpoints to create ➊, stop ➌, and delete
    ➋ sqlmap tasks. You can replace @get in this command with @post to see the API’s
    available endpoints for POST requests. Only three API calls require an HTTP POST
    request, as shown in [Listing 9-4](#filepos630337).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很快我们将介绍如何使用API端点来创建➊、停止➌和删除➋sqlmap任务。你可以将此命令中的@get替换为@post，以查看API的可用端点，处理POST请求。只有三个API调用需要HTTP
    POST请求，如[列表9-4](#filepos630337)所示。
- en: $ rgrep "@post" .
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ rgrep "@post" .
- en: lib/utils/api.py:@post("/option/taskid/get")
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@post("/option/taskid/get")
- en: lib/utils/api.py:@post("/option/taskid/set")
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lib/utils/api.py:@post("/option/taskid/set")
- en: 'lib/utils/api.py:@post("/scan/taskid/start") Listing 9-4: REST API endpoints
    for POST requests'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'lib/utils/api.py:@post("/scan/taskid/start") 列表9-4: 用于POST请求的REST API端点'
- en: When using the sqlmap API, we need to create a task to test a given URL for
    SQL injections. Tasks are identified by their task ID, which we enter in place
    of taskid in the API options in [Listings 9-3](#filepos629313) and [9-4](#filepos630337).
    We can use curl to test the sqlmap server to ensure it is running properly and
    to get a feel for how the API behaves and the data it sends back. This will give
    us a good idea of how our C# code is going to work when we begin writing our sqlmap
    classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用sqlmap API时，我们需要创建一个任务，以测试给定的URL是否存在SQL注入。任务通过其任务ID来标识，我们将在[列表9-3](#filepos629313)和[9-4](#filepos630337)中的API选项中用任务ID替换taskid。我们可以使用curl测试sqlmap服务器，确保它正常运行，并且对API的行为和返回的数据有所了解。这将帮助我们更好地理解当我们开始编写sqlmap类时，我们的C#代码将如何工作。
- en: Testing the sqlmap API with curl
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl测试sqlmap API
- en: Normally, sqlmap is run on the command line using the Python script we covered
    earlier in this chapter, but the Python commands will hide what sqlmap is doing
    on the backend and won’t give us insight into how each API call will work. To
    get a feel for using the sqlmap API directly, we’ll use curl, which is a command
    line tool generally used to make HTTP requests and see the responses to those
    requests. For example, [Listing 9-5](#filepos632101) shows how to make a new sqlmap
    task by calling to the port sqlmap is listening to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，sqlmap是在命令行中通过我们在本章之前讨论过的Python脚本运行的，但Python命令会隐藏sqlmap在后台的操作，不能让我们看到每个API调用如何工作。为了直接体验使用sqlmap
    API，我们将使用curl，它是一个通常用于发送HTTP请求并查看请求响应的命令行工具。例如，[列表9-5](#filepos632101)展示了如何通过调用sqlmap正在监听的端口来创建一个新的sqlmap任务。
- en: $ curl ➊127.0.0.1:8775/task/new
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl ➊127.0.0.1:8775/task/new
- en: '{'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '➋"taskid": "dce7f46a991c5238",'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➋"taskid": "dce7f46a991c5238",'
- en: '"success": true'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"success": true'
- en: '}'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-5: Creating a new sqlmap task with curl'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '列表9-5: 使用curl创建一个新的sqlmap任务'
- en: Here, the port is 127.0.0.1:8775 ➊. This returns a new task ID after the taskid
    key and a colon ➋. Make sure that your sqlmap server is running as in [Listing
    9-2](#filepos627726) before making this HTTP request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，端口是 127.0.0.1:8775 ➊。这会在任务 ID 后返回一个新任务 ID，并且跟随一个冒号 ➋。在发送此 HTTP 请求之前，请确保你的
    sqlmap 服务器正在运行，正如在[示例9-2](#filepos627726)中所示。
- en: After making a simple GET request with curl to the /task/new endpoint, sqlmap
    returns a new task ID for us to use. We’ll use this task ID to make other API
    calls later, including starting and stopping the task and getting the task results.
    To view a list of all scan options for a given task ID available for use with
    sqlmap, call the /option/taskid/list endpoint and substitute the ID you created
    earlier, as shown in [Listing 9-6](#filepos634250). Note we are using the same
    task ID in the API endpoint request that was returned in [Listing 9-5](#filepos632101).
    Knowing the options for a task is important for starting the SQL injection scan
    later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在用 curl 向 /task/new 端点发送简单的 GET 请求后，sqlmap 会返回一个新的任务 ID，供我们使用。我们将使用这个任务 ID 进行其他
    API 调用，包括启动和停止任务以及获取任务结果。要查看给定任务 ID 所有可用的扫描选项列表，可以调用 /option/taskid/list 端点，并替换为你之前创建的
    ID，如[示例9-6](#filepos634250)所示。请注意，我们在 API 端点请求中使用的是与[示例9-5](#filepos632101)中返回的任务
    ID 相同的任务 ID。了解任务的选项对于稍后启动 SQL 注入扫描非常重要。
- en: $ curl 127.0.0.1:8775/option/dce7f46a991c5238/list
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl 127.0.0.1:8775/option/dce7f46a991c5238/list
- en: '{'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"options": {'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"options": {'
- en: '"crawlDepth": null,'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"crawlDepth": null,'
- en: '"osShell": false,'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"osShell": false,'
- en: '➊"getUsers": false,'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➊"getUsers": false,'
- en: '➋"getPasswordHashes": false,'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➋"getPasswordHashes": false,'
- en: '"excludeSysDbs": false,'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"excludeSysDbs": false,'
- en: '"uChar": null,'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"uChar": null,'
- en: --snip--
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: '➌"tech": "BEUSTQ",'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➌"tech": "BEUSTQ",'
- en: '"textOnly": false,'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"textOnly": false,'
- en: '"commonColumns": false,'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"commonColumns": false,'
- en: '"keepAlive": false'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"keepAlive": false'
- en: '}'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-6: Listing the options for a given task ID'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-6：列出给定任务 ID 的选项
- en: Each of these task options corresponds with a command line argument from the
    command line sqlmap tool. These options tell sqlmap how it should perform a SQL
    injection scan and how it should exploit any injections it finds. Among the interesting
    options shown in [Listing 9-6](#filepos634250) is one for setting the injection
    techniques (tech) to test for; here it is set to the default BEUSTQ to test for
    all SQL injection types ➌. You also see options for dumping the user database,
    which is off in this example ➊, and dumping password hashes, which is also off
    ➋. If you are interested in what all the options do, run sqlmap --help at the
    command line to see the option descriptions and usage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务选项中的每一个都对应于命令行 sqlmap 工具中的命令行参数。这些选项告诉 sqlmap 如何执行 SQL 注入扫描，以及它应该如何利用发现的注入点。在[示例9-6](#filepos634250)中展示了其中一个有趣的选项，它用于设置要测试的注入技术（tech）；这里它被设置为默认的
    BEUSTQ，测试所有类型的 SQL 注入 ➌。你还可以看到用于导出用户数据库的选项，在这个例子中该选项被关闭 ➊，以及导出密码哈希的选项，这个选项也被关闭
    ➋。如果你对所有选项的作用感兴趣，可以在命令行中运行 sqlmap --help 查看选项的描述和用法。
- en: After creating our task and viewing its currently set options, we can set one
    of the options and then start a scan. To set specific options, we make a POST
    request and need to include some data that tells sqlmap what to set the options
    to. [Listing 9-7](#filepos636292) details starting a sqlmap scan with curl to
    test a new URL.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任务并查看其当前设置的选项后，我们可以设置其中一个选项并启动扫描。要设置特定选项，我们需要发送一个 POST 请求，并包含一些数据，告诉 sqlmap
    要设置哪些选项。[示例9-7](#filepos636292)详细说明了如何使用 curl 启动 sqlmap 扫描以测试新 URL。
- en: $ curl ➊-X POST ➋-H "Content-Type:application/json" \
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl ➊-X POST ➋-H "Content-Type:application/json" \
- en: ➌--data '{"url":"http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search"}'
    \
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌--data '{"url":"http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search"}'
    \
- en: ➍http://127.0.0.1:8775/scan/dce7f46a991c5238/start
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍http://127.0.0.1:8775/scan/dce7f46a991c5238/start
- en: '{'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"engineid": 7181,'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"engineid": 7181,'
- en: '"success": true➎'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"success": true➎'
- en: '}'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-7: Starting a scan with new options using the sqlmap API'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-7：使用 sqlmap API 以新选项启动扫描
- en: This POST request command looks different from the GET request in [Listing 9-5](#filepos632101),
    but it is actually very similar. First, we designate the command as a POST request
    ➊. Then we list the data to send to the API by placing the name of the option
    to set in quotes (such as "url"), followed by a colon, then the data to set the
    option to ➌. We designate the content of the data to be JSON using the -H argument
    to define a new HTTP header ➋, which ensures the Content-Type header will be correctly
    set to the application/json MIME-type for the sqlmap server. Then we start the
    command with a POST request using the same API call format as the GET request
    in [Listing 9-6](#filepos634250), with the endpoint /scan/taskid/start ➍.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 POST 请求命令看起来与 [示例 9-5](#filepos632101) 中的 GET 请求不同，但实际上非常相似。首先，我们将命令指定为 POST
    请求 ➊。然后，我们通过将设置选项的名称放在引号中（例如 "url"），后面跟一个冒号，再加上设置该选项的数据 ➌，来列出要发送到 API 的数据。我们使用
    -H 参数定义一个新的 HTTP 头来指定数据的内容类型为 JSON ➋，这确保了 sqlmap 服务器的 Content-Type 头会被正确设置为 application/json
    MIME 类型。然后，我们使用与 [示例 9-6](#filepos634250) 中的 GET 请求相同的 API 调用格式，发起一个 POST 请求，并指定端点
    /scan/taskid/start ➍。
- en: Once the scan has been started and sqlmap reports success ➎, we need to get
    the scan status. We can do that with a simple curl call using the status endpoint,
    as shown in [Listing 9-8](#filepos638064).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描启动后，sqlmap 报告成功 ➎，接下来我们需要获取扫描状态。我们可以使用简单的 curl 命令通过状态端点来实现，如 [示例 9-8](#filepos638064)
    所示。
- en: $ curl 127.0.0.1:8775/scan/dce7f46a991c5238/status
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl 127.0.0.1:8775/scan/dce7f46a991c5238/status
- en: '{'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '➊"status": "terminated",'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➊"status": "terminated",'
- en: '"returncode": 0,'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"returncode": 0,'
- en: '"success": true'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"success": true'
- en: '}'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-8: Getting the status of a scan'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-8: 获取扫描状态'
- en: After the scan has finished running, sqlmap will change the status of the scan
    to terminated ➊. Once the scan has terminated, we can use the log endpoint to
    retrieve the scan log and see whether sqlmap found anything during the scan, as
    [Listing 9-9](#filepos639457) shows.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描完成后，sqlmap 会将扫描的状态更改为 terminated ➊。扫描终止后，我们可以使用日志端点来检索扫描日志，并查看 sqlmap 在扫描过程中是否发现了任何问题，如
    [示例 9-9](#filepos639457) 所示。
- en: $ curl 127.0.0.1:8775/scan/dce7f46a991c5238/log
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl 127.0.0.1:8775/scan/dce7f46a991c5238/log
- en: '{'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"log": ['
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"log": ['
- en: '{'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '➊"message": "flushing session file",'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➊"message": "正在刷新会话文件",'
- en: '➋"level": "INFO",'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➋"level": "INFO",'
- en: '➌"time": "09:24:18"'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➌"time": "09:24:18"'
- en: '},'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"message": "testing connection to the target URL",'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"message": "正在测试与目标 URL 的连接",'
- en: '"level": "INFO",'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"level": "INFO",'
- en: '"time": "09:24:18"'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"time": "09:24:18"'
- en: '},'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: --snip--
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: '],'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '],'
- en: '"success": true'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"success": true'
- en: '}'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-9: Making a request for the scan log'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-9: 请求扫描日志'
- en: The sqlmap scan log is an array of statuses that includes the message ➊, message
    level ➋, and timestamp ➌ for each status. The scan log gives us great visibility
    into what happened during a sqlmap scan of a given URL, including any injectable
    parameters. Once we are done with the scan and have our results, we should go
    ahead and clean up to conserve resources. To delete the task we just created when
    we’re done with it, call /task/taskid/delete, as shown in [Listing 9-10](#filepos640641).
    Tasks can be freely created and deleted in the API, so feel free to create new
    tasks, play around with them, and then delete them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap 扫描日志是一个状态数组，每个状态都包括消息 ➊、消息级别 ➋ 和时间戳 ➌。扫描日志让我们能够清楚地看到在对给定 URL 进行 sqlmap
    扫描期间发生的事情，包括任何可注入的参数。一旦扫描完成并获得结果，我们应该进行清理以节省资源。当我们完成任务时，可以通过调用 /task/taskid/delete
    来删除刚创建的任务，如 [示例 9-10](#filepos640641) 所示。API 中可以自由创建和删除任务，因此可以随意创建新的任务，进行尝试，然后删除它们。
- en: $ curl 127.0.0.1:8775/task/dce7f46a991c5238/delete➊
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl 127.0.0.1:8775/task/dce7f46a991c5238/delete➊
- en: '{'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"success": true➋'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"success": true➋'
- en: '}'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-10: Deleting a task in the sqlmap API'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 9-10: 在 sqlmap API 中删除任务'
- en: After calling the /task/taskid/delete endpoint ➊, the API will return the task’s
    status and whether it was successfully deleted ➋. Now that we have the general
    workflow of creating, running, and deleting a sqlmap scan, we can begin working
    on our C# classes to automate the whole process from start to finish.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 /task/taskid/delete 端点 ➊ 后，API 将返回任务的状态以及是否成功删除 ➋。现在我们已经掌握了创建、运行和删除 sqlmap
    扫描的基本工作流程，可以开始着手编写 C# 类来自动化整个过程。
- en: Creating a Session for sqlmap
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为 sqlmap 创建会话
- en: No authentication is required to use the REST API, so we can easily use the
    session/manager pattern, which is a simple pattern similar to the other API patterns
    in previous chapters. This pattern allows us to separate the protocol’s transport
    (how we talk to the API) from the protocol’s exposed functionality (what the API
    can do). We’ll implement SqlmapSession and SqlmapManager classes to drive the
    sqlmap API to automatically find and exploit injections.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST API 不需要身份验证，因此我们可以轻松地使用会话/管理器模式，这是一种类似于前几章中其他 API 模式的简单模式。该模式允许我们将协议的传输（即如何与
    API 通信）与协议暴露的功能（即 API 可以做什么）分开。我们将实现 SqlmapSession 和 SqlmapManager 类，以驱动 sqlmap
    API 自动发现并利用注入漏洞。
- en: We’ll begin by writing the SqlmapSession class. This class, shown in [Listing
    9-11](#filepos643558), requires only a constructor and two methods called ExecuteGet()
    and ExecutePost(). These methods will do most of the heavy lifting of the two
    classes we’ll write. They will make the HTTP requests (one for GET requests and
    one for POST requests, respectively) that allow our classes to talk with the sqlmap
    REST API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写 SqlmapSession 类。该类如 [清单 9-11](#filepos643558) 所示，只需要一个构造函数和两个名为 ExecuteGet()
    和 ExecutePost() 的方法。这些方法将完成我们将编写的两个类的大部分工作。它们将发起 HTTP 请求（分别用于 GET 和 POST 请求），使我们的类能够与
    sqlmap REST API 进行通信。
- en: 'public class ➊SqlmapSession : IDisposable'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ➊SqlmapSession : IDisposable'
- en: '{'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: private string _host = string.Empty;
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private string _host = string.Empty;
- en: private int _port = 8775; //default port
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private int _port = 8775; // 默认端口
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➋SqlmapSession(string host, int port = 8775)
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➋SqlmapSession(string host, int port = 8775)
- en: '{'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _host = host;
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _host = host;
- en: _port = port;
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _port = port;
- en: '}'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➌ExecuteGet(string url)
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➌ExecuteGet(string url)
- en: '{'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return string.Empty;
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return string.Empty;
- en: '}'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➍ExecutePost(string url, string data)
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➍ExecutePost(string url, string data)
- en: '{'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return string.Empty;
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return string.Empty;
- en: '}'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public void ➎Dispose()
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void ➎Dispose()
- en: '{'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _host = null;
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _host = null;
- en: '}'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-11: The  SqlmapSession  class'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-11：SqlmapSession 类
- en: We start by creating a public class called SqlmapSession ➊ that will implement
    the IDisposable interface. This lets us use the SqlmapSession with a using statement,
    allowing us to write cleaner code with variables managed through garbage collection.
    We also declare two private fields, a host and a port, which we will use when
    making our HTTP requests. We assign the _host variable a value of string.Empty
    by default. This is a feature of C# that allows you to assign an empty string
    to a variable without actually instantiating a string object, resulting in a slight
    performance boost (but for now, it’s just to assign a default value). We assign
    the _port variable the port that sqlmap listens on, which is 8775, the default.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 SqlmapSession ➊ 的公共类，该类将实现 IDisposable 接口。这使我们能够在使用语句中使用 SqlmapSession，从而写出更简洁的代码，并通过垃圾回收管理变量。我们还声明了两个私有字段，一个主机和一个端口，我们将在发起
    HTTP 请求时使用它们。我们默认将 _host 变量赋值为 string.Empty。这是 C# 的一项特性，它允许你在不实际实例化字符串对象的情况下将空字符串赋值给变量，从而稍微提高性能（但目前只是为了赋一个默认值）。我们将
    _port 变量赋值为 sqlmap 监听的端口，默认为 8775。
- en: 'After declaring the private fields, we create a constructor that accepts two
    arguments ➋: the host and the port. We assign the private fields the values that
    are passed as the parameters to the constructor so we can connect to the correct
    API host and port. We also declare two stub methods for executing GET and POST
    requests that return string.Empty for the time being. We’ll define these methods
    next. The ExecuteGet() method ➌ only requires a URL as input. The ExecutePost()
    method ➍ requires a URL and the data to be posted. Finally, we write the Dispose()
    method ➎, which is required when implementing the IDisposable interface. Within
    this method, we clean up our private fields by assigning them a value of null.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明私有字段后，我们创建一个构造函数，接受两个参数 ➋：主机和端口。我们将私有字段赋值为传递给构造函数的参数值，以便连接到正确的 API 主机和端口。我们还声明了两个占位方法，用于执行
    GET 和 POST 请求，暂时返回 string.Empty。接下来，我们将定义这些方法。ExecuteGet() 方法 ➌ 只需要一个 URL 作为输入。ExecutePost()
    方法 ➍ 需要一个 URL 和要发布的数据。最后，我们编写 Dispose() 方法 ➎，这是实现 IDisposable 接口时必需的。在此方法中，我们通过将私有字段的值赋为
    null 来清理它们。
- en: Creating a Method to Execute a GET Request
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个执行 GET 请求的方法
- en: '[Listing 9-12](#filepos646610) shows how to use WebRequest to implement the
    first of the two stubbed methods to execute a GET request and return a string.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-12](#filepos646610) 显示了如何使用 WebRequest 实现两个被占位的方法中的第一个，以执行 GET 请求并返回一个字符串。'
- en: public string ExecuteGet(string url)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ExecuteGet(string url)
- en: '{'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.➊Create("http://" + _host +
    ":" + _port + url);
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest.➊Create("http://" + _host +
    ":" + _port + url);
- en: req.Method = "GET";
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Method = "GET";
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: ➋using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
- en: resp = rdr.➌ReadToEnd();
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.➌ReadToEnd();
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return resp;
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return resp;
- en: '}'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-12: The  ExecuteGet()  method'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-12：ExecuteGet() 方法
- en: We create a WebRequest ➊ with the _host, _port, and url variables to build a
    full URL and then set the Method property to GET. Next, we perform the request
    ➋ and read the response into a string with ReadToEnd() ➌, which is then returned
    to the caller method. When you implement SqlmapManager, you’ll use the Json.NET
    library to deserialize the JSON returned in the string so that you can easily
    pull values from it. Deserialization is the process of converting strings into
    JSON objects, and serialization is the opposite process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 _host、_port 和 url 变量创建一个 WebRequest ➊ 来构建完整的 URL，并将 Method 属性设置为 GET。接下来，我们执行请求
    ➋ 并通过 ReadToEnd() ➌ 将响应读取到字符串中，然后返回给调用方法。当你实现 SqlmapManager 时，你将使用 Json.NET 库来反序列化字符串中返回的
    JSON，以便轻松提取其中的值。反序列化是将字符串转换为 JSON 对象的过程，而序列化是相反的过程。
- en: Executing a POST Request
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 POST 请求
- en: The ExecutePost() method is only slightly more complex than the ExecuteGet()
    method. Since ExecuteGet() can only make simple HTTP requests, ExecutePost() will
    allow us to send complex requests with more data (such as JSON). It will also
    return a string containing the JSON response that will be deserialized by the
    SqlmapManager. [Listing 9-13](#filepos649306) shows how to implement the ExecutePost()
    method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutePost() 方法比 ExecuteGet() 方法稍微复杂一些。由于 ExecuteGet() 只能发起简单的 HTTP 请求，ExecutePost()
    允许我们发送包含更多数据（如 JSON）的复杂请求。它还将返回一个包含 JSON 响应的字符串，该字符串将被 SqlmapManager 反序列化。[示例
    9-13](#filepos649306) 展示了如何实现 ExecutePost() 方法。
- en: public string ExecutePost(string url, string data)
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ExecutePost(string url, string data)
- en: '{'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] buffer = ➊Encoding.ASCII.GetBytes(data);
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buffer = ➊Encoding.ASCII.GetBytes(data);
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://"+_host+":"+_port+url);
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://"+_host+":"+_port+url);
- en: req.Method = "POST"➋;
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Method = "POST"➋;
- en: req.ContentType = "application/json"➌;
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentType = "application/json"➌;
- en: req.ContentLength = buffer.Length;
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentLength = buffer.Length;
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream stream = req.GetRequestStream())
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream stream = req.GetRequestStream())
- en: stream.➍Write(buffer, 0, buffer.Length);
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.➍Write(buffer, 0, buffer.Length);
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: using (StreamReader r = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader r = new StreamReader(req.GetResponse().GetResponseStream()))
- en: resp = r.➎ReadToEnd();
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = r.➎ReadToEnd();
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return resp;
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return resp;
- en: '}'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-13: The  ExecutePost()  method'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-13：ExecutePost() 方法
- en: 'This is very similar to the code we wrote when fuzzing POST requests in [Chapters
    2](index_split_007.html#filepos114239) and [3](index_split_008.html#filepos243384).
    This method expects two arguments: an absolute URI and the data to be posted into
    the method. The Encoding class ➊ (available in the System.Text namespace) is used
    to create a byte array that represents the data to be posted. We then create a
    WebRequest object and set it up as we did for the ExecuteGet() method, except
    we set the Method to POST ➋. Notice that we also specify a ContentType of application/json
    ➌ and a ContentLength that matches the length of the byte array. Since we will
    be sending the server JSON data, we need to set the appropriate content type and
    length of our data in the HTTP request. We write ➍ the byte array to the request
    TCP stream (the connection between your computer and the HTTP server) once the
    WebRequest is set up, sending the JSON data to the server as the HTTP request
    body. Finally, we read ➎ the HTTP response into a string that is returned to the
    calling method.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第 2 章](index_split_007.html#filepos114239)和[第 3 章](index_split_008.html#filepos243384)进行
    POST 请求模糊测试时写的代码非常相似。此方法需要两个参数：一个绝对 URI 和要发送到方法的数据。Encoding 类 ➊（在 System.Text
    命名空间中可用）用于创建表示要发送数据的字节数组。然后，我们创建一个 WebRequest 对象并像在 ExecuteGet() 方法中一样进行设置，只是我们将
    Method 设置为 POST ➋。注意，我们还指定了 ContentType 为 application/json ➌，并且 ContentLength
    匹配字节数组的长度。由于我们将发送 JSON 数据到服务器，因此我们需要在 HTTP 请求中设置适当的内容类型和数据长度。WebRequest 设置完成后，我们通过
    ➍ 将字节数组写入请求的 TCP 流（即计算机与 HTTP 服务器之间的连接），将 JSON 数据作为 HTTP 请求体发送到服务器。最后，我们将 HTTP
    响应读取 ➎ 为一个字符串，并返回给调用方法。
- en: Testing the Session Class
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Session 类
- en: Now we are ready to write a small application to test the new SqlmapSession
    class in the Main() method. We’ll create a new task, call our methods, and then
    delete the task, as [Listing 9-14](#filepos652523) shows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写一个小应用程序，在`Main()`方法中测试新的SqlmapSession类。我们将创建一个新任务，调用我们的方法，然后删除该任务，如[清单9-14](#filepos652523)所示。
- en: public static void Main(string[] args)
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string host = ➊args[0];
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string host = ➊args[0];
- en: int port = int.Parse(args[1]);
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int port = int.Parse(args[1]);
- en: using (SqlmapSession session = new ➋SqlmapSession(host, port))
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (SqlmapSession session = new ➋SqlmapSession(host, port))
- en: '{'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string response = session.➌ExecuteGet("/task/new");
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string response = session.➌ExecuteGet("/task/new");
- en: JToken token = JObject.Parse(response);
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JToken token = JObject.Parse(response);
- en: string taskID = token.➍SelectToken("taskid").ToString();
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string taskID = token.➍SelectToken("taskid").ToString();
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➎Console.WriteLine("New task id: " + taskID);'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➎Console.WriteLine("新任务ID: " + taskID);'
- en: 'Console.WriteLine("Deleting task: " + taskID);'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("正在删除任务: " + taskID);'
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏response = session.ExecuteGet("/task/" + taskID + "/delete");
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏response = session.ExecuteGet("/task/" + taskID + "/delete");
- en: token = JObject.Parse(response);
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: token = JObject.Parse(response);
- en: bool success = (bool)token.➐SelectToken("success");
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool success = (bool)token.➐SelectToken("success");
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Delete successful: " + success);'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("删除成功: " + success);'
- en: '}'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 9-14: The  Main()  method of our sqlmap console application'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-14：我们sqlmap控制台应用程序的Main()方法
- en: The Json.NET library makes dealing with JSON in C# simple (as you saw in [Chapter
    5](index_split_010.html#filepos420379)). We grab the host and port from the first
    and second arguments passed into the program ➊, respectively. Then we use int.Parse()
    to parse the integer from the string argument for the port. Although we’ve been
    using port 8775 for this whole chapter, since the port is configurable (8775 is
    just the default), we shouldn’t assume it will be 8775 all the time. Once we have
    assigned values to the variables, we instantiate a new SqlmapSession ➋ using the
    parameters passed into the program. We then call the /task/new endpoint ➌ to retrieve
    a new task ID and use the JObject class to parse the JSON returned. Once we have
    the response parsed, we use the SelectToken() method ➍ to retrieve the value for
    the taskid key and assign this value to the taskID variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Json.NET库使得在C#中处理JSON变得简单（如你在[第5章](index_split_010.html#filepos420379)中看到的）。我们从程序传入的第一个和第二个参数分别获取host和port➊。然后我们使用int.Parse()将字符串参数解析为整数形式的端口。尽管我们在这一整章中一直使用端口8775，但由于端口是可配置的（8775只是默认值），我们不应该假设它总是8775。当我们为变量赋值后，我们使用传入程序的参数实例化一个新的SqlmapSession➋。然后我们调用/task/new端点➌来获取一个新的任务ID，并使用JObject类解析返回的JSON。一旦解析了响应，我们使用SelectToken()方法➍来获取taskid键的值，并将该值赋给taskID变量。
- en: NOTE
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A few standard types in C# have a Parse() method, like the int.Parse() method
    we just used. The int type is an Int32, so it will attempt to parse a 32-bit integer.
    Int16 is a short integer, so short.Parse() will attempt to parse a 16-bit integer.
    Int64 is a long integer, and long.Parse() will attempt to parse a 64-bit integer.
    Another useful Parse() method exists on the DateTime class. Each of these methods
    is static, so no object instantiation is necessary.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C#中的一些标准类型具有Parse()方法，就像我们刚才使用的int.Parse()方法一样。int类型是Int32，因此它将尝试解析一个32位整数。Int16是短整数，因此short.Parse()将尝试解析一个16位整数。Int64是长整数，long.Parse()将尝试解析一个64位整数。DateTime类上也有一个有用的Parse()方法。这些方法都是静态的，因此不需要实例化对象。
- en: After printing the new taskID to the console ➎, we can delete the task by calling
    the /task/taskid/delete endpoint ➏. We again use the JObject class to parse the
    JSON response and then retrieve the value for the success key ➐, cast it as a
    Boolean, and assign it to the success variable. This variable is printed to the
    console, showing the user whether the task was successfully deleted. When you
    run the tool, it produces output about creating and deleting a task, as shown
    in [Listing 9-15](#filepos655824).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新任务ID打印到控制台➎后，我们可以通过调用/task/taskid/delete端点➏来删除任务。我们再次使用JObject类来解析JSON响应，然后获取success键的值➐，将其转换为布尔值，并赋值给success变量。这个变量会被打印到控制台，显示任务是否成功删除。当你运行该工具时，它会输出关于创建和删除任务的内容，如[清单9-15](#filepos655824)所示。
- en: $ mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775
- en: 'New task id: 96d9fb9d277aa082'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '新任务ID: 96d9fb9d277aa082'
- en: 'Deleting task: 96d9fb9d277aa082'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '删除任务: 96d9fb9d277aa082'
- en: 'Delete successful: True Listing 9-15: Running the program that creates a sqlmap
    task and then deletes it'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '删除成功: True 清单9-15：运行创建sqlmap任务并删除它的程序'
- en: Once we know we can successfully create and delete a task, we can create the
    SqlmapManager class to encapsulate the API functionality we want to use in the
    future, such as setting scan options and getting the scan results.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The SqlmapManager Class
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The SqlmapManager class, shown in [Listing 9-16](#filepos657962), wraps the
    methods exposed through the API in an easy-to-use (and maintainable!) way. When
    we finish writing the methods needed for this chapter, we can start a scan on
    a given URL, watch it until it completes, and then retrieve the results and delete
    the task. We’ll also make heavy use of the Json.NET library. To reiterate, the
    goal of the session/manager pattern is to separate the transport of the API from
    the functionality exposed by the API. An added benefit to this pattern is that
    it allows the programmer using the library to focus on the results API calls.
    The programmer can, however, still interact directly with the session if needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊SqlmapManager : IDisposable'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private ➋SqlmapSession _session = null;
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➌SqlmapManager(SqlmapSession session)
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (session == null)
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: throw new ArgumentNullException("session");
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = session;
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void ➍Dispose()
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session.Dispose();
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = null;
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-16: The  SqlmapManager  class'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We declare the SqlmapManager class ➊ and have it implement the IDisposable interface.
    We also declare a private field ➋ for the SqlmapSession that will be used throughout
    the class. Then, we create the SqlmapManager constructor ➌, which accepts a SqlmapSession,
    and we assign the session to the private _session field.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implement the Dispose() method ➍, which cleans up the private SqlmapSession.
    You may wonder why we have both the SqlmapSession and SqlmapManager implement
    IDisposable, when in the Dispose() method of the SqlmapManager, we call Dispose()
    on the SqlmapSession as well. A programmer may want to instantiate only a SqlmapSession
    and interact with it directly in case a new API endpoint is introduced that the
    manager hasn’t been updated to support. Having both classes implement IDisposable
    offers the greatest flexibility.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Since we just implemented the methods needed to create a new task and delete
    an existing one when we tested the SqlmapSession class in [Listing 9-14](#filepos652523),
    we’ll add these actions as their own methods to the SqlmapManager class above
    the Dispose() method, as shown in [Listing 9-17](#filepos660615).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: public string NewTask()
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JToken tok = JObject.Parse(_session.ExecuteGet("/task/new"));
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊return tok.SelectToken("taskid").ToString();
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool DeleteTask(string taskid)
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JToken tok = Jobject.Parse(session.ExecuteGet("/task/" + taskid + "/delete"));
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋return (bool)tok.SelectToken("success");
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-17: The  NewTask()  and  DeleteTask()  methods to manage a task in
    sqlmap'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The NewTask() and DeleteTask() methods make it easy to create and delete tasks
    as we need in the SqlmapManager class and are nearly identical to the code in
    [Listing 9-14](#filepos652523), except that they print less output and return
    the task ID after creating a new task ➊ or the result (success or failure) of
    deleting a task ➋.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use these new methods to rewrite the previous command line application
    testing the SqlmapSession class, as seen in [Listing 9-18](#filepos662569).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string host = args[0];
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int port = int.Parse(args[1]);
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (SqlmapManager mgr = new SqlmapManager(new SqlmapSession(host, port)))
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string taskID = mgr.➊NewTask();
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Created task: " + taskID);'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Deleting task");
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool success = mgr.➋DeleteTask(taskID);
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Delete successful: " + success);'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '} //clean up and dispose manager automatically'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-18: Rewriting the application to use the  SqlmapManager  class'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: This code is more intuitive to read and easier to understand at a quick glance
    than the original application in [Listing 9-14](#filepos652523). We’ve replaced
    the code to create and delete tasks with the NewTask() ➊ and DeleteTask() ➋ methods.
    By just reading the code, you have no idea that the API uses HTTP as its transport
    or that we are dealing with JSON responses.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Listing sqlmap Options
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The next method we’ll implement (shown in [Listing 9-19](#filepos664854)) retrieves
    the current options for tasks. One thing to note is that because sqlmap is written
    in Python, it’s weakly typed. This means that a few of the responses will have
    a mixture of types that are a bit difficult to deal with in C#, which is strongly
    typed. JSON requires all keys to be strings, but the values in the JSON will have
    different types, such as integers, floats, Booleans, and strings. What this means
    for us is that we must treat all the values as generically as possible on the
    C# side of things. To do that, we’ll treat them as simple objects until we need
    to know their types.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: public Dictionary<string, object> ➊GetOptions(string taskid)
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<string, object> options = ➋new Dictionary<string, object>();
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject tok = JObject.➌Parse(_session.ExecuteGet ("/option/" + taskid + "/list"));
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tok = tok["options"] as JObject;
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍foreach (var pair in tok)
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options.Add(pair.Key, ➎pair.Value);
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➏options;
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-19: The  GetOptions()  method'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The GetOptions() method ➊ in [Listing 9-19](#filepos664854) accepts a single
    argument: the task ID to retrieve the options for. This method will use the same
    API endpoint we used in [Listing 9-5](#filepos632101) when testing the sqlmap
    API with curl. We begin the method by instantiating a new Dictionary ➋ that requires
    the key to be a string but allows you to store any kind of object as the other
    value of the pair. After making the API call to the options endpoint and parsing
    the response ➌, we loop ➍ through the key/value pairs in the JSON response from
    the API and add them to the options dictionary ➎. Finally, the currently set options
    for the task are returned ➏ so that we can update them and use them later when
    we start the scan.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this dictionary of options in the StartTask() method, which we’ll
    implement soon, to pass options as an argument to start a task with. First, though,
    go ahead and add the following lines in [Listing 9-20](#filepos666802) to your
    console application after calling mgr.NewTask() but before deleting the task with
    mgr.DeleteTask().
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary<string, object> ➊options = mgr.GetOptions(➋taskID);
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌ foreach (var pair in options)
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Key: " + pair.Key + "\t:: Value: " + pair.Value); Listing
    9-20: Lines appended to the main application to retrieve and print the current
    task options'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this code, a taskID is given to GetOptions() ➋ as an argument, and the returned
    options dictionary is assigned to a new Dictionary, which is also called options
    ➊. The code then loops through options and prints each of its key/value pairs
    ➌. After adding these lines, rerun your application in your IDE or in the console,
    and you should see the full list of options you can set with their current values
    printed to the console. This is shown in [Listing 9-21](#filepos668338).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: $ mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: crawlDepth ::Value:'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: osShell ::Value: False'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: getUsers ::Value: False'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: getPasswordHashes ::Value: False'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: excludeSysDbs ::Value: False'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: uChar ::Value:'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: regData ::Value:'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: prefix ::Value:'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key: code ::Value:'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-21: Printing the task options to the screen after retrieving them
    with GetOptions()'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re able to see task options, it’s time to perform a scan.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Making a Method to Perform Scans
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to prepare our task to perform a scan. Within our options dictionary,
    we have a key that’s a url, which is the URL we’ll test for SQL injections. We
    pass the modified Dictionary to a new StartTask() method, which posts the dictionary
    as a JSON object to the endpoint and uses the new options when the task begins.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Using the Json.NET library makes the StartTask() method super short because
    it takes care of all the serialization and deserialization for us, as [Listing
    9-22](#filepos669967) shows.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: public bool StartTask(string taskID, Dictionary<string, object> opts)
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string json = JsonConvert.➊SerializeObject(opts);
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JToken tok = JObject.➋Parse(session.ExecutePost("/scan/"+taskID+"/start", json));
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌return(bool)tok.SelectToken("success");
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-22: The  StartTask()  method'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: We use the Json.NET JsonConvert class to convert a whole object into JSON. The
    SerializeObject() method ➊ is used to get a JSON string representing the options
    dictionary that we can post to the endpoint. Then we make the API request and
    parse the JSON response ➋. Finally, we return ➌ the value of the success key from
    the JSON response, which is hopefully true. This JSON key should always be present
    in the response for this API call, and it will be true when the task was started
    successfully or false if the task was not started.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: It would also be useful to know when a task is complete. This way, you know
    when you can get the full log of the task and when to delete the task. To get
    the task’s status, we implement a small class (shown in [Listing 9-23](#filepos671779))
    that represents a sqlmap status response from the /scan/taskid/status API endpoint.
    This can be added in a new class file if you like, even though it’s a super-short
    class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: public class SqlmapStatus
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊public string Status { get; set; }
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋public int ReturnCode { get; set; }
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-23: The  SqlmapStatus  class'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'For the SqlmapStatus class, we don’t need to define a constructor because,
    by default, every class has a public constructor. We do define two public properties
    on the class: a string status message ➊ and the integer return code ➋. To get
    the task status and store it in SqlmapStatus, we implement GetScanStatus, which
    takes a taskid as input and returns a SqlmapStatus object.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The GetScanStatus() method is shown in [Listing 9-24](#filepos673361).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: public SqlmapStatus GetScanStatus(string taskid)
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject tok = JObject.Parse(_session.➊ExecuteGet("/scan/" + taskid + "/status"));
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SqlmapStatus stat = ➋new SqlmapStatus();
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: stat.Status = (string)tok["status"];
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (tok["returncode"].Type != JTokenType.Null➌)
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: stat.ReturnCode = (int)tok["returncode"];
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍return stat;
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-24: The  GetScanStatus()  method'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We use the ExecuteGet() method we defined earlier to retrieve the /scan/taskid/status
    API endpoint ➊, which returns a JSON object with information about the task’s
    scan status. After calling the API endpoint, we create a new SqlmapStatus object
    ➋ and assign the status value from the API call to the Status property. If the
    returncode JSON value isn’t null ➌, we cast it to an integer and assign the result
    to the ReturnCode property. Finally, we return ➍ the SqlmapStatus object to the
    caller.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The New Main() Method
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll add the logic to the command line application so that we can scan
    the vulnerable Search page within BadStore that we exploited in [Chapter 2](index_split_007.html#filepos114239)
    and monitor the scan. Begin by adding the code shown in [Listing 9-25](#filepos675728)
    to the Main() method before you call DeleteTask.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: options["url"] = ➊"http://192.168.1.75/cgi-bin/badstore.cgi?" +
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"searchquery=fdsa&action=search";'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋mgr.StartTask(taskID, options);
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌SqlmapStatus status = mgr.GetScanStatus(taskID);
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍while (status.Status != "terminated")
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Threading.Thread.Sleep(new TimeSpan(0,0,10));
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: status = mgr.GetScanStatus(taskID);
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➎ Console.WriteLine("Scan finished!"); Listing 9-25: Starting a scan and watching
    it finish in the main sqlmap application'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Replace the IP address ➊ with that of the BadStore you wish to scan. After the
    application assigns the url key in the options dictionary, it will start the task
    with the new options ➋ and get the scan status ➌, which should be running. Then,
    the application will loop ➍ until the status of the scan is terminated, which
    means the scan has finished. The application will print "Scan finished!" ➎ once
    it exits the loop.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Reporting on a Scan
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: To see if sqlmap was able to exploit any of the vulnerable parameters, we’ll
    create a SqlmapLogItem class to retrieve the scan log, as shown in [Listing 9-26](#filepos677165).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: public class SqlmapLogItem
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Message { get; set; }
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Level { get; set; }
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Time { get; set; }
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-26: The  SqlmapLogItem  class'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has only three properties: Message, Level, and Time. The Message
    property contains the message describing the log item. Level controls how much
    information sqlmap will print in the report, which will be Error, Warn, or Info.
    Each log item has only one of these levels, which makes it easy to search for
    specific types of log items later (say, when you just want to print the errors
    but not the warnings or informational items). Errors are generally fatal, while
    warnings mean something seems wrong but sqlmap can keep going. Informational items
    are just that: basic information about what the scan is doing or finding, such
    as the type of injection being tested for. Finally, Time is the time the item
    was logged.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implement the GetLog() method to return a list of these SqlmapLogItems
    and then retrieve the log by executing a GET request on the /scan/taskid/log endpoint,
    as shown in [Listing 9-27](#filepos679681).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: public List<SqlmapLogItem> GetLog(string taskid)
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject tok = JObject.Parse(session.➊ExecuteGet("/scan/" + taskid + "/log"));
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JArray items = tok ["log"]➋ as JArray;
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<SqlmapLogItem> logItems = new List<SqlmapLogItem>();
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌foreach (var item in items)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍SqlmapLogItem i = new SqlmapLogItem(); i.Message = (string)item["message"];
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i.Level = (string)item["level"];
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i.Time = (string)item["time"];
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: logItems.Add(i);
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎return logItems;
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-27: The  GetLog()  method'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the GetLog() method is make the request to the endpoint
    ➊ and parse the request into a JObject. The log key ➋ has an array of items as
    its value, so we pull its value as a JArray using the as operator and assign it
    to the items variable ➌. This may be the first time you have seen the as operator.
    My main reason for using it is readability, but the primary difference between
    the as operator and explicit casting is that as will return null if the object
    to the left cannot be cast to the type on the right. You can’t use it on value
    types because value types can’t be null.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an array of log items, we create a list of SqlmapLogItems. We loop
    over each item in the array and instantiate a new SqlmapLogItem each time ➍. Then
    we assign the new object the value in the log item returned by sqlmap. Finally,
    we add the log item to the list and return the list to the caller method ➎.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Automating a Full sqlmap Scan
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We’ll call GetLog() from the console application after the scan terminates and
    print the log messages to the screen. Your application’s logic should look like
    [Listing 9-28](#filepos683137) now.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (SqlmapManager manager = new SqlmapManager(session))
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string taskid = manager.NewTask();
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<string, object> options = manager.GetOptions(taskid);
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["url"] = args[0];
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["flushSession"] = true;
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manager.StartTask(taskid, options);
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SqlmapStatus status = manager.GetScanStatus(taskid);
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (status.Status != "terminated")
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Threading.Thread.Sleep(new TimeSpan(0,0,10));
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: status = manager.GetScanStatus(taskid);
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<SqlmapLogItem> logItems = manager.➊GetLog(taskid);
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SqlmapLogItem item in logItems)
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋Console.WriteLine(item.Message);
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manager.DeleteTask(taskid);
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-28: The full  Main()  method to automate sqlmap to scan a URL'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: After adding the call to GetLog() ➊ to the end of the sqlmap main application,
    we can iterate over the log messages and print them to the screen ➋ for us to
    see when the scan is finished. Finally, we are ready to run the full sqlmap scan
    and retrieve the results. Passing the BadStore URL as an argument to the application
    will send the scan request to sqlmap. The results should look something like [Listing
    9-29](#filepos686144).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch9_automating_sqlmap.exe "http://10.37.129.3/cgi-bin/badstore.cgi?
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: searchquery=fdsa&action=search"
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: flushing session file
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testing connection to the target URL
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: heuristics detected web page charset 'windows-1252'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: checking if the target is protected by some kind of WAF/IPS/IDS
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testing if the target URL is stable
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: target URL is stable
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testing if GET parameter 'searchquery' is dynamic
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: confirming that GET parameter 'searchquery' is dynamic
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GET parameter 'searchquery' is dynamic
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: heuristics detected web page charset 'ascii'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: heuristic (basic) test shows that GET parameter 'searchquery' might be
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: injectable
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(possible DBMS: ''MySQL'')'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: –-snip--
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GET parameter 'searchquery➊' seems to be 'MySQL <= 5.0.11 OR time-based blind
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (heavy query)' injectable
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: testing 'Generic UNION query (NULL) - 1 to 20 columns'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: automatically extending ranges for UNION query injection technique tests as
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: there is at least one other (potential) technique found
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ORDER BY technique seems to be usable. This should reduce the time needed to
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: find the right number of query columns. Automatically extending the range for
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: current UNION query injection technique test
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: target URL appears to have 4 columns in query
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GET parameter 'searchquery➋' is 'Generic UNION query (NULL) - 1 to 20
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: columns' injectable
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the back-end DBMS is MySQL➌
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-29: Running the sqlmap application on a vulnerable BadStore URL'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: It works! The output from sqlmap can be very verbose and potentially confusing
    for someone not used to reading it. But even though it can be a lot to take in,
    there are key points to look for. As you can see in the output, sqlmap finds that
    the searchquery parameter is vulnerable to a time-based SQL injection ➊, that
    there is a UNION-based SQL injection ➋, and that the database is MySQL ➌. The
    rest of the messages are information regarding what sqlmap is doing during the
    scan. With these results, we can definitely say this URL is vulnerable to at least
    two SQL injection techniques.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Integrating sqlmap with the SOAP Fuzzer
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to use the sqlmap API to audit and exploit a simple URL.
    In [Chapters 2](index_split_007.html#filepos114239) and [3](index_split_008.html#filepos243384),
    we wrote a few fuzzers for vulnerable GET and POST requests in SOAP endpoints
    and JSON requests. We can use the information we gather from our fuzzers to drive
    sqlmap and, with only a few more lines of code, go from finding potential vulnerabilities
    to fully validating and exploiting them.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Adding sqlmap GET Request Support to the SOAP Fuzzer
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two types of HTTP requests are made in the SOAP fuzzer: GET and POST requests.
    First, we add support to our fuzzer so it will send URLs with GET parameters to
    sqlmap. We also want the ability to tell sqlmap which parameter we think is vulnerable.
    We add the methods TestGetRequestWithSqlmap() and TestPostRequestWithSqlmap()
    to the bottom of the SOAP fuzzer console application to test GET and POST requests,
    respectively. We’ll also update the FuzzHttpGetPort(), FuzzSoapPort(), and FuzzHttpPostPort()
    methods in a later section to use the two new methods.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by writing the TestGetRequestWithSqlmap() method, shown in [Listing
    9-30](#filepos689714).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: static void TestGetRequestWithSqlmap(string url, string parameter)
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Testing url with sqlmap: " + url);'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (SqlmapManager manager = new SqlmapManager(session))
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋string taskID = manager.NewTask();
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌var options = manager.GetOptions(taskID);
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["url"] = url;
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["level"] = 1;
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["risk"] = 1;
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["dbms"] = ➍"postgresql";
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["testParameter"] = ➎parameter;
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["flushSession"] = true;
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'manager.➏StartTask(taskID, options); Listing 9-30: First half of the  TestGetRequestWithSqlmap()  method'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first half of the method creates our SqlmapSession ➊ and SqlmapManager objects,
    which we call session and manager, respectively. Then it creates a new task ➋
    and retrieves and sets up the sqlmap options for our scan ➌. We explicitly set
    the DBMS to PostgreSQL ➍ since we know the SOAP service uses PostgreSQL. This
    saves us some time and bandwidth by testing only PostgreSQL payloads. We also
    set the testParameter option to the parameter we decided is vulnerable ➎ after
    previously testing it with a single apostrophe and receiving an error from the
    server. We then pass the task ID and the options to the StartTask() method ➏ of
    manager to begin the scan.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-31](#filepos691903) details the second half of the TestGetRequestWithSqlmap()
    method, similar to the code we wrote in [Listing 9-25](#filepos675728).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: SqlmapStatus status = manager.GetScanStatus(taskid);
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (status.Status != ➊"terminated")
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Threading.Thread.Sleep(new TimeSpan(0,0,10));
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: status = manager.GetScanStatus(taskID);
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<SqlmapLogItem> logItems = manager.➋GetLog(taskID);
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SqlmapLogItem item in logItems)
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.➌WriteLine(item.Message);
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manager.➍DeleteTask(taskID);
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-31: The second half of the  TestGetRequestWithSqlmap()  method'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the method watches the scan until it is finished, just like
    in our original test application. Since we have written similar code before, I
    won’t go over every line. After waiting until the scan is finished running ➊,
    we retrieve the scan results using GetLog() ➋. We then write the scan results
    to the screen ➌ for the user to see. Finally, the task is deleted when the task
    ID is passed to the DeleteTask() method ➍.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Adding sqlmap POST Request Support
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The TestPostRequestWithSqlmap() method is a bit more complex than its companion.
    [Listing 9-32](#filepos694132) shows the beginning lines of the method.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: static void TestPostRequestWithSqlmap(➊string url, string data,
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string soapAction, string vulnValue)
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➋Console.WriteLine("Testing url with sqlmap: " + url);'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (SqlmapManager manager = new SqlmapManager(session))
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍string taskID = manager.NewTask();
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: var options = manager.GetOptions(taskID);
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["url"] = url;
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["level"] = 1;
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["risk"] = 1;
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["dbms"] = "postgresql";
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["data"] = data.➎Replace(vulnValue, "*").Trim();
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'options["flushSession"] = "true"; Listing 9-32: Beginning lines of the  TestPostRequestWithSqlmap()  method'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The TestPostRequestWithSqlmap() method accepts four arguments ➊. The first argument
    is the URL that will be sent to sqlmap. The second argument is the data that will
    be in the post body of the HTTP request—be it POST parameters or SOAP XML. The
    third argument is the value that will be passed in the SOAPAction header in the
    HTTP request. The last argument is the unique value that is vulnerable. It will
    be replaced with an asterisk in the data from the second argument before being
    sent to sqlmap to fuzz.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: After we print a message to the screen to tell the user which URL is being tested
    ➋, we create our SqlmapSession and SqlmapManager objects ➌. Then, as before, we
    create a new task and set the current options ➍. Pay special attention to the
    data option ➎. This is where we replace the vulnerable value in the post data
    with an asterisk. The asterisk is a special notation in sqlmap that says, “Ignore
    any kind of smart parsing of the data and just search for a SQL injection in this
    specific spot.”
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: We still need to set one more option before we can start the task. We need to
    set the correct content type and SOAP action in the HTTP headers in the request.
    Otherwise, the server will just return 500 errors. This is what the next part
    of the method does, as detailed in [Listing 9-33](#filepos696464).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: string headers = string.Empty;
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (!string.➊IsNullOrWhitespace(soapAction))
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'headers = "Content-Type: text/xml\nSOAPAction: " + ➋soapAction;'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'headers = "Content-Type: application/x-www-form-urlencoded";'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: options["headers"] = ➌headers;
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'manager.StartTask(taskID, options); Listing 9-33: Setting the right headers
    in the  TestPostRequestWithSqlmap()  method'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the soapAction variable ➋ (the value we want in the SOAPAction header telling
    the SOAP server the action we want to perform) is null or an empty string ➊, we
    can assume this is not an XML request but rather a POST parameter request. The
    latter only requires the correct Content-Type to be set to x-www-form-urlencoded.
    If soapAction is not an empty string, however, we should assume we are dealing
    with an XML request and then set the Content-Type to text/xml and add a SOAPAction
    header with the soapAction variable as the value. After setting the correct headers
    in the scan options ➌, we finally pass the task ID and the options to the StartTask()
    method.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the method, shown in [Listing 9-34](#filepos698752), should look
    familiar. It just watches the scan and returns the results, much as does the TestGetRequestWithSqlmap()
    method.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: SqlmapStatus status = manager.➊GetScanStatus(taskID);
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (status.Status != "terminated")
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Threading.Thread.➋Sleep(new TimeSpan(0,0,10));
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: status = manager.GetScanStatus(taskID);
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<SqlmapLogItem> logItems = manager.➌GetLog(taskID);
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SqlmapLogItem item in logItems)
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.➍WriteLine(item.Message);
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manager.➎DeleteTask(taskID);
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-34: The final lines in the  TestPostRequestWithSqlmap()  method'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly like the code in [Listing 9-25](#filepos675728). We use the
    GetScanStatus() method ➊ to retrieve the current status of the task, and while
    the status isn’t terminated, we sleep for 10 seconds ➋. Then we get the status
    again. Once finished, we pull the log items ➌ and iterate over each item, printing
    the log message ➍. Finally, we delete the task ➎ when all is done.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Calling the New Methods
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: In order to complete our utility, we need to call these new methods from their
    respective fuzzing methods in the SOAP fuzzer. First, we update the FuzzSoapPort()
    method that we made in [Chapter 3](index_split_008.html#filepos243384) by adding
    the method call for TestPostRequestWithSqlmap() into the if statement that tests
    whether a syntax error has occurred due to our fuzzing, as shown in [Listing 9-35](#filepos700608).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: if (➊resp.Contains("syntax error"))
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.➋WriteLine("Possible SQL injection vector in parameter: " +'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: type.Parameters[k].Name);
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌TestPostRequestWithSqlmap(_endpoint, soapDoc.ToString(),
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: op.SoapAction, parm.ToString());
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-35: Adding support to use sqlmap to the  FuzzSoapPort()  method in
    the SOAP fuzzer from [Chapter 3](index_split_008.html#filepos243384)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: In our original SOAP fuzzer in the FuzzSoapPort() method at the very bottom,
    we tested whether the response came back with an error message reporting a syntax
    error ➊. If so, we printed the injection vector ➋ for the user. To make the FuzzSoapPort()
    method use our new method for testing a POST request with sqlmap, we just need
    to add a single line after the original WriteLine() method call printing the vulnerable
    parameter. Add a line that calls the TestPostRequestWithSqlmap() method ➌, and
    your fuzzer will automatically submit potentially vulnerable requests to sqlmap
    for processing.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we update the FuzzHttpGetPort() method in the if statement testing
    for a syntax error in the HTTP response, as shown in [Listing 9-36](#filepos702356).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: if (resp.Contains("syntax error"))
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " +'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input.Parts[k].Name);
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TestGetRequestWithSqlmap(url, input.Parts[k].Name);
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-36: Adding sqlmap support to the  FuzzHttpGetPort()  method from
    the SOAP fuzzer'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the if statement testing for the syntax error in FuzzHttpPostPort()
    just as simply, as [Listing 9-37](#filepos703295) shows.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: if (resp.Contains("syntax error"))
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " +'
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input.Parts[k].Name);
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TestPostRequestWithSqlmap(url, testParams, null, guid.ToString());
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-37: Adding sqlmap support to the  FuzzHttpPostPort()  method from
    the SOAP fuzzer'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: With these lines added to the SOAP fuzzer, it should now not only output potentially
    vulnerable parameters but also any of the SQL injection techniques sqlmap was
    able to use to exploit the vulnerabilities.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Running the updated SOAP fuzzer tool in your IDE or in a terminal should yield
    new information printed to the screen regarding sqlmap, as [Listing 9-38](#filepos704856)
    shows.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: $ mono ./ch9_automating_sqlmap_soap.exe http://172.18.20.40/Vulnerable.asmx
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fetching the WSDL for service: http://172.18.20.40/Vulnerable.asmx'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fetched and loaded the web service description.
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing service: VulnerableService'
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing soap port: VulnerableServiceSoap'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: AddUser'
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➊ Testing url with sqlmap: http://172.18.20.40/Vulnerable.asmx'
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 9-38: Running the updated SOAP fuzzer with sqlmap support against the
    vulnerable SOAP service from [Chapter 3](index_split_008.html#filepos243384)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: In the SOAP fuzzer output, note the new lines regarding testing the URL with
    sqlmap ➊. Once sqlmap has finished testing the SOAP request, the sqlmap log should
    be printed to the screen for the user to see the results.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you saw how to wrap the functionality of the sqlmap API into
    easy-to-use C# classes to create a small application that starts basic sqlmap
    scans against URLs passed as an argument. After we created the basic sqlmap application,
    we added sqlmap support to the SOAP fuzzer from [Chapter 3](index_split_008.html#filepos243384)
    to make a tool that automatically exploits and reports on potentially vulnerable
    HTTP requests.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: The sqlmap API can use any argument that the command line–based sqlmap tool
    can, making it just as powerful, if not more so. With sqlmap, you can use your
    C# skills to automatically retrieve password hashes and database users after verifying
    that a given URL or HTTP request is indeed vulnerable. We’ve only scratched the
    surface of sqlmap’s power for offensive pentesters or security-minded developers
    looking for more exposure to the tools hackers use. Hopefully, you can take the
    time to learn the more subtle nuances of the sqlmap features to really bring flexible
    security practices to your work.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
