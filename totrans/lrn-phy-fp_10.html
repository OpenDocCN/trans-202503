<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_113"/><span class="big">9</span><br/>TUPLES AND TYPE CONSTRUCTORS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">A tuple is an ordered collection of values. There are tuples for ordered pairs, ordered triples, ordered quadruples, and so on. The types of the values in a tuple are generally different, but they could be the same.</p>&#13;
<p class="indent">In this chapter, we’ll discuss tuples and their generalization: the type constructor. Function types, list types, and tuple types are all examples of type constructors. We’ll present a unified way to think about these type constructors, which on the surface appear different, but all share essential features. Finally, we’ll revisit numerical integration to show how tuples, in conjunction with iteration, give a way to perform numerical integration that we will later generalize to solve differential equations.</p>&#13;
<h3 class="h3" id="ch9lev1">Pairs</h3>&#13;
<p class="noindent">The simplest tuple is the pair. A pair type is specified by giving an ordered pair <code>(a,b)</code> of types <code>a</code> and <code>b</code>, separated by a comma and enclosed in parentheses. If <code>x :: a</code> and <code>y :: b</code>, then <code>(x,y) :: (a,b)</code>. The value <code>(x,y)</code> has the type <code>(a,b)</code>. The comma and parentheses have two uses: they form the type <code>(a,b)</code> and they form the value <code>(x,y)</code> of that type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>For example, here is a pair composed of a <code>String</code> describing a person’s name and an <code>Int</code> representing the person’s score on an exam:</p>&#13;
<pre>nameScore :: (String,Int)&#13;
nameScore = ("Albert Einstein", 79)</pre>&#13;
<p class="indent">In this example, the pair type is <code>(String,Int)</code> and the pair value is <code>("Albert</code> <code>Einstein", 79)</code>.</p>&#13;
<p class="indent">To get some experience with tuples, let’s write a function <code>pythag</code> that computes the hypotenuse of a right triangle from the lengths of its two sides. We’ll pass the two side lengths to the function using a pair. Here is one way to write this function:</p>&#13;
<pre>pythag :: (R,R) -&gt; R&#13;
pythag (x,y) = sqrt (x**2 + y**2)</pre>&#13;
<p class="indent">This type signature shows us that <code>pythag</code> expects a pair of two <code>R</code>s as input and produces an <code>R</code> as output. The fact that in the second line we call the input <code>(x,y)</code> (rather than a simple variable like <code>p</code>) means that this definition uses pattern matching on the input. This is similar to the pattern matching we saw earlier for <code>Bool</code> and for lists. Pattern matching for pairs is simple because there is only one pattern: every pair has the form <code>(x,y)</code>. Recall that <code>Bool</code> has two patterns (<code>True</code> and <code>False</code>) and that lists have two patterns (the empty list <code>[]</code> and the cons of an element and a list <code>x:xs</code>).</p>&#13;
<p class="indent">A couple of Prelude functions deal with pairs. The <code>fst</code> function takes a pair as input and returns the first component of the pair as output. The <code>snd</code> function takes a pair as input and returns the second component of the pair as output. We can test this behavior in GHCi:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">fst ("Albert Einstein", 79)</span>&#13;
"Albert Einstein"</pre>&#13;
<p class="indent">The types of functions <code>fst</code> and <code>snd</code> are given entirely in terms of type variables, indicating that these functions care nothing for the type of the payload.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t fst</span>&#13;
fst :: (a, b) -&gt; a&#13;
Prelude&gt; <span class="codestrong1">:t snd</span>&#13;
snd :: (a, b) -&gt; b</pre>&#13;
<p class="indent">In general, there are two ways to get data out of a type like a pair that contains multiple pieces of data. One way is pattern matching, and the other is using functions like <code>fst</code> and <code>snd</code>, generally called <em>eliminators</em>. While it is theoretically possible to write code that uses only pattern matching and never uses eliminators, eliminators are sometimes simpler, so it is nice to have access to both. The eliminators <code>fst</code> and <code>snd</code> are particularly useful if you process some data that results in a pair and you just want one part of it. An example is the function <code>integral'</code> in the last section of this chapter.</p>&#13;
<h3 class="h3" id="ch9lev2"><span epub:type="pagebreak" id="page_115"/>Currying a Function of Two Variables</h3>&#13;
<p class="noindent">In <a href="ch06.xhtml">Chapter 6</a>, we talked about currying as a way to think of a function as accepting more than one argument. Using a higher-order function, we can write our hypotenuse function as follows:</p>&#13;
<pre>pythagCurried :: R -&gt; R -&gt; R&#13;
pythagCurried x y = sqrt (x**2 + y**2)</pre>&#13;
<p class="indent">Tuples offer an alternative way to write a function of two variables. Although <code>pythag</code> and <code>pythagCurried</code> are different Haskell functions with different types, they’re doing the same thing mathematically: they are both expressing the mathematical function that finds the hypotenuse. Let’s call <code>pythag</code> the <em>tuple form</em> of the hypotenuse function and <code>pythagCurried</code> the <em>curried form</em> of the hypotenuse function.</p>&#13;
<p class="indent">These two ways of encoding a function of two variables are mutually exclusive. You need to pick one or the other for a particular function; you can’t use both. Notice that the tuple form <code>pythag</code> requires the use of parentheses and a comma around the two arguments. That’s because you need to have a tuple as input! Notice that the curried form <code>pythagCurried</code> has no parentheses and no comma. It’s not that the comma is optional; no comma can be present.</p>&#13;
<p class="indent">Sometimes you might use one form but realize later on that you wish you had used the other. Haskell provides two functions to let you convert between forms. To convert from tuple form to curried form, Haskell provides the function <code>curry</code>. The function <code>curry pythag</code> is exactly the same function as <code>pythagCurried</code> we defined earlier. The function <code>uncurry pythagCurried</code> is the same as the function <code>pythag</code>. However, it does not make sense to write <code>curry pythagCurried</code> or <code>uncurry pythag</code>; these constructions will produce type errors when the compiler tries to read them.</p>&#13;
<p class="indent">If we load these functions into GHCi (code files are available at <a href="https://lpfp.io"><em>https://lpfp.io</em></a>),</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Tuples</span>&#13;
[1 of 1] Compiling Main            ( Tuples.lhs, interpreted )&#13;
Ok, one module loaded.</pre>&#13;
<p class="noindent">we can see that the types of <code>pythagCurried</code> and <code>curry pythag</code> are the same:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t pythagCurried</span>&#13;
pythagCurried :: R -&gt; R -&gt; R&#13;
*Main&gt; <span class="codestrong1">:t curry pythag</span>&#13;
curry pythag :: R -&gt; R -&gt; R</pre>&#13;
<p class="indent">We can also see that the types of <code>pythag</code> and <code>uncurry pythagCurried</code> are the same:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t pythag</span>&#13;
pythag :: (R, R) -&gt; R&#13;
&#13;
*Main&gt; <span class="codestrong1">:t uncurry pythagCurried</span>&#13;
uncurry pythagCurried :: (R, R) -&gt; R</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Take a look at the types for <code>curry</code> and <code>uncurry</code>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t curry</span>&#13;
curry :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c&#13;
*Main&gt; <span class="codestrong1">:t uncurry</span>&#13;
uncurry :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</pre>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig1">Figure 9-1</a> attempts to explain these complex types. The two types shown in the figure are alternative ways to encode a function of two variables. The higher-order functions <code>curry</code> and <code>uncurry</code> transform one two-variable function type into the other.</p>&#13;
<div class="imagel" id="ch9fig1"><img src="Images/116fig01.jpg" alt="Image" width="309" height="111"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Two types for a function of two variables. The higher-order functions <span class="codeitalic1">curry</span> and <span class="codeitalic1">uncurry</span> transform a two-variable function of one type into the other type.</em></p>&#13;
<h3 class="h3" id="ch9lev3">Triples</h3>&#13;
<p class="noindent">In addition to pairs, you can make triples, or tuples with even more components. However, the functions <code>fst</code> and <code>snd</code> work only with pairs. To access elements of triples and larger tuples, the standard method is to use pattern matching. For example, functions that pick out the components of triples can be defined as follows:</p>&#13;
<pre>fst3 :: (a,b,c) -&gt; a&#13;
fst3 (x,y,z) = x&#13;
&#13;
snd3 :: (a,b,c) -&gt; b&#13;
snd3 (_,y,_) = y&#13;
&#13;
thd3 :: (a,b,c) -&gt; c&#13;
thd3 (_x,_y,z) = z</pre>&#13;
<p class="indent">The definitions of <code>fst3</code>, <code>snd3</code>, and <code>thd3</code> use pattern matching to assign names to the items in the triple. These names can then be used on the right-hand side of the definition to indicate the value we want the function to return. In the function <code>fst3</code>, the values <code>y</code> and <code>z</code> are not used. Because they are not used, it is in some sense superfluous to give them names. In <span epub:type="pagebreak" id="page_117"/>the definition of <code>snd3</code>, the <code>_</code> (underscore) character is used as a placeholder to represent a quantity that doesn’t get used in the expression that follows. In the definition of <code>snd3</code>, we use underscores in the first and third slots of the triple. This signals that it is superfluous to give these items names since the names are not used in the definition. In the definition of <code>thd3</code>, we show an alternate use of underscores. Here we start the variable name with an underscore, indicating it won’t be used, but we give it a name for our own use, perhaps to remind us of the purpose of that variable. Using underscores for quantities that aren’t used is a best practice, because the compiler will generate warnings about unused variables, which are often errors. To distinguish these genuine errors (frequently misspellings) from items you don’t want to use, employ the underscore.</p>&#13;
<h3 class="h3" id="ch9lev4">Comparing Lists and Tuples</h3>&#13;
<p class="noindent">A tuple is different from a list in that every element of a list must have the same type. On the other hand, unlike a list, the type of a tuple says exactly how many elements the tuple has. If an expression has type <code>[Int]</code>, for example, it can be a list of zero, one, two, or more <code>Int</code>s. However, if an expression has type <code>(String,Int)</code>, it is a pair consisting of exactly one <code>String</code> and exactly one <code>Int</code>. If you want to combine exactly two things or exactly three things, a tuple is what you want. Beyond three items, tuples rapidly become unwieldy. Lists, on the other hand, are often very long. A list can happily contain thousands of elements.</p>&#13;
<p class="indent">Before we discuss lists of pairs, we’ll take a short detour to look at a class of types that will be helpful for that discussion.</p>&#13;
<h3 class="h3" id="ch9lev5">Maybe Types</h3>&#13;
<p class="noindent">We saw in <a href="ch05.xhtml">Chapter 5</a> that for any type <code>a</code> there is another type <code>[a]</code> consisting of lists of elements that each have type <code>a</code>. Such a list may have zero, one, two, or more elements of type <code>a</code>.</p>&#13;
<p class="indent">Similarly, for any type <code>a</code> there is another type <code>Maybe a</code> consisting of zero or one element of type <code>a</code>. To motivate this new data type, imagine that we are writing a function <code>findFirst</code> that will search through a list for the first element that meets some criterion. We might want such a function to have the following type:</p>&#13;
<pre>findFirst :: (b -&gt; Bool) -&gt; [b] -&gt; b</pre>&#13;
<p class="indent">The type indicates our intent to have the function <code>findFirst</code> accept a predicate and a list of elements of type <code>b</code> as input and provide a single element of type <code>b</code> as output. But what if the list contains no element that meets our criterion? In that case, there is a problem because the function <code>findFirst</code> has no way to come up with an element of type <code>b</code>, but the type <em>demands</em> that the function return an element of type <code>b</code>. One possibility is for <code>findFirst</code> to use the <code>error</code> function if no suitable element is found, but this is an extreme measure and will halt the program so that no later recovery is possible.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>A better solution is to use a different type signature, like so:</p>&#13;
<pre>findFirstMaybe :: (b -&gt; Bool) -&gt; [b] -&gt; Maybe b</pre>&#13;
<p class="indent">If <code>findFirstMaybe</code> finds an element <code>x :: b</code> that meets the criterion, it will return <code>Just x</code>. If it finds no element of type <code>b</code> that meets the criterion, <code>find</code> <code>FirstMaybe</code> will return <code>Nothing</code>. Let’s see what the function definition looks like:</p>&#13;
<pre>findFirstMaybe p xs = case dropWhile (not . p) xs of&#13;
                        []    -&gt; Nothing&#13;
                        (x:_) -&gt; Just x</pre>&#13;
<p class="indent">The expression <code>dropWhile (not . p) xs</code> is what remains of the list <code>xs</code> after the longest possible sequence of elements that do <em>not</em> satisfy the predicate are removed from the front of the list. The <code>case</code> construction allows us to do pattern matching on the expression <code>dropWhile (not . p) xs</code>, asking which of the two list patterns the expression matches and returning an appropriate result in each case.</p>&#13;
<p class="indent">The type <code>Maybe a</code> has two patterns. (Recall that <code>Bool</code> has two patterns, lists have two patterns, and tuples have one pattern.) A value of <code>Maybe a</code> is either <code>Nothing</code> or <code>Just x</code> for some <code>x :: a</code>. The value <code>Nothing</code> is the way of specifying zero elements of type <code>a</code>, and the value <code>Just x</code> is the way of specifying one element of type <code>a</code> (namely <code>x</code>). <a href="ch09.xhtml#ch9tab1">Table 9-1</a> shows some expressions involving <code>Maybe</code> and their types.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> Expressions Involving Maybe and Their Types</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Nothing</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Maybe a</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Just "me"</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Maybe [Char]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Just 'X'</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Maybe Char</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Just False</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Maybe Bool</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>Just 4</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>Num a =&gt; Maybe a</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab2">Table 9-2</a> shows a comparison of expressions having <code>Maybe</code> types with expressions having the underlying type.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2:</strong> Comparison of Maybe Type and Underlying Type Expressions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expressions with this type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Bool</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>False</code>, <code>True</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Maybe Bool</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Just False</code>, <code>Just True</code>, <code>Nothing</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>'h'</code>, <code>'7'</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Maybe Char</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Just 'h'</code>, <code>Just '7'</code>, <code>Nothing</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>String</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>"Monday"</code>, <code>"Tuesday"</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Maybe String</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Just "Monday"</code>, <code>Just "Tuesday"</code>, <code>Nothing</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Int</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>3</code>, <code>7</code>, <code>-13</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>Maybe Int</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>Just 3</code>, <code>Just 7</code>, <code>Just (-13)</code>, <code>Nothing</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/><a href="ch09.xhtml#ch9tab2">Table 9-2</a> shows four things: for each type <code>a</code> there is a type <code>Maybe a</code>; an expression of type <code>Maybe String</code>, unless it is <code>Nothing</code>, holds a value of type <code>String</code>; an expression of type <code>String</code> can be made into an expression of type <code>Maybe String</code> by prefixing the expression with the constructor <code>Just</code>; and these observations about the <code>String</code> type are also valid for <code>Bool</code>, <code>Char</code>, or any other type.</p>&#13;
<p class="indent">Now that we have the <code>Maybe</code> type under our belt, let’s take a look at lists of pairs.</p>&#13;
<h3 class="h3" id="ch9lev6">Lists of Pairs</h3>&#13;
<p class="noindent">Just as we can form lists of lists, we can make pairs of pairs, lists of pairs, pairs of lists, and more complicated things. The list of pairs is probably the most useful of these (although lists of lists are very useful), for reasons we will see next.</p>&#13;
<p class="indent">To form a list of pairs, we can use the Prelude function <code>zip</code>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t zip</span>&#13;
zip :: [a] -&gt; [b] -&gt; [(a, b)]</pre>&#13;
<p class="indent">The <code>zip</code> function takes two lists and pairs their first elements, their second elements, and so on until the end of the shorter list. <a href="ch09.xhtml#ch9tab3">Table 9-3</a> shows some examples of how to use <code>zip</code>.</p>&#13;
<p class="tabcap" id="ch9tab3"><strong>Table 9-3:</strong> Examples of <code>zip</code> and <code>zipWith</code></p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>zip [1,2,3] [4,5,6]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[(1,4),(2,5),(3,6)]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>zip [1,2] [4,5,6]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[(1,4),(2,5)]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>zip [5..7] "who"</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[(5,'w'),(6,'h'),(7,'o')]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>zipWith (+) [1,2,3] [4,5,6]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[5,7,9]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>zipWith (-) [1,2,3] [4,5,6]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[-3,-3,-3]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>zipWith (*) [1,2,3] [4,5,6]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>[4,10,18]</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Prelude function <code>zipWith</code> is a high-power relative of <code>zip</code> that goes one step further and applies a function to each pair of values that <code>zip</code> would have generated.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t zipWith</span>&#13;
zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</pre>&#13;
<p class="indent">The first argument to <code>zipWith</code> is a higher-order function that describes what to do with an element of type <code>a</code> (from the first list) and an element of type <code>b</code> (from the second list). The second argument to <code>zipWith</code> is the first list, and the third argument to <code>zipWith</code> is the second list.</p>&#13;
<p class="indent">The Prelude function <code>unzip</code> takes a lists of pairs and turns it into a pair of lists.</p>&#13;
<span epub:type="pagebreak" id="page_120"/>&#13;
<pre>*Main&gt; <span class="codestrong1">:t unzip</span>&#13;
unzip :: [(a, b)] -&gt; ([a], [b])</pre>&#13;
<p class="indent">One use for a list of pairs is a lookup table. In a lookup table, the first item of each pair serves as a <em>key</em> and the second item of each pair serves as a <em>value</em>. Such a pair is referred to as a <em>key-value pair</em>. The following list of pairs is a lookup table containing the final numeric grade for the History of Western Civilization course taken by three famous scientists. The name of each person acts as the key, and the grade is the value.</p>&#13;
<pre>grades :: [(String, Int)]&#13;
grades = [ ("Albert Einstein", 89)&#13;
         , ("Isaac Newton"   , 95)&#13;
         , ("Alan Turing"    , 91)&#13;
         ]</pre>&#13;
<p class="indent">The Prelude function <code>lookup</code> takes a key and a lookup table and returns the corresponding value, if there is one. The function <code>lookup</code> returns a <code>Maybe</code> type to allow for the possibility that the key is not found in the lookup table.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t lookup</span>&#13;
lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b&#13;
*Main&gt; <span class="codestrong1">lookup "Isaac Newton" grades</span>&#13;
Just 95&#13;
*Main&gt; <span class="codestrong1">lookup "Richard Feynman" grades</span>&#13;
Nothing</pre>&#13;
<h3 class="h3" id="ch9lev7">Tuples and List Comprehensions</h3>&#13;
<p class="noindent">Later, we’ll want to have a way to use list comprehensions to form lists of pairs (<em>x</em>,<em>y</em>) we want to plot. In <a href="ch11.xhtml">Chapter 11</a>, for example, we’ll meet a plotting function called <code>plotPath</code> that takes a list of pairs of numbers as input, usually <code>[(R,R)]</code>, and produces a plot. We can use list comprehensions to transform our data into a form suitable for plotting. If we wanted to plot position as a function of time, we could form a list of time-position pairs as follows:</p>&#13;
<pre>txPairs :: [(R,R)]&#13;
txPairs = [(t,yRock30 t) | t &lt;- [0,0.1..6]]&#13;
&#13;
type R = Double</pre>&#13;
<p class="indent">The same list of pairs can be formed with <code>map</code>:</p>&#13;
<pre>txPairs' :: [(R,R)]&#13;
txPairs' = map (\t -&gt; (t,yRock30 t)) [0,0.1..6]&#13;
&#13;
yRock30 :: R -&gt; R&#13;
yRock30 t = 30 * t - 0.5 * 9.8 * t**2</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_121"/>Besides mapping, a list comprehension can filter data based on a Boolean expression. Let’s continue our example of forming a list of time-position pairs with <code>yRock30</code>. Suppose we want to only have pairs in our list while the rock is in the air (<em>y</em> &gt; 0).</p>&#13;
<pre>txPairsInAir :: [(R,R)]&#13;
txPairsInAir&#13;
   = [(t,yRock30 t) | t &lt;- [0,0.1..20], yRock30 t &gt; 0]</pre>&#13;
<p class="indent">After we give the list that the values of <code>t</code> come from, we add a comma and then the Boolean expression to use for filtering. The computer will form a list, as before, but now only keep values for which the Boolean expression returns <code>True</code>.</p>&#13;
<p class="indent">We can achieve the same effect with a combination of <code>map</code> and <code>filter</code>. We can do the filtering first,</p>&#13;
<pre>txPairsInAir' :: [(R,R)]&#13;
txPairsInAir'&#13;
   = map (\t -&gt; (t,yRock30 t)) $&#13;
     filter (\t -&gt; yRock30 t &gt; 0) [0,0.1..20]</pre>&#13;
<p class="noindent">or we can do the mapping first:</p>&#13;
<pre>txPairsInAir'' :: [(R,R)]&#13;
txPairsInAir''&#13;
    = filter (\(_t,y) -&gt; y &gt; 0) $&#13;
      map (\t -&gt; (t,yRock30 t)) [0,0.1..20]</pre>&#13;
<p class="indent">The application operator <code>$</code> from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> has a precedence of 0, so the expressions on each side of it are evaluated before they are combined. In this way, the application operator serves as a kind of one-symbol parentheses. The same effect could have been produced by enclosing the entire <code>map</code> line above in parentheses.</p>&#13;
<p class="indent">Note the use of the <code>_</code> (underscore) character in the anonymous function just shown. Since the conditional expression only depends on the second item in the pair, there is no need to give a name to the first item in the pair.</p>&#13;
<p class="indent">The type of a pair is formed from two existing types. The type of a triple is formed from three existing types. The idea of a <em>type constructor</em>, which we explore in the next section, provides a unifying framework for constructing new types from old.</p>&#13;
<h3 class="h3" id="ch9lev8">Type Constructors and Kinds</h3>&#13;
<p class="noindent"><code>Maybe Int</code> is a type, <code>Maybe Bool</code> is a type, and <code>Maybe R</code> is a type, but <code>Maybe</code> itself is not a type. It’s what’s called a <em>type constructor</em>. A type constructor is an object that takes zero or more types as input and produces a type as output. <code>Maybe</code> is a one-place type constructor, taking the type <code>Int</code> as input and producing the type <code>Maybe Int</code> as output. In other words, <code>Maybe</code> is a function at the type level. A zero-place type constructor is the same as a type. To keep track of <span epub:type="pagebreak" id="page_122"/>this complexity, Haskell assigns a <em>kind</em> to each type and type constructor. A type, such as <code>R</code>, has the kind <code>*</code>. GHCi has the command :kind (or <code>:k</code> for short) to ask about the kind of something.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k R</span>&#13;
R :: *</pre>&#13;
<p class="indent">A one-place type constructor, such as <code>Maybe</code>, has the kind <code>* -&gt; *</code>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Maybe</span>&#13;
Maybe :: * -&gt; *</pre>&#13;
<p class="indent">Once we apply <code>Maybe</code> to <code>R</code>, the resulting <code>Maybe R</code> is once again a type, with the kind <code>*</code>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Maybe R</span>&#13;
Maybe R :: *</pre>&#13;
<p class="indent">Types have the kind <code>*</code>, one-place type constructors have the kind <code>* -&gt; *</code>, and there are objects with more complicated kinds as well. It is interesting to note that you can ask GHCi for the kind of a type class.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Num</span>&#13;
Num :: * -&gt; Constraint</pre>&#13;
<p class="indent">This kind means that, when provided with a type, the type class <code>Num</code> produces a constraint.</p>&#13;
<p class="indent">Function types, list types, and tuple types are all special cases of types constructed with a type constructor. Haskell provides special syntax for function types, list types, and tuple types, so it may aid our understanding to give regular names to the type constructors that produce functions, lists, and tuples. The <code>type</code> keyword, which was introduced in <a href="ch04.xhtml">Chapter 4</a> to make <code>R</code> a synonym for <code>Double</code>, can also be used for parameterized types.</p>&#13;
<pre>type List a = [a]&#13;
type Function a b = a -&gt; b&#13;
type Pair a b = (a,b)&#13;
type Triple a b c = (a,b,c)</pre>&#13;
<p class="indent"><code>List</code>, like <code>Maybe</code>, is a one-place type constructor. It takes one type as input and produces a type as output. <code>Function</code> and <code>Pair</code> are two-place type constructors. They take two types as input and produce a type as output. <code>Triple</code> is a three-place type constructor. It takes three types as input and produces a type as output.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_123"/><a href="ch09.xhtml#ch9tab4">Table 9-4</a> shows the kinds of some type constructors and type classes.</p>&#13;
<p class="tabcap" id="ch9tab4"><strong>Table 9-4:</strong> Kinds of Several Type Constructors and Type Classes</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type constructor/class</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Kind</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Integer</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>R -&gt; R</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[String]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(Int,String)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Maybe Int</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>List</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Maybe</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>IO</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Function</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(-&gt;)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Pair</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>(,)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>Either</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Triple</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; * -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>(,,)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; * -&gt; * -&gt; *</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Num</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; Constraint</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>Foldable</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>(* -&gt; *) -&gt; Constraint</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Basic types, function types, list types, tuple types, <code>Maybe</code> types, and the unit type all have the kind <code>*</code>. One-place type constructors, such as <code>List</code>, <code>Maybe</code>, and <code>IO</code>, have the kind <code>* -&gt; *</code>, which indicates that they take a type as input and produce a type as output. Note that the symbol <code>[]</code>, which is the empty list and hence is a data constructor for the list type, serves double duty as a type constructor for the list type. In this role it does the same thing as the <code>List</code> type constructor we defined above. <code>IO</code> is a type constructor that turns a pure type into a type with side effects; we’ll discuss it in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">Two-place type constructors, such as <code>Function</code>, <code>Pair</code>, and <code>Either</code> have the kind <code>* -&gt; * -&gt; *</code> to indicate that they take two types as input and produce a type as output. The symbol <code>(-&gt;)</code> is the same as the <code>Function</code> type constructor we defined above and <code>(,)</code> is the same as <code>Pair</code>. A three-place type constructor, such as <code>Triple</code>, has the kind <code>* -&gt; * -&gt; * -&gt; *</code> to indicate that it takes three types as input and produces a type as output. The symbol <code>(,,)</code> is the same as <code>Triple</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/><a href="ch09.xhtml#ch9tab5">Table 9-5</a> shows the meanings of various kinds in Haskell.</p>&#13;
<p class="tabcap" id="ch9tab5"><strong>Table 9-5:</strong> Meanings of Kinds</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Kind</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Meaning</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>*</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; *</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">One-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; * -&gt; *</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Two-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>* -&gt; * -&gt; * -&gt; *</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Three-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>* -&gt; Constraint</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Type class for types</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>(* -&gt; *) -&gt; Constraint</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Type class for type constructors</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each type class also has a kind. A type class takes a type or type constructor as input and produces a constraint as output. The basic type classes we discussed in <a href="ch08.xhtml">Chapter 8</a> have the kind <code>* -&gt; Constraint</code>, meaning they take a type as input and produce a type-class constraint as output. The type class <code>Foldable</code> has the kind <code>(* -&gt; *) -&gt; Constraint</code>, meaning that it takes a type constructor (such as <code>List</code> or <code>Maybe</code>) as input and produces a type-class constraint as output. <code>List</code> and <code>Maybe</code> are instances of <code>Foldable</code>, but <code>IO</code> is not.</p>&#13;
<p class="indent">Our final use of tuples in this chapter is in numerical integration. By using a tuple together with <code>iterate</code>, we get a method for numerical integration that we can later generalize to a method for solving a differential equation.</p>&#13;
<h3 class="h3" id="ch9lev9">Numerical Integration Redux</h3>&#13;
<p class="noindent">We looked at numerical integration in <a href="ch06.xhtml">Chapter 6</a>, where we used a list comprehension to sum the areas of rectangles under a curve. Now that we have tuples, we can present an alternative method for numerical integration that comes closer to the method we’ll later use to solve differential equations. The idea is that if we pair up the current value of the integration variable (let’s call it time) with the accumulating value of the integral, we can proceed step by step to get the entire integral. To take one step forward, we increment the time by the time step and increment the running total that will ultimately be our integral by the area of one rectangle under the curve.</p>&#13;
<p class="indent">The function that advances one step looks like this:</p>&#13;
<pre>oneStep :: R         -- time step&#13;
        -&gt; (R -&gt; R)  -- function to integrate&#13;
        -&gt; (R,R)     -- current (t,y)&#13;
        -&gt; (R,R)     -- updated (t,y)&#13;
oneStep dt f (t,y) = let t' = t + dt&#13;
                         y' = y + f t * dt&#13;
                     in (t',y')</pre>&#13;
<p class="indent">The function <code>oneStep</code> names the incoming time step <code>dt</code>, the function to be integrated <code>f</code>, the current value of the integration variable <code>t</code>, and the current accumulating value of the integral <code>y</code>. It then returns a pair with the <span epub:type="pagebreak" id="page_125"/>integration variable increased by the time step and the current value of the integral increased by the area f t * dt of one rectangle under the function <code>f</code>.</p>&#13;
<p class="indent">To compute the integral, we iterate the single step as long as the independent variable is less than the upper limit.</p>&#13;
<pre>integral' :: R -&gt; Integration&#13;
integral' dt f a b&#13;
    = snd $ head $ dropWhile (\(t,_) -&gt; t &lt; b) $&#13;
      iterate (oneStep dt f) (a + dt/2,0)</pre>&#13;
<p class="indent">The expression <code>oneStep dt f :: (R,R) -&gt; (R,R)</code> is a function that updates the current time-integral pair by one time step. Since this function has the type <code>a -&gt; a</code>, it can be iterated with <code>iterate</code>. The expression iterate (oneStep dt f) (a + dt/2,0) produces an infinite list of time-integral pairs, starting with the time a + dt/2, which is in the middle of the first time interval, and an initial value of 0 for the value of the integral that will accumulate as we iterate.</p>&#13;
<p class="indent">By acting on the infinite list with <code>dropWhile (\(t,_) -&gt; t &lt; b)</code>, we drop the initial pairs whose times are less than the upper limit <code>b</code> to obtain an infinite list whose first pair has a time very close to the upper limit <code>b</code>. Acting on this infinite list with <code>head</code> returns the pair whose time is very close to the upper limit. Finally, acting on this pair with <code>snd</code> returns the value of the integral.</p>&#13;
<p class="indent">For convenience, here is the <code>Integration</code> type from <a href="ch06.xhtml">Chapter 6</a> that we used earlier in the type signature of <code>integral'</code>:</p>&#13;
<pre>type Integration = (R -&gt; R)  -- function&#13;
                 -&gt; R        -- lower limit&#13;
                 -&gt; R        -- upper limit&#13;
                 -&gt; R        -- result</pre>&#13;
<h3 class="h3" id="ch9lev10">Summary</h3>&#13;
<p class="noindent">This chapter introduced tuples, a way to combine two or more values into a single value. We then looked at type constructors, functions at the type level that form an output type from an input type. We ended the chapter by using tuples to introduce an alternative way to achieve numerical integration using <code>iterate</code>.</p>&#13;
<p class="indent">In the next chapter, we’ll return to physics, look at kinematics in three dimensions, and develop the data type we’ll use for vectors.</p>&#13;
<h3 class="h3" id="ch9lev11">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 9.1.</strong> Write a function</p>&#13;
<pre>polarToCart :: (R,R) -&gt; (R,R)</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_126"/>that takes as input polar coordinates (<em>r</em>, <em>θ</em>), with <em>θ</em> in radians, and returns as output a pair (x, y) of Cartesian coordinates.</p>&#13;
<p class="noindentts"><strong>Exercise 9.2.</strong> Explain in words the meaning of the types of <code>curry</code> and <code>uncurry</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.3.</strong> The Prelude function</p>&#13;
<pre>head :: [a] -&gt; a</pre>&#13;
<p class="noindentts">is slightly problematic in that it causes a runtime error if it is passed an empty list. Write a function</p>&#13;
<pre>headSafe :: [a] -&gt; Maybe a&#13;
headSafe = undefined</pre>&#13;
<p class="noindentts">that returns <code>Nothing</code> if passed the empty list and <code>Just x</code> otherwise, where <code>x</code> is the first element (the head) of the given list. Replace the undefined with your own code. (You can use undefined in your own functions as a placeholder if you want your code to load before you are finished writing it.)</p>&#13;
<p class="noindentts"><strong>Exercise 9.4.</strong> We mentioned earlier that the type <code>Maybe a</code> is a bit like the type <code>[a]</code>, except that elements of <code>Maybe a</code> are constrained to have zero or one element. To make this analogy precise, write a function</p>&#13;
<pre>maybeToList :: Maybe a -&gt; [a]&#13;
maybeToList = undefined</pre>&#13;
<p class="noindentts">that makes a list out of a <code>Maybe</code> type. What list should <code>Nothing</code> map to? What list should <code>Just x</code> map to?</p>&#13;
<p class="noindentts"><strong>Exercise 9.5.</strong> Find out and explain what happens when <code>zip</code> is used with two lists that don’t have the same length.</p>&#13;
<p class="noindentts"><strong>Exercise 9.6.</strong> Define a function</p>&#13;
<pre>zip' :: ([a], [b]) -&gt; [(a, b)]&#13;
zip' = undefined</pre>&#13;
<p class="noindentts">that turns a pair of lists into a list of pairs. (Hint: consider using <code>curry</code> or <code>uncurry</code>.)</p>&#13;
<p class="noindentts"><strong>Exercise 9.7.</strong> The dot operator (<code>.</code>) is for function composition. If we do <code>unzip</code> followed by <code>zip'</code>, we have a function with the following type signature:</p>&#13;
<pre>   zip' . unzip :: [(a, b)] -&gt; [(a, b)]</pre>&#13;
<p class="indent">Is this the identity function? (In other words, does it always return the expression it was given?) If so, how do you know? If not, give a counterexample.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>If we do <code>zip'</code> followed by <code>unzip</code>, we have a function with the following type signature:</p>&#13;
<pre>   unzip . zip' :: ([a], [b]) -&gt; ([a], [b])</pre>&#13;
<p class="indent">Is this the identity function?</p>&#13;
<p class="noindentts"><strong>Exercise 9.8.</strong> Using the <code>grades</code> lookup table from earlier, show how to use the <code>lookup</code> function to produce the value <code>Just 89</code>. Also show how to use the <code>lookup</code> function to produce the value <code>Nothing</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.9.</strong> Translate the following mathematical function into Haskell:</p>&#13;
<div class="imagec"><em>x</em>(<em>r</em>, <em>θ</em>, <em>ϕ</em>) = <em>r</em> sin <em>θ</em> cos <em>ϕ</em></div>&#13;
<p class="indent">Use a triple for the input to the function <code>x</code>. Give a type signature as well as a function definition.</p>&#13;
<p class="noindentts"><strong>Exercise 9.10.</strong> A car starts from rest and accelerates at 5 m/s<sup>2</sup> along a straight, level highway. We want to make an infinite list <code>tvPairs</code> of time-velocity pairs for this car, one every second. Here is our code for <code>tvPairs</code>:</p>&#13;
<pre>tvPairs :: [(R,R)]&#13;
tvPairs = iterate tvUpdate (0,0)</pre>&#13;
<p class="indent">Write a type signature and function definition for <code>tvUpdate</code>.</p>&#13;
<pre>tvUpdate = undefined</pre>&#13;
<p class="indent">The list <code>tvPairs</code> should look like [(0,0),(1,5),(2,10),(3,15),...]. After you write the function <code>tvUpdate</code>, use the <code>take</code> function to see the first several elements of <code>tvPairs</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.11.</strong> A Fibonacci sequence is one in which each term is the sum of the previous two terms. The first several terms are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. Write a sequence</p>&#13;
<pre>fibonacci :: [Int]&#13;
fibonacci = undefined</pre>&#13;
<p class="noindentts">for the (infinite) list of Fibonacci numbers.</p>&#13;
<p class="indent">As a suggestion, write a helping sequence</p>&#13;
<pre>fibHelper :: [(Int,Int)]&#13;
fibHelper = undefined</pre>&#13;
<p class="noindentts">using the function <code>iterate</code>. The first several terms of fibHelper should be [(0,1),(1,1),(1,2),(2,3),(3,5),...]. Then write the sequence <code>fibonacci</code> using <code>fibHelper</code>.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_128"/><strong>Exercise 9.12.</strong> The factorial function takes a non-negative integer and returns the product of all positive integers up to and including the given integer. It is usually denoted with an exclamation point. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120. We define 0! = 1. The purpose of this exercise is to write a factorial function</p>&#13;
<pre>fact :: Int -&gt; Int</pre>&#13;
<p class="noindentts">using <code>iterate</code>. The suggestion in Exercise 9.11 is useful here as well (write a sequence <code>factHelper :: [(Int,Int)]</code> using <code>iterate</code> and then define <code>fact</code> to get its values from this sequence using the <code>!!</code> operator).</p>&#13;
<p class="noindentts"><strong>Exercise 9.13.</strong> Write the following function using a list comprehension rather than a map:</p>&#13;
<pre>pick13 :: [(R,R,R)] -&gt; [(R,R)]&#13;
pick13 triples = map (\(x1,_,x3) -&gt; (x1,x3)) triples</pre>&#13;
<p class="noindentts"><strong>Exercise 9.14.</strong> Suppose we throw a rock straight up in the air at 15 m/s. Use a list comprehension to make a list of (time, position, velocity) triples (type <code>[(R,R,R)]</code>) for an interval of time while the rock is in the air. Your list should have enough triples to let the data make a reasonably smooth graph if plotted.</p>&#13;
<p class="noindentts"><strong>Exercise 9.15.</strong> Tuples can be nested, like <code>((3,4),5)</code>. Although this pair contains three numbers, it is not the same as a triple. Write a function</p>&#13;
<pre>toTriple :: ((a,b),c) -&gt; (a,b,c)&#13;
toTriple = undefined</pre>&#13;
<p class="noindentts">that converts a pair whose first component is a pair into a triple.</p>&#13;
</div></body></html>