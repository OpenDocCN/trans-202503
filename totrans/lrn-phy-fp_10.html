<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_113"/><span class="big">9</span><br/>TUPLES AND TYPE CONSTRUCTORS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">A tuple is an ordered collection of values. There are tuples for ordered pairs, ordered triples, ordered quadruples, and so on. The types of the values in a tuple are generally different, but they could be the same.</p>&#13;
<p class="indent">In this chapter, we’ll discuss tuples and their generalization: the type constructor. Function types, list types, and tuple types are all examples of type constructors. We’ll present a unified way to think about these type constructors, which on the surface appear different, but all share essential features. Finally, we’ll revisit numerical integration to show how tuples, in conjunction with iteration, give a way to perform numerical integration that we will later generalize to solve differential equations.</p>&#13;
<h3 class="h3" id="ch9lev1">Pairs</h3>&#13;
<p class="noindent">The simplest tuple is the pair. A pair type is specified by giving an ordered pair <span class="literal">(a,b)</span> of types <span class="literal">a</span> and <span class="literal">b</span>, separated by a comma and enclosed in parentheses. If <span class="literal">x :: a</span> and <span class="literal">y :: b</span>, then <span class="literal">(x,y) :: (a,b)</span>. The value <span class="literal">(x,y)</span> has the type <span class="literal">(a,b)</span>. The comma and parentheses have two uses: they form the type <span class="literal">(a,b)</span> and they form the value <span class="literal">(x,y)</span> of that type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>For example, here is a pair composed of a <span class="literal">String</span> describing a person’s name and an <span class="literal">Int</span> representing the person’s score on an exam:</p>&#13;
<pre>nameScore :: (String,Int)&#13;
nameScore = ("Albert Einstein", 79)</pre>&#13;
<p class="indent">In this example, the pair type is <span class="literal">(String,Int)</span> and the pair value is <span class="literal">("Albert</span> <span class="literal">Einstein", 79)</span>.</p>&#13;
<p class="indent">To get some experience with tuples, let’s write a function <span class="literal">pythag</span> that computes the hypotenuse of a right triangle from the lengths of its two sides. We’ll pass the two side lengths to the function using a pair. Here is one way to write this function:</p>&#13;
<pre>pythag :: (R,R) -&gt; R&#13;
pythag (x,y) = sqrt (x**2 + y**2)</pre>&#13;
<p class="indent">This type signature shows us that <span class="literal">pythag</span> expects a pair of two <span class="literal">R</span>s as input and produces an <span class="literal">R</span> as output. The fact that in the second line we call the input <span class="literal">(x,y)</span> (rather than a simple variable like <span class="literal">p</span>) means that this definition uses pattern matching on the input. This is similar to the pattern matching we saw earlier for <span class="literal">Bool</span> and for lists. Pattern matching for pairs is simple because there is only one pattern: every pair has the form <span class="literal">(x,y)</span>. Recall that <span class="literal">Bool</span> has two patterns (<span class="literal">True</span> and <span class="literal">False</span>) and that lists have two patterns (the empty list <span class="literal">[]</span> and the cons of an element and a list <span class="literal">x:xs</span>).</p>&#13;
<p class="indent">A couple of Prelude functions deal with pairs. The <span class="literal">fst</span> function takes a pair as input and returns the first component of the pair as output. The <span class="literal">snd</span> function takes a pair as input and returns the second component of the pair as output. We can test this behavior in GHCi:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">fst ("Albert Einstein", 79)</span>&#13;
"Albert Einstein"</pre>&#13;
<p class="indent">The types of functions <span class="literal">fst</span> and <span class="literal">snd</span> are given entirely in terms of type variables, indicating that these functions care nothing for the type of the payload.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:t fst</span>&#13;
fst :: (a, b) -&gt; a&#13;
Prelude&gt; <span class="codestrong1">:t snd</span>&#13;
snd :: (a, b) -&gt; b</pre>&#13;
<p class="indent">In general, there are two ways to get data out of a type like a pair that contains multiple pieces of data. One way is pattern matching, and the other is using functions like <span class="literal">fst</span> and <span class="literal">snd</span>, generally called <em>eliminators</em>. While it is theoretically possible to write code that uses only pattern matching and never uses eliminators, eliminators are sometimes simpler, so it is nice to have access to both. The eliminators <span class="literal">fst</span> and <span class="literal">snd</span> are particularly useful if you process some data that results in a pair and you just want one part of it. An example is the function <span class="literal">integral'</span> in the last section of this chapter.</p>&#13;
<h3 class="h3" id="ch9lev2"><span epub:type="pagebreak" id="page_115"/>Currying a Function of Two Variables</h3>&#13;
<p class="noindent">In <a href="ch06.xhtml">Chapter 6</a>, we talked about currying as a way to think of a function as accepting more than one argument. Using a higher-order function, we can write our hypotenuse function as follows:</p>&#13;
<pre>pythagCurried :: R -&gt; R -&gt; R&#13;
pythagCurried x y = sqrt (x**2 + y**2)</pre>&#13;
<p class="indent">Tuples offer an alternative way to write a function of two variables. Although <span class="literal">pythag</span> and <span class="literal">pythagCurried</span> are different Haskell functions with different types, they’re doing the same thing mathematically: they are both expressing the mathematical function that finds the hypotenuse. Let’s call <span class="literal">pythag</span> the <em>tuple form</em> of the hypotenuse function and <span class="literal">pythagCurried</span> the <em>curried form</em> of the hypotenuse function.</p>&#13;
<p class="indent">These two ways of encoding a function of two variables are mutually exclusive. You need to pick one or the other for a particular function; you can’t use both. Notice that the tuple form <span class="literal">pythag</span> requires the use of parentheses and a comma around the two arguments. That’s because you need to have a tuple as input! Notice that the curried form <span class="literal">pythagCurried</span> has no parentheses and no comma. It’s not that the comma is optional; no comma can be present.</p>&#13;
<p class="indent">Sometimes you might use one form but realize later on that you wish you had used the other. Haskell provides two functions to let you convert between forms. To convert from tuple form to curried form, Haskell provides the function <span class="literal">curry</span>. The function <span class="literal">curry pythag</span> is exactly the same function as <span class="literal">pythagCurried</span> we defined earlier. The function <span class="literal">uncurry pythagCurried</span> is the same as the function <span class="literal">pythag</span>. However, it does not make sense to write <span class="literal">curry pythagCurried</span> or <span class="literal">uncurry pythag</span>; these constructions will produce type errors when the compiler tries to read them.</p>&#13;
<p class="indent">If we load these functions into GHCi (code files are available at <a href="https://lpfp.io"><em>https://lpfp.io</em></a>),</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Tuples</span>&#13;
[1 of 1] Compiling Main            ( Tuples.lhs, interpreted )&#13;
Ok, one module loaded.</pre>&#13;
<p class="noindent">we can see that the types of <span class="literal">pythagCurried</span> and <span class="literal">curry pythag</span> are the same:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t pythagCurried</span>&#13;
pythagCurried :: R -&gt; R -&gt; R&#13;
*Main&gt; <span class="codestrong1">:t curry pythag</span>&#13;
curry pythag :: R -&gt; R -&gt; R</pre>&#13;
<p class="indent">We can also see that the types of <span class="literal">pythag</span> and <span class="literal">uncurry pythagCurried</span> are the same:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t pythag</span>&#13;
pythag :: (R, R) -&gt; R&#13;
&#13;
*Main&gt; <span class="codestrong1">:t uncurry pythagCurried</span>&#13;
uncurry pythagCurried :: (R, R) -&gt; R</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Take a look at the types for <span class="literal">curry</span> and <span class="literal">uncurry</span>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t curry</span>&#13;
curry :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c&#13;
*Main&gt; <span class="codestrong1">:t uncurry</span>&#13;
uncurry :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</pre>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig1">Figure 9-1</a> attempts to explain these complex types. The two types shown in the figure are alternative ways to encode a function of two variables. The higher-order functions <span class="literal">curry</span> and <span class="literal">uncurry</span> transform one two-variable function type into the other.</p>&#13;
<div class="imagel" id="ch9fig1"><img src="Images/116fig01.jpg" alt="Image" width="309" height="111"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Two types for a function of two variables. The higher-order functions <span class="codeitalic1">curry</span> and <span class="codeitalic1">uncurry</span> transform a two-variable function of one type into the other type.</em></p>&#13;
<h3 class="h3" id="ch9lev3">Triples</h3>&#13;
<p class="noindent">In addition to pairs, you can make triples, or tuples with even more components. However, the functions <span class="literal">fst</span> and <span class="literal">snd</span> work only with pairs. To access elements of triples and larger tuples, the standard method is to use pattern matching. For example, functions that pick out the components of triples can be defined as follows:</p>&#13;
<pre>fst3 :: (a,b,c) -&gt; a&#13;
fst3 (x,y,z) = x&#13;
&#13;
snd3 :: (a,b,c) -&gt; b&#13;
snd3 (_,y,_) = y&#13;
&#13;
thd3 :: (a,b,c) -&gt; c&#13;
thd3 (_x,_y,z) = z</pre>&#13;
<p class="indent">The definitions of <span class="literal">fst3</span>, <span class="literal">snd3</span>, and <span class="literal">thd3</span> use pattern matching to assign names to the items in the triple. These names can then be used on the right-hand side of the definition to indicate the value we want the function to return. In the function <span class="literal">fst3</span>, the values <span class="literal">y</span> and <span class="literal">z</span> are not used. Because they are not used, it is in some sense superfluous to give them names. In <span epub:type="pagebreak" id="page_117"/>the definition of <span class="literal">snd3</span>, the <span class="literal">_</span> (underscore) character is used as a placeholder to represent a quantity that doesn’t get used in the expression that follows. In the definition of <span class="literal">snd3</span>, we use underscores in the first and third slots of the triple. This signals that it is superfluous to give these items names since the names are not used in the definition. In the definition of <span class="literal">thd3</span>, we show an alternate use of underscores. Here we start the variable name with an underscore, indicating it won’t be used, but we give it a name for our own use, perhaps to remind us of the purpose of that variable. Using underscores for quantities that aren’t used is a best practice, because the compiler will generate warnings about unused variables, which are often errors. To distinguish these genuine errors (frequently misspellings) from items you don’t want to use, employ the underscore.</p>&#13;
<h3 class="h3" id="ch9lev4">Comparing Lists and Tuples</h3>&#13;
<p class="noindent">A tuple is different from a list in that every element of a list must have the same type. On the other hand, unlike a list, the type of a tuple says exactly how many elements the tuple has. If an expression has type <span class="literal">[Int]</span>, for example, it can be a list of zero, one, two, or more <span class="literal">Int</span>s. However, if an expression has type <span class="literal">(String,Int)</span>, it is a pair consisting of exactly one <span class="literal">String</span> and exactly one <span class="literal">Int</span>. If you want to combine exactly two things or exactly three things, a tuple is what you want. Beyond three items, tuples rapidly become unwieldy. Lists, on the other hand, are often very long. A list can happily contain thousands of elements.</p>&#13;
<p class="indent">Before we discuss lists of pairs, we’ll take a short detour to look at a class of types that will be helpful for that discussion.</p>&#13;
<h3 class="h3" id="ch9lev5">Maybe Types</h3>&#13;
<p class="noindent">We saw in <a href="ch05.xhtml">Chapter 5</a> that for any type <span class="literal">a</span> there is another type <span class="literal">[a]</span> consisting of lists of elements that each have type <span class="literal">a</span>. Such a list may have zero, one, two, or more elements of type <span class="literal">a</span>.</p>&#13;
<p class="indent">Similarly, for any type <span class="literal">a</span> there is another type <span class="literal">Maybe a</span> consisting of zero or one element of type <span class="literal">a</span>. To motivate this new data type, imagine that we are writing a function <span class="literal">findFirst</span> that will search through a list for the first element that meets some criterion. We might want such a function to have the following type:</p>&#13;
<pre>findFirst :: (b -&gt; Bool) -&gt; [b] -&gt; b</pre>&#13;
<p class="indent">The type indicates our intent to have the function <span class="literal">findFirst</span> accept a predicate and a list of elements of type <span class="literal">b</span> as input and provide a single element of type <span class="literal">b</span> as output. But what if the list contains no element that meets our criterion? In that case, there is a problem because the function <span class="literal">findFirst</span> has no way to come up with an element of type <span class="literal">b</span>, but the type <em>demands</em> that the function return an element of type <span class="literal">b</span>. One possibility is for <span class="literal">findFirst</span> to use the <span class="literal">error</span> function if no suitable element is found, but this is an extreme measure and will halt the program so that no later recovery is possible.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>A better solution is to use a different type signature, like so:</p>&#13;
<pre>findFirstMaybe :: (b -&gt; Bool) -&gt; [b] -&gt; Maybe b</pre>&#13;
<p class="indent">If <span class="literal">findFirstMaybe</span> finds an element <span class="literal">x :: b</span> that meets the criterion, it will return <span class="literal">Just x</span>. If it finds no element of type <span class="literal">b</span> that meets the criterion, <span class="literal">find</span> <span class="literal">FirstMaybe</span> will return <span class="literal">Nothing</span>. Let’s see what the function definition looks like:</p>&#13;
<pre>findFirstMaybe p xs = case dropWhile (not . p) xs of&#13;
                        []    -&gt; Nothing&#13;
                        (x:_) -&gt; Just x</pre>&#13;
<p class="indent">The expression <span class="literal">dropWhile (not . p) xs</span> is what remains of the list <span class="literal">xs</span> after the longest possible sequence of elements that do <em>not</em> satisfy the predicate are removed from the front of the list. The <span class="literal">case</span> construction allows us to do pattern matching on the expression <span class="literal">dropWhile (not . p) xs</span>, asking which of the two list patterns the expression matches and returning an appropriate result in each case.</p>&#13;
<p class="indent">The type <span class="literal">Maybe a</span> has two patterns. (Recall that <span class="literal">Bool</span> has two patterns, lists have two patterns, and tuples have one pattern.) A value of <span class="literal">Maybe a</span> is either <span class="literal">Nothing</span> or <span class="literal">Just x</span> for some <span class="literal">x :: a</span>. The value <span class="literal">Nothing</span> is the way of specifying zero elements of type <span class="literal">a</span>, and the value <span class="literal">Just x</span> is the way of specifying one element of type <span class="literal">a</span> (namely <span class="literal">x</span>). <a href="ch09.xhtml#ch9tab1">Table 9-1</a> shows some expressions involving <span class="literal">Maybe</span> and their types.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> Expressions Involving Maybe and Their Types</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Nothing</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Maybe a</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Just "me"</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Maybe [Char]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Just 'X'</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Maybe Char</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Just False</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Maybe Bool</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">Just 4</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">Num a =&gt; Maybe a</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab2">Table 9-2</a> shows a comparison of expressions having <span class="literal">Maybe</span> types with expressions having the underlying type.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2:</strong> Comparison of Maybe Type and Underlying Type Expressions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expressions with this type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Bool</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">False</span>, <span class="literal">True</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Maybe Bool</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Just False</span>, <span class="literal">Just True</span>, <span class="literal">Nothing</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">'h'</span>, <span class="literal">'7'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Maybe Char</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Just 'h'</span>, <span class="literal">Just '7'</span>, <span class="literal">Nothing</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">String</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">"Monday"</span>, <span class="literal">"Tuesday"</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Maybe String</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Just "Monday"</span>, <span class="literal">Just "Tuesday"</span>, <span class="literal">Nothing</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Int</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">3</span>, <span class="literal">7</span>, <span class="literal">-13</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Maybe Int</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Just 3</span>, <span class="literal">Just 7</span>, <span class="literal">Just (-13)</span>, <span class="literal">Nothing</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/><a href="ch09.xhtml#ch9tab2">Table 9-2</a> shows four things: for each type <span class="literal">a</span> there is a type <span class="literal">Maybe a</span>; an expression of type <span class="literal">Maybe String</span>, unless it is <span class="literal">Nothing</span>, holds a value of type <span class="literal">String</span>; an expression of type <span class="literal">String</span> can be made into an expression of type <span class="literal">Maybe String</span> by prefixing the expression with the constructor <span class="literal">Just</span>; and these observations about the <span class="literal">String</span> type are also valid for <span class="literal">Bool</span>, <span class="literal">Char</span>, or any other type.</p>&#13;
<p class="indent">Now that we have the <span class="literal">Maybe</span> type under our belt, let’s take a look at lists of pairs.</p>&#13;
<h3 class="h3" id="ch9lev6">Lists of Pairs</h3>&#13;
<p class="noindent">Just as we can form lists of lists, we can make pairs of pairs, lists of pairs, pairs of lists, and more complicated things. The list of pairs is probably the most useful of these (although lists of lists are very useful), for reasons we will see next.</p>&#13;
<p class="indent">To form a list of pairs, we can use the Prelude function <span class="literal">zip</span>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t zip</span>&#13;
zip :: [a] -&gt; [b] -&gt; [(a, b)]</pre>&#13;
<p class="indent">The <span class="literal">zip</span> function takes two lists and pairs their first elements, their second elements, and so on until the end of the shorter list. <a href="ch09.xhtml#ch9tab3">Table 9-3</a> shows some examples of how to use <span class="literal">zip</span>.</p>&#13;
<p class="tabcap" id="ch9tab3"><strong>Table 9-3:</strong> Examples of <span class="literal">zip</span> and <span class="literal">zipWith</span></p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">zip [1,2,3] [4,5,6]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[(1,4),(2,5),(3,6)]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">zip [1,2] [4,5,6]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">[(1,4),(2,5)]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">zip [5..7] "who"</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[(5,'w'),(6,'h'),(7,'o')]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">zipWith (+) [1,2,3] [4,5,6]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">[5,7,9]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">zipWith (-) [1,2,3] [4,5,6]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[-3,-3,-3]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">zipWith (*) [1,2,3] [4,5,6]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">[4,10,18]</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Prelude function <span class="literal">zipWith</span> is a high-power relative of <span class="literal">zip</span> that goes one step further and applies a function to each pair of values that <span class="literal">zip</span> would have generated.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t zipWith</span>&#13;
zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</pre>&#13;
<p class="indent">The first argument to <span class="literal">zipWith</span> is a higher-order function that describes what to do with an element of type <span class="literal">a</span> (from the first list) and an element of type <span class="literal">b</span> (from the second list). The second argument to <span class="literal">zipWith</span> is the first list, and the third argument to <span class="literal">zipWith</span> is the second list.</p>&#13;
<p class="indent">The Prelude function <span class="literal">unzip</span> takes a lists of pairs and turns it into a pair of lists.</p>&#13;
<span epub:type="pagebreak" id="page_120"/>&#13;
<pre>*Main&gt; <span class="codestrong1">:t unzip</span>&#13;
unzip :: [(a, b)] -&gt; ([a], [b])</pre>&#13;
<p class="indent">One use for a list of pairs is a lookup table. In a lookup table, the first item of each pair serves as a <em>key</em> and the second item of each pair serves as a <em>value</em>. Such a pair is referred to as a <em>key-value pair</em>. The following list of pairs is a lookup table containing the final numeric grade for the History of Western Civilization course taken by three famous scientists. The name of each person acts as the key, and the grade is the value.</p>&#13;
<pre>grades :: [(String, Int)]&#13;
grades = [ ("Albert Einstein", 89)&#13;
         , ("Isaac Newton"   , 95)&#13;
         , ("Alan Turing"    , 91)&#13;
         ]</pre>&#13;
<p class="indent">The Prelude function <span class="literal">lookup</span> takes a key and a lookup table and returns the corresponding value, if there is one. The function <span class="literal">lookup</span> returns a <span class="literal">Maybe</span> type to allow for the possibility that the key is not found in the lookup table.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t lookup</span>&#13;
lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b&#13;
*Main&gt; <span class="codestrong1">lookup "Isaac Newton" grades</span>&#13;
Just 95&#13;
*Main&gt; <span class="codestrong1">lookup "Richard Feynman" grades</span>&#13;
Nothing</pre>&#13;
<h3 class="h3" id="ch9lev7">Tuples and List Comprehensions</h3>&#13;
<p class="noindent">Later, we’ll want to have a way to use list comprehensions to form lists of pairs (<em>x</em>,<em>y</em>) we want to plot. In <a href="ch11.xhtml">Chapter 11</a>, for example, we’ll meet a plotting function called <span class="literal">plotPath</span> that takes a list of pairs of numbers as input, usually <span class="literal">[(R,R)]</span>, and produces a plot. We can use list comprehensions to transform our data into a form suitable for plotting. If we wanted to plot position as a function of time, we could form a list of time-position pairs as follows:</p>&#13;
<pre>txPairs :: [(R,R)]&#13;
txPairs = [(t,yRock30 t) | t &lt;- [0,0.1..6]]&#13;
&#13;
type R = Double</pre>&#13;
<p class="indent">The same list of pairs can be formed with <span class="literal">map</span>:</p>&#13;
<pre>txPairs' :: [(R,R)]&#13;
txPairs' = map (\t -&gt; (t,yRock30 t)) [0,0.1..6]&#13;
&#13;
yRock30 :: R -&gt; R&#13;
yRock30 t = 30 * t - 0.5 * 9.8 * t**2</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_121"/>Besides mapping, a list comprehension can filter data based on a Boolean expression. Let’s continue our example of forming a list of time-position pairs with <span class="literal">yRock30</span>. Suppose we want to only have pairs in our list while the rock is in the air (<em>y</em> &gt; 0).</p>&#13;
<pre>txPairsInAir :: [(R,R)]&#13;
txPairsInAir&#13;
   = [(t,yRock30 t) | t &lt;- [0,0.1..20], yRock30 t &gt; 0]</pre>&#13;
<p class="indent">After we give the list that the values of <span class="literal">t</span> come from, we add a comma and then the Boolean expression to use for filtering. The computer will form a list, as before, but now only keep values for which the Boolean expression returns <span class="literal">True</span>.</p>&#13;
<p class="indent">We can achieve the same effect with a combination of <span class="literal">map</span> and <span class="literal">filter</span>. We can do the filtering first,</p>&#13;
<pre>txPairsInAir' :: [(R,R)]&#13;
txPairsInAir'&#13;
   = map (\t -&gt; (t,yRock30 t)) $&#13;
     filter (\t -&gt; yRock30 t &gt; 0) [0,0.1..20]</pre>&#13;
<p class="noindent">or we can do the mapping first:</p>&#13;
<pre>txPairsInAir'' :: [(R,R)]&#13;
txPairsInAir''&#13;
    = filter (\(_t,y) -&gt; y &gt; 0) $&#13;
      map (\t -&gt; (t,yRock30 t)) [0,0.1..20]</pre>&#13;
<p class="indent">The application operator <span class="literal">$</span> from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> has a precedence of 0, so the expressions on each side of it are evaluated before they are combined. In this way, the application operator serves as a kind of one-symbol parentheses. The same effect could have been produced by enclosing the entire <span class="literal">map</span> line above in parentheses.</p>&#13;
<p class="indent">Note the use of the <span class="literal">_</span> (underscore) character in the anonymous function just shown. Since the conditional expression only depends on the second item in the pair, there is no need to give a name to the first item in the pair.</p>&#13;
<p class="indent">The type of a pair is formed from two existing types. The type of a triple is formed from three existing types. The idea of a <em>type constructor</em>, which we explore in the next section, provides a unifying framework for constructing new types from old.</p>&#13;
<h3 class="h3" id="ch9lev8">Type Constructors and Kinds</h3>&#13;
<p class="noindent"><span class="literal">Maybe Int</span> is a type, <span class="literal">Maybe Bool</span> is a type, and <span class="literal">Maybe R</span> is a type, but <span class="literal">Maybe</span> itself is not a type. It’s what’s called a <em>type constructor</em>. A type constructor is an object that takes zero or more types as input and produces a type as output. <span class="literal">Maybe</span> is a one-place type constructor, taking the type <span class="literal">Int</span> as input and producing the type <span class="literal">Maybe Int</span> as output. In other words, <span class="literal">Maybe</span> is a function at the type level. A zero-place type constructor is the same as a type. To keep track of <span epub:type="pagebreak" id="page_122"/>this complexity, Haskell assigns a <em>kind</em> to each type and type constructor. A type, such as <span class="literal">R</span>, has the kind <span class="literal">*</span>. GHCi has the command :kind (or <span class="literal">:k</span> for short) to ask about the kind of something.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k R</span>&#13;
R :: *</pre>&#13;
<p class="indent">A one-place type constructor, such as <span class="literal">Maybe</span>, has the kind <span class="literal">* -&gt; *</span>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Maybe</span>&#13;
Maybe :: * -&gt; *</pre>&#13;
<p class="indent">Once we apply <span class="literal">Maybe</span> to <span class="literal">R</span>, the resulting <span class="literal">Maybe R</span> is once again a type, with the kind <span class="literal">*</span>.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Maybe R</span>&#13;
Maybe R :: *</pre>&#13;
<p class="indent">Types have the kind <span class="literal">*</span>, one-place type constructors have the kind <span class="literal">* -&gt; *</span>, and there are objects with more complicated kinds as well. It is interesting to note that you can ask GHCi for the kind of a type class.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:k Num</span>&#13;
Num :: * -&gt; Constraint</pre>&#13;
<p class="indent">This kind means that, when provided with a type, the type class <span class="literal">Num</span> produces a constraint.</p>&#13;
<p class="indent">Function types, list types, and tuple types are all special cases of types constructed with a type constructor. Haskell provides special syntax for function types, list types, and tuple types, so it may aid our understanding to give regular names to the type constructors that produce functions, lists, and tuples. The <span class="literal">type</span> keyword, which was introduced in <a href="ch04.xhtml">Chapter 4</a> to make <span class="literal">R</span> a synonym for <span class="literal">Double</span>, can also be used for parameterized types.</p>&#13;
<pre>type List a = [a]&#13;
type Function a b = a -&gt; b&#13;
type Pair a b = (a,b)&#13;
type Triple a b c = (a,b,c)</pre>&#13;
<p class="indent"><span class="literal">List</span>, like <span class="literal">Maybe</span>, is a one-place type constructor. It takes one type as input and produces a type as output. <span class="literal">Function</span> and <span class="literal">Pair</span> are two-place type constructors. They take two types as input and produce a type as output. <span class="literal">Triple</span> is a three-place type constructor. It takes three types as input and produces a type as output.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_123"/><a href="ch09.xhtml#ch9tab4">Table 9-4</a> shows the kinds of some type constructors and type classes.</p>&#13;
<p class="tabcap" id="ch9tab4"><strong>Table 9-4:</strong> Kinds of Several Type Constructors and Type Classes</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type constructor/class</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Kind</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Integer</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">R -&gt; R</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">[String]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(Int,String)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Maybe Int</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">List</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">[]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Maybe</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">IO</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Function</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(-&gt;)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Pair</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">(,)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">Either</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Triple</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; * -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">(,,)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; * -&gt; * -&gt; *</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">Num</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; Constraint</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">Foldable</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><span class="literal">(* -&gt; *) -&gt; Constraint</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Basic types, function types, list types, tuple types, <span class="literal">Maybe</span> types, and the unit type all have the kind <span class="literal">*</span>. One-place type constructors, such as <span class="literal">List</span>, <span class="literal">Maybe</span>, and <span class="literal">IO</span>, have the kind <span class="literal">* -&gt; *</span>, which indicates that they take a type as input and produce a type as output. Note that the symbol <span class="literal">[]</span>, which is the empty list and hence is a data constructor for the list type, serves double duty as a type constructor for the list type. In this role it does the same thing as the <span class="literal">List</span> type constructor we defined above. <span class="literal">IO</span> is a type constructor that turns a pure type into a type with side effects; we’ll discuss it in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">Two-place type constructors, such as <span class="literal">Function</span>, <span class="literal">Pair</span>, and <span class="literal">Either</span> have the kind <span class="literal">* -&gt; * -&gt; *</span> to indicate that they take two types as input and produce a type as output. The symbol <span class="literal">(-&gt;)</span> is the same as the <span class="literal">Function</span> type constructor we defined above and <span class="literal">(,)</span> is the same as <span class="literal">Pair</span>. A three-place type constructor, such as <span class="literal">Triple</span>, has the kind <span class="literal">* -&gt; * -&gt; * -&gt; *</span> to indicate that it takes three types as input and produces a type as output. The symbol <span class="literal">(,,)</span> is the same as <span class="literal">Triple</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/><a href="ch09.xhtml#ch9tab5">Table 9-5</a> shows the meanings of various kinds in Haskell.</p>&#13;
<p class="tabcap" id="ch9tab5"><strong>Table 9-5:</strong> Meanings of Kinds</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Kind</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Meaning</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">*</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; *</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">One-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; * -&gt; *</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Two-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">* -&gt; * -&gt; * -&gt; *</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Three-place type constructor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">* -&gt; Constraint</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Type class for types</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">(* -&gt; *) -&gt; Constraint</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Type class for type constructors</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each type class also has a kind. A type class takes a type or type constructor as input and produces a constraint as output. The basic type classes we discussed in <a href="ch08.xhtml">Chapter 8</a> have the kind <span class="literal">* -&gt; Constraint</span>, meaning they take a type as input and produce a type-class constraint as output. The type class <span class="literal">Foldable</span> has the kind <span class="literal">(* -&gt; *) -&gt; Constraint</span>, meaning that it takes a type constructor (such as <span class="literal">List</span> or <span class="literal">Maybe</span>) as input and produces a type-class constraint as output. <span class="literal">List</span> and <span class="literal">Maybe</span> are instances of <span class="literal">Foldable</span>, but <span class="literal">IO</span> is not.</p>&#13;
<p class="indent">Our final use of tuples in this chapter is in numerical integration. By using a tuple together with <span class="literal">iterate</span>, we get a method for numerical integration that we can later generalize to a method for solving a differential equation.</p>&#13;
<h3 class="h3" id="ch9lev9">Numerical Integration Redux</h3>&#13;
<p class="noindent">We looked at numerical integration in <a href="ch06.xhtml">Chapter 6</a>, where we used a list comprehension to sum the areas of rectangles under a curve. Now that we have tuples, we can present an alternative method for numerical integration that comes closer to the method we’ll later use to solve differential equations. The idea is that if we pair up the current value of the integration variable (let’s call it time) with the accumulating value of the integral, we can proceed step by step to get the entire integral. To take one step forward, we increment the time by the time step and increment the running total that will ultimately be our integral by the area of one rectangle under the curve.</p>&#13;
<p class="indent">The function that advances one step looks like this:</p>&#13;
<pre>oneStep :: R         -- time step&#13;
        -&gt; (R -&gt; R)  -- function to integrate&#13;
        -&gt; (R,R)     -- current (t,y)&#13;
        -&gt; (R,R)     -- updated (t,y)&#13;
oneStep dt f (t,y) = let t' = t + dt&#13;
                         y' = y + f t * dt&#13;
                     in (t',y')</pre>&#13;
<p class="indent">The function <span class="literal">oneStep</span> names the incoming time step <span class="literal">dt</span>, the function to be integrated <span class="literal">f</span>, the current value of the integration variable <span class="literal">t</span>, and the current accumulating value of the integral <span class="literal">y</span>. It then returns a pair with the <span epub:type="pagebreak" id="page_125"/>integration variable increased by the time step and the current value of the integral increased by the area f t * dt of one rectangle under the function <span class="literal">f</span>.</p>&#13;
<p class="indent">To compute the integral, we iterate the single step as long as the independent variable is less than the upper limit.</p>&#13;
<pre>integral' :: R -&gt; Integration&#13;
integral' dt f a b&#13;
    = snd $ head $ dropWhile (\(t,_) -&gt; t &lt; b) $&#13;
      iterate (oneStep dt f) (a + dt/2,0)</pre>&#13;
<p class="indent">The expression <span class="literal">oneStep dt f :: (R,R) -&gt; (R,R)</span> is a function that updates the current time-integral pair by one time step. Since this function has the type <span class="literal">a -&gt; a</span>, it can be iterated with <span class="literal">iterate</span>. The expression iterate (oneStep dt f) (a + dt/2,0) produces an infinite list of time-integral pairs, starting with the time a + dt/2, which is in the middle of the first time interval, and an initial value of 0 for the value of the integral that will accumulate as we iterate.</p>&#13;
<p class="indent">By acting on the infinite list with <span class="literal">dropWhile (\(t,_) -&gt; t &lt; b)</span>, we drop the initial pairs whose times are less than the upper limit <span class="literal">b</span> to obtain an infinite list whose first pair has a time very close to the upper limit <span class="literal">b</span>. Acting on this infinite list with <span class="literal">head</span> returns the pair whose time is very close to the upper limit. Finally, acting on this pair with <span class="literal">snd</span> returns the value of the integral.</p>&#13;
<p class="indent">For convenience, here is the <span class="literal">Integration</span> type from <a href="ch06.xhtml">Chapter 6</a> that we used earlier in the type signature of <span class="literal">integral'</span>:</p>&#13;
<pre>type Integration = (R -&gt; R)  -- function&#13;
                 -&gt; R        -- lower limit&#13;
                 -&gt; R        -- upper limit&#13;
                 -&gt; R        -- result</pre>&#13;
<h3 class="h3" id="ch9lev10">Summary</h3>&#13;
<p class="noindent">This chapter introduced tuples, a way to combine two or more values into a single value. We then looked at type constructors, functions at the type level that form an output type from an input type. We ended the chapter by using tuples to introduce an alternative way to achieve numerical integration using <span class="literal">iterate</span>.</p>&#13;
<p class="indent">In the next chapter, we’ll return to physics, look at kinematics in three dimensions, and develop the data type we’ll use for vectors.</p>&#13;
<h3 class="h3" id="ch9lev11">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 9.1.</strong> Write a function</p>&#13;
<pre>polarToCart :: (R,R) -&gt; (R,R)</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_126"/>that takes as input polar coordinates (<em>r</em>, <em>θ</em>), with <em>θ</em> in radians, and returns as output a pair (x, y) of Cartesian coordinates.</p>&#13;
<p class="noindentts"><strong>Exercise 9.2.</strong> Explain in words the meaning of the types of <span class="literal">curry</span> and <span class="literal">uncurry</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.3.</strong> The Prelude function</p>&#13;
<pre>head :: [a] -&gt; a</pre>&#13;
<p class="noindentts">is slightly problematic in that it causes a runtime error if it is passed an empty list. Write a function</p>&#13;
<pre>headSafe :: [a] -&gt; Maybe a&#13;
headSafe = undefined</pre>&#13;
<p class="noindentts">that returns <span class="literal">Nothing</span> if passed the empty list and <span class="literal">Just x</span> otherwise, where <span class="literal">x</span> is the first element (the head) of the given list. Replace the undefined with your own code. (You can use undefined in your own functions as a placeholder if you want your code to load before you are finished writing it.)</p>&#13;
<p class="noindentts"><strong>Exercise 9.4.</strong> We mentioned earlier that the type <span class="literal">Maybe a</span> is a bit like the type <span class="literal">[a]</span>, except that elements of <span class="literal">Maybe a</span> are constrained to have zero or one element. To make this analogy precise, write a function</p>&#13;
<pre>maybeToList :: Maybe a -&gt; [a]&#13;
maybeToList = undefined</pre>&#13;
<p class="noindentts">that makes a list out of a <span class="literal">Maybe</span> type. What list should <span class="literal">Nothing</span> map to? What list should <span class="literal">Just x</span> map to?</p>&#13;
<p class="noindentts"><strong>Exercise 9.5.</strong> Find out and explain what happens when <span class="literal">zip</span> is used with two lists that don’t have the same length.</p>&#13;
<p class="noindentts"><strong>Exercise 9.6.</strong> Define a function</p>&#13;
<pre>zip' :: ([a], [b]) -&gt; [(a, b)]&#13;
zip' = undefined</pre>&#13;
<p class="noindentts">that turns a pair of lists into a list of pairs. (Hint: consider using <span class="literal">curry</span> or <span class="literal">uncurry</span>.)</p>&#13;
<p class="noindentts"><strong>Exercise 9.7.</strong> The dot operator (<span class="literal">.</span>) is for function composition. If we do <span class="literal">unzip</span> followed by <span class="literal">zip'</span>, we have a function with the following type signature:</p>&#13;
<pre>   zip' . unzip :: [(a, b)] -&gt; [(a, b)]</pre>&#13;
<p class="indent">Is this the identity function? (In other words, does it always return the expression it was given?) If so, how do you know? If not, give a counterexample.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>If we do <span class="literal">zip'</span> followed by <span class="literal">unzip</span>, we have a function with the following type signature:</p>&#13;
<pre>   unzip . zip' :: ([a], [b]) -&gt; ([a], [b])</pre>&#13;
<p class="indent">Is this the identity function?</p>&#13;
<p class="noindentts"><strong>Exercise 9.8.</strong> Using the <span class="literal">grades</span> lookup table from earlier, show how to use the <span class="literal">lookup</span> function to produce the value <span class="literal">Just 89</span>. Also show how to use the <span class="literal">lookup</span> function to produce the value <span class="literal">Nothing</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.9.</strong> Translate the following mathematical function into Haskell:</p>&#13;
<div class="imagec"><em>x</em>(<em>r</em>, <em>θ</em>, <em>ϕ</em>) = <em>r</em> sin <em>θ</em> cos <em>ϕ</em></div>&#13;
<p class="indent">Use a triple for the input to the function <span class="literal">x</span>. Give a type signature as well as a function definition.</p>&#13;
<p class="noindentts"><strong>Exercise 9.10.</strong> A car starts from rest and accelerates at 5 m/s<sup>2</sup> along a straight, level highway. We want to make an infinite list <span class="literal">tvPairs</span> of time-velocity pairs for this car, one every second. Here is our code for <span class="literal">tvPairs</span>:</p>&#13;
<pre>tvPairs :: [(R,R)]&#13;
tvPairs = iterate tvUpdate (0,0)</pre>&#13;
<p class="indent">Write a type signature and function definition for <span class="literal">tvUpdate</span>.</p>&#13;
<pre>tvUpdate = undefined</pre>&#13;
<p class="indent">The list <span class="literal">tvPairs</span> should look like [(0,0),(1,5),(2,10),(3,15),...]. After you write the function <span class="literal">tvUpdate</span>, use the <span class="literal">take</span> function to see the first several elements of <span class="literal">tvPairs</span>.</p>&#13;
<p class="noindentts"><strong>Exercise 9.11.</strong> A Fibonacci sequence is one in which each term is the sum of the previous two terms. The first several terms are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. Write a sequence</p>&#13;
<pre>fibonacci :: [Int]&#13;
fibonacci = undefined</pre>&#13;
<p class="noindentts">for the (infinite) list of Fibonacci numbers.</p>&#13;
<p class="indent">As a suggestion, write a helping sequence</p>&#13;
<pre>fibHelper :: [(Int,Int)]&#13;
fibHelper = undefined</pre>&#13;
<p class="noindentts">using the function <span class="literal">iterate</span>. The first several terms of fibHelper should be [(0,1),(1,1),(1,2),(2,3),(3,5),...]. Then write the sequence <span class="literal">fibonacci</span> using <span class="literal">fibHelper</span>.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_128"/><strong>Exercise 9.12.</strong> The factorial function takes a non-negative integer and returns the product of all positive integers up to and including the given integer. It is usually denoted with an exclamation point. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120. We define 0! = 1. The purpose of this exercise is to write a factorial function</p>&#13;
<pre>fact :: Int -&gt; Int</pre>&#13;
<p class="noindentts">using <span class="literal">iterate</span>. The suggestion in Exercise 9.11 is useful here as well (write a sequence <span class="literal">factHelper :: [(Int,Int)]</span> using <span class="literal">iterate</span> and then define <span class="literal">fact</span> to get its values from this sequence using the <span class="literal">!!</span> operator).</p>&#13;
<p class="noindentts"><strong>Exercise 9.13.</strong> Write the following function using a list comprehension rather than a map:</p>&#13;
<pre>pick13 :: [(R,R,R)] -&gt; [(R,R)]&#13;
pick13 triples = map (\(x1,_,x3) -&gt; (x1,x3)) triples</pre>&#13;
<p class="noindentts"><strong>Exercise 9.14.</strong> Suppose we throw a rock straight up in the air at 15 m/s. Use a list comprehension to make a list of (time, position, velocity) triples (type <span class="literal">[(R,R,R)]</span>) for an interval of time while the rock is in the air. Your list should have enough triples to let the data make a reasonably smooth graph if plotted.</p>&#13;
<p class="noindentts"><strong>Exercise 9.15.</strong> Tuples can be nested, like <span class="literal">((3,4),5)</span>. Although this pair contains three numbers, it is not the same as a triple. Write a function</p>&#13;
<pre>toTriple :: ((a,b),c) -&gt; (a,b,c)&#13;
toTriple = undefined</pre>&#13;
<p class="noindentts">that converts a pair whose first component is a pair into a triple.</p>&#13;
</div></body></html>