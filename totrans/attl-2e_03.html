<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_35"/><span class="big">3</span><br/>UNDERSTANDING THE GNU CODING STANDARDS</h2>&#13;
<p class="quote"><em>I don’t know what’s the matter with people: they don’t learn by understanding, they learn by some other way—by rote or something. Their knowledge is so fragile!<br/>—Richard Feynman</em>, “Surely You’re Joking, Mr. Feynman!”</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In <a href="ch02.xhtml">Chapter 2</a>, I gave an overview of the GNU Autotools and some resources that can help reduce the learning curve required to master them. In this chapter, we’re going to step back a little and examine project organization techniques that you can apply to any project, not just one that uses the Autotools.</p>&#13;
<p class="indent">When you’re done reading this chapter, you should be familiar with the common <span class="literal">make</span> targets and why they exist. You should also have a solid understanding of why projects are organized the way they are. You will, in fact, be well on your way to becoming an Autotools expert.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>The information provided in this chapter comes primarily from two sources:</p>&#13;
<ul>&#13;
<li class="noindent">The <em>GNU Coding Standards (GCS)</em><sup><a id="ch03fn_1" href="footnote.xhtml#ch03fn1">1</a></sup></li>&#13;
<li class="noindent">The <em>Filesystem Hierarchy Standard (FHS)</em><sup><a id="ch03fn_2" href="footnote.xhtml#ch03fn2">2</a></sup></li>&#13;
</ul>&#13;
<p class="indent">If you’d like to brush up on your <span class="literal">make</span> syntax, you may also find the <em>GNU Make Manual</em> <sup><a id="ch03fn_3" href="footnote.xhtml#ch03fn3">3</a></sup> very useful. If you’re particularly interested in portable <span class="literal">make</span> syntax, then check out the POSIX man page for <span class="literal">make</span>.<sup><a id="ch03fn_4" href="footnote.xhtml#ch03fn4">4</a></sup> Note, however, there are current discussions on the Autotools mailing lists around making GNU <span class="literal">make</span> the target standard because it’s so widely available today. Therefore, portable <span class="literal">make</span> script isn’t as important as it used to be.</p>&#13;
<h3 class="h3" id="ch03sec1">Creating a New Project Directory Structure</h3>&#13;
<p class="noindent">You need to ask yourself two questions when you’re setting up the build system for an open source software project:</p>&#13;
<ul>&#13;
<li class="noindent">Which platforms will I target?</li>&#13;
<li class="noindent">What do my users expect?</li>&#13;
</ul>&#13;
<p class="indentt">The first is an easy question—you get to decide which platforms to target, but you shouldn’t be too restrictive. Open source software projects are only as good as their communities, and arbitrarily limiting the number of platforms reduces the potential size of your community. However, you might consider supporting only current versions of your target platforms. You can check with user groups and communities to determine which versions of each are relevant.</p>&#13;
<p class="indent">The second question is more difficult to answer. First, let’s narrow the scope to something manageable. What you really need to ask is, <em>What do my users expect of my build system?</em> Experienced open source software developers become familiar with these expectations by downloading, unpacking, building, and installing hundreds of packages. Eventually, they come to know intuitively what users expect of a build system. But, even so, the processes of package configuration, build, and installation vary widely, so it’s difficult to define any solid norm.</p>&#13;
<p class="indent">Rather than taking a survey of every build system out there yourself, you can consult the Free Software Foundation (FSF), sponsor of the GNU project, which has done a lot of the legwork for you. The FSF provides some of the best definitive sources of information on free, open source software, including the <em>GCS</em>, which covers a wide variety of topics related to writing, <span epub:type="pagebreak" id="page_37"/>publishing, and distributing free, open source software. Even many non-GNU open source software projects align themselves with the <em>GCS</em>. Why? Well, the FSF invented the concept of free software, and the ideas make sense, for the most part.<sup><a id="ch03fn_5" href="footnote.xhtml#ch03fn5">5</a></sup> There are dozens of issues to consider when designing a system that manages packaging, building, and installing software, and the <em>GCS</em> takes most of them into account.</p>&#13;
<div class="box5">&#13;
<p class="sidebart">WHAT’S IN A NAME?</p>&#13;
<p class="noindent">You probably know that open source software projects generally have quirky names—they might be named after some device, an invention, a Latin term, a past hero, an ancient god, or they might be named after some small, furry animal that has (vaguely) similar characteristics to the software. Some names are just made-up words or acronyms that are catchy and easy to pronounce. Another significant characteristic of a good project name is uniqueness—it’s important that your project be easy to distinguish from others. You also want your project name to be easy to distinguish from any other uses of the name in a search engine. Additionally, you should ensure that your project’s name does not have negative connotations in any language or culture.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch03sec2">Project Structure</h3>&#13;
<p class="indent">We’ll start with a basic sample project and build on it as we continue our exploration of source-level software distribution. We’ll call our project <em>Jupiter</em> and create a project directory structure using the following commands:</p>&#13;
<pre>$ <span class="codestrong1">cd projects</span>&#13;
$ <span class="codestrong1">mkdir -p jupiter/src</span>&#13;
$ <span class="codestrong1">cd jupiter</span>&#13;
$ <span class="codestrong1">touch Makefile src/Makefile jupiter/src/main.c</span>&#13;
$</pre>&#13;
<p class="indent">We now have one source code directory called <em>src</em>, one C source file called <em>main.c</em>, and a makefile for each of the two directories in our project. Minimal, yes, but this is a new endeavor and the key to a successful open source software project is evolution. Start small and grow as needed—and as you have the time and inclination.</p>&#13;
<p class="indent">Let’s start by adding support for building and cleaning our project. We’ll need to add other important capabilities to our build system later on, but these two will get us going. The top-level makefile does very little at this point; it merely passes requests down to <em>src/Makefile</em>, recursively. This <span epub:type="pagebreak" id="page_38"/>constitutes a fairly common type of build system, known as a <em>recursive build system</em>, so named because makefiles recursively invoke <span class="literal">make</span> on subdirectory makefiles.<sup><a id="ch03fn_6" href="footnote.xhtml#ch03fn6">6</a></sup> We’ll spend a little time at the end of this chapter considering how to convert our recursive system into a nonrecursive system.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex01">Listings 3-1</a> through <a href="ch03.xhtml#ch03ex03">3-3</a> show the contents of each of these three files, thus far.</p>&#13;
<p class="margin">Git tag 3.0</p>&#13;
<pre>all clean jupiter:&#13;
        cd src &amp;&amp; $(MAKE) $@&#13;
&#13;
.PHONY: all clean</pre>&#13;
<p class="caption"><a id="ch03ex01"/><em>Listing 3-1: Makefile: An initial draft of a top-level makefile for Jupiter</em></p>&#13;
<pre>all: jupiter&#13;
&#13;
jupiter: main.c&#13;
        gcc -g -O0 -o $@ main.c&#13;
clean:&#13;
        -rm jupiter&#13;
&#13;
.PHONY: all clean</pre>&#13;
<p class="caption"><a id="ch03ex02"/><em>Listing 3-2:</em> src/Makefile: <em>The first draft of Jupiter’s src directory makefile</em></p>&#13;
<pre>#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
&#13;
int main(int argc, char * argv[])&#13;
{&#13;
    printf("Hello from %s!\n", argv[0]);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="caption"><a id="ch03ex03"/><em>Listing 3-3:</em> src/main.c: <em>The first version of the only C source file in the Jupiter project</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As you read this code, you will probably notice places where a makefile or a source code file contains a construct that is not written in the simplest manner or is perhaps not written the way you would have chosen to write it. There is a method to my madness: I’ve tried to use constructs that are portable to many flavors of the <em><span class="literal">make</span></em> utility.</em></p>&#13;
</div>&#13;
<p class="indentt">Now let’s discuss the basics of <span class="literal">make</span>. If you’re already pretty well versed in it, you can skip the next section. Otherwise, give it a quick read, and we’ll return our attention to the Jupiter project later in the chapter.</p>&#13;
<h3 class="h3" id="ch03sec3"><span epub:type="pagebreak" id="page_39"/>Makefile Basics</h3>&#13;
<p class="noindent">If you don’t use <span class="literal">make</span> on a regular basis, it’s often difficult to remember exactly what goes where in a makefile, so here are a few things to keep in mind. Besides comments, which begin with a hash mark (<span class="literal">#</span>), there are only two basic types of entities in a makefile:</p>&#13;
<ul>&#13;
<li class="noindent">Rule definitions</li>&#13;
<li class="noindent">Variable assignments</li>&#13;
</ul>&#13;
<p class="indent">While there are several other types of constructs in a makefile (including conditional statements, directives, extension rules, pattern rules, function variables, and include statements, among others), for our purposes, we’ll just touch lightly on them as needed instead of covering them all in detail. This doesn’t mean they’re unimportant. On the contrary, they’re very useful if you’re going to write your own complex build system by hand. However, our purpose is to gain the background necessary for understanding the GNU Autotools, so I’ll only cover the aspects of <span class="literal">make</span> you need to know to accomplish that goal.</p>&#13;
<p class="indent">If you want a broader education on <span class="literal">make</span> syntax, refer to the <em>GNU Make Manual</em>. For strictly portable syntax, the POSIX man page for <span class="literal">make</span> is an excellent reference. If you want to become a <span class="literal">make</span> expert, be prepared to spend a good deal of time studying these resources—there’s much more to the <span class="literal">make</span> utility than is initially apparent.</p>&#13;
<h4 class="h4" id="ch03sec3-1"><em>Rules</em></h4>&#13;
<p class="noindent">Rules follow the general format shown in <a href="ch03.xhtml#ch03ex04">Listing 3-4</a>.</p>&#13;
<pre><span class="codeitalic1">targets</span>: [<span class="codeitalic1">dependencies</span>][; <span class="codeitalic1">command-0</span>]&#13;
[&lt;tab&gt;<span class="codeitalic1">command-1</span>&#13;
&lt;tab&gt;<span class="codeitalic1">command-2</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
&lt;tab&gt;<span class="codeitalic1">command-N</span>]</pre>&#13;
<p class="caption"><a id="ch03ex04"/><em>Listing 3-4: The syntax of a rule within a makefile</em></p>&#13;
<p class="indent">In this syntax definition, square brackets (<span class="literal">[</span> and <span class="literal">]</span>) denote optional portions of a rule and <span class="literal">&lt;tab&gt;</span> represents a tab (ctrl-i) character.</p>&#13;
<p class="indent">Except for the tab characters and the line feeds, all other whitespace is optional and ignored. When a line in a makefile begins with a tab character, <span class="literal">make</span> generally considers it a command (with the exception of continuation lines, discussed later). Indeed, one of the most frustrating aspects of makefile syntax to neophytes and experts alike is that commands must be prefixed with an essentially invisible character. The error messages generated by the legacy UNIX <span class="literal">make</span> utility when a required tab is missing (or has been converted to spaces by your editor), or when an unintentional tab is inserted at the start of a line that follows something that could be <span epub:type="pagebreak" id="page_40"/>interpreted as a rule, are obscure at best. GNU <span class="literal">make</span> does a better job with such error messages. Nonetheless, be careful to use leading tab characters properly in your makefiles—always and only before commands.<sup><a id="ch03fn_7" href="footnote.xhtml#ch03fn7">7</a></sup></p>&#13;
<p class="indent">Note that almost everything in a rule is optional; the only required aspect of a rule is the <em><span class="literal">targets</span></em> portion and its colon (<span class="literal">:</span>) character. Use of the first command, <em><span class="literal">command-0</span></em> and its preceding semicolon (<span class="literal">;</span>), is an optional form that’s generally discouraged by the Autotools, but is perfectly legitimate <span class="literal">make</span> syntax if you have a single command to execute. You may even combine <em><span class="literal">command-0</span></em> with additional commands, but this almost never done.</p>&#13;
<p class="indent">In general, <em>targets</em> are objects that need to be built, and <em>dependencies</em> are objects that provide source material for targets. Thus, targets are said to depend upon the dependencies. Dependencies are essentially <em>prerequisites</em> of the targets, and therefore they should be updated first.<sup><a id="ch03fn_8" href="footnote.xhtml#ch03fn8">8</a></sup></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex05">Listing 3-5</a> shows the general layout of a makefile.</p>&#13;
<pre><span class="codeitalic1">var1</span> = <span class="codeitalic1">val1</span>&#13;
<span class="codeitalic1">var2</span> = <span class="codeitalic1">val2</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
<span class="codeitalic1">target1</span> : <span class="codeitalic1">t1_dep1 t1_dep2</span> ... <span class="codeitalic1">t1_depN</span>&#13;
&lt;tab&gt;<span class="codeitalic1">shell-command1a</span>&#13;
&lt;tab&gt;<span class="codeitalic1">shell-command1b</span>&#13;
<span class="codeitalic1">--snip</span><span class="codeitalic1">--</span>&#13;
<span class="codeitalic1">target2</span> : <span class="codeitalic1">t2_dep1 t2_dep2</span> ... <span class="codeitalic1">t2_depN</span>&#13;
&lt;tab&gt;<span class="codeitalic1">shell-command2a</span>&#13;
&lt;tab&gt;<span class="codeitalic1">shell-command2b</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex05"/><em>Listing 3-5: The general layout of a makefile</em></p>&#13;
<p class="indent">The contents of a makefile comprise a <em>declarative language</em> wherein you define a set of desired goals and <span class="literal">make</span> decides the best way to accomplish those goals. The <span class="literal">make</span> utility is a rule-based command engine, and the rules at work indicate which commands should be executed and when. When you define commands within rules, you’re telling <span class="literal">make</span> that you want it to execute each of the following statements from a shell whenever the preceding target should be built. Presumably, the commands actually do create or update the target. The existence and timestamps of the files mentioned in the targets and dependencies of rules indicate whether the commands should be executed and in what order.</p>&#13;
<p class="indent">As <span class="literal">make</span> processes the text in a makefile, it builds a web of dependency chains (technically called a <em>directed acyclic graph</em>, or <em>DAG</em>). When building a particular target, <span class="literal">make</span> must walk backward through the entire graph to the beginning of each “chain.” While traversing a chain, <span class="literal">make</span> executes the commands for each rule, beginning with the rule farthest from the target and <span epub:type="pagebreak" id="page_41"/>working forward to the rule for the desired target. As <span class="literal">make</span> discovers targets that are older than their dependencies, it must execute the associated set of commands to update those targets before it can process the next rule in the chain. As long as the rules are written correctly, this algorithm ensures that <span class="literal">make</span> will build a completely up-to-date product using the least number of operations possible. Indeed, as we’ll see shortly, when the rules in a makefile are written properly, it’s rather a joy to watch it run after various changes to files in the project.</p>&#13;
<h4 class="h4" id="ch03sec3-2"><em>Variables</em></h4>&#13;
<p class="noindent">Lines in a makefile containing an equal sign (<span class="literal">=</span>) are variable definitions. Variables in makefiles are somewhat similar to shell or environment variables, but there are some key differences.</p>&#13;
<p class="indent">In Bourne-shell syntax, you’d reference a variable in this manner: <span class="literal">${my_var}</span>. Equally viable, without the curly brackets, is <span class="literal">$my_var</span>. The syntax for referencing variables in a makefile is nearly identical, except that you have the choice of using curly brackets or parentheses: <span class="literal">$(my_var)</span>. To minimize confusion, it has become somewhat of a convention to use parentheses rather than curly brackets when dereferencing <span class="literal">make</span> variables. For single-character <span class="literal">make</span> variables, using these delimiters is optional, but you should use them in order to avoid ambiguity. For example, <span class="literal">$X</span> is functionally equivalent to <span class="literal">$(X)</span> or <span class="literal">${X}</span>, but <span class="literal">$(my_var)</span> would require parentheses so <span class="literal">make</span> does not interpret the reference as <span class="literal">$(m)y_var</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To dereference a shell variable inside a <em><span class="literal">make</span></em> command, escape the dollar sign by doubling it—for example, <em><span class="literal">$${shell_var}</span></em>. Escaping the dollar sign tells <em><span class="literal">make</span></em> not to interpret the variable reference but rather to treat it as literal text in the command. The variable reference is thus left to be interpolated by the shell when the command is executed.</em></p>&#13;
</div>&#13;
<p class="indent">By default, <em><span class="literal">make</span></em> reads the process environment into its variable table before processing the makefile; this allows you to access most environment variables without explicitly defining them in the makefile. Note, however, that variables set inside the makefile will override those obtained from the environment.<sup><a id="ch03fn_9" href="footnote.xhtml#ch03fn9">9</a></sup> It’s generally not a good idea to depend on the existence of environment variables in your build process, although it’s okay to use them conditionally. In addition, <span class="literal">make</span> defines several useful variables of its own, such as the <span class="literal">MAKE</span> variable, the value of which is the command used to invoke <span class="literal">make</span> for the current process.</p>&#13;
<p class="indent">You can assign variables at any point in the makefile. However, you should be aware that <span class="literal">make</span> processes a makefile in two passes. In the first pass, it gathers variables and rules into tables and internal structures. In the second pass, it resolves dependencies defined by the rules, invoking those rules as necessary to rebuild the dependencies based on the filesystem <span epub:type="pagebreak" id="page_42"/>timestamps gathered during the first pass. If a dependency in a rule is newer than the target or if the target is missing, then <span class="literal">make</span> executes the commands of the rule to update the target. Some variable references are resolved immediately during the first pass while processing rules, and others are resolved later during the second pass while executing commands.</p>&#13;
<h4 class="h4" id="ch03sec3-3"><em>A Separate Shell for Each Command</em></h4>&#13;
<p class="noindent">As it processes rules, <span class="literal">make</span> executes each command independently of those around it. That is, each individual command under a rule is executed in its own shell. This means that you cannot export a shell variable in one command and then try to access its value in the next.</p>&#13;
<p class="indent">To do something like this, you would have to string commands together on the same command line with command separator characters (for example, semicolons in Bourne-shell syntax). When you write commands like this, <span class="literal">make</span> passes the set of concatenated commands as one command line to the same shell. To avoid long command lines and increase readability, you can wrap them using a backslash at the end of each line—by convention, after the semicolon.<sup><a id="ch03fn_10" href="footnote.xhtml#ch03fn10">10</a></sup> The wrapped portion of such commands may also be preceded by a tab character. POSIX specifies that <span class="literal">make</span> remove all leading tab characters (even those following escaped newlines) before processing commands, but be aware that some implementations of <span class="literal">make</span> do output—usually harmlessly—the tab characters embedded within wrapped commands.<sup><a id="ch03fn_11" href="footnote.xhtml#ch03fn11">11</a></sup></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex06">Listing 3-6</a> shows a few simple examples of multiple commands that will be executed by the same shell.</p>&#13;
<pre><span class="ent">➊</span> foo: bar.c&#13;
           sources=bar.c; \&#13;
           gcc -o foo $${sources}&#13;
<span class="ent">➋</span> fud: baz.c&#13;
           sources=baz.c; gcc -o fud $${sources}&#13;
<span class="ent">➌</span> doo: doo.c&#13;
           TMPDIR=/var/tmp gcc -o doo doo.c</pre>&#13;
<p class="caption"><a id="ch03ex06"/><em>Listing 3-6: A makefile with some examples of multiple commands executed by the same shell</em></p>&#13;
<p class="indent">In the first example at <span class="ent">➊</span>, both lines are executed by the same shell because the backslash escapes the newline character between the lines. The <span class="literal">make</span> utility will remove any escaped newline characters before passing a single, multi-command statement to the shell. The second example at <span class="ent">➋</span> is identical to the first, from <span class="literal">make</span>’s perspective.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>The third example at <span class="ent">➌</span> is a bit different. In this case, I’ve defined the <span class="literal">TMPDIR</span> variable only for the child process that will run <span class="literal">gcc</span>.<sup><a id="ch03fn_12" href="footnote.xhtml#ch03fn12">12</a></sup> Note the missing semicolon; as far as the shell is concerned, this is a single command.<sup><a id="ch03fn_13" href="footnote.xhtml#ch03fn13">13</a></sup></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you choose to wrap commands with a trailing backslash, be sure that there are no spaces or other invisible characters after it. The backslash escapes the newline character, so it must immediately precede that character.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03sec3-4"><em>Variable Binding</em></h4>&#13;
<p class="noindent">Variables referenced in commands may be defined after the command in the makefile because such references are not bound to their values until just before <span class="literal">make</span> passes the command to the shell for execution—long after the entire makefile has been read. In general, <span class="literal">make</span> binds variables to values as late as it possibly can.</p>&#13;
<p class="indent">Since commands are processed at a later stage than rules, variable references in commands are bound later than those in rules. Variable references found in rules are expanded when <span class="literal">make</span> builds the directed graph from the rules in the makefile. Thus, a variable referenced in a rule must be fully defined in a makefile before the referencing rule. <a href="ch03.xhtml#ch03ex07">Listing 3-7</a> shows a portion of a makefile that illustrates both of these concepts.</p>&#13;
<pre>   <span class="codeitalic1">--snip--</span>&#13;
   mytarget = foo&#13;
<span class="ent">➊</span> $(mytarget): $(mytarget).c&#13;
        <span class="ent">➋</span> gcc -o $(mytarget) $(mytarget).c&#13;
   mytarget = bar&#13;
   <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex07"/><em>Listing 3-7: Variable expansion in a makefile</em></p>&#13;
<p class="indent">In the rule at <span class="ent">➊</span>, both references to <span class="literal">$(mytarget)</span> are expanded to <span class="literal">foo</span> because they’re processed during the first pass, when <span class="literal">make</span> is building the variable list and directed graph. However, the outcome is probably not what you’d expect, because both references to <span class="literal">$(mytarget)</span> in the command at <span class="ent">➋</span> are not expanded until much later, long after <span class="literal">make</span> has already assigned <span class="literal">bar</span> to <span class="literal">mytarget</span>, overwriting the original assignment of <span class="literal">foo</span>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex08">Listing 3-8</a> shows the same rule and command the way <span class="literal">make</span> sees them after the variables are fully expanded.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
foo: foo.c&#13;
        gcc -o bar bar.c&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex08"/><em>Listing 3-8: The results after variable expansion of the code in <a href="ch03.xhtml#ch03ex07">Listing 3-7</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>The moral of this story is that you should understand where variables will be expanded in makefile constructs so you’re not surprised when <span class="literal">make</span> refuses to act in a sane manner when it processes your makefile. It is good practice (and a good way to avoid headaches) to always assign variables before you intend to use them. For more information on immediate and deferred expansion of variables in makefiles, refer to “How make Reads a Makefile” in the <em>GNU Make Manual</em>.</p>&#13;
<h4 class="h4" id="ch03sec3-5"><em>Rules in Detail</em></h4>&#13;
<p class="noindent">The rules used in my examples, known as <em>common</em> <span class="literal">make</span> rules, contain a single colon character (<span class="literal">:</span>). The colon separates targets on the left from dependencies on the right.</p>&#13;
<p class="indent">Remember that targets are products—that is, filesystem entities that can be produced by running one or more commands, such as a C or C++ compiler, a linker, or a documentation generator like Doxygen or LaTeX. Dependencies, on the other hand, are source objects, or objects from which targets are created. These may be computer language source files, intermediate products built by a previous rule, or anything else that can be used by a command as a resource.</p>&#13;
<p class="indent">You can specify any target defined within a makefile rule directly on the <span class="literal">make</span> command line, and <span class="literal">make</span> will execute all the commands necessary to generate that target.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you don’t specify any targets on the <em><span class="literal">make</span></em> command line, <em><span class="literal">make</span></em> will use the default target—the first one it finds in the makefile.</em></p>&#13;
</div>&#13;
<p class="indent">For example, a C compiler takes dependency <em>main.c</em> as input and generates target <em>main.o</em>. A linker then takes dependency <em>main.o</em> as input and generates a named executable target—<span class="literal">program</span>, in this case.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03fig01">Figure 3-1</a> shows the flow of data as it might be specified by the rules defined in a makefile.</p>&#13;
<div class="image"><img src="../images/03fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch03fig01"><em>Figure 3-1: A data flow diagram for the compile and link processes</em></p>&#13;
<p class="indent">The <span class="literal">make</span> utility implements some fairly complex logic to determine when a rule should be run, based on whether a target exists and whether it is older than its dependencies. <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> shows a makefile containing rules, some of which execute the actions in <a href="ch03.xhtml#ch03fig01">Figure 3-1</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_45"/>program: main.o print.o display.o&#13;
     <span class="ent">➊</span> ld main.o print.o display.o ... -o program&#13;
&#13;
main.o: main.c&#13;
        gcc -c -g -O2 -o main.o main.c&#13;
&#13;
print.o: print.c&#13;
        gcc -c -g -O2 -o print.o print.c&#13;
&#13;
display.o: display.c&#13;
        gcc -c -g -O2 -o display.o display.c</pre>&#13;
<p class="caption"><a id="ch03ex09"/><em>Listing 3-9: Using multiple <span class="literal">make</span> rules to compile and link a program</em></p>&#13;
<p class="indent">The first rule in this makefile says that <span class="literal">program</span> depends on <em>main.o</em>, <em>print.o</em>, and <em>display.o</em>. The remaining rules say that each <em>.o</em> file depends on the corresponding <em>.c</em> file. Ultimately, <span class="literal">program</span> depends on the three source files, but the object files are necessary as intermediate dependencies because there are two steps to the process—compile and link—with a result in between. For each rule, <span class="literal">make</span> uses an associated list of commands to build the rule’s target from its list of dependencies.</p>&#13;
<p class="indent">Unix compilers are designed as higher-level tools than linkers. They have built-in, low-level knowledge about system-specific linker requirements. In the makefile in <a href="ch03.xhtml#ch03ex09">Listing 3-9</a>, the ellipsis in the line at <span class="ent">➊</span> is a placeholder for a list of system-specific, low-level objects and libraries required to build all programs on this system. The compiler can be used to call the linker, silently passing these system-specific objects and libraries. (It’s so effective and widely used that it’s often difficult to discover how to manually execute the linker on a given system.) <a href="ch03.xhtml#ch03ex10">Listing 3-10</a> shows how you might rewrite the makefile from <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> to use the compiler to compile the sources and call the linker in a single rule.</p>&#13;
<pre>sources = main.c print.c display.c&#13;
&#13;
program: $(sources)&#13;
        gcc -g -O2 -o program $(sources)</pre>&#13;
<p class="caption"><a id="ch03ex10"/><em>Listing 3-10: Using a single <span class="literal">make</span> rule to compile sources into an executable</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Using a single rule and command to process both steps is possible in this case because the example is very basic. For larger projects, skipping from source to executable in a single step is usually not the wisest way to manage the build process. However, in either case, using the compiler to call the linker can ease the burden of determining the many system objects that need to be linked into an application, and, in fact, this very technique is used quite often. More complex examples, wherein each file is compiled separately, use the compiler to compile each source file into an object file and then use the compiler to call the linker to link them all together into an executable.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>In this example, I’ve added a <span class="literal">make</span> variable (<span class="literal">sources</span>) that allows us to consolidate all product dependencies into one location. We now have a list of source files captured in a variable definition that is referenced in two places: in the dependency list and on the command line.</p>&#13;
<h5 class="h5">Automatic Variables</h5>&#13;
<p class="noindent">There may be other kinds of objects in a dependency list that are not in the <span class="literal">sources</span> variable, including precompiled objects and libraries. These other objects would have to be listed separately, both in the rule and on the command line. Wouldn’t it be nice if we had a shorthand notation for referencing the rule’s entire dependency list in the commands?</p>&#13;
<p class="indent">As it happens, various <em>automatic</em> variables can be used to reference portions of the controlling rule during the execution of a command. Unfortunately, most of these are all but useless if you care about portability between implementations of <span class="literal">make</span>. The <span class="literal">$@</span> variable (which references the current target) happens to be portable and useful, but most of the other automatic variables are too limited to be very useful.<sup><a id="ch03fn_14" href="footnote.xhtml#ch03fn14">14</a></sup> The following is a complete list of portable automatic variables defined by POSIX for <span class="literal">make</span>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">$@</span> refers to the full target name of the current target or the archive filename part of a library archive target. This variable is valid in both explicit and implicit rules.</li>&#13;
<li class="noindent"><span class="literal">$%</span> refers to a member of an archive and is valid only when the current target is an archive member—that is, an object file that is a member of a static library. This variable is valid in both explicit and implicit rules.</li>&#13;
<li class="noindent"><span class="literal">$?</span> refers to the list of dependencies that are newer than the current target. This variable is valid in both explicit and implicit rules.</li>&#13;
<li class="noindent"><span class="literal">$&lt;</span> refers to the member of the dependency list whose existence allowed the rule to be chosen for the target. This variable is only valid in implicit rules.</li>&#13;
<li class="noindent"><span class="literal">$*</span> refers to the current target name with its suffix deleted. This variable is guaranteed by POSIX to be valid only in implicit rules.</li>&#13;
</ul>&#13;
<p class="indent">GNU <span class="literal">make</span> dramatically extends the POSIX-defined list, but since GNU extensions are not portable, it’s unwise to use any of these except <span class="literal">$@</span>.</p>&#13;
<h5 class="h5">Dependency Rules</h5>&#13;
<p class="noindent">Let us now assume that <em>print.c</em> and <em>display.c</em> each have a header file of the same name, ending in <em>.h</em>. Each of these source files includes its own header file, but <em>main.c</em> includes both <em>print.h</em> and <em>display.h</em>. Given the makefiles of <a href="ch03.xhtml#ch03ex09">Listings 3-9</a> and <a href="ch03.xhtml#ch03ex10">3-10</a>, what do you suppose would happen if you executed <span epub:type="pagebreak" id="page_47"/><span class="literal">make</span> to build <span class="literal">program</span>, then modified one of the header files—say <em>print.h</em>—and then re-executed <span class="literal">make</span>? Nothing would happen because <span class="literal">make</span> is unaware even of the existence of these header files. As far as <span class="literal">make</span> is concerned, you didn’t touch anything related to <span class="literal">program</span>.</p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch03ex11">Listing 3-11</a>, I’ve replaced the <span class="literal">sources</span> variable with an <span class="literal">objects</span> variable and replaced the list of source files with a list of object files. This version of the makefile in <a href="ch03.xhtml#ch03ex10">Listing 3-10</a> also eliminates redundancy by making use of both standard and automatic variables.</p>&#13;
<pre>objects <span class="ash">= main.</span>o <span class="ash">print.</span>o <span class="ash">display.</span>o&#13;
&#13;
main.o: main.c print.h display.h&#13;
print.o: print.c print.h&#13;
display.o: display.c display.h&#13;
&#13;
<span class="ash">program: $(</span>objects<span class="ash">)</span>&#13;
        <span class="ash">gcc -g -O2 -o</span> $@ <span class="ash">$(</span>objects<span class="ash">)</span></pre>&#13;
<p class="caption"><a id="ch03ex11"/><em>Listing 3-11: Using automatic variables in a command</em></p>&#13;
<p class="indent">I’ve also added three <em>dependency rules</em>, which are rules without commands that clarify the relationships between compiler output files and dependent source and header files. Because <em>print.h</em> and <em>display.h</em> are (presumably) included by <em>main.c</em>, <em>main.c</em> must be recompiled if either of those files changes; however, <span class="literal">make</span> has no way of knowing that these two header files are included by <em>main.c</em>. Dependency rules allow the developer to tell <span class="literal">make</span> about such backend relationships.</p>&#13;
<h5 class="h5">Implicit Rules</h5>&#13;
<p class="noindent">If you attempt to mentally follow the dependency graph that <span class="literal">make</span> would build from the rules within the makefile in <a href="ch03.xhtml#ch03ex11">Listing 3-11</a>, you’ll find what appears to be a hole in the web. According to the last rule in the file, the <span class="literal">program</span> executable depends on <em>main.o</em>, <em>print.o</em>, and <em>display.o</em>. This rule also provides the command to link these objects into an executable (using the compiler merely to call the linker this time). The object files are tied to their corresponding C source and header files by the three dependency rules. But where are the commands that compile the <em>.c</em> files into <em>.o</em> files?</p>&#13;
<p class="indent">We could add these commands to the dependency rules, but there’s really no need because <span class="literal">make</span> has a <em>built-in</em> rule that knows how to build <em>.o</em> files from <em>.c</em> files. There’s nothing magic about <span class="literal">make</span>—it only knows about the relationships you describe to it through the rules you write. But <span class="literal">make</span> does have certain built-in rules that describe the relationships between, for example, <em>.c</em> files and <em>.o</em> files. This particular built-in rule provides commands for building anything with a <em>.o</em> extension from a file of the same base name with a <em>.c</em> extension. These built-in rules are called <em>suffix rules</em> or, more generally, <em>implicit rules</em>, because the name of the dependency (source file) is implied by the name of the target (object file).</p>&#13;
<p class="indent">To make the built-in implicit rules more widely usable, their commands often consume well-known <span class="literal">make</span> variables. If you set those variables, <span epub:type="pagebreak" id="page_48"/>overriding the default values, you can wield some control over the execution of a built-in rule. For instance, the command in the standard POSIX definition of the built-in implicit rule for converting <em>.o</em> files to <em>.c</em> files is:<sup><a id="ch03fn_15" href="footnote.xhtml#ch03fn15">15</a></sup></p>&#13;
<pre>$(CC) $(CPPFLAGS) $(CFLAGS) -c</pre>&#13;
<p class="indent">Here, you can override just about every aspect of this built-in rule by setting your own values for <span class="literal">CC</span>, the compiler; <span class="literal">CPPFLAGS</span>, options passed to the C preprocessor; and <span class="literal">CFLAGS</span>, options passed to the C compiler.</p>&#13;
<p class="indent">You can write implicit rules yourself, if you wish. You can even override the default implicit rules with your own versions. Implicit rules are a powerful tool, and they shouldn’t be overlooked, but for the purposes of this book, we won’t go into any more detail. You can learn more about writing and using implicit rules within makefiles in “Using Implicit Rules” in the <em>GNU Make Manual</em>.</p>&#13;
<p class="indent">To illustrate this implicit functionality, I created trivial C source and header files to accompany the sample makefile from <a href="ch03.xhtml#ch03ex11">Listing 3-11</a>. Here’s what happened when I executed <span class="literal">make</span> on this makefile:</p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">make</span>&#13;
   cc    -c -o main.o main.c&#13;
   $&#13;
<span class="ent">➋</span> $ <span class="codestrong1">make program</span>&#13;
   cc    -c -o print.o print.c&#13;
   cc    -c -o display.o display.c&#13;
   gcc -g -O2 -o program main.o print.o display.o&#13;
   $</pre>&#13;
<p class="indent">As you can see, <span class="literal">cc</span> was magically executed with <span class="literal">-c</span> and <span class="literal">-o</span> options to generate <em>main.o</em> from <em>main.c</em>. This is common command line syntax used to make a C-language compiler build objects from sources—it’s so common, in fact, that the functionality is built into <span class="literal">make</span>. If you look for <span class="literal">cc</span> on a modern GNU/Linux system, you’ll find that it’s a soft link in <em>/usr/bin</em> that refers to the system’s GNU C compiler. On other systems, it refers to the system’s native C compiler. Calling the system C compiler <em>cc</em> has been a de facto standard for decades.<sup><a id="ch03fn_16" href="footnote.xhtml#ch03fn16">16</a></sup></p>&#13;
<p class="indent">The extra spaces between <span class="literal">cc</span> and <span class="literal">-c</span> in that output under <span class="ent">➊</span> represent the spaces between the uses of the <span class="literal">CPPFLAGS</span> and <span class="literal">CFLAGS</span> variables, which are defined as empty by default.</p>&#13;
<p class="indent">But why did the <span class="literal">make</span> utility build only <em>main.o</em> when we typed <span class="literal">make</span> at <span class="ent">➊</span>? Simply because the dependency rule for <em>main.o</em> provided the first (and thus, the default) target for the makefile. In this case, to build <span class="literal">program</span>, we needed to execute <span class="literal">make program</span>, as we did in <span class="ent">➋</span>. Remember that when you enter <span class="literal">make</span> <span epub:type="pagebreak" id="page_49"/>on the command line, the <span class="literal">make</span> utility attempts to build the first explicitly defined target within the file called <em>Makefile</em> in the current directory. If we wanted to make <span class="literal">program</span> the default target, we could rearrange the rules so the <span class="literal">program</span> rule would be the first one listed in the makefile.</p>&#13;
<p class="indent">To see the dependency rules in action, touch one of the header files and then rebuild the <span class="literal">program</span> target:</p>&#13;
<pre>$ <span class="codestrong1">touch display.h</span>&#13;
$ <span class="codestrong1">make program</span>&#13;
cc -c -o main.o main.c&#13;
cc -c -o display.o display.c&#13;
gcc -g -O0 -o program main.o print.o display.o&#13;
$</pre>&#13;
<p class="indent">After <em>display.h</em> was updated, only <em>display.o</em>, <em>main.o</em>, and <span class="literal">program</span> were rebuilt. The <em>print.o</em> object didn’t need to be rebuilt because <em>print.c</em> doesn’t depend on <em>display.h</em>, according to the rules specified in the makefile.</p>&#13;
<h5 class="h5">Phony Targets</h5>&#13;
<p class="noindent">Targets are not always files. They can also be so-called <em>phony targets</em>, as in the case of <span class="literal">all</span> and <span class="literal">clean</span>. These targets don’t refer to true products in the filesystem but rather to particular outcomes or actions—when you make these targets, the project is <em>cleaned</em>, <em>all</em> products are built, and so on.</p>&#13;
<h5 class="h5">Multiple Targets</h5>&#13;
<p class="noindent">In the same way that you can list multiple dependencies within a rule on the right side of a colon, you can combine rules for multiple targets with the same dependencies and commands by listing the targets on the left side of a colon, as shown in <a href="ch03.xhtml#ch03ex12">Listing 3-12</a>.</p>&#13;
<pre>all clean:&#13;
        cd src &amp;&amp; $(MAKE) $@</pre>&#13;
<p class="caption"><a id="ch03ex12"/><em>Listing 3-12: Using multiple targets in a rule</em></p>&#13;
<p class="indent">While it may not be immediately apparent, this example contains two separate rules: one for each of the two targets, <span class="literal">all</span> and <span class="literal">clean</span>. Because these two rules have the same set of dependencies (none, in this case) and the same set of commands, we’re able to take advantage of a shorthand notation supported by <span class="literal">make</span> that allows us to combine their rules into one specification.</p>&#13;
<p class="indent">To help you understand this concept, consider the <span class="literal">$@</span> variable in <a href="ch03.xhtml#ch03ex12">Listing 3-12</a>. Which target does it refer to? Well, that depends on which rule is currently executing—the one for <span class="literal">all</span> or the one for <span class="literal">clean</span>. Since a rule can only be executed on a single target at any given time, <span class="literal">$@</span> can only ever refer to one target, even when the controlling rule specification contains several.</p>&#13;
<h4 class="h4" id="ch03sec3-6"><em><span epub:type="pagebreak" id="page_50"/>Resources for Makefile Authors</em></h4>&#13;
<p class="noindent">GNU <span class="literal">make</span> is significantly more powerful than the original AT&amp;T UNIX <span class="literal">make</span> utility, although GNU <span class="literal">make</span> is completely backward compatible, as long as you avoid GNU extensions. The <em>GNU Make Manual</em><sup><a id="ch03fn_17" href="footnote.xhtml#ch03fn17">17</a></sup> is available online, and O’Reilly has published an excellent book on the original AT&amp;T UNIX <span class="literal">make</span> utility<sup><a id="ch03fn_18" href="footnote.xhtml#ch03fn18">18</a></sup> and all of its many nuances. While you can still find this title, the publisher has since merged its content into a new edition that also covers GNU <span class="literal">make</span> extensions.<sup><a id="ch03fn_19" href="footnote.xhtml#ch03fn19">19</a></sup></p>&#13;
<p class="indent">This concludes the general discussion of makefile syntax and the <span class="literal">make</span> utility, although we will look at additional makefile constructs as we encounter them throughout the rest of this chapter. With this general information behind us, let’s return to the Jupiter project and begin adding some more interesting functionality.</p>&#13;
<h3 class="h3" id="ch03sec4">Creating a Source Distribution Archive</h3>&#13;
<p class="noindent">In order to actually get source code for Jupiter to our users, we’re going to have to create and distribute a source archive—a tarball. We could write a separate script to create the tarball, but since we can use phony targets to create arbitrary sets of functionality in makefiles, let’s design a <span class="literal">make</span> target to perform this task instead. Building a source archive for distribution is usually relegated to the <span class="literal">dist</span> target.</p>&#13;
<p class="indent">When designing a new <span class="literal">make</span> target, we need to consider whether its functionality should be distributed among the makefiles of the project or handled in a single location. Normally, the rule of thumb is to take advantage of a recursive build system’s nature by allowing each directory to manage its own portions of a process. We did just this in <a href="ch03.xhtml#ch03ex01">Listing 3-1</a> when we passed control of building the <span class="literal">jupiter</span> program down to the <em>src</em> directory, where the source code is located. However, building a compressed archive from a directory structure isn’t really a recursive process.<sup><a id="ch03fn_20" href="footnote.xhtml#ch03fn20">20</a></sup> This being the case, we’ll have to perform the entire task in one of the two makefiles.</p>&#13;
<p class="indent">Global processes are often handled by the makefile at the highest relevant level in the project directory structure. We’ll add the <span class="literal">dist</span> target to our top-level makefile, as shown in <a href="ch03.xhtml#ch03ex13">Listing 3-13</a>.</p>&#13;
<p class="margin"><span epub:type="pagebreak" id="page_51"/>Git tag 3.1</p>&#13;
<pre><span class="ent">➊</span> package = jupiter&#13;
   version = 1.0&#13;
   tarname = $(package)&#13;
   distdir = $(tarname)-$(version)&#13;
&#13;
   <span class="ash">all clean jupiter:</span>&#13;
           <span class="ash">cd src &amp;&amp; $(MAKE) $@</span>&#13;
&#13;
<span class="ent">➋</span> dist: $(distdir).tar.gz&#13;
&#13;
<span class="ent">➌</span> $(distdir).tar.gz: $(distdir)&#13;
           tar chof - $(distdir) | gzip -9 -c &gt; $@&#13;
           rm -rf $(distdir)&#13;
&#13;
<span class="ent">➍</span> $(distdir):&#13;
           mkdir -p $(distdir)/src&#13;
           cp Makefile $(distdir)&#13;
           cp src/Makefile src/main.c $(distdir)/src&#13;
&#13;
<span class="ent">➎</span> <span class="ash">.PHONY: all clean</span> dist</pre>&#13;
<p class="caption"><a id="ch03ex13"/><em>Listing 3-13:</em> Makefile: Adding the <span class="literal">dist</span> target to the top-level makefile</p>&#13;
<p class="indent">Besides the addition of the <span class="literal">dist</span> target at <span class="ent">➋</span>, I’ve also made several other modifications. Let’s look at them one at a time. I’ve added the <span class="literal">dist</span> target to the <span class="literal">.PHONY</span> rule at <span class="ent">➎</span>. The <span class="literal">.PHONY</span> rule is a special kind of built-in rule called a <em>dot-rule</em> or <em>directive</em>. The <span class="literal">make</span> utility understands several dot-rules. The purpose of <span class="literal">.PHONY</span> is simply to tell <span class="literal">make</span> that certain targets don’t generate filesystem objects. Normally, <span class="literal">make</span> determines which commands to run by comparing the timestamps of the targets to those of their dependencies in the filesystem—but phony targets don’t have associated filesystem objects. Using <span class="literal">.PHONY</span> ensures that <span class="literal">make</span> won’t go looking for nonexistent product files named after these targets. It also ensures that if a file or directory named <em>dist</em> somehow inadvertently gets added to the directory, <span class="literal">make</span> will still treat the <span class="literal">dist</span> target as non-real.</p>&#13;
<p class="indent">Adding a target to the <span class="literal">.PHONY</span> rule has another effect. Since <span class="literal">make</span> won’t be able to use timestamps to determine whether the target is up-to-date (that is, newer than its dependencies), <span class="literal">make</span> has no recourse but to <em>always</em> execute the commands associated with phony targets whenever these targets either are requested on the command line or appear in a dependency chain.</p>&#13;
<p class="indent">I’ve separated the functionality of the <span class="literal">dist</span> target into three separate rules (<span class="ent">➋</span>, <span class="ent">➌</span>, and <span class="ent">➍</span>) for the sake of readability, modularity, and maintenance. This is a great rule of thumb to follow in any software engineering process: <em>build large processes from smaller ones and reuse the smaller processes where it makes sense.</em></p>&#13;
<p class="indent">The <span class="literal">dist</span> target at <span class="ent">➋</span> depends on the existence of the ultimate goal—in this case, a source-level compressed archive package, <em>jupiter-1.0.tar.gz</em>. I’ve used one variable to hold the version number (which makes it easier to update the project version later) and another variable for the package name at <span class="ent">➊</span>, which will make it easier to change the name if I ever decide to reuse this makefile for another project. I’ve also logically split the functions of package name and tarball name; the default tarball name is the package name, but we do have the option of making them different.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>The rule that builds the tarball at <span class="ent">➌</span> indicates how this should be done with a command that uses the <span class="literal">gzip</span> and <span class="literal">tar</span> utilities to create the file. But, notice that the rule has a dependency—the directory to be archived. The directory name is derived from the tarball name and the package version number; it’s stored in yet another variable called <span class="literal">distdir</span>.</p>&#13;
<p class="indent">We don’t want object files and executables from our last build attempt to end up in the archive, so we need to build an image directory containing exactly what we want to ship—including any files required in the build and install processes and any additional documentation or license files. Unfortunately, this pretty much mandates the use of individual copy  (<span class="literal">cp</span>) commands.</p>&#13;
<p class="indent">Since there’s a rule in the makefile (at <span class="ent">➍</span>) that tells how this directory should be created, and since that rule’s target is a dependency of the tarball, <span class="literal">make</span> runs the commands for that rule <em>before</em> running the commands for the tarball rule. Recall that <span class="literal">make</span> processes rules to build dependencies recursively, from the bottom up, until it can run the commands for the requested target.<sup><a id="ch03fn_21" href="footnote.xhtml#ch03fn21">21</a></sup></p>&#13;
<h4 class="h4" id="ch03sec4-1"><em>Forcing a Rule to Run</em></h4>&#13;
<p class="noindent">There’s a subtle flaw in the <span class="literal">$(distdir)</span> target that may not be obvious right now, but it will rear its ugly head at the worst of times. If the archive image directory (<em>jupiter-1.0</em>) already exists when you execute <span class="literal">make dist</span>, then <span class="literal">make</span> won’t try to create it. Try this:</p>&#13;
<pre>$ <span class="codestrong1">mkdir jupiter-1.0</span>&#13;
$ <span class="codestrong1">make dist</span>&#13;
tar chof - jupiter-1.0 | gzip -9 -c &gt; jupiter-1.0.tar.gz&#13;
rm -rf jupiter-1.0&#13;
$</pre>&#13;
<p class="indent">Notice that the <span class="literal">dist</span> target didn’t copy any files—it just built an archive out of the existing <em>jupiter-1.0</em> directory, which was empty. Our users would get a real surprise when they unpack this tarball! Worse still, if the image directory from the previous attempt to archive happened to still be there, the new tarball would contain the now-outdated sources from our last attempt to create a distribution tarball.</p>&#13;
<p class="indent">The problem is that the <span class="literal">$(distdir)</span> target is a real target with no dependencies, which means that <span class="literal">make</span> will consider it up-to-date as long as it exists in the filesystem. We could add the <span class="literal">$(distdir)</span> target to the <span class="literal">.PHONY</span> rule to force <span class="literal">make</span> to rebuild it every time we make the <span class="literal">dist</span> target, but it’s not a phony target—it’s a real filesystem object. The proper way to ensure that <span class="literal">$(distdir)</span> is always rebuilt is to ensure that it doesn’t exist before <span class="literal">make</span> attempts to build it. One way to accomplish this is to create a true phony target that will always execute and then add that target to the dependency list for the <span class="literal">$(distdir)</span> target. A common name for this kind of target is <span class="literal">FORCE</span>, and I’ve implemented this concept in <a href="ch03.xhtml#ch03ex14">Listing 3-14</a>.</p>&#13;
<p class="margin"><span epub:type="pagebreak" id="page_53"/>Git tag 3.2</p>&#13;
<pre>   <span class="codeitalic1a">--snip--</span>&#13;
   <span class="ash">$(distdir).tar.gz: $(distdir)</span>&#13;
           <span class="ash">tar chof - $(distdir) | gzip -9 -c &gt; $@</span>&#13;
           <span class="ash">rm -rf $(distdir)</span>&#13;
&#13;
<span class="ent">➊</span> <span class="ash">$(distdir):</span> FORCE&#13;
           <span class="ash">mkdir -p $(distdir)/src</span>&#13;
           <span class="ash">cp Makefile $(distdir)</span>&#13;
           <span class="ash">cp src/Makefile $(distdir)/src</span>&#13;
           <span class="ash">cp src/main.c $(distdir)/src</span>&#13;
&#13;
<span class="ent">➋</span> FORCE:&#13;
           -rm $(distdir).tar.gz &gt;/dev/null 2&gt;&amp;1&#13;
           rm -rf $(distdir)&#13;
&#13;
  <span class="ash">.PHONY:</span> FORCE <span class="ash">all clean dist</span></pre>&#13;
<p class="caption"><a id="ch03ex14"/><em>Listing 3-14: Makefile: Using the <span class="literal">FORCE</span> target</em></p>&#13;
<p class="indent">The <span class="literal">FORCE</span> rule’s commands (at <span class="ent">➋</span>) are executed every time because <span class="literal">FORCE</span> is a phony target. Since we made <span class="literal">FORCE</span> a dependency of the <span class="literal">$(distdir)</span> target (at <span class="ent">➊</span>), we have the opportunity to delete any previously created files and directories <em>before</em> <span class="literal">make</span> begins to evaluate whether it should execute the commands for <span class="literal">$(distdir)</span>.</p>&#13;
<h4 class="h4" id="ch03sec4-2"><em>Leading Control Characters</em></h4>&#13;
<p class="noindent">A leading dash character (<span class="literal">-</span>) on a command tells <span class="literal">make</span> not to care about the status code of the command it precedes. Normally, when <span class="literal">make</span> encounters a command that returns a nonzero status code to the shell, it will stop execution and display an error message, but if you use a leading dash, it will just ignore the error and continue. I use a leading dash on the first <span class="literal">rm</span> command in the <span class="literal">FORCE</span> rule because I want to delete previously created product files that may <em>or may not</em> exist, and <span class="literal">rm</span> will return an error if I attempt to delete a nonexistent file.</p>&#13;
<p class="indent">In general, a better option is to use the <span class="literal">-f</span> flag on the <span class="literal">rm</span> command line, which causes <span class="literal">rm</span> to ignore missing file errors. Another benefit of using <span class="literal">-f</span> is that we no longer need to redirect error messages to <em>/dev/null</em>, as we really care about other errors—permission errors, for example. From this point on, we’ll remove the leading dash in front of any <span class="literal">rm</span> commands and ensure we use <span class="literal">-f</span>.</p>&#13;
<p class="indent">Another leading character that you may encounter is the at sign (<span class="literal">@</span>). A command prefixed with an at sign tells <span class="literal">make</span> not to perform its normal behavior of printing the command to the <span class="literal">stdout</span> device as it executes it. It is common to use a leading at sign on <span class="literal">echo</span> statements. You don’t want <span class="literal">make</span> to print <span class="literal">echo</span> statements, because then your message will be printed twice: once by <span class="literal">make</span> and then again by the <span class="literal">echo</span> statement itself.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You may also combine these leading characters (<em><span class="literal">@</span></em>, <em><span class="literal">-</span></em>, and <em><span class="literal">+</span></em>) in any order. The plus (<em><span class="literal">+</span></em>) character is used to force a command to execute that would otherwise not be executed due, for example, to a <em><span class="literal">-n</span></em> command line option, which tells <em><span class="literal">make</span></em> to perform a so-called dry run. Some commands make sense even in a dry run.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>It’s best to use the at sign judiciously. I usually reserve it for commands I <em>never</em> want to see, such as <span class="literal">echo</span> statements. If you like quiet build systems, consider using the global <span class="literal">.SILENT</span> directive in your makefiles. Or better still, simply do nothing, thereby allowing the user the option of adding the <span class="literal">-s</span> option to their <span class="literal">make</span> command lines. This enables the user to choose how much noise they want to see.</p>&#13;
<h3 class="h3" id="ch03sec5">Automatically Testing a Distribution</h3>&#13;
<p class="noindent">The rule for building the archive directory is probably the most frustrating rule in this makefile because it contains commands to copy individual files into the distribution directory. Every time we change the file structure in our project, we have to update this rule in our top-level makefile, or we’ll break the <span class="literal">dist</span> target. But there’s nothing more we can do—we’ve made the rule as simple as possible. Now we just have to remember to manage this process properly.</p>&#13;
<p class="indent">Unfortunately, though, even worse things than breaking the <span class="literal">dist</span> target could happen if you forget to update the <span class="literal">distdir</span> rule’s commands. It may <em>appear</em> that the <span class="literal">dist</span> target is working, but it may not actually be copying all of the required files into the tarball. In fact, it is far more likely that this, rather than an error, will occur, because adding files to a project is a more common activity than moving them around or deleting them. New files will not be copied, but the <span class="literal">dist</span> rule won’t notice the difference.</p>&#13;
<p class="indent">There is a way to perform a sort of self-check on the <span class="literal">dist</span> target. We can create another phony target, called <span class="literal">distcheck</span>, that does exactly what our users will do: unpack the tarball and build the project. We can have this rule’s commands perform this task in a temporary directory. If the build process fails, then the <span class="literal">distcheck</span> target will break, telling us that we forgot something crucial in our distribution.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex15">Listing 3-15</a> shows the modifications to our top-level makefile that are required to implement the <span class="literal">distcheck</span> target.</p>&#13;
<p class="margin">Git tag 3.3</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">$(distdir): FORCE</span>&#13;
        <span class="ash">mkdir -p $(distdir)/src</span>&#13;
        <span class="ash">cp Makefile $(distdir)</span>&#13;
        <span class="ash">cp src/Makefile src/main.c $(distdir)/src</span>&#13;
&#13;
distcheck: $(distdir).tar.gz&#13;
        gzip -cd $(distdir).tar.gz | tar xvf -&#13;
        cd $(distdir) &amp;&amp; $(MAKE) all&#13;
        cd $(distdir) &amp;&amp; $(MAKE) clean&#13;
        rm -rf $(distdir)&#13;
        @echo "*** Package $(distdir).tar.gz is ready for distribution."&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">.PHONY: FORCE all clean dist</span> distcheck</pre>&#13;
<p class="caption"><a id="ch03ex15"/><em>Listing 3-15: Makefile: Adding a <span class="literal">distcheck</span> target to the top-level makefile</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>The <span class="literal">distcheck</span> target depends on the tarball itself, so the rule that builds the tarball is executed first. The <span class="literal">make</span> utility then executes the <span class="literal">distcheck</span> commands, which unpack the tarball just built and then recursively run <span class="literal">make</span> on the <span class="literal">all</span> and <span class="literal">clean</span> targets within the resulting directory. If that process succeeds, the <span class="literal">distcheck</span> target prints out a message indicating that your users will likely not have a problem with this tarball.</p>&#13;
<p class="indent">Now all you have to do is remember to execute <span class="literal">make distcheck</span> <em>before</em> you post your tarballs for public distribution!</p>&#13;
<h3 class="h3" id="ch03sec6">Unit Testing, Anyone?</h3>&#13;
<p class="noindent">Some people insist that unit testing is evil, but the only honest rationale they can come up with for not doing it is laziness. Proper unit testing is hard work, but it pays off in the end. Those who do it have learned a lesson (usually in childhood) about the value of delayed gratification.</p>&#13;
<p class="indent">A good build system should incorporate proper unit testing. The most commonly used target for testing a build is the <span class="literal">check</span> target, so we’ll go ahead and add it in the usual manner. The actual unit test should probably go in <em>src/Makefile</em> because that’s where the <span class="literal">jupiter</span> executable is built, so we’ll pass the <span class="literal">check</span> target down from the top-level makefile.</p>&#13;
<p class="indent">But what commands do we put in the <span class="literal">check</span> rule? Well, <span class="literal">jupiter</span> is a pretty simple program—it prints the message <em>Hello from</em> some/path/<em>jupiter!</em> where <em>some/path</em> depends on the location from which <span class="literal">jupiter</span> was executed. I’ll use the <span class="literal">grep</span> utility to test that <span class="literal">jupiter</span> actually outputs such a string.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex16">Listings 3-16</a> and <a href="ch03.xhtml#ch03ex17">3-17</a> illustrate the modifications to our top-level and <em>src</em> directory makefiles, respectively.</p>&#13;
<p class="margin">Git tag 3.4</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">all clean</span> check <span class="ash">jupiter:</span>&#13;
        <span class="ash">cd src &amp;&amp; $(MAKE) $@</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">.PHONY: FORCE all clean</span> check <span class="ash">dist distcheck</span></pre>&#13;
<p class="caption"><a id="ch03ex16"/><em>Listing 3-16:</em> Makefile: <em>Passing the <span class="literal">check</span> target to src/Makefile</em></p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">src/jupiter: src/main.c</span>&#13;
        <span class="ash">$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ src/main.c</span>&#13;
&#13;
check: all&#13;
        ./jupiter | grep "Hello from .*jupiter!"&#13;
        @echo "*** ALL TESTS PASSED ***"&#13;
<span class="codeitalic1a">--snip--</span>&#13;
&#13;
<span class="ash">.PHONY: all clean</span> check</pre>&#13;
<p class="caption"><a id="ch03ex17"/><em>Listing 3-17:</em> src/Makefile: <em>Implementing the unit test in the <span class="literal">check</span> target</em></p>&#13;
<p class="indent">Note that <span class="literal">check</span> depends on <span class="literal">all</span>. We can’t really test our products unless they are up-to-date, reflecting any recent source code or build system changes <span epub:type="pagebreak" id="page_56"/>that may have been made. It makes sense that if the user wants to test the products, they also want the products to exist and be up-to-date. We can ensure they exist and are current by adding <span class="literal">all</span> to <span class="literal">check</span>’s dependency list.</p>&#13;
<p class="indent">There’s one more enhancement we can make to our build system: we can add <span class="literal">check</span> to the list of targets executed by <span class="literal">make</span> in our <span class="literal">distcheck</span> rule, between the commands to make <span class="literal">all</span> and <span class="literal">clean</span>. <a href="ch03.xhtml#ch03ex18">Listing 3-18</a> shows where this is done in the top-level makefile.</p>&#13;
<p class="margin">Git tag 3.5</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">distcheck: $(distdir).tar.gz</span>&#13;
        <span class="ash">gzip -cd $(distdir).tar.gz | tar xvf -</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) all</span>&#13;
        cd $(distdir) &amp;&amp; $(MAKE) check&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) clean</span>&#13;
        <span class="ash">rm -rf $(distdir)</span>&#13;
        <span class="ash">@echo "*** Package $(distdir).tar.gz is ready for distribution."</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex18"/><em>Listing 3-18:</em> Makefile: <em>Adding the <span class="literal">check</span> target to the <span class="literal">$(MAKE)</span> command</em></p>&#13;
<p class="indent">Now when we run <span class="literal">make distcheck</span>, it will test the entire build system shipped with the package.</p>&#13;
<h3 class="h3" id="ch03sec7">Installing Products</h3>&#13;
<p class="noindent">We’ve reached the point where our users’ experiences with Jupiter should be fairly painless—even pleasant—as far as building the project is concerned. Users will simply unpack the distribution tarball, change into the distribution directory, and type <span class="literal">make</span>. It really can’t get any simpler than that.</p>&#13;
<p class="indent">But we still lack one important feature—installation. In the case of the Jupiter project, this is fairly trivial. There’s only one program, and most users would guess correctly that to install it, they should copy <span class="literal">jupiter</span> into either their <em>/usr/bin</em> or <em>/usr/local/bin</em> directory. More complex projects, however, could cause users real consternation over where to put user and system binaries, libraries, header files, and documentation, including man pages, info pages, PDF files, and the more or less obligatory <em>README</em>, <em>AUTHORS</em>, <em>NEWS</em>, <em>INSTALL</em>, and <em>COPYING</em> files generally associated with GNU projects.</p>&#13;
<p class="indent">We don’t really want our users to have to figure all that out, so we’ll create an <span class="literal">install</span> target to manage putting things where they go once they’re built properly. In fact, why not just make installation part of the <span class="literal">all</span> target? Well, let’s not get carried away. There are actually a few good reasons for not doing this.</p>&#13;
<p class="indent">First, build and installation are separate logical concepts. The second reason is a matter of filesystem rights. Users have rights to build projects in their own home directories, but installation often requires <em>root</em>-level rights to copy files into system directories. Finally, there are several reasons why a user may wish to build but not install a project, so it would be unwise to tie these actions together.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>While creating a distribution package may not be an inherently recursive process, installation certainly is, so we’ll allow each subdirectory in our project to manage installation of its own components. To do this, we need to modify both the top-level and the <em>src</em>-level makefiles. Changing the top-level makefile is easy: since there are no products to be installed in the top-level directory, we’ll just pass the responsibility on to <em>src/Makefile</em> in the usual way.</p>&#13;
<p class="indent">The modifications for adding an <span class="literal">install</span> target are shown in <a href="ch03.xhtml#ch03ex19">Listings 3-19</a> and <a href="ch03.xhtml#ch03ex20">3-20</a>.</p>&#13;
<p class="margin">Git tag 3.6</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">all clean check</span> install <span class="ash">jupiter:</span>&#13;
        <span class="ash">cd src &amp;&amp; $(MAKE) $@</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
&#13;
<span class="ash">.PHONY: FORCE all clean check dist distcheck</span> install</pre>&#13;
<p class="caption"><a id="ch03ex19"/><em>Listing 3-19:</em> Makefile: <em>Passing the <span class="literal">install</span> target to src/Makefile</em></p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">check: all</span>&#13;
        <span class="ash">./src/jupiter | grep "Hello from .*jupiter!"</span>&#13;
        <span class="ash">@echo "*** All TESTS PASSED"</span>&#13;
&#13;
install:&#13;
        cp jupiter /usr/bin&#13;
        chown root:root /usr/bin/jupiter&#13;
        chmod +x /usr/bin/jupiter&#13;
<span class="codeitalic1a">--snip--</span>&#13;
&#13;
<span class="ash">.PHONY: all clean check</span> install</pre>&#13;
<p class="caption"><a id="ch03ex20"/><em>Listing 3-20:</em> src/Makefile: <em>Implementing the <span class="literal">install</span> target</em>&#13;
</p>&#13;
<p class="indent">In the top-level makefile shown in <a href="ch03.xhtml#ch03ex19">Listing 3-19</a>, I’ve added <span class="literal">install</span> to the list of targets passed down to <em>src/Makefile</em>. The installation of files is handled by the <em>src</em>-level makefile shown in <a href="ch03.xhtml#ch03ex20">Listing 3-20</a>.</p>&#13;
<p class="indent">Installation is a bit more complex than simply copying files. If a file is placed in the <em>/usr/bin</em> directory, then <em>root</em> should own it so that only <em>root</em> can delete or modify it. Additionally, the <span class="literal">jupiter</span> binary should be flagged executable, so I’ve used the <span class="literal">chmod</span> command to set the mode of the file as such. This is probably redundant, as the linker ensures that <span class="literal">jupiter</span> is created as an executable file, but some types of executable products are not generated by a linker—shell scripts, for example.</p>&#13;
<p class="indent">Now our users can just type the following sequence of commands and the Jupiter project will be built, tested, and installed with the correct system attributes and ownership on their platforms:</p>&#13;
<pre>$ <span class="codestrong1">gzip -cd jupiter-1.0.tar.gz | tar xf -</span>&#13;
$ <span class="codestrong1">cd jupiter-1.0</span>&#13;
$ <span class="codestrong1">make all check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
<span epub:type="pagebreak" id="page_58"/>$ <span class="codestrong1">sudo make install</span>&#13;
Password: <span class="codestrong1">******</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<h4 class="h4" id="ch03sec7-1"><em>Installation Choices</em></h4>&#13;
<p class="noindent">All of this is well and good, but it could be a bit more flexible with regard to where things are installed. Some users may be okay with having <span class="literal">jupiter</span> installed into the <em>/usr/bin</em> directory. Others are going to ask why it isn’t installed into the <em>/usr/local/bin</em> directory—after all, this is a common convention. We could change the target directory to <em>/usr/local/bin</em>, but then users may ask why they don’t have the option of installing into their home directories. This is the perfect situation for a little command line–supported flexibility.</p>&#13;
<p class="indent">Another problem with our current build system is that we have to do a lot of stuff just to install files. Most Unix systems provide a system-level program—sometimes simply a shell script—called <span class="literal">install</span> that allows a user to specify various attributes of the files being installed. The proper use of this utility could simplify things a bit for Jupiter’s installation, so while we’re adding location flexibility, we might as well use the <span class="literal">install</span> utility, too. These modifications are shown in <a href="ch03.xhtml#ch03ex21">Listings 3-21</a> and <a href="ch03.xhtml#ch03ex22">3-22</a>.</p>&#13;
<p class="margin">Git tag 3.7</p>&#13;
<pre>   <span class="ash">package = jupiter</span>&#13;
   <span class="ash">version = 1.0</span>&#13;
   <span class="ash">tarname = $(package)</span>&#13;
   <span class="ash">distdir = $(tarname)-$(version)</span>&#13;
&#13;
   prefix=/usr/local&#13;
<span class="ent">➊</span> export prefix&#13;
&#13;
   <span class="ash">all clean check install jupiter:</span>&#13;
           <span class="ash">cd src &amp;&amp; $(MAKE) $@</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex21"/><em>Listing 3-21:  Makefile: Adding a <span class="literal">prefix</span> variable</em></p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">install:</span>&#13;
     <span class="ent">➋</span> <span class="ash">install -d</span> $(prefix)<span class="ash">/bin</span>&#13;
        <span class="ash">install -m 0755 jupiter</span> $(prefix)<span class="ash">/bin</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex22"/><em>Listing 3-22:</em> src/Makefile: <em>Using the <span class="literal">prefix</span> variable in the <span class="literal">install</span> target</em></p>&#13;
<p class="indent">Notice that I only declared and assigned the <span class="literal">prefix</span> variable in the top-level makefile, but I referenced it in <em>src/Makefile</em>. I can do this because I used the <span class="literal">export</span> modifier at <span class="ent">➊</span> in the top-level makefile—this modifier exports the variable to the shell that <span class="literal">make</span> spawns when it executes itself in the <em>src</em> directory. This feature of <span class="literal">make</span> allows us to define all of our user variables in one obvious location—at the beginning of the top-level makefile.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><span epub:type="pagebreak" id="page_59"/>GNU <em><span class="literal">make</span></em> allows you to use the <em><span class="literal">export</span></em> keyword on the assignment line, but this syntax is not portable between GNU <em><span class="literal">make</span></em> and other versions of <em><span class="literal">make</span></em>. Technically, POSIX doesn’t support the use of <em><span class="literal">export</span></em> at all, but most <em><span class="literal">make</span></em> implementations support it.</em></p>&#13;
</div>&#13;
<p class="indent">I’ve now declared the <span class="literal">prefix</span> variable to be <em>/usr/local</em>, which is very nice for those who want to install <span class="literal">jupiter</span> in <em>/usr/local/bin</em> but not so nice for those who want it in <em>/usr/bin</em>. Fortunately, <span class="literal">make</span> allows you to define <span class="literal">make</span> variables on the command line, in this manner:</p>&#13;
<pre>$ <span class="codestrong1">sudo make prefix=/usr install</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Remember that variables defined on the command line override those defined within the makefile.<sup><a id="ch03fn_22" href="footnote.xhtml#ch03fn22">22</a></sup> Thus, users who want to install <span class="literal">jupiter</span> into the <em>/usr/bin</em> directory now have the option of specifying this on the <span class="literal">make</span> command line.</p>&#13;
<p class="indent">With this system in place, our users may install <span class="literal">jupiter</span> into a <em>bin</em> directory beneath any directory they choose, including a location in their home directory (for which they do not need additional rights). This is, in fact, the reason we added the <span class="literal">install -d $(prefix)/bin</span> command at <span class="ent">➋</span> in <a href="ch03.xhtml#ch03ex22">Listing 3-22</a>—this command creates the installation directory if it doesn’t already exist. Since we allow the user to define <span class="literal">prefix</span> on the <span class="literal">make</span> command line, we don’t actually know where the user is going to install <span class="literal">jupiter</span>; therefore, we have to be prepared for the possibility that the location may not yet exist. Give this a try:<sup><a id="ch03fn_23" href="footnote.xhtml#ch03fn23">23</a></sup></p>&#13;
<pre>$ <span class="codestrong1">make all</span>&#13;
$ <span class="codestrong1">make prefix=$PWD/inst install</span>&#13;
$&#13;
$ <span class="codestrong1">ls -1p</span>&#13;
inst/&#13;
Makefile&#13;
src/&#13;
$&#13;
$ <span class="codestrong1">ls -1p inst</span>&#13;
bin/&#13;
$&#13;
$ <span class="codestrong1">ls -1p inst/bin</span>&#13;
jupiter&#13;
$</pre>&#13;
<h4 class="h4" id="ch03sec7-2"><em><span epub:type="pagebreak" id="page_60"/>Uninstalling a Package</em></h4>&#13;
<p class="noindent">What if a user doesn’t like our package after they’ve installed it, and they just want to get it off their system? This is a fairly likely scenario for the Jupiter project, as it’s rather useless and takes up valuable space in the <em>bin</em> directory. In the case of <em>your</em> projects, however, it’s more likely that a user would want to do a clean install of a newer version of the project or replace the test build they downloaded from the project website with a professionally packaged version that comes with their Linux distribution. Support for an <span class="literal">uninstall</span> target would be very helpful in situations like these.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex23">Listings 3-23</a> and <a href="ch03.xhtml#ch03ex24">3-24</a> show the addition of an <span class="literal">uninstall</span> target to our two makefiles.</p>&#13;
<p class="margin">Git tag 3.8</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">all clean check install</span> uninstall <span class="ash">jupiter:</span>&#13;
        <span class="ash">cd src &amp;&amp; $(MAKE) $@</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
&#13;
<span class="ash">.PHONY: FORCE all clean check dist distcheck install</span> uninstall</pre>&#13;
<p class="caption"><a id="ch03ex23"/><em>Listing 3-23:</em> Makefile: <em>Adding the <span class="literal">uninstall</span> target to the top-level makefile</em></p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">install:</span>&#13;
        <span class="ash">install -d $(prefix)/bin</span>&#13;
        <span class="ash">install -m 0755 jupiter $(prefix)/bin</span>&#13;
&#13;
uninstall:&#13;
        rm -f $(prefix)/bin/jupiter&#13;
        -rmdir $(prefix)/bin &gt;/dev/null 2&gt;&amp;1&#13;
<span class="codeitalic1a">--snip--</span>&#13;
&#13;
<span class="ash">.PHONY: all clean check install</span> uninstall</pre>&#13;
<p class="caption"><a id="ch03ex24"/><em>Listing 3-24:</em> src/Makefile: <em>Adding the <span class="literal">uninstall</span> target to the src-level makefile</em></p>&#13;
<p class="indent">As with the <span class="literal">install</span> target, this target requires root-level rights if the user is using a system prefix, such as <em>/usr</em> or <em>/usr/local</em>. You should be very careful about how you write your <span class="literal">uninstall</span> targets; unless a directory belongs specifically to your package, you shouldn’t assume you created it. If you do, you may end up deleting a system directory like <em>/usr/bin</em>!</p>&#13;
<p class="indent">On the other hand, we did create the directory in the <span class="literal">install</span> target if it was originally missing, so we should remove it if possible. Here, we can use the <span class="literal">rmdir</span> command, whose job it is to remove empty directories. Even if the directory is a system directory such as <em>/usr/bin</em>, removing it is harmless if it’s empty, but <span class="literal">rmdir</span> will fail if it’s not empty. Recalling that command failure stops the <span class="literal">make</span> process, we’ll also prefix it with a dash character. And we don’t really want to see such a failure, so we’ll redirect it’s output to <em>/dev/null</em>.</p>&#13;
<p class="indent">The list of things to maintain in our build system is getting out of hand. There are now two places we need to update when we change our installation processes: the <span class="literal">install</span> and <span class="literal">uninstall</span> targets. Unfortunately, this is really <span epub:type="pagebreak" id="page_61"/>about the best we can hope for when writing our own makefiles, unless we resort to fairly complex shell script commands. But hang in there—in <a href="ch06.xhtml">Chapter 6</a>, I’ll show you how to rewrite this makefile in a much simpler way using GNU Automake.</p>&#13;
<h4 class="h4" id="ch03sec7-3"><em>Testing Install and Uninstall</em></h4>&#13;
<p class="noindent">Now let’s add some code to our <span class="literal">distcheck</span> target to test the functionality of the <span class="literal">install</span> and <span class="literal">uninstall</span> targets. After all, it’s fairly important that both of these targets work correctly from our distribution tarballs, so we should test them in <span class="literal">distcheck</span> before declaring the tarball release worthy. <a href="ch03.xhtml#ch03ex25">Listing 3-25</a> illustrates the necessary changes to the top-level makefile.</p>&#13;
<p class="margin">Git tag 3.9</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">distcheck: $(distdir).tar.gz</span>&#13;
        <span class="ash">gzip -cd $(distdir).tar.gz | tar xvf -</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) all</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) check</span>&#13;
        cd $(distdir) &amp;&amp; $(MAKE) prefix=$${PWD}/_inst install&#13;
        cd $(distdir) &amp;&amp; $(MAKE) prefix=$${PWD}/_inst uninstall&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) clean</span>&#13;
        <span class="ash">rm -rf $(distdir)</span>&#13;
        <span class="ash">@echo "*** Package $(distdir).tar.gz is ready for distribution."</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex25"/><em>Listing 3-25:</em> Makefile: <em>Adding <span class="literal">distcheck</span> tests for the <span class="literal">install</span> and <span class="literal">uninstall</span> targets</em></p>&#13;
<p class="indent">Note that I used a double dollar sign on the <span class="literal">$${PWD}</span> variable references, ensuring that <span class="literal">make</span> passes the variable reference to the shell with the rest of the command line, rather than expanding it inline before executing the command. I wanted this variable to be dereferenced by the shell rather than by the <span class="literal">make</span> utility.<sup><a id="ch03fn_24" href="footnote.xhtml#ch03fn24">24</a></sup></p>&#13;
<p class="indent">What we’re doing here is testing to ensure the <span class="literal">install</span> and <span class="literal">uninstall</span> targets don’t generate errors—but this isn’t very likely because all they do is install files into a temporary directory within the build directory. We could add some code immediately after the <span class="literal">make</span> <span class="literal">install</span> command that looks for the products that are supposed to be installed, but that’s more than I’m willing to do. One reaches a point of diminishing returns, where the code that does the checking is just as complex as the installation code—in which case, the check becomes pointless.</p>&#13;
<p class="indent">But there is something else we can do: we can write a more or less generic test that checks to see if everything we installed was properly removed. Since the stage directory was empty before our installation, it had better be in a similar state after we uninstall. <a href="ch03.xhtml#ch03ex26">Listing 3-26</a> shows the addition of this test.</p>&#13;
<p class="margin"><span epub:type="pagebreak" id="page_62"/>Git tag 3.10</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">distcheck: $(distdir).tar.gz</span>&#13;
        <span class="ash">gzip -cd $(distdir).tar.gz | tar xvf -</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) all</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) check</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) prefix=$${PWD}/_inst install</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) prefix=$${PWD}/_inst uninstall</span>&#13;
     <span class="ent">➊</span> @remaining="`find $(distdir)/_inst -type f | wc -l`"; \&#13;
        if test "$${remaining}" -ne 0; then \&#13;
        <span class="ent">➋</span> echo "*** $${remaining} file(s) remaining in stage directory!"; \&#13;
           exit 1; \&#13;
        fi&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) clean</span>&#13;
        <span class="ash">rm -rf $(distdir)</span>&#13;
        <span class="ash">@echo "*** Package $(distdir).tar.gz is ready for distribution."</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex26"/><em>Listing 3-26:</em> Makefile: <em>Adding a test for leftover files after <span class="literal">uninstall</span> finishes</em></p>&#13;
<p class="indent">The test first generates a numeric value at <span class="ent">➊</span> in a shell variable called <span class="literal">remaining</span>, which represents the number of regular files found in the stage directory we used. If this number is not zero, the test prints a message to the console at <span class="ent">➋</span> indicating how many files were left behind by the <span class="literal">uninstall</span> commands and then it exits with an error. Exiting early leaves the stage directory intact so we can examine it to find out which files we forgot to uninstall.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This test code represents a good use of multiple shell commands passed to a single shell. I had to do this here so that the value of <em><span class="literal">remaining</span></em> would be available for use by the <em><span class="literal">if</span></em> statement. Conditionals don’t work very well when the closing <em><span class="literal">if</span></em> is not executed by the same shell as the opening <em><span class="literal">if</span></em>!</em></p>&#13;
</div>&#13;
<p class="indent">I don’t want to alarm people by printing the embedded <span class="literal">echo</span> statement unless it really should be executed, so I prefixed the entire test with an at sign (<span class="literal">@</span>) so that <span class="literal">make</span> wouldn’t print the code to <span class="literal">stdout</span>. Since <span class="literal">make</span> considers these five lines of code a single command, the only way to suppress printing the <span class="literal">echo</span> statement is to suppress printing the entire command.</p>&#13;
<p class="indent">Now, this test isn’t perfect—not by a long shot. This code only checks for regular files. If your installation procedure creates any soft links, this test won’t notice if they’re left behind. The directory structure that’s built during installation is purposely left in place because the check code doesn’t know whether a subdirectory within the stage directory belongs to the system or to the project. The <span class="literal">uninstall</span> rule’s commands can be aware of which directories are project specific and properly remove them, but I don’t want to add project-specific knowledge into the <span class="literal">distcheck</span> tests—it’s that problem of diminishing returns again.</p>&#13;
<h3 class="h3" id="ch03sec8"><span epub:type="pagebreak" id="page_63"/>The Filesystem Hierarchy Standard</h3>&#13;
<p class="noindent">You may be wondering by now where I’m getting these directory names. What if some Unix system out there doesn’t use <em>/usr</em> or <em>/usr/local</em>? For one thing, this is another reason for providing the <span class="literal">prefix</span> variable—to allow the user some choice in these matters. However, most Unix-like systems nowadays follow the <em>Filesystem Hierarchy Standard (FHS)</em> as closely as possible. The <em>FHS</em> defines a number of standard places, including the following root-level directories:</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
<col style="width:34%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/bin</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/etc</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/home</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/opt</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/sbin</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/srv</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/tmp</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/var</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This list is by no means exhaustive. I’ve only mentioned the directories that are most relevant to our study of open source project build systems. In addition, the <em>FHS</em> defines several standard locations beneath these root-level directories. For instance, the <em>/usr</em> directory should contain the following subdirectories:</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
<col style="width:34%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/bin</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/include</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/lib</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/local</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/sbin</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/share</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>/usr/src</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;"><p class="taba"> </p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <em>/usr/local</em> directory should contain a structure very similar to that of the <em>/usr</em> directory. The <em>/usr/local</em> directory provides a location for software installation that overrides versions of the same packages installed in the <em>/usr</em> directory structure, because system software updates often overwrite software in <em>/usr</em> without prejudice. The <em>/usr/local</em> directory structure allows a system administrator to decide which version of a package to use on their system because <em>/usr/local/bin</em> may be (and usually is) added to the <span class="literal">PATH</span> before <em>/usr/bin</em>. A fair amount of thought has gone into designing the <em>FHS</em>, and the GNU Autotools take full advantage of this consensus of understanding.</p>&#13;
<p class="indent">Not only does the <em>FHS</em> define these standard locations, but it also explains in detail what they’re for and what types of files should be kept there. All in all, the <em>FHS</em> leaves you, as project maintainer, just enough flexibility and choice to keep your life interesting but not enough to make you wonder whether you’re installing your files in the right places.<sup><a id="ch03fn_25" href="footnote.xhtml#ch03fn25">25</a></sup></p>&#13;
<h3 class="h3" id="ch03sec9"><span epub:type="pagebreak" id="page_64"/>Supporting Standard Targets and Variables</h3>&#13;
<p class="noindent">In addition to those I’ve already mentioned, the <em>GNU Coding Standards</em> lists some important targets and variables that you should support in your projects—mainly because your users will expect support for them.</p>&#13;
<p class="indent">Some of the chapters in the <em>GCS</em> document should be taken with a grain of salt (unless you’re actually working on a GNU-sponsored project). For example, you probably won’t care much about the C source code formatting suggestions in <a href="ch05.xhtml">Chapter 5</a> of the <em>GCS</em>. Your users certainly won’t care, so you can use whatever source code formatting style you wish.</p>&#13;
<p class="indent">That’s not to say that all of <a href="ch05.xhtml">Chapter 5</a> is worthless to non-GNU open source projects. The “Portability between System Types” and “Portability between CPUs” subsections, for instance, provide excellent information on C source code portability. Also, the “Internationalization” subsection gives some useful tips on using GNU software to internationalize your projects. We’ll consider internationalization in greater detail in <a href="ch11.xhtml">Chapter 11</a> of this book.</p>&#13;
<p class="indent">While <a href="ch06.xhtml">Chapter 6</a> of the <em>GCS</em> discusses documentation the GNU way, some sections of <a href="ch06.xhtml">Chapter 6</a> describe various top-level text files commonly found in projects, such as the <em>AUTHORS</em>, <em>NEWS</em>, <em>INSTALL</em>, <em>README</em>, and <em>ChangeLog</em> files. These are all bits of information that the well-indoctrinated open source software user expects to see in any reputable project.</p>&#13;
<p class="indent">The <em>really</em> useful information in the <em>GCS</em> document begins in <a href="ch07.xhtml">Chapter 7</a>, “The Release Process.” This chapter is critical to you as a project maintainer because it defines what your users will expect of your projects’ build systems. <a href="ch07.xhtml">Chapter 7</a> contains the de facto standards for the user options that packages provide in source-level distributions.</p>&#13;
<h4 class="h4" id="ch03sec9-1"><em>Standard Targets</em></h4>&#13;
<p class="noindent">The “How Configuration Should Work” subsection of <a href="ch07.xhtml">Chapter 7</a> of the <em>GCS</em> defines the configuration process, which I cover briefly in “Configuring Your Package” on <a href="ch03.xhtml#page_77">page 77</a>. The “Makefile Conventions” subsection of the <em>GCS</em> covers all of the standard targets and many of the standard variables that users have come to expect in open source software packages. Standard targets defined by the <em>GCS</em> include the following:</p>&#13;
<table id="table003" class="table1">&#13;
<colgroup>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">all</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install-html</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install-dvi</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install-pdf</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install-ps</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">install-strip</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uninstall</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">clean</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">distclean</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">mostlyclean</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">maintainer-clean</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">TAGS</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">info</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">dvi</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">html</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">pdf</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">ps</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">dist</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">check</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">installcheck</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">installdirs</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;"><p class="taba"> </p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_65"/>You don’t need to support all of these targets, but you should consider supporting the ones that make sense for your project. For example, if you build and install HTML pages, you should probably consider supporting the <span class="literal">html</span> and <span class="literal">install-html</span> targets. Autotools projects support these and more. Some targets are useful to end users, while others are useful only to project maintainers.</p>&#13;
<h4 class="h4" id="ch03sec9-2"><em>Standard Variables</em></h4>&#13;
<p class="noindent">Variables you should support as you see fit include those listed in the following table. In order to provide flexibility for the end user, most of these variables are defined in terms of a few of them and, ultimately, only one of them: <span class="literal">prefix</span>. For lack of a more standard name, I call these <em>prefix variables</em>. Most of these could be classified as <em>installation directory variables</em> that refer to standard locations, but there are a few exceptions, such as <span class="literal">srcdir</span>.</p>&#13;
<p class="indent">These variables are meant to be fully resolved by <span class="literal">make</span>, so they’re defined in terms of <span class="literal">make</span> variables, using parentheses rather than curly brackets. <a href="ch03.xhtml#ch03tab1">Table 3-1</a> lists these prefix variables and their default values.</p>&#13;
<p class="tabcap" id="ch03tab1"><strong>Table 3-1:</strong> Prefix Variables and Their Default Values</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Variable</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Default Value</strong></p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">prefix</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">/usr/local</p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">exec_prefix</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(prefix)</span></p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">bindir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(exec_prefix)</span>/bin</p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">sbindir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(exec_prefix)</span>/sbin</p></td></tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">libexecdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(exec_prefix)</span>/libexec</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">datarootdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(prefix)</span>/share</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">datadir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(datarootdir)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">sysconfdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(prefix)</span>/etc</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">sharedstatedir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(prefix)</span>/com</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">localstatedir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(prefix)</span>/var</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">includedir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(prefix)/</span>include</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">oldincludedir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba">/usr/include</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">docdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(datarootdir)</span>/doc/<span class="literal">$(package)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">infodir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(datarootdir)</span>/info</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">htmldir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(docdir)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">dvidir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(docdir)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">pdfdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(docdir)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">psdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(docdir)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">libdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(exec_prefix)</span>/lib</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">lispdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(datarootdir)</span>/emacs/site-lisp</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">localedir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(datarootdir)</span>/locale</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><span epub:type="pagebreak" id="page_66"/><p class="taba"><span class="literal">mandir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">$(datarootdir)</span>/man</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">man</span><em><span class="literal">N</span></em><span class="literal">dir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">$(mandir)</span>/man<em>N</em> (<em>N</em> = 1..9)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">manext</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba">.1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">man</span><em><span class="literal">N</span></em><span class="literal">ext</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">.<em>N</em> (<em>N</em> = 1..9)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba"><span class="literal">srcdir</span></p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">The source-tree directory corresponding to the current directory in the build tree</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Autotools-based projects support these and other useful variables automatically, as needed; Automake provides full support for them, while Autoconf’s support is more limited. If you write your own makefiles and build systems, you should support as many of these as you use in your build and installation processes.</p>&#13;
<h4 class="h4" id="ch03sec9-3"><em>Adding Location Variables to Jupiter</em></h4>&#13;
<p class="noindent">To support the variables that we’ve used so far in the Jupiter project, we need to add the <span class="literal">bindir</span> variable, as well as any variables that it relies on—in this case, the <span class="literal">exec_prefix</span> variable. <a href="ch03.xhtml#ch03ex27">Listings 3-27</a> and <a href="ch03.xhtml#ch03ex28">3-28</a> show how to do this in the top-level and <em>src</em> directory makefiles.</p>&#13;
<p class="margin">Git tag 3.11</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">prefix = /usr/local</span>&#13;
exec_prefix = $(prefix)&#13;
bindir = $(exec_prefix)/bin&#13;
<span class="ash">export prefix</span>&#13;
export exec_prefix&#13;
export bindir&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex27"/><em>Listing 3-27:</em> Makefile: <em>Adding the <span class="literal">bindir</span> variable</em></p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">install:</span>&#13;
        <span class="ash">install -d</span> $(bindir)&#13;
        <span class="ash">install -m 0755 jupiter</span> $(bindir)&#13;
&#13;
<span class="ash">uninstall:</span>&#13;
        <span class="ash">rm -f</span> $(bindir)<span class="ash">/jupiter</span>&#13;
        <span class="ash">-rmdir</span> $(bindir) <span class="ash">&gt;/dev/null 2&gt;&amp;1</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex28"/><em>Listing 3-28:</em> src/Makefile: <em>Adding the <span class="literal">bindir</span> variable</em></p>&#13;
<p class="indent">Even though we only use <span class="literal">bindir</span> in <em>src/Makefile</em>, we have to export <span class="literal">prefix</span>, <span class="literal">exec_prefix</span>, and <span class="literal">bindir</span> because <span class="literal">bindir</span> is defined in terms of <span class="literal">exec_prefix</span>, which is itself defined in terms of <span class="literal">prefix</span>. When <span class="literal">make</span> runs the <span class="literal">install</span> commands, it will first resolve <span class="literal">bindir</span> to <span class="literal">$(exec_prefix)</span><em>/bin</em>, then to <span class="literal">$(prefix)</span><em>/bin</em>, and finally to <em>/usr/local/bin</em>. Thus, <em>src/Makefile</em> needs to have access to all three variables during this process.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>How do such recursive variable definitions make life better for the end user? After all, the user can change the root install location from <em>/usr/local</em> to <em>/usr</em> by simply typing the following:</p>&#13;
<pre>$ <span class="codestrong1">make prefix=/usr install</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">The ability to change prefix variables at multiple levels is particularly useful to a Linux distribution packager (an employee or volunteer at a Linux company whose job it is to professionally package your project as a <em>.deb</em> or <em>.rpm</em> package) who needs to install packages into very specific system locations. For example, a distro packager could use the following command to change the installation prefix to <em>/usr</em> and the system configuration directory to <em>/etc</em>:</p>&#13;
<pre>$ <span class="codestrong1">make prefix=/usr sysconfdir=/etc install</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Without the ability to change prefix variables at multiple levels, configuration files would end up in <em>/usr/etc</em> because the default value of <span class="literal">$(sysconfdir)</span> is <span class="literal">$(prefix)</span><em>/etc</em>.</p>&#13;
<h3 class="h3" id="ch03sec10">Getting Your Project into a Linux Distro</h3>&#13;
<p class="noindent">When a Linux distro picks up your package for distribution, your project magically moves from the realm of tens of users to that of tens of thousands of users—almost overnight. Some people will be using your software without even knowing it. Since one great value of open source software for the developer is free help in making your software better, this can be seen as a good thing—a dramatic increase in community size.</p>&#13;
<p class="indent">By following the <em>GCS</em> within your build system, you remove many of the barriers to including your project in a Linux distro. If your tarball follows all the usual conventions, distro packagers will immediately know what to do with it. These packagers generally get to decide, based on needed functionality and their feelings about your package, whether it should be included in their flavor of Linux. Since they have a fair amount of power in this process, it behooves you to please them.</p>&#13;
<p class="indent">Section 7 of the <em>GCS</em> contains a small subsection that talks about supporting <em>staged installations</em>. It is easy to support this concept in your build system, but if you neglect to support it, it will almost always cause problems for packagers.</p>&#13;
<p class="indent">Packaging systems such as the Red Hat Package Manager (RPM) accept one or more tarballs, a set of patch files, and a specification file. The so-called <em>spec file</em> describes the process of building and packaging your project for a particular system. In addition, it defines all of the products installed into the target installation directory structure. The package manager software uses this information to install your package into a temporary <span epub:type="pagebreak" id="page_68"/>directory, from which it then pulls the specified products, storing them in a special binary archive that the package installation program (for example, <span class="literal">rpm</span>) understands.</p>&#13;
<p class="indent">To support staged installation, all you need is a variable named <span class="literal">DESTDIR</span> that acts as a sort of super-prefix to all of your installed products. To show you how this is done, I’ll add staged installation support to the Jupiter project. This is so trivial that it requires only four changes to <em>src/Makefile</em>. The required changes are highlighted in <a href="ch03.xhtml#ch03ex29">Listing 3-29</a>.</p>&#13;
<p class="margin">Git tag 3.12</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">install:</span>&#13;
        <span class="ash">install -d</span> $(DESTDIR)<span class="ash">$(bindir)</span>&#13;
        <span class="ash">install -m 0755 jupiter</span> $(DESTDIR)<span class="ash">$(bindir)</span>&#13;
&#13;
<span class="ash">uninstall:</span>&#13;
        <span class="ash">rm -f</span> $(DESTDIR)<span class="ash">$(bindir)/jupiter</span>&#13;
        <span class="ash">-rmdir</span> $(DESTDIR)<span class="ash">$(bindir) &gt;/dev/null 2&gt;&amp;1</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex29"/><em>Listing 3-29:</em> src/Makefile: <em>Adding staged build functionality</em></p>&#13;
<p class="indent">As you can see, I’ve added the <span class="literal">$(DESTDIR)</span> prefix to the <span class="literal">$(bindir)</span> references in the <span class="literal">install</span> and <span class="literal">uninstall</span> targets that refer to installation paths. You don’t need to define a default value for <span class="literal">DESTDIR</span>, because when it is left undefined, it expands to an empty string, which has no effect on the paths to which it’s prepended.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Do not add a slash after <em><span class="literal">$(DESTDIR)</span></em>, which is usually empty. The prefix variables ultimately resolve to something starting with a slash; adding a slash after <em><span class="literal">$(DESTDIR)</span></em> is therefore redundant and, in some situations, can cause unintended side effects.</em></p>&#13;
</div>&#13;
<p class="indent">I didn’t need to add <span class="literal">$(DESTDIR)</span> to the <span class="literal">uninstall</span> rule’s <span class="literal">rm</span> command for the sake of the package manager, because package managers don’t care how your package is uninstalled. They only install your package so they can copy the products from a stage directory. To uninstall the stage directory, package managers simply delete it. Package manager programs such as <span class="literal">rpm</span> use their own rules for removing products from a system, and these rules are based on a package manager database rather than your <span class="literal">uninstall</span> target.</p>&#13;
<p class="indent">However, for the sake of symmetry, and to be complete, it doesn’t hurt to add <span class="literal">$(DESTDIR)</span> to <span class="literal">uninstall</span>. Besides, we need it to be complete for the sake of the <span class="literal">distcheck</span> target, which we’ll now modify to take advantage of our staged installation functionality. This modification is shown in <a href="ch03.xhtml#ch03ex30">Listing 3-30</a>.</p>&#13;
<p class="margin">Git tag 3.13</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">distcheck: $(distdir).tar.gz</span>&#13;
        <span class="ash">gzip -cd $(distdir).tar.gz | tar xvf -</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) all</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) check</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE)</span> DESTDIR<span class="ash">=$${PWD}/inst install</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE)</span> DESTDIR<span class="ash">=$${PWD}/inst uninstall</span>&#13;
        <span epub:type="pagebreak" id="page_69"/><span class="ash">@remaining="`find $(distdir)/inst -type f | wc -l`"; \</span>&#13;
        <span class="ash">if test "$${remaining}" -ne 0; then \</span>&#13;
          <span class="ash">echo "*** $${remaining} file(s) remaining in stage directory!"; \</span>&#13;
          <span class="ash">exit 1; \</span>&#13;
        <span class="ash">fi</span>&#13;
        <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) clean</span>&#13;
        <span class="ash">rm -rf $(distdir)</span>&#13;
        <span class="ash">@echo "*** Package $(distdir).tar.gz is ready for distribution."</span>&#13;
<span class="codeitalic1a">--</span><span class="codeitalic1a">snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex30"/><em>Listing 3-30:</em> Makefile: <em>Using <span class="literal">DESTDIR</span> in the <span class="literal">distcheck</span> target</em></p>&#13;
<p class="indent">Changing <span class="literal">prefix</span> to <span class="literal">DESTDIR</span> in the <span class="literal">install</span> and <span class="literal">uninstall</span> commands allows us to properly test a complete installation directory hierarchy, as we’ll see shortly.</p>&#13;
<p class="indent">At this point, an RPM spec file could provide the following text as the installation commands for the Jupiter package:</p>&#13;
<pre>%install&#13;
make prefix=/usr DESTDIR=%BUILDROOT install</pre>&#13;
<p class="indent">Don’t worry about package manager file formats. Instead, just focus on providing staged installation functionality through the <span class="literal">DESTDIR</span> variable.</p>&#13;
<p class="indent">You may be wondering why the <span class="literal">prefix</span> variable couldn’t provide this functionality. For one thing, not every path in a system-level installation is defined relative to the <span class="literal">prefix</span> variable. The system configuration directory (<span class="literal">sysconfdir</span>), for instance, is often defined as <em>/etc</em> by packagers. You can see in <a href="ch03.xhtml#ch03tab1">Table 3-1</a> that the default definition of <span class="literal">sysconfdir</span> is <span class="literal">$(prefix)</span><em>/etc</em>, so the only way <span class="literal">sysconfdir</span> would resolve to <em>/etc</em> would be if you explicitly set it to do so on the <span class="literal">configure</span> or <span class="literal">make</span> command line. If you configured it that way, only a variable like <span class="literal">DESTDIR</span> would affect the base location of <span class="literal">sysconfdir</span> during staged installation. Other reasons for this will become clearer as we talk about project configuration later on in this chapter, and then again in the next two chapters.</p>&#13;
<h3 class="h3" id="ch03sec11">Build vs. Installation Prefix Overrides</h3>&#13;
<p class="noindent">At this point, I’d like to digress slightly to explain an elusive (or at least nonobvious) concept regarding <span class="literal">prefix</span> and other path variables defined in the <em>GCS</em>. In the preceding examples, I used prefix overrides on the <span class="literal">make install</span> command line, like this:</p>&#13;
<pre>$ <span class="codestrong1">make prefix=/usr install</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">The question I wish to address is: what is the difference between using a prefix override for <span class="literal">make all</span> and for <span class="literal">make install</span>? In our small sample makefiles, we’ve managed to avoid using prefixes in any targets not related to installation, so it may not be clear to you at this point that a prefix is <em>ever</em> <span epub:type="pagebreak" id="page_70"/>useful during the build stage. However, prefix variables can be very useful during the build stage to substitute paths into source code at compile time, as shown in <a href="ch03.xhtml#ch03ex31">Listing 3-31</a>.</p>&#13;
<pre>program: main.c&#13;
       gcc -DCFGDIR="\"$(sysconfdir)\"" -o $@ main.c</pre>&#13;
<p class="caption"><a id="ch03ex31"/><em>Listing 3-31: Substituting paths into source code at compile time</em></p>&#13;
<p class="indent">In this example, I’m defining a C-preprocessor variable called <span class="literal">CFGDIR</span> on the compiler command line for use by <em>main.c</em>. Presumably, there’s some code in <em>main.c</em> like that shown in <a href="ch03.xhtml#ch03ex32">Listing 3-32</a>.</p>&#13;
<pre>#ifndef CFGDIR&#13;
# define CFGDIR "/etc"&#13;
#endif&#13;
const char *cfgdir = CFGDIR;</pre>&#13;
<p class="caption"><a id="ch03ex32"/><em>Listing 3-32: Substituting <span class="literal">CFGDIR</span> at compile time</em></p>&#13;
<p class="indent">Later in the code, you might use the C global variable <span class="literal">cfgdir</span> to access the application’s configuration file.</p>&#13;
<p class="indent">Linux distro packagers often use different prefix overrides for build and install command lines in RPM spec files. During the build stage, the actual runtime directories are hardcoded into the executable using commands like the <span class="literal">./configure</span> command shown in <a href="ch03.xhtml#ch03ex33">Listing 3-33</a>.</p>&#13;
<pre>%build&#13;
%setup&#13;
./configure prefix=/usr sysconfdir=/etc&#13;
make</pre>&#13;
<p class="caption"><a id="ch03ex33"/><em>Listing 3-33: The portion of an RPM spec file that builds the source tree</em></p>&#13;
<p class="indent">Note that we have to explicitly specify <span class="literal">sysconfdir</span> along with <span class="literal">prefix</span>, because, as I mentioned earlier, the system configuration directory is usually outside of the <span class="literal">prefix</span> directory structure. The package manager installs these executables into a stage directory so it can then copy them out of their installed locations when it builds the binary installation package. The corresponding installation commands might look like those shown in <a href="ch03.xhtml#ch03ex34">Listing 3-34</a>.</p>&#13;
<pre>%install&#13;
make DESTDIR=%BUILDROOT% install</pre>&#13;
<p class="caption"><a id="ch03ex34"/><em>Listing 3-34: The installation portion of an RPM spec file</em></p>&#13;
<p class="indent">Using <span class="literal">DESTDIR</span> during installation will temporarily override <em>all</em> installation prefix variables, so you don’t have to remember which variables you’ve overridden during configuration. Given the configuration command shown in <a href="ch03.xhtml#ch03ex33">Listing 3-33</a>, using <span class="literal">DESTDIR</span> in the manner shown in <a href="ch03.xhtml#ch03ex34">Listing 3-34</a> has the same effect as the code shown in <a href="ch03.xhtml#ch03ex35">Listing 3-35</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_71"/>%install&#13;
make prefix=%BUILDROOT%/usr sysconfdir=%BUILDROOT%/etc install</pre>&#13;
<p class="caption"><a id="ch03ex35"/><em>Listing 3-35: Overriding the default <span class="literal">sysconfdir</span> during installation</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>The key point here is one that I touched on earlier. Never write your install target to build all or even part of your products in your makefiles. Installation functionality should be limited to copying files, if possible. Otherwise, your users won’t be able to access your staged installation features if they are using prefix overrides.</em></p>&#13;
</div>&#13;
<p class="indent">Another reason for limiting installation functionality in this way is that it allows the user to install sets of packages as a group into an isolated location and then create links to the actual files in the proper locations. Some people like to do this when they are testing out a package and want to keep track of all its components.<sup><a id="ch03fn_26" href="footnote.xhtml#ch03fn26">26</a></sup></p>&#13;
<p class="indent">One final point: if you’re installing into a system directory hierarchy, you’ll need <em>root</em> permissions. People often run <span class="literal">make install</span> like this:</p>&#13;
<pre>$ <span class="codestrong1">sudo make install</span></pre>&#13;
<p class="indent">If your <span class="literal">install</span> target depends on your build targets, and you’ve neglected to build them beforehand, <span class="literal">make</span> will happily build your program before installing it—but the local copies will all be owned by <em>root</em>. This inconvenience is easily avoided by having <span class="literal">make install</span> fail for lack of things to install, rather than jumping right into a build while running as <em>root</em>.</p>&#13;
<h3 class="h3" id="ch03sec12">User Variables</h3>&#13;
<p class="noindent">The <em>GCS</em> defines a set of variables that are sacred to the user. These variables should be <em>referenced</em> by a GNU build system but never <em>modified</em> by a GNU build system. These so-called <em>user variables</em> include those listed in <a href="ch03.xhtml#ch03tab2">Table 3-2</a> for C and C++ programs.</p>&#13;
<p class="tabcap" id="ch03tab2"><strong>Table 3-2:</strong> Some User Variables and Their Purposes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Variables</p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba">Purpose</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">CC</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to the system C compiler</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">CFLAGS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba">Desired C compiler flags</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">CXX</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to the system C++ compiler</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><span epub:type="pagebreak" id="page_72"/><p class="taba"><span class="literal">CXXFLAGS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba">Desired C++ compiler flags</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">LDFLAGS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Desired linker flags</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba"><span class="literal">CPPFLAGS</span></p></td>&#13;
<td style="vertical-align: top;" class="table-a"><p class="taba">Desired C/C++ preprocessor flags</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1"><p class="taba"><em><span class="literal">--snip--</span></em></p></td>&#13;
<td style="vertical-align: top;" class="table-h1"><p class="taba"/></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This list is by no means comprehensive, and interestingly, there isn’t a comprehensive list to be found in the <em>GCS</em>. In fact, most of these variables come from the documentation for the <span class="literal">make</span> utility itself. These variables are used in the built-in rules of the <span class="literal">make</span> utility—they’re somewhat hardcoded into <span class="literal">make</span>, so they are effectively defined by <span class="literal">make</span>. You can find a fairly complete list of program name and flag variables in the “Variables Used by Implicit Rules” section of the <em>GNU Make Manual</em>.</p>&#13;
<p class="indent">Note that <span class="literal">make</span> assigns default values for many of these variables based on common Unix utility names. For example, the default value of <span class="literal">CC</span> is <span class="literal">cc</span>, which (at least on Linux systems) is a soft link to the GCC C compiler (<span class="literal">gcc</span>). On other systems, <span class="literal">cc</span> is a soft link to the system’s own compiler. Thus, we don’t need to set <span class="literal">CC</span> to <span class="literal">gcc</span>, which is good, because GCC may not be installed on non-Linux platforms. There may be times when you do wish to set <span class="literal">CC</span> on the <span class="literal">make</span> command line, such as when using an alternative compiler like <span class="literal">clang</span> or when using the <span class="literal">ccache</span> utility to cache <span class="literal">gcc</span> results for faster recompilation.</p>&#13;
<p class="indent">For our purposes, the variables shown in <a href="ch03.xhtml#ch03tab2">Table 3-2</a> are sufficient, but for a more complex makefile, you should become familiar with the larger list outlined in the <em>GNU Make Manual</em>.</p>&#13;
<p class="indent">To use these variables in our makefiles, we’ll just replace <span class="literal">gcc</span> with <span class="literal">$(CC)</span>. We’ll do the same for <span class="literal">CFLAGS</span> and <span class="literal">CPPFLAGS</span>, although <span class="literal">CPPFLAGS</span> will be empty by default. The <span class="literal">CFLAGS</span> variable has no default value either, but this is a good time to add one. I like to use <span class="literal">-g</span> to build objects with symbols and <span class="literal">-O0</span> to disable optimizations for debug builds. The updates to <em>src/Makefile</em> are shown in <a href="ch03.xhtml#ch03ex36">Listing 3-36</a>.</p>&#13;
<p class="margin">Git tag 3.14</p>&#13;
<pre>4CFLAGS = -g -O0&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">jupiter: main.c</span>&#13;
        $(CC) $(CPPFLAGS) $(CFLAGS) <span class="ash">-o $@ main.c</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex36"/><em>Listing 3-36:</em> src/Makefile: <em>Adding appropriate user variables</em></p>&#13;
<p class="indent">This works because the <span class="literal">make</span> utility allows such variables to be overridden by options on the command line. For example, to switch compilers and set some compiler command line options, a user need only type the following:</p>&#13;
<pre>$ <span class="codestrong1">make CC=ccache CFLAGS='-g -O2' CPPFLAGS=-Dtest</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>In this case, our user has decided to use the <span class="literal">ccache</span> utility instead of <span class="literal">gcc</span>, generate debug symbols, and optimize their code using level-two optimizations. They’ve also decided to enable the <span class="literal">test</span> option through the use of a C-preprocessor definition. Note that these variables are set on the <span class="literal">make</span> command line; this apparently equivalent Bourne-shell syntax will not work as expected:</p>&#13;
<pre>$ <span class="codestrong1">CC=ccache CFLAGS='-g -O2' CPPFLAGS=-Dtest make</span></pre>&#13;
<p class="indent">The reason is that we’re merely setting environment variables in the local environment passed to the <span class="literal">make</span> utility by the shell. Remember that environment variables do not automatically override those set in the makefile. To get the functionality we want, we could use a little GNU <span class="literal">make</span>–specific syntax in our makefile, as shown in <a href="ch03.xhtml#ch03ex37">Listing 3-37</a>.</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">CFLAGS</span> ?= <span class="ash">-g -O0</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption"><a id="ch03ex37"/><em>Listing 3-37: Using the GNU <span class="literal">make</span>–specific query-assign operator (<span class="literal">?=</span>) in a makefile</em></p>&#13;
<p class="indent">The <span class="literal">?=</span> operator is a GNU <span class="literal">make</span>–specific operator, which will only set the variable in the makefile if it hasn’t already been set elsewhere. This means we can now override these particular variable settings by setting them in the environment. But don’t forget that this will only work in GNU <span class="literal">make</span>. In general, it’s better to set <span class="literal">make</span> variables on the <span class="literal">make</span> command line.</p>&#13;
<h3 class="h3" id="ch03sec13">Nonrecursive Build Systems</h3>&#13;
<p class="noindent">Now that we’ve spent all this time creating the perfect build system for our project, let’s take a look at a <em>more perfect</em> solution—a nonrecursive system. I mentioned at the start of this chapter that there was a problem with recursive builds that we’d discuss at a later point.</p>&#13;
<p class="indent">The fundamental problem with recursive build systems is that they artificially introduce flaws into <span class="literal">make</span>’s directed graph—the set of rules <span class="literal">make</span> uses to determine what depends on what and when something needs to be rebuilt. For Jupiter, very little can go wrong because there’s one top-level makefile invoking <span class="literal">make</span> on a single subdirectory makefile, but let’s consider a more complex project where multiple submodules, nested arbitrarily deeply, are interdependent upon each other in more complex ways.</p>&#13;
<p class="indent">With a single makefile, the one <span class="literal">make</span> process can “see the big picture.” That is, it can see and understand all of the interdependencies in the system, and it can create a DAG that properly represents all of the inter­dependencies among all of the filesystem objects within the project. With multiple makefiles, each child <span class="literal">make</span> process executed by parent <span class="literal">make</span> can see only a portion of the dependency graph. Ultimately, this can cause <span class="literal">make</span> to build products out of order so that a product that depends on prerequisites not within its own purview is built before those prerequisites are updated.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>The preceding problem is compounded when you use <em>parallel</em> <em><span class="literal">make</span></em> by adding <span class="literal">-j</span> to the <span class="literal">make</span> command line. The <span class="literal">-j</span> option tells <span class="literal">make</span> to examine its DAG and find places where portions of the DAG do not depend on each other, then execute those portions at the same time. On a multiprocessor system, this can dramatically speed up the build process for large projects. However, this causes problems from two different angles. First, since <span class="literal">make</span> can’t see the whole picture, it can make incorrect assumptions about what things can be done in parallel. Second, as far as the top-level <span class="literal">make</span> is concerned, child <span class="literal">make</span> processes are all independent and can be run in parallel, which we can easily see is simply not true. For an example that does not even rely on the differences between recursive and nonrecursive build systems, consider the following command line:</p>&#13;
<pre>$ <span class="codestrong1">make -j clean all</span></pre>&#13;
<p class="indent">As far as <span class="literal">make</span> is concerned, <span class="literal">clean</span> and <span class="literal">all</span> are 100 percent independent of each other, so <span class="literal">make</span> will happily run them both at the same time. Even a novice can see the problems with this assumption. The point is, <span class="literal">make</span> doesn’t understand the high-level relationship between <span class="literal">clean</span> and <span class="literal">all</span>. That relationship is understood only by the author of the makefile. Similar barriers to <span class="literal">make</span>’s understanding of the big picture are artificially introduced at the boundaries between parent and child <span class="literal">make</span> invocations in a recursive build system.</p>&#13;
<p class="indent">So, how hard is it to turn Jupiter’s recursive build system into a nonrecursive system? We want to maintain modularity, so we still want a <em>Makefile</em> in each directory that essentially manages the tasks of that directory. This is easily accomplished by using another feature of common <span class="literal">make</span>—the <span class="literal">include</span> directive. The <span class="literal">include</span> directive allows us to break up our single, parent-level makefile into chunks of directory-specific rules and then include just those snippets in the top-level makefile. <a href="ch03.xhtml#ch03ex38">Listing 3-38</a> shows what the complete updated top-level makefile looks like.</p>&#13;
<p class="margin">Git tag 3.15</p>&#13;
<pre>   <span class="ash">package = jupiter</span>&#13;
   <span class="ash">version = 1.0</span>&#13;
   <span class="ash">tarname = $(package)</span>&#13;
   <span class="ash">distdir = $(tarname)-$(version)</span>&#13;
&#13;
   <span class="ash">prefix = /usr/local</span>&#13;
   <span class="ash">exec_prefix = $(prefix)</span>&#13;
   <span class="ash">bindir = $(exec_prefix)/bin</span>&#13;
&#13;
<span class="ent">➊</span><span class="ash"/> #<span class="ash">export prefix</span>&#13;
   #<span class="ash">export exec_prefix</span>&#13;
   #<span class="ash">export bindir</span>&#13;
&#13;
<span class="ent">➋</span> all jupiter: src/jupiter&#13;
&#13;
   <span class="ash">dist: $(distdir).tar.gz</span>&#13;
&#13;
   <span class="ash">$(distdir).tar.gz: $(distdir)</span>&#13;
           <span class="ash">tar chof - $(distdir) | gzip -9 -c &gt; $@</span>&#13;
           <span class="ash">rm -rf $(distdir)</span>&#13;
<span epub:type="pagebreak" id="page_75"/>&#13;
   <span class="ash">$(distdir): FORCE</span>&#13;
           <span class="ash">mkdir -p $(distdir)/src</span>&#13;
           <span class="ash">cp Makefile $(distdir)</span>&#13;
           <span class="ash">cp src/Makefile $(distdir)/src</span>&#13;
           <span class="ash">cp src/main.c $(distdir)/src</span>&#13;
&#13;
   <span class="ash">distcheck: $(distdir).tar.gz</span>&#13;
           <span class="ash">gzip -cd $(distdir).tar.gz | tar xvf -</span>&#13;
           <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) all</span>&#13;
           <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) check</span>&#13;
           <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) DESTDIR=$${PWD}/_inst install</span>&#13;
           <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) DESTDIR=$${PWD}/_inst uninstall</span>&#13;
           <span class="ash">@remaining="`find $${PWD}/$(distdir)/_inst -type f | wc -l`"; \</span>&#13;
           <span class="ash">if test "$${remaining}" -ne 0; then \</span>&#13;
             <span class="ash">echo "*** $${remaining} file(s) remaining in stage directory!"; \</span>&#13;
             <span class="ash">exit 1; \</span>&#13;
           <span class="ash">fi</span>&#13;
           <span class="ash">cd $(distdir) &amp;&amp; $(MAKE) clean</span>&#13;
           <span class="ash">rm -rf $(distdir)</span>&#13;
           <span class="ash">@echo "*** Package $(distdir).tar.gz is ready for distribution."</span>&#13;
&#13;
   <span class="ash">FORCE:</span>&#13;
           <span class="ash">-rm -f $(distdir).tar.gz &gt;/dev/null 2&gt;&amp;1</span>&#13;
           <span class="ash">-rm -rf $(distdir) &gt;/dev/null 2&gt;&amp;1</span>&#13;
<span class="ent">➌</span> include src/Makefile&#13;
&#13;
  <span class="ash">.PHONY: FORCE all clean check dist distcheck install uninstall</span></pre>&#13;
<p class="caption"><a id="ch03ex38"/><em>Listing 3-38:</em> Makefile: <em>A nonrecursive version of the top-level makefile</em></p>&#13;
<p class="indent">Three changes were made here, but please note that the only really significant change made to this makefile was the replacement of the rule at <span class="ent">➋</span> where recursion was done with a single rule for <span class="literal">all</span>, <span class="literal">clean</span>, <span class="literal">check</span>, <span class="literal">install</span>, <span class="literal">uninstall</span>, and an explicit <span class="literal">jupiter</span> target. Even this replacement could have been a simple deletion if we hadn’t cared that the new default target would have become <span class="literal">dist</span>, had we not added the <span class="literal">all</span> target at this location. I’ve also added an explicit <span class="literal">jupiter</span> target that maps to <span class="literal">src/jupiter</span> to maintain feature parity with the previous system.</p>&#13;
<p class="indent">The second change made was to include the <em>src</em>-level makefile at <span class="ent">➌</span>. Finally, I also commented out the <span class="literal">export</span> statements at <span class="ent">➊</span> because we no longer need to export variables to child <span class="literal">make</span> processes; they’re left as comments simply for illustration.</p>&#13;
<p class="indent">Now, let’s examine what changed in the <em>src</em>-level makefile. The complete, updated version is shown in <a href="ch03.xhtml#ch03ex39">Listing 3-39</a>.</p>&#13;
<pre><span class="ash">CFLAGS = -g -O0</span>&#13;
&#13;
src/<span class="ash">jupiter:</span> src/<span class="ash">main.c</span>&#13;
        <span class="ash">$(CC) $(CFLAGS) $(CPPFLAGS) -o $@</span> src/<span class="ash">main.c</span>&#13;
&#13;
<span class="ash">check: all</span>&#13;
<span epub:type="pagebreak" id="page_76"/>                <span class="ash">./</span>src/<span class="ash">jupiter | grep "Hello from .*jupiter!"</span>&#13;
        <span class="ash">@echo "*** All TESTS PASSED"</span>&#13;
&#13;
<span class="ash">install:</span>&#13;
        <span class="ash">install -d $(DESTDIR)$(bindir)</span>&#13;
        <span class="ash">install -m 0755</span> src/<span class="ash">jupiter $(DESTDIR)$(bindir)</span>&#13;
&#13;
<span class="ash">uninstall:</span>&#13;
        <span class="ash">rm -f $(DESTDIR)$(bindir)/jupiter</span>&#13;
        <span class="ash">-rmdir -f $(DESTDIR)$(bindir) &gt;/dev/null 2&gt;&amp;1</span>&#13;
&#13;
<span class="ash">clean:</span>&#13;
        <span class="ash">rm -f</span> src/<span class="ash">jupiter</span></pre>&#13;
<p class="caption"><a id="ch03ex39"/><em>Listing 3-39:</em> src/Makefile: <em>A nonrecursive version of the src-level makefile</em></p>&#13;
<p class="indent">First, the <span class="literal">all</span> target was removed. We don’t need one here now because this makefile is not intended to be executed directly but, rather, included by the parent makefile. Hence, we do not need a default target. Second, all references to objects in the <em>src</em> directory are now referenced by paths that are relative to the parent directory. Again, this is because <span class="literal">make</span> is executed only once from the parent directory, so references to objects in the <em>src</em> directory must be considered relative to where <span class="literal">make</span> is running—the parent directory.</p>&#13;
<p class="indent">We also removed the <span class="literal">.PHONY</span> directive at the bottom because this directive contained a proper subset of the <span class="literal">.PHONY</span> directive in the parent makefile, making the directive redundant. In short, we merely converted this makefile into a snippet that could be included in the parent makefile, removed redundancies, and ensured that all filesystem references are now made relative to the parent directory. I hope you can see that these changes actually constitute a simplification of what we had before. Intuitively, it seems more complicated but it is actually simpler.</p>&#13;
<p class="indent">This makefile is a more accurate and faster version of our recursive system. I say “this makefile” because there is really only one makefile here—the included file can be pasted directly into the parent makefile at the point of inclusion (at <span class="ent">➋</span> in <a href="ch03.xhtml#ch03ex38">Listing 3-38</a>), just as with inclusions of header files in C-language source files. Ultimately, after all the inclusions are resolved, there are only one makefile and one <span class="literal">make</span> process that executes commands based on the rules in that makefile.</p>&#13;
<p class="indent">One apparent drawback of nonrecursive build systems is that you cannot simply enter <span class="literal">make</span> while sitting in the <em>src</em> directory and build the portion of the project related to that directory. Instead, you have to change into the parent directory and run <span class="literal">make</span>, which builds everything. But this, too, is a fallacious concern because you’ve always had the ability to execute any portion of the build system you wished by specifying exactly the target you desired on the <span class="literal">make</span> command line. The difference is that now what gets built is actually what should get built because <span class="literal">make</span> understands the entire set of dependencies for any given target you command it to build.</p>&#13;
<p class="indent">As we’ll see in the coming chapters, Automake has full support for nonrecursive build systems. I encourage you to start writing your next <span epub:type="pagebreak" id="page_77"/>project build system in a nonrecursive fashion because it can seem like an overwhelming task to retrofit an existing system, even though, as we’ve seen here, it’s not really all that difficult.</p>&#13;
<h3 class="h3" id="ch03sec14">Configuring Your Package</h3>&#13;
<p class="noindent">The <em>GCS</em> describes the configuration process in the “How Configuration Should Work” subsection of Section 7. Up to this point, we’ve been able to do about everything we’ve wanted to with Jupiter using only makefiles, so you might be wondering what configuration is actually for. The opening paragraphs of this subsection in the <em>GCS</em> answer our question:</p>&#13;
<p class="bqpara">Each GNU distribution should come with a shell script named <span class="literal">configure</span>. This script is given arguments which describe the kind of machine and system you want to compile the program for. The <span class="literal">configure</span> script must record the configuration options so that they affect compilation.</p>&#13;
<p class="bqpara">The description here is the specification of the interface for the <span class="literal">configure</span> script in GNU packages. Many packages implement it using GNU Autoconf (see “Introduction” in Autoconf) and/or GNU Automake (see “Introduction” in Automake), but you do not have to use these tools. You can implement it any way you like; for instance, by making <span class="literal">configure</span> be a wrapper around a completely different configuration system.</p>&#13;
<p class="bqpara">Another way for the <span class="literal">configure</span> script to operate is to make a link from a standard name such as <em>config.h</em> to the proper configuration file for the chosen system. If you use this technique, the distribution should <em>not</em> contain a file named <em>config.h</em>. This is so that people won’t be able to build the program without configuring it first.</p>&#13;
<p class="bqpara">Another thing that <span class="literal">configure</span> can do is to edit the <em>Makefile</em>. If you do this, the distribution should <em>not</em> contain a file named <em>Makefile</em>. Instead, it should include a file <em>Makefile.in</em> which contains the input used for editing. Once again, this is so that people won’t be able to build the program without configuring it first.<sup><a id="ch03fn_27" href="footnote.xhtml#ch03fn27">27</a></sup></p>&#13;
<p class="indent">So then, the primary tasks of a typical configuration script are as follows:</p>&#13;
<ul>&#13;
<li class="noindent">Generate files from templates containing replacement variables.</li>&#13;
<li class="noindent">Generate a C-language header file (<em>config.h</em>) for inclusion by project source code.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_78"/>Set user options for a particular <span class="literal">make</span> environment (debug flags and so on).</li>&#13;
<li class="noindent">Set various package options as environment variables.</li>&#13;
<li class="noindent">Test for the existence of tools, libraries, and header files.</li>&#13;
</ul>&#13;
<p class="indent">For complex projects, configuration scripts often generate the project makefiles from one or more templates maintained by project developers. These templates contain configuration variables in a format that is easy to recognize (and substitute). The configuration script replaces these variables with values determined during the configuration process—either from command line options specified by the user or from a thorough analysis of the platform environment. This analysis entails such things as checking for the existence of certain system or package header files and libraries, searching various filesystem paths for required utilities and tools, and even running small programs designed to indicate the feature set of the shell, C compiler, or desired libraries.</p>&#13;
<p class="indent">The tool of choice for variable replacement has, in the past, been the <span class="literal">sed</span> stream editor. A simple <span class="literal">sed</span> command can replace all the configuration variables in a makefile template in a single pass through the file. However, Autoconf versions 2.62 and newer prefer <span class="literal">awk</span> to <span class="literal">sed</span> for this process. The <span class="literal">awk</span> utility is almost as pervasive as <span class="literal">sed</span> these days, and it provides more functionality to allow for efficient replacement of many variables. For our purposes on the Jupiter project, either of these tools would suffice.</p>&#13;
<h3 class="h3" id="ch03sec15">Summary</h3>&#13;
<p class="noindent">We have now created a complete project build system by hand, with one important exception: we haven’t designed a <span class="literal">configure</span> script according to the design criteria specified in the <em>GNU Coding Standards</em>. We could do this, but it would take a dozen more pages of text to build one that even comes close to conforming to these specifications. Still, there are a few key build features related specifically to the makefiles that the <em>GCS</em> indicates are desirable. Among these is the concept of vpath building. This is an important feature that can be properly illustrated only by actually writing a configuration script that works as specified by the <em>GCS</em>.</p>&#13;
<p class="indent">Rather than spend the time and effort to do this now, I’d like to simply move on to a discussion of Autoconf in <a href="ch04.xhtml">Chapter 4</a>, which will allow us to build one of these configuration scripts in as little as two or three lines of code. With that behind us, it will be trivial to add vpath building and other common Autotools features to the Jupiter project.</p>&#13;
</body></html>