- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Introduction to Shell Scripts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本简介
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: If you can enter commands into the shell, you can write shell scripts. A *shell
    script* (also known as a *Bourne shell script*) is a series of commands written
    in a file; the shell reads the commands from the file just as it would if you
    typed them into a terminal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在 shell 中输入命令，你就能编写 shell 脚本。*Shell 脚本*（也称为 *Bourne shell 脚本*）是一系列写入文件中的命令；shell
    会从文件中读取这些命令，就像你在终端中输入一样。
- en: 11.1 Shell Script Basics
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 Shell 脚本基础
- en: Bourne shell scripts generally start with the following line, which indicates
    that the `/bin/sh` program should execute the commands in the script file. (Make
    sure that there’s no whitespace at the beginning of the script file.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne shell 脚本通常以以下行开始，指示 `/bin/sh` 程序应执行脚本文件中的命令。（确保脚本文件开头没有空白字符。）
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `#!` part is called a *shebang*; you’ll see it in other scripts in this
    book. You can list any commands that you want the shell to execute following the
    `#!/bin/sh` line. For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!` 部分被称为 *shebang*；你将在本书的其他脚本中看到它。你可以在`#!/bin/sh`行后列出任何你希望 shell 执行的命令。例如：'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As with any program on Unix systems, you need to set the executable bit for
    a shell script file, but you must also set the read bit in order for the shell
    to be able to read the file. The easiest way to do this is as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Unix 系统上的任何程序一样，你需要为 shell 脚本文件设置可执行位，但你还必须设置读取位，以便 shell 能够读取该文件。做到这一点的最简单方法如下：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `chmod` command allows other users to read and execute `script`. If you
    don’t want that, use the absolute mode `700` instead (and refer to Section 2.17
    for a refresher on permissions).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`chmod`命令允许其他用户读取并执行`script`。如果你不希望这样，可以使用绝对模式`700`来代替（更多权限内容请参见第 2.17 节）。
- en: After creating a shell script and setting read and execute permissions, you
    can run it by placing the script file in one of the directories in your command
    path and then running the script name on the command line. You can also run `./``script`
    if the script is located in your current working directory, or you can use the
    full pathname.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 shell 脚本并设置读取和执行权限后，你可以将脚本文件放置在命令路径中的一个目录里，然后在命令行上运行脚本名称来执行它。如果脚本位于当前工作目录中，你也可以运行`./``script`，或者使用完整路径名来运行。
- en: Running a script with a shebang is almost (but not quite) the same as running
    a command with your shell; for example, running a script called `myscript` causes
    the kernel to run `/bin/sh myscript`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 shebang 运行脚本几乎（但不完全）等同于在你的 shell 中运行一个命令；例如，运行一个名为`myscript`的脚本会导致内核运行`/bin/sh
    myscript`。
- en: With the basics behind us, let’s look at some of the limitations of shell scripts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本内容讲解完毕后，让我们来看一看 shell 脚本的一些限制。
- en: 11.1.1 Limitations of Shell Scripts
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 Shell 脚本的限制
- en: The Bourne shell manipulates commands and files with relative ease. In Section
    2.14, you saw the way the shell can redirect output, one of the important elements
    of shell script programming. However, the shell script is only one tool for Unix
    programming, and although scripts have considerable power, they also have limitations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne shell 轻松地操作命令和文件。在第 2.14 节中，你已经看到 shell 如何重定向输出，这是 shell 脚本编程的一个重要元素。然而，shell
    脚本只是 Unix 编程的一个工具，尽管脚本拥有相当强大的功能，但它们也有局限性。
- en: One of the main strengths of shell scripts is that they can simplify and automate
    tasks that you can otherwise perform at the shell prompt, like manipulating batches
    of files. But if you’re trying to pick apart strings, perform repeated arithmetic
    computations, or access complex databases, or if you want functions and complex
    control structures, you’re better off using a scripting language like Python,
    Perl, or `awk`, or perhaps even a compiled language like C. (This is important,
    so you’ll see it throughout the chapter.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本的一个主要优点是，它们可以简化和自动化你在 shell 提示符下执行的任务，例如批量操作文件。但如果你想分解字符串、进行重复的算术计算、访问复杂的数据库，或者需要函数和复杂的控制结构，那么最好使用像
    Python、Perl 或 `awk` 这样的脚本语言，或者甚至是像 C 这样的编译语言。（这是很重要的，所以你会在整章中看到它。）
- en: Finally, be aware of your shell script sizes. Keep your shell scripts short.
    Bourne shell scripts aren’t meant to be big, though you will undoubtedly encounter
    some monstrosities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意你的 shell 脚本大小。保持脚本简短。Bourne shell 脚本并不适合做成很大，尽管你可能会遇到一些庞然大物。
- en: 11.2 Quoting and Literals
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 引号和字面量
- en: 'One of the most confusing elements of working with the shell and scripts is
    knowing when and why to use quotation marks (quotes) and other punctuation. Let’s
    say you want to print the string `$100` and you do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Shell 和脚本打交道时，最令人困惑的元素之一就是知道什么时候以及为什么使用引号（引用符）和其他标点符号。假设你想打印字符串 `$100`，并且你这样做了：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Why did this print `00`? Because `$1` has a `$` prefix, which the shell interprets
    as a shell variable (we’ll cover these soon). You think to yourself that maybe
    if you surround it with double quotes, the shell will leave the `$1` alone:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它打印了 `00`？因为 `$1` 具有 `$` 前缀，Shell 将其解释为一个 Shell 变量（我们稍后会讲解这些）。你想，也许如果用双引号将它括起来，Shell
    就不会动 `$1` 了：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That still didn’t work. You ask a friend, who says that you need to use single
    quotes instead:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然没有成功。你问朋友，朋友说你应该改用单引号：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why did this particular incantation work?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个特定的命令能成功？
- en: 11.2.1 Literals
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 字面量
- en: When you use quotes, you’re often trying to create a *literal*, a string that
    the shell should not analyze (or try to change) before passing it to the command
    line. In addition to the `$` in the example that you just saw, this often comes
    up when you want to pass a `*` character to a command such as `grep` instead of
    having the shell expand it, and when you need to use a semicolon (`;`) in a command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用引号时，你通常是试图创建一个*字面量*，这是一个 Shell 在传递给命令行之前不应分析（或试图改变）的字符串。除了你刚才看到的示例中的 `$`，当你想要将
    `*` 字符传递给像 `grep` 这样的命令，而不是让 Shell 展开它时，或者当你需要在命令中使用分号（`;`）时，这种情况经常会出现。
- en: 'When writing scripts and working on the command line, remember what happens
    when the shell runs a command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本和使用命令行时，记住当 Shell 运行命令时会发生什么：
- en: Before running the command, the shell looks for variables, globs, and other
    substitutions and performs the substitutions if they appear.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行命令之前，Shell 会查找变量、通配符和其他替换，并在它们出现时执行替换。
- en: The shell passes the results of the substitutions to the command.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shell 将替换结果传递给命令。
- en: 'Problems involving literals can be subtle. Let’s say you’re looking for all
    entries in */etc/passwd* that match the regular expression `r.*t` (that is, a
    line that contains an `r` followed by a `t` later in the line, which would enable
    you to search for usernames such as `root` and `ruth` and `robot`). You can run
    this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及字面量的问题可能会比较微妙。假设你正在查找 */etc/passwd* 中所有匹配正则表达式 `r.*t` 的条目（也就是说，包含 `r` 并且稍后在行中有
    `t` 的行，这样你就能搜索到像 `root`、`ruth` 和 `robot` 这样的用户名）。你可以运行以下命令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It works most of the time, but sometimes it mysteriously fails. Why? The answer
    is probably in your current directory. If that directory contains files with names
    such as *r.input* and *r.output*, then the shell expands `r.*t` to `r.input r.output`
    and creates this command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它大多数时候是有效的，但有时神秘地失败了。为什么？答案可能在你当前的目录中。如果该目录包含名为 *r.input* 和 *r.output* 的文件，那么
    Shell 会将 `r.*t` 展开为 `r.input r.output` 并创建以下命令：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The key to avoiding problems like this is to first recognize the characters
    that can get you in trouble and then apply the correct kind of quotes to protect
    those characters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此类问题的关键是首先识别可能导致问题的字符，然后应用正确类型的引号来保护这些字符。
- en: 11.2.2 Single Quotes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 单引号
- en: 'The easiest way to create a literal and make the shell leave a string alone
    is to enclose the entire string in single quotes (`''`), as in this example with
    `grep` and the `*` character:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字面量并让 Shell 保持字符串不变的最简单方法是将整个字符串用单引号（`'`）括起来，如这个示例中使用 `grep` 和 `*` 字符：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As far as the shell is concerned, all characters between two single quotes,
    including spaces, make up a single parameter. Therefore, the following command
    does *not* work, because it asks the `grep` command to search for the string `r.*t
    /etc/passwd` in the standard input (because there’s only one parameter to `grep`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就 Shell 而言，两个单引号之间的所有字符，包括空格，构成一个单一的参数。因此，以下命令*不*有效，因为它要求 `grep` 命令在标准输入中查找字符串
    `r.*t /etc/passwd`（因为 `grep` 只有一个参数）：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you need to use a literal, you should always turn to single quotes first,
    because you’re guaranteed that the shell won’t try *any* substitutions. As a result,
    it’s a generally clean syntax. However, sometimes you need a little more flexibility,
    so you can turn to double quotes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用字面量时，你应该首先使用单引号，因为这样可以确保 Shell 不会尝试进行*任何*替换。因此，这是一种相对简洁的语法。然而，有时你需要更多的灵活性，这时你可以转而使用双引号。
- en: 11.2.3 Double Quotes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 双引号
- en: Double quotes (`"`) work just like single quotes, except that the shell expands
    any variables that appear within double quotes. You can see the difference by
    running the following command and then replacing the double quotes with single
    quotes and running it again.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号（`"）`的功能与单引号相同，只是 Shell 会展开双引号内的任何变量。你可以通过运行以下命令并将双引号替换为单引号，再次运行来看出区别。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you run the command, notice that the shell substitutes for `$PATH` but
    does not substitute for the `*`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行命令时，注意到 Shell 会替换 `$PATH`，但不会替换 `*`。
- en: 11.2.4 Literal Single Quotes
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 文字单引号
- en: 'Using literals with the Bourne shell can be tricky when you’re passing a literal
    single quote to a command. One way to do this is to place a backslash before the
    single quote character:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个文字单引号给命令时，使用 Bourne shell 可能会很棘手。实现这一点的一种方法是，在单引号字符前加上反斜杠：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The backslash and quote *must* appear outside any pair of single quotes. A
    string such as `''don\''t` results in a syntax error. Oddly enough, you can enclose
    the single quote inside double quotes, as shown in the following example (the
    output is identical to that of the preceding command):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠和引号 *必须* 出现在任何一对单引号外。像 `'don\'t` 这样的字符串会导致语法错误。奇怪的是，你可以将单引号放入双引号中，如以下示例所示（输出与前面的命令相同）：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you’re in a bind and you need a general rule to quote an entire string with
    no substitutions, follow this procedure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你陷入困境并且需要一个通用规则来引用整个字符串而不进行替换，请按照此过程操作：
- en: Change all instances of `'` (single quote) to `'\''` (single quote, backslash,
    single quote, single quote).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有出现的 `'`（单引号）替换为 `'\''`（单引号、反斜杠、单引号、单引号）。
- en: Enclose the entire string in single quotes.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个字符串放入单引号中。
- en: 'Therefore, you can quote an awkward string such as `this isn''t a forward slash:
    \` as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，你可以像下面这样引用一个尴尬的字符串 `this isn''t a forward slash: \`：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 11.3 Special Variables
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 特殊变量
- en: Most shell scripts understand command-line parameters and interact with the
    commands that they run. To take your scripts from being just a simple list of
    commands to becoming more flexible shell script programs, you need to know how
    to use the special Bourne shell variables. These special variables are like any
    other shell variable as described in Section 2.8, except that you can’t change
    the values of certain ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Shell 脚本理解命令行参数，并与它们运行的命令进行交互。为了让你的脚本不仅仅是简单的命令列表，而成为更灵活的 Shell 脚本程序，你需要了解如何使用特殊的
    Bourne shell 变量。这些特殊变量与第 2.8 节中描述的其他 Shell 变量类似，不同之处在于你不能更改某些变量的值。
- en: '11.3.1 Individual Arguments: $1, $2, and So On'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 单个参数：$1，$2，等等
- en: '`$1`, `$2`, and all variables named as positive nonzero integers contain the
    values of the script parameters, or *arguments*. For example, say the name of
    the following script is *pshow*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`$1`、`$2` 和所有命名为正整数的变量包含脚本参数或*参数*的值。例如，假设以下脚本的名称是 *pshow*：'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Try running the script as follows to see how it prints the arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按照以下方式运行脚本，看看它是如何打印参数的：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The built-in shell command `shift` can be used with argument variables to remove
    the first argument (`$1`) and advance the rest of the arguments so that `$2` becomes
    `$1`, `$3` becomes `$2`, and so on. For example, assume that the name of the following
    script is *shiftex*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 Shell 命令 `shift` 可以与参数变量一起使用，移除第一个参数（`$1`）并使其余参数前移，使得 `$2` 成为 `$1`，`$3`
    成为 `$2`，依此类推。例如，假设以下脚本的名称是 *shiftex*：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run it like this to see it work:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的方式运行它来查看它如何工作：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `shiftex` prints all three arguments by printing the first,
    shifting the remaining arguments, and repeating.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`shiftex` 通过打印第一个参数、移动剩余参数并重复该过程，来打印所有三个参数。
- en: '11.3.2 Number of Arguments: $#'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 参数个数：$#
- en: The `$#` variable holds the number of arguments passed to a script and is especially
    important when you’re running `shift` in a loop to pick through arguments. When
    `$#` is `0`, no arguments remain, so `$1` is empty. (See Section 11.6 for a description
    of loops.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`$#` 变量保存传递给脚本的参数数量，在你运行 `shift` 循环以逐个处理参数时特别重要。当 `$#` 为 `0` 时，表示没有参数剩余，因此
    `$1` 为空。（有关循环的描述，请参见第 11.6 节。）'
- en: '11.3.3 All Arguments: $@'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 所有参数：$@
- en: 'The `$@` variable represents all of a script’s arguments and is very useful
    for passing them to a command inside the script. For example, Ghostscript commands
    (`gs`) are usually long and complicated. Suppose you want a shortcut for rasterizing
    a PostScript file at 150 dpi, using the standard output stream, while also leaving
    the door open for passing other options to `gs`. You could write a script like
    this to allow for additional command-line options:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`$@` 变量表示脚本的所有参数，对于将它们传递给脚本内的命令非常有用。例如，Ghostscript 命令（`gs`）通常很长且复杂。假设你想要为以
    150 dpi 的分辨率光栅化 PostScript 文件并使用标准输出流，同时又希望能够传递其他选项给 `gs`。你可以编写这样的脚本来允许添加更多命令行选项：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '11.3.4 Script Name: $0'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 脚本名称：$0
- en: 'The `$0` variable holds the name of the script and is useful for generating
    diagnostic messages. For example, say your script needs to report an invalid argument
    that is stored in the `$BADPARM` variable. You can print the diagnostic message
    with the following line so that the script name appears in the error message:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0` 变量保存脚本的名称，并且在生成诊断信息时非常有用。例如，假设你的脚本需要报告一个存储在 `$BADPARM` 变量中的无效参数。你可以使用以下代码打印诊断信息，以便错误消息中出现脚本名称：'
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All diagnostic error messages should go to the standard error. As explained
    in Section 2.14.1, `2>&1` redirects the standard error to the standard output.
    For writing to the standard error, you can reverse the process with `1>&2`. To
    do this for the preceding example, use this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的诊断错误信息应该输出到标准错误流。如在第 2.14.1 节中所解释，`2>&1` 将标准错误重定向到标准输出。若要写入标准错误流，可以通过 `1>&2`
    反转这一过程。要为上述示例实现此操作，请使用：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '11.3.5 Process ID: $$'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 进程 ID：$$
- en: The `$$` variable holds the process ID of the shell.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`$$` 变量保存了 shell 的进程 ID。'
- en: '11.3.6 Exit Code: $?'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.6 退出代码：$?
- en: The `$?` variable holds the exit code of the last command that the shell executed.
    Exit codes, which are critical to mastering shell scripts, are discussed next.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`$?` 变量保存了 shell 执行的最后一条命令的退出代码。退出代码是掌握 shell 脚本的关键，接下来将讨论这一点。'
- en: 11.4 Exit Codes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 退出代码
- en: When a Unix program finishes, it leaves an *exit code*, a numeric value also
    known as an *error code* or *exit value*, for the parent process that started
    the program. When the exit code is zero (`0`), it typically means that the program
    ran without a problem. However, if the program has an error, it usually exits
    with a number other than `0` (but not always, as you’ll see next).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Unix 程序完成时，它会留下一个*退出代码*，这是一个数值，也称为*错误代码*或*退出值*，供启动该程序的父进程使用。当退出代码为零（`0`）时，通常表示程序没有问题地运行。然而，如果程序出现错误，它通常会以非零数字退出（但并不总是如此，正如你接下来会看到的那样）。
- en: 'The shell holds the exit code of the last command in the `$?` special variable,
    so you can check it out at your shell prompt:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: shell 会将最后一条命令的退出代码保存在 `$?` 特殊变量中，因此你可以在 shell 提示符下查看它：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that the successful command returned `0` and the unsuccessful command
    returned `1` (assuming, of course, that you don’t have a directory named */asdfasdf*
    on your system).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到成功的命令返回了 `0`，而失败的命令返回了 `1`（当然，前提是你的系统中没有名为 */asdfasdf* 的目录）。
- en: If you intend to use a command’s exit code, you *must* use or store that code
    immediately after running the command (because the next command you run overwrites
    the previous code). For example, if you run `echo $?` twice in a row, the output
    of the second command is always `0` because the first `echo` command completes
    successfully.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用一个命令的退出代码，你*必须*在运行命令后立即使用或存储该代码（因为下一个运行的命令会覆盖前一个代码）。例如，如果你连续运行两次 `echo
    $?`，第二条命令的输出总是 `0`，因为第一次 `echo` 命令执行成功。
- en: When writing shell code, you may come across situations where your script needs
    to halt due to an error (such as a bad filename). Use `exit 1` in your script
    to terminate and pass an exit code of `1` back to whatever parent process ran
    the script. (You can use different nonzero numbers if your script has various
    abnormal exit conditions.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 shell 代码时，你可能会遇到需要因为错误（例如错误的文件名）而使脚本停止的情况。可以在脚本中使用 `exit 1` 来终止并将退出代码 `1`
    返回给执行脚本的父进程。（如果你的脚本有不同的异常退出条件，你可以使用不同的非零数字。）
- en: Note that some programs, like `diff` and `grep`, use nonzero exit codes to indicate
    normal conditions. For example, `grep` returns `0` if it finds something matching
    a pattern and `1` if it doesn’t. For these programs, an exit code of `1` is not
    an error, so `grep` and `diff` use the exit code `2` if they encounter an actual
    problem. If you think a program might be using a nonzero exit code to indicate
    success, read its manual page. The exit codes are usually explained in the EXIT
    VALUE or DIAGNOSTICS section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些程序（如`diff`和`grep`）使用非零的退出代码来表示正常情况。例如，如果`grep`找到匹配的模式，它会返回`0`，如果没有找到则返回`1`。对于这些程序，退出代码`1`并不是错误，因此`grep`和`diff`在遇到实际问题时会返回退出代码`2`。如果你认为某个程序可能使用非零退出代码来表示成功，可以阅读该程序的手册页面。退出代码通常会在EXIT
    VALUE或DIAGNOSTICS部分进行说明。
- en: 11.5 Conditionals
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 条件语句
- en: 'The Bourne shell has special constructs for conditionals, including `if`/`then`/`else`
    and `case` statements. For example, this simple script with an `if` conditional
    checks to see whether the script’s first argument is `hi`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne Shell有专门用于条件判断的结构，包括`if`/`then`/`else`和`case`语句。例如，这个包含`if`条件的简单脚本会检查脚本的第一个参数是否为`hi`：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The words `if`, `then`, `else`, and `fi` in the preceding script are shell keywords;
    everything else is a command. This distinction is extremely important because
    it’s easy to mistake the conditional, `[ $1 = "hi" ]`, for special shell syntax.
    In fact, the `[` character is an actual program on a Unix system. All Unix systems
    have a command called `[` that performs tests for shell script conditionals. This
    program is also known as `test`; the manual pages for `test` and `[` are the same.
    (You’ll soon learn that the shell doesn’t always run `[`, but for now you can
    think of it as a separate command.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前述脚本中的`if`、`then`、`else`和`fi`是Shell关键字；其他的则是命令。这一点非常重要，因为很容易将条件表达式`[ $1 = "hi"
    ]`误认为是特殊的Shell语法。实际上，`[`字符是Unix系统中的一个实际程序。所有Unix系统都有一个名为`[`的命令，它用于执行Shell脚本中的条件测试。这个程序也被称为`test`；`test`和`[`的手册页面是一样的。（你很快会学到，Shell并不总是运行`[`，但现在你可以把它当作一个独立的命令来理解。）
- en: 'Here’s where it’s vital to understand the exit codes as explained in Section
    11.4. Let’s look at how the previous script actually works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，理解退出代码的重要性正如第11.4节所解释的那样。让我们看看前一个脚本实际是如何工作的：
- en: The shell runs the command after the `if` keyword and collects the exit code
    of that command.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shell会运行`if`关键字后面的命令，并收集该命令的退出代码。
- en: If the exit code is `0`, the shell executes the commands that follow the `then`
    keyword, stopping when it reaches an `else` or `fi` keyword.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果退出代码是`0`，Shell会执行紧跟在`then`关键字后的命令，直到遇到`else`或`fi`关键字为止。
- en: If the exit code is not `0` and there’s an `else` clause, the shell runs the
    commands after the `else` keyword.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果退出代码不是`0`并且有`else`语句块，Shell会运行`else`关键字后面的命令。
- en: The conditional ends at `fi`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件表达式在`fi`处结束。
- en: 'We’ve established that the test following `if` is a command, so let’s look
    at the semicolon (`;`). It’s just the regular shell marker for the end of a command,
    and it’s there because we put the `then` keyword on the same line. Without the
    semicolon, the shell passes `then` as a parameter to the `[` command, which often
    results in an error that isn’t easy to track. You can avoid the semicolon by placing
    the `then` keyword on a separate line as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了`if`后面的测试是一个命令，那么让我们来看一下分号（`;`）。它只是Shell中用于表示命令结束的常规标记，之所以出现，是因为我们将`then`关键字放在了同一行。如果没有分号，Shell会将`then`作为参数传递给`[`命令，这通常会导致难以追踪的错误。你可以通过将`then`关键字放在单独的行上来避免使用分号，如下所示：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 11.5.1 A Workaround for Empty Parameter Lists
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 空参数列表的解决方法
- en: 'There’s a potential problem with the conditional in the preceding example,
    due to a commonly overlooked scenario: `$1` could be empty, because the user might
    run the script with no parameters. If `$1` is empty, the test reads `[ = hi ]`,
    and the `[` command will abort with an error. You can fix this by enclosing the
    parameter in quotes in one of two common ways:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，条件语句可能存在一个潜在问题，这是一个常被忽视的情景：`$1`可能为空，因为用户可能没有传递任何参数来运行脚本。如果`$1`为空，测试就变成了`[
    = hi ]`，此时`[`命令会因错误而中止。你可以通过以下两种常见方式之一，将参数用引号括起来来修复这个问题：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 11.5.2 Other Commands for Tests
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 其他测试命令
- en: 'There are many possibilities for using commands other than `[` for tests. Here’s
    an example that uses `grep`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`[`，还有许多其他命令可以用于条件测试。这里有一个使用`grep`的示例：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 11.5.3 elif
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 elif
- en: 'There is also an `elif` keyword that lets you string `if` conditionals together,
    as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`elif`关键字，它可以将多个`if`条件语句连接起来，如下所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Keep in mind that the control flows only through the first successful conditional,
    so if you run this script with the arguments `hi bye`, you’ll only get confirmation
    of the `hi` argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，控制流只会通过第一个成功的条件，因此，如果你使用`hi bye`作为参数运行此脚本，你将只得到`hi`参数的确认。
- en: 11.5.4 Logical Constructs
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.4 逻辑构造
- en: 'There are two quick, one-line conditional constructs that you may see from
    time to time, using the `&&` (“and”) and `||` (“or”) syntax. The `&&` construct
    works like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种快速的一行条件构造，你可能时不时会看到，使用`&&`（"与"）和`||`（"或"）语法。`&&`构造如下工作：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the shell runs `command1`, and if the exit code is `0`, the shell also
    runs `command2`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，shell运行`command1`，如果退出代码为`0`，shell还会运行`command2`。
- en: The `||` construct is similar; if the command before a `||` returns a nonzero
    exit code, the shell runs the second command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`||`构造类似；如果`||`前的命令返回非零退出代码，shell将运行第二个命令。'
- en: The constructs `&&` and `||` are often used in `if` tests, and in both cases,
    the exit code of the last command run determines how the shell processes the conditional.
    In the case of the `&&` construct, if the first command fails, the shell uses
    its exit code for the `if` statement, but if the first command succeeds, the shell
    uses the exit code of the second command for the conditional. In the case of the
    `||` construct, the shell uses the exit code of the first command if successful,
    or the exit code of the second if the first is unsuccessful.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`构造通常用于`if`测试，在这两种情况下，最后运行的命令的退出代码决定了shell如何处理条件。在`&&`构造的情况下，如果第一个命令失败，shell将使用它的退出代码作为`if`语句，但如果第一个命令成功，shell将使用第二个命令的退出代码作为条件。在`||`构造的情况下，如果第一个命令成功，shell使用第一个命令的退出代码，否则如果第一个命令失败，则使用第二个命令的退出代码。'
- en: 'For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If your conditionals include the test command (`[`), as shown here, you can
    use `-a` and `-o` instead of `&&` and `||`, for example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的条件语句中包含测试命令（`[`），如这里所示，你可以使用`-a`和`-o`来代替`&&`和`||`，例如：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can invert a test (that is, a logical not) by placing the `!` operator
    before a test. For example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在测试前放置`!`运算符来反转测试（即逻辑非）。例如：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this specific case of comparisons, you might see `!=` used as an alternative,
    but `!` can be used with any of the condition tests described in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定的比较情况下，你可能会看到`!=`作为一种替代方法，但`!`可以与接下来章节中描述的任何条件测试一起使用。
- en: 11.5.5 Testing Conditions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.5 条件测试
- en: 'You’ve seen how `[` works: the exit code is `0` if the test is true and nonzero
    when the test fails. You also know how to test string equality with `[` `str1`
    `=` `str2` `]`. However, remember that shell scripts are well suited to operations
    on entire files because many useful `[` tests involve file properties. For example,
    the following line checks whether `file` is a regular file (not a directory or
    special file):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了`[`的工作原理：如果测试为真，退出代码为`0`，如果测试失败，则退出代码为非零。你也知道如何使用`[` `str1` `=` `str2`
    `]`来测试字符串相等性。然而，请记住，shell脚本非常适合对整个文件进行操作，因为许多有用的`[`测试涉及文件属性。例如，以下行检查`file`是否为常规文件（不是目录或特殊文件）：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In a script, you might see the `-f` test in a loop similar to this one, which
    tests all of the items in the current working directory (you’ll learn more about
    loops in Section 11.6):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，你可能会看到`-f`测试出现在类似于此的循环中，它测试当前工作目录中的所有项目（你将在11.6节中学到更多关于循环的内容）：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are dozens of test operations, all of which fall into three general categories:
    file tests, string tests, and arithmetic tests. The info manual contains complete
    online documentation, but the test(1) manual page is a fast reference. The following
    sections outline the main tests. (I’ve omitted some of the less common ones.)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种测试操作，所有操作都可归为三大类：文件测试、字符串测试和算术测试。info手册包含完整的在线文档，但test(1)手册页是快速参考。以下部分概述了主要的测试。（我省略了一些不太常见的测试。）
- en: File Tests
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件测试
- en: 'Most file tests, like `-f`, are called *unary* operations because they require
    only one argument: the file to test. For example, here are two important file
    tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文件测试，如`-f`，被称为*一元*操作，因为它们只需要一个参数：要测试的文件。例如，以下是两个重要的文件测试：
- en: '`-e` Returns true if a file exists'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-e` 如果文件存在，则返回true'
- en: '`-s` Returns true if a file is not empty'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-s` 如果文件不为空，则返回true'
- en: Several operations inspect a file’s type, meaning that they can determine whether
    something is a regular file, a directory, or some kind of special device, as listed
    in [Table 11-1](#table11-1). There are also a number of unary operations that
    check a file’s permissions, as listed in [Table 11-2](#table11-2). (See Section
    2.17 for an overview of permissions.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作符检查文件类型，这意味着它们可以确定某个文件是否为常规文件、目录或某种特殊设备，如 [表 11-1](#table11-1) 所列。此外，还有一些单目操作符检查文件的权限，如
    [表 11-2](#table11-2) 所列。（有关权限的概述，请参见第 2.17 节。）
- en: 'Table 11-1: File Type Operators'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1：文件类型操作符
- en: '| **Operator** | **Tests for** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **测试条件** |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-f` | Regular file |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `-f` | 常规文件 |'
- en: '| `-d` | Directory |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 目录 |'
- en: '| `-h` | Symbolic link |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `-h` | 符号链接 |'
- en: '| `-b` | Block device |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `-b` | 块设备 |'
- en: '| `-c` | Character device |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `-c` | 字符设备 |'
- en: '| `-p` | Named pipe |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | 命名管道 |'
- en: '| `-S` | Socket |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `-S` | 套接字 |'
- en: 'Table 11-2: File Permissions Operators'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-2：文件权限操作符
- en: '| **Operator** | **Permission** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **权限** |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-r` | Readable |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 可读 |'
- en: '| `-w` | Writable |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `-w` | 可写 |'
- en: '| `-x` | Executable |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `-x` | 可执行 |'
- en: '| `-u` | Setuid |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 设置 UID |'
- en: '| `-g` | Setgid |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `-g` | 设置 GID |'
- en: '| `-k` | “Sticky” |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `-k` | “粘滞” |'
- en: 'Finally, three *binary* operators (tests that need two files as arguments)
    are used in file tests, but they’re not terribly common. Consider this command,
    which includes `-nt` (“newer than”):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，三个*二进制*操作符（需要两个文件作为参数的测试）用于文件测试，但它们并不常见。考虑以下命令，它包括 `-nt`（“比...新”）：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This exits true if `file1` has a newer modification date than `file2`. The `-ot`
    (“older than”) operator does the opposite. And if you need to detect identical
    hard links, `-ef` compares two files and returns true if they share inode numbers
    and devices.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `file1` 的修改日期比 `file2` 新，则此命令返回 true。`-ot`（“比...旧”）操作符则执行相反的操作。如果你需要检测相同的硬链接，`-ef`
    会比较两个文件，如果它们共享 inode 编号和设备，则返回 true。
- en: String Tests
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串测试
- en: 'You’ve seen the binary string operator `=`, which returns true if its operands
    are equal, and the `!=` operator that returns true if its operands are not equal.
    There are two additional unary string operations:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过二进制字符串操作符 `=`，它在操作数相等时返回 true，和 `!=` 操作符，它在操作数不相等时返回 true。还有两个额外的单目字符串操作：
- en: '`-z` Returns true if its argument is empty (`[ -z "" ]` returns `0`)'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-z` 如果参数为空则返回 true（`[ -z "" ]` 返回 `0`）'
- en: '`-n` Returns true if its argument is not empty (`[ -n "" ]` returns `1`)'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-n` 如果参数不为空则返回 true（`[ -n "" ]` 返回 `1`）'
- en: Arithmetic Tests
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术测试
- en: 'Note that the equal sign (`=`) looks for *string* equality, not *numeric* equality.
    Therefore, `[ 1 = 1 ]` returns `0` (true), but `[ 01 = 1 ]` returns false. When
    working with numbers, use `-eq` instead of the equal sign: `[ 01 -eq 1 ]` returns
    true. [Table 11-3](#table11-3) provides the full list of numeric comparison operators.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，等号（`=`）用于检查*字符串*相等，而非*数值*相等。因此，`[ 1 = 1 ]` 返回 `0`（真），但 `[ 01 = 1 ]` 返回 false。处理数字时，使用
    `-eq` 而非等号：`[ 01 -eq 1 ]` 返回 true。[表 11-3](#table11-3) 提供了完整的数值比较操作符列表。
- en: 'Table 11-3: Arithmetic Comparison Operators'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3：算术比较操作符
- en: '| **Operator** | **Returns true when the first argument is ___________ the
    second** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **当第一个参数是 ___________ 第二个时返回 true** |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-eq` | equal to |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `-eq` | 等于 |'
- en: '| `-ne` | not equal to |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `-ne` | 不等于 |'
- en: '| `-lt` | less than |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `-lt` | 小于 |'
- en: '| `-gt` | greater than |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `-gt` | 大于 |'
- en: '| `-le` | less than or equal to |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `-le` | 小于或等于 |'
- en: '| `-ge` | greater than or equal to |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `-ge` | 大于或等于 |'
- en: 11.5.6 case
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.6 case
- en: 'The `case` keyword forms another conditional construct that is exceptionally
    useful for matching strings. It does not execute any test commands and therefore
    does not evaluate exit codes. However, it can do pattern matching. This example
    tells most of the story:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 关键字形成另一种条件构造，非常适用于匹配字符串。它不会执行任何测试命令，因此不会评估退出码。然而，它可以进行模式匹配。这个示例讲述了大部分内容：'
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The shell executes this as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 执行如下：
- en: The script matches `$1` against each case value demarcated with the `)` character.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本将 `$1` 与每个用 `)` 字符标记的 case 值进行匹配。
- en: If a case value matches `$1`, the shell executes the commands below the case
    until it encounters `;;`, at which point it skips to the `esac` keyword.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 case 的值匹配 `$1`，shell 会执行 case 下面的命令，直到遇到 `;;`，此时它会跳到 `esac` 关键字。
- en: The conditional ends with `esac`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件语句以 `esac` 结束。
- en: For each case value, you can match a single string (like `bye` in the preceding
    example) or multiple strings with `|` (`hi|hello` returns true if `$1` equals
    `hi` or `hello`), or you can use the `*` or `?` patterns (`what*`). To make a
    default case that catches all possible values other than the case values specified,
    use a single `*` as shown by the final case in the preceding example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个情况值，你可以匹配单个字符串（比如前面的示例中的 `bye`）或使用 `|` 匹配多个字符串（`hi|hello` 当 `$1` 等于 `hi`
    或 `hello` 时返回真），或者你可以使用 `*` 或 `?` 模式（`what*`）。要创建一个默认情况来匹配除指定的情况值之外的所有值，可以使用一个单独的
    `*`，如前面示例中的最后一个情况所示。
- en: 11.6 Loops
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 循环
- en: 'There are two kinds of loops in the Bourne shell: `for` and `while` loops.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne shell 中有两种循环：`for` 循环和 `while` 循环。
- en: 11.6.1 for Loops
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.1 for 循环
- en: 'The `for` loop (which is a “for each” loop) is the most common. Here’s an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环（也叫做“for each”循环）是最常见的。以下是一个示例：'
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this listing, `for`, `in`, `do`, and `done` are all shell keywords. The
    shell does the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，`for`、`in`、`do` 和 `done` 都是 shell 关键字。Shell 执行以下操作：
- en: Sets the variable `str` to the first of the four space-delimited values following
    the `in` keyword (`one`).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量 `str` 设置为 `in` 关键字后面四个以空格分隔的值中的第一个值（`one`）。
- en: Runs the `echo` command between the `do` and `done`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `do` 和 `done` 之间运行 `echo` 命令。
- en: Goes back to the `for` line, setting `str` to the next value (`two`), runs the
    commands between `do` and `done`, and repeats the process until it’s through with
    the values following the `in` keyword.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `for` 行，将 `str` 设置为下一个值（`two`），执行 `do` 和 `done` 之间的命令，并重复这个过程，直到它完成 `in`
    关键字后面的所有值。
- en: 'The output of this script looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的输出如下所示：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 11.6.2 while Loops
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.2 while 循环
- en: 'The Bourne shell’s `while` loop uses exit codes, like the `if` conditional.
    For example, this script does 10 iterations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne shell 的 `while` 循环使用退出码，就像 `if` 条件语句一样。例如，以下脚本执行 10 次迭代：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the exit code of `grep -q firstline` is the test. As soon as the exit
    code is nonzero (in this case, when the string `firstline` no longer appears in
    the last 10 lines in `$FILE`), the loop exits.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`grep -q firstline` 的退出码就是测试条件。只要退出码为非零（在本例中，当字符串 `firstline` 不再出现在 `$FILE`
    的最后 10 行中时），循环就会退出。
- en: You can break out of a `while` loop with the `break` statement. The Bourne shell
    also has an `until` loop that works just like `while`, except that it breaks the
    loop when it encounters a zero exit code rather than a nonzero exit code. This
    said, you shouldn’t need to use the `while` and `until` loops very often. In fact,
    if you find that you need to use `while`, you should probably be using a language
    more appropriate to your task, such as Python or `awk`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `break` 语句跳出 `while` 循环。Bourne shell 还有一个 `until` 循环，作用与 `while` 类似，不同之处在于，当遇到退出码为零时，它会终止循环，而不是遇到非零退出码。也就是说，你不需要经常使用
    `while` 和 `until` 循环。事实上，如果你发现需要使用 `while`，你可能应该使用一个更适合你任务的语言，如 Python 或 `awk`。
- en: 11.7 Command Substitution
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 命令替换
- en: The Bourne shell can redirect a command’s standard output back to the shell’s
    own command line. That is, you can use a command’s output as an argument to another
    command, or you can store the command output in a shell variable by enclosing
    a command in `$()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Bourne shell 可以将命令的标准输出重定向回 shell 自身的命令行。也就是说，你可以将命令的输出作为另一个命令的参数，或者通过将命令包裹在
    `$()` 中，将命令输出存储在 shell 变量中。
- en: This example stores a command’s output inside the `FLAGS` variable. The bold
    code in the second line shows the command substitution.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将命令的输出存储在 `FLAGS` 变量中。第二行中的粗体代码展示了命令替换。
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example is somewhat complicated because it demonstrates that you can use
    both single quotes and pipelines inside the command substitution. The result of
    the `grep` command is sent to the `sed` command (more about `sed` in Section 11.10.3),
    which removes anything matching the expression `.*:`, and the result of `sed`
    is passed to `head`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有些复杂，因为它展示了你可以在命令替换中使用单引号和管道符。`grep` 命令的结果被传递给 `sed` 命令（关于 `sed` 的更多内容请参见第
    11.10.3 节），`sed` 去除所有与表达式 `.*:` 匹配的内容，`sed` 的结果再传递给 `head`。
- en: It’s easy to go overboard with command substitution. For example, don’t use
    `$(ls)` in a script, because using the shell to expand `*` is faster. Also, if
    you want to invoke a command on several filenames that you get as a result of
    a `find` command, consider using a pipeline to `xargs` rather than command substitution,
    or use the `-exec` option (both are discussed in Section 11.10.4).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令替换时很容易过度使用。例如，不要在脚本中使用`$(ls)`，因为使用 shell 来扩展 `*` 更快。此外，如果你想对多个通过 `find`
    命令获得的文件名执行命令，考虑使用管道将其传递给 `xargs`，而不是命令替换，或者使用 `-exec` 选项（这两种方法都将在 11.10.4 节中讨论）。
- en: 11.8 Temporary File Management
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 临时文件管理
- en: It’s sometimes necessary to create a temporary file to collect output for use
    by a later command. When creating such a file, make sure that the filename is
    distinct enough that no other programs will accidentally write to it. Sometimes
    using something as simple as the shell’s PID (`$$`) in a filename works, but when
    you need to be certain that there will be no conflicts, a utility such as `mktemp`
    is often a better option.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要创建一个临时文件来收集输出，以便后续命令使用。创建这样的文件时，确保文件名足够独特，以免其他程序意外地写入此文件。有时，使用简单的 shell
    PID（`$$`）作为文件名就能实现，但当你需要确保没有冲突时，像 `mktemp` 这样的工具通常是更好的选择。
- en: 'Here’s how to use the `mktemp` command to create temporary filenames. This
    script shows you the device interrupts that have occurred in the last two seconds:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `mktemp` 命令创建临时文件名的方法。这个脚本显示了过去两秒内发生的设备中断：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The argument to `mktemp` is a template. The `mktemp` command converts the `XXXXXX`
    to a unique set of characters and creates an empty file with that name. Notice
    that this script uses variable names to store the filenames so that you only have
    to change one line if you want to change a filename.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`mktemp` 的参数是一个模板。`mktemp` 命令将 `XXXXXX` 转换为一组唯一的字符，并使用该名称创建一个空文件。请注意，这个脚本使用变量名来存储文件名，这样如果你想更改文件名，只需更改一行即可。'
- en: 'A common problem with scripts that employ temporary files is that if the script
    is aborted, the temporary files could be left behind. In the preceding example,
    pressing ctrl-C before the second `cat` command leaves a temporary file in */tmp*.
    Avoid this if possible. Instead, use the `trap` command to create a signal handler
    to catch the signal that ctrl-C generates and remove the temporary files, as in
    this handler:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时文件的脚本中常见的问题是，如果脚本被中止，临时文件可能会被遗留。在前面的例子中，在第二个 `cat` 命令之前按下 ctrl-C 会将临时文件留在
    */tmp* 中。尽可能避免这种情况。相反，使用 `trap` 命令创建一个信号处理器，捕获 ctrl-C 生成的信号并删除临时文件，如以下处理器所示：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You must use `exit` in the handler to explicitly end script execution, or the
    shell will continue running as usual after running the signal handler.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在处理器中使用 `exit` 来显式结束脚本执行，否则 shell 在运行信号处理器后会继续照常运行。
- en: 11.9 Here Documents
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9 Here Documents
- en: 'Say you want to print a large section of text or feed a lot of text to another
    command. Rather than using several `echo` commands, you can use the shell’s *here
    document* feature, as shown in the following script:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想打印一大段文本或将大量文本传递给另一个命令。与其使用多个`echo`命令，你可以使用 shell 的 *here document* 特性，如以下脚本所示：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The items in bold control the here document. `<<EOF` tells the shell to redirect
    all subsequent lines to the standard input of the command that precedes `<<EOF`,
    which in this case is `cat`. The redirection stops as soon as the `EOF` marker
    occurs on a line by itself. The marker can actually be any string, but remember
    to use the same marker at the beginning and end of the here document. Also, convention
    dictates that the marker be in all uppercase letters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分控制着 here document。`<<EOF` 告诉 shell 将随后的所有行重定向到 `<<EOF` 前面的命令的标准输入中，在这个例子中是
    `cat`。重定向会在 `EOF` 标记单独出现在一行时停止。该标记实际上可以是任何字符串，但请记住，在 here document 的开始和结束使用相同的标记。另外，惯例是标记应使用全大写字母。
- en: Notice the shell variable `$DATE` in the here document. The shell expands shell
    variables inside here documents, which is especially useful when you’re printing
    out reports that contain many variables.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 here document 中的 shell 变量 `$DATE`。shell 会在 here document 中扩展 shell 变量，这在你打印包含多个变量的报告时尤其有用。
- en: 11.10 Important Shell Script Utilities
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 重要的 Shell 脚本工具
- en: Several programs are particularly useful in shell scripts. Certain utilities,
    such as `basename`, are really only practical when used with other programs, and
    therefore don’t often find a place outside shell scripts. However, others, such
    as `awk`, can be quite useful on the command line, too.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shell脚本中，有几个程序特别有用。某些工具，如`basename`，只有与其他程序一起使用时才实际有效，因此不常在Shell脚本外找到应用。然而，像`awk`这样的程序也可以在命令行上非常有用。
- en: 11.10.1  basename
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.1  basename
- en: 'If you need to strip the extension from a filename or get rid of the directories
    in a full pathname, use the `basename` command. Try these examples on the command
    line to see how the command works:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要去除文件名的扩展名或去掉完整路径名中的目录部分，请使用`basename`命令。尝试在命令行中运行这些示例，看看命令是如何工作的：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In both cases, `basename` returns `example`. The first command strips the *.html*
    suffix from *example.html*, and the second removes the directories from the full
    pathname.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`basename`都会返回`example`。第一个命令去除了*example.html*的*.html*后缀，第二个命令则从完整路径名中去除了目录部分。
- en: 'This example shows how you can use `basename` in a script to convert GIF image
    files to the PNG format:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何在脚本中使用`basename`将GIF图像文件转换为PNG格式：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 11.10.2  awk
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.2  awk
- en: The `awk` command is not a simple single-purpose command; it’s actually a powerful
    programming language. Unfortunately, `awk` usage is now something of a lost art,
    having been replaced by larger languages such as Python.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令不是一个简单的单用途命令；它实际上是一种强大的编程语言。不幸的是，`awk`的使用如今已经成为一种失传的技艺，被像Python这样的大型语言所取代。'
- en: 'There are entire books on the subject of `awk`, including *The AWK Programming
    Language* by Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger (Addison-Wesley,
    1988). This said, many, many people use `awk` only to do one thing—to pick a single
    field out of an input stream like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`awk`的书籍有很多，包括阿尔弗雷德·V·阿霍（Alfred V. Aho）、布赖恩·W·科尼根（Brian W. Kernighan）和彼得·J·温伯格（Peter
    J. Weinberger）所著的*The AWK Programming Language*（1988年，Addison-Wesley）。不过，很多人仅仅用`awk`来做一件事——从输入流中提取单个字段，像这样：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This command prints the fifth field of the `ls` output (the file size). The
    result is a list of file sizes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令打印`ls`输出中的第五个字段（文件大小）。结果是一个文件大小的列表。
- en: 11.10.3  sed
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.3  sed
- en: The `sed` (“stream editor”) program is an automatic text editor that takes an
    input stream (a file or the standard input), alters it according to some expression,
    and prints the results to standard output. In many respects, `sed` is like `ed`,
    the original Unix text editor. It has dozens of operations, matching tools, and
    addressing capabilities. As with `awk`, entire books have been written about `sed`,
    including a quick reference covering both, *sed & awk Pocket Reference*, 2nd edition,
    by Arnold Robbins (O’Reilly, 2002).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`（“流编辑器”）程序是一个自动文本编辑器，它接受一个输入流（一个文件或标准输入），根据某些表达式对其进行修改，并将结果输出到标准输出。在很多方面，`sed`像是原始的Unix文本编辑器`ed`。它有数十种操作、匹配工具和寻址功能。与`awk`类似，关于`sed`的书籍也有很多，包括一本快速参考书，*sed
    & awk Pocket Reference*（第二版，Arnold Robbins，O’Reilly，2002年）。'
- en: Although `sed` is a big program and an in-depth analysis is beyond the scope
    of this book, it’s easy to see how it works. In general, `sed` takes an address
    and an operation as one argument. The address is a set of lines, and the command
    determines what to do with the lines.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`sed`是一个大型程序，且深入分析超出了本书的范围，但我们很容易看出它是如何工作的。一般来说，`sed`接受一个地址和一个操作作为参数。地址是一组行，命令则决定如何处理这些行。
- en: 'A very common task for `sed` is to substitute some text for a regular expression
    (see Section 2.5.1), like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`的一个非常常见的任务是用正则表达式替换某些文本（参见第2.5.1节），像这样：'
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you wanted to replace the first colon in each line of */etc/passwd* with
    a `%` and send the result to the standard output, then, you’d do it like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将每行中的第一个冒号替换为`%`并将结果发送到标准输出，你可以这样做：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To substitute *all* colons in */etc/passwd*, add the `g` (global) modifier
    to the end of the operation, like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换*/etc/passwd*中的*所有*冒号，可以在操作末尾添加`g`（全局）修饰符，像这样：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s a command that operates on a per-line basis; it reads */etc/passwd*,
    deletes lines three through six, and sends the result to the standard output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个按行操作的命令；它读取*/etc/passwd*，删除第三行到第六行，并将结果输出到标准输出：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, `3,6` is the address (a range of lines), and `d` is the operation
    (delete). If you omit the address, `sed` operates on all lines in its input stream.
    The two most common `sed` operations are probably `s` (search and replace) and
    `d`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`3,6` 是地址（行号范围），而 `d` 是操作（删除）。如果省略地址，`sed` 将作用于其输入流中的所有行。最常用的两个 `sed`
    操作可能是 `s`（搜索和替换）和 `d`。
- en: 'You can also use a regular expression as the address. This command deletes
    any line that matches the regular expression `exp`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用正则表达式作为地址。此命令删除与正则表达式 `exp` 匹配的任何行：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In all of these examples, `sed` writes to the standard output, and this is by
    far the most common usage. With no file arguments, `sed` reads from the standard
    input, a pattern that you’ll frequently encounter in shell pipelines.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些示例中，`sed` 写入标准输出，这是最常见的用法。如果没有文件参数，`sed` 会从标准输入读取，这种模式你在 Shell 管道中经常会遇到。
- en: 11.10.4  xargs
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.4  xargs
- en: When you have to run one command on a huge number of files, the command or shell
    may respond that it can’t fit all of the arguments in its buffer. Use `xargs`
    to get around this problem by running a command on each filename in its standard
    input stream.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须对大量文件执行一个命令时，命令或 Shell 可能会提示无法将所有参数放入其缓冲区。使用 `xargs` 可以解决这个问题，它通过对标准输入流中的每个文件名执行命令来绕过这个限制。
- en: 'Many people use `xargs` with the `find` command. For example, the following
    script can help you verify that every file in the current directory tree that
    ends with *.gif* is actually a GIF image:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将 `xargs` 与 `find` 命令一起使用。例如，以下脚本可以帮助你验证当前目录树中每个以 *.gif* 结尾的文件是否确实是 GIF 图像：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, `xargs` runs the `file` command. However, this invocation can cause errors
    or leave your system open to security problems, because filenames can include
    spaces and newlines. When writing a script, use the following form instead, which
    changes the `find` output separator and the `xargs` argument delimiter from a
    newline to a NULL character:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`xargs` 运行 `file` 命令。然而，这种调用可能会导致错误或使系统面临安全问题，因为文件名中可能包含空格和换行符。编写脚本时，请使用以下形式，该形式将
    `find` 输出的分隔符和 `xargs` 参数分隔符从换行符改为 NULL 字符：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`xargs` starts a *lot* of processes, so don’t expect great performance if you
    have a large list of files.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs` 启动了*大量*进程，因此，如果你有一个很大的文件列表，别指望能得到很好的性能。'
- en: You may need to add two dashes (`--`) to the end of your `xargs` command if
    there’s a chance that any of the target files start with a single dash (`-`).
    The double dash (`--`) tells a program that any arguments that follow are filenames,
    not options. However, keep in mind that not all programs support the use of a
    double dash.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标文件名可能以单个短横线（`-`）开头，你可能需要在 `xargs` 命令的末尾添加两个短横线（`--`）。双短横线（`--`）告诉程序，后续的任何参数都是文件名，而不是选项。然而，请记住，并非所有程序都支持双短横线。
- en: 'When you’re using `find`, there’s an alternative to `xargs`: the `-exec` option.
    However, the syntax is somewhat tricky because you need to supply braces, `{}`,
    to substitute the filename and a literal `;` to indicate the end of the command.
    Here’s how to perform the preceding task using only `find`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `find` 时，有一个替代方案是 `xargs`：`-exec` 选项。然而，语法有些复杂，因为你需要提供大括号 `{}` 来替代文件名，并且使用字面量的
    `;` 来表示命令的结束。以下是仅使用 `find` 完成前述任务的方法：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 11.10.5  expr
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.5  expr
- en: If you need to use arithmetic operations in your shell scripts, the `expr` command
    can help (and even do some string operations). For example, the command `expr
    1 + 2` prints `3`. (Run `expr --help` for a full list of operations.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 Shell 脚本中使用算术运算，`expr` 命令可以提供帮助（甚至能做一些字符串操作）。例如，命令 `expr 1 + 2` 会输出 `3`。（运行
    `expr --help` 获取完整的操作列表。）
- en: The `expr` command is a clumsy, slow way of doing math. If you find yourself
    using it frequently, you should probably be using a language like Python instead
    of a shell script.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr` 命令是一个笨拙且缓慢的数学运算方法。如果你发现自己经常使用它，可能应该使用像 Python 这样的语言，而不是 Shell 脚本。'
- en: 11.10.6  exec
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.10.6  exec
- en: The `exec` command is a built-in shell feature that replaces the current shell
    process with the program you name after `exec`. It carries out the `exec()` system
    call described in Chapter 1. This feature is designed for saving system resources,
    but remember that there’s no return; when you run `exec` in a shell script, the
    script and shell running the script are gone, replaced by the new command.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 命令是一个内建的 Shell 功能，它将当前的 Shell 进程替换为你在 `exec` 后指定的程序。它执行了第 1 章中描述的 `exec()`
    系统调用。这个功能是为了节省系统资源，但请记住，执行 `exec` 后没有返回；当你在脚本中运行 `exec` 时，脚本和运行脚本的 Shell 都会被新的命令替代。'
- en: To test this in a shell window, try running `exec cat`. After you press ctrl-D
    or ctrl-C to terminate the `cat` program, your window should disappear because
    its child process no longer exists.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Shell窗口中测试这个，试着运行`exec cat`。当你按ctrl-D或ctrl-C终止`cat`程序后，窗口应该会消失，因为它的子进程已经不存在了。
- en: 11.11 Subshells
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11 子Shell
- en: Say you need to alter the environment in a shell slightly but don’t want a permanent
    change. You can change and restore a part of the environment (such as the path
    or working directory) using shell variables, but that’s a clumsy way to go about
    things. The simpler option is to use a *subshell*, an entirely new shell process
    that you can create just to run a command or two. The new shell has a copy of
    the original shell’s environment, and when the new shell exits, any changes you
    made to its shell environment disappear, leaving the initial shell to run as normal.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要稍微改变Shell中的环境，但不希望进行永久更改。你可以使用Shell变量改变并恢复环境的一部分（例如路径或工作目录），但这是一种笨重的方法。更简单的选择是使用*子Shell*，一个全新的Shell进程，你可以创建它来运行一两个命令。新Shell有一个原Shell环境的副本，当新Shell退出时，你对其环境所做的任何更改都会消失，初始的Shell将正常运行。
- en: 'To use a subshell, put the commands to be executed by the subshell in parentheses.
    For example, the following line executes the command `uglyprogram` while in *uglydir*
    and leaves the original shell intact:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子Shell时，将要由子Shell执行的命令放在括号中。例如，以下这一行将在*uglydir*中执行`uglyprogram`命令，同时保持原Shell不变：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This example shows how to add a component to the path that might cause problems
    as a permanent change:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何将一个组件添加到路径中，这可能作为永久更改引发问题：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using a subshell to make a single-use alteration to an environment variable
    is such a common task that there’s even a built-in syntax that avoids the subshell:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子Shell对环境变量进行一次性更改是非常常见的任务，甚至有一个内置语法可以避免使用子Shell：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Pipes and background processes work with subshells, too. The following example
    uses `tar` to archive the entire directory tree within *orig* and then unpacks
    the archive into the new directory *target*, which effectively duplicates the
    files and folders in *orig* (this is useful because it preserves ownership and
    permissions, and it’s generally faster than using a command such as `cp -r`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和后台进程也可以与子Shell一起工作。以下示例使用`tar`来归档*orig*中的整个目录树，然后将归档文件解压到新目录*target*中，从而有效地复制*orig*中的文件和文件夹（这很有用，因为它保留了所有权和权限，并且通常比使用如`cp
    -r`等命令更快）：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 11.12 Including Other Files in Scripts
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.12 包含其他文件到脚本中
- en: 'If you need to include code from another file in your shell script, use the
    dot (`.`) operator. For example, this runs the commands in the file *config.sh*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在Shell脚本中包含来自另一个文件的代码，使用点（`.`）操作符。例如，这会执行*config.sh*文件中的命令：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This method of inclusion is also called *sourcing* a file and is useful for
    reading variables (for example, in a shared configuration file) and other kinds
    of definitions. This is not the same as executing another script; when you run
    a script (as a command), it starts in a new shell, and you can’t get anything
    back other than the output and the exit code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包含方法也称为*源文件*，它在读取变量（例如，在共享配置文件中）和其他类型的定义时非常有用。这不同于执行另一个脚本；当你运行一个脚本（作为命令）时，它会在一个新的Shell中启动，除了输出和退出代码，你无法获取其他任何东西。
- en: 11.13 Reading User Input
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.13 读取用户输入
- en: 'The `read` command reads a line of text from the standard input and stores
    the text in a variable. For example, the following command stores the input in
    `$``var`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`命令从标准输入中读取一行文本，并将文本存储在一个变量中。例如，以下命令将输入存储在`$var`中：'
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This built-in shell command can be useful in conjunction with other shell features
    not mentioned in this book. With `read`, you can create simple interactions, such
    as prompting a user to enter input instead of requiring them to list everything
    on the command line, and build “Are you sure?” confirmations preceding dangerous
    operations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内置的Shell命令与书中未提到的其他Shell特性一起使用时非常有用。通过`read`，你可以创建简单的交互，例如提示用户输入，而不是要求他们在命令行中列出所有内容，并构建“你确定吗？”的确认操作，作为危险操作的前置步骤。
- en: 11.14 When (Not) to Use Shell Scripts
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.14 何时（不）使用Shell脚本
- en: The shell is so feature-rich that it’s difficult to condense its important elements
    into a single chapter. If you’re interested in what else the shell can do, have
    a look at some of the books on shell programming, such as *Unix Shell* Programming,
    3rd edition, by Stephen G. Kochan and Patrick Wood (SAMS Publishing, 2003), or
    the shell script discussion in *The UNIX Programming Environment* by Brian W.
    Kernighan and Rob Pike (Prentice Hall, 1984).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 功能如此丰富，以至于很难将其重要元素浓缩到单一章节。如果你对 shell 还能做什么感兴趣，可以看看一些关于 shell 编程的书籍，比如
    Stephen G. Kochan 和 Patrick Wood 合著的《*Unix Shell* 编程》第三版（SAMS 出版社，2003年），或 Brian
    W. Kernighan 和 Rob Pike 合著的《*UNIX 编程环境*》（Prentice Hall，1984年）中的 shell 脚本讨论。
- en: 'However, at a certain point (especially when you start to overuse the `read`
    built-in), you have to ask yourself if you’re still using the right tool for the
    job. Remember what shell scripts do best: manipulate simple files and commands.
    As stated earlier, if you find yourself writing something that looks convoluted,
    especially if it involves complicated string or arithmetic operations, don’t be
    afraid to look to a scripting language like Python, Perl, or `awk`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某个时刻（特别是当你开始过度使用`read`内置命令时），你必须问问自己，是否仍然使用适合该任务的工具。记住，shell 脚本最擅长的事情是：操作简单的文件和命令。正如前面所说，如果你发现自己写的东西看起来复杂，尤其是涉及到复杂的字符串或算术操作时，不要害怕转向像
    Python、Perl 或 `awk` 这样的脚本语言。
